[{"content":"多线程：一个程序里面的不同的执行路径 一个时间点上其实只有一个线程在执行，只不过，速度很快，看起来像几个线程同时执行。 有两种方法 ： 继承 Thred类，或者实现runnable借口。 优先级：setPriority(Thred. NORM_PRIORITY+3) ; Java线程的优先级是一个整数，其取值范围是1 （Thread.MIN_PRIORITY） - 10 （Thread.MAX_PRIORITY）。  Thread源代码里对NORM_PRIORITY （数值为5） 的注释是“线程默认的优先级”   线程的优先级表示该线程的紧急程度，线程越紧急，被处理器调度执行的机会就越大。在Thread类中优先级取值范围为1到10，并定义了3个表示线程优先级的常量：    public static final int MAX_PRIORITY = 10; // 最高优先级    public static final int NORM_PRIORITY = 5; // 默认优先级    public static final int MIN_PRIORITY = 1; // 最低优先级    数值越大，优先级越高。getPriority和setPriority用于获取和设置线程的优先级。方法的定义分别为：    public int getPriority()    public void setPriority(int newPriority) wait和sleep的区别 ： sleep睡着也要抱着锁（必须等方法执行完） ，其他线程不能执行，但是不影响非线程方法的访问。 wait ：其他线程可以执行（一般加一个判断语句），判断语句外加this.notify  （叫醒其他等待当前线程锁的线程）。视频11. wait和notify都是Object类里面的方法。只有锁定了某个线程，才能wait 。 notify ：叫醒正在我这个对象上等待的线程 ，而不是自己。一般notifyAll 。","title":"java多线程"},{"content":"WIFI建立过程概述： STA ------------> Probe Request   ----------------> AP //广播自身数据 STA <------------ Probe Response   <------------- AP STA ------------>     Authentication Request --------> AP //认证Auth类型，Open System , Shared Key等 STA ------------>     Authentication Response------> AP STA------------->    Association Request  ------------> AP  //请求与AP建立关联，从而可以进行数据交互 STA------------->    Association Response-----------> AP                                    WEP/WPA/WPA2/DISABLED Security Type. Data Communication http://standards.ieee.org/about/get/802/802.11.html ","title":"WIFI连接建立过程"},{"content":"If you launched Xcode from a read-only disk image, consider copying Xcode to your Applications folder and unmounting the disk image.  解决方案:    因为MAC的安装机制和WINDOWS有所不同，MAC的安装包是以设备的方式挂载到系统上，所以只是一个镜像，相当于windows的DVD，你打开finder会发现XCODE已设备的方式在左下角，打开这个文件夹将xcode拖拽到桌面，拷贝完成后关闭所有xcode程序重新从桌面打开，即可进行你的操作。  只有将程序拖拽到桌面或者Applications下，才算是真正安装到了本机上，才能够提供写权限。","title":"a read-only disk image"},{"content":"mainActivity如下: package cn.dragtest;import android.app.Activity;import android.graphics.Rect;import android.os.Bundle;import android.util.DisplayMetrics;import android.view.MotionEvent;import android.view.View;import android.view.View.OnTouchListener;import android.view.Window;import android.widget.Button;import android.widget.ImageView;public class MainActivity extends Activity implements OnTouchListener{   private Button mButton;   private ImageView mImageView;   private DisplayMetrics displayMetrics;   private float lastX=0;   private float lastY=0;   private int screenWidth=0;   private int screenHeight=0;   private int left;   private int top;   private int right;   private int bottom;   private boolean isFirst=true;    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.main);        initView();    }\tprivate void initView() {         mButton=(Button) findViewById(R.id.button);\t         mImageView=(ImageView) findViewById(R.id.imageView);         mButton.setOnTouchListener(this);         mImageView.setOnTouchListener(this);\t}\tpublic boolean onTouch(View view, MotionEvent event) {\t\tif (isFirst) {\t\t\t// 得到屏幕的宽\t\t\tdisplayMetrics = getResources().getDisplayMetrics();\t\t\tscreenWidth = displayMetrics.widthPixels;\t\t\t// 得到标题栏和状态栏的高度\t\t\tRect rect = new Rect();\t\t\tWindow window = getWindow();\t\t\tmImageView.getWindowVisibleDisplayFrame(rect);\t\t\tint statusBarHeight = rect.top;\t\t\tint contentViewTop = window.findViewById(Window.ID_ANDROID_CONTENT).getTop();\t\t\tint titleBarHeight = contentViewTop - statusBarHeight;\t\t\t// 得到屏幕的高\t\t\tscreenHeight = displayMetrics.heightPixels- (statusBarHeight + titleBarHeight);\t\t\tisFirst=false;\t\t}\t\tint action=event.getAction();\t\tswitch (action) {\t\t//按下\t\tcase MotionEvent.ACTION_DOWN:\t\t\t//按下处坐标\t\t\tlastX=event.getRawX();\t\t\tlastY=event.getRawY();\t\t\tbreak;\t\t//移动\t\tcase MotionEvent.ACTION_MOVE:\t\t\t//移动的距离\t\t\tfloat distanceX=event.getRawX()-lastX;\t\t\tfloat distanceY=event.getRawY()-lastY;\t\t\t//移动后控件的坐标\t\t\tleft=(int)(view.getLeft()+distanceX);\t\t\ttop=(int)(view.getTop()+distanceY);\t\t\tright=(int)(view.getRight()+distanceX);\t\t\tbottom=(int)(view.getBottom()+distanceY);\t\t\t//处理拖出屏幕的情况\t\t\tif (left<0) {\t\t\t\tleft=0;\t\t\t\tright=view.getWidth();\t\t\t}\t\t\tif (right>screenWidth) {\t\t\t\tright=screenWidth;\t\t\t\tleft=screenWidth-view.getWidth();\t\t\t}\t\t\tif (top<0) {\t\t\t\ttop=0;\t\t\t\tbottom=view.getHeight();\t\t\t}\t\t\tif (bottom>screenHeight) {\t\t\t\tbottom=screenHeight;\t\t\t\ttop=screenHeight-view.getHeight();\t\t\t}\t\t\t//显示图片\t\t\tview.layout(left, top, right, bottom);\t\t\tlastX=event.getRawX();\t\t\tlastY=event.getRawY();\t\t\tbreak;\t\t//抬起\t\tcase MotionEvent.ACTION_UP:\t\t\tbreak;\t\tdefault:\t\t\tbreak;\t\t}\t\treturn false;\t}} main.xml如下: <LinearLayout     xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:tools=\"http://schemas.android.com/tools\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\"    android:orientation=\"vertical\"    android:gravity=\"center_horizontal\"     >    <ImageView        android:id=\"@+id/imageView\"        android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\"        android:src=\"@drawable/ic_launcher\"        android:clickable=\"true\"     />    <Button         android:id=\"@+id/button\"        android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\"        android:text=\"please drag\"        android:clickable=\"true\"    /><\/LinearLayout>  ","title":"Android拖动控件改变其位置"},{"content":"mainActivity如下: package com.cn;import android.os.Bundle;import android.app.Activity;import android.view.Menu;public class MainActivity extends Activity {    private SurfaceViewTest mSurfaceViewTest;    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        mSurfaceViewTest=new SurfaceViewTest(MainActivity.this);        setContentView(mSurfaceViewTest);    }    @Override    public boolean onCreateOptionsMenu(Menu menu) {        getMenuInflater().inflate(R.menu.main, menu);        return true;    }} SurfaceViewTest如下: package com.cn;import android.content.Context;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.Paint.Style;import android.graphics.RectF;import android.view.SurfaceHolder;import android.view.SurfaceView;//注意//1 矩形构造方法//RectF rectF=new RectF(10, 10, 100, 100);//RectF(float left, float top, float right, float bottom)//must ensure that left <= right and top <= bottom//第一个,第二个参数float left, float top//表示矩形的起始点(即左上角的点)//第一个,第二个参数float right, float bottom//表示矩形的终止点(即右下角的点)//2 绘制椭圆//并没有想象中的\"直接\"绘制椭圆的方法//而是在一个矩形中绘制了椭圆//因为一个矩形就定位了椭圆public class SurfaceViewTest extends SurfaceView implements SurfaceHolder.Callback{\tprivate Context mContext;\tprivate Paint mPaint;\tpublic SurfaceViewTest(Context context) {\t\tsuper(context);\t\tthis.mContext=context;\t\t//设置生命周期回调接口的实现\t\tthis.getHolder().addCallback(this);\t\tmPaint=new Paint();\t\t//抗锯齿\t\tmPaint.setAntiAlias(true);\t}\t@Override\tprotected void onDraw(Canvas canvas) {\t\tsuper.onDraw(canvas);\t\t//-------->绘制白色矩形背景\t\t//设置画笔颜色\t\tmPaint.setColor(Color.WHITE);\t\t//绘制白色矩形背景\t\tcanvas.drawRect(0, 0, 350, 450, mPaint);\t\tmPaint.reset();\t\t\t\t//-------->绘制直线\t\tmPaint.setColor(Color.RED);\t\t//设置线条宽度\t\tmPaint.setStrokeWidth(10);\t\tcanvas.drawLine(30, 10, 200, 70, mPaint);\t\tmPaint.reset();\t\t\t\t//-------->绘制带边框的空心矩形(实心矩形)\t\tmPaint.setStrokeWidth(5);\t\tmPaint.setARGB(50, 0, 255, 0);\t\t//注释掉下一句即为实心矩形\t\tmPaint.setStyle(Style.STROKE);\t\tRectF rectF1=new RectF(10, 10, 150, 150);\t\tcanvas.drawRect(rectF1, mPaint);\t\tmPaint.reset();\t\t\t\t//-------->绘制空心圆(实心圆)\t\tmPaint.setColor(Color.GREEN);\t\tmPaint.setAntiAlias(true);\t\t//注释掉下一句即为实心圆\t\tmPaint.setStyle(Style.STROKE);\t\tcanvas.drawCircle(150, 200, 30, mPaint);\t\tmPaint.reset();\t\t\t\t//-------->绘制椭圆充满矩形\t\tmPaint.setColor(Color.YELLOW);\t\tRectF rectF2=new RectF(10, 230, 200, 300);\t\tcanvas.drawOval(rectF2, mPaint);\t\tmPaint.reset();\t\t\t\t//-------->绘制文字\t\tmPaint.setColor(Color.BLACK);\t\tmPaint.setTextSize(25);\t\t//设置文字下划线\t\tmPaint.setUnderlineText(true);\t\tcanvas.drawText(\"大家好,Hello world\", 50, 340, mPaint);\t\tmPaint.reset();\t}\t\t//实现SurfaceHolder.Callback中的方法\tpublic void surfaceCreated(SurfaceHolder holder) {\t\tCanvas canvas=holder.lockCanvas();\t\ttry {\t\t\tsynchronized (holder) {\t\t\t   onDraw(canvas);\t\t\t\t}\t\t} catch (Exception e) {\t\t}finally{\t\t\tif (canvas!=null) {\t\t\t\tholder.unlockCanvasAndPost(canvas);\t\t\t}\t\t}\t}\t//实现SurfaceHolder.Callback中的方法\tpublic void surfaceChanged(SurfaceHolder holder, int format, int width,int height) {\t}\t//实现SurfaceHolder.Callback中的方法\tpublic void surfaceDestroyed(SurfaceHolder holder) {\t}}    ","title":"Android图形绘制基础(二)"},{"content":"//first.c#include <stdio.h>void f(void);int x = 15213;int y = 15212;int main(){\tf();\tprintf(\"x = ox%x y = 0x%x\\n\", x, y);\t\treturn 0;} //bar.cdouble x;void f(){\tx = -0.0;} xxx@ubuntu-64bit-compile:~/share2/learning/csapp/project$ cc first.c bar4.c /usr/bin/ld: Warning: alignment 4 of symbol `x' in /tmp/ccFBxcBU.o is smaller than 8 in /tmp/ccOvyDIy.o xxx@ubuntu-64bit-compile:~/share2/learning/csapp/project$ ./a.out  x = ox0 y = 0x80000000 因为double 类型是8个字节， 而int 类型是4个字节。因此， 负值的双精度浮点表示覆盖存储中 x 和 y的位置。因此就会产生那样的打印结果。 为此， 在项目中， 得到了一条经验教训： 不要忽视 编译警告。。。。  这一点开发人员一直不注意。","title":"链接器解析多重定义的全局变量"},{"content":"今天自行研究了下json ，感觉非常好用，经过测试比google的GSON快多了       同时Jackson可以轻松的将Java对象转换成json对象和xml文档，同样也可以将json、xml转换成Java对象。功能非常的强悍！        大家也知道，json 在如今互联网时代应用的非常广，因为大家如此的关注，所以对json的解析性能要求也是非常高的。   一、 准备工作 1、 下载依赖库jar包 Jackson的jar all下载地址：http://jackson.codehaus.org/1.7.6/jackson-all-1.7.6.jar 然后在工程中导入这个jar包即可开始工作 官方示例：http://wiki.fasterxml.com/JacksonInFiveMinutes 因为下面的程序是用junit测试用例运行的，所以还得添加junit的jar包。版本是junit-4.2.8 如果你需要转换xml，那么还需要stax2-api.jar 2、 测试类基本代码如下   [java] view plaincopy /*   * @project java   * @package    * @file Jackson.java   * @version  1.0   * @author   廖益平   * @time  2011-11-8 上午02:59:37   */      public class Jackson {       /*       *       * Class Descripton goes here.       *       * @class Jackson       * @version  1.0       * @author   廖益平       * @time  2011-11-8 上午02:59:37       */       public  static JsonGenerator jsonGenerator = null;       private static ObjectMapper mapper = new ObjectMapper();       public static void main(String[] args) {           Student student = new Student();           student.setIsstudent(true);           student.setUid(1000);           student.setUname(\"xiao liao\");           student.setUpwd(\"123\");           student.setNumber(12);                      Map<String, Student> stuMap = new HashMap<String, Student>();           stuMap.put(\"1\", student);           stuMap.put(\"2\", student);                      List<Object> stuList = new ArrayList<Object>();           List<Student> stuList1 = new ArrayList<Student>();           stuList1.add(student);           student=  new  Student();           student.setIsstudent(false);           student.setUid(200);           student.setUname(\"xiao mi\");           stuList1.add(student);                      stuList.add(student);           stuList.add(\"xiao xin\");           stuList.add(\"xiao er\");           stuList.add(stuMap);                      //readJson2List();           try {               //readJson2Array();               //writeArray2Json(array);               //writeJson2List();               //writeEntity2Json(student);               writeJson2Entity();               //writeMap2Json(stuMap);               //writeList2Json(stuList1);                          } catch (IOException e) {               e.printStackTrace();           }       }        /**        *         * <code>writeEntity2Json<\/code>        * @description: TODO(实体类转换成json)         * @param object        * @throws IOException        * @since   2011-11-8     廖益平        */        public static void writeEntity2Json(Object object) throws IOException {              mapper.writeValue( new File(\"D:\\\\developSoft\\\\aaadowload\\\\testjson1\\\\lib\\\\aa.txt\"),object );              mapper.writeValue( System.out,object );                    }        /**        *         * <code>writeArray2Json<\/code>        * @description: TODO(数组转换成json数组)         * @param object        * @throws IOException        * @since   2011-11-8     廖益平        */        public static void writeArray2Json(Object object) throws IOException {                        // writeValue具有和writeObject相同的功能            mapper.writeValue( new File(\"D:\\\\developSoft\\\\aaadowload\\\\testjson1\\\\lib\\\\aa.txt\"),object );            mapper.writeValue(System.out,object );                    }        /**        *         * <code>writeMap2Json<\/code>        * @description: TODO(map对象转换成json对象)         * @param object        * @throws IOException        * @since   2011-11-8     廖益平        */        public static void writeMap2Json(Object object) throws IOException {                        System.out.println(\"使用ObjectMapper-----------\");            // writeValue具有和writeObject相同的功能            System.out.println(\"==>\"+mapper.writeValueAsString(object));            mapper.writeValue( new File(\"D:\\\\developSoft\\\\aaadowload\\\\testjson1\\\\lib\\\\aamap.txt\"),object );            mapper.writeValue( System.out , object );        }        /**        *         * <code>writeList2Json<\/code>        * @description: TODO(list转换成json)         * @param object        * @throws IOException        * @since   2011-11-8     廖益平        */        public static void writeList2Json(Object object) throws IOException {            System.out.println(\"==>\"+mapper.writeValueAsString(object));            mapper.writeValue( new File(\"D:\\\\developSoft\\\\aaadowload\\\\testjson1\\\\lib\\\\aamap.txt\"),object );            mapper.writeValue( System.out , object );        }        /**        *         * <code>writeJson2Entity<\/code>        * @description: TODO(json转换成实体)         * @throws IOException        * @since   2011-11-8     廖益平        */        public static void writeJson2Entity() throws IOException {            System.out.println(\"json串转换成entity-------------\");   //       File file = new File(\"D:\\\\developSoft\\\\aaadowload\\\\testjson1\\\\lib\\\\aa.txt\");   //       FileInputStream inputStream = new FileInputStream(file);   //       Student student = mapper.readValue(inputStream,Student.class);   //       System.out.println(student.toString());            //漂亮输出            //mapper.defaultPrettyPrintingWriter().writeValueAsString(value);                   String json = \"{\\\"uid\\\":1000,\\\"uname\\\":\\\"xiao liao\\\",\\\"upwd\\\":\\\"123\\\",\\\"number\\\":12.0,\\\"isstudent\\\":true}\";            Student student1 = mapper.readValue(json,Student.class);            System.out.println(\"json2:\"+student1.toString());        }        /**        *         * <code>writeJson2List<\/code>        * @description: TODO(json专程list对象)         * @throws IOException        * @since   2011-11-8     廖益平        */        public static void writeJson2List() throws IOException {            System.out.println(\"json串转换成entity-------------\");            File file = new File(\"D:\\\\developSoft\\\\aaadowload\\\\testjson1\\\\lib\\\\aa.txt\");            FileInputStream inputStream = new FileInputStream(file);            Student student = mapper.readValue(inputStream,Student.class);            System.out.println(student.toString());                        String json = \"[{\\\"uid\\\":1000,\\\"uname\\\":\\\"xiao liao\\\",\\\"upwd\\\":\\\"123\\\",\\\"number\\\":12.0,\\\"isstudent\\\":true},{\\\"uid\\\":200,\\\"uname\\\":\\\"xiao mi\\\",\\\"upwd\\\":null,\\\"number\\\":0.0,\\\"isstudent\\\":false}]\";            List<LinkedHashMap<String, Object>> s= mapper.readValue(json,List.class);            for (int i = 0; i < s.size(); i++) {                LinkedHashMap<String, Object> link = s.get(i);                Set<String>  key = link.keySet();                for (Iterator iterator = key.iterator(); iterator.hasNext();) {                   String string = (String) iterator.next();                   System.out.println(string+\"==>\"+link.get(string));                                  }                System.out.println(\"json:\"+i+\"\"+s.get(i).toString());                          }        }        /**         * JSON转换为List对象         */         public static void readJson2List() {          String json = \"[{\\\"uid\\\":1,\\\"uname\\\":\\\"www\\\",\\\"number\\\":234,\\\"upwd\\\":\\\"456\\\"},\"            + \"{\\\"uid\\\":5,\\\"uname\\\":\\\"tom\\\",\\\"number\\\":3.44,\\\"upwd\\\":\\\"123\\\"}]\";          try {           List<LinkedHashMap<String, Object>> list = mapper.readValue(             json, List.class);           System.out.println(list.size());           for (int i = 0; i < list.size(); i++) {            Map<String, Object> map = list.get(i);            Set<String> set = map.keySet();            for (Iterator<String> it = set.iterator(); it.hasNext();) {             String key = it.next();             System.out.println(key + \":\" + map.get(key));            }           }          } catch (JsonParseException e) {           e.printStackTrace();          } catch (JsonMappingException e) {           e.printStackTrace();          } catch (IOException e) {           e.printStackTrace();          }         }         /**         * JSON转换为List对象         */         public static void readJson2Array() {             String json = \"[{\\\"uid\\\":1,\\\"uname\\\":\\\"www\\\",\\\"number\\\":234,\\\"upwd\\\":\\\"456\\\"},\"                 + \"{\\\"uid\\\":5,\\\"uname\\\":\\\"tom\\\",\\\"number\\\":3.44,\\\"upwd\\\":\\\"123\\\"}]\";             try {                 Student[] students = mapper.readValue(json, Student[].class);                 for (Student student : students) {                   System.out.println(\">\"+student.toString());               }             } catch (JsonParseException e) {                 e.printStackTrace();             } catch (JsonMappingException e) {                 e.printStackTrace();             } catch (IOException e) {                 e.printStackTrace();             }         }      }   打印结果 ： 串转换成entity------------- json2:uid=1000,name=xiao liao,upwd=123,number=12.0,isStudent=true writeMap2Json ----------- {\"2\":{\"uid\":1000,\"uname\":\"xiao liao\",\"upwd\":\"123\",\"number\":12.0,\"isstudent\":true},\"1\":{\"uid\":1000,\"uname\":\"xiao liao\",\"upwd\":\"123\",\"number\":12.0,\"isstudent\":true}} readJson2Array------------------ >uid=1,name=www,upwd=456,number=234.0,isStudent=false >uid=5,name=tom,upwd=123,number=3.44,isStudent=false writeMap2Json ----------- {\"2\":{\"uid\":1000,\"uname\":\"xiao liao\",\"upwd\":\"123\",\"number\":12.0,\"isstudent\":true},\"1\":{\"uid\":1000,\"uname\":\"xiao liao\",\"upwd\":\"123\",\"number\":12.0,\"isstudent\":true}} 大家逐个自己试试吧  ，上面也是我的测试代码   [java] view plaincopy 实体类：   /*   * @project java   * @package    * @file Student.java   * @version  1.0   * @author   廖益平   * @time  2011-11-8 上午03:01:08   */      public class Student {       /*       *       * Class Descripton goes here.       *       * @class Student       * @version  1.0       * @author   廖益平       * @time  2011-11-8 上午03:01:08       */         private int uid;         private String uname;         private String upwd;         private double number;         private boolean isstudent;       public int getUid() {           return uid;       }       public void setUid(int uid) {           this.uid = uid;       }       public String getUname() {           return uname;       }       public void setUname(String uname) {           this.uname = uname;       }       public String getUpwd() {           return upwd;       }       public void setUpwd(String upwd) {           this.upwd = upwd;       }       public double getNumber() {           return number;       }       public void setNumber(double number) {           this.number = number;       }       public boolean isIsstudent() {           return isstudent;       }       public void setIsstudent(boolean isstudent) {           this.isstudent = isstudent;       }       @Override       public String toString() {                  return \"uid=\"+uid+\",name=\"+uname+\",upwd=\"+upwd+\",number=\"+number+\",isStudent=\"+isstudent;       }                   }  ","title":"Jackson 高性能的JSON处理 android/移动开发必备jackson ."},{"content":"这是我的测试中 baidu地图和Google地图 的显示情况， 显然 百度的更详细一些，google地图在电脑上的表现还是很好的，所以做手机地图测试我开始也是用google的，没想到  实现过程  超麻烦，首先是申请API key , google apikey现在的申请地址也换了，让我找了好半天，现是下面这个链接 https://developers.google.com/maps/documentation/android/v1/maps-api-signup?hl=zh-CN   打开后就是悲催的 无法显示  之前都是刷新几次就出来了，这回刷新了好几次直接白屏了，尼玛万里长城长又长。。。 千辛万苦，跋山涉水，翻山越岭 （此处省略一万字）终于注册到了。。。。。。。 才开始 地图开发 ，尼玛， 下面是工程结构（左图），  需要注意的是 开发google地图应用 |需要创建 google apis 虚拟机，普通虚拟机不行，之前我可走了大弯路，由于我的SDK里只有android-10和android-14  没想到开发地图应用需要创建 google apis 虚拟机,  我就加了个maps包， 代码完全正常, （右图）  就是运行的时候提示错误，我在网上查那个错误信息，按照网上的各种 方法修改都不行， 在群里也是各种问，全部 无果，，后来查到一个 说要创建 google apis 虚拟机，然后我就在网上查找google apis 包，解压到sdk\\add-ons里，重启eclipse 就可以创建 google apis 虚拟机和工程了， 布局文件 main.xml  , 其中 apiKey 就是填写在Google上申请到的apikey   <com.google.android.maps.MapView        android:id=\"@+id/myMapView1\"        android:layout_width=\"fill_parent\"        android:layout_height=\"fill_parent\"        android:layout_x=\"0px\"        android:layout_y=\"102px\"        android:apiKey=\"0Gjfd4yOVZC0yPDlP26cBY46WfJ2MWz9urcu7JQ\"                /> 主Activity   包括自定义图层绘制 public class GooglemapActivity extends MapActivity {\tprivate MapController mMapController01;\tprivate MapView mMapView01;\tprivate Button mButton01, mButton02, mButton03;\tprivate EditText mEditText01;\tprivate EditText mEditText02;\tprivate int intZoomLevel = 0;\t/* Map启动时的预设坐标： */\t// private double dLat=34.818881;\t// private double dLng=113.68235;\tprivate double dLat;\tprivate double dLng;\t@Override\tprotected void onCreate(Bundle icicle) {\t\tsuper.onCreate(icicle);\t\tsetContentView(R.layout.main);\t\t/* 定位到自己当前位置 */\t\tmyself();\t\t/* 建立MapView对象 */\t\tmMapView01 = (MapView) findViewById(R.id.myMapView1);\t\t// 取得MapController对象(控制MapView)\t\tmMapController01 = mMapView01.getController();\t\tmMapView01.setEnabled(true);\t\tmMapView01.setClickable(true);\t\t/* 设定MapView的显示选项（卫星、街道） */\t\t// mMapView01.setSatellite(false); //卫星图\t\tmMapView01.setStreetView(true);// 街道图\t\t/* 预设放己的层级 */\t\tintZoomLevel = 15;\t\tmMapController01.setZoom(intZoomLevel);\t\tmMapView01.setBuiltInZoomControls(true);// 显示缩放控件\t\tmMapView01.displayZoomControls(true);//\t\tmMapView01.setTraffic(true);// 交通图\t\t/* 设定Map的中点为预设经纬度 */\t\trefreshMapView();\t\tDrawable marker = getResources().getDrawable(R.drawable.da_marker_red);\t\tmarker.setBounds(0, 0, marker.getIntrinsicWidth(),\t\t\t\tmarker.getIntrinsicHeight());// Intrinsic固有\t\tmMapView01.getOverlays().add(new MyItemizedOverlay(marker, this));\t\tmEditText01 = (EditText) findViewById(R.id.myEdit1);\t\tmEditText02 = (EditText) findViewById(R.id.myEdit2);\t\t/* 送出查询的Button */\t\tmButton01 = (Button) findViewById(R.id.myButton1);\t\tmButton01.setOnClickListener(new Button.OnClickListener() {\t\t\t@Override\t\t\tpublic void onClick(View v) {\t\t\t\t/* 经纬度空白检查 */\t\t\t\tif (mEditText01.getText().toString().equals(\"\")\t\t\t\t\t\t|| mEditText02.getText().toString().equals(\"\")) {\t\t\t\t\tshowDialog(\"经度或纬度填写不正确!\");\t\t\t\t} else {\t\t\t\t\t/* 取得输入的经纬度 */\t\t\t\t\tdLng = Double.parseDouble(mEditText01.getText().toString());\t\t\t\t\tdLat = Double.parseDouble(mEditText02.getText().toString());\t\t\t\t\t/* 依输入的经纬度重整Map */\t\t\t\t\trefreshMapView();\t\t\t\t}\t\t\t}\t\t});\t\t/* 放大Map的Button */\t\tmButton02 = (Button) findViewById(R.id.myButton2);\t\tmButton02.setOnClickListener(new Button.OnClickListener() {\t\t\t@Override\t\t\tpublic void onClick(View v) {\t\t\t\tintZoomLevel++;\t\t\t\tif (intZoomLevel > mMapView01.getMaxZoomLevel()) {\t\t\t\t\tintZoomLevel = mMapView01.getMaxZoomLevel();\t\t\t\t}\t\t\t\tmMapController01.setZoom(intZoomLevel);\t\t\t}\t\t});\t\t/* 缩小Map的Button */\t\tmButton03 = (Button) findViewById(R.id.myButton3);\t\tmButton03.setOnClickListener(new Button.OnClickListener() {\t\t\t@Override\t\t\tpublic void onClick(View v) {\t\t\t\tintZoomLevel--;\t\t\t\tif (intZoomLevel < 1) {\t\t\t\t\tintZoomLevel = 1;\t\t\t\t}\t\t\t\tmMapController01.setZoom(intZoomLevel);\t\t\t}\t\t});\t}\t// 同一类型覆盖物的绘制\tclass MyItemizedOverlay extends ItemizedOverlay<OverlayItem> {\t\t// 属性\t\tprivate Drawable marker;\t\tprivate Context mContext;\t\tprivate List<OverlayItem> geoList = new ArrayList<OverlayItem>();\t\t// 经纬度的属性\t\tprivate double mLat1 = 34.818881;\t\tprivate double mLon1 = 113.68235;\t\tprivate double mLat2 = 39.607723;\t\tprivate double mLon2 = 116.397741;\t\tprivate double mLat3 = 39.917723;\t\tprivate double mLon3 = 116.6552;\t\t// 构造方法\t\tpublic MyItemizedOverlay(Drawable marker, Context context) {\t\t\tsuper(boundCenterBottom(marker));\t\t\tthis.marker = marker;\t\t\tthis.mContext = context;\t\t\t// 构造地理坐标\t\t\tGeoPoint p1 = new GeoPoint((int) (mLat1 * 1E6), (int) (mLon1 * 1E6));\t\t\tGeoPoint p2 = new GeoPoint((int) (mLat2 * 1E6), (int) (mLon2 * 1E6));\t\t\tGeoPoint p3 = new GeoPoint((int) (mLat3 * 1E6), (int) (mLon3 * 1E6));\t\t\tgeoList.add(new OverlayItem(p1, \"P1\", \"这是我的当前位置\"));\t\t\tgeoList.add(new OverlayItem(p2, \"P2\", \"point2\"));\t\t\tgeoList.add(new OverlayItem(p3, \"P3\", \"point3\"));\t\t\tpopulate();// 执行填充方法\t\t}\t\t// 绘制方法\t\tpublic void draw(Canvas canvas, MapView mapView, boolean shadow) {\t\t\t// 投影，用于屏幕像素点坐标系统与地球经纬度点坐标系统的转换\t\t\tProjection projection = mapView.getProjection();\t\t\tfor (int index = size() - 1; index >= 0; index--) {\t\t\t\tOverlayItem overlayItem = this.getItem(index);\t\t\t\tString title = overlayItem.getTitle();\t\t\t\tPoint point = projection.toPixels(overlayItem.getPoint(), null);\t\t\t\tPaint painttext = new Paint();\t\t\t\tpainttext.setColor(Color.BLACK);\t\t\t\tpainttext.setTextSize(15);\t\t\t\tcanvas.drawText(title, point.x - 30, point.y - 25, painttext);\t\t\t}\t\t\tsuper.draw(canvas, mapView, shadow);\t\t\tboundCenterBottom(marker);\t\t}\t\t// 添加成员方法\t\t@Override\t\tprotected OverlayItem createItem(int i) {\t\t\treturn geoList.get(i);\t\t}\t\t@Override\t\tpublic int size() {\t\t\treturn geoList.size();\t\t}\t\t// 添加点击事件\t\tpublic boolean onTap(int i) {\t\t\tsetFocus(geoList.get(i));\t\t\tToast.makeText(this.mContext, geoList.get(i).getSnippet(),\t\t\t\t\tToast.LENGTH_LONG).show();// snippet片段\t\t\treturn true;\t\t}\t\tpublic boolean onTap(GeoPoint point, MapView mapView) {\t\t\treturn super.onTap(point, mapView);\t\t}\t}\t/* 重整Map的method */\tpublic void refreshMapView() {\t\tGeoPoint p = new GeoPoint((int) (dLat * 1E6), (int) (dLng * 1E6));\t\tmMapView01.displayZoomControls(true);\t\t/* 将Map的中点移出GeoPoint */\t\tmMapController01.animateTo(p);\t\tmMapController01.setZoom(intZoomLevel);\t}\t@Override\tprotected boolean isRouteDisplayed() {\t\treturn false;\t}\tpublic void myself() {\t\tLocationManager lm = (LocationManager) getSystemService(LOCATION_SERVICE);\t\tLocation l = lm.getLastKnownLocation(LocationManager.GPS_PROVIDER);\t\tif (l == null) {\t\t\tToast.makeText(GooglemapActivity.this, \"无法获取自己的位置\",\t\t\t\t\tToast.LENGTH_SHORT).show();\t\t\t/* 默认 的位置 */\t\t\tdLat = 34.818881;\t\t\tdLng = 113.68235;\t\t} else {\t\t\t// GeoPoint gp = new GeoPoint((int)(l.getLatitude() * 1E6),\t\t\t// (int)(l.getLongitude() * 1E6));\t\t\t// mMapController01.animateTo(gp);\t\t\t// // mMapController01.setZoom(17);\t\t\tdLat = (int) (l.getLatitude() * 1E6);\t\t\tdLng = (int) (l.getLongitude() * 1E6);\t\t}\t}\t/* 显示Dialog的method */\tprivate void showDialog(String mess) {\t\tnew AlertDialog.Builder(GooglemapActivity.this).setTitle(\"Message\")\t\t\t\t.setMessage(mess)\t\t\t\t.setNegativeButton(\"确定\", new DialogInterface.OnClickListener() {\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\t\t\t\t\t}\t\t\t\t}).show();\t}} 百度地图API  for android 首页 http://developer.baidu.com/map/sdk-android.htm 点击左侧导航 的  获取密钥 -->  填写信息 --> 然后就申请成功了， 很轻松吧 中文好有爱啊，说明文档啥的 下下来一看就懂了，而且还有demo，代码的实现过程跟google差不多 总结：在我大天朝还是用百度吧","title":"google 地图和baidu地图 在android上的实现过程和对比 包含 自定义图层的绘制"},{"content":"Android横竖屏： 一。布局；二。重新载入。 1.布局：如果不想让软件在横竖屏之间切换，最简单的办法就是在项目的 AndroidManifest.xml中找到你所指定的activity中加上android:screenOrientation属性，他有以下几个参数： \"unspecified\"  默认值 由系统来判断显示方向.判定的策略是和设备相关的，所以不同的设备会有不同的显示方向.  \"landscape\"  横屏显示（宽比高要长）  \"portrait\"  竖屏显示(高比宽要长)  \"user\"  用户当前首选的方向  \"behind\"  和该Activity下面的那个Activity的方向一致(在Activity堆栈中的)  \"sensor\"  有物理的感应器来决定。如果用户旋转设备这屏幕会横竖屏切换。  \"nosensor\"  忽略物理感应器，这样就不会随着用户旋转设备而更改了 （ \"unspecified\"设置除外 ）。 也可以在Java代码中通过setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);来设置。 如果要让软件在横竖屏之间切换，由于横竖屏的高宽会发生转换，有可能会要求不同的布局。可以通过以下方法来切换布局： 1）在res目录下建立layout-land和layout-port目录,相应的layout文件不变，比如main.xml。layout-land是横屏的layout,layout-port是竖屏的layout，其他的不用管，模拟器会自动寻找。 2）通过this.getResources().getConfiguration().orientation来判断当前是横屏还是竖屏然后来加载相应的xml布局文件。因为当屏幕变为横屏的时候,系统会重新呼叫当前Activity的OnCreate方法,你可以把以下方法放在你的OnCreate中来检查当前的方向,然后可以让你的SetContentView来载入不同的Layout xml.  if (this.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {  Log.i(\"info\", \"landscape\");  }  else if (this.getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) {  Log.i(\"info\", \"portrait\");  } 2.重新载入问题。如果不需要从新载入，可以在androidmanifest.xml中加入配置android:configChanges=\"orientation\"，配置android:configChanges的作用就是如文档所说的：Specify one or more configuration changes that the activity will handle itself. If not specified, the activity will be restarted if any of these configuration changes happen in the system。这样在程序中. Activity就不会重复的调用onCreate()甚至不会调用onPause.onResume.只会调用一个onConfigurationChanged(Configuration newConfig)。 –*************其实在这里我遇到两个奇怪的问题，那就是 1.如果我在android:configChanges中只设置orientation，他依然会重新加载，只有设置了orientation|keyboardHidden它才会只调用一个onConfigurationChanged(Configuration newConfig) 2.当横屏变竖屏的时候，他会调用两次onConfigurationChanged，而竖屏转横屏时他只调用一次onConfigurationChanged，真是太奇怪了。如果你知道，欢迎留言共同探讨*************– 如果需要重新载入，则不需要做任何修改。不过如果需要在重新载入过程中保存之前的操作内容或数据，则需要保存之前的数据。然后在activity的onCreate()中取出来。当然，如此就不能设置android:configChanges()了，否则就不会调用onCreate()方法。那么数据可以保存在哪呢？Android中四种存储方法都可以，另外，还可以用Android为我们提供了onRetainNonConfigurationInstance()方法来暂时保存数据。 下面为此举个例子： 保存临时图片： @Override public Object onRetainNonConfigurationInstance() {  final LoadedPhoto[] list = new LoadedPhoto[numberOfPhotos];      keepPhotos(list);  return list;  }  之后便可以在activity的onCreate()函数中实现重新调用临时文件，在代码中需要判断系统是否需要重新加载临时文件。以下是放在OnCreate()函数中加载临时文件的代码： private void loadPhotos() {  final Object data = getLastNonConfigurationInstance();    // The activity is starting for the first time, load the photos from Flickr if (data == null) {          mTask = new GetPhotoListTask().execute(mCurrentPage);      } else {  // The activity was destroyed/created automatically, populate the grid // of photos with the images loaded by the previous activity final LoadedPhoto[] photos = (LoadedPhoto[]) data;  for (LoadedPhoto photo : photos) {              addPhoto(photo);          }      }  } ","title":"android横竖屏 用法总结"},{"content":"内核同步： 主要是防止多核处理器同时访问修改某段代码，或者在对设备驱动程序进行临界区保护。主要有一下几种方式： 1. Mutex（互斥） 头文件： #include <linux/mutex.h> 初始化方法： DEFINE_MUTEX(name); 或者 void mutex_init(struct mutex *lock); 使用方法： void mutex_lock (struct mutex *lock); 尝试得到互斥量，否则进入睡眠，不能被中断，否则会导致进程无法杀死 int mutex_lock_interruptible (struct mutex *lock); Same, but can be interrupted. If interrupted, returns a non zero value and doesn't hold the lock. Test the return value!!!  可以被中断 int mutex_trylock (struct mutex *lock); Never waits. Returns a non zero value if the mutex is not available.int mutex_is_locked (struct mutex *lock);Just tells whether the mutex is locked or not. 无等待 void mutex_unlock (struct mutex *lock); Releases the lock. Make sure you do it as quickly as possible!   2. Reader/writer semphopres 读写信号量 Allow shared access by unlimited readers, or by only 1 writer. Writers get priority. 允许有限数量的读访问，但是只能有一个写访问。 void init_rwsem (struct rw_semaphore *sem); void down_read (struct rw_semaphore *sem); int down_read_trylock (struct rw_semaphore *sem); int up_read (struct rw_semaphore *sem); void down_write (struct rw_semaphore *sem); int down_write_trylock (struct rw_semaphore *sem); int up_write (struct rw_semaphore *sem); Well suited for rare writes, holding the semaphore briefly. Otherwise, readers get starved, waiting too long for the semaphore to be released.   3. Spinlocks 自旋锁 初始化： Static spinlock_t my_lock = SPIN_LOCK_UNLOCKED; Dynamic void spin_lock_init (spinlock_t *lock); 使用： void spin_[un]lock (spinlock_t *lock); Doesn't disable interrupts. Used for locking in process context (critical sections in which you do not want to sleep). void spin_lock_irqsave / spin_unlock_irqrestore (spinlock_t *lock, unsigned long flags); Disables / restores IRQs on the local CPU. Typically used when the lock can be accessed in both process and interrupt context, to prevent preemption by interrupts     进程同步/通信 1. Semaphore 信号量 简单过程： semaphore sv = 1;    loop forever {    P(sv);    critical code section;    V(sv);    noncritical code section; } 头文件以及函数： #include <sys/sem.h> int semctl(int sem_id, int sem_num, int command, ...); int semget(key_t key, int num_sems, int sem_flags); int semop(int sem_id, struct sembuf *sem_ops, size_t num_sem_ops);   2.Share Memory 共享内存 头文件以及函数 #include <sys/shm.h> void *shmat(int shm_id, const void *shm_addr, int shmflg); int shmctl(int shm_id, int cmd, struct shmid_ds *buf); int shmdt(const void *shm_addr); int shmget(key_t key, size_t size, int shmflg);   3.Message Queues 消息队列 头文件以及函数 #include <sys/msg.h> int msgctl(int msqid, int cmd, struct msqid_ds *buf); int msgget(key_t key, int msgflg); int msgrcv(int msqid, void *msg_ptr, size_t msg_sz, long int msgtype, int msgflg); int msgsnd(int msqid, const void *msg_ptr, size_t msg_sz, int msgflg);   线程同步 1. semophore 信号量 简单用法： #include <semaphore.h> sem_t bin_sem; res = sem_init(&bin_sem, 0, 0); sem_wait(&bin_sem); sem_post(&bin_sem); sem_destroy(&bin_sem);   2. Mutex 互斥 头文件以及函数 #include <pthread.h> int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr); int pthread_mutex_lock(pthread_mutex_t *mutex)); int pthread_mutex_unlock(pthread_mutex_t *mutex); int pthread_mutex_destroy(pthread_mutex_t *mutex); 3. 读写锁 头文件以及函数 #include <pthread.h> int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr); int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); 4. 条件变量 #include <pthread.h> pthread_cond_t cond = PTHREAD_COND_INITIALIZER; int    pthread_cond_init(pthread_cond_t    *cond,    pthread_condattr_t  *cond_attr);  int pthread_cond_signal(pthread_cond_t *cond); int pthread_cond_broadcast(pthread_cond_t *cond); int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);  int   pthread_cond_timedwait(pthread_cond_t   *cond,    pthread_mutex_t  *mutex, const struct timespec *abstime); int pthread_cond_destroy(pthread_cond_t *cond);","title":"Linux内核同步，进程，线程同步"},{"content":"1.先获取到当前运行的应用，获取到他们的uid；使用ActivityManager的getRunningAppProces方法获得RunningAppProcessInfo，在RunningAppProcessInfo里面会有pid，uid。 2.使用TrafficStats提供的接口，获取每一个uid的使用流量，过一会再获取，就能知道哪个应用再联网，用了多少？ 具体的根据需要自己搞吧。 另外，其它很多统计信息都可以从ActivityManager里面获取到，比如： RecentTaskInfo， RunningTaskInfo， RunningServiceInfo， MemoryInfo， ProcessErrorStateInfo， RunningAppProcessInfo， PkgUsageStats, ConfigurationInfo, ApplicationInfo, TaskThumbNails. 等等 具体的看一下源代码就了解了。 具体方法参考： 获取Android正在运行的任务和服务 android如何开发流量监控软件","title":"Android 如何监控各个应用的流量和其它乱七八糟的信息"},{"content":"// 得到屏幕的宽\t\t\tdisplayMetrics = getResources().getDisplayMetrics();\t\t\tscreenWidth = displayMetrics.widthPixels;\t\t\t// 得到标题栏和状态栏的高度\t\t\tRect rect = new Rect();\t\t\tWindow window = getWindow();\t\t\tmImageView.getWindowVisibleDisplayFrame(rect);\t\t\tint statusBarHeight = rect.top;\t\t\tint contentViewTop = window.findViewById(Window.ID_ANDROID_CONTENT).getTop();\t\t\tint titleBarHeight = contentViewTop - statusBarHeight;\t\t\t// 得到屏幕的高\t\t\tscreenHeight = displayMetrics.heightPixels- (statusBarHeight + titleBarHeight);","title":"Android得到状态栏和标题栏的高度"},{"content":"首先从http://code.google.com/p/cocos2d-iphone/downloads/list；下载最新版的cocos2d-iphone； 下载完成，把它解压在文档目录下，为了在终端下放便找到该目录; 在终端下进入文档目录，再进入解压的目录中； 终端输入：./install-template.sh 如果成功： 你会在目录下看到： 成功！！ 下面开始创建第一个hello world！程序 打到xcode创建新的应用程序： 选择第一个！！ 目录结构如下： 运行结果： 呵呵！初学者！","title":"cocos2d学习入门"},{"content":"         今天收到个bug，问题是：在输入界面使用中文，输入字符，出现汉字选项，此时点击汉字最后面的翻页箭头，无法翻页，一直只显示一行汉字。 这个问题主要涉及到CandidateView 文件。关于这个的说明，我参考了http://blog.csdn.net/rangq1/article/details/5837003，让我对输入法有了一个大致的了解。另外比较幸运的是看见网友也遇到同样的问题并得以解决：http://bbs.csdn.net/topics/350189202。我用他说的方法果然是解决了，非常感谢。 总结： 输入法源码位置：packages\\inputmethods\\PinyinIME 输入法无法翻页的问题：          主要在CandidateView类中进行处理，CandidateView是一个候选字显示view，它提供一个候选字选择的视图，直接继承于View类即可。在我们输入字符时，它应该能根据字符显示一定的提示，比如拼音同音字啊，联想的字啊之类的。CandidateView 类里onSizeChanged 方法中，由于每次size发生变化，都会导致第一页重置，所以将导致重置的那个成员变量去掉即可，即mPageNo = 0 注释即可。          问题是解决了，但是对输入法IME的框架和流程还不是特别清楚，近两天恶补一下： http://blog.sina.com.cn/s/blog_818a90240101306f.html Android PinyinIME 源码笔记 -- 附A.1 输入法的启动 http://blog.sina.com.cn/s/blog_818a90240101306d.html  Android PinyinIME 源码笔记 -- 2. 底层服务启动  ","title":"Android自带的谷歌拼音输入法不能翻页问题"},{"content":"mainActiviry如下: package com.cn;import android.app.Activity;import android.os.Bundle;public class MainActivity extends Activity {     private DrawBitmapView mDrawBitmapView;    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        mDrawBitmapView=new DrawBitmapView(MainActivity.this, null);        setContentView(mDrawBitmapView);    }  } DrawBitmapView如下: package com.cn;import android.content.Context;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.graphics.Canvas;import android.graphics.Matrix;import android.graphics.Paint;import android.util.AttributeSet;import android.view.MotionEvent;import android.view.View;//问题0://Matrix m1=new Matrix();//注意这个类的包的引入,android.graphics.Matrix//问题1://post和set以及pre的使用//这三种都可以改变Matrix但是用法不太一样//1.1若连续多次使用set那么只有最后一个set起到作用//1.2常用的是第一次时用set,在随后都采用post的方式//   表示追加.//1.3pre表示最先发生.即会在post和set前发生//问题2://Rotate默认是以(0,0)为参照点//所以常要设置参考旋转点//m1.postRotate(30,70,100);//问题3://设置Alpha的时候//mPaint.setAlpha(30);//取值范围为[0..255]//备注://最好将以下测试方法,分开进行public class DrawBitmapView extends View {\tBitmap mBitmap;\tPaint mPaint;\tpublic DrawBitmapView(Context context, AttributeSet attrs) {\t\tsuper(context, attrs);\t\tinitView();\t}\tpublic void initView(){\t\tmPaint=new Paint();\t\tmBitmap=BitmapFactory.decodeResource(getResources(), R.drawable.ic_launcher);\t}    @Override\tprotected void onDraw(Canvas canvas) {\t\tsuper.onDraw(canvas);//\t\t // ----->测试1://\t\t //先绘制一个图形//\t\t //然后绘制经过位移,旋转,缩放后的图形(方法1)//\t\t //第一次绘制//\t\t mPaint.setAntiAlias(true);//\t\t canvas.drawBitmap(mBitmap, 50, 50, mPaint);//\t\t canvas.save();//\t\t //第二次绘制//\t\t Matrix m1 = new Matrix();//\t\t m1.setTranslate(70, 100);//\t\t m1.postScale(1.5f, 1.5f);//\t\t m1.postRotate(30, 70, 100);//\t\t canvas.drawBitmap(mBitmap, m1, mPaint);//\t\t// ----->测试2://\t\t// 先绘制一个图形//\t\t// 然后绘制经过位移,旋转,缩放后的图形(方法2)//\t\t// 第一次绘制//\t\tmPaint.setAntiAlias(true);//\t\tcanvas.drawBitmap(mBitmap, 50, 50, mPaint);//\t\tcanvas.save();//\t\t// 第二次绘制//\t\tMatrix m2 = new Matrix();//\t\tm2.setTranslate(70, 100);//\t\tm2.postScale(1.5f, 1.5f);//\t\tMatrix m3=new Matrix();//\t\tmPaint.setAlpha(50);//\t\tm3.setRotate(30, 70, 100);//\t\t//利用setConcat衔接两个变换//\t\tMatrix m4=new Matrix();//\t\tm4.setConcat(m2, m3);//\t\tcanvas.drawBitmap(mBitmap, m4, mPaint);//      canvas.restore();//\t\tcanvas.save();\t\t\t\t// ----->测试3:preXXX()方法和xxxSkew()方法\t\t//该类方法会在当前矩阵的最前面发生\t\t//比如在该例子中,会先旋转后位移\t\t// 第一次绘制\t\tmPaint.setAntiAlias(true);\t\tcanvas.drawBitmap(mBitmap, 50, 50, mPaint);\t\tcanvas.save();\t\t// 第二次绘制\t\tMatrix m5=new Matrix();\t\tm5.setTranslate(100, 200);\t\tm5.preRotate(30, 50, 50);\t\t//skew表示倾斜\t\tm5.postSkew(0.2f, 0.2f, 50, 50);\t\tcanvas.drawBitmap(mBitmap, m5, mPaint);\t\t\t}    @Override    public boolean onTouchEvent(MotionEvent event) {    \treturn super.onTouchEvent(event);    }}  ","title":"Android图形绘制基础(一)"},{"content":"博文首发地址：http://webfrogs.github.com/2012/12/26/iphone-use-zbar/ 简介 当开发IOS程序中需要用到二维码识别功能的时候，zbar这个开源库估计会被不少人选择。但是关于zbar的用法，网上的资料大部分都集中在ZBarReaderViewController这个类的使用上。本人在使用中，发现ZBarReaderViewController这个类使用很不灵活，比如，如果需要对界面做一些自定义的定制时会变得很麻烦。在zbar的头文件中，我发现了ZBarReaderView这个类，直觉告诉我这个类的使用应该是比较灵活。google之后发现针对这个类的使用说明比较少，几乎没有，只能自己动手了，在下载了zbar的源码稍作研究后，终于搞定了ZBarReaderView的用法。 详见：http://webfrogs.github.com/2012/12/26/iphone-use-zbar/ 转载请注明出处。","title":"IOS开发之ZBarReaderView的使用"},{"content":"今天再做软键盘隐藏时遇到的问题记录一下： 我在上一个界面的onResume方法里隐藏软键盘始终隐藏不掉，后来在当前界面的onPause方法里面写才算解决问题。网上查资料是这样的： 软键盘的显示与隐藏可以写在某控件的onClick事件里来或者用timer来控制，若你直接在onCreate或onResume里面写是不行的，因为软件盘要在所有view画完才能显示的。 后来做个试验： 在onResume方法中，通过handler延迟200毫秒执行隐藏键盘操作，果然OK了。记录在此，纪念耗费的时间。","title":"EditText隐藏软件盘的问题"},{"content":"        我把android的adt和sdk从4.0升级到4.2，发现eclipse的android设置里面原来列出的各种api level的platform消失了，而且无法新建android工程。而且检查过了sdk和adt都是最新的。         解决方式就是重新建一个工作区(workspace)。在eclipse的Windows > Preferences > General > Startup an Shutdown > Workspaces 里面，Remove掉以前的workspace，再重启eclispe（这会导致看不到以前的所以工程，建议在remove之前先到Package Explorer里面全选所有工程，然后导出为‘File System’，用于以后再导入)。         重新进入eclipse之后，查看android的SDK Location，就应该可以识别了。如果还是不行，重命名你的SDK所在的目录，再到eclipse设置的Android类别里面把SDK Location指向重命名后的目录所在的路径，就能识别了。识别完成后把那个目录重命名回原来的，再到设置里面重新指定路径。","title":"android升级adt和sdk之后无法识别SDK Location的一个解决方式"},{"content":"据《新闻晚报》报道，11月30日晚21点50分，时间和数字定格在这一刻，淘宝、天猫的年交易额突破一万亿。08年温总也不过拿出了四万亿拯救中国经济，所以说那是一个非凡的时刻，标志着一个新时代的到来。这一时刻，激励了大大小小的无数的电商，也给了许多网络淘金者广阔的梦想空间，一场撑不死人却会饿死人的饕餮大餐摆在所有人面前，盛宴曲终人散时，又会有几家欢乐几家愁。意淫结束，不为盛世唱赞歌，简单谈谈android手机的网店客户端。 对于复杂的网店域名，有时连店老板都常常需要先登录自己的淘宝帐号，再选择链接才能找到自己网店，这样让消费者情何以堪。所以做一个简单的网店客户端，使用户可以不必记忆你的域名，不必收藏你的网站，轻松一点按钮就能登录购物，对于培养长期粉丝，服务优质客户还是具有一定意义。甚至可以在客户端里写一些代码，对使用你的客户端的用户，销售做一些小的优惠，也可以让人注册会员优惠，还可以扩展做一个小的WIDGET做新产品展示和活动广告，为优质客户提供差异化服务。 这里只做一个简单的客户端，复杂客户端留待以后扩展。只需要几行代码就能实现，抛砖引玉吧，目的是帮助懒人省去加书签或者记域名的烦恼。 新建一工程，名字随意，这里叫shopping，在shopping里的Activity函数里添加如下代码， shoppingUrl就是店的地址了，这里使用 Intent类调用系统的浏览器打开网店，打开后把应用程序线程关闭。.String shoppingUrl = \"http://xianji-shanghai.taobao.com/\";Uri uri =Uri.parse(shoppingUrl); Intent it = new Intent(Intent.ACTION_VIEW, uri); startActivity(it); android.os.Process.killProcess(android.os.Process.myPid()); 全部的完整代码如下： public class MainActivity extends Activity {\tString shoppingUrl = \"http://xianji-shanghai.taobao.com/\";\t@Override\tprotected void onCreate(Bundle savedInstanceState) {\t\tsuper.onCreate(savedInstanceState);\t\tsetContentView(R.layout.activity_main);\t\t\t\tUri uri =Uri.parse(shoppingUrl);         Intent it = new Intent(Intent.ACTION_VIEW, uri);         startActivity(it);         android.os.Process.killProcess(android.os.Process.myPid());\t}\t@Override\tpublic boolean onCreateOptionsMenu(Menu menu) {\t\t// Inflate the menu; this adds items to the action bar if it is present.\t\tgetMenuInflater().inflate(R.menu.activity_main, menu);\t\treturn true;\t} 这样就行了，可能当用户进入时，会先看我们的窗口，然后才是打开窗口，不美观，可以把我们的默认窗口设成透明，打开程序的AndroidManifest.xml文件，在里面添加一行代码android:theme=\"@android:style/Theme.Translucent.NoTitleBar.Fullscreen实现这个功能，AndroidManifest.xml完整代码如下： <?xml version=\"1.0\" encoding=\"utf-8\"?><manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"    package=\"com.shopping\"    android:versionCode=\"1\"    android:versionName=\"1.0\" >    <uses-sdk        android:minSdkVersion=\"8\"        android:targetSdkVersion=\"16\" />    <application        android:allowBackup=\"true\"        android:icon=\"@drawable/ic_launcher\"        android:label=\"@string/app_name\"        android:theme=\"@style/AppTheme\" >        <activity            android:name=\"com.shopping.MainActivity\"            android:label=\"@string/app_name\"             android:theme=\"@android:style/Theme.Translucent.NoTitleBar.Fullscreen\">            <intent-filter>                <action android:name=\"android.intent.action.MAIN\" />                <category android:name=\"android.intent.category.LAUNCHER\" />                            <\/intent-filter>        <\/activity>    <\/application><\/manifest> 这样运行把上面的网址换成自己的网店，一个小小的客户端就完成了，这里偷了一下懒，调用的是系统的，也不容易受控制，其实我们也可以使用webView来实现这一功能，不使用系统默认的浏览器，优点吗，就是不需要使用系统的或者第三方的，看起来比较烧包了，缺点嘛，如果你的网店如果不支持手机登录，会显示不完整或者显示对了，毕竟webView无法和成熟的浏览器相比，htm有一些比较新的技术可能支持不到。 创建一个shopping2的程序，在布局里把窗口里的hello world标签去掉，添加一个webView控件，布局文件内容如下： <RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:tools=\"http://schemas.android.com/tools\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\"    tools:context=\".MainActivity\" >    <WebView        android:id=\"@+id/webViewshopping\"        android:layout_width=\"fill_parent\"        android:layout_height=\"fill_parent\"        android:focusable=\"false\" /><\/RelativeLayout> 在AndroidManifest.xml里添中一个访问网络的权限，代码如下： <?xml version=\"1.0\" encoding=\"utf-8\"?><manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"    package=\"com.shopping2\"    android:versionCode=\"1\"    android:versionName=\"1.0\" >    <uses-sdk        android:minSdkVersion=\"8\"        android:targetSdkVersion=\"16\" />    <uses-permission android:name=\"android.permission.INTERNET\">      <\/uses-permission>    <application        android:allowBackup=\"true\"        android:icon=\"@drawable/ic_launcher\"        android:label=\"@string/app_name\"        android:theme=\"@style/AppTheme\" >        <activity            android:name=\"com.shopping2.MainActivity\"            android:label=\"@string/app_name\" >                        <intent-filter>                <action android:name=\"android.intent.action.MAIN\" />                                <category android:name=\"android.intent.category.LAUNCHER\" />            <\/intent-filter>        <\/activity>    <\/application><\/manifest> 然后在MainActivity.java文件中添中两行代码如下： public class MainActivity extends Activity {\tString shoppingurl = \"http://xianji-shanghai.taobao.com/\"; \t@Override\tprotected void onCreate(Bundle savedInstanceState) {\t\tsuper.onCreate(savedInstanceState);\t\tsetContentView(R.layout.activity_main);\t\t//jia add\t\tWebView webView = (WebView) findViewById(R.id.webViewshopping);  \t\twebView.loadUrl(shoppingurl); \t}\t@Override\tpublic boolean onCreateOptionsMenu(Menu menu) {\t\t// Inflate the menu; this adds items to the action bar if it is present.\t\tgetMenuInflater().inflate(R.menu.activity_main, menu);\t\treturn true;\t}}运行就可以了，转载请大神们注明出处，网上不要修改，TTHINK YOU。","title":"简单的（淘宝）android网店客户端"},{"content":"作者：wzhongyu   发布：2012-04-13 13:19   分类：Android   阅读：2,011 浏览数   抢沙发   现在要来实现一个自定义的Dialog，主要涉及到样式文件style。参考案例，自己写代码来实现。首先创建一个Android Project——CustomDialog，然后res/drawable文件夹下创建一个xml文件filled_box.xml，其内容为： <?xml version=”1.0″ encoding=”utf-8″?> <shape xmlns:android=”http://schemas.android.com/apk/res/android”> <solid android:color=”#ffff0000″/> <stroke android:width=”3dp” color=”#00ffff80″/> <corners android:radius=”2dp” /> <padding android:left=”10dp” android:top=”10dp” android:right=”10dp” android:bottom=”10dp” /> <\/shape> 这个文件主要是画了一个圆角矩形（shape的android:shape属性的默认值为rectangle，故这里没有设置为矩形，默认是矩形。），设置了其填充颜色为#ffff0000，就是solid这项了；圆角大小是2dp，就是corners这项了；padding项主要控制各边得对齐信息，stroke项主要是边框效果。欲了解shape的详细信息，请参与文档里Dev Guide–>Framework Topics–>Application Resources–>Resource Types–>Drawable页面的相关内容。 下一步就是在res/values目录下创建styles.xml样式文件，内容如下： <?xml version=”1.0″ encoding=”utf-8″?> <resources> <style name=”Theme.CustomDialog” parent=”android:style/Theme.Dialog”> <item name=”android:windowBackground”>@drawable/filled_box<\/item> <\/style> <\/resources> Theme.CustomDialog是自己定义的主题名字，parent属性指定主题的父级主题为android:style/Theme.Dialog，这个主题在“Dialog提示窗口”的案例中已经使用过，然后通过name为android:windowBackground的item指定了窗口背景为之前通过filled_box定义的shape。 现在有了主题样式定义，只需要为Activity添加使用的主题项就可以了，跟前一个案例“Dialog提示窗口”的处理方式一样，打开AndroidManifest.xml文件，在Activity定义处加上属性android:theme=”@style/Theme.CustomDialog”，指定主题为自定义的主题。现在就可以运行一下项目，看看自定义的效果。","title":"Android自定义对话框(Custom Dialog)"},{"content":"在前几篇中，虽然已经实现了rtsp视频流的对接，但是还要做的工作还非常多，onvif本来就是一个覆盖面非常广的一个协议，每一个功能都要填充大量的函数。而且稍不注意就会出现segmentation fault错误。下面把我之前开发调试时的经验写下来，希望能够帮助有这方面需求的人。【来自http://blog.csdn.net/ghostyu】 1、打开onvif调试开关，以便让onvif打印一些可用的调试信息。 在Makefile中添加调试宏定义如: CC = gcc -DDEBUG 2、打开调试宏后，默认在程序运行的目录产生三个文件： RECV.log SENT.log TEST.log RECV.log是onvif接收到的SOAP数据，没接收一条，都会在RECV.log中记录 SENT.log是onvif发送出去的SOAP数据，没发送一套，也会在SENT.log中生成记录 最后是TEST.log，如果说RECV和SENT可以用wireshark工具抓包代替，那么TEST.log是谁也替代不了的，TEST.log记录了onvif的实时的工作状态。 尤其当出现segmentation fault错误，TEST.log就成了唯一一个能够定位到具体内存出错的地方了。 3、最常见的错误：segmentation fault错误的解决方法 segmentation fault错误是onvif开发过程最常见的错误，至少我是这样的，主要是由于访问了没有分配地址的内存导致的，在填充功能函数时，很容易漏掉为必须的结构体分配内存，导致gSoap产生的代码会在不知情的状况下访问该结构体，然后报segmentation fault错误。那如何快速的定位到内存出错的地方呢？ 有人说使用GDB、在这里GDB调试工具起不到什么作用的，因为GDB定位到的内存访问错误，是真的定位到访问时的那一条代码，而onvif中访问结构体内存的代码是有gSOAP自动产生的，代码本身并没有错，是最高一层的填充错误，这时候gdb就显得无能为力了。只能通过TEST.log定位。 我故意将将成员变量Uri的内存非配注释掉，然后编译运行程序，出现内存错误： 虽然我在函数里，打印了一条信息，表明出错的函数，现在我们完全可以忽略该信息，直接看TEST.log 出现内存错误等致命错误，程序会立刻结束，所以打开TEST.log直接看最后面的信息 Element begin tag='SOAP-ENV:Body' level='1' id='0' type=''Lookup location=0xbfd44a30 type=1548: not foundElement begin tag='trt:GetSnapshotUriResponse' level='2' id='0' type=''Element begin tag='trt:MediaUri' level='3' id='0' type=''最后一条显示的Element begin tag=' trt:MediaUri'，说明程序在开始编码trt:GetSnapshotUriResponse的trt:MediaUri出了问题，这里回过头来看源代码， 结构体的第一条就是Uri，假如我注释的并不是Uri，而是__any等，那么TEST.log中的最后一条就肯定不是上面那样子的，我们可以再一些测试，说明TEST.log对于查找错误的重要性。 修改的程序如下： 重新运行程序，运行到这段代码的时候就会产生一个内存错误，我们再次打开TEST.log 从打印的信息来看，tt:Timeout已经编码结束了，然后才出现的问题，这是再看看源代码中Timeout后面的成员变量是什么 所以就很快的定位到出错的地方了。 但是如果使用gdb调试会是什么样的呢，还是可以做一下测试： 这能看出什么啊？对于调试onvif，gdb就显得那么多余了。。。","title":"onvif规范的实现：onvif开发常用调试方法 和常见的segmentation fault错误"},{"content":"原创文章，转载请注明出处：http://blog.csdn.net/zhy_cheng/article/details/8434598 使得运动的物体有尾巴的效果，可以使用CCMotionStreak。 这里我使用【Cocos2d-x游戏引擎开发笔记(12)】粒子系统实现与用户交互的特效的例子，使得效果更加的酷。 在头文件中加入： CCMotionStreak* strike; 然后在init函数中加入下面的代码： \t\tstrike=CCMotionStreak::streakWithFade(1.0f,//尾巴持续的时间\t\t\t16.0f,//尾巴大小\t\t\t16.0f,//图片的大小\t\t\tccc3(255,255,0),//颜色\t\t\t\"sprite.png\"//使用的图片\t\t\t);\t\taddChild(strike,1);\t\tstrike->setPosition(ccp(240,160)); 然后在ccTouchMoved函数中改变位置 strike->setPosition(pTouch->getLocation()); 在ccTouchBegan函数中设置位置  strike->setPosition(pTouch->getLocation()); 好了，大功告成，下面的效果图是在我佳域G2手机上的运行效果 源代码下载：点击下载  ","title":"【Cocos2d-x游戏引擎开发笔记(17)】实现运动的尾巴效果"},{"content":"最近在做html5这一块，参考网上的代码写了一个购物车JS脚本，很简单，直接上代码，shoppingCart.js： utils = {    setParam : function (name,value){        localStorage.setItem(name,value)    },    getParam : function(name){        return localStorage.getItem(name)    }}product={    id:0,    name:\"\",    num:0,    price:0.00,};orderdetail={    username:\"\",    phone:\"\",    address:\"\",    zipcode:\"\",    totalNumber:0,    totalAmount:0.00    }cart = {    //向购物车中添加商品    addproduct:function(product){        var ShoppingCart = utils.getParam(\"ShoppingCart\");        if(ShoppingCart==null||ShoppingCart==\"\"){\t\t\t//第一次加入商品            var jsonstr = {\"productlist\":[{\"id\":product.id,\"name\":product.name,\"num\":product.num,\"price\":product.price}],\"totalNumber\":product.num,\"totalAmount\":(product.price*product.num)};            utils.setParam(\"ShoppingCart\",\"'\"+JSON.stringify(jsonstr));        }else{            var jsonstr = JSON.parse(ShoppingCart.substr(1,ShoppingCart.length));            var productlist = jsonstr.productlist;            var result=false;\t\t\t//查找购物车中是否有该商品            for(var i in productlist){                if(productlist[i].id==product.id){                    productlist[i].num=parseInt(productlist[i].num)+parseInt(product.num);                    result = true;                }            }            if(!result){\t\t\t\t//没有该商品就直接加进去                productlist.push({\"id\":product.id,\"name\":product.name,\"num\":product.num,\"price\":product.price});            }\t\t\t//重新计算总价            jsonstr.totalNumber=parseInt(jsonstr.totalNumber)+parseInt(product.num);            jsonstr.totalAmount=parseFloat(jsonstr.totalAmount)+(parseInt(product.num)*parseFloat(product.price));            orderdetail.totalNumber = jsonstr.totalNumber;            orderdetail.totalAmount = jsonstr.totalAmount;            //保存购物车            utils.setParam(\"ShoppingCart\",\"'\"+JSON.stringify(jsonstr));        }    },    //修改给买商品数量    updateproductnum:function(id,num){        var ShoppingCart = utils.getParam(\"ShoppingCart\");        var jsonstr = JSON.parse(ShoppingCart.substr(1,ShoppingCart.length));        var productlist = jsonstr.productlist;                for(var i in productlist){            if(productlist[i].id==id){                jsonstr.totalNumber=parseInt(jsonstr.totalNumber)+(parseInt(num)-parseInt(productlist[i].num));                jsonstr.totalAmount=parseFloat(jsonstr.totalAmount)+((parseInt(num)*parseFloat(productlist[i].price))-parseInt(productlist[i].num)*parseFloat(productlist[i].price));                productlist[i].num=parseInt(num);                                orderdetail.totalNumber = jsonstr.totalNumber;                orderdetail.totalAmount = jsonstr.totalAmount;                utils.setParam(\"ShoppingCart\",\"'\"+JSON.stringify(jsonstr));                return;            }        }    },    //获取购物车中的所有商品    getproductlist:function(){        var ShoppingCart = utils.getParam(\"ShoppingCart\");        var jsonstr = JSON.parse(ShoppingCart.substr(1,ShoppingCart.length));        var productlist = jsonstr.productlist;        orderdetail.totalNumber = jsonstr.totalNumber;        orderdetail.totalAmount = jsonstr.totalAmount;        return productlist;    },    //判断购物车中是否存在商品    existproduct:function(id){        var ShoppingCart = utils.getParam(\"ShoppingCart\");        var jsonstr = JSON.parse(ShoppingCart.substr(1,ShoppingCart.length));        var productlist = jsonstr.productlist;        var result=false;        for(var i in productlist){            if(productlist[i].id==product.id){                result = true;            }        }        return result;    },    //删除购物车中商品    deleteproduct:function(id){        var ShoppingCart = utils.getParam(\"ShoppingCart\");        var jsonstr = JSON.parse(ShoppingCart.substr(1,ShoppingCart.length));        var productlist = jsonstr.productlist;        var list=[];        for(var i in productlist){            if(productlist[i].id==id){                jsonstr.totalNumber=parseInt(jsonstr.totalNumber)-parseInt(productlist[i].num);                jsonstr.totalAmount=parseFloat(jsonstr.totalAmount)-parseInt(productlist[i].num)*parseFloat(productlist[i].price);            }else{                list.push(productlist[i]);            }        }        jsonstr.productlist = list;        orderdetail.totalNumber = jsonstr.totalNumber;        orderdetail.totalAmount = jsonstr.totalAmount;        utils.setParam(\"ShoppingCart\",\"'\"+JSON.stringify(jsonstr));    }}; 使用也很简单： var product ={\t'id': id,        //属性名用引号括起来，属性间由逗号隔开\t'name': 'hhh',\t'num':jq('#text-4').val(),\t'price':199.9};//商品加入到购物车cart.addproduct(product);var productlist=cart.getproductlist();//取出购物车商品alert('', '商品:'+productlist[0].id+' '+productlist[0].name+' '+productlist[0].num+' '+productlist[0].price, '确定');","title":"基于html5 localStorage的购物车JS脚本"},{"content":"     1. 首先安装qtcreator（qt-creator-windows-opensource-2.6.0.exe），是Qt的集成开发环境，安装后并没有Qt Gui 应用程序的选项，必须安装Qt的library，提供对创建Qt应用程序的支持。（Qt开发环境不像vs那样安装开发环境的同时提供相应的Library的支持，因此必须手动安装并配置）      2. 安装minGW（MinGW-gcc440_1，直接解压） [minGW的作用From Baiduzhidao：MinGW和VC一样，是一个开发环境。开发QT用MinGW是因为QT是Linux环境下的一个图形库，用来开发图形界面的应用程序，而Windows环境开发图形界面应用程序不需要QT，但是为了不大量修改源代码，就要把QT移植到Win下。(实事上，开发QT也可以用VC，不过需要用源代码重新编译QT库，开始的时候不那么方便。MinGW因为也是从Linux下移植过来了（当然在Linux下不叫MinGW），所以有相应的编译好了的QT库，直接用就可以了。]      3. 安装qt-win-opensource-4.8.4-mingw，提供对Qt 创建的支持。安装过程中提示minGW的安装路径，选择第2步的路径，安装后将出现qt design 的可视化界面开发工具。 配置Qt开发环境： 打开Qt Creator，(1). 工具->选项->构建和运行，“QT版本”中选择“手动设置”，然后添加第3步安装的d:\\Qt\\4.8.2\\bin\\qmake.exe；                             (2). 切换到“工具链”，选择“手动设置”，然后添加第1步安装的d:\\Qt\\mingw\\bin\\mingw32-g++.exe； 好了，现在Qt 的开发环境已经搭建完成了，写一写Qt应用程序试试吧。","title":"Qt的开发环境的搭建"},{"content":"1.百度地图例子: http://download.csdn.net/detail/yizhe25763/4452900 2.Android 闹钟源码:  http://download.csdn.net/detail/yizhe25763/4479270 3.MySeekBar自定义： http://download.csdn.net/detail/yizhe25763/4486506 4.SeekBar与系统音量同步： http://download.csdn.net/detail/yizhe25763/4486510 5.定时关闭程序： http://download.csdn.net/detail/yizhe25763/4486513 6.滚动视图： http://download.csdn.net/detail/yizhe25763/4486515 7.SpinnerDemo：http://download.csdn.net/detail/yizhe25763/4486518 8.获取当前分辨率： http://download.csdn.net/detail/yizhe25763/4486522 9.仿搜狐应用滑动广告源代码：http://download.csdn.net/detail/yizhe25763/4486617 10.aidl跨进程调用： http://download.csdn.net/detail/yizhe25763/4676953 11.Android模仿乐淘的应用程序： http://download.csdn.net/detail/yizhe25763/4676959 12.Android有未接来电后处理（判断未接来电）: http://download.csdn.net/detail/yizhe25763/4676969 13.Android与JS交互： http://download.csdn.net/detail/yizhe25763/4676973 14.Android远程登录含有Loading登录效果：http://download.csdn.net/detail/yizhe25763/4676975 15.Android在Wifi下手机与电脑的Scoket通信： http://download.csdn.net/detail/yizhe25763/4676983 16.Android中监听电话状态：http://download.csdn.net/detail/yizhe25763/4676990 17.Android自动发送短信： http://download.csdn.net/detail/yizhe25763/4676993 18.Android自动开关机实现： http://download.csdn.net/detail/yizhe25763/4676994 19.BrewClock闹钟： http://download.csdn.net/detail/yizhe25763/4677003 20.cellmap v2.0 基站查询定位导航系统：http://download.csdn.net/detail/yizhe25763/4677005 21.Android去除边框： http://download.csdn.net/detail/yizhe25763/4677009 22.FiveChess五子棋：http://download.csdn.net/detail/yizhe25763/4677011 22.Flashlight灯光：http://download.csdn.net/detail/yizhe25763/4677013 23.ImageView图片循环跑马灯效果： http://download.csdn.net/detail/yizhe25763/4677016 23.MiniTwitter登录界面： http://download.csdn.net/detail/yizhe25763/4677018 24.OPENG开始示例代码：http://download.csdn.net/detail/yizhe25763/4677019 25.OssSystem（OA系统图书管理简单版）：http://download.csdn.net/detail/yizhe25763/4677021 26.ProgressBar几乎全部的用法：http://download.csdn.net/detail/yizhe25763/4677026 27.QQ_UI之分类菜单：http://download.csdn.net/detail/yizhe25763/4677030 28.QQ登录界面源代码： http://download.csdn.net/detail/yizhe25763/4677031 29.客户端连接服务器并交互实例：http://download.csdn.net/detail/yizhe25763/4677036 30.口袋微博服务器 客户端代码： http://download.csdn.net/detail/yizhe25763/4677039 31.模仿Engadget菜单：http://download.csdn.net/detail/yizhe25763/4677041 32.SeeJoPlayer播放器：http://download.csdn.net/detail/yizhe25763/4677791 33.TableLogin登陆界面：http://download.csdn.net/detail/yizhe25763/4677794 34.坦克大战代码：http://download.csdn.net/detail/yizhe25763/4677800 35.UI设计之仿蘑菇街：http://download.csdn.net/detail/yizhe25763/4677801","title":"android 经典源码库地址"},{"content":"    关于进程的内存占用情况查询，大家可以参考国外论坛的一个帖子（http://stackoverflow.com/questions/2298208/how-to-discover-memory-usage-of-my-application-in-android），这个帖子在国内被转载颇多，很有参考价值，因为其中对\"Pss\"， \"PrivateDirty\"和 \"SharedDirty\"的概念做了一定阐述，使大家看到这几个参数时不会云里雾里。     后面跟帖中也有打印进程内存使用情况的代码，还附有跟帖人对那段代码的疑问，代码如下。代码中打印信息的循环看似多余，明显，由于输入数组pids[]只有一个元素，返回的memoryInfoArray[]数组也只会含有一个元素，那段循环的意义就只有增强代码的可扩展性了。 ActivityManager activityManager = (ActivityManager) context.getSystemService(ACTIVITY_SERVICE);MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();activityManager.getMemoryInfo(memoryInfo);Log.i(TAG, \" memoryInfo.availMem \" + memoryInfo.availMem + \"\\n\" );Log.i(TAG, \" memoryInfo.lowMemory \" + memoryInfo.lowMemory + \"\\n\" );Log.i(TAG, \" memoryInfo.threshold \" + memoryInfo.threshold + \"\\n\" );List<RunningAppProcessInfo> runningAppProcesses = activityManager.getRunningAppProcesses();Map<Integer, String> pidMap = new TreeMap<Integer, String>();for (RunningAppProcessInfo runningAppProcessInfo : runningAppProcesses){    pidMap.put(runningAppProcessInfo.pid, runningAppProcessInfo.processName);}Collection<Integer> keys = pidMap.keySet();for(int key : keys){    int pids[] = new int[1];    pids[0] = key;    android.os.Debug.MemoryInfo[] memoryInfoArray = activityManager.getProcessMemoryInfo(pids);    for(android.os.Debug.MemoryInfo pidMemoryInfo: memoryInfoArray)    {        Log.i(TAG, String.format(\"** MEMINFO in pid %d [%s] **\\n\",pids[0],pidMap.get(pids[0])));        Log.i(TAG, \" pidMemoryInfo.getTotalPrivateDirty(): \" + pidMemoryInfo.getTotalPrivateDirty() + \"\\n\");        Log.i(TAG, \" pidMemoryInfo.getTotalPss(): \" + pidMemoryInfo.getTotalPss() + \"\\n\");        Log.i(TAG, \" pidMemoryInfo.getTotalSharedDirty(): \" + pidMemoryInfo.getTotalSharedDirty() + \"\\n\");    }}   在看到上述代码之前，自己按照API说明也写了类似代码如下，包含了更多的输出参数。如果要检查其他进程的内存使用情况，可略去循环中的条件判断。按stackoverflow.com中帖子的说法 Pss的值是最能表明进程使用内存状况 public long getmem_SELF() {        ActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);        List<RunningAppProcessInfo> procInfo = am.getRunningAppProcesses();        for (RunningAppProcessInfo runningAppProcessInfo : procInfo) {          \tSystem.out.println(runningAppProcessInfo.processName+ String.format(\",pid = %d\", runningAppProcessInfo.pid));          \tif( runningAppProcessInfo.processName.indexOf(this.getPackageName()) != -1 )        \t{        \t\tint pids[] = {runningAppProcessInfo.pid};        \t\tDebug.MemoryInfo self_mi[] = am.getProcessMemoryInfo(pids);        \t\tStringBuffer  strbuf = new StringBuffer();        \t\tstrbuf.append(\" proccess Name:\").append(runningAppProcessInfo.processName)        \t\t\t.append(\"\\n pid:\").append(runningAppProcessInfo.pid)        \t\t\t.append(\"\\n dalvikPrivateDirty:\").append(self_mi[0].dalvikPrivateDirty)\t    \t\t\t.append(\"\\n dalvikPss:\").append(self_mi[0].dalvikPss)\t    \t\t\t.append(\"\\n dalvikSharedDirty:\").append(self_mi[0].dalvikSharedDirty)\t    \t\t\t.append(\"\\n nativePrivateDirty:\").append(self_mi[0].nativePrivateDirty)\t    \t\t\t.append(\"\\n nativePss:\").append(self_mi[0].nativePss)\t    \t\t\t.append(\"\\n nativeSharedDirty:\").append(self_mi[0].nativeSharedDirty)\t    \t\t\t.append(\"\\n otherPrivateDirty:\").append(self_mi[0].otherPrivateDirty)\t    \t\t\t.append(\"\\n otherPss:\").append(self_mi[0].otherPss)\t    \t\t\t.append(\"\\n otherSharedDirty:\").append(self_mi[0].otherSharedDirty)\t    \t\t\t.append(\"\\n TotalPrivateDirty:\").append(self_mi[0].getTotalPrivateDirty())\t    \t\t\t.append(\"\\n TotalPss:\").append(self_mi[0].getTotalPss())\t    \t\t\t.append(\"\\n TotalSharedDirty:\").append(self_mi[0].getTotalSharedDirty());        \t\tLog.v(\"TEST\",strbuf.toString());        \t}\t}\treturn 0;} 翻译：\"Pss\"， \"PrivateDirty\"和 \"SharedDirty\"有什么区别    Android（亦即Linux）中，大量内存实际由多个进程共享，所以一个进程实际占用多少内存并不明确。甚至不太清楚哪些分页被添加到磁盘。     这样，要是你要获取所有实际映射在每个进程的物理内存值，然后试图加总求和，你可能会得到一个远大于实际内存总量的值。     Pss是考虑共享内存的内核计算尺度 -- 基本上一个进程的每个内存页面被按一个比率缩减，这个比率和同样使用该页面的其他进程的数量有关。理论上你可以累计所有进程的Pss占用量来检查所有进程的内存占用量，也可以比较进程的Pss来大致发现进程各自的权重。     另一个有趣的参数是PrivateDirty，它基本上是进程内不能被分页到磁盘的内存，也不和其他进程共享。查看进程的内存用量的另一个途径，就是当进程结束时刻，系统可用内存的变化情况（也可能会很快并入高速缓冲或其他使用该内存区的进程，[微笑这样一来，企图就落空了：-）]）。 原文 But as to what the difference is between \"Pss\", \"PrivateDirty\", and \"SharedDirty\"... well now the fun begins. A lot of memory in Android (and Linux systems in general) is actually shared across multiple processes. So how much memory a processes uses is really not clear. Add on top of that paging out to disk (let alone swap which we don't use on Android) and it is even less clear. Thus if you were to take all of the physical RAM actually mapped in to each process, and add up all of the processes, you would probably end up with a number much greater than the actual total RAM. The Pss number is a metric the kernel computes that takes into account memory sharing -- basically each page of RAM in a process is scaled by a ratio of the number of other processes also using that page. This way you can (in theory) add up the pss across all processes to see the total RAM they are using, and compare pss between processes to get a rough idea of their relative weight. The other interesting metric here is PrivateDirty, which is basically the amount of RAM inside the process that can not be paged to disk (it is not backed by the same data on disk), and is not shared with any other processes. Another way to look at this is the RAM that will become available to the system when that process goes away (and probably quickly subsumed into caches and other uses of it).","title":"如何获取进程内存使用情况"},{"content":"背景 熟悉MYSQL编程的都比较清楚，对于结果集一般都是 while(rs.next()){    ......................} native-mysql给出来的结果集和这个差距较大，从百度的几个结果都是使用 res.on('row', function(r) { \t\tlog.info( 'read.....');});在回调函数里面就可以取出每一条数据继续操作， 那查询没有结果呢，怎么办？ 解决办法 通过查看node_modules下的command.js，发现是存放到result里面 在看examples目录下，有这样的代码 'test select no results': function(cb) {    var db = createConnection();    var sql = 'SELECT * FROM tbl WHERE id = 1000000000'    db.query(sql).addListener('resulti', function(r) {      assert.ok(r.rows.length == 0)    }).addListener('end', function() {      db.close();      cb();    })  }, 那综合看，可以用下面的方法来处理     var sql = 'SELECT * FROM users'    dbConn.query(sql).addListener('end', function() {         log.info(\"end \"+this.result.rows.length);\t log.info(\"end \"+this.result.rows[0][0]);   ///如果有结果，就这么取，之前需要判断。     }) 在end方法里面，对result进行引用，很细粒度的控制。 特别说明 native-mysql只适合小数据结集的操作，所以千万不要返回很多数据，通过条件加以控制。把负载留给mysql。","title":"node.js mysql-native 判断结果集合大小"},{"content":"wireless driver中要实现控制开发板中的gpio的led灯，需要知道gpio的定义管脚地址，在driver中控制其亮与灭，设计到wireless运行原理，以及kernel编程。 首先wireless的连接建立过程，找出在哪里建立连接，然后设置led灯的亮，在哪里断开连接，设置led灯的灭。 这里面有点不懂的就是其使用了内核定时器。 struct timer_list; 这个我前面转载的文章中有介绍如何使用，其实现了传输数据时的led闪烁。至于，wireless连接是否完成需要深入去学习，jiffies+10这个是立即点亮led吗？ 我需要查看arm的hz值才能确定每秒种的节拍数从而确定是多久。 根据目前的debug的信息，当led那点的信息输出的时候，我们的led灯并没有立即点亮，wireless网卡也没有抓到包，过了大概有两三秒的样子，是否抓包有delay?需要在发送包的位置添加debug信息。 做关于driver的编程真的很有意思，嘿嘿。","title":"ralink wireless driver中控制开发板gpio LED灯的亮灭"},{"content":"现在越来越多的手机开始支持HTML5等一些新技术，原本只能通过图片和Flash来实现的东西，可以通过HTML5来实现了。但是我们给用户的WAP站的入口只有一个，这就需要判别手机操作系统和手机浏览器后，自动跳转到适合的版本（3G版或者触屏版）。 验证跳转的效果，我们可以通过手机来进行测试，但是仅仅为了测试这个功能，拿那么多手机来测试，个人感觉太过于浪费，况且我们的手头的测试手机也不可能一下子就那么齐全，因此我们可以借助浏览器的User_Agent切换的工具。本人用的是Chrome浏览器下的User_Agent Switcher插件，通过这个插件可以模拟不同的浏览器头（当然，这个只是模拟了浏览器头，浏览器的内核是不会有任何变化的）。","title":"WAP站开发之3G版、触屏版跳转验证工具"},{"content":"本文译自：http://developer.android.com/training/basics/supporting-devices/languages.html#UseString 从你的应用程序代码中把UI的字符串提取到一个外部文件中是一个很好的实践，Android系统在每个Android工程中用一个资源目录让这件事变的很容易。 如果你使用Android的SDK工具创建工程，该工具会在工程的顶层创建一个叫res/的目录。在这个res/的目录中是各种资源类型的子目录。还有一些默认的文件，如res/values/strings.xml，该文件会保存字符串值。 创建语言目录和字符串文件 要添加对多语言的支持，就要在res/目录中添加一个包含连字符和ISO国家代码结尾的values目录，如，values-es/就是一个包含了语言编码是“es”的地区字符资源的目录。Android系统会在运行时，根据语言设置来加载对应的资源。 一旦你决定了你要支持的语言，就要创建资源子目录和字符串资源文件，如： MyProject/     res/        values/            strings.xml        values-es/            strings.xml        values-fr/            strings.xml 把每种语言的字符串值添加到对应的文件中。 在运行时，Android系统会根据用户设备当前的语言设置，使用对应的字符串资源。 例如，以下是不同语言的字符串资源文件。 英语（默认语言编码），/values/strings.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <resources>     <string name=\"title\">My Application<\/string>     <string name=\"hello_world\">Hello World!<\/string> <\/resources> 西班牙语，/values-es/strings.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <resources>     <string name=\"title\">Mi Aplicación<\/string>     <string name=\"hello_world\">Hola Mundo!<\/string> <\/resources> 法语，/values-fr/strings.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <resources>     <string name=\"title\">Mon Application<\/string>     <string name=\"hello_world\">Bonjour le monde !<\/string> <\/resources> 注意：你可以在任何类型的资源目录上使用语言限定符，如提供本地化的位图资源。 使用字符串资源 你可以在你资源代码和其他的XML文件中，使用<string>元素的name属性定义的名称来引用你的字符串资源。 在你的源代码中，你可以用R.string.<string_name>的语法来引用字符串资源。有很多方法，用这种语法方式来接收字符串资源，如： // Get a string resource from your app's Resources String hello = getResources().getString(R.string.hello_world);   // Or supply a string resource to a method that requires a string TextView textView = new TextView(this); textView.setText(R.string.hello_world); 在其他的XML文件中，你可在任何接收字符串值的XML属性中，使用@string/<string_name>语法形式来引用字符串资源，如： <TextView     android:layout_width=\"wrap_content\"     android:layout_height=\"wrap_content\"     android:text=\"@string/hello_world\"/>    ","title":"Android培训---支持不同的语言"},{"content":"下面是一条跳转指令,代码这里不贴，但是其中的代码很重要，在lowlevel.S中实现比如说点亮LED灯、关闭watchdog、关闭中断、串口初始化、系统时钟初始、nand flash初始化、内存控制器初始化。不过说实在的，去仔细分析这些初始化的过程，对于你对如何控制硬件有很大的帮 助， 对于这个函数，所要说的东西太多，会在后面的文章中单独分析它，现在先知道功能就好，没有它代码无法启动。 */ -------------------- bllowlevel_init --------------------   /* 跳转出来以后，继续执行下面的代码，下面的代码是判断程序是否已经在ram中了，在的话就不拷贝，直接跳转到stack_setup了，否则    继续执行copy_loop */ -------------------- #ifndefCONFIG_SKIP_RELOCATE_UBOOT relocate:                       @relocate U-Boot to RAM        adr   r0,_start        @r0 <- current position of code        ldr   r1,_TEXT_BASE         @ test if we run from flash or RAM        cmp r0,r1                    @ don't reloc during debug        beq  stack_setup          ..........................................   copy_loop:                          @copy 32 bytes at a time        ldmia      r0!,{r3 - r10}              @ copy from source address [r0]        stmia       r1!,{r3 - r10}              @ copy to   targetaddress [r1]        cmp r0,r2                    @ until source end addreee [r2]        ble   copy_loop #endif     /* CONFIG_SKIP_RELOCATE_UBOOT */ --------------------   --------------------   /*    堆栈初始化代码 */ --------------------  /* Set up the stack          */ stack_setup: ldr r0, _TEXT_BASE  /* upper 128 KiB:relocated uboot   */  sub r0, r0, #CFG_MALLOC_LEN /* mallocarea                      */  sub r0, r0, #CFG_GBL_DATA_SIZE /*bdinfo                        */ #ifdef CONFIG_USE_IRQ  sub r0, r0,#(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ) #endif  sub  sp, r0, #12 /* leave 3 words for abort-stack   */  and         sp, sp, #~7         @ 8 byte alinged for (ldr/str)d #endif --------------------   /* 清零BSS段内容为0 */ -------------------- clear_bss:  ldr r0, _bss_start  /* find start of bss segment        */  ldr r1, _bss_end  /* stop here                        */  mov r2, #0x00000000  /* clear                            */ clbss_l:  str  r2, [r0]             @ clear BSS location  cmp r0, r1                  @are we at the end yet  add       r0, r0, #4             @ increment clear index pointer  bne       clbss_l                 @ keep clearing till at end --------------------   /* 跳转到uboot代码的第二个阶段，第二阶段基本上都是用C实现的，幸好前面sp的值已经设置好了 */ --------------------  ldr pc, _start_armboot _start_armboot:.word start_armboot --------------------","title":"smdkc100之u-boot 2010.03代码的分析2"},{"content":"升级的时候，需要搞个提示，加个键盘控制神马的。 所以，咱得把这个键盘加到Eboot里面。 由于Eboot里面使用不了这个中断，所以只能使用扫描按键的方式。 按键接的是： 行：GPK8~GPK13 列：GPL0~GPL4（这里只需要使用到一列就够了，就使用GPL0吧，这样就有6个按键了） 参照键盘驱动KeyPad，这里把其简化，分成初始化和循环扫描处理，按键识别三部分。 使用的时候，咱先初始化一下键盘： 调用 ret = InitKey(); 初始化成功后，在循环里面调用 KScan_Proc(); 去检测按键按下，接着再通过 keyValue = GetKeyDown(); 去获取按下的按键，然后做识别处理。 6个按键，根据行列扫描后的键值，定义如下：（Key.h） #define\t\tKEY_ENTER\t\t(0x1)#define\t\tKEY_SCAN\t\t(0x2)#define\t\tKEY_CANCEL\t\t(0x4)#define\t\tKEY_DELETE\t\t(0x8)#define\t\tKEY_BACKSPACE\t(0x10)#define\t\tKEY_UP\t\t\t(0x20) Key.c的实现如下： // *** you add ***// for 6410 key.// use row0 & col0~col5#include \"Key.h\"#include <windows.h>#include \"Winbase.h\"#include <oal.h>#include <s3c6410.h>//#ifdef _KEY_H_//#define _KEY_H_// define#define\t\tSIZE_COLS\t1#define\t\tKEYIF_Row_Read\t(pKeyPadReg->KEYIFROW)// KEYIFCON#define\t\tFC_EN_DIS            (0<<3)#define\t\tFC_EN_EN             (1<<3)#define\t\tDF_EN_DIS            (0<<2)#define\t\tDF_EN_EN             (1<<2)#define\t\tINT_R_ENABLE         (0<<1)#define\t\tINT_R_DISABLE        (1<<1)#define\t\tINT_F_ENABLE         (0<<0)#define\t\tINT_F_DISABLE        (1<<0)// KEYIFFC#define\t\tFC_DIV_VAL(n)        (((n)&0x3ff)<<0)#define\t\tKEY_POWER_ON   (1<<11)                      // PCLKCON#ifndef FIN#define FIN        12000000#endif#define\t\tFT_CLK_DIV     (FIN/32000 - 1)// KEYIFSTSCLR#define\t\tCLEAR_P_INT            (0xFF<<0)#define\t\tCLEAR_R_INT            (0xFF<<8)// global variablevolatile S3C6410_GPIO_REG *pGPIOReg2 = NULL;volatile S3C6410_KEYPAD_REG *pKeyPadReg = NULL;volatile S3C6410_SYSCON_REG *pSysConReg = NULL;DWORD KeyState[SIZE_COLS];// functionBOOL InitKey();void KScan_Proc();DWORD GetKeyDown();void ClearKey();BOOL InitKey(){    // GPIO Virtual alloc    pGPIOReg2 = (S3C6410_GPIO_REG *)OALPAtoVA(S3C6410_BASE_REG_PA_GPIO, FALSE);\tif(pGPIOReg2 == NULL)\treturn FALSE;    // Keypad Virtual alloc    pKeyPadReg = (S3C6410_KEYPAD_REG *)OALPAtoVA(S3C6410_BASE_REG_PA_KEYPAD, FALSE);\tif(pKeyPadReg == NULL)\treturn FALSE;    // Syscon Virtual alloc    pSysConReg = (S3C6410_SYSCON_REG *)OALPAtoVA(S3C6410_BASE_REG_PA_SYSCON, FALSE);\tif(pSysConReg == NULL)\treturn FALSE;\t// enable the Keypad Clock (PCLK)\tpSysConReg->PCLK_GATE |= KEY_POWER_ON;\tpKeyPadReg->KEYIFCON = INT_F_DISABLE|INT_R_DISABLE|DF_EN_EN|FC_EN_DIS;\t//Keypad interfae debouncing filter clock division register\tpKeyPadReg->KEYIFFC = FC_DIV_VAL(FT_CLK_DIV);\tpKeyPadReg->KEYIFCOL = (0x00<<8);\t// select all column - Set Keypad column GPIO to output(low)\t//pGPIOReg2->GPLCON0=(pGPIOReg2->GPLCON0 & ~(0xfffff<<0)) | (0x33333<<0);    //KBC_0(GPL0)~ KBC_4(GPL4)\tpGPIOReg2->GPLCON0=(pGPIOReg2->GPLCON0 & ~(0xf<<0)) | (0x3<<0);\t\t\t\t//KBC_0(GPL0)\tpKeyPadReg->KEYIFCOL = (0x0 & 0xff);\t// configure - Set Keypad row GPIO to [Key PAD ROW]\tpGPIOReg2->GPKCON1=(pGPIOReg2->GPKCON1 & ~(0xffffff<<0)) | (0x333333<<0);    //KBR_0(GPK8)~ KBR_5(GPK13)\t// unmask the key interrupt\tpKeyPadReg->KEYIFSTSCLR = CLEAR_P_INT|CLEAR_R_INT;    // Clear Pressed/Released Interrupt\treturn TRUE;}void KScan_Proc(){\tint i=0;\tvolatile int m=0;\t// Read the Matrix\t// KBC_0 ~ KBC_7\tfor(i = 0 ; i < SIZE_COLS; i++){\t\tpKeyPadReg->KEYIFCOL = (0x0 & 0xff);\t\t// select a column\t\tpKeyPadReg->KEYIFCOL = pKeyPadReg->KEYIFCOL | (0xff & ~(0x1 << i));\t\tfor(m=0; m<2000; m++);\t\tKeyState[i] = (~KEYIF_Row_Read) & 0xff;\t\tfor(m=0; m<2000; m++);\t}\tpKeyPadReg->KEYIFCOL = (0x0 & 0xff);}DWORD GetKeyDown(){\tDWORD key = 0x0;\tint i=0;\tfor(i = 0 ; i < SIZE_COLS; i++){\t\tif(KeyState[i] & KEY_ENTER)\tkey |= KEY_ENTER;\t\tif(KeyState[i] & KEY_SCAN)\tkey |= KEY_SCAN;\t\tif(KeyState[i] & KEY_CANCEL)\tkey |= KEY_CANCEL;\t\tif(KeyState[i] & KEY_DELETE)\tkey |= KEY_DELETE;\t\tif(KeyState[i] & KEY_BACKSPACE)\tkey |= KEY_BACKSPACE;\t\tif(KeyState[i] & KEY_UP)\tkey |= KEY_UP;\t}\treturn key;}void ClearKey(){\tmemset(KeyState, 0, sizeof(KeyState)/sizeof(DWORD));}//#endif 特此记录一下。 仅供参考，请勿模仿~~ 若存在错误，请大家指出","title":"6410 Eboot 添加键盘控制"},{"content":"Notification图标设置问题 只设置Notification.icon的话，状态栏和拉开状态栏后的显示区域都使用这个值。 只设置contentView，不设置Notification.icon或者Notification.ticker的话，状态栏不显示一开始的滚动信息 既设置Notification.icon又设置contentView的话，状态栏显示Notification.icon和Notification.ticker，拉开状态栏后显示contentView。 这里有一个需要注意的地方，只设置Notification.icon，不设置contentView的话，有的系统会在拉开状态栏显示Notification.icon时，对Notification.icon进行加工。目前在MIUI上发现了这个问题。 结论：弹出Notification的话，最后使用统一的工具来弹。 另外：Notification.icon在不同的drawable下尺寸有系统规定的值，不要人为设死一个icon资源。","title":"Notification icon问题"},{"content":"一、文档简介： 本文档用于介绍1B开发板+GSM模块发送彩信的实现过程，以及彩信MMS协议封装过程。 开发环境参数： 操作系统：Ubuntu 11.04 本机平台：X86 目标平台：Loongson 1B 开发板+华为GSM模块MG323 交叉编译工具链：gcc-3.4.6-2f（1B交叉编译工具链） 所需软件及工具包： 1b-linux-3.0内核git版本号：115a0a040ffdaaba5f3afa58cb08625020d3fde8 PPP工具源码包：ppp-2.4.5.tar.gz 二、实现过程 1.实现步骤： A. 开发板上PPP连接GPRS上网 B. 与移动网关建立TCP-Socket连接 C. 封装MMS-PDU数据包 D. 封装HTTP-POST数据包 E. 发送HTTP报文至移动网关 F. 接收网关回复信息 2.开发板上PPP连接GPRS上网 首先配置kernel使它支持如下PPP选项： Make menuconfig--->Device Drivers--->Network device support---> PPP(point-to-point) support PPP multilink support(EXPERIMENTAL) PPP support for async serial prots PPP support for sync tty ports PPP Deflate compression PPP BSD-Compress compression 接下来编译交叉编译ppp-2.4.5。 编译完成后将./pppd/pppd, ,/chat/chat, ./pppdump/pppdump, ./pppstats/pppstats四个文件拷贝到1B开发板文件系统的/usr/sbin目录下，并将他们的文件属性改为755。 检查/etc/host.conf脚本，确保这一行：order hosts,bind 在1B开发板文件系统/etc/ppp目录下建立如下四个PPP配置文件： File1：/etc/ppp/peers/gprs #/etc/ppp/peers/gprs # Usage:   root>pppd call gprs /dev/ttyS0   #改成自己的GSM模块设备号 115200    #改成自己串口波特率 nocrtscts  #可能你的串口是需要crtscts，硬件流控的，这是由你的串口决定的，一般嵌入式系统的串口没有带硬件流控，也不需要就加nocrtscts modem   #这个参数使得pppd进程将等待模块发回的CD (Carrier Detect)信号，与local真好相反 #noauth debug  #把调试信息输出到/var/log/messages，在调试成功后去掉它，以减少垃圾的产生。 nodetach  #hide-password usepeerdns  #以下的3个参数一般不可少 noipdefault defaultroute  user \"cmnet\"  #设置接入的用户名，在chap-secrets或者pap-secets中使用 0.0.0.0:0.0.0.0  #本地和远端的ip都设为0使得接入的isp分配本地的ip地址 ipcp-accept-local  #要求peer也就是isp给自己非配动态的IP地址 #ipcp-accept-remote #lcp-echo-failure  12 #lcp-echo-interval 3 noccp  #不需要压缩控制协议，有可能对端不需要，根据自己的isp的情况 #novj #novjccomp persist  #保证在连接断开的情况下不退出，并尝试重新打开连接 connect '/usr/sbin/chat -s -v -f /etc/ppp/gprs-connect-chat'  #pppd调用chat会话进程接入对端isp，启动对端的pppd，然后本地pppd与对端的pppd一起进行协 #商网络参数和chap/pap认证，成功后，再进行ncp层的ip的分配。 File2：/etc/ppp/gprs-connect-chat #/etc/ppp/gprs-connect-chat #chat script for China Mobile, used wavecom module by lee. TIMEOUT 15 ABORT '\\nDELAYED\\r' ABORT '\\nBUSY\\r' ABORT '\\nERROR\\r' ABORT '\\nNO DIALTONE\\r' ABORT '\\nNO CARRIER\\r' '' \\rAT OK ATS0=0 OK ATE0V1 OK AT+CGDCONT=1,\"IP\",\"CMWAP\" OK ATDT*99***1# CONNECT '' File3：/etc/ppp/chap-secrets #cat /etc/ppp/chap-secrets #client server secret IP address \"cmnet\" * \"cmnet\" * File4：/etc/ppp/pap-secrets #cat /etc/ppp/pap-secrets # Secrets for authentication using PAP# client server secret IP addresses ######## redhat-config-network will overwrite this part!!! (begin) ########## ######## redhat-config-network will overwrite this part!!! (end) ############ \"cmnet\" * \"cmnet\" * 完成以上配置，然后在板上执行以下指令就能实现PPP连接GPRS了： [root@Loongson-gz:/]#pppd call gprs & [root@Loongson-gz:/]#ifconfig ppp0      Link encap:Point-to-Point Protocol             inet addr:10.55.53.150  P-t-P:192.200.1.21  Mask:255.255.255.255           UP POINTOPOINT RUNNING NOARP MULTICAST  MTU:1500  Metric:1           RX packets:4 errors:0 dropped:0 overruns:0 frame:0           TX packets:5 errors:0 dropped:0 overruns:0 carrier:0           collisions:0 txqueuelen:3            RX bytes:58 (58.0 B)  TX bytes:98 (98.0 B) [root@Loongson-gz:/]#ping 10.0.0.172 PING 10.0.0.172 (10.0.0.172): 56 data bytes 64 bytes from 10.0.0.172: seq=0 ttl=252 time=556.702 ms 64 bytes from 10.0.0.172: seq=1 ttl=252 time=293.645 ms 64 bytes from 10.0.0.172: seq=2 ttl=252 time=492.732 ms 64 bytes from 10.0.0.172: seq=3 ttl=252 time=290.228 ms ^C --- 10.0.0.172 ping statistics --- 4 packets transmitted, 4 packets received, 0% packet loss round-trip min/avg/max = 290.228/408.326/556.702 ms 看到以上打印信息，就说明成功使用PPP拨通GSM模块的GPRS连接上网络。 3.MMS封装及发送过程 彩信和其它WAP应用的架构差不多，都要经过WAP Gateway中转，彩信在中国移动以及中国联通的GPRS接入点均一样，都是10.0.0.172的80端口或者9201端口。要注意的是彩信并非直接投递给接收方，而是像邮件一样，先发送给一个中间服务器MMS Proxy-Relay。MMS Proxy-Relay暂时保存彩信，然后通过push协议给彩信接收方发送一个通知，彩信接收方收到通知后从MMS Proxy-Relay上获取彩信内容。MMS Client和WAP Gateway之间用WAP传输协议传输，而WAP Gateway和MMS Proxy-Relay之间走传统的TCP/IP协议。 要实现发送彩信，作为客户端，我们需要完成的主要是与10.0.0.172建立TCP连接，将彩信数据包发送至WAP Gateway即可，其他部分工作由WAP Gateway与MMS Proxy-Relay自行完成。 将彩信数据包发送至WAP Gateway有两种实现方式，由于MMS是基于WAP协议的，移动的WAP代理服务器80/8080端口支持WAP2.0，可以采用HTTP方式传输数据；也可以通过WSP/WTP/WDP这一套传输协议传输数据，WAP代理服务器9201端口支持WSP/WTP/WDP协议。在这里我们选择的是HTTP方式。 以下是采用HTTP方式传输数据的数据包结构： 1 HTTP-HEADER HTTP-DATA 2 MMS-HEADER Message Body 接下来从MMS-PDU封装实现开始，主要参考MMS的编码协议文档《WAP-209-MMSEncapsulation-20010601-a.pdf》。 首先需要了解一下MMS PDU的结构，MMS PDU（Protocol Data Unit，协议数据单元）由MMS头和MMS消息体组成，MMS头由多个域名和域值组成，由客户端指定，MMS头里面的一些域可以被MMS Proxy-Replay修改或补充，MMS Proxy-Replay使用这些头域信息生成MM通知以及构造接收MM PDU中的相关头域，连同消息实体一同送往接收方。消息体跟在MMS头之后，大多数MMS PDU只含有MMS头，它们起到建立和维持通信的作用，只有在M-Send.req和M-Retrieve.conf PDU中才有消息体。MMS PDU和HTTP PDU极为类似，但要简单一些。一个MMS PDU对应一种消息格式。不同类型的MMS PDU有不同的MMS Header 。MMS Header根据由一系列的域组成，这些域定义了PDU的各种属性，包括PDU类型，版本号，接受方，发送方，主题，发送时间等。MMS Header中的域分为可选项和必选项，根据PDU的类型不同而不同。 常见的PDU的类型有： 发送请求:     M-send.req 发送确认:     M-send.conf 彩信通知:     M-notification.ind 通知回应:     M-notifyresp.ind 获取彩信回应: M-retrieve.conf 接收确认:     M-acknowledge.ind 彩信回执:     M-delivery.ind 而要实现发送彩信功能，我们需要完成一个M-send.req Message的封装。M-send.req Message由两部分组成，MMS Header后面接的是Message Body。根据MMS Message Body组装的是否有序（是否有位置控制信息，有显示先后顺序），M-send.req Message的组装方式分为: application/vnd.wap.multipart.mixed方式，所有的消息内容混合在一起，没有时间上的顺序，内容怎么显示由客户端的显示控制策略来决定。 application/vnd.wap.multipart.related方式，各消息内容之间有一定关系，该关系可能是显示的时间上的先后，显示的位置等。这样在终端显示该消息的时候，就可以以幻灯片的方式显示一系列消息。 我们仅需要简单实现文本以及图片的发送，所以选择application/vnd.wap.multipart.mixed组装方式。 根据协议文档，M-send.req Message Header由以下内容组成： Name Content Comments Value X-Mms-Message-Type Message-type-value=m-send-req Mandatory 0x0C X-Mms-Transaction-ID Transaction-id-value Mandatory 0x18 X-Mms-MMS-Version MMS-version-value Mandatory 0x0D Date Date-value Optional 0x05 From   From-value Mandatory 0x09 To To-value Optional 0x17 Cc Cc-value Optional 0x02 Bcc Bcc-value Optional 0x01 Subject Subject-value  Optional 0x16 X-Mms-Message-Class Message-class-value Optional 0x0A X-Mms-Expiry Expiry-value Optional 0x08 X-Mms-Delivery-Time Delivery-time-value Optional 0x07 X-Mms-Priority Priority-value Optional 0x0F X-Mms-Sender-Visibility Sender-visibility-value Optional 0x14 X-Mms-Delivery-Report Delivery-report-value Optional 0x06 X-Mms-Read-Reply Read-reply-value Optional 0x10 Content-Type Content-type-value Mandatory 0x04 在MMS-HEADER中，X-Mms-Message-Type ,X-Mms-Transaction-ID和X-Mms-MMS-Version必须位于MMS-HEADER的开始，并且按照前面所列的顺序。Content-Type必须在MMS-HEADER域的最后，其后为消息体，其它域的顺序可以随意安排。而为了使传输的数据更紧凑，MMS协议规定，对于Header Field Name的编码，数值的最高位（即bit7）置1。因此，上述编码值在实际的MMS PDU中需要加上0x80。  下面主要以一段MMS PDU数据为例进行分析各个域值： 8c  80  98  30  00  8d  90  89  01  81  97  2b  38  36  31  35  38  31  34  35  34  32  39  37  35  2f  54  59  50  45  3d  50  4c  4d  4e  00  96  74  65  73  74  00  84  a3  02  1c  0c  0a  83  85  31  2e  74  78  74  00  81  ea  c0  22  3c  31  2e  74  78  74  3e  00  8e  31  2e  74  78  74  00  4d  4d  53  20  42  79  20  45  74  68  61  6e  12  df  22  9d  c0  22  3c  31  2e  67  69  66  3e  00  8e  31  2e  67  69  66  00  ff  d8 ... ff  d9 8C：X-Mms-Message-Type 80：M-send.req 98：X-Mms-Transaction-ID 30  00：MMS Transaction ID为48 8D：X-Mms-Version 90：MMS Version值为1.0 89：From 发送方 01：后接一个字节数据  81：发送方号码占位符 97：To 接收方 2b  38  36  31  35  38  31  34  35  34  32  39  37  35  2f  54  59  50  45  3d  50  4c  4d  4e  00：接收方数据“+8615814542975/TYPE=PLMN ” 84：Content-Type a3：表示:application/vnd.wap.multipart.mixed组装方式  02：表示后接两部分内容数据 接下来讲述一下内容数据部分的结构： 每一部分的内容数据均由两部分组成，分别是Header+Data； 首先包含一个HeaderLen，用来指示ContentType域和Header域的总长度，是一个Uintvar变量； 接下来时DataLen，用来指示后面Data域的长度，在这里指的是一块多媒体数据的字节数； 然后是ContentType域用来表示后面的数据块是什么类型的数据（如txt文本，jpeg图片，还是vidoe数据流）； 再后边是Content Location和Content ID值，通常是多媒体数据的文件名，Content Location域以单引号\"开始，后面一对<>里面包含文件名，Content ID域则直接就是一对<>里面包含文件名； 最后接Data域，它的长度由DataLen指定； 1c  0c  0a  83  85  31  2e  74  78  74  00  81  ea  c0  22  3c  31  2e  74  78  74  3e  00  8e  31  2e  74  78  74  00  4d  4d  53  20  42  79  20  45  74  68  61  6e  ：第一段内容的Header+Data 1c：Header的长度为28字节 0c：Data的长度为12字节 0a：指明后边数据为txt文本类型 85 ~00：这段数据的指明文件名为1.txt 4d~6e：文本数据 12  df  22  9d  c0  22  3c  31  2e  67  69  66  3e  00  8e  31  2e  67  69  66  00  ff  d8 ... ff  d9  第二段内容的Header+Data 12：Header的长度为18字节 df 22：Data的长度为1219字节 HeaderLen和DataLen均是采用Uintvar变量，特点是对超过7bit的数值进行拆分，低7位存放数据，高位补1表示有后续，最大32bit。  9d：指明后边数据为gif格式，但是在测试过程中，发现jpg格式也可以发送成功并显示。 22 ~00：这段数据的指明文件名为1.gif ff~d9：图片数据，这是一张jpg图片 至此，便完成了整个MMS PDU的组装，在组装的过程中，需计算好整个MMS PDU的长度。 接下来是对MMS PDU进行HTTP封装，主要方法是为MMS PDU增加一个HTTP HEADER，以下是HTTP HEADER相关代码： if(mms_main.net_choose == UNIWAP)     {         //联通彩信接入点         sprintf(http_request,, \"POST http://mmsc.myuni.com.cn/ HTTP/1.1\\r\\n\"                 \"Host:10.0.0.172:80\\r\\nUser-Agent: Ethan\\r\\n\"                 \"Content-Type: application/vnd.wap.multipart.related\\r\\n\"                 \"Accept: application/vnd.wap.multipart.related\\r\\n\"                 \"Content-Length: %d\\r\\n\\r\\n\", mms_pdu_len);     }     else if(mms_main.net_choose == CMWAP)     {         //移动彩信接入点         sprintf(http_request, \"POST http://mmsc.monternet.com/ HTTP/1.1\\r\\n\"                 \"Host:10.0.0.172:80\\r\\nUser-Agent: Ethan\\r\\n\"                 \"Content-Type: application/vnd.wap.multipart.related\\r\\n\"                 \"Accept: application/vnd.wap.multipart.related\\r\\n\"                 \"Content-Length: %d\\r\\n\\r\\n\", mms_pdu_len); } 其中mms_pdu_len为之前MMS PDU的长度，若Content-Length错误，则网关回复HTTP 400错误(Content-Length<mms_pdu_len)或者HTTP 500错误(Content-Length>mms_pdu_len)。 然后将MMS PDU整个数据包置于HTTP HEADER之后，再发送出去即可。 发送成功，网关回复： HTTP/1.1 200 OK Content-Type: application/vnd.wap.mms-message Content-Length: 32 Date: Thu, 07 Jun 2012 07:00:56 GMT Server: MMSC x-mmsc-code: -128 x-mmsc-from: 8613026872332 x-mmsc-tid: 0 x-mmsc-to: +86***********","title":"Loongson1B开发板+GSM模块彩信发送实现"},{"content":"我最近一直在“叫嚷”中文计算器 ，最早发布的是网页版的，纯JS实现；半个月前又发布了微博版的；今天实现了微信版！ 通过扫描下面的二维码，或者搜索用户名 calc-cn，或者在“查找微信公众帐号”中搜索“中文计算器” 来添加！","title":"微信版中文计算器"},{"content":"        在项目中尝试用surfaceview自绘UI来提高用户滑动体验，其中要在特定区域中绘制Text，而且要求固定长度，这就需要自己计算Text所占的宽度，并进行处理。   最终效果：   \tfloat text_size = 25.0f;\tpublic void drawBooks() {\t\tCanvas canvas = new Canvas(bmp_shelf);\t\t\t\tint i=0;\t\tfloat row_average = d.screen_width/4.0f;\t\tint offset_x = (int)((row_average - bmp_book.getWidth())/2.0f);\t\tint offset_y = rowheight - bmp_book.getHeight() - 20;\t\tint title_offset_y = (int)(90.0f*dpi/240.0f);\t\t\t\tTextPaint textPaint = new TextPaint();\t\ttextPaint.setARGB(0xff, 255, 255, 255);\t\ttextPaint.setTextSize(text_size);\t\ttextPaint.setTextAlign(Align.RIGHT);\t\ttextPaint.setAntiAlias(true);\t\t\t\tfor(Iterator<BookData> itr=d.list_book.iterator();itr.hasNext();) {\t\t\tBookData bd = itr.next();\t\t\tint r = i/4;\t\t\tint book_x = (int)((i%4)*(row_average)+offset_x);\t\t\tint book_y = r*rowheight+offset_y;\t\t\t\t\t\tcanvas.drawBitmap(bmp_book, book_x, book_y, null);\t\t\t\t\t\tString title = measureTitle(bd.title);\t\t\tStaticLayout layout = new StaticLayout(title, textPaint, 240, Alignment.ALIGN_NORMAL, 1.0F, 0.0F, true);\t\t\tcanvas.translate(book_x+bmp_book.getWidth(), book_y+title_offset_y);\t\t\tlayout.draw(canvas);\t\t\tcanvas.translate(-book_x-bmp_book.getWidth(), -book_y-title_offset_y);\t\t\t\t\t\ti++;\t\t}\t}\t\tpublic String measureTitle(String title) {\t\tTextPaint textPaint = new TextPaint();\t\ttextPaint.setTextSize(text_size);\t\t\t\tif(textPaint.measureText(title, 0, title.length())<bmp_book.getWidth()) \t\t\treturn title;\t\t\t\tint i; String str=null;\t\tfor(i=title.length();i>0;i--) {\t\t\tstr = title.substring(0, i) + \"...\";\t\t\tfloat width = textPaint.measureText(str);\t\t\tif(width<bmp_book.getWidth()) {\t\t\t\tbreak;\t\t\t}\t\t}\t\t\t\treturn str;\t}         其中关键代码在measureTitle上。","title":"处理固定宽度下的长字符串绘制(Android)"},{"content":"注：本文由BeyondVincent(破船)翻译首发         转载请注明出处：BeyondVincent(破船)@DevDiv.com   第25日-加速度计:         今天，我来介绍Windows 8设备中另外一个传感器：加速度计。加速度计用来测量设备3个轴（X、Y和Z）上的加速度值。 X轴水平横穿设备。Y轴垂直穿过设备。Z轴穿过设备的前面到后面。下面我用Windows Phone的一个图示来演示：   注：下图为译者添加的： 摘自：Beginning Windows 8 Application Development – XAML Edition.pdf  page 271   用简单的术语来说，加速度计是用来测量三个轴上的重力加速度值。因此，当我们把Windows 8 平板设备正面朝上平放在桌子上时，可以获取到Z轴的值为-1，因为此时有一个”g”（一个单位的重力）施加于Z轴的负方向上。同样，如果我们把设备立起来（跟上图中手机一样），我们会获得Y轴的值为-1。 PDF下载地址： 第25日-加速度计 更多内容请浏览下面链接： Windows 8 开发31日 一些截图","title":"Windows Store apps开发[83]Windows 8 开发31日-第25日-加速度计"},{"content":"距离上次玩cocos2dx，已经是几个月以前的事情。今天去官网一看，已经有2.0.3的稳定版，且2.1.0的beta版也出来了。于是在github上clone了一份2.1.0的代码，升级到最新版本。 首先说一下升级Xcode的模板。就是把~/Library/Developer/Xcode/Templates的cocos2d-x删掉，然后运行cocos2d-x根目录下的install-templates-xcode.sh 然后说一下android的环境(Mac/Linux)。主要看下一几个脚本文件。 1. cocos2d-x根目录下的create-android-project.sh脚本      这个脚本需要sdk和ndk的路径。但是可以不改这个脚本，因为它会去取全局环境变量，所以只需要在bash_profile中增加环境变量 export ANDROID_SDK_ROOT=~/workspace/android-sdk-macosxexport ANDROID_NDK_ROOT=~/workspace/android-ndk-r8bexport COCOS2DX_ROOT=~/workspace/cocos2d-xexport NDK_ROOT=~/workspace/android-ndk-r8bexport PATH=$PATH:$ANDROID_SDK_ROOTexport PATH=$PATH:$ANDROID_NDK_ROOT设为自己的路径即可 这个脚本主要做了两件事 1. 创建一个android工程 就是调的android.sdk/tools/下的android命令，具体可以自己看谷歌文档 2. 调用template/android/下的copy_files.sh脚本来拷贝文件，并对工程进行一些修改，比如小改AndroidManifest.xml。 好了 ，看一下copy_files.sh这个脚本,就是一系列的copy，比如拷贝资源文件，java文件，修改AndoirdManifest.xml。 主要工作的脚本就是这两个。问题来了 之前用的2.0.1的版本，在根目录下有个HelloWorld。运行create-android-project.sh脚本创建一个新工程，它的初始java文件 jni文件，资源文件都是拷贝自这个HelloWorld工程。 然后2.1.0的版本有一些改动。2.1.0版将helloworld 和tests及一些Lua，javascript的demo都放在了samples目录下。\\ 在2.1.0版的根目录下运行create-android-project.sh生成新工程会出现问题，AndoridManifest.xml是个空文件，不能用ant编译。 我通过查看它的脚本，发现copy_files.sh有惊喜 HELLOWORLD_ROOT=$COCOS2DX_ROOT/samples/HelloCpp这个是定义的HelloWorld的路径，这个路径不对，少个Cpp。所以这个需要改为如下： HELLOWORLD_ROOT=$COCOS2DX_ROOT/samples/Cpp/HelloCpp所以拷贝的时候根本找不到helloworld的目录，嘿嘿。 再看copy_src_and_jni()函数，它拷贝了HellWorld目录的src和jni文件。这个脚本和2.0.1版本有一点区别。2.0.1是先调用copy_src_and_jni()函数拷贝src和jni目录，然后调用copy_library_src()拷贝cocos2dx/platform/android/java/src_common/下的java文件。而2.1.0没有copy_library_src()函数，就是没有拷贝platform下的java文件。它是怎么做的呢。 在create-android-project.sh中有一行 $ANDROID_SDK_ROOT_LOCAL/tools/android update project -l ../../cocos2dx/platform/android/java -p $PROJECT_DIR/      proj.android它是把platform下的java文件作为新工程的库来搞的。所以如果用eclipse的话同样可以把platform下的java做成一个库工程。但我试过在命令行，用ant编译不过。我不知道是不是它updata project后生成的build.xml问题，个人比较菜，没搞定，求高手指教。 于是我还是把他改成跟2.0.1一样的方式了。如下 1.注释掉上面那句，即在行首加一个# 2.修改copy_files.sh脚本的HELLOWORLD_ROOT路径，如下 3.修改copy_files.sh脚本。    在cop_src_and_jni()函数中加一行，如图 打完，收工。","title":"cocos2d-x最新2.1.0版本若干问题"},{"content":"        Java的concurrent包里面的CountDownLatch其实可以把它看作一个计数器，只不过这个计数器的操作是原子操作，同时只能有一个线程去操作这个计数器，也就是同时只能有一个线程去减这个计数器里面的值。         你可以向CountDownLatch对象设置一个初始的数字作为计数值，任何调用这个对象上的await()方法都会阻塞，直到这个计数器的计数值被其他的线程减为0为止。         CountDownLatch的一个非常典型的应用场景是：有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行。假如我们这个想要继续往下执行的任务调用一个CountDownLatch对象的await()方法，其他的任务执行完自己的任务后调用同一个CountDownLatch对象上的countDown()方法，这个调用await()方法的任务将一直阻塞等待，直到这个CountDownLatch对象的计数值减到0为止。         在Android当中使用CountDownLatch要注意一点，即，需要另外新建一个线程监视工作线程，否则会ANR错误。代码如下： package com.example.test;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import android.app.Activity;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.util.Log;/** *  * @Title: MainActivity.java * @Package com.example.test * @Description: Android当中使用CountDownLatch * @author Yang    * @date 2012-12-25 下午9:30:57 * @version V1.0 */public class MainActivity extends Activity {\tprivate DatePickerFragment fragment;\t@Override\tpublic void onCreate(Bundle savedInstanceState) {\t\tsuper.onCreate(savedInstanceState);\t\tsetContentView(R.layout.activity_main);\t\ttestCountDownLatch();\t}\tprivate void testCountDownLatch() {\t\tLightProgressDialog.create(MainActivity.this, \"Test\");\t\tfinal Handler handler = new Handler() {\t\t\tpublic void handleMessage(Message msg) {\t\t\t\tif (msg.what == 1){\t\t\t\t\tLightProgressDialog.cancelDialog();\t\t\t\t\tLog.d(\"MainActivity\",\"========================SUCESS========================\");\t\t\t\t}\t\t\t}\t\t};\t\tnew Thread() {\t\t\tpublic void run() {\t\t\t\tCountDownLatch latch = new CountDownLatch(2);// 设置计数值,\t\t\t\tExecutorService exec = Executors.newCachedThreadPool();// 创建线程池\t\t\t\texec.execute(new TestRunable1(latch));\t\t\t\texec.execute(new TestRunable2(latch));\t\t\t\ttry {\t\t\t\t\tlatch.await();// 等待所有线程完成操作\t\t\t\t} catch (InterruptedException e) {\t\t\t\t\te.printStackTrace();\t\t\t\t}\t\t\t\thandler.sendEmptyMessage(1);\t\t\t\texec.shutdown();\t\t\t};\t\t}.start();\t}\tclass TestRunable1 implements Runnable {\t\tprivate CountDownLatch latch;\t\tpublic TestRunable1(CountDownLatch latch) {\t\t\tsuper();\t\t\tthis.latch = latch;\t\t}\t\t@Override\t\tpublic void run() {\t\t\t\ttry {\t\t\t\t\tThread.sleep(1000 * 5);\t\t\t\t} catch (InterruptedException e) {\t\t\t\t\te.printStackTrace();\t\t\t\t}\t\t\t\tlatch.countDown();\t\t}\t}\tclass TestRunable2 implements Runnable {\t\tprivate CountDownLatch latch;\t\tpublic TestRunable2(CountDownLatch latch) {\t\t\tsuper();\t\t\tthis.latch = latch;\t\t}\t\t@Override\t\tpublic void run() {\t\t\ttry {\t\t\t\tThread.sleep(1000 * 3);\t\t\t\tlatch.countDown();\t\t\t} catch (InterruptedException e) {\t\t\t\te.printStackTrace();\t\t\t}\t\t}\t}}","title":"Android中使用CountDownLatch并发多线程操作"},{"content":"mainActivity显示如下: package cn.testcamera;import java.io.File;import java.text.SimpleDateFormat;import java.util.Date;import android.app.Activity;import android.content.Intent;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.net.Uri;import android.os.Bundle;import android.provider.MediaStore;import android.view.View;import android.widget.Button;import android.widget.ImageView;public class MainActivity extends Activity {\tprivate Button mButton;\tprivate ImageView mImageView;\tprivate File mPhotoFile;\tprivate String mPhotoPath;    public final static int CAMERA_RESULT=8888;    public final static String TAG=\"xx\";\t@Override\tpublic void onCreate(Bundle savedInstanceState) {\t\tsuper.onCreate(savedInstanceState);\t\tsetContentView(R.layout.main);\t\tmButton = (Button) findViewById(R.id.button);\t\tmButton.setOnClickListener(new ButtonOnClickListener());\t\tmImageView = (ImageView) findViewById(R.id.imageView);\t}\tprivate class ButtonOnClickListener implements View.OnClickListener {\t\tpublic void onClick(View v) {\t\t\ttry {\t\t\t\tIntent intent = new Intent(\"android.media.action.IMAGE_CAPTURE\");\t\t\t\tmPhotoPath=\"mnt/sdcard/DCIM/Camera/\"+getPhotoFileName();\t\t\t\tmPhotoFile = new File(mPhotoPath);\t\t\t\tif (!mPhotoFile.exists()) {\t\t\t\t\tmPhotoFile.createNewFile();\t\t\t\t}\t\t\t    intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(mPhotoFile));\t\t        startActivityForResult(intent,CAMERA_RESULT);\t\t\t} catch (Exception e) {\t\t\t}\t\t}\t}\t\tprivate String getPhotoFileName() {\t\tDate date = new Date(System.currentTimeMillis());\t\tSimpleDateFormat dateFormat = new SimpleDateFormat(\"'IMG'_yyyyMMdd_HHmmss\");\t\treturn dateFormat.format(date) + \".jpg\";\t}\t\t@Override\tprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\t\tsuper.onActivityResult(requestCode, resultCode, data);\t\tif (requestCode==CAMERA_RESULT) {\t\t\t Bitmap bitmap = BitmapFactory.decodeFile(mPhotoPath, null);  \t\t\t mImageView.setImageBitmap(bitmap);\t\t}\t}} main.xml如下: <RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:tools=\"http://schemas.android.com/tools\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\" >    <Button        android:id=\"@+id/button\"        android:layout_width=\"fill_parent\"        android:layout_height=\"wrap_content\"        android:text=\"点击按钮拍照\"     />    <ImageView         android:id=\"@+id/imageView\"        android:layout_below=\"@id/button\"        android:layout_width=\"fill_parent\"        android:layout_height=\"wrap_content\"     /><\/RelativeLayout> manifest.xml如下: <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"    package=\"cn.testcamera\"    android:versionCode=\"1\"    android:versionName=\"1.0\" >    <uses-sdk        android:minSdkVersion=\"8\"        android:targetSdkVersion=\"10\" />    <uses-permission android:name=\"android.permission.CAMERA\"/>    <uses-permission android:name=\"android.permission.INTERNET\" />    <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />      <application        android:icon=\"@drawable/ic_launcher\"        android:label=\"@string/app_name\"        android:theme=\"@style/AppTheme\" >        <activity            android:name=\".MainActivity\"            android:launchMode=\"singleTask\"            android:label=\"@string/title_activity_main\" >            <intent-filter>                <action android:name=\"android.intent.action.MAIN\" />                <category android:name=\"android.intent.category.LAUNCHER\" />            <\/intent-filter>        <\/activity>    <\/application><\/manifest>  ","title":"Android拍照后显示照片"},{"content":"        boolean preferMultiPane = context.getResources().getBoolean(             com.android.internal.R.bool.preferences_prefer_dual_pane);","title":"判断是否为平板"},{"content":"定义util Ext.define('DingCan.util.Config', {    singleton : true,    config : {        website:'http://londit-50c03e41547f8.com.1130.url-test.com'    },    constructor : function(config) {        this.initConfig(config);    }}); 在application 里面requires[' DingCan.util.Config'] 然后访问需要用 DingCan.util.Config.getWebsite()","title":"Sencha touch 2 定义全局变量"},{"content":"在Eboot里面显示图片，如果要显示一些非全屏大小的图片，感觉不是很爽，所以封装了几个函数，用于显示图片，或者画图用。 屏幕大小是320*240的，这样的屏幕，画的时候在屏幕的左上角开始往右边画，画完一行，接着画下一行。要显示的图片，需要先转成对应的数组。这里使用的是bmp2c.exe软件。由于，屏幕打竖来放，即变成240*320。这样子的话，做出来的图片需要逆时针旋转90度之后，才能够转换成对应的数组。 下面的函数支持全屏或非全屏的图片或颜色显示 其中的几个关键函数如下： // 显示图片BOOL ShowPicture(int startX, int startY, int width, int high, const unsigned short *picture){\tunsigned int *pFB;\tint i,j;\tif(startX>320 || startY>240)\treturn FALSE;\tif(picture == NULL)\treturn FALSE;\tpFB = (unsigned int *)EBOOT_FRAMEBUFFER_UA_START;\tfor(j=0; j<high; j++){\t\tfor(i=0; i<width; i++){\t\t\tUpDataBitmaptmp4=(int)picture[i+j*width];\t\t\tUpDataBitmaptmp=(((UpDataBitmaptmp4>>11)<<19)|(((UpDataBitmaptmp4>>5)&0x3F)<<10)|((UpDataBitmaptmp4&0x1F)<<3)|0x0);\t\t\t*(pFB+(startY*320+startX)+j*320+i) = UpDataBitmaptmp;\t\t}\t}}// 显示颜色BOOL ShowColor(int startX, int startY, int width, int high, const unsigned short color){\tunsigned int *pFB;\tint i,j;\tif(startX>320 || startY>240)\treturn FALSE;\tpFB = (unsigned int *)EBOOT_FRAMEBUFFER_UA_START;\tfor(j=0; j<high; j++){\t\tfor(i=0; i<width; i++){\t\t\tUpDataBitmaptmp4=(int)color;\t\t\tUpDataBitmaptmp=(((UpDataBitmaptmp4>>11)<<19)|(((UpDataBitmaptmp4>>5)&0x3F)<<10)|((UpDataBitmaptmp4&0x1F)<<3)|0x0);\t\t\t*(pFB+(startY*320+startX)+j*320+i) = UpDataBitmaptmp;\t\t}\t}}// 清屏void ClearScreen(){\tunsigned int *pFB;\tvolatile unsigned long i=0;\tpFB = (unsigned int *)EBOOT_FRAMEBUFFER_UA_START;\tfor(i=0; i<76800; i++){\t\t*(pFB+i)=0x00000000;\t}} 上述函数中的参数说明： startX  ： 图片开始的X坐标（以屏幕为320*240为准） startY  ：  图片开始的Y坐标 width   ： 图片的宽度（旋转后的图片宽度） high     ： 图片的高度（旋转后的图片高度） picture ： 图片对应的数组指针 color    ： 颜色值。0xFFFF表示白色，0x0000表示黑色","title":"6410 Eboot 显示图片"},{"content":"mainActivity如下: package cn.com;import java.io.ByteArrayOutputStream;import java.io.InputStream;import java.net.HttpURLConnection;import java.net.URL;import cn.db.DBservice;import cn.db.Photo;import android.app.Activity;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.view.View;import android.widget.Button;import android.widget.ImageView;public class MainActivity extends Activity {    private Button mButton;    private Bitmap mBitmap;    private ImageView mImageView;    private boolean isDownload=true;    private boolean isSave=false;    private boolean isLoadFromDB=false;    private static final int DOWNLOAD_FINISH=88;    private byte[] photoByte;    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.main);        mButton=(Button) findViewById(R.id.button);        mButton.setOnClickListener(new ButtonOnClickListener());        mImageView=(ImageView) findViewById(R.id.imageView);    }      private class ButtonOnClickListener implements View.OnClickListener{\tpublic void onClick(View v) {\t\tif (isDownload) {\t\t\tnew Thread(){\t\t\t\tpublic void run() {\t\t\t\t\tmBitmap=getBitmap(\"http://s12.sinaimg.cn/middle/4b181bd0gbf6cb07c2a1b&690\");\t\t\t\t\thandler.sendEmptyMessage(DOWNLOAD_FINISH);\t\t\t\t}\t\t\t}.start();\t\t}\t\tif (isSave) {\t\t\tDBservice service=new DBservice(MainActivity.this);\t\t\tPhoto photo=new Photo(1,mBitmap);\t\t\tservice.save(photo,photoByte);\t\t\tisLoadFromDB=true;\t\t\tisSave=false;\t\t\tmButton.setText(\"从数据库中加载bitmap\");\t\t\tmImageView.setImageBitmap(null);\t\t\treturn;\t\t}\t\tif (isLoadFromDB) {\t\t\tDBservice service=new DBservice(MainActivity.this);\t\t\tPhoto photo=service.find(1);\t\t\tmImageView.setImageBitmap(photo.getPhoto());\t\t}\t }   }      Handler handler=new Handler(){   \tpublic void handleMessage(Message msg) {   \t\tswitch (msg.what) {\t\t\tcase DOWNLOAD_FINISH:\t\t\t\tmImageView.setImageBitmap(mBitmap);\t\t\t\tmButton.setText(\"保存图片至SQLite\");\t\t\t\tisDownload=false;\t\t\t\tisSave=true;\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tbreak;\t\t\t}   \t};   };   \tpublic Bitmap getBitmap(String imagePath) {\t\ttry {\t\t\tURL imageUrl = new URL(imagePath);\t\t\tHttpURLConnection connection = (HttpURLConnection) imageUrl.openConnection();\t\t\tconnection.setConnectTimeout(5000);\t\t\tconnection.setRequestMethod(\"POST\");\t\t\tif (connection.getResponseCode() == 200) {\t\t\t\tInputStream inputStream = connection.getInputStream();\t\t\t\tphotoByte= readResource(inputStream);\t\t\t\tBitmap bitmap=BitmapFactory.decodeByteArray(photoByte, 0, photoByte.length);\t\t\t\treturn bitmap;\t\t\t}\t\t} catch (Exception e) {\t\t}\t\t\t\treturn null;\t};   public byte[] readResource(InputStream inputStream){\t   try {\t\t   ByteArrayOutputStream outputStream=new ByteArrayOutputStream();\t    \tbyte [] buffer=new byte[1024];\t    \tint len=0;\t    \twhile( (len=inputStream.read(buffer))!=-1){\t    \t\t   outputStream.write(buffer,0,len);\t    \t}\t    \tinputStream.close();\t    \toutputStream.close();   \t\t    \treturn outputStream.toByteArray();\t} catch (Exception e) {\t}    return null;   }} DataBaseOpenHelper.java如下: package cn.db;import android.content.Context;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteOpenHelper;public class DataBaseOpenHelper extends SQLiteOpenHelper {\tpublic DataBaseOpenHelper(Context context) {\t\tsuper(context, \"testbold.db\", null, 1);\t}\t@Override\tpublic void onCreate(SQLiteDatabase db) {\t\tdb.execSQL(\"create table test(photoid integer primary key autoincrement,id ingeter(10),photo Blob(20))\");\t}\t@Override\tpublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\t\t\t}}   DBservice.java如下: package cn.db;import android.content.Context;import android.database.Cursor;import android.database.sqlite.SQLiteDatabase;import android.graphics.Bitmap;import android.graphics.BitmapFactory;public class DBservice {\tprivate DataBaseOpenHelper openHelper;\tpublic DBservice(Context context) {\t\topenHelper=new DataBaseOpenHelper(context);\t}\t\t\tpublic void save(Photo photo,byte [] photoByte){\t\tSQLiteDatabase db=openHelper.getWritableDatabase();        db.execSQL(\"insert into test (id,photo) values(?,?)\",new Object[]{photo.getId(),photoByte});        db.close();\t}\t\t\tpublic Photo find(int i){\t\tSQLiteDatabase db=openHelper.getWritableDatabase();\t\tCursor cursor=db.rawQuery(\"select * from test where photoid=?\", new String[]{String.valueOf(i)});\t\twhile(cursor.moveToFirst()){\t\t\tint photoid=cursor.getInt(cursor.getColumnIndex(\"photoid\"));\t\t\tbyte[] photoByte=cursor.getBlob(cursor.getColumnIndex(\"photo\"));          \t\t\tBitmap bitmap=BitmapFactory.decodeByteArray(photoByte, 0, photoByte.length); \t\t\tPhoto photo=new Photo(photoid, bitmap);\t\t\treturn photo;\t\t}\t\tcursor.close();\t\tdb.close();\t\treturn null;\t}\t} Photo.java如下: package cn.db;import android.graphics.Bitmap;public class Photo {\tprivate int id;\tprivate Bitmap bitmap;\tpublic Photo() {\t}\tpublic Photo(int id, Bitmap bitmap) {\t\tsuper();\t\tthis.id = id;\t\tthis.bitmap = bitmap;\t}\tpublic int getId() {\t\treturn id;\t}\tpublic void setId(int id) {\t\tthis.id = id;\t}\tpublic Bitmap getPhoto() {\t\treturn bitmap;\t}\tpublic void setPhoto(Bitmap bitmap) {\t\tthis.bitmap = bitmap;\t}}    ","title":"Android中SQlite数据库存取Bitmap(一)"},{"content":"前几章参考： 1-引言 2-Objective-C 编程 3-类、对象和方法 4-数据类型和表达式 建议熟悉C语言，Java语言的同学，迅速简单的过了这一章。我看得很痛苦啊，n年前就知道的东西啦。只能作为复习了。 计算机的基本属性之一就是它能够重复执行一组语句。 这句话很吊。 for语句将按以下步骤执行： 1.先求初始表达式的值。 2.求循环条件的值。 3.执行组成循环体的程序语句。 4.求循环表达式的值。 5.返回到2执行。 如果在一组嵌套循环中执行break语句，仅会推出执行break语句的最内层循环。","title":"5-循环结构"},{"content":"在Java代码中HashMap的遍历有两种常用的方法，那就是使用keyset及entryset来进行遍历，但两者的遍历速度是有差别的。        第一种: 使用键-值对映射项。 　　Map map = new HashMap(); 　　Iterator iter = map.entrySet().iterator(); 　　while (iter.hasNext()) { 　　         Map.Entry entry = (Map.Entry) iter.next(); Object key = entry.getKey(); 　　         Object val = entry.getValue(); 　　} 　　效率高,以后一定要使用此种方式！ 　　第二种：使用键的Set视图。 　　Map map = new HashMap(); 　　Iterator iter = map.keySet().iterator(); 　　while (iter.hasNext()) { 　　         Object key = iter.next(); 　　         Object val = map.get(key); 　　} 　　效率低,以后尽量少使用！ 　　代码实例：        public class HashMapTest {          public static void main(String[] args) {                    HashMap<Integer, String> hashmap = new HashMap<Integer, String>();                    for (int i = 0; i < 500000; i++) {                             hashmap.put(i, \"thanks\");                    }                    long bs = Calendar.getInstance().getTimeInMillis();                    Iterator<Integer> iterator = hashmap.keySet().iterator();                    while (iterator.hasNext()) {                             System.out.print(hashmap.get(iterator.next()));                    }                    System.out.println(Calendar.getInstance().getTimeInMillis() - bs);          }          public static void main2(String[] args) {                    HashMap<Integer, String> hashmap = new java.util.HashMap<Integer, String>();                    for (int i = 0; i < 500000; i++) {                             hashmap.put(i, \"thanks\");                    }                    long bs = Calendar.getInstance().getTimeInMillis();//9297                    Iterator it = hashmap.entrySet().iterator();                    while (it.hasNext()) {                             Map.Entry<Integer, String> entry = (Map.Entry<Integer, String> ) it.next();                             // entry.getKey() 返回与此项对应的键                             // entry.getValue() 返回与此项对应的值                             System.out.print(entry.getValue());                    }                    System.out.println(Calendar.getInstance().getTimeInMillis() - bs);          } } 　　 　　对于keySet其实是遍历了2次，一次是转为iterator，一次就从hashmap中取出key所对于的value。而entryset只是遍历了第一次，他把key和value都放到了entry中，所以就快了 HashMap roleHm = (HashMap)this.getRequest().getSession().getAttribute(\"roleHm\");   boolean flag = (Boolean)this.getRequest().getSession().getAttribute(\"isKy\");   //如果session 中的 roleHm 为空，则重新读取；   if(Utils.isNullOrEmpty(roleHm)){       IRoleManager rm = ManagerFactory.getRoleManager();    AppRole[] roles = rm.getUserRoles(Integer.parseInt(UIMConfig      .getInstance().appID), userID);    roleHm = new HashMap();    // add by  科研人员按需求是不能看到高级查询的 故科研人员的角色是 10191    long targetRoleId = 10191;    for (int i = 0; i < roles.length; i++) {     roleHm.put(Long.toString(roles[i].getId()), roles[i]);     if (null != roles[i] && roles[i].getId() == targetRoleId) {      flag = true;     }    }   }    /*      java.util.Iterator iterator = (java.util.Iterator)roleHm.keySet().iterator();    while(iterator.hasNext()){     String value = (String)roleHm.get(iterator.next());    }    */  ","title":"map遍历"},{"content":"Intent跳转到系统应用中的拨号界面、联系人界面、短信界面及其他 现在开发中的功能需要直接跳转到拨号、联系人、短信界面等等，查找了很多资料，自己整理了一下。 首先，我们先看拨号界面，代码如下： Intent intent =new Intent();intent.setAction(\"android.intent.action.CALL_BUTTON\");startActivity(intent); 和 Uri uri = Uri.parse(\"tel:xxxxxx\");Intent intent = new Intent(Intent.ACTION_DIAL, uri);startActivity(intent);两者都行   但是如果是跳转到应用,使用一下代码：Intent intent= new Intent(\"android.intent.action.DIAL\");intent.setClassName(\"com.android.contacts\",\"com.android.contacts.DialtactsActivity\");到通话记录界面：Intent intent=new Intent();intent.setAction(Intent.ACTION_CALL_BUTTON);startActivity(intent);  到联系人界面：Intent intent = new Intent();intent.setAction(Intent.ACTION_VIEW);intent.setData(Contacts.People.CONTENT_URI);startActivity(intent);同理，到应用：Intent intent= new Intent(\"com.android.contacts.action.LIST_STREQUENT\");intent.setClassName(\"com.android.contacts\",\"com.android.contacts.DialtactsActivity\");  调用联系人界面：Intent intent = new Intent();intent.setAction(Intent.ACTION_PICK);intent.setData(Contacts.People.CONTENT_URI);startActivity(intent);   插入联系人Intent intent=new Intent(Intent.ACTION_EDIT,Uri.parse(\"content://com.android.contacts/contacts/\"+\"1\"));startActivity(intent);到联系人列表界面      Intent intent = new Intent(Intent.ACTION_INSERT_OR_EDIT);            intent.setType(\"vnd.android.cursor.item/person\");            intent.setType(\"vnd.android.cursor.item/contact\");            intent.setType(\"vnd.android.cursor.item/raw_contact\");            intent.putExtra(android.provider.ContactsContract.Intents.Insert.NAME, name);            intent.putExtra(android.provider.ContactsContract.Intents.Insert.COMPANY,company);            intent.putExtra(android.provider.ContactsContract.Intents.Insert.PHONE, tel);            intent.putExtra(android.provider.ContactsContract.Intents.Insert.PHONE_TYPE, 3);  到短信界面：Intent intent = new Intent(Intent.ACTION_VIEW);                intent.setType(\"vnd.android-dir/mms-sms\");//              intent.setData(Uri.parse(\"content://mms-sms/conversations/\"));//此为号码                startActivity(intent);到应用：Intent intent = new Intent(\"android.intent.action.CONVERSATION\");startActivity(intent);  以下是在网上找到的其他方法：1.从google搜索内容 Intent intent = new Intent();intent.setAction(Intent.ACTION_WEB_SEARCH);intent.putExtra(SearchManager.QUERY,\"searchString\")startActivity(intent);   2.浏览网页 Uri uri = Uri.parse(\"http://www.google.com\");Intent it   = new Intent(Intent.ACTION_VIEW,uri);startActivity(it);   3.显示地图 Uri uri = Uri.parse(\"geo:38.899533,-77.036476\");Intent it = new Intent(Intent.Action_VIEW,uri);startActivity(it);   4.路径规划 Uri uri = Uri.parse(\"http://maps.google.com/maps?f=dsaddr=startLat%20startLng&daddr=endLat%20endLng&hl=en\");Intent it = new Intent(Intent.ACTION_VIEW,URI);startActivity(it);  5.拨打电话 Uri uri = Uri.parse(\"tel:xxxxxx\");Intent it = new Intent(Intent.ACTION_DIAL, uri);startActivity(it);和uri = Uri.parse(\"tel:\"+number);                intent = new Intent(Intent.ACTION_CALL,uri);                startActivity(intent);   其中不同自己试验一下就知道了。 6.调用发短信的程序 Intent it = new Intent(Intent.ACTION_VIEW);it.putExtra(\"sms_body\", \"The SMS text\");it.setType(\"vnd.android-dir/mms-sms\");startActivity(it);  和 uri = Uri.parse(\"smsto:\"+要发送短信的对方的number);                intent = new Intent(Intent.ACTION_SENDTO,uri);                startActivity(intent);和mIntent = new Intent(Intent.ACTION_VIEW);        mIntent.putExtra(\"address\", c.getString(c.getColumnIndex(column)));        mIntent.setType(\"vnd.android-dir/mms-sms\");        startActivity(mIntent);    7.发送短信 Uri uri = Uri.parse(\"smsto:0800000123\");Intent it = new Intent(Intent.ACTION_SENDTO, uri);it.putExtra(\"sms_body\", \"The SMS text\");startActivity(it);String body=\"this is sms demo\";Intent mmsintent = new Intent(Intent.ACTION_SENDTO, Uri.fromParts(\"smsto\", number, null));mmsintent.putExtra(Messaging.KEY_ACTION_SENDTO_MESSAGE_BODY, body);mmsintent.putExtra(Messaging.KEY_ACTION_SENDTO_COMPOSE_MODE, true);mmsintent.putExtra(Messaging.KEY_ACTION_SENDTO_EXIT_ON_SENT, true);startActivity(mmsintent);8.发送彩信 Uri uri = Uri.parse(\"content://media/external/images/media/23\");Intent it = new Intent(Intent.ACTION_SEND);it.putExtra(\"sms_body\", \"some text\");it.putExtra(Intent.EXTRA_STREAM, uri);it.setType(\"image/png\");startActivity(it);StringBuilder sb = new StringBuilder();sb.append(\"file://\");sb.append(fd.getAbsoluteFile());Intent intent = new Intent(Intent.ACTION_SENDTO, Uri.fromParts(\"mmsto\", number, null));// Below extra datas are all optional.intent.putExtra(Messaging.KEY_ACTION_SENDTO_MESSAGE_SUBJECT, subject);intent.putExtra(Messaging.KEY_ACTION_SENDTO_MESSAGE_BODY, body);intent.putExtra(Messaging.KEY_ACTION_SENDTO_CONTENT_URI, sb.toString());intent.putExtra(Messaging.KEY_ACTION_SENDTO_COMPOSE_MODE, composeMode);intent.putExtra(Messaging.KEY_ACTION_SENDTO_EXIT_ON_SENT, exitOnSent);startActivity(intent);   9.发送Email Uri uri = Uri.parse(\"mailto:xxx@abc.com\");Intent it = new Intent(Intent.ACTION_SENDTO, uri);startActivity(it);Intent it = new Intent(Intent.ACTION_SEND);it.putExtra(Intent.EXTRA_EMAIL, \"me@abc.com\");it.putExtra(Intent.EXTRA_TEXT, \"The email body text\");it.setType(\"text/plain\");startActivity(Intent.createChooser(it, \"Choose Email Client\"));Intent it=new Intent(Intent.ACTION_SEND);String[] tos={\"me@abc.com\"};String[] ccs={\"you@abc.com\"};it.putExtra(Intent.EXTRA_EMAIL, tos);it.putExtra(Intent.EXTRA_CC, ccs);it.putExtra(Intent.EXTRA_TEXT, \"The email body text\");it.putExtra(Intent.EXTRA_SUBJECT, \"The email subject text\");it.setType(\"message/rfc822\");startActivity(Intent.createChooser(it, \"Choose Email Client\"));     Intent it = new Intent(Intent.ACTION_SEND);it.putExtra(Intent.EXTRA_SUBJECT, \"The email subject text\");it.putExtra(Intent.EXTRA_STREAM, \"file:///sdcard/mysong.mp3\");sendIntent.setType(\"audio/mp3\");startActivity(Intent.createChooser(it, \"Choose Email Client\"));   10.播放多媒体   Intent it = new Intent(Intent.ACTION_VIEW);Uri uri = Uri.parse(\"file:///sdcard/song.mp3\");it.setDataAndType(uri, \"audio/mp3\");startActivity(it);Uri uri = Uri.withAppendedPath(MediaStore.Audio.Media.INTERNAL_CONTENT_URI, \"1\");Intent it = new Intent(Intent.ACTION_VIEW, uri);startActivity(it);   11.uninstall apk Uri uri = Uri.fromParts(\"package\", strPackageName, null);Intent it = new Intent(Intent.ACTION_DELETE, uri);startActivity(it);   12.install apk Uri installUri = Uri.fromParts(\"package\", \"xxx\", null);returnIt = new Intent(Intent.ACTION_PACKAGE_ADDED, installUri);   13. 打开照相机 <1>Intent i = new Intent(Intent.ACTION_CAMERA_BUTTON, null);          this.sendBroadcast(i);    <2>long dateTaken = System.currentTimeMillis();         String name = createName(dateTaken) + \".jpg\";         fileName = folder + name;         ContentValues values = new ContentValues();         values.put(Images.Media.TITLE, fileName);         values.put(\"_data\", fileName);         values.put(Images.Media.PICASA_ID, fileName);         values.put(Images.Media.DISPLAY_NAME, fileName);         values.put(Images.Media.DESCRIPTION, fileName);         values.put(Images.ImageColumns.BUCKET_DISPLAY_NAME, fileName);         Uri photoUri = getContentResolver().insert(                   MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values);            Intent inttPhoto = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);         inttPhoto.putExtra(MediaStore.EXTRA_OUTPUT, photoUri);         startActivityForResult(inttPhoto, 10);   14.从gallery选取图片 Intent i = new Intent();        i.setType(\"image/*\");        i.setAction(Intent.ACTION_GET_CONTENT);        startActivityForResult(i, 11);   15. 打开录音机 Intent mi = new Intent(Media.RECORD_SOUND_ACTION);         startActivity(mi);16.显示应用详细列表      Uri uri = Uri.parse(\"market://details?id=app_id\");Intent it = new Intent(Intent.ACTION_VIEW, uri);startActivity(it);//where app_id is the application ID, find the ID//by clicking on your application on Market home//page, and notice the ID from the address bar刚才找app id未果，结果发现用package name也可以 Uri uri = Uri.parse(\"market://details?id=<packagename>\");这个简单多了 17寻找应用      Uri uri = Uri.parse(\"market://search?q=pname:pkg_name\");Intent it = new Intent(Intent.ACTION_VIEW, uri);startActivity(it);//where pkg_name is the full package path for an application18打开联系人列表 <1>         Intent i = new Intent();         i.setAction(Intent.ACTION_GET_CONTENT);         i.setType(\"vnd.android.cursor.item/phone\");         startActivityForResult(i, REQUEST_TEXT);   <2>         Uri uri = Uri.parse(\"content://contacts/people\");         Intent it = new Intent(Intent.ACTION_PICK, uri);         startActivityForResult(it, REQUEST_TEXT);   19 打开另一程序 Intent i = new Intent();         ComponentName cn = new ComponentName(\"com.yellowbook.android2\",                   \"com.yellowbook.android2.AndroidSearch\");         i.setComponent(cn);         i.setAction(\"android.intent.action.MAIN\");         startActivityForResult(i, RESULT_OK);20 添加到短信收件箱ContentValues cv = new ContentValues();                cv.put(\"type\", \"1\");cv.put(\"address\",\"短信地址\");cv.put(\"body\", \"短信内容\");getContentResolver().insert(Uri.parse(\"content://sms/inbox\"), cv);   21 从sim卡或者联系人中查询Cursor cursor;        Uri uri;        if (type == 1) {            Intent intent = new Intent();            intent.setData(Uri.parse(\"content://icc/adn\"));            uri = intent.getData();        } else            uri = People.CONTENT_URI;          cursor = activity.getContentResolver().query(uri, null, null, null, null);while (cursor.moveToNext()) { int peopleId = cursor.getColumnIndex(People._ID); int nameId = cursor.getColumnIndex(People.NAME); int phoneId = cursor.getColumnIndex(People.NUMBER);} 查看某个联系人，当然这里是ACTION_VIEW，如果为选择并返回action改为ACTION_PICK，当然处理intent时返回需要用到 startActivityforResult Uri personUri = ContentUris.withAppendedId(People.CONTENT_URI, ID);//最后的ID参数为联系人Provider中的数据库BaseID，即哪一行 Intent intent = new Intent(); intent.setAction(Intent.ACTION_VIEW); intent.setData(personUri); startActivity(intent); 22 删除uri = ContentUris.withAppendedId(People.CONTENT_URI, 联系人id);        int count = activity.getContentResolver().delete(uri, null, null);  23 添加到联系人：ContentValues cv = new ContentValues();ArrayList<ContentProviderOperation> operationList = new ArrayList<ContentProviderOperation>();ContentProviderOperation.Builder builder =  ContentProviderOperation.newInsert(RawContacts.CONTENT_URI);                    builder.withValues(cv);                    operationList.add(builder.build());                    builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);                    builder.withValueBackReference(StructuredName.RAW_CONTACT_ID, 0);                    builder.withValue(Data.MIMETYPE, StructuredName.CONTENT_ITEM_TYPE);                    builder.withValue(StructuredName.DISPLAY_NAME, \"自定义联系人名\");                    operationList.add(builder.build());                    builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);                    builder.withValueBackReference(Phone.RAW_CONTACT_ID, 0);                    builder.withValue(Data.MIMETYPE, Phone.CONTENT_ITEM_TYPE);                    builder.withValue(Phone.NUMBER, \"联系人的phonenumber\");                    builder.withValue(Data.IS_PRIMARY, 1);                    operationList.add(builder.build());                    try {                        getContentResolver().applyBatch(ContactsContract.AUTHORITY, operationList);                    } catch (RemoteException e) {                        e.printStackTrace();                    } catch (OperationApplicationException e) {                        e.printStackTrace();                    } 23 选择一个图片 Intent intent = new Intent(Intent.ACTION_GET_CONTENT);intent.addCategory(Intent.CATEGORY_OPENABLE); intent.setType(\"image/*\"); startActivityForResult(intent, 0);   24 调用Android设备的照相机，并设置拍照后存放位置Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(new File(Environment .getExternalStorageDirectory().getAbsolutePath()+\"/cwj\", android123 + \".jpg\")));//存放位置为sdcard卡上cwj文件夹，文件名为android123.jpg格式startActivityForResult(intent, 0);  25 在market上搜索指定package name，比如搜索com.android123.cwj的写法如下 Uri uri = Uri.parse(\"market://search?q=pname:com.android123.cwj\"); Intent intent = new Intent(Intent.ACTION_VIEW, uri); startActivity(intent);  26获取文件信息，并使用相对应软件打开view plainprivate void openFile(File f) {   Intent intent = new Intent();   intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);   intent.setAction(android.content.Intent.ACTION_VIEW);   String type = getMIMEType(f);   intent.setDataAndType(Uri.fromFile(f), type);   startActivity(intent); }     private String getMIMEType(File f){   String end = f       .getName()       .substring(f.getName().lastIndexOf(\".\") + 1,           f.getName().length()).toLowerCase();   String type = \"\";   if (end.equals(\"mp3\") || end.equals(\"aac\") || end.equals(\"aac\")       || end.equals(\"amr\") || end.equals(\"mpeg\")       || end.equals(\"mp4\"))   {     type = \"audio\";   } else if (end.equals(\"jpg\") || end.equals(\"gif\")       || end.equals(\"png\") || end.equals(\"jpeg\"))   {     type = \"image\";   } else   {     type = \"*\";   }   type += \"/*\";   return type;","title":"android 调用系统界面"},{"content":"利用HttpURLConnection对象,我们可以向网络发送xml数据. StringBuilder xml =  new StringBuilder(); xml.append(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\" ?>\"); xml.append(\"<M1 V=10000>\"); xml.append(\"<U I=1 D=\\\"N73\\\">中国<\/U>\"); xml.append(\"<\/M1>\"); byte[] xmlbyte = xml.toString().getBytes(\"UTF-8\"); URL url = new URL(\"http://localhost:8080/itcast/contanctmanage.do?method=readxml\"); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setConnectTimeout(5* 1000); conn.setDoOutput(true);//允许输出 conn.setUseCaches(false);//不使用Cache conn.setRequestMethod(\"POST\");         conn.setRequestProperty(\"Connection\", \"Keep-Alive\");//维持长连接 conn.setRequestProperty(\"Charset\", \"UTF-8\"); conn.setRequestProperty(\"Content-Length\", String.valueOf(xmlbyte.length)); conn.setRequestProperty(\"Content-Type\", \"text/xml; charset=UTF-8\"); DataOutputStream outStream = new DataOutputStream(conn.getOutputStream()); outStream.write(xmlbyte);//发送xml数据 outStream.flush(); if (conn.getResponseCode() != 200) throw new RuntimeException(\"请求url失败\"); InputStream is = conn.getInputStream();//获取返回数据 String result = readAsString(is, \"UTF-8\"); outStream.close();","title":"向Internet发送xml数据"},{"content":"根据Bezier曲线的定义，画出曲线上密密麻麻的点，再连接那些点以成线。 运行结果： 源程序： /*** Justme0* 绘制Bezier曲线**/#define _CRT_SECURE_NO_WARNINGS#include <iostream>#include <cmath>#include <cstdlib>#include \"graphics.h\"using namespace std;// 生成的Bezier曲线由BEZIER_CURVE_POINTS_NUMBER个点组成（粗略说）const int BEZIER_CURVE_POINTS_NUMBER = 100000;struct Pt2D {public:\tdouble x;\tdouble y;\tPt2D():x(0), y(0){}};void GetCnk(int n, int *c){\t// 有更好的算法\tfor (int k = 0; k <= n; ++k) {\t\tc[k] = 1;\t\tfor (int i = n; i >= k + 1; --i) {\t\t\tc[k] *= i;\t\t}\t\tfor (int i = n - k; i >= 2; --i) {\t\t\tc[k] /= i;\t\t}\t}}void GetPointPr(int *c, double t, Pt2D *Pt, int ControlN, Pt2D *ControlP){\tPt->x = 0;\t// key!\tPt->y = 0;\tdouble n = ControlN - 1;\tfor (int k = 0; k < ControlN; ++k) {\t\tdouble Bernstein = c[k] * pow(t, k) * pow(1 - t, n - k);\t\tPt->x += ControlP[k].x * Bernstein;\t\tPt->y += ControlP[k].y * Bernstein;\t}}void BezierCurve(int m, int ControlN, Pt2D *ControlP){\tint *C = new int[ControlN];\t// 应检测异常\tGetCnk(ControlN - 1, C);\tmoveto(int(ControlP->x), int(ControlP->y));\tsetcolor(YELLOW);\tPt2D CurvePt;\tfor (int i = 0; i <= m; ++i) {\t\tGetPointPr(C, (double)i / (double)m, &CurvePt, ControlN, ControlP);\t\tlineto(int(CurvePt.x), int(CurvePt.y));\t}\tdelete []C;\tC = NULL;}// 给出ControlN个控制点，绘制曲线void Display(int ControlN, Pt2D ControlP[]){\tinitgraph(500, 500);\t// 画控制多边形\tmoveto(int(ControlP->x), int(ControlP->y));\tfor (int i = 0; i < ControlN; ++i) {\t\tlineto(int(ControlP[i].x), int(ControlP[i].y));\t}\t// 画Bezier曲线\tBezierCurve(BEZIER_CURVE_POINTS_NUMBER, ControlN, ControlP);\tSleep(4000);\tclosegraph();}int main(int argc, char **argv){\tfreopen(\"cin.txt\", \"r\", stdin);\tcout << \"请输入点的个数：\" << endl;\tint ControlN;\tcin >> ControlN;\tPt2D *ControlP = new Pt2D[ControlN];\t// 应检测异常\t\tcout << \"请输入各点坐标：\" << endl;\tfor (int i = 0; i < ControlN; ++i) {\t\tcin >> ControlP[i].x >> ControlP[i].y;\t}\tDisplay(ControlN, ControlP);\tdelete []ControlP;\tControlP = NULL;\treturn 0;}/**cin.txt:5400 100100 100100 400400 400400 250*/","title":"CG实验4th：Bezier曲线"},{"content":"由于需要做android传感器（加速度相关）采集应用，而加速度相关信息采集是实时的，显然创建一个Service来单独处理传感器的信息采集是明智之举，而之气没有使用过Service和BroadcastReceiver，因此在前期学习时颇为不顺。 之前参考了一篇文章《Android 传感器应用举例》，无奈有种被坑的感觉：http://wenku.baidu.com/view/ef9bd802a6c30c2259019e8f.html 在编译时出现java.lang.RuntimeException: Unable to instantiate receiver 折腾两天，终于找到问题根源了 被坑原因并不是文章有问题，而是文章中提到的BroadcastReceiver是Activity的内部类，但是文中没有给出AndroidManifest.xml文件，我想当然地认为与普通的服务和广播写法一样。 正确的写法如下文：http://blog.csdn.net/lzg08_08/article/details/8303003 特别注意：Activity创建BroadcastReceiver内部类时要声明为static类，同时在AndroidManifest.xml文件中需要用$标识出内部Receiver。 废话不多说，贴出源码 SensorService.java package com.dm;import android.app.Notification;import android.app.NotificationManager;import android.app.PendingIntent;import android.app.Service;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.hardware.Sensor;import android.hardware.SensorEvent;import android.hardware.SensorEventListener;import android.hardware.SensorManager;import android.os.IBinder;import android.util.Log;public class SensorService extends Service {\t// 声明加速度传感器对象\tprivate SensorManager sm = null; // 获取SensorManager对象，通过它可以获得距离，加速度等传感器对象\tprivate Sensor accelerationSensor = null; // 加速度传感器\tprivate Sensor magneticSensor = null; // 磁力传感器\t// ******************加速度传感器初始化变量*********************************************//\tdouble gravity[] = new double[3];// 代表3个方向的重力加速度\tdouble xAcceleration = 0;// 代表3个方向的真正加速度\tdouble yAcceleration = 0;\tdouble zAcceleration = 0;\tdouble currentAcceleration = 0; // 当前的合加速度\tdouble maxAcceleration = 0; // 最大加速度\t// 接下来定义的数组是为了对加速度传感器采集的加速度加以计算和转化而定义的，转化的目的是为了使数据看上去更符合我们平时的习惯\tfloat[] magneticValues = new float[3];\tfloat[] accelerationValues = new float[3];\tfloat[] values = new float[3];\tfloat[] rotate = new float[9];\t// 初始化的三个方位角的值\tfloat Yaw = 0;\tfloat Pitch = 0; // values[1]\tfloat Roll = 0;\t\tfinal static int CMD_STOP = 0;\tfinal static int CMD_UPDATAE = 1;\t\t\tpublic void onCreate() {\t\tsuper.onCreate();\t\t/**\t\t * 设置加速度传感器\t\t */\t\tsm = (SensorManager) this.getSystemService(SENSOR_SERVICE);\t\taccelerationSensor = sm.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);\t\tmagneticSensor = sm.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);\t\tsm.registerListener(accelerationListener, accelerationSensor,\t\t\t\tSensorManager.SENSOR_DELAY_UI);\t\tsm.registerListener(magneticListener, accelerationSensor,\t\t\t\tSensorManager.SENSOR_DELAY_UI);\t\tsm.registerListener(magneticListener, magneticSensor,\t\t\t\tSensorManager.SENSOR_DELAY_UI);\t}\t\tpublic void onStart(Intent intent, int startId) {\t\tsuper.onStart(intent, startId);\t\tLog.i(\"-----------SensorService---------------\",\"服务启动\" ); \t}\t//重写 onDestroy 方法\tpublic void onDestroy() {\t\tsm.unregisterListener(accelerationListener);\t\tcurrentAcceleration = 0;\t\tmaxAcceleration = 0;\t\txAcceleration = yAcceleration = zAcceleration = 0;\t\t// 注销监听器\t\tsm.unregisterListener(magneticListener);\t\tsm = null;\t\tsuper.onDestroy();\t}\t\t\t@Override\tpublic IBinder onBind(Intent arg0) {\t\t// TODO Auto-generated method stub\t\treturn null;\t}\t\t// **************************加速度测试传感器部分*************************\t// 加速度传感器监听器，当获取的传感器数据发生精度要求范围内的变化时，监听器会调用onSensorChanged函数\tSensorEventListener accelerationListener = new SensorEventListener() {\t\t\t\tpublic void onSensorChanged(SensorEvent event) {\t\t\tfinal double alpha = 0.8;\t\t\tgravity[0] = alpha * gravity[0] + (1 - alpha) * event.values[0];\t\t\tgravity[1] = alpha * gravity[1] + (1 - alpha) * event.values[1];\t\t\tgravity[2] = alpha * gravity[2] + (1 - alpha) * event.values[2];\t\t\txAcceleration = event.values[0] - gravity[0];\t\t\tyAcceleration = event.values[1] - gravity[1];\t\t\tzAcceleration = event.values[2] - gravity[2];\t\t\t// 计算三个方向上的和加速度\t\t\tdouble G = Math.sqrt(Math.pow(xAcceleration, 2)\t\t\t\t\t+ Math.pow(zAcceleration, 2) + Math.pow(yAcceleration, 2));\t\t\tcurrentAcceleration = G;\t\t\tif (currentAcceleration > maxAcceleration)\t\t\t\tmaxAcceleration = currentAcceleration;\t\t\t\t\t\tIntent i = new Intent();\t\t\ti.setAction(\"com.dm.accReceiver\");\t\t\ti.putExtra(\"xAcceleration\", xAcceleration);\t\t\ti.putExtra(\"yAcceleration\", yAcceleration);\t\t\ti.putExtra(\"zAcceleration\", zAcceleration);\t\t\ti.putExtra(\"currentAcceleration\", currentAcceleration);\t\t\ti.putExtra(\"maxAcceleration\", maxAcceleration);\t\t\tsendBroadcast(i);\t\t}\t\tpublic void onAccuracyChanged(Sensor sensor, int accuracy) {\t\t}\t};\t// ************************方向传感器**************************\t// 手机方位传感器监听器，当获取的加速度或者磁力传感器数据发生精度要求范围内的变化时，监听器会调用onSensorChanged函数\tSensorEventListener magneticListener = new SensorEventListener() {\t\tpublic void onSensorChanged(SensorEvent event) {\t\t\t// 如果是加速度传感器的值发生了变化\t\t\tif (event.sensor.getType() == Sensor.TYPE_ACCELEROMETER) {\t\t\t\taccelerationValues = event.values;\t\t\t}\t\t\t// 如果是磁力传感器的值发生了变化\t\t\tif (event.sensor.getType() == Sensor.TYPE_MAGNETIC_FIELD) {\t\t\t\tmagneticValues = event.values;\t\t\t}\t\t\tSensorManager.getRotationMatrix(rotate, null, accelerationValues,\t\t\t\t\tmagneticValues);\t\t\tSensorManager.getOrientation(rotate, values);\t\t\tfor (int i = 0; i < 3; i++) {\t\t\t\tvalues[i] = (float) Math.toDegrees(values[i]);\t\t\t\tLog.i(\"方位检测\", \"values[\" + i + \"]=\" + values[i]);\t\t\t}\t\t\tYaw = values[0];\t\t\tPitch = values[1];\t\t\tRoll = values[2];\t\t\t\t\t\tIntent i = new Intent();\t\t\ti.setAction(\"com.dm.magReceiver\");\t\t\ti.putExtra(\"Yaw\", Yaw);\t\t\ti.putExtra(\"Pitch\", Pitch);\t\t\ti.putExtra(\"Roll\", Roll);\t\t\tsendBroadcast(i);\t\t}\t\tpublic void onAccuracyChanged(Sensor sensor, int accuracy) {\t\t}\t};\t}Activity中核心代码(在onCreate()方法中创建BroadcastReceiver实例) \t\tBroadcastReceiver accReceiver = new BroadcastReceiver() {\t\t\t@Override\t\t\tpublic void onReceive(Context context, Intent intent) {\t\t\t\tBundle bundle = intent.getExtras();// 获得 Bundle\t\t\t\txAcceleration = bundle.getDouble(\"xAcceleration\", 0);\t\t\t\tyAcceleration = bundle.getDouble(\"yAcceleration\", 0);\t\t\t\tzAcceleration = bundle.getDouble(\"zAcceleration\", 0);\t\t\t\tcurrentAcceleration = bundle.getDouble(\"currentAcceleration\", 0);\t\t\t\tmaxAcceleration = bundle.getDouble(\"maxAcceleration\", 0);\t\t\t\t\t\t\t\tLog.i(\"-----------accReceiver---------------\", String.valueOf(xAcceleration) + \"|\" +\t\t\t\t\t\tString.valueOf(xAcceleration) + \"|\" +\t\t\t\t\t\tString.valueOf(yAcceleration) + \"|\" +\t\t\t\t\t\tString.valueOf(zAcceleration) + \"|\" +\t\t\t\t\t\tString.valueOf(currentAcceleration) + \"|\" +\t\t\t\t\t\tString.valueOf(maxAcceleration) ); \t\t\t        }\t\t\t};\t\t\t\t\tIntentFilter accFilter = new IntentFilter();\t\taccFilter.addAction(\"com.dm.accReceiver\");\t\tregisterReceiver(accReceiver, accFilter);\t\t\t\t// 新建并注册广播接收器，用于接收传感器类传递的数据\t\tBroadcastReceiver magReceiver = new BroadcastReceiver() {\t\t\t@Override\t\t\tpublic void onReceive(Context context, Intent intent) {\t\t\t\tBundle bundle = intent.getExtras();// 获得 Bundle\t\t\t\tYaw = bundle.getFloat(\"Yaw\", 0);\t\t\t\tPitch = bundle.getFloat(\"Pitch\", 0);\t\t\t\tRoll = bundle.getFloat(\"Roll\", 0);\t\t\t\t\t\t\t\tLog.i(\"-----------magReceiver---------------\", \t\t\t\t\t\tString.valueOf(Yaw) + \"|\" +\t\t\t\t\t\tString.valueOf(Pitch) + \"|\" +\t\t\t\t\t\tString.valueOf(Roll) ); \t\t\t        }\t\t\t};\t\t\t\t\t\t\tIntentFilter magFilter = new IntentFilter();\t\tmagFilter.addAction(\"com.dm.magReceiver\");\t\tregisterReceiver(magReceiver, magFilter);\t\t\t\t\t\t\t\t\t\t// 启动注册了传感器监听的 Service\t\tIntent i = new Intent(this, SensorService.class);\t\tstartService(i); 希望大家在做android传感器项目时不要再犯这样的错误。","title":"android传感器 android与Service通信 使用BroadCast发送和接收消息"},{"content":"1.户可以根据自己输入的地址下载网络上的图片 第一步： 先写layout的布局文件 <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"     xmlns:tools=\"http://schemas.android.com/tools\"     android:layout_width=\"match_parent\"     android:layout_height=\"match_parent\"     android:orientation=\"vertical\"     tools:context=\".MainActivity\" >     <TextView         android:id=\"@+id/textview1\"         android:layout_width=\"wrap_content\"         android:layout_height=\"wrap_content\" />     <Button         android:id=\"@+id/button1\"         android:layout_width=\"wrap_content\"         android:layout_height=\"wrap_content\"         android:text=\"显示下载的图片\" />     <Button         android:id=\"@+id/button3\"         android:layout_width=\"wrap_content\"         android:layout_height=\"wrap_content\"         android:text=\"显示下载的html\" />     <ImageView         android:id=\"@+id/imageView1\"         android:layout_width=\"wrap_content\"         android:layout_height=\"wrap_content\" /> <\/LinearLayout> 第二步再写activity package com.hbsi.csdn.picture; import com.hsbi.csdn.service.ImageService; import android.os.Bundle; import android.app.Activity; import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.util.Log; import android.view.Menu; import android.view.View; import android.view.View.OnClickListener; import android.widget.Button; import android.widget.ImageView; import android.widget.Toast; public class MainActivity extends Activity {  @Override  protected void onCreate(Bundle savedInstanceState) {   super.onCreate(savedInstanceState);   setContentView(R.layout.activity_main);   final ImageView imageview=(ImageView) findViewById(R.id.imageView1);   Button btn=(Button) findViewById(R.id.button1);   btn.setOnClickListener(new OnClickListener() {        @Override    public void onClick(View v) {     // TODO Auto-generated method stub     String path=\"http://list.image.baidu.com/t/image/w_bizhi.jpg\";     try {      byte[] data=ImageService.getImage(path);      Bitmap bm=BitmapFactory.decodeByteArray(data, 0, data.length);            imageview.setImageBitmap(bm);           } catch (Exception e) {      // TODO Auto-generated catch block      e.printStackTrace();      Toast.makeText(getBaseContext(), \"出错啦\", 1);      Log.e(\"ERR\",e.toString());     }    }   });     }  @Override  public boolean onCreateOptionsMenu(Menu menu) {   // Inflate the menu; this adds items to the action bar if it is present.   getMenuInflater().inflate(R.menu.activity_main, menu);   return true;  } } 第三步： 单独写一个imageservice类 package com.hsbi.csdn.service; import java.io.ByteArrayOutputStream; import java.io.InputStream; import java.net.HttpURLConnection; import java.net.MalformedURLException; import java.net.URL; public class ImageService {  public static byte[] getImage(String path) throws Exception{   URL url=new URL(path);//得到代表路径的url;   HttpURLConnection conn=(HttpURLConnection) url.openConnection();   conn.setConnectTimeout(20*1000);   conn.setRequestMethod(\"GET\");   if (conn.getResponseCode() != 200) throw new RuntimeException(\"请求url失败\");   InputStream in=conn.getInputStream();   ByteArrayOutputStream outStream=new ByteArrayOutputStream();   byte[] buffer=new byte[1024];   int len=-1;    while((len=in.read(buffer))!=-1){     outStream.write(buffer,0,len);    }    byte[] data=outStream.toByteArray();//图片的二进制数组    return data;  } } 最后一步： 在清单文件中获得网络权限  <uses-permission android:name=\"android.permission.INTERNET\"/>","title":"可以根据自己输入的地址下载网络上的图片"},{"content":"在node.js开发过程中使用了npm install log默认下载的模块，日期时间很不符合习惯。 [Tue Dec 25 2012 21:07:37 GMT+0800 (中国标准时间)] 可通过如下方法格式化 $node_module/log/lib/log.js line 172:log方法替换为： /** \t * 格式化日期 \t * <code> \t * yyyy-------年 \t * MM---------月 \t * dd---------日 \t * hh---------时 \t * mm---------分 \t * formatDate(new Date() , 'yyyy-MM-dd mm:hh'); \t * or formateDate(new Date(), 'yyyy/MM/dd mm/hh'); \t * <\/code> * @param {Date}date 需要格式化的日期对象 \t * @param {Object} style 样式 \t * @return 返回格式化后的当前时间 \t */    formatDate : function(date, style){       var y = date.getFullYear();        var M = \"0\" + (date.getMonth() + 1);        M = M.substring(M.length - 2);       var d = \"0\" + date.getDate();       d = d.substring(d.length - 2);        var h = \"0\" + date.getHours();        h = h.substring(h.length - 2);        var m = \"0\" + date.getMinutes();        m = m.substring(m.length - 2); \t  var s = \"0\" + date.getSeconds();        s = s.substring(s.length - 2);       return style.replace('yyyy', y).replace('MM', M).replace('dd', d).replace('hh', h).replace('mm', m).replace('ss', s);  },  /**   * Log output message.   *   * @param  {String} levelStr   * @param  {Array} args   * @api private   */  log: function(levelStr, args) {    if (exports[levelStr] <= this.level) {      var i = 1;      var msg = args[0].replace(/%s/g, function(){        return args[i++];      });\t  dStr = this.formatDate(new Date(),'yyyy-MM-dd hh:mm:ss');       this.stream.write(          '[' + dStr + ']'        + ' ' + levelStr        + ' ' + msg        + '\\n'      );    }  }, 最后输入如 yyyy-MM-dd hh:mm:ss 这样就好多了 更多的 日期时间javascript 函数可用 http://momentjs.com/","title":"node.js log模块日期格式化"},{"content":"消隐采用的是深度排序算法（油画家算法） 运行结果： 源程序： #define _CRT_SECURE_NO_WARNINGS#include <iostream>#include <queue>#include \"graphics.h\"using namespace std;struct MyRectangle {\tdouble x0;\tdouble y0;\tdouble x1;\tdouble y1;\tMyRectangle():x0(0), y0(0), x1(0), y1(0){}};// 每一个元素由一个矩形和它的深度及颜色组成struct Element {\tMyRectangle rec;\tdouble buffer;\tCOLORREF color;\tElement():buffer(0), color(0){}\tbool operator<(const Element &other) const {\t\treturn this->buffer > other.buffer;\t// 让深度较小的排在前面，先出队\t}};void Draw(priority_queue Q){\tinitgraph(500, 500);\twhile (!Q.empty())\t{\t\tElement tmp = Q.top();\t\tQ.pop();\t\tint x0 = (int)tmp.rec.x0;\t\tint y0 = (int)tmp.rec.y0;\t\tint x1 = (int)tmp.rec.x1;\t\tint y1 = (int)tmp.rec.y1;\t\tCOLORREF color = tmp.color;\t\t\t\tsetfillstyle(color);\t\tbar(x0, y0, x1, y1);\t\t\t\tSleep(2000);\t}\tclosegraph();}int main(int argc, char **argv){\tfreopen(\"cin.txt\", \"r\", stdin);\tpriority_queue<Element> Q;\t// 按深度来排的优先队列\tElement tmp;\twhile (cin >> tmp.rec.x0 >> tmp.rec.y0 >> tmp.rec.x1 >> tmp.rec.y1 >> tmp.buffer)\t// Element最好重载>>\t{\t\t// 颜色用十六进制输入，如：0xA80000或A80000\t\tscanf(\"%x\", &tmp.color);\t\tQ.push(tmp);\t}\tDraw(Q);\treturn 0;}/**cin.txt0 0 200 200 \t0.7\t0xA8000027 27 300 300\t2\t0x00A80035 440 90 10 \t1\t0xA8A800470 40 10 160 \t3\t0x0000A8*/","title":"CG实验4th：消隐"},{"content":"        Tesseract是一个开源的OCR（Optical Character Recognition，光学字符识别）引擎，可以识别多种格式的图像文件并将其转换成文本，目前已支持60多种语言（包括中文）。 Tesseract最初由HP公司开发，后来由Google维护，目前发布在Googel Project上。地址为http://code.google.com/p/tesseract-ocr/。 使用默认的语言库识别 1.安装Tesseract         从http://code.google.com/p/tesseract-ocr/downloads/list下载Tesseract，目前版本为Tesseract3.02。因为只是测试使用，这里直接下载winodws下的安装文件tesseract-ocr-setup-3.02.02.exe。安装成功后会在相应磁盘上生成一个Tesseract-OCR目录。通过目录下的tesseract.exe程序就可以对图像字符进行识别了。 2.准备一副待识别的图像，这里用画图工具随便写了一串数字，保存为number.jpg，如下图所示：          3.  打开命令行，定位到Tesseract-OCR目录，输入命令：  tesseract.exe number.jpg result -l eng      其中result表示输出结果文件txt名称，eng表示用以识别的语言文件为英文。 3.  打开Tesseract-OCR目录下的result.txt文件，看到识别的结果为7542315857，有3个字符识别错误，识别率还不是很高，那有没有什么方法来提供识别率呢？Tesseract提供了一套训练样本的方法，用以生成自己所需的识别语言库。下面介绍一下具体训练样本的方法。       训练样本 关于如何训练样本，Tesseract-OCR官网有详细的介绍http://code.google.com/p/tesseract-ocr/wiki/TrainingTesseract3。这里通过一个简单的例子来介绍一下如何进行样本训练。 1.下载工具jTessBoxEditor. http://sourceforge.net/projects/vietocr/files/jTessBoxEditor/，这个工具是用来训练样本用的，由于该工具是用JAVA开发的，需要安装JAVA虚拟机才能运行。 2. 获取样本图像。用画图工具绘制了5张0-9的文样本图像（当然样本越多越好），如下图所示：       3.合并样本图像。运行jTessBoxEditor工具，在点击菜单栏中Tools--->Merge TIFF。在弹出的对话框中选择样本图像（按Shift选择多张），合并成num.font.exp0.tif文件。4.生成Box File文件。打开命令行，执行命令：   tesseract.exe num.font.exp0.tif num.font.exp0 batch.nochop makebox   生成的BOX文件为num.font.exp0.box，BOX文件为Tessercat识别出的文字和其坐标。 注：Make Box File的命令格式为：   tesseract [lang].[fontname].exp[num].tif [lang].[fontname].exp[num] batch.nochop makebox 其中lang为语言名称，fontname为字体名称，num为序号，可以随便定义。 5.文字校正。运行jTessBoxEditor工具，打开num.font.exp0.tif文件（必须将上一步生成的.box和.tif样本文件放在同一目录），如下图所示。可以看出有些字符识别的不正确，可以通过该工具手动对每张图片中识别错误的字符进行校正。校正完成后保存即可。 6.定义字体特征文件。Tesseract-OCR3.01以上的版本在训练之前需要创建一个名称为font_properties的字体特征文件。 font_properties不含有BOM头，文件内容格式如下： <fontname> <italic> <bold> <fixed> <serif> <fraktur> 其中fontname为字体名称，必须与[lang].[fontname].exp[num].box中的名称保持一致。<italic> 、<bold> 、<fixed> 、<serif>、 <fraktur>的取值为1或0，表示字体是否具有这些属性。 这里在样本图片所在目录下创建一个名称为font_properties的文件，用记事本打开，输入以下下内容： font 0 0 0 0 0这里全取值为0，表示字体不是粗体、斜体等等。 7.生成语言文件。在样本图片所在目录下创建一个批处理文件，输入如下内容。 rem 执行改批处理前先要目录下创建font_properties文件echo Run Tesseract for Training..tesseract.exe num.font.exp0.tif num.font.exp0 nobatch box.trainecho Compute the Character Set..unicharset_extractor.exe num.font.exp0.boxmftraining -F font_properties -U unicharset -O num.unicharset num.font.exp0.trecho Clustering..cntraining.exe num.font.exp0.trecho Rename Files..rename normproto num.normprotorename inttemp num.inttemprename pffmtable num.pffmtablerename shapetable num.shapetable echo Create Tessdata..combine_tessdata.exe num. 将批处理通过命令行执行。执行后的结果如下： 需确认打印结果中的Offset 1、3、4、5、13这些项不是-1。这样，一个新的语言文件就生成了。 num.traineddata便是最终生成的语言文件，将生成的num.traineddata拷贝到Tesseract-OCR-->tessdata目录下。可以用它来进行字符识别了。 使用训练后的语言库识别 用训练后的语言库识别number.jpg文件， 打开命令行，定位到Tesseract-OCR目录，输入命令： tesseract.exe number.jpg result -l eng 识别结果如如图所示，可以看到识别率提高了不少。通过自定义训练样本，可以进行图形验证码、车牌号码识别等。感兴趣的朋友可以研究研究。","title":"Tesseract-OCR 字符识别---样本训练"},{"content":"系统自带(四种效果)： presentModalViewController模态的动画效果设置：          UIViewController *detailViewController = [[UIViewController alloc] init];    detailViewController.modalTransitionStyle = UIModalTransitionStylePartialCurl;    // 设置动画效果    [self presentModalViewController:detailViewController animated:YES];    [detailViewController release];     共有以下四种动画效果：         typedef enum {        UIModalTransitionStyleCoverVertical = 0,        UIModalTransitionStyleFlipHorizontal,        UIModalTransitionStyleCrossDissolve,        #if __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_3_2        UIModalTransitionStylePartialCurl,        #endif    } UIModalTransitionStyle; 自定义： CATransition *animation = [CATransition animation];[animation setDuration:0.5];[animation setType:kCATransitionPush];[animation setSubtype:kCATransitionFromRight];[animation setTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]];[[myViewController.view layer] addAnimation:animation forKey:@\"SwitchToView\"];  [self presentModalViewController:myViewController animated:NO];","title":"presentModalViewController 的动画效果"},{"content":"1. 8086/8088微处理器内部结构 ① 8086/8088微处理器的内部由哪两个工作部件构成？功能分别是什么？ EU（指令执行部件）和BIU（总线接口部件）。 EU功能： 执行指令。 BIU功能： 负责与微处理器“外部”的内存储器或I/O端口进行数据传输。 ② EU包括哪些组成部件？ 包含算术逻辑运算单元（ALU）、标识寄存器（FLAGS）、通用寄存器组和EU控制器4个部件 ③ BIU包括哪些组成部件？ 包含地址加法器、专用寄存器组、指令队列、总线控制逻辑4个部件 2. 8086/8088存储器组织（教材P5） ① 8086/8088系统的内存大小及地址范围 内存大小：物理地址用20位二进制表示，所以内存大小为2^20=1M 地址范围： ② 存储器的分段结构","title":"8086/8088微处理器"},{"content":"当外部应用需要对ContentProvider中的数据进行添加、删除、修改和查询操作时，可以使用ContentResolver 类来完成，要获取ContentResolver 对象，可以使用Activity提供的getContentResolver()方法。 ContentResolver 类提供了与ContentProvider类相同签名的四个方法： public Uri insert(Uri uri, ContentValues values) 该方法用于往ContentProvider添加数据。 public int delete(Uri uri, String selection, String[] selectionArgs) 该方法用于从ContentProvider删除数据。 public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) 该方法用于更新ContentProvider中的数据。 public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) 该方法用于从ContentProvider中获取数据。 这些方法的第一个参数为Uri，代表要操作的是哪个ContentProvider和对其中的什么数据进行操作，假设给定的是： Uri.parse(“content://cn.itcast.provider.personprovider/person/10”)，那么将会对主机名为cn.itcast.provider.personprovider的ContentProvider进行操作，操作的数据为person表中id为10的记录。 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 使用ContentResolver对ContentProvider中的数据进行添加、删除、修改和查询操作： ContentResolver resolver =  getContentResolver(); Uri uri = Uri.parse(\"content://cn.itcast.provider.personprovider/person\"); //添加一条记录 ContentValues values = new ContentValues(); values.put(\"name\", \"itcast\"); values.put(\"age\", 25); resolver.insert(uri, values); //获取person表中所有记录 Cursor cursor = resolver.query(uri, null, null, null, \"personid desc\"); while(cursor.moveToNext()){ Log.i(\"ContentTest\", \"personid=\"+ cursor.getInt(0)+ \",name=\"+ cursor.getString(1)); } //把id为1的记录的name字段值更改新为liming ContentValues updateValues = new ContentValues(); updateValues.put(\"name\", \"liming\"); Uri updateIdUri = ContentUris.withAppendedId(uri, 2); resolver.update(updateIdUri, updateValues, null, null); //删除id为2的记录 Uri deleteIdUri = ContentUris.withAppendedId(uri, 2); resolver.delete(deleteIdUri, null, null);","title":"使用ContentResolver操作ContentProvider中的数据"},{"content":"android 动态换肤，Android系统已经完美解决换肤问题，看到网上好多的朋友还在询问如何换肤。我示例一下Android换肤 看效果 点击 Day 后的主题皮肤 点击 Night后，主题皮肤 package cn.hpc.assistant;import android.app.Activity;import android.content.Context;import android.graphics.PixelFormat;import android.graphics.Point;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.view.Gravity;import android.view.View;import android.view.WindowManager;import android.view.WindowManager.LayoutParams;public class MainActivity extends Activity {\tprivate int mThemeId = -1; // 皮肤主题ID，默认-1 不处理\t@Override\tprotected void onCreate(Bundle savedInstanceState) {\t\tsuper.onCreate(savedInstanceState);\t\tif (savedInstanceState != null) {\t\t\tif (savedInstanceState.getInt(\"theme\", -1) != -1) {// 读取皮肤主题ID，-1 不处理\t\t\t\tmThemeId = savedInstanceState.getInt(\"theme\");\t\t\t\tthis.setTheme(mThemeId);  //设置主题皮肤\t\t\t}\t\t}\t\tsetContentView(R.layout.activity_main);\t\tthis.findViewById(R.id.id_btn_day).setOnClickListener(mOnClickListener);   // day 明亮主题\t\tthis.findViewById(R.id.id_btn_night).setOnClickListener(mOnClickListener);  //night 黑暗主题\t}\tView.OnClickListener mOnClickListener = new View.OnClickListener() {\t\t@Override\t\tpublic void onClick(View v) {\t\t\t// TODO Auto-generated method stub\t\t\tswitch (v.getId()) {\t\t\tcase R.id.id_btn_day:\t\t\t\tonTheme(android.R.style.Theme_Light);\t\t\t\tbreak;\t\t\tcase R.id.id_btn_night:\t\t\t\tonTheme(android.R.style.Theme_Black);\t\t\t\tbreak;\t\t\tdefault:\t\t\t}\t\t}\t};          // 设置主题，并重建\tprivate void onTheme(int iThemeId){\t\tmThemeId = iThemeId;\t\tthis.recreate();\t}\t// 保存主题ID，onCreate 时读取主题\t@Override\tpublic void onSaveInstanceState(Bundle outState) {\t\tsuper.onSaveInstanceState(outState);\t\toutState.putInt(\"theme\", mThemeId);\t}} 布局文件： activity_main.xml <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:tools=\"http://schemas.android.com/tools\"    android:layout_width=\"wrap_content\"    android:layout_height=\"wrap_content\"    android:orientation=\"horizontal\"    tools:context=\".MainActivity\" >    <TextView        android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\"        android:layout_centerHorizontal=\"true\"        android:layout_centerVertical=\"true\"        android:text=\"@string/hello_world\" />    <Button        android:id=\"@+id/id_btn_fun\"        android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\" />    <Button        android:id=\"@+id/id_btn_day\"        android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\"         android:text=\"Day\"/>    <Button        android:id=\"@+id/id_btn_night\"        android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\"        android:text=\"Night\" /><\/LinearLayout>","title":"android 动态切换主题,动态换肤"},{"content":"第七课的主要内容：iPad 和iPhone的通用程序 这节课主要讲如何在一个程序里适配iPad 和iPhone。 内容简介 1、UIToolbar上面放的都是UIBarButtonItem 可以参考iOS学习之UINavigationController详解与使用(三)ToolBar 这节课的Demo是把UIToolbar拖放到iPad的故事版的顶部来使用。 2、UISplitViewController UISplitViewController只能在iPad的storyboard使用。 3、UISplitViewControllerDelegate Showing and Hiding View Controllers – splitViewController:shouldHideViewController:inOrientation: – splitViewController:willHideViewController:withBarButtonItem:forPopoverController: – splitViewController:willShowViewController:invalidatingBarButtonItem: – splitViewController:popoverController:willPresentViewController:这几个代理方法会用到。 有了这些理论知识后， 开始Demo 先得有上节课的材料：Psychologist.zip 的程序。把这个项目下载下来，打开。 在开始弄iPad之前，先解决下下面这个bug. 在前面的课程都是用的iPhone的项目。这次打开源码后，运行时选择模拟器选择iPad。运行后 按command+ ->改变模拟器的方向，上面的的button显示不大好看，改一下 spring&structs。 这样在app水平放下时按钮自动缩放了。 开始通用程序的修改吧 1、修改项目设置为Universal。 打开项目targets 把原来的MainStoryboard.storyboard改名成：iPhone.storyboard。 对应的targets也改成iPhone.storyboard。 新建一个iPad.storyboard,targets里添加iPad.storyboard。 2、在iPad.storyboard拖放一个UISplitViewController。 iPad.storyboard里是一片空白，放进去UISplitViewController好大个家伙。 后面的table view controller不需要，删掉。 3、新建RotatableViewController 新建RotatableViewController之后，把iPhone storyboard里的Psychologist界面拷到iPad.storyboard 然后在navigation Controller上按住control拖到 Psychologist界面上，选择relationship 为root view。 把对应的Dr.Pill 和Dr. Freud都拷过来，从两个按钮那拖过来选push方式。 把Psychologist的界面的class设置为：RotatableViewController RotatableViewController的代码如下： #import <UIKit/UIKit.h>@interface RotatableViewController : UIViewController<UISplitViewControllerDelegate>@end #import \"RotatableViewController.h\"#import \"SplitViewBarButtonItemPresenter.h\"@interface RotatableViewController ()@end@implementation RotatableViewController- (void)awakeFromNib{    [super awakeFromNib];    self.splitViewController.delegate = self;}- (id <SplitViewBarButtonItemPresenter>)splitViewBarButtonItemPresenter{    id detailVC = [self.splitViewController.viewControllers lastObject];    if (![detailVC conformsToProtocol:@protocol(SplitViewBarButtonItemPresenter)]) {        detailVC = nil;    }    return  detailVC;}- (BOOL)splitViewController:(UISplitViewController *)svc   shouldHideViewController:(UIViewController *)vc              inOrientation:(UIInterfaceOrientation)orientation{    return [self splitViewBarButtonItemPresenter] ? UIInterfaceOrientationIsPortrait(orientation) :NO;} - (void)splitViewController:(UISplitViewController *)svc     willHideViewController:(UIViewController *)aViewController          withBarButtonItem:(UIBarButtonItem *)barButtonItem       forPopoverController:(UIPopoverController *)pc{    barButtonItem.title = self.title;    [self splitViewBarButtonItemPresenter].splitViewBarButtonItem = barButtonItem;    }-(void)splitViewController:(UISplitViewController *)svc    willShowViewController:(UIViewController *)aViewController invalidatingBarButtonItem:(UIBarButtonItem *)barButtonItem{     [self splitViewBarButtonItemPresenter].splitViewBarButtonItem = nil;}- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation{    return YES;}@end 4、设置HappinessViewController 把iPad.storyboard上最大的detail 的controller设置它的class为HappinessViewController。 再拖放一个空白的view到上面去，选择view,设置view的class为FaceView。 点住Happiness View controller的黄色按钮，再按住conrtol按钮拖到view上，选择faceView。 现在运行看下效果： 运行正常。 不过现在还没有和它的幸福度关联起来。 5、关联幸福度 在PsychologistViewController.m文件里修改添加如下： - (HappinessViewController *)splitViewHappinessViewController{    id hvc = [self.splitViewController.viewControllers lastObject];    if (![hvc isKindOfClass:[HappinessViewController class]]) {        hvc = nil;    }    return hvc;}- (void)setAndShowDiagnosis:(int)diagnosis{    self.diagnosis = diagnosis;    if ([self splitViewHappinessViewController]) {        [self splitViewHappinessViewController].happiness = diagnosis;    }else{        [self performSegueWithIdentifier:@\"ShowDiagnosis\" sender:self];    }}这样就ok了。 6、添加UIToolbar 在iPad.storyboard大大的view的最上面拖放一UIToolbar ,把item删掉。关联代码里的toolbar 。 添加一个protocol 新建protocol  SplitViewBarButtonItemPresenter #import <UIKit/UIKit.h>@protocol SplitViewBarButtonItemPresenter <NSObject>@property (nonatomic, strong) UIBarButtonItem *splitViewBarButtonItem;@end HappinessViewController .h #import <UIKit/UIKit.h>#import \"SplitViewBarButtonItemPresenter.h\"@interface HappinessViewController : UIViewController<SplitViewBarButtonItemPresenter>@property (nonatomic) int happiness;  // 0 is sad; 100 is very happy@end HappinessViewController实现协议。 #import \"HappinessViewController.h\"#import \"FaceView.h\"@interface HappinessViewController() <FaceViewDataSource>@property (nonatomic, weak) IBOutlet FaceView *faceView;@property (nonatomic, weak) IBOutlet UIToolbar *toolbar;@end@implementation HappinessViewController@synthesize happiness = _happiness;@synthesize faceView = _faceView;@synthesize splitViewBarButtonItem = _splitViewBarButtonItem;@synthesize toolbar = _toolbar;- (void)setSplitViewBarButtonItem:(UIBarButtonItem *)splitViewBarButtonItem{    if (_splitViewBarButtonItem != splitViewBarButtonItem) {        NSMutableArray *toolbarItems = [self.toolbar.items mutableCopy];        if (_splitViewBarButtonItem) {            [toolbarItems removeObject:_splitViewBarButtonItem];        }        if (splitViewBarButtonItem) {            [toolbarItems insertObject: splitViewBarButtonItem atIndex:0 ];        }        self.toolbar.items = toolbarItems;        _splitViewBarButtonItem = splitViewBarButtonItem;    }}//....... 运行，看下效果：   看到toolbar了，可以点它展开左边的栏。可以按 command+ 方向键来跳转模拟器的放下看效果。 这是跟着视频做好的代码 http://download.csdn.net/detail/totogo2010/4927845 容芳志 (http://blog.csdn.net/totogo2010) 本文遵循“署名-非商业用途-保持一致”创作公用协议","title":"2011年冬斯坦福大学公开课 iOS应用开发教程学习笔记(第七课)"},{"content":"主activity package com.netimg;import android.app.Activity;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.ImageView;import android.widget.Toast;public class AndroidnetimgActivity extends Activity {    /** Called when the activity is first created. */\t//定义所使用的组件\tprivate Button button;\tprivate EditText editText;\tprivate ImageView imagesView;\t    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.main);        //实例化用到的组件        editText =(EditText)findViewById(R.id.EditText);        imagesView = (ImageView)findViewById(R.id.ImageView);        button = (Button)findViewById(R.id.Button);                //为按钮添加监听事件        button.setOnClickListener(new buttonListener());            }            private final class buttonListener implements OnClickListener{\t\t@Override\t\tpublic void onClick(View v) {\t\t\tString path = editText.getText().toString();\t\t\t\t\t\tSystem.out.println(path);\t\t\t\t\t\t//通过业务类ImageService的getImage方法得到数据\t\t\ttry {\t\t\t\tbyte[] data = ImageService.getImage(path);\t\t\t\tBitmap bitmap = BitmapFactory.decodeByteArray(data, 0, data.length);\t\t\t\timagesView.setImageBitmap(bitmap);//显示图片\t\t\t} catch (Exception e) {\t\t\t\t// TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t\tToast.makeText(getApplicationContext(), \"获取失败\", 1).show();\t\t\t}\t\t\t\t\t\t\t\t}    \t    }} 业务类 package com.netimg;import java.io.InputStream;import java.net.HttpURLConnection;import java.net.URL;public class ImageService {\tpublic static byte[] getImage(String path) throws Exception {\t\t\tURL url = new URL(path);\t\t//基于HTTP协议连接对象\t\tHttpURLConnection conn = (HttpURLConnection)url.openConnection();\t\t\t\tconn.setConnectTimeout(5000);\t\tconn.setRequestMethod(\"GET\");\t\t\t\tif(conn.getResponseCode() == 200){\t\t\tInputStream inStream = conn.getInputStream();\t\t\treturn StreamTool.read(inStream);\t\t}\t\t\t\treturn null;\t}} 工具类 package com.netimg;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;public class StreamTool {\tpublic static byte[] read(InputStream inStream) throws IOException {\t\tByteArrayOutputStream outStream = new ByteArrayOutputStream();\t\tbyte[] buffer = new byte[1024];\t\tint len = 0;\t\twhile( (len = inStream.read(buffer)) != -1){\t\t\toutStream.write(buffer, 0, len);\t\t}\t\tinStream.close();\t\treturn outStream.toByteArray();\t}} 获得网络权限 <uses-permission android:name=\"android.permission.INTERNET\"/>","title":"android网络通信之通过网络获得图片"},{"content":"ContentProvider类主要方法的作用： public boolean onCreate() 该方法在ContentProvider创建后就会被调用， Android开机后， ContentProvider在其它应用第一次访问它时才会被创建。 public Uri insert(Uri uri, ContentValues values) 该方法用于供外部应用往ContentProvider添加数据。 public int delete(Uri uri, String selection, String[] selectionArgs) 该方法用于供外部应用从ContentProvider删除数据。 public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) 该方法用于供外部应用更新ContentProvider中的数据。 public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) 该方法用于供外部应用从ContentProvider中获取数据。 public String getType(Uri uri) 该方法用于返回当前Url所代表数据的MIME类型。如果操作的数据属于集合类型，那么MIME类型字符串应该以vnd.android.cursor.dir/开头，例如：要得到所有person记录的Uri为content://cn.itcast.provider.personprovider/person，那么返回的MIME类型字符串应该为：“vnd.android.cursor.dir/person”。如果要操作的数据属于非集合类型数据，那么MIME类型字符串应该以vnd.android.cursor.item/开头，例如：得到id为10的person记录，Uri为content://cn.itcast.provider.personprovider/person/10，那么返回的MIME类型字符串应该为：“vnd.android.cursor.item/person”。 ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------","title":"使用ContentProvider共享数据"},{"content":"利用HttpURLConnection对象,我们可以从网络中获取文件数据. URL url = new URL(\"http://photocdn.sohu.com/20100125/Img269812337.jpg\"); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setConnectTimeout(5* 1000); conn.setRequestMethod(\"GET\"); if (conn.getResponseCode() != 200) throw new RuntimeException(\"请求url失败\"); InputStream is = conn.getInputStream(); readAsFile(is, \"Img269812337.jpg\"); public static void readAsFile(InputStream inSream, File file) throws Exception{ FileOutputStream outStream = new FileOutputStream(file); byte[] buffer = new byte[1024]; int len = -1; while( (len = inSream.read(buffer)) != -1 ){ outStream.write(buffer, 0, len); }   outStream.close(); inSream.close(); }","title":"从Internet获取数据"},{"content":"    最近在iOS开发中，需要用到单例模式，于是自己动手写了一个，它看起来是这样的： <1> + (id)sharedInstance{    static id sharedInstance = nil;        if (!sharedInstance) {        sharedInstance = [[NSObject alloc] init];    }        return sharedInstance;}     后来发现许多书上的做法都使用到了BOOL变量作为标值位，它看起来是这样的： <2> + (id)sharedInstance{    static id sharedInstance = nil;    static BOOL token = NO;        if (!token) {        token = YES;                sharedInstance = [[NSObject alloc] init];    }        return sharedInstance;}     但是参考了苹果官方的单例模式代码，发现它看起来是这样的： <3> + (id)sharedInstance{    static id sharedInstance;    static dispatch_once_t onceToken;        dispatch_once(&onceToken, ^{        sharedInstance = [[NSObject alloc] init];    });        return sharedInstance;}     那么它们究竟有多大区别呢？     原来，它们的区别在于多线程并发时的表现。     <1>使用了一个指针变量作为标志位，这在多线程并发时是不可取的，因为sharedInstance = [[NSObject alloc] init];这行代码的执行本身是需要时间的。很可能有两个线程同时进入到了这行代码，而这将导致内存泄漏。     <2>使用的标志位是一个BOOL变量，尽管token = YES;这行代码的执行也需要时间，但是它远远好过<1>     <3>使用了dispatch_once函数。这个函数来自于Grand Central Dispatch (GCD)，Apple自Mac OS 10.6 / iOS 4.0引用了它。     该函数接收一个dispatch_once_t用于检查该代码块是否已经被调度的谓词（是一个长整型，实际上作为BOOL使用）。它还接收一个希望在应用的生命周期内仅被调度一次的代码块。这不仅意味着代码仅会被运行一次，而且还是线程安全的，你不需要使用诸如@synchronized之类的来防止使用多个线程或者队列时不同步的问题。     Apple的GCD Documentation证实了这一点:     如果被多个线程调用，该函数会同步等等直至代码块完成。","title":"iOS 单例模式"},{"content":"main.xml如下: <RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:tools=\"http://schemas.android.com/tools\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\" >    <Button        android:id=\"@+id/button\"        android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\"        android:layout_centerHorizontal=\"true\"        android:text=\"下载图片\"     />    <ImageView        android:id=\"@+id/imageView\"        android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\"        android:layout_centerInParent=\"true\"     /><\/RelativeLayout> manifest.xml如下: <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"    package=\"cn.com\"    android:versionCode=\"1\"    android:versionName=\"1.0\" >    <uses-sdk        android:minSdkVersion=\"8\"        android:targetSdkVersion=\"15\" />     <uses-permission android:name=\"android.permission.INTERNET\" />    <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />    <uses-permission android:name=\"android.permission.MOUNT_UNMOUNT_FILESYSTEMS\" />         <application        android:icon=\"@drawable/ic_launcher\"        android:label=\"@string/app_name\"        android:theme=\"@style/AppTheme\" >        <activity            android:name=\".MainActivity\"            android:label=\"@string/title_activity_main\" >            <intent-filter>                <action android:name=\"android.intent.action.MAIN\" />                <category android:name=\"android.intent.category.LAUNCHER\" />            <\/intent-filter>        <\/activity>    <\/application><\/manifest>  ","title":"Android中SQlite数据库存取Bitmap(二)"},{"content":"Xml代码   <LinearLayout android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\"                   android:id=\"@+id/checkinlinear\" android:layout_below=\"@id/assetnameet\"                   android:focusable=\"true\"  android:focusableInTouchMode=\"true\"                   android:lineSpacingExtra=\"5dip\">                  <EditText android:id=\"@+id/checkin_content\" android:layout_height=\"50dip\" android:layout_width=\"200dip\"                   android:layout_weight=\"1\" android:hint=\"@string/checkin_content_hint\" android:singleLine=\"true\"/>                <Button android:text=\"@string/checkin_submit_btn\" android:id=\"@+id/checkin_submitbtn\"                 android:layout_height=\"wrap_content\" android:layout_width=\"wrap_content\"                 android:layout_weight=\"3\"/>     <\/LinearLayout>    android:focusable=\"true\"  android:focusableInTouchMode=\"true\"   此前,当我进入做项目的时候!发现,当我进入到对应的ui中,焦点会自动的到edittext中,这样就会呼出软键盘!我在网上找了一些资料!有的是关闭,或者监控软键盘状态,或者焦点位置!    但是!这些都不是我项目想要的!   我想要的仅仅是第一次进入到对应ui的时候,不要呼出软键盘,当用户点击的时候,才呼出软键盘!      而在linearyout中加入这两行代码就能实现我的要求了了!","title":"取消自动获取焦点(默认进来焦点到edittext),取消进入呼出软件盘"},{"content":"mainActivity如下: package cn.testcamera;import java.io.File;import java.text.SimpleDateFormat;import java.util.Date;import android.app.Activity;import android.content.ContentResolver;import android.content.ContentUris;import android.content.Intent;import android.database.Cursor;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.net.Uri;import android.os.Bundle;import android.provider.MediaStore;import android.view.View;import android.widget.Button;import android.widget.ImageView;public class MainActivity extends Activity {\tprivate Button mButton;\tprivate ImageView mImageView;\tprivate File mPhotoFile;\tprivate String mPhotoPath;\tprivate Uri mPhotoOnSDCardUri;    public final static int CAMERA_RESULT=777;    public final static int CAMERA_RESULT_CUT=888;    public final static int CAMERA_RESULT_CUT_OVER=999;    public final static String TAG=\"xx\";\t@Override\tpublic void onCreate(Bundle savedInstanceState) {\t\tsuper.onCreate(savedInstanceState);\t\tsetContentView(R.layout.main);\t\tmButton = (Button) findViewById(R.id.button);\t\tmButton.setOnClickListener(new ButtonOnClickListener());\t\tmImageView = (ImageView) findViewById(R.id.imageView);\t}\tprivate class ButtonOnClickListener implements View.OnClickListener {\t\tpublic void onClick(View v) {\t\t\ttry {\t\t\t\tIntent intent = new Intent(\"android.media.action.IMAGE_CAPTURE\");\t\t\t\tmPhotoPath=\"mnt/sdcard/DCIM/Camera/\"+getPhotoFileName();\t\t\t\tmPhotoFile = new File(mPhotoPath);\t\t\t\tif (!mPhotoFile.exists()) {\t\t\t\t\tmPhotoFile.createNewFile();\t\t\t\t}\t\t\t\tmPhotoOnSDCardUri=Uri.fromFile(mPhotoFile);\t\t\t    intent.putExtra(MediaStore.EXTRA_OUTPUT, mPhotoOnSDCardUri);\t\t\t    //拍照后显示此图片\t\t        //startActivityForResult(intent,CAMERA_RESULT);\t\t        //拍照后先修改再显示此图片\t\t        startActivityForResult(intent,CAMERA_RESULT_CUT);\t\t\t} catch (Exception e) {\t\t\t}\t\t}\t}\t\t@Override\tprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\t\tsuper.onActivityResult(requestCode, resultCode, data);\t\t//1   拍照后显示照片\t\tif (requestCode==CAMERA_RESULT) {\t\t\t Bitmap bitmap = BitmapFactory.decodeFile(mPhotoPath, null);  \t\t\t mImageView.setImageBitmap(bitmap);\t\t}\t\t//2   拍照后剪切照片,然后显示\t\t//2.1拍照且剪裁\t\tif (requestCode == CAMERA_RESULT_CUT) {\t\t\tIntent intent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE,mPhotoOnSDCardUri);\t\t\tsendBroadcast(intent);\t\t\ttry {\t\t\t\tThread.sleep(2000);\t\t\t} catch (InterruptedException e) {\t\t\t\te.printStackTrace();\t\t\t}\t\t\tUri systemImageUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;\t\t\tContentResolver contentResolver = getContentResolver();\t\t\tCursor cursor = contentResolver.query(systemImageUri, null,\t\t\t\t\tMediaStore.Images.Media.DISPLAY_NAME + \"='\"\t\t\t\t\t\t\t+ mPhotoFile.getName() + \"'\", null, null);\t\t\tUri photoUriInMedia = null;\t\t\tif (cursor != null && cursor.getCount() > 0) {\t\t\t\tcursor.moveToLast();\t\t\t\tlong id = cursor.getLong(0);\t\t\t\tphotoUriInMedia = ContentUris.withAppendedId(systemImageUri, id);\t\t\t}\t\t\tcursor.close();\t\t\tIntent in = new Intent(\"com.android.camera.action.CROP\");\t\t\t//需要裁减的图片格式\t\t\tin.setDataAndType(photoUriInMedia, \"image/*\");\t\t\t//允许裁减\t\t\tin.putExtra(\"crop\", \"true\");\t\t\t//剪裁后ImageView显时图片的宽\t\t\tin.putExtra(\"outputX\", 250);\t\t\t//剪裁后ImageView显时图片的高\t\t\tin.putExtra(\"outputY\", 250);\t\t\t//设置剪裁框的宽高比例\t\t\tin.putExtra(\"aspectX\", 1);\t\t\tin.putExtra(\"aspectY\", 1);\t\t\tin.putExtra(\"return-data\", true);\t\t\tstartActivityForResult(in, CAMERA_RESULT_CUT_OVER);\t\t}\t\t//2.2显示\t\tif (requestCode==CAMERA_RESULT_CUT_OVER) {\t\t\t//剪切图片的时候,若\"放弃\"则回答的data为null\t\t\tif (data!=null) {\t\t\t\tBitmap bitmap = (Bitmap) data.getExtras().get(\"data\");\t\t\t\tmImageView.setImageBitmap(bitmap);\t\t\t}\t\t}\t}\t\tprivate String getPhotoFileName() {\t\tDate date = new Date(System.currentTimeMillis());\t\tSimpleDateFormat dateFormat = new SimpleDateFormat(\"'IMG'_yyyyMMdd_HHmmss\");\t\treturn dateFormat.format(date) + \".jpg\";\t}} main.xml如下: <RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:tools=\"http://schemas.android.com/tools\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\" >    <Button        android:id=\"@+id/button\"        android:layout_width=\"fill_parent\"        android:layout_height=\"wrap_content\"        android:text=\"点击按钮拍照\"     />    <ImageView         android:id=\"@+id/imageView\"        android:layout_below=\"@id/button\"        android:layout_width=\"fill_parent\"        android:layout_height=\"wrap_content\"     /><\/RelativeLayout> manifest.xml如下: <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"    package=\"cn.testcamera\"    android:versionCode=\"1\"    android:versionName=\"1.0\" >    <uses-sdk        android:minSdkVersion=\"8\"        android:targetSdkVersion=\"10\" />    <uses-permission android:name=\"android.permission.CAMERA\"/>    <uses-permission android:name=\"android.permission.INTERNET\" />    <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />      <application        android:icon=\"@drawable/ic_launcher\"        android:label=\"@string/app_name\"        android:theme=\"@style/AppTheme\" >        <activity            android:name=\".MainActivity\"            android:launchMode=\"singleTask\"            android:label=\"@string/title_activity_main\" >            <intent-filter>                <action android:name=\"android.intent.action.MAIN\" />                <category android:name=\"android.intent.category.LAUNCHER\" />            <\/intent-filter>        <\/activity>    <\/application><\/manifest>  ","title":"Android拍照后先剪裁再显示图片"},{"content":"Handler的官方注释如下： A Handler allows you to send and process Message and Runnable objects associated with a thread’s MessageQueue. Each Handler instance is associated with a single thread and that thread’s message queue. Handler会关联一个单独的线程和消息队列。Handler默认关联主线程，虽然要提供Runnable参数 ，但默认是直接调用Runnable中的run()方法。也就是默认下会在主线程执行，如果在这里面的操作会有阻塞，界面也会卡住。如果要在其他线程执行，可以使用HandlerThread。 Handler使用方法：         Handler handler = new Handler() { \t\t\t@Override\t\t\tpublic void handleMessage(Message msg) {\t\t\t\t// 处理发送过来的消息\t\t\t\tBundle b = msg.getData();\t\t\t\tSystem.out.println(\"msg:\" + msg.arg1);\t\t\t\tSystem.out.println(\"msg:\" + b.getString(\"name\") + \" - age:\" + b.getInt(\"age\"));\t\t\t\tsuper.handleMessage(msg);\t\t\t}         };         Message msg = handler.obtainMessage();        msg.arg1 = 121;        Bundle b = new Bundle();        b.putInt(\"age\", 24);        b.putString(\"name\", \"Fatkun\");        msg.setData(b);        msg.sendToTarget();         handler.post(r);     }     Runnable r = new Runnable() { \t\tpublic void run() {\t\t\ttry {                                // 在这里只是睡一下\t\t\t\tThread.sleep(10000);\t\t\t} catch (InterruptedException e) {\t\t\t\te.printStackTrace();\t\t\t} \t\t}\t}; HandlerThread使用方法： //把上面创建Handler的代码Handler handler = new Handler() {...} //改为：HandlerThread thread = new HandlerThread(\"athread\");thread.start(); //要把线程启动 Handler handler = new Handler(thread.getLooper()) {...}","title":"Android Handler和HandlerThread使用方法"},{"content":"一、实现步骤 1、点击 Window -----> navigation ---》出现如下窗口 2、烘焙场景，在需要巡路的对象上添加Nav mesh Agent组件， Component ----->navigation ---->Nav mesh Agent 3、在你需要巡路的对象上添加了Nav mesh Agent组件，需要进行合理的设置，如下图， 还需写一个脚本，我这里的脚本是ZhuJueXunLu.cs 代码如下： using UnityEngine; using System.Collections; public class ZhuJueXunLu : MonoBehaviour { public bool isKaiHui = false; //主角开会 private Vector3 destination; public void SetIsKaiHui(bool flag){ this.isKaiHui = flag; } public bool GetIsKaiHui() { return this.isKaiHui; } public void Start () { } public void Update () { if(isKaiHui){ destination = SI_Logic.kaiHuiWeiZhi_ZJ; this.GetComponent<NavMeshAgent>().destination = destination;//目的地 if (this.GetComponent<NavMeshAgent>().hasPath) //还有路程吗？ { this.animation[\"Zou\"].layer = 1; this.animation.CrossFade(\"Zou\") ; }else { this.animation[\"DaiJi\"].layer = 1; this.animation.CrossFade(\"DaiJi\"); } } } }","title":"Unity3.5 自带的寻路功能简单实现"},{"content":"2.第二阶段代码分析（代码在lib_arm目录下的board.c里面，start_armboot函数）   1）初始化CPU及外围硬件   voidstart_armboot (void) {        init_fnc_t **init_fnc_ptr;        char *s; #ifdefined(CONFIG_VFD) || defined(CONFIG_LCD)        unsigned long addr; #endif          /* Pointer is writable since we allocateda register for it */        gd = (gd_t*)(_armboot_start -CONFIG_SYS_MALLOC_LEN - sizeof(gd_t));        /* compiler optimization barrier neededfor GCC >= 3.4 */        __asm__ __volatile__(\"\": ::\"memory\");          memset ((void*)gd, 0, sizeof (gd_t));        gd->bd = (bd_t*)((char*)gd -sizeof(bd_t));        memset (gd->bd, 0, sizeof (bd_t));          gd->flags |= GD_FLG_RELOC;          monitor_flash_len = _bss_start -_armboot_start;          for (init_fnc_ptr = init_sequence;*init_fnc_ptr; ++init_fnc_ptr) {               if((*init_fnc_ptr)() != 0) {                      hang ();               }        }   解释：定义二级指针init_fnc_ptr指向一个存放函数指针的数组，init_fnc_ptr是typedef int (init_fnc_t) (void)类型，即函数类型，init_fnc_ptr可以指向一个没有参数，返回值为int型的函数指针的地址，我们看上面代码最后的for循环init_fnc_ptr = init_sequence，if中会使用（*init_fnc_ptr)()方式调用init_sequence中的函数（函数名可以看为一个地址），如果返回值不是0，则执行hang报错。gd = (gd_t*)(_armboot_start -CONFIG_SYS_MALLOC_LEN - sizeof(gd_t)); 我们知道，malloc区域、stack区域、bdinfo数据、gd_t在内存的位置是放在upper of uboot。__asm__ __volatile__(\"\":: :\"memory\");这条是内嵌汇编，请查看另一篇介绍内嵌汇编的博文。        gd->bd指针指向数据类型为bd_t的结构体，bd_t结构体记录开发板的参数，例如串口波特率、ip地址、机器类型、启动参数、环境变量位置等。 monitor_flash_len= _bss_start - _armboot_start; bss段是u-boot最后一个段，bss最终需要清零，这时候不再需要搬移，可以参考链接脚本u-boot.lds。        下面分析for循环执行的函数： #ifdefined(CONFIG_ARCH_CPU_INIT)        arch_cpu_init,        /* basic arch cpudependent setup */ #endif 这里我们定义了CONFIG_ARCH_CPU_INIT，所以执行函数arch_cpu_init。跳到这里，又有一个宏，CONFIG_ARCH_CPU_INIT，这个宏也是定义了的，所以可以继续看，                   board_init：   30，31行一个是记录机器类型，一个是指定向内核传参的地址。 继续分析,宏CONFIG_USE_IRQ),函数interrupt_init不执行          init_baudrate：        139行使用getenv_r函数在default_environment里找baudrate关键字，找到后把“=”号后面的值赋值给gd->baudrate，然后         再放到gd->bd->bi_baudrate里面。simple_strtoul是uboot实现的字符串转UL类型。        serial_init：什么都没做，保持默认的8位数据、无奇偶校验、1 停止位、无开始位。        console_init_f：gd->have_console = 1就这一句话        display_banner：串口打印uboot信息，就是uboot启动的时候我们看到的信息，这里使用的是printf，但是我们追进去后，关注的函数        应该是serial_putc，它是真实向串口输出一个字符的函数，这个函数会递归调用，应该说自己调用自己，遇到\\n结束。        print_cpuinfo：打印CPU信息，CPU型号和速度 CPU：...        checkboard：打印开发板信息 BOARD：...        dram_init：        记录dram的起始地址，0x30000000，size为256M（smdkc100的）        display_dram_config：因为没有定义DEBUG，所以打印DRAM:256M   2）配置malloc空间  这个函数的作用是记录堆栈空间的起始地址、结束地址、当前地址。    4）环境变量初始化 5）网络初始化 6）设备列表初始化 7）配置功能函数表 8）终端完全初始化 9）开中断异常向量表 10）网卡芯片初始化 11）一些后续初始化 12）main_loop详解 等有时间，会针对这些问题在新的文章中深入浅出说明上述问题","title":"smdkc100之u-boot 2010.03代码的分析3"},{"content":"作用域          当前类                同包                 子孙类           其他包 public              √                        √                       √                        √ protected        √                        √                       √                         × default            √                        √                        ×                        × private            √                         ×                       ×                        ×","title":"Java--访问修饰符"},{"content":"        前段时间参加了2012年度IT博客大赛，进了前十强，写了一篇获奖感言，不过还没正式在CSDN发表出来。眼看2012年就要结束了，刚好借这个机会将2012年度IT博客大十强获奖感言发表出来，也算是对2012年博客的一个总结，关键字是“梦想”、“学习”、“坚持”、“自信”、“淡定”。希望大家一如既往地支持老罗的CSDN专栏《老罗的Android之旅》以及老罗的新书《Android系统源代码情景分析》。         自2011年6月21日开博至今天2012年12月31日，在这560天里面，主要是取得了以下成绩：         1. 发表了72篇原创博客，访问量1060200次，评论3153条。         2. 出版了《Android系统源代码情景分析》一书，一共3大篇16章830页1570千字。         3. 被评为2012年度十大杰出博客。         写博客之初，是没有出书的计划的，不过在各方面的巧合之下，就整理了博客上的文章，然后就出版了，不过也算是了却心愿，以后就可以专心地写博客了。下面就简单说一下从写博客以来的一些感受。         1. 梦想。APP刚刚火起来的那阵子，还没接触过移动开发。有一天听说我们的产品经理自己做了个APP，用来订阅自己感兴趣的视频。顿时倍受打击：连产品经理都会做APP了，作为一个码农，怎么还能对移动开发无动于衷呢？！于是就准备学习移动开发，做个APP来玩玩。但是后来想了一下，其实我更感兴趣的是移动操作系统，很想知道它和PC操作系统有什么区别。于是就带着“了解移动操作系统长什么样子”这个梦想踏上了研究Android的旅程。再啰嗦说一下梦想这个话题。再年轻一些的时候，会觉得谈梦想是一件很扯很遥远很虚无缥缈的事情。随着年纪的增大，年轻时的棱角随着生活中的各种遭遇和压力都慢慢地磨平了，只剩下每天重复的上下班。这时候才发现年轻时的梦想是多么的弥足珍贵：梦想原来是可以让人这么年轻而富有激情的！现在看达人秀的时候，更多的感动是来自那些选手对梦想的执着追求，而不是他们的表演。         2. 学习。决定了要学习移动操作系统开发以后，接下来就是选平台了。当时iOS和Android都是红透半边天，WP还未成型。由于Android是开放源码的，因此，它就是学习移动操作系统的不二选择了。了解到Android是基于Linux内核来开发之后，就开始看Linux内核的书：《Linux Kernel Development》、《Understanding the Linux Kernel》、《Linux Device Drivers》和《Linux内核源代码情景分析》。这四本书每一本书都至少看过两遍。对Linux内核有了大概的了解之后，就开始学习Android应用开发，因为我觉学习一个新知识的最好切入点就是先知道它是怎么使用的。于是，接下来又看了两本讲Android应用开发的书：《Professional Android Application Development》和《Google Android SDK开发范例大全》。看完了之后，觉得还是有点云里雾里，于是又写了个Android小游戏——交互式人机对战五子棋。说来和五子棋有缘，高中时经常和同学在几何簿上画着来玩玩五子棋，有时上课也偷偷玩；上大学学习C和Java时，也是拿五子棋来练手。在Android上开发的这个五子棋游戏虽小，但却五脏俱全：Activity、Service、Broadcast Receiver和Content Provider四大组件全用上了，异步任务和Binder进程间通信机制等也用上了。这为日后研究Android系统打下了坚实的基础。其实学习这个东西就是这样，它不是快餐，饿了就去吃，必须得老老实实地一步一步地打基础。         3. 坚持。长期地坚持去做一件事情，真的很难。不过，当你下定决心持续地去做一件事情的时候，你的坚持就会变成一种习惯。习惯一旦养成，你不去做那件事情的时候，反而会觉得心里不舒服，好像少了什么似的。因为平时要上班，所以一天下来，其实也没多少时间去研究Android系统。这时候我就告诉自己，更加要坚持，并且给自己算了一笔数：工作日每天看20页书，周末每天看50页书，大概两周就可以看一本400～500页的书；一天看300行左右代码，一周就能看2000～3000行代码；一天写1个段落的博客，一周也能捣鼓出1篇来。另外，当坚持了一段时间之后，就会发现学习的速度比以前更快了，就好像有一种加速度一样，这时候就会发现事情越做越快。         4. 自信。自信是很重要的，尤其是在你做一件很有挑战性的事情的时候。如果没有自信，在碰到难以解决的困难时，或许就会放弃了。其实在很多时候，机遇都是偏爱那些有自信并且一直坚持着梦想的人。记得在研究Android系统的UI渲染服务SurfaceFlinger的时候，被一个20多行代码的函数难住了，百思不得其解。后来盯了两三天，联系了各种上下文，最后总算是把它弄明白了。我一直都相信潜意识这种东西：只要你相信你能解决一个问题，并且坚持住不放弃，潜意识就会帮助你去加工和组织各种原始信息。因此，自信很重要，它是一种软实力：有自信不一定能成功，但是没有自信要成功就难上加难。         5. 淡定。淡定是一种人生态度，它能使你不功利，不浮躁，从容地面对得与失，找到一条更合适自己长远发展的路。往往梦想都是一个比较长期的东西，不是短期内就能看到效益的。在坚持梦想的过程中，又可能要付出很多代价，例如，你没有时间找（陪）老婆或者女朋友，你赚的钱没有一起毕业的同学多，诸如此类的等等事情。这时候，你就更需要淡定：只要你判断你正在做的事情是值得的，你就淡定地面对别人的眼光和周围的环境。我发现写博客以来，自己变得越来越宅了，下班后和周末都更愿意呆在房间里，当渐渐地发现同学都在忙着晒结婚照或者小孩照的时候，自己还在单身着:(。这可能就是宅的代价吧，不过现在对这件事情还是比较淡定:)。         上述5点感受总结来说就是：心怀梦想，带着自信和淡定，持之以恒，学习、学习，再学习！很讽刺的是，如果是五六年以前的自己看到上面的这些文字，我会觉得很扯，很空洞，没意义。人可能就是要非得亲自去经历一些事情，才能深刻地领会一些道理。         最后，老罗和大多数人一样，出身草根，也就是欲称的屌丝，如今也是在平凡的职位上做着平凡的事情，但是老罗相信，虽不是官二代富二代，但是拼尽全力地去奋斗，就会有希望！在接下来的2013年里面，老罗仍然会坚持写Android方面的文章，第一目标是继续研究Android系统的UI架构，第二目标是研究Android系统的Dalvik虚拟机。希望大家一如既往地支持《老罗的Android之旅》，同时，如果大家觉得博客的内容有用，还请多多支持老罗的新书《Android系统源代码情景分析》！         老罗的新浪微博：http://weibo.com/shengyangluo，欢迎关注！ ","title":"[置顶] 2012年的Android之旅：梦想、学习、坚持、自信、淡定"},{"content":"在场景中绘制多个不透明物体时很简单，哪个物体离得近，看到的就是哪个物体。但如果加入一个透明的物体，像玻璃，如何渲染就有些麻烦。拿一块红色的玻璃挡住眼睛，看到的物体都偏红，换成蓝色的玻璃，物体都偏蓝。DirectX中的“混合（Blending）”技术可以解决这个问题。混合技术其实也不难，但是通过不同运算方式和系数的组合，它能实现很多效果。它的基本原理就是混合方程： 其中乘号表示向量对应元素相乘，C和A分别表示颜色和Alpha的混合结果，其它参数可以自由指定。详细的介绍可以看DirectX 10游戏编程入门，虽然版本不同，但是原理没有区别。继续拿玻璃做例子，个人感觉混合技术就像一个调色板，只有两种颜料，分别是玻璃的颜色Csrc和它后面对应位置的物体颜色Cdst，而最终的颜色C是两种颜料按不同比例混合后的颜色，其中Fsrc控制玻璃的颜料比例，Fdst控制物体的颜料比例。Alpha通道的混合原理与颜色混合类似，不过少了两个分量。 因为Csrc和Cdst随物体不同而变化，所以实际使用混合时每个方程需要指定三个参数：混合方式、Fsrc和Fdst。在DirectX 11中，与混合相关的结构体定义如下： typedef struct D3D11_BLEND_DESC{BOOL AlphaToCoverageEnable;    BOOLIndependentBlendEnable;    D3D11_RENDER_TARGET_BLEND_DESC RenderTarget[ 8 ];}   D3D11_BLEND_DESC;typedef struct D3D11_RENDER_TARGET_BLEND_DESC{    BOOL BlendEnable;    D3D11_BLEND SrcBlend;   // Csrc    D3D11_BLEND DestBlend;  // Cdst    D3D11_BLEND_OP BlendOp; // 颜色混合方式    D3D11_BLEND SrcBlendAlpha;  // Fsrc    D3D11_BLEND DestBlendAlpha; // Fdst    D3D11_BLEND_OP BlendOpAlpha;   // Alpha混合方式UINT8 RenderTargetWriteMask;}   D3D11_RENDER_TARGET_BLEND_DESC; 其他参数的说明可以参照MSDN http://msdn.microsoft.com/ZH-CN/library/windows/desktop/ff476087(v=vs.85).aspx 了解混合技术的原理之后就要着手将混合效果添加到上一篇文章中已实现的模型中去，给水面添加透明的效果，使它更真实些。首先从修改顶点着色器代码开始。打算将Alpha纹理一整张铺在水面上，不需要复制。所以在顶点着色器的输出中添加一个texa成员，用于保存Alpha纹理坐标。 struct VertexShaderOutput{    float4 posH : SV_POSITION;    float3 posW   : POSITION;    float3 normal : NORMAL;    float2 tex : TEXCOOD;    float2 texa :TEXCOOD_ALPHA;}; 在main方法中，正常纹理坐标需要变换，但是Alpha纹理坐标不需要。 // 纹理坐标变换output.tex = mul(float4(input.tex, 0.0f, 1.0f),texTransform).xy; // Alpha纹理不进行变换output.texa = input.tex; 然后就要修改像素着色器部分，像素着色器的输入自然与顶点着色器的输出对应。同时，像素着色器还要添加一个全局变量texAlpha存储Alpha纹理资源。 Texture2D texDiffuse : register(t0);Texture2D texAlpha : register(t1); struct PixelShaderInput{    float4 posH : SV_POSITION;    float3 posW : POSITION;    float3 normal : NORMAL;    float2 tex : TEXCOOD;    float2 texa :TEXCOOD_ALPHA;}; 注意texDiffuse和texAlpha后面的register，它用来说明资源的存储位置。Alpha纹理的使用与普通纹理使用没有区别，不过这次需要用采样器采的是纹理的Alpha分量，用.a表示。 // 只有水模型会设置并使用Alpha纹理// 绘制其他模型时不保证texAlpha一定有内容// 不能实际应用// 按原始透明度显示太透明所以乘4finalColor.a = texAlpha.Sample(samplerLinear,input.texa).a * 4;       接下来就是修改C++代码。需要改动的地方只有Renderer.h和Renderer.cpp两个文件而已。这次载入的Alpha纹理资源是dds格式的，所以向项目中添加DDSTextureLoader.h和DDSTextureLoader.cpp文件，并在Renderer.h中包含DDSTextureLoader.h。此外，还要在Renderer类中添加两个成员，用来保存Alpha纹理视图和混合状态。 Microsoft::WRL::ComPtr<ID3D11ShaderResourceView> m_WaterAlphaSRV;Microsoft::WRL::ComPtr<ID3D11BlendState> m_BlendState; 完成后就可以在CreateDeviceResources方法中的createTexTask部分添加Alpha纹理载入代码并初始化混合状态。 DX::ThrowIfFailed(    CreateDDSTextureFromFile(    m_d3dDevice.Get(),    L\"Texture/water_alpha.dds\",    &tex,    m_WaterAlphaSRV.GetAddressOf()    )    ); // 初始化混合状态D3D11_BLEND_DESC blendDesc = {0};blendDesc.RenderTarget[0].BlendEnable = TRUE;blendDesc.RenderTarget[0].SrcBlend = D3D11_BLEND_SRC_ALPHA; // Color_FsrcblendDesc.RenderTarget[0].DestBlend = D3D11_BLEND_INV_SRC_ALPHA; // Color_FdstblendDesc.RenderTarget[0].BlendOp = D3D11_BLEND_OP_ADD; // Color_OperationblendDesc.RenderTarget[0].SrcBlendAlpha = D3D11_BLEND_ONE; // Alpha_FsrcblendDesc.RenderTarget[0].DestBlendAlpha = D3D11_BLEND_ZERO; // Alpha_FdstblendDesc.RenderTarget[0].BlendOpAlpha = D3D11_BLEND_OP_ADD; // Alpha_OperationblendDesc.RenderTarget[0].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL; DX::ThrowIfFailed(    m_d3dDevice->CreateBlendState(    &blendDesc,    &m_BlendState    )    ); 主要说明下颜色混合的设置。颜色的混合参数Fsrc和Fdst的说明可以从MSDN找到 http://msdn.microsoft.com/ZH-CN/library/windows/desktop/ff476086(v=vs.85).aspx D3D11_BLEND_SRC_ALPHA The blend factoris (As, As, As, As), that is alpha data (A) from a pixel shader. No pre-blendoperation. D3D11_BLEND_INV_SRC_ALPHA The blend factoris ( 1 - As, 1 - As, 1 - As, 1 - As), that is alpha data (A) from a pixelshader. The pre-blend operation inverts the data, generating 1 - A. D3D11_BLEND_OP_ADD Add source 1 andsource 2. 将其代入混合方程可得出实际的计算公式： 假设当前玻璃的透明度是0.2，那么最终的混合结果就是0.2份的玻璃颜色加上0.8份的物体颜色。创建好混合状态之后就能够使用了。不过这时要注意物体的绘制顺序，需要遵守下面的规则： 首先绘制不透明物体。然后，根据透明物体与摄像机之间的距离进行排序，按照从后向前的顺序绘制透明物体。因为混合时，透明物体要在不透明物体的前面，从而能够透过它看到后面的物体。如果这时不透明物体还没有画出来，那什么都看不到。所以，必须将透明物体后面的物体绘制出来后再进行混合。 这样，在Render方法中，要完成陆地渲染后再设置混合状态，并设置Alpha纹理，最后渲染水面，完成后清除混合状态。 // 设置水面纹理和Alpha纹理m_d3dContext->PSSetShaderResources(    0,  // 对应像素着色器中register(t0)    1,    m_WaterSRV.GetAddressOf()    ); m_d3dContext->PSSetShaderResources(    1,  // 对应像素着色器中register(t1)    1,    m_WaterAlphaSRV.GetAddressOf()); // 设置混合状态FLOAT blendFactors[4] = { 0, };m_d3dContext->OMSetBlendState(m_BlendState.Get(),blendFactors, 0xffffffff); …… // 清除混合模式状态m_d3dContext->OMSetBlendState(0, blendFactors,0xffffffff); 实际运行效果如下图： 图1是使用Alpha纹理贴图的效果，图2是统一水面的Alpha为0.6。蓝圈中是两图类似的部分，红圈则是不同部分，不是特别明显。 还可以在这个模型中加入之前实现的木箱，细节不用多说，注意要在绘制水面之前渲染木箱。效果如下图：   本篇文章的源代码：Direct3DApp_HillWaveBlend 原文地址：http://blog.csdn.net/raymondcode/article/details/8456714","title":"Windows 8 Directx 开发学习笔记（十二）利用混合实现浮在水面的木箱"},{"content":"今天在使用android-ndk-r8b时，发现其对  STL标准库支持不够好，找不到algorithm,  vector等， 网上查找时才知道要使用 crystax 类型的NDK, 这种是支持 STL的，然后改换   crystax 类型的NDK, 编译项目，algorithm vector的好了，居然又报 unreferenced   std::ios_base::Init::Init()      std::ostream 错误， 查半天， 一种方案说是gcc 编译 C++文件，需要添加   -lstdc++  库，经测试，没有通过， 另一种方案是我综合各种错误后找出的一个解决方案  -lcrystax_static -lgnustl_static -lsupc++，  编译通过，太TM伤神了","title":"NDK 编译时出现 algorithm,vector std::ios_base::Init::Init() , 以及ostream等问题解决方案"},{"content":"序 linux下的进程通信手段基本上是从Unix平台上的进程通信手段继承而来的。而对Unix发展做出重大贡献的两大主力 AT&T的贝尔实验室及BSD（加州大学伯克利分校的伯克利软件发布中心）在进程间通信方面的侧重点有所不同。前者对Unix早期的进程间通信手段进行了系统的改进和扩充，形成了“system V IPC”，通信进程局限在单个计算机内；后者则跳过了该限制，形成了基于套接口（socket）的进程间通信机制。Linux则把两者继承了下来，如图示： 其中，最初Unix IPC包括：管道、FIFO、信号；System V IPC包括：System V消息队列、System V信号灯、System V共享内存区；Posix IPC包括： Posix消息队列、Posix信号灯、Posix共享内存区。有两点需要简单说明一下：1）由于Unix版本的多样性，电子电气工程协会（IEEE）开发了一个独立的Unix标准，这个新的ANSI Unix标准被称为计算机环境的可移植性操作系统界面（PSOIX）。现有大部分Unix和流行版本都是遵循POSIX标准的，而Linux从一开始就遵循POSIX标准；2）BSD并不是没有涉足单机内的进程间通信（socket本身就可以用于单机内的进程间通信）。事实上，很多Unix版本的单机 IPC留有BSD的痕迹，如4.4BSD支持的匿名内存映射、4.3+BSD对可靠信号语义的实现等等。 图一给出了linux 所支持的各种IPC手段，在本文接下来的讨论中，为了避免概念上的混淆，在尽可能少提及Unix的各个版本的情况下，所有问题的讨论最终都会归结到 Linux环境下的进程间通信上来。并且，对于Linux所支持通信手段的不同实现版本（如对于共享内存来说，有Posix共享内存区以及System V共享内存区两个实现版本），将主要介绍Posix API。 linux下进程间通信的几种主要手段简介： 管道（Pipe）及有名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信； 信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）； 报文（Message）队列（消息队列）：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。 共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。 信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。 套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。 下面将对上述通信机制做具体阐述。 附1：参考文献[2]中对linux环境下的进程进行了概括说明： 一般来说，linux下的进程包含以下几个关键要素： 有一段可执行程序； 有专用的系统堆栈空间； 内核中有它的控制块（进程控制块），描述进程所占用的资源，这样，进程才能接受内核的调度； 具有独立的存储空间 进程和线程有时候并不完全区分，而往往根据上下文理解其含义。 参考资料 UNIX环境高级编程，作者：W.Richard Stevens，译者：尤晋元等，机械工业出版社。具有丰富的编程实例，以及关键函数伴随Unix的发展历程。 linux内核源代码情景分析（上、下），毛德操、胡希明著，浙江大学出版社，提供了对linux内核非常好的分析，同时，对一些关键概念的背景进行了详细的说明。 UNIX网络编程第二卷：进程间通信，作者：W.Richard Stevens，译者：杨继张，清华大学出版社。一本比较全面阐述Unix环境下进程间通信的书（没有信号和套接口，套接口在第一卷中）。","title":"深刻理解Linux进程间通信（IPC）"},{"content":"一、Android Bluetooth现状 （1）Android2.2版 支持的蓝牙核心版本是Bluetooth 2.0 + EDR。 （2）Android 的蓝牙 使用了BlueZ协议栈，但只实现了Handset/Handfree和A2DP/AVRCP等Profile。 （一些常用的Profile（如HID/DUN/SPP/OPP/FTP/PAN等）在现在的Android2.2版中并没有实现。需要自己在Android中实现Profile）。 （3）目前版本（Android2.2） 只支持 绑定设备（bonded devices）之间通信，而不支持ad-hoc网络通信。 （4）目前版本（Android2.2） emulator（仿真器、模拟器）不支持蓝牙的调试，只能通过LOG和BlueZ带的工具来调试。 （5）Android2.0 API level5 之后的版本才支持Bluetooth。 （6）Android 的Bluetooth通信API是BlueZ 的RFCOMM的封装。 RfcommSocket 在 API level7 之后的版本才提供Bluetooth 的通信 RfcommSocket 使用JAVA 的IputStream 和OutputStream对象 二、Android Bluetooth 架构 1、面向库的架构视图 2、面向进程的架构视图 LinuxKernel层： bluez协议栈、uart驱动, h4协议, hci,l2cap, sco, rfcomm Library层: libbluedroid.so 等 Framework层： 实现了Headset /Handsfree 和 A2DP/AVRCP profile，但其实现方式不同Handset/Handfree是直接 在bluez的RFCOMM Socket上开发的，没有利用bluez的audio plugin，而A2DP/AVRCP是在bluez的audio plugin基础上开发的，大大降低了实现的难度。   三、 BlueZ介绍 （详见http://www.bluez.org/）： BlueZ 是Linux OS开放的bluetooth 协议栈主要包括IBM公司的BlueDrekar, Nokia公司的Affix, Axis公司的OpenBT和官方的协议栈BlueZ. Bluetooth协议栈BlueZ分为两部分：内核代码和用户态程序及工具集。 内核代码：由BlueZ核心协议和驱动程序组 成；Bluetooth协议实现在内核源代码 /net/bluetooth中。包括hci,l2cap,hid，rfcomm,sco,SDP,BNEP等协议的实现。驱动程序放在 /driver/bluetooth中,包含Linux kernel对各种接口的Bluetooth device的驱动。例如：USB接口，串口等。 用户态程序及工具集：包括应用程序接口和BlueZ工具集。BlueZ提供函数库以及应用程序接口，便于程序员开发bluetooth应用程序。BlueZ utils是主要工具集，实现对bluetooth设备的初始化和控制。 四、几个术语： HFP(Hands-free Profile)耳机模式： 让蓝牙设备可以控制电话，如接听、挂断、拒接、语音拨号等，拒接、语音拨号要视蓝牙耳机及电话是否支持。 HSP（Handset Profile）耳机模式 用于支持蓝牙耳机与移动电话之间使用 HID() 人机接口设备配置文件 HID 配置文件定义了 Bluetooth HID（如键盘、指向设备、游戏设备及远程监视设备）使用的协议、程序及功能 拨号网络配置文件 (DUN) DUN 提供了通过 Bluetooth 无线技术接入 Internet 和其它拨号服务的标准。最常见的情况是在手机上拨号，从膝上型计算机以无线方式接入 Internet。 个人局域网配置文件 (PAN) PAN 描述了两个或更多个 Bluetooth 设备如何构成一个即时网络，以及如何使用同一机制通过网络接入点接入远程网络。配置文件角色包括网络接入点、组即时网络及个人局域网用户。 SDP（ Service Discovery Protocol ）服务发现协议 提供应用程序在蓝牙环境中发现哪个服务可用和决定那些可用服务的特征。 GAP(Generic Access Profile)通用访问应用 一般访问应用规范定义了蓝牙设备如何发现和建立与其他设备的安全（或不安全）连接。它处理一些一般模式的业务（如询问、命名和搜索）和一些安全性问题（如担保），同时还处理一些有关连接的业务（如链路建立、信道和连接建立）。GAP规定的是一些一般性的运行任务。因此，它具有强制性，并作为所有其它蓝牙应用规范的基础。 三、蓝牙协议栈 蓝牙技术规范的目的是使符合该规范的各种应用之间能够实现互操作。互操作的远端设备需要使用相同的协议栈，不同的应用需要不同的协议栈。但是，所有的应用都要使用蓝牙技术规范中的数据链路层和物理层。 完整的蓝牙协议栈如图1所示，不是任何应用都必须使用全部协议，而是可以只使用其中的一列或多列。图1显示了所有协议之间的相互关系，但这种关系在某些应用中是有变化的。 蓝牙协议体系中的协议 蓝牙协议体系中的协议按SIG的关注程度分为四层： 核心协议：BaseBand、LMP、L2CAP、SDP； 电缆替代协议：RFCOMM； 电话传送控制协议：TCS-Binary、AT命令集； 选用协议：PPP、UDP/TCP/IP、OBEX、WAP、vCard、vCal、IrMC、WAE。 除上述协议层外，规范还定义了主机控制器接口（HCI），它为基带控制器、连接管理器、硬件状态和控制寄存器提供命令接口。在图1中，HCI位于L2CAP的下层，但HCI也可位于L2CAP上层。 蓝牙核心协议由SIG制定的蓝牙专用协议组成。绝大部分蓝牙设备都需要核心协议（加上无线部分），而其他协议则根据应用的需要而定。总之，电缆替代协议、电话控制协议和被采用的协议在核心协议基础上构成了面向应用的协议。 1．蓝牙核心协议 基带协议 基带和链路控制层确保微微网内各蓝牙设备单元之间由射频构成的物理连接。蓝牙的射频系统是一个跳频系统，其任一分组在指定时隙、指定频率上发送。它使用查询和分页进程同步不同设备间的发送频率和时钟，为基带数据分组提供了两种物理连接方式，即面向连接（SCO）和无连接（ACL），而且，在同一射频上可实现多路数据传送。ACL适用于数据分组，SCO适用于话音以及话音与数据的组合，所有的话音和数据分组都附有不同级别的前向纠错（FEC）或循环冗余校验（CRC），而且可进行加密。此外，对于不同数据类型（包括连接管理信息和控制信息）都分配一个特殊通道。 可使用各种用户模式在蓝牙设备间传送话音，面向连接的话音分组只需经过基带传输，而不到达L2CAP。话音模式在蓝牙系统内相对简单，只需开通话音连接就可传送话音。 连接管理协议（LMP） 该协议负责各蓝牙设备间连接的建立。它通过连接的发起、交换、核实，进行身份认证和加密，通过协商确定基带数据分组大小。它还控制无线设备的电源模式和工作周期，以及微微网内设备单元的连接状态。 逻辑链路控制和适配协议（L2CAP） 该协议是基带的上层协议，可以认为它与LMP并行工作，它们的区别在于，当业务数据不经过LMP时，L2CAP为上层提供服务。L2CAP向上层提供面向连接的和无连接的数据服务，它采用了多路技术、分割和重组技术、群提取技术。L2CAP允许高层协议以64k字节长度收发数据分组。虽然基带协议提供了SCO和ACL两种连接类型，但L2CAP只支持ACL。     ·服务发现协议（SDP） 发现服务在蓝牙技术框架中起着至关紧要的作用，它是所有用户模式的基础。使用SDP可以查询到设备信息和服务类型，从而在蓝牙设备间建立相应的连接。 2．电缆替代协议(RFCOMM) RFCOMM是基于ETSI-07.10规范的串行线仿真协议。它在蓝牙基带协议上仿真RS-232控制和数据信号，为使用串行线传送机制的上层协议（如OBEX）提供服务。 3．电话控制协议 二元电话控制协议（TCS-Binary或TCSBIN） 该协议是面向比特的协议，它定义了蓝牙设备间建立语音和数据呼叫的控制信令，定义了处理蓝牙TCS设备群的移动管理进程。基于ITU TQ.931建议的TCSBinary被指定为蓝牙的二元电话控制协议规范。 AT命令集电话控制协议        SIG定义了控制多用户模式下移动电话和调制解调器的AT命令集，该AT命令集基于ITU TV.250建议和GSM07.07，它还可以用于传真业务。 4．选用协议 点对点协议（PPP） 在蓝牙技术中，PPP位于RFCOMM上层，完成点对点的连接。 TCP/UDP/IP 该协议是由互联网工程任务组制定，广泛应用于互联网通信的协议。在蓝牙设备中，使用这些协议是为了与互联网相连接的设备进行通信。 对象交换协议（OBEX）        IrOBEX(简写为OBEX)是由红外数据协会（IrDA）制定的会话层协议，它采用简单的和自发的方式交换目标。OBEX是一种类似于HTTP的协议，它假设传输层是可靠的，采用客户机/服务器模式，独立于传输机制和传输应用程序接口（API）。 电子名片交换格式（vCard）、电子日历及日程交换格式（vCal）都是开放性规范，它们都没有定义传输机制，而只是定义了数据传输格式。SIG采用vCard/vCal规范，是为了进一步促进个人信息交换。 无线应用协议（WAP） 该协议是由无线应用协议论坛制定的，它融合了各种广域无线网络技术，其目的是将互联网内容和电话传送的业务传送到数字蜂窝电话和其他无线终端上。 用户模式及协议栈        1．文件传输模式 文件传输模式提供两终端间的数据通信功能，可传输后缀为.xls、.ppt、.wav、.jpg和.doc的文件（但并不限于这几种），以及完整的文件夹、目录或多媒体数据流等，提供远端文件夹浏览功能。文件传输协议栈如图2所示。        2．因特网网桥模式 这种用户模式可通过手机或无线调制解调器向PC提供拨号入网和收发传真的功能，而不必与PC有物理上的连接。拨号上网需要两列协议栈（不包括SDP），如图3所示。AT命令集用来控制移动电话或调制解调器以及传送其他业务数据的协议栈。传真采用类似协议栈，但不使用PPP及基于PPP的其他网络协议，而由应用软件利用RFCOMM直接发送。        3．局域网访问模式 该用户模式下，多功能数据终端(DTs)经局域网访问点(LAP)无线接入局域网，然后，DTs的操作与通过拨号方式接入局域网的设备的操作一样，其协议栈如图4所示。        4．同步模式 同步用户模式提供设备到设备的个人资料管理(PIM)的同步更新功能，其典型应用如电话簿、日历、通知和记录等。它要求PC、蜂窝电话和个人数字助理(PDA)在传输和处理名片、日历及任务通知时，使用通用的协议和格式。其协议栈如图5所示，其中同步应用模块代表红外移动通信（IrMC）客户机或服务器。        5.一机三用电话模式 手持电话机有三种使用方法：第一，接入公用电话网，作为普通电话使用；第二，作为不计费的内部电话使用；第三，作为蜂窝移动电话使用。无线电话和内部电话使用相同的协议栈；语音数据流直接与基带协议接口，不经过L2CAP层，如图6所示。        6.头戴式设备模式 使用该模式，用户打电话时可自由移动。通过无线连接，头戴式设备通常作为蜂窝电话、无线电话或PC的音频输入输出设备。头戴式设备协议栈如图7所示，语音数据流不经过L2CAP层而直接接入基带协议层。头戴式设备必须能收发并处理AT命令。 完整的协议栈包括蓝牙专用协议（如连接管理协议LMP和逻辑链路控制应用协议L2CAP）以及非专用协议（如对象交换协议OBEX和用户数据报协议UDP）。设计协议和协议栈的主要原则是尽可能利用现有的各种高层协议，保证现有协议与蓝牙技术的融合以及各种应用之间的互操作，充分利用兼容蓝牙技术规范的软硬件系统。蓝牙技术规范的开放性保证了设备制造商可以自由地选用其专用协议或习惯使用的公共协议，在蓝牙技术规范基础上开发新的应用。 Android蓝牙系统分为四个层次，内核层、BlueZ库、BlueTooth的适配库、BlueTooth的JNI部分、Java框架层、应用层。下面先来分析Android的蓝牙协议栈。 Android的蓝牙协议栈采用BlueZ来实现，BlueZ分为两部分：内核代码和用户态程序及工具集。 内核代码主要由BlueZ核心协议和驱动程序组成；蓝牙协议实现在内核源代码net/bluetooth中，驱动程序位于内核源代码目录 driver/bluetooth中。用户态程序及工具集主要包括应用程序接口和BlueZ工具集，位于Android源代码目录externel /bluetooth(注：Android版本不一样，有的在externel/bluez目录下)中。 1、蓝牙协议栈 蓝牙协议栈的体系结构由底层硬件模块、中间协议层和高端应用层三部分组成。 一、底层硬件模块 组成： 链路管理协议(Link ManagerProtocol，LMP)； 基带(Base Band，BB)； 射频(Radio Frequency，RF)。 功能： 射频(RF)通过2.4GHz的ISM频段实现数据流的过滤和传输。 基带(BB)提供两种不同的物理链路，即同步面向连接链路(Synchronous Connection Oriented，SCO)和异步无连接链路(AsynchronousConnection Less，ACL)，负责跳频和蓝牙数据，及信息帧的传输，且对所有类型的数据包提供不同层次的前向纠错码(Frequency Error Correction，FEC)或循环冗余度差错校验(CyclicRedundancy Check，CRC)。 链路管理协议(LMP)负责两个或多个设备链路的建立和拆除，及链路的安全和控制，如鉴权和加密、控制和协商基带包的大小等，它为上层软件模块提供了不同的访问入口。 主机控制器接口(HostController Interface，HCI)是蓝牙协议中软硬件之间的接口，提供了一个调用下层BB、LMP、状态和控制寄存器等硬件的统一命令，上下两个模块接口之间的消息和数据的传递必须通过HCI的解释才能进行。 二、中间协议层 组成： 逻辑链路控制和适配协议(LogicalLink Control and Adaptation Protocol，L2CAP)； 服务发现协议(ServiceDiscovery Protocol，SDP)； 串口仿真协议(或称线缆替换协议RFCOMM)； 二进制电话控制协议(TelephonyControlprotocol Spectocol，TCS)。 功能： L2CAP位于基带(BB)之上，向上层提供面向连接的和无连接的数据服务，它主要完成数据的拆装、服务质量控制、协议的复用、分组的分割和重组，及组提取等功能。 SDP是一个基于客户/服务器结构的协议，它工作在L2CAP层之上，为上层应用程序提供一种机制来发现可用的服务及其属性，服务的属性包括服务的类型及该服务所需的机制或协议信息。 RFCOMM是一个仿真有线链路的无线数据仿真协议，符合ETSI标准的TS07.10串口仿真协议，它在蓝牙基带上仿真RS-232的控制和数据信号，为原先使用串行连接的上层业务提供传送能力。 TCS定义了用于蓝牙设备之间建立语音和数据呼叫的控制信令(Call Control Signalling)，并负责处理蓝牙设备组的移动管理过程。 三、高端应用层 组成： 点对点协议(Point-to-PointProtocol，PPP); 传输控制协议/网络层协议(TCP/IP); 用户数据包协议(UserDatagram Protocol，UDP)； 对象交换协议(ObjectExchang Protocol，OBEX)； 无线应用协议(WirelessApplication Protocol，WAP); 无线应用环境(WirelessApplication Environment，WAE)； 功能： PPP定义了串行点对点链路应当如何传输因特网协议数据，主要用于LAN接入、拨号网络及传真等应用规范。 TCP/IP、UDP定义了因特网与网络相关的通信及其他类型计算机设备和外围设备之间的通信。 OBEX支持设备间的数据交换，采用客户/服务器模式提供与HTTP(超文本传输协议)相同的基本功能。可用于交换的电子商务卡、个人日程表、消息和便条等格式。 WAP用于在数字蜂窝电话和其他小型无线设备上实现因特网业务，支持移动电话浏览网页、收取电子邮件和其他基于因特网的协议。 WAE提供用于WAP电话和个人数字助理(PersonalDigital Assistant，PDA)所需的各种应用软件。 2、android与蓝牙协议栈的关系 蓝牙系统的核心是BlueZ，因此JNI和上层都围绕跟BlueZ的沟通进行。JNI和android应用层，跟BlueZ沟通的主要手段是D- BUS，这是一套被广泛采用的IPC通信机制，跟Android框架使用的Binder类似。BlueZ以D-BUS为基础，给其他部分提供主要接口。 四、蓝牙各种版本区别  蓝牙目前暂时共有四个版本 V1.1/1.2/2.0/2.1。以通讯距离来在不同版本可再分为 Class A(1)/Class B(2)。      1）蓝牙目前暂时共有四个版本 V1.1/1.2/2.0/2.1。   　　2）以通讯距离来在不同版本可再分为 Class A(1)/Class B(2)。   　　3）版本的区别          1.1为最早期版本，传输率约在748~810kpbs8，因是早期设计，容易受到同频率之产品所干扰下影响通讯质量。   　　1.2 同样是只有 748~810kpbs 的传输率，但在加上了(改善 Software)抗干扰跳频功能。(太深入之技术理论不再详述!)。     　  4）通讯距离版本   　　a)Class A 是用在大功率/远距离的蓝芽产品上，但因成本高和耗电量大，不适合作个人通讯产品之用(手机/蓝牙耳机/蓝牙 Dongle 等等)，故多用在部份商业特殊用途上，通讯距离大约在 80~100M 距离之间。   　　b)Class B 是目前最流行的制式，通讯距离大约在 8~30M 之间，视乎产品的设计而定，多用于手机内/蓝牙耳机/蓝牙 Dongle 的个人通讯产品上，耗电量和体积较细，方便携带。   　　5）无论 1.1/1.2 版本的蓝牙产品，本身基本是可以支持 Stereo 音效的传输要求，但只能够作（单工）方式工作，加上音带频率响应不太足够，并未算是最好之 Stereo 传输工具。   　　6）版本 2.0 是 1.2 的改良提升版，传输率约在 1.8Mpbs~2.1Mpbs，可以有（双工）的工作方式。即一面作语音通讯，同时亦可以传输档案/高质素图片，台湾有部份蓝牙 Dongle 已经有在市面发售，但在手机内有支持蓝牙 2.0 版本则是很少。蓝牙耳机能够真正使用的亦不多，部份蓝牙产品自称是 2.0 版本，但仍然要利用外加配件才能达到。 2.0 版本当然也支持 Stereo 运作。   　　7）稍后蓝牙 2.0 版本的芯片，是有机会加入了 Stereo 译码芯片，则连 A2DP（Advanced Audio Distribution Profile）也可以不需要了。   蓝牙，是一种支持设备短距离通信（一般10m内）的无线电技术。能在包括移动电话、PDA、无线耳机、笔记本电脑、相关外设等众多设备之间进行无线信息交换。利用“蓝牙”技术，能够有效地简化移动通信终端设备之间的通信，也能够成功地简化设备与因特网Internet之间的通信，从而数据传输变得更加迅速高效，为无线通信拓宽道路。蓝牙采用分散式网络结构以及快跳频和短包技术，支持点对点及点对多点通信，工作在全球通用的2.4GHz ISM（即工业、科学、医学）频段。其数据速率为1Mbps。采用时分双工传输方案实现全双工传输。 低耗电蓝牙相关规范 　　 技术规范 典型的蓝牙 低耗电的蓝牙 无线电频率 2.4 GHz 2.4 GHz 距离 10米 10米 空中数据速率 1-3 Mb/s 1 Mb/s 应用吞吐量 0.7-2.1 Mb/s 0.2 Mb/s Nodes/Active slaves 7-16,777,184 无限 安全 64/128-bit及用户自定义的应用层 128-bitAES及用户自定义的应用层 鲁棒性 自动适应快速跳频，FEC,快速 ACK 自动适应快速跳频 延迟（非连接状态） 发送数据的总时间 100 m/s <6 m/s 政府监管 全球 全球 认证机构 蓝牙技术联盟(Bluetooth SIG) 蓝牙技术联盟(Bluetooth SIG) 语音能力 有 没有 网络拓扑 分散网 Star-bus 耗电量 1（作为参考） 0.01至0.5（视符使用情况） Peak current consumption <30 mA <15 mA (最高运行时为15 mA) Service discovery 有 有 简介概念 有 有 主要用途 手机，游戏机，耳机，stereo audio streaming,  汽车和PC等 手机，游戏机，PC,表，体育和健身，医疗保健，  汽车，家用电子，自动化和工业等 虽然制造商对各种设备实施的特定用户接口因设备而异，但首次连接两个设备的一些基本步骤是相同的。用户应保持在安全环境下进行配对。 　　设备充电 　　如果设备是新的 Bluetooth 设备，确保在进行连接或打开前已充电。尤其是 Bluetooth 耳机，使用前必须充电。 　　设备开机 　　打开需要配对设备的电源。对于某些设备，如 Bluetooth 无线耳机，设备开机的同时即启动配对过程。 　　开启 Bluetooth 功能 　　在您收到设备时，该设备的 Bluetooth 功能可能已经开启，也可能尚未开启。对于多数计算机，用户需要从控制面板或系统首选项中开启 Bluetooth 射频功能。 　　将设备设置为可见 　　作为安全措施，某些设备可将 Bluetooth 功能设置为关闭、隐藏或可见。尝试连接设备时，用户应将设备设置为可见，这样才能为彼此所发现。完成设备配对后，如果用户担心设备会被其它设备发现，可以将设备设置为隐藏。 　　将两个设备设为连接模式 　　两个设备都充好电后，打开设备电源并开启 Bluetooth 功能，每个设备都需要初始化通信会话。通常，在两个设备之间连接时，一个设备会作为“主机”，而另一个设备则作为“访客”。主机设备是具有用户界面的设备，多数连接设置都将从此进行。一个设备可以是另一个设备的主机，也可以作为其它设备的访客。例如，手机与无线耳机配对时，该手机就是主机。但是，手机与膝上型计算机配对时，膝上型计算机就是主机。 　　输入密码 　　设备彼此发现对方后，用户将被要求在一个或两个设备中输入密码。某些情况下，如连接无线耳机时，密码是由制造商为耳机指定的固定密码。此时，用户需要在主机设备中输入此指定的密码。用户可在用户手册中找到此密码。在其它情况下，用户可输入他/她自己的密码。在这些情况下，用户将在两个设备中输入密码各一次。强烈建议用户为一次配对过程设定 8 位字母数字字符密码。输入密码后，设备将彼此验证并完成建立信任连接。 　　删除或断开与信任设备的连接 　　用户应何时删除或断开与信任设备的连接？如果您的其中一个 Bluetooth 设备丢失或被偷，您应取消以前与该设备配对的所有设备的配对设置。 　　如何取消配对或删除信任设备？对于手机或计算机之类设备，用户应进入设备的连接设置，然后查找信任设备列表。用户随后便能选择添加新设备或删除信任设备。突出显示需要删除的设备，然后按删除按钮。键盘或鼠标之类设备只有一个按钮或开关作为用户接口，因此每次只能连接到一个设备。要删除其原来的信任设备，只需将鼠标或键盘连接到新设备。","title":"Android Bluetooth蓝牙开发\\蓝牙协议\\蓝牙通信例子"},{"content":"一、    支持NAND FLASH启动 新版u-boot在链接时加了“-pie”选项 -pie            Produce a position independentexecutable on targets which support it. For predictable results, you must also specify the same set of optionsthat were used to generate code (-fpie, -fPIE, or model suboptions) when youspecify this option. 产生的代码中，没有绝对地址，全部使用相对地址，故而代码可以被加载器加载到内存的任意 位置，都可以正确的执行。 最终u-boot.bin中多了这些段 .rel.dyn : {          __rel_dyn_start = .;          *(.rel*)          __rel_dyn_end = .;   }     .dynsym : {          __dynsym_start = .;          *(.dynsym)   } 从NOR FLASH把代码复制到SDRAM，程序的链接地址是0，访问全局变量、静态变量、调用函数时是使用基于0地址编译得到的地址，现在把程序复制到了SDRAM(0x3000000),需要修改代码，把原来的地址改为新地址。这样太复杂了，我还是使用老版本的方法。 去掉“-pie”选项，在u-boot源码搜索“-pie” root@zjh:/home/work/u-boot-2012.04.01#grep \"\\-pie\" . -nR ./doc/README.arm-relocation:3:Atarch level: add linker flag -pie ./arch/x86/config.mk:43:LDFLAGS_FINAL+= --gc-sections -pie ./arch/arm/config.mk:75:LDFLAGS_u-boot+= -pie 去除arch/arm/config.mk:75:LDFLAGS_u-boot += -pie中的“-pie” # needed for relocation ifndef CONFIG_NAND_SPL #LDFLAGS_u-boot +=-pie endif 修改配置文件include\\configs\\tq2440.h，给u-boot分配512KB #define CONFIG_SYS_TEXT_BASE 0x33f80000 增加文件board\\tq2440\\nand_read_ll.c并修改相应的Makefile COBJS   := tq2440.onand_read_ll.o Nand_read_ll.c文件内容如下： /* NAND FLASH控制器 */ #define NFCONF(*((volatile unsigned long *)0x4E000000)) #define NFCONT(*((volatile unsigned long *)0x4E000004)) #define NFCMMD(*((volatile unsigned char *)0x4E000008)) #define NFADDR(*((volatile unsigned char *)0x4E00000C)) #define NFDATA(*((volatile unsigned char *)0x4E000010)) #define NFSTAT(*((volatile unsigned char *)0x4E000020))   static intisBootFromNorFlash(void) {   volatile int *p = (volatile int *)0;   int val;     val = *p;   *p = 0x12345678;   if (*p == 0x12345678) {          /* 写成功,是nand启动 */          *p = val;          return 0;   } else {          /* NOR不能像内存一样写 */          return 1;   } }   voidclear_bss(void) {   extern int __bss_start, __bss_end__;   int *p = &__bss_start;     for (; p < &__bss_end__; p++)          *p = 0; }   void nand_init_ll(void) { #define TACLS   0 #defineTWRPH0  1 #defineTWRPH1  0   /* 设置时序 */   NFCONF =(TACLS<<12)|(TWRPH0<<8)|(TWRPH1<<4);   /* 使能NAND Flash控制器,初始化ECC, 禁止片选 */   NFCONT =(1<<4)|(1<<1)|(1<<0);     }   static voidnand_select(void) {   NFCONT &= ~(1<<1); }   static voidnand_deselect(void) {   NFCONT |= (1<<1);     }   static voidnand_cmd(unsigned char cmd) {   volatile int i;   NFCMMD = cmd;   for (i = 0; i < 10; i++); }   static voidnand_addr(unsigned int addr) {   unsigned int col  = addr % 2048;   unsigned int page = addr / 2048;   volatile int i;     NFADDR = col & 0xff;   for (i = 0; i < 10; i++);   NFADDR = (col >> 8) & 0xff;   for (i = 0; i < 10; i++);     NFADDR = page & 0xff;   for (i = 0; i < 10; i++);   NFADDR = (page >> 8) & 0xff;   for (i = 0; i < 10; i++);   NFADDR = (page >> 16) & 0xff;   for (i = 0; i < 10; i++);  }   static voidnand_wait_ready(void) {   while (!(NFSTAT & 1)); }   static unsignedchar nand_data(void) {   return NFDATA; }   voidnand_read_ll(unsigned int addr, unsigned char *buf, unsigned int len) {   int col = addr % 2048;   int i = 0;            /* 1. 选中 */   nand_select();     while (i < len) {          /* 2. 发出读命令00h */          nand_cmd(0x00);            /* 3. 发出地址(分5步发出) */          nand_addr(addr);            /* 4. 发出读命令30h */          nand_cmd(0x30);            /* 5. 判断状态 */          nand_wait_ready();            /* 6. 读数据 */          for (; (col < 2048) && (i< len); col++) {                 buf[i] = nand_data();                 i++;                 addr++;          }                   col = 0;   }     /* 7. 取消选中 */              nand_deselect(); }   voidcopy_code_to_sdram(unsigned char *src, unsigned char *dest, unsigned int len) {   int i = 0;     /* 如果是NOR启动 */   if (isBootFromNorFlash()) {          while (i < len) {                 dest[i] = src[i];                 i++;          }   } else {          nand_init_ll();          nand_read_ll((unsigned int)src, dest,len);   } } 修改arch\\arm\\cpu\\arm920t\\start.S call_board_init_f:     ldr sp, =(CONFIG_SYS_INIT_SP_ADDR)     bic sp, sp, #7 /* 8-byte alignment for ABIcompliance */     ldr r0,=0x00000000     ldr r1, _TEXT_BASE     ldr r2, _bss_start_ofs     bl copy_code_to_sdram     bl clear_bss     ldr pc, = board_init_f  /* 跳转到SDRAM */ .globl second second: /* 调用第2阶段的代码 */        bl board_init_r 注释掉以下代码 #if 0        .globl    relocate_code relocate_code:        mov      r4, r0   /* save addr_sp */        mov      r5, r1   /* save addr of gd */        mov      r6, r2   /* save addr of destination */          /* Set up the stack                                              */ stack_setup:        mov      sp, r4          adr r0, _start        cmp      r0, r6        beq       clear_bss          /* skip relocation */        mov      r1, r6                 /* r1 <- scratch forcopy_loop */        ldr  r3, _bss_start_ofs        add       r2, r0, r3           /* r2 <- source end address        */   copy_loop:        ldmia    r0!, {r9-r10}            /* copy from source address[r0]    */        stmia    r1!, {r9-r10}            /* copy to   target address [r1]    */        cmp      r0, r2                 /* until source end address[r2]    */        blo copy_loop   #ifndef CONFIG_SPL_BUILD        /*         * fix .rel.dynrelocations         */        ldr  r0, _TEXT_BASE            /* r0 <- Text base */        sub       r9, r6, r0           /* r9 <- relocation offset */        ldr  r10,_dynsym_start_ofs   /* r10 <- sym tableofs */        add       r10, r10, r0             /* r10 <- sym table in FLASH */        ldr  r2,_rel_dyn_start_ofs      /* r2 <- reldyn start ofs */        add       r2, r2, r0           /* r2 <- rel dyn start in FLASH */        ldr  r3, _rel_dyn_end_ofs       /* r3 <- rel dyn end ofs */        add       r3, r3, r0           /* r3 <- rel dyn end in FLASH */ fixloop:        ldr  r0, [r2]              /* r0 <- location to fix up, INFLASH! */        add       r0, r0, r9           /* r0 <- location to fix up in RAM*/        ldr  r1, [r2, #4]        and       r7, r1, #0xff        cmp      r7, #23                     /* relative fixup? */        beq       fixrel        cmp      r7, #2                 /* absolute fixup? */        beq       fixabs        /* ignore unknown type of fixup */        b     fixnext fixabs:        /* absolute fix: set location to (offset) symbol value */        mov      r1, r1, LSR #4         /* r1 <- symbol index in .dynsym */        add       r1, r10, r1        /* r1 <- address of symbol in table*/        ldr  r1, [r1, #4]              /* r1 <- symbol value */        add       r1, r1, r9           /* r1 <- relocated sym addr */        b     fixnext fixrel:        /* relative fix: increase location by offset */        ldr  r1, [r0]        add       r1, r1, r9 fixnext:        str  r1, [r0]        add       r2, r2, #8          /* each rel.dyn entry is 8 bytes */        cmp      r2, r3        blo fixloop #endif   clear_bss: #ifndef CONFIG_SPL_BUILD        ldr  r0, _bss_start_ofs        ldr  r1, _bss_end_ofs        mov      r4, r6                 /* reloc addr */        add       r0, r0, r4        add       r1, r1, r4        mov      r2, #0x00000000         /* clear                         */   clbss_l:str  r2, [r0]              /*clear loop...                  */        add       r0, r0, #4        cmp      r0, r1        bne       clbss_l          bl coloured_LED_init        bl red_led_on #endif #endif 修改arch\\arm\\lib\\board.c中的函数board_init_f //addr -=gd->mon_len; //addr &=~(4096 - 1); addr =CONFIG_SYS_TEXT_BASE; 注视最后的重定位，并跳转到刚才定义的second //relocate_code(addr_sp,id, addr); second(id, addr); 修改链接脚本arch\\arm\\cpu\\u-boot.lds把start.o、nand_read_ll.o、lowlevel_init.o编译到前面4k CPUDIR/start.o (.text) board/tq2440/libtq2440.o(.text) 重新编译，烧到NAND FLASH TQ2440 # nand erase 040000;tftp 32000000 u-boot.bin;nand write 32000000 0 40000   NAND erase: device 0 offset0x0, size 0x40000 Erasing at 0x20000 -- 100%complete. OK dm9000 i/o: 0x20000000, id:0x90000a46 DM9000: running in 16 bitmode MAC: 00:0c:29:4d:e4:f4 Using dm9000 device TFTP from server172.28.12.60; our IP address is 172.28.12.10 Filename 'u-boot.bin'. Load address: 0x32000000 Loading: T ############### done Bytes transferred = 208508(32e7c hex)   NAND write: device 0 offset0x0, size 0x40000  262144 bytes written: OK TQ2440 # 从NAND FLASH启动 U-Boot 2012.04.01 (Dec 312012 - 11:57:16)   CPUID: 32440001 FCLK:      400 MHz HCLK:      100 MHz PCLK:       50 MHz DRAM:  64 MiB WARNING: Caches not enabled Flash: *** failed *** ### ERROR ### Please RESETthe board ### 由于从NAND启动，CPU检测不到NOR FLASH，具体代码如下arch\\arm\\lib\\board.c #if!defined(CONFIG_SYS_NO_FLASH)   puts(\"Flash: \");     flash_size = flash_init();   if (flash_size > 0) { # ifdefCONFIG_SYS_FLASH_CHECKSUM          char *s = getenv(\"flashchecksum\");            print_size(flash_size, \"\");          /*           * Compute and printflash CRC if flashchecksum is set to 'y'           *           * NOTE: Maybe weshould add some WATCHDOG_RESET()? XXX           */          if (s && (*s == 'y')) {                 printf(\" CRC: %08X\", crc32(0,                        (const unsigned char *) CONFIG_SYS_FLASH_BASE,                        flash_size));          }          putc('\\n'); # else     /* !CONFIG_SYS_FLASH_CHECKSUM */          print_size(flash_size, \"\\n\"); # endif /*CONFIG_SYS_FLASH_CHECKSUM */   } else {          puts(failed);          hang();   } #endif void hang(void) {   puts(\"### ERROR ### Please RESET the board ###\\n\");   for (;;); } 我们直接注释掉上面的hang(); # endif /*CONFIG_SYS_FLASH_CHECKSUM */   } else {          puts(failed);          //hang();   } #endif 重新编译，烧到NAND FLASH，从NAND启动 U-Boot 2012.04.01 (Dec 31 2012- 12:27:20)   CPUID: 32440001 FCLK:      400 MHz HCLK:      100 MHz PCLK:       50 MHz DRAM:  64 MiB WARNING: Caches not enabled Flash: *** failed *** NAND:  256 MiB 卡在这里，检查后发现修改start.S的时候调用第二阶段代码没有重新设置栈指针，做如下修改 board.c中的board_init_f函数 //relocate_code(addr_sp, id,addr);   second(id, addr, addr_sp); start.S second:   mov sp, r2 /*重新设置栈指针 */ /* 调用第2阶段的代码 */   bl board_init_r 重新编译，烧到NAND，从NAND启动 U-Boot 2012.04.01 (Dec 312012 - 12:31:58)   CPUID: 32440001 FCLK:      400 MHz HCLK:      100 MHz PCLK:       50 MHz DRAM:  64 MiB WARNING: Caches not enabled Flash: *** failed *** NAND:  256 MiB In:    serial Out:   serial Err:   serial Net:   dm9000 TQ2440 #","title":"u-boot-2012.04.01移植到TQ2440(六)：支持NAND FLASH启动"},{"content":"置顶：          手机端：教学遥控器.apk             微盘下载    快盘下载          电脑端：教学遥控器.rar              微盘下载    快盘下载 -------------------------------------------------------------华丽的分割线------------------------------------------------------------- 题记：          终于有时间升级下我的遥控器了，同时想感受下安卓广告平台的收益，现推出全新版本。          加入少许广告，希望大家谅解，感谢点击广告支持本软件的发展~          鉴于上个版本进行了大量改进，傻瓜式搭建（ 启动服务 -> 连接Wifi -> 连接使用）。 使用人群：潮流讲师以及屌丝必备神器！ 使用条件：Android 2.1 以上 使用模式：电脑服务端 + 安卓客户端 开发平台：MyEclipse 8.6 + Java JDK 1.6 、 Eclipse 3.7.2 + Android SDK 调试环境：HTC Incredible S G11 + Android 4.0.4 提供建议：若您有好的建议或点子 欢迎来信To: wjz32768@163.com 项目展示 - 客户端： 一、启动界面 二、连接界面：自动搜索服务端IP   三、主界面   四、屏幕绘图：电脑屏幕实时动态显示、可在任何情况下绘制 (PPT、Word、桌面、电影..)   五、PPT控制：带有PPT缩略图的上下翻页、放映及退出   六、鼠标操作：八方向控制鼠标移动、点击、包含常用物理按键   七、系统管理：一键远程关闭、重启、注销、锁定计算机   八、版权信息   项目展示 - 服务端： 一、服务管理   二、日志记录   发布汇总：          持续添加中...          也可直接搜索 教学遥控器 下载，请认准 伍家灶 出品.. 项目总结：          ˇ獨萊獨徍ゞ -- 荣誉出品..                                                                                                                        By 伍家灶                                                                                                                       2012-12-31","title":"教学遥控器 全新发布"},{"content":"如今的应用大部分基予网络，在开源中国iOS客户端源码中关于网络通信方面用了三个类库，ASI和AFNetworking，还有一个苹果官方给出的Reachability用于检测当前网络状况，本文介绍当前用的比较多的ASI类库； ASIHTTPRequest简称ASI,它是对CFNetwork API进行封装，使在与web服务器通信时的繁琐步骤变得容易一些。它是使用Objective-C 编写，能够很好的用在Mac OS X和iPhone应用程序中；它适用于执行基本的HTTP请求和交互基于 REST的服务(GET / POST / PUT /DELETE)互交。 ASIHTTPRequest下载 https://github.com/pokeb/asi-http-request/tree 关于ASI类库介绍在  http://allseeing-i.com/ASIHTTPRequest/ 添加ASI到你工程中步骤 http://allseeing-i.com/ASIHTTPRequest/Setup-instructions ASI特点 l通过简单的接口，即可完成向服务端提交数据和从服务端获取数据的工作  l下载的数据，可存储到内存中或直接存储到磁盘中  l能上传本地文件到服务端  l可以方便的访问和操作请求和返回的Http头信息  l可以获取到上传或下载的进度信息，为应用程序提供更好的体验  l支持上传或下载队列，并且可获取队列的进度信息  l支持基本、摘要和NTLM身份认证，在同一会话中授权凭证会自动维持，并且可以存储在Keychain（Mac和iOS操作    系统的密码管理系统）中  l 支持Cookie  l当应用（iOS4+）在后台运行时，请求可以继续运行  l 支持GZIP压缩数据  l内置的ASIDownloadCache类，可以缓存请求返回的数据，这样即使没有网络也可以返回已经缓存的数据结果  l ASIWebPageRequest –可以下载完整的网页，包括包含的网页、样式表、脚本等资源文件，并显示在UIWebView  /WebView中。任意大小的页面都可以无限期缓存，这样即使没有网络也可以离线浏览  l支持客户端证书  l支持通过代理发起Http请求  l支持带宽限制。在iOS平台，可以根据当前网络情况来自动决定是否限制带宽，例如当使  用WWAN(GPRS/Edge/3G)网络时限制，而当使用WIFI时不做任何限制  l支持断点续传  l支持同步和异步请 ASI类库里包括22个文件，4个主要的类ASIHTTPRequest 、ASIFormDataRequest、ASINetworkQueue、ASIDownloadCache，5个支持的类ASIInputStream、ASIDataDecompressor、ASIDataCompressor、ASIAuthenticationDialog、Reachability，4个协议配置文件ASIHTTPRequestDelegate、ASIProgressDelegate、ASICacheDelegate、ASIHTTPRequestConfig.h，这些文件作用在开发文档中都有详细介绍. 在http://allseeing-i.com/ASIHTTPRequest/How-to-use有关于初次接触ASI的简单使用，很有必要看一看， 了解简单的同步请求、异步请求，block块请求，队列请求等其他用法。 用ASI写的一个简单请求数据的Demo: 测试使用的URL是国家气象局API，返回一个json数据 #define URL @\"http://www.weather.com.cn/data/sk/101010100.html\"      请求得到数据: //同步请求- (IBAction)synchronization_bt:(id)sender {        NSURL *url = [NSURL URLWithString:URL];    ASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:url];//    启动同步方式访问    [request startSynchronous];        NSError *error = [request error];//    请求成功    if (!error) {        NSString *response = [request responseString];        NSLog(@\"请求数据:%@\",response);     }    }    } //异步请求- (IBAction)asynchronous_bt:(id)sender {    NSURL *url = [NSURL URLWithString:URL];    ASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:url];    [request setDelegate:self];//    启动异步方式访问    [request startAsynchronous];}//异步请求Delegate Methods-(void)requestFinished:(ASIHTTPRequest *)request{    NSString *responseString = [request responseString];    NSLog(@\"请求的String数据:%@\",responseString);//   以 二进制文件形式存储    NSData *responseData = [request responseData];    NSLog(@\"请求的Data数据:%@\",responseData);    }-(void)requestFailed:(ASIHTTPRequest *)request{    NSError *error = [request error];    NSLog(@\"Error:%@\",error.userInfo);} //block块请求- (IBAction)blocks_tn:(id)sender {    NSURL *url = [NSURL URLWithString:URL];    __block ASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:url];    [request setCompletionBlock:^{        NSString *responseString = [request responseString];        NSLog(@\"请求的String数据:%@\",responseString);            }];    [request setFailedBlock:^{        NSError *error = [request error];         NSLog(@\"Error:%@\",error.userInfo);    }];    [request startAsynchronous];} //队列请求- (IBAction)queue_bt:(id)sender {        if (![self queue]) {        [self setQueue:[[[NSOperationQueue alloc]init]autorelease]];    }    NSURL *url = [NSURL URLWithString:URL];    ASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:url];    [request setDelegate:self];    [request setDidFinishSelector:@selector(requestDone:)];    [request setDidFailSelector:@selector(requestWentWrong:)];    [[self queue] addOperation:request];}-(void)requestDone:(ASIHTTPRequest *)request{    NSString *response = [request responseString];    NSLog(@\"请求的数据:%@\",response);}-(void)requestWentWrong:(ASIHTTPRequest *)request{    NSError *error = [request error];    NSLog(@\"Error:%@\",error.userInfo);} 将类库加入到工程中不要忘了添加支持的framework框架和库： SystemConfiguration.framework, MobileCoreServices.framework, CoreGraphics.framework 和 libz.dylib. 源代码:http://download.csdn.net/detail/duxinfeng2010/4947729 正在学习过程中，错误之处请指正，欢迎交流，共同学习； 欢迎转载分享，请注明出处http://blog.csdn.net/duxinfeng2010","title":"[置顶] 开源中国iOS客户端学习——(五)网络通信ASI类库(1)"},{"content":"IOS塔防游戏《坦克对大炮》的开发设计记录 引子     游戏已经在App Store上线几个月了，一直很想写点什么记录一下。真要写的时候，却又发现无从下笔没啥好写的。在2012年进入IOS，对于独立游戏开发来说，已经很晚了。前两三年抓住机会的独立开发者多少已经掘到了第一桶金。12年的时候IOS移动游戏已经炙手可热， 大量的公司和小团队涌入。App Store刷榜横行，榜单早就是公司刷榜的自留地，当然这时候，有一些独立开发者还在做着App Store是最后一片后花园的梦。 操蛋的苹果     其实2011年以前，我基本没接触过苹果的设备，也不知道App Store是个什么东西，没见过iphone，更分不清ipad和ipod的区别。用过的最潮的手机就是Nokia街机E72。如果非要说用过苹果，那就是很多年前抽奖中过一个nano，不过当时对它毫无兴趣。         苹果其实是个很操蛋很霸道的玩意儿，对于开发者也一样。要参与苹果的游戏，就得买苹果的设备，这就是游戏规则。很多想尝试开发苹果游戏的人，都被这招霸王条款吓跑了。这一年不少哥们同事都曾经打电话问我，说他们也想试着弄弄苹果游戏App开发玩玩，是不是一定要买个苹果电脑啊。我一般都说是。然后他们就挂机退却了。我想这其中一定吓跑了不少惊才绝艳的人。 　　对于中国的收入水平来说，个人开发者要弄齐一套开发苹果的开发环境，还是要一些投入的。咬咬牙很臭屁的从香港买了当时最高配的MacBook Pro, 又带了一个黑色的ipad2。在东单买了IPhone 4S。突然家里就多了一堆圆角的白色充电器，有时候看着很有喜感。说实话，买这些东西之前，苹果的电脑和手机本身对我没啥诱惑，我只不过需要开发和测试工具。所谓的欣喜，只是凑齐了开发工具之后的成就感，还有淡淡的虽千万人吾往矣的肉疼，一下子捣腾出去几万块。     当然，痛并快乐着的历程才刚刚开始。MBP拿回家之后，我突然发现自己没有VISA信用卡，连apple ID都注册不了。于是跑去银行搞定信用卡先，半个月后卡终于到手了，发现银行给我办了一张国内的信用卡不带VISA的。我了个去，吐血三升，又花了半个月再去办理。     注册苹果开发者也算是一场磨难，99$的注册费还算小事，搞明白和填写苹果开发者长篇累牍的英文条款就花了好几天的时间。上赶着给人送钱都这么难，个中滋味，一言难尽。（后来中国苹果ID终于可以用储蓄卡注册了，苹果在改变世界，中国也在改变苹果。这是后话了）     苹果的开发语言Object C也是个操蛋的玩意儿。以为凭着自己的C/C++功底，搞定Obj C还不是分分钟的问题。但是实际上苹果的开发语言和环境都是自成一体的，用惯了PC和微软那一套东西的开发者，刚上来必然会水土不服。Obj C的语法在前几个月让我别扭不已，Mac的操作系统、XCode的开发环境，也一直搞得我火冒三丈手忙脚乱。Obj C的语言关还没过，游戏开发的引擎关又来叫板。虽然只是一个2D引擎，Cocos2d依然来者不善。我很苦逼的抱着引擎啃了很久，感觉以前十多年的3D游戏引擎开发经验，突然就变轻了，像烧火棍一样不值钱了。     后来一直到用Obj C和cocos2d把游戏写了得差不多了，有人才告诉我有cocos2d-x这么个东西，用C++就可以了，根本不用跟Obj C丫的死磕。于是又吐血三升。等我开始打量cocos2d-x的时候，有人游戏上了App Store榜首，告诉我用过Unity 3D之后才知道啥叫糙快猛。     所以说，徒有悍将之勇只知道闭门造车埋头苦干也是不行的，在游戏行业这一亩三分地儿，也得有与时俱进的精神。更何况是苹果IOS移动平台这茬儿新地界。 为什么是塔防          游戏题材一开始就选定了塔防，这没啥好说的。IOS触屏手机本身能适应的游戏类型就不多，目前受众良好的就那么几种。塔防算是一个很重要的分支。塔防的操作模式和节奏都比较适合触屏的操作，以前在浩方平台上玩过一些War3 TD Mod，也还觉得蛮有意思。IOS平台上也找了几个塔防游戏来做调研参考，最早看的是《三国群殴传》，这款游戏算是老牌塔防游戏App。我觉得美术的风格把握得很到位，地图紧凑，人物KUSO。     第二个看的是《三国塔防魏传》，这款游戏是大企鹅代理的，还去听过他们的这款游戏开发设计的讲座分享。三国塔防的美术也很细致，地图比较大，兵种也有所区别，不过引入的道具让我觉得繁琐，可能是为了收费的Slot。 还有一个玩得比较多的是《塔塔水浒》，这款塔防游戏引入了英雄的概念，多了一些操作。不过早期版本游戏的难度很大，而且一局的时间又特别长，大概半个小时。打到最后失败挫折感就很强，不想再打。后来我提了一些意见，官方居然还有反馈。 著名的《Kingdom rush》反而没有玩过，国内风头一时无两的《保卫萝卜》也是到后来才出世，小猴塔防也是上线后才知道的。     玩别人的IOS塔防游戏做调研参考，主要是以之为鉴。自己的游戏设计好不好玩，能不能跟它们有所区别，什么样的问题自己觉得不好不能犯。     比如地图紧凑的问题，我觉得一个塔防关卡地图，在iphone里刚好一屏幕就好。如果大于一屏，就需要玩家多做操作去拖动地图，这个体验我认为不是很好。这个在三国塔防里就很明显，在《小鳄鱼爱洗澡》里面有些场景也是。不能一眼看到整个地图关卡，会让我觉得不踏实不舒服，而且还需要频繁拖动地图，破坏整个游戏的操作感。     塔防的精髓之一，就在于炮塔的种类、威力和功用。玩三国群殴也发现一些问题，比如有的地图造满投石车之后，就基本不用管看着就行了。这种情况是我不愿意看到的。所以我后来在设计塔防的炮塔的时候，就很注意避免类似的问题。 为什么是坦克     游戏的美术风格的确定也费了不少周折，因为美术我自己做。当时中国App Store很多塔防游戏都是三国流，确实三国武将小兵、炮塔弩车的模式，很适合塔防的调调。我很喜欢三国群殴KUSO的画风，但是真要自己去画，问题就来了。作为一个资深引擎程序员出身的我，根本就无法把握一个Q版的武将人物造型。别说武将了，实际上，我连一个拒马墩都画不好。而且，手机游戏上的图片，是像素画的级别。在32X32、64X64的图片大小里面，就要表现出人物风格造型。这个完全超出了一个眼高手低的程序员的手绘范畴。我摩挲着临时购入的廉价Wacom Bamboo绘图板，看着十几张凌乱而惨不忍睹画稿，一时万念俱灰。     让我去从其他游戏里扣点图片出来用用？这个又明显不符合一个自命不凡的程序员的气节风尚。我是一个很注重版权的人。     在美术风格上纠结了很久，可能有一两个月吧。我突然想起了20多年前，我小时候一口气玩过一百多关的坦克大战。武将画不好，我照猫画虎画几个砖块和坦克总行吧？好歹哥也曾经在小学绘画比赛中得过名次。     有坦克有炮塔，游戏就叫《坦克对大炮》吧。     实践证明，其实坦克也不是那么好画的。我每天都为每种坦克的造型头疼，可能一周也就能搞定一辆坦克。美术弄了几个月，坦克造型、炮塔造型、游戏特效、粒子设计、场景地图贴图、UI图片都陆续差不多弄好了。还借鉴了一些国外开源的像素美术资源（当然要认真遵循别人的协议）。     游戏出来之后，不少人反馈都觉得美术是短板。我自己也觉得确实那个。。。咳。。。咳。。。拿不出手。不过能自己搞定整个游戏美术，也算多了一次经历。这种感觉很不错。凡是有得必有失，咱要鱼不要熊掌。 程序和引擎     程序开发方面，反倒没什么好说的。cocos2d引擎本身是有一些坑的，比如有一次调试到晚上1点，凌晨起来接着Debug。后来发现是被cocos2d引擎的action机制摆了一道。在有复杂情形和需要精确控制的游戏逻辑处理中，action机制相当不可靠。有时候游戏中频繁出现莫名其妙的情况，反复测试调试修改都不行。最后丢弃使用引擎中action的部分，自己重新实现类似机制，问题迎刃而解。这种类似的问题出现过不止一次。趟平了这些坑，就过去了。    苹果的模拟器调试和真机调试，也是有一些区别的。比如模拟器可能有些文件名大小写是兼容的，但是到了真机里面就是大小写敏感的，以前运行正常的游戏就会报错崩溃。真机联机调试，跟itune安装测试，也是有一定区别的。联机调试没问题，安装测试不一定没问题。这个也是我付出了一次审核被拒的经历，才得到的教训。 穿刺炮的设计 我只打算做一款简单的塔防游戏，但是塔防要做得玩起来有点意思，也需要下不少功夫。其实这是废话，任何游戏要好玩，都得下功夫。 虽然我事先考察了一些塔防游戏，但是我从来没有想到照抄或者借鉴这些塔防游戏的玩法和设计。好不容易要做一款独立游戏，自然要做自己的游戏，当然，从其他我喜欢的游戏里借鉴是有的。或者说受了深刻的影响。就像2005年我们做MMO RPG的时候，无一例外或多或少都会受到WOW的影响一样。这个后面会陆续说到。     设计的炮塔里面，有一种炮叫做穿刺炮，子弹有穿刺属性，可以穿刺攻击多个目标，造成一连串伤害。但是为了不让这种炮特别逆天，同时能够清晰的表达穿刺特效，我把这种穿刺炮的子弹速度控制的比较慢。但是在测试过程中，我发现很少有玩家会在实战中使用这种穿刺炮，甚至包括我自己。     我后来就想，为啥呢？我发现是现有的穿刺机制，并不足以鼓励玩家使用这种炮。因为要控制炮弹穿刺打击几个坦克目标，还是比较困难的。对炮塔摆放位置要求很高，并且需要冰冻减速炮的配合。     我要做的是要鼓励玩家多利用穿刺炮的机制，鼓励玩家最大化穿刺的伤害。当时Diabolo 3刚刚出来，我正在玩恶魔猎手。作为暗黑系列AMA式的人物，穿刺箭是招牌技能。有一个穿刺箭的符文，就是每穿刺一次，攻击力就增加70%。我觉得这个设计不错，就是我要找的东西，于是借鉴过来用。这样穿刺炮在穿刺多个目标之后，可能就会打出出很可观的伤害。     然后我发现，这样的改进，穿刺炮的使用率还是不高。似乎还差点什么东西。穿刺炮可以升到3级，每级也就增加一次穿刺次数而已。升级到最高级的炮台，并不能带来激动人心的收益。我后来考虑让最高级的穿刺炮获得一个破甲属性，达到最大穿刺次数以后，会对坦克产生破甲效果。不过因为我糟糕的美术功底，画了一个破甲特效之后，自己都看不下去。于是考虑搞点简单的效果，最后把破甲特效改成了感电特效。     最高级穿刺炮有一定几率对坦克造成感电效果，每穿刺一次，感电的几率增加，当达到最大穿刺数的时候，则100%触发感电特效。感电会在坦克身上引起闪电火花特效，这时候所有炮塔对于坦克的伤害都加倍，并会减缓坦克的速度。好吧，玩DNF（地下城与勇士）的同学可以笑了。     穿刺炮的设计，后来在炮塔群里输出最大化伤害时，起到了一些作用。不过上线之后，我发现穿刺炮的出场率还是没有预期的高，于是在第二版中稍微强化了穿刺炮的射程，并在不影响穿刺特效表达的情况下，调高了炮弹飞行速度。     红衣大炮     游戏里有一种炮塔叫红衣大炮，游戏名字都叫《坦克对大炮》，那么红衣大炮自然是威力最大的一种炮了。红衣大炮不仅炮弹威力最大，而且命中之后有范围爆炸效果（参见星际1的坦克炮）。爆炸之后还有一定的Knock Back作用。2级红衣大炮的爆炸还附带灼烧效果（灼烧Dot伤害）。最高级的红衣大炮，甚至有一定几率击晕坦克(Stun特效）。看上去很不错是不是？      不过我当时犯了矫枉过正的错误，为了防止出现类似无脑投石车那样无敌的问题（或者可以参见帝国时代1的弩车），我严格控制了坦克的威力，而红衣大炮的价格又很贵。所以红衣大炮在第一版上线的时候，性价比很低，玩家根本不买账。有些玩家开始还造一个玩玩，后来发现坑了就不造了。     后来我发现红衣大炮是第一版游戏中出场率倒数第二鸡肋的炮塔。于是在第二版设计中，调整了炮弹威力、爆炸范围、Knock Back距离、以及强化了大炮的射程。通过这些调整，后来新版本上线之后，在有些地图的地形上，可以演化出以红衣大炮为主的打法，甚至是完美过关的打法。  多重射击炮     每个游戏里面都有一个散弹炮，无论是魂斗罗还是打飞机还是塔防。多重射击炮自然就肩负了这样的使命。上面既然说了倒数第二，那么这个就是第一版的倒数第一了。没有人喜欢多重炮，因为它很弱。多重炮刚开始的设计就是级别越高散弹越多，升到最高级的时候，可以触发“乱射”效果。说到乱射，玩过DNF的最帅的漫游枪手同学肯定笑了。其实刚才说到穿刺攻击，应该也有玩弹药的同学笑了。    当然第二版更新，多重炮也是一顿大改。我把乱射技能改到了2级就能触发，3级技能改成了弹幕排射。因为这时候我正在玩LOL（英雄联盟），赏金女枪的大招“弹幕时间”似乎很不错。 玩家的馈赠 虽然第一版上线的《坦克对大炮》的3种炮塔的数值设计有各种问题，但是总体上还是一个数值非常平衡的游戏。好吧，实际上这个游戏总共也只有5种炮塔。但是剩下的两种炮塔：连环弩、冰冻减速炮，数值做的很平衡。 所谓的平衡，就是有一些数值平了以后，才能发现不平衡的。所以在第二版的上线版本中，连环弩、冰冻减速炮的数值，我一个字也没动，也不敢动。因为很多人以这两种炮塔为主力把整个游戏所有关卡打通关了。虽然大家都一致表示游戏关卡很难，有些炮很鸡肋。但是有人通关了我还是很高兴。是非常高兴。     最早通关的玩家，是大艾格拉斯的策划总监张总，也是后来App Store红透半边天的ARPG 《英雄战魂OL》的总设计师。这个对我来说，是很大的肯定。因为游戏上线之后，说实在话我也有些忐忑，不知道游戏到底有没有人喜欢玩儿，不管有多自命不凡，尽管每个关卡都测试过500多遍，其实还是没底儿。后来陆续有更多玩家通关，交流关卡的打法，我的这种紧张忐忑才缓解了一点。     玩家也提出来不少建议和想法。比如第一版打法比较单一，主要就是冰塔减速冻住，连环弩输出伤害。     游戏里确实只有冰冻减速塔一个主要控制手段。其他的控制其实也有，比如3级穿刺炮的感电减速、3级红衣大炮的击晕Stun、Knock Back。但是因为第一版后两种炮塔的鸡肋，这些控制手段也都没有出场机会。一直到第二版更新以后，我强化了其他炮塔，并重新校验了一下各种炮塔的子弹速度，才让打法和炮塔组合更多样了一些。    为什么要强化子弹速度呢，因为这款塔防游戏跟其他的塔防不太一样，炮塔不是锁定攻击的。每颗炮弹的攻击都是真实的飞行碰撞。我当时过于强调了冰冻减速炮的作用，所以其他炮塔对于冰冻减速炮依赖很大。如果没有减速或者冰冻控制，炮弹弹道经常会打不中坦克。后来经过玩家反馈和思考，我发现这么设计过度也有问题，过度依赖冰冻减速，也会抹杀其他各种炮的特性，造成单一的打法，也增大了游戏难度。    我有一个习惯，就是很注意现场观察玩家的操作。在游戏发售前，这项工作我做了很多次，主要是找熟人做测试，从十几岁到几十岁的都有。那怕是有的玩家玩了一下就丢开的，也要琢磨一下为什么。比如我发现了不少玩家使用iphone玩这个游戏的时候，习惯使用拇指操作，而不是我原来想象的那样用食指。这样就要针对这种操作习惯，对于游戏的UE做一些微调。如果一直用模拟器测试，这些问题是发现不了的。而如何微调以适应这种玩家的操作习惯，也不是空想就能调整好的，除了观察玩家，还需要仔细琢磨其他游戏是怎么做的。比如大企鹅的游戏一向在UE方面都做的特别好。     游戏的关卡长度和游戏节奏也是一个问题。很多人都知道手机游戏用碎片时间啥的上等理论。实际上很少人去实践。为了感受游戏的长短节奏，我半年时间都在坐地铁的时候玩自己的游戏，主要是体验坐多少站可以玩一关。还有其他场合，比如银行排队、等人、五谷轮回的时候。   单机需要平衡么          我想做的是一个严谨的游戏，虽然只是一个玩票的塔防游戏。     很多玩家反应最多的是游戏难度太大。特别是第一关就有不少人过不去，甚至有个手机游戏App的网站编辑，打了3个晚上第一关都没过去。这个跟第一版有些炮塔威力不够有关，当然确实是难。     我把游戏数值和金钱抠的很死，前期如果开局不好，比如炮塔搭配不好、或者造塔地形没选好、或者攒钱不花的话，就会造成开局不利的劣势，逐渐积累劣势和错误，就会造成游戏崩盘过关失败。     当然如果懂得利用地形，善于搭配炮塔，利用各种炮塔的特效的话，游戏过程中也会享受到闯关成功的回馈，甚至是完美过关的巨大成就感。还有，很多关卡需要尝试多遍才能打过去是必须的，包括我都经常折戟。我曾经给人演示第5关怎么打，结果我被灭了。     有的玩家打了几天通关、有的玩家陆续玩了几个月才通关、也有玩家几个小时就全通的。还有的玩家为了追求每个关卡都完美过关，经常拿出来玩玩的。     有人问我为什么只做16关？因为每一关都要测试500遍以上，就为了微调数值，做到关卡经得起推敲。可能为了数值是0.5或是0.3的，就要一下午反复的测试某一关或者某一个数据几十次。     我实在没有精力在第一版做很多的关卡。因为做每一关都挺费劲儿。做完16关之后，都有点江郎才尽的感觉。     大艾格拉斯的策划总监张总曾经给我推荐过小猴塔防，说这样的塔防单机才是方向。数值平衡和严谨并不重要，单机游戏的要的是爽快感。而《坦克对大炮》的数值卡的太严，所以很难有这样痛快的感觉。张总的话虽然我不是总是完全同意，但是他说的话我总是会琢磨很多遍。因为张总每次都能发现很多好的游戏，并发掘其中的创意和本质。换句话说，如果有一个人能十几年如一日的专注寻找游戏的奥秘，每天玩好几种游戏，在跃层别墅摆一个街机，我也会尊重他说的见解。    我后来也对小猴塔防的模式想了很久，一个能在很多国家都排在Rank榜单Top 200的独立游戏，并且出到了第5代，这就值得思考。所以虽然当时我坚持说要走数值平衡路线，我还是在第二版更新中做了很多改动。有很多就是为了强化游戏的爽快感和打击感。    为了兼顾爽快感，《坦克对大炮》后面的版本，可能还会推出一个疯狂对攻模式。主要打得以酣畅淋漓为主，弱化数值的严谨性。这个版本早就有了构思，在程序结构上也做了铺垫，现在就只当剧透吧。      我对于游戏这种平衡的执拗来自哪里呢？我后来也反思了很久。我后来想到了我曾经打过几万局的街霸对局。这是一个严谨平衡的游戏，也是对于打击感的诠释。如果一个人玩了十几年街霸，而且还在玩儿，可能就会有这种执拗。           重点     好吧，开始说重点。这款游戏的上线情况不是很理想。App Store中国榜单排名，最好到过策略游戏68名，这还是限免的状态。平时收费下载的话，名次要更靠后。在美国、加拿大、欧洲、日本有一点付费下载收入。 目前和以后     一直在琢磨触屏手机上的动作游戏，主要是横版动作格斗类。俯视角的动作类游戏也有考虑。在触屏时代，这里面可以研究的东西很多。不是简单移植那么简单。   特别鸣谢      曾经两度排行App Store榜首的B总在开发过程中给了我很多支持。      大企鹅软件架构师蛙总在开发过程中也有一些精神上的支持。         大艾格拉斯策划总监张总就不再提了。           2012.12.28 《坦克对大炮》 App Store 链接：  https://itunes.apple.com/cn/app/tank-vs-cannon/id558724834?mt=8","title":"IOS塔防游戏《坦克对大炮》的开发设计记录"},{"content":"cocos2d 开发]看我怎么山寨 忍者跳跃 !!!           其实中国的游戏开发者不写游戏!这里包含各种内涵的意思 ... 如今山寨成风,今个儿开始山寨 一款从iphone上,跨平台到android 很火的游戏 . ninjump (忍者跳跃). 要山寨 先搞清楚别人是怎么开发的 ,能否直接获取到别人的素材?! 这个很关键,因为中国的开发者,一个穷屌丝往往兼顾几个人的使用:游戏策划,游戏运营,游戏编程,游戏美工,游戏音效 等等岗位.  结果出来,各种排斥,各种难赚钱,最后走上加广告的道路,各种推送,各种被骂...如何之苦b,就不是这里要讨论的话题了.刚刚说到 游戏素材,最好能解压apk,拿到直接的png图片,有的 是pk文件,就有些麻烦,别人打包了比较难窃取,今天不讨论.自己下去研究下.         其次要搞清楚别人的开发技术 ,所以游戏 一般有一个技术总监,来指导游戏编程. 解压后ninjump.apk后,你就会发现,里面 目录其实很清楚 : \\assets\\ 下面放着各种  : music  ;scripts;sounds;textures 等 ;通过名字大概就知道 图片纹理在哪,声音在哪;        scripts 是放在全是lua文件.可知,它是采用 lua脚本编程,java很少的代码, 是c++的引擎库 和lua 脚本实现游戏界面. 而且它能很好的跨平台,只要再各各平台实现 引擎库,lua 都不用变 直接上,很是方便. 开源的引擎是有很多的. 今个儿选择 cocos2d 来山寨它 .        先上山寨截图.                    游戏如今分几个模块来开发: hero 英雄sbHero            :   climber 攀爬者, 向上攀爬. 处理各种 动画脚本,碰撞反应 bg 背景sbBackGround   :    背景图,背景滚动,这里用到 2个 CCSpriteBatchNode 来循环 向下滚动 . 动画管理器AnimationManager: 用来管理纹理缓冲,获得动画.(所有的动画都从这里获取得) bird      sbBird                :  鸟儿障碍物 squirrel  sbSquirrel        :   松鼠障碍物 star 飞镖 sbStar            :   飞镖障碍物 bomb     sbBomb       :   炸弹障碍物.   level    等级                   : 最关键的 一个类,管理 游戏背景中障碍物的出现,已经碰撞检测. 粒子效果的产生.游戏的平很全靠它.  关于动画管理器AnimationManager: 动画管理很重要,包含纹理CCTextureCache. bool AnimationManager::initAnimationMap(){\tCCAnimationCache::sharedAnimationCache()->addAnimation(createNPCAnimation(), \"jumping\");\t/* 代码  ... 忽略20行 */\treturn true;} CCAnimation* AnimationManager::createNPCAnimation(){\tCCTexture2D *playerRunTexture = CCTextureCache::sharedTextureCache()->addImage(\"enemies/jumping.png\");          CCAnimation* animation = CCAnimation::create();  \tfor( int i = 0;i < 5;i++){          animation->addSpriteFrame(CCSpriteFrame::create(playerRunTexture, cocos2d::CCRectMake(100*i, 0, 100, 100)));      }  \t for( int i = 0;i < 5;i++){          animation->addSpriteFrame(CCSpriteFrame::create(playerRunTexture, cocos2d::CCRectMake(100*i, 100, 100, 100)));      }      animation->setDelayPerUnit(0.4f/10 );\tanimation->setRestoreOriginalFrame(false);\treturn animation;} 动画使用呢,很简单 .这个实现左右jump .  由于纹理 只有一个方向.通过 heroSprite->setFlipX(true);来设置精灵左右倒置. case HERO_ACTION_JUMP_L:\t\tif( spState != HERO_ACTION_RUN_R )\t\t\t\t\tbreak;\t\t//heroSprite->setFlipX(false);\t\taction2 = CCMoveTo::create(0.4f, CCPointMake(HERO_OFFX, HERO_OFFY));  \t\taction = CCSpawn::create(sAnimationMgr->createAnimate(\"jumping\") ,action2,NULL);\t\taction4 = CCCallFuncND::create(this,callfuncND_selector(sbHero::Action_done), (void *)act);\t\taction3  = CCSequence::create( action,action4,NULL   );\t\theroSprite->runAction( action3 );\t\tspState = HERO_ACTION_JUMP_L;\t\tbreak;以上为代码中一部分.使用其动画! JUMP动画创建完成,调用完成后,走 Action_done  ! 根据往左跳还是往右跳,分别是实现 jump 动画 后的 向上爬 的动画. \tvoid Action_done( void *ad ,int act )\t{\t\tswitch( act )\t\t{\t\tcase HERO_ACTION_JUMP_L:\t\t\theroSprite->setPosition(ccp(HERO_OFFX,HERO_OFFY));  \t\t\theroSprite->setFlipX(false);\t\t\tStart( HERO_ACTION_RUN );\t\t\tspState = HERO_ACTION_RUN_L;\t\t\tbreak;\t\tcase HERO_ACTION_JUMP_R:\t\t\t heroSprite->setPosition(ccp(SCREEN_SIZE_W-HERO_OFFX-40,HERO_OFFY));  \t\t\t heroSprite->setFlipX(true);\t\t\t Start( HERO_ACTION_RUN );\t\t\t spState = HERO_ACTION_RUN_R;\t\t\t break;\t\tcase HERO_ACTION_RUNON_SQL:\t\t\tAction_done(NULL,spState);\t\t\tbreak;/* 代码  ... 忽略20行 */ 这样 通过 动画管理器,实现一个左右跳动后,继续向上爬的过程. 如此,继续向动画管理器中加入其他动画实例,在需要的里面调用. 比如bird 怎么飞.  松鼠应该是在 晒衣服绳子上跳. 未完. 我的csdn下载资源: http://download.csdn.net/user/icemanyandy","title":"[置顶] [cocos2d 开发]看我怎么山寨 跳跃忍者 !!!ninjump 1"},{"content":"有段时间没更新博客了，这几天都比较忙，要完成boss布置的一些任务，前些天又请了四天假回校考试跟入党转正。对于实习生来说，一下子请四天假堪称胆大包天！话说入党这事真的很纠结，也不知道自己大一点时候怎么就那么傻要申请入党呢？现在有点后悔了。愤青伤不起。 这篇博客我就不参考其他高手的啦，可以看出自己这阶段确实是有点进步的！不过推荐大家看篇程序员“小说”吧。昨天无意间看到的，有一百多篇，挺喜欢的，觉得跟自己找工作时的情况很像。我想，你看了之后肯定也能从其中找到共鸣的！ http://blog.csdn.net/norains?viewmode=contents  那些年，哪些是——一个程序员的奋斗史 好，开始进入正题。 说到这个逐帧动画，额，应该是叫逐帧动画吧。对这货理解的比较容易，因为大一的时候有用半年时间自学过flash，所以用起来也还算顺。 首先从官方自带的tsetcpp说起： 在spritetest中 \"Sprite offset + anchor + rot\";这个例子：有如下几句：     //这是第一种方法，我用的也是这种     CCSpriteFrameCache* cache = CCSpriteFrameCache::sharedSpriteFrameCache();     cache->addSpriteFramesWithFile(\"animations/grossini.plist\");     cache->addSpriteFramesWithFile(\"animations/grossini_gray.plist\", \"animations/grossini_gray.png\");     CCArray* animFrames = CCArray::createWithCapacity(14);         char str[100] = {0};         for(int i = 0; i < 14; i++)          {             sprintf(str, \"grossini_dance_%02d.png\",(i+1));             CCSpriteFrame *frame = cache->spriteFrameByName(str);             animFrames->addObject(frame);         }         CCAnimation* animation = CCAnimation::createWithSpriteFrames(animFrames, 0.3f);         sprite->runAction(CCRepeatForever::create( CCAnimate::create(animation) ) );                     //     // File animation，这是第二种方法     //     // With 2 loops and reverse     CCAnimationCache *cache = CCAnimationCache::sharedAnimationCache();     cache->addAnimationsWithFile(\"animations/animations-2.plist\");     CCAnimation *animation2 = cache->animationByName(\"dance_1\");     CCAnimate* action2 = CCAnimate::create(animation2);     m_tamara->runAction(CCSequence::create(action2, action2->reverse(), NULL));     //     // File animation，这是第三种方法，其实也不能这么说，它就是在第二种的基础上做了一些更基础的改动     //     // with 4 loops     CCAnimation *animation3 = (CCAnimation *)animation2->copy()->autorelease();     animation3->setLoops(4);     CCAnimate* action3 = CCAnimate::create(animation3);     m_kathia->runAction(action3); 好了，test就这么些，但是我必须强调的是：上面几种除了第一种，其他方法我用起来都没成功过！！！ 第二种一直卡在 CCAnimation *animation2 = cache->animationByName(\"dance_1\");这一步，为什么呢？因为 dance_1这不是图片，这是一个动画，我根本就不知道在什么时候，什么地点要做这个动画，所以，扑街。 第三种跟第二种差不多，无解。 其实有一种傻瓜式的方法。前两个星期我做动画的时候依然采取了下面这种傻瓜式逐帧动画。请看大屏幕： CCSpriteFrameCache *cache = CCSpriteFrameCache::sharedSpriteFrameCache(); cache->addSpriteFramesWithFile(\"feng/fall.plist\"); CCArray *animFrames = new CCArray(3); // 一共有4幀         CCSpriteFrame *frame = cache->spriteFrameByName(\"fall1.png\"); // 加進第1幀         animFrames->addObject(frame);         frame = cache->spriteFrameByName(\"fall2.png\"); // 加進第2幀         animFrames->addObject(frame);         frame = cache->spriteFrameByName(\"fall3.png\"); // 加進第3幀         animFrames->addObject(frame); //control the fall each frame of move CCAnimation *animation = CCAnimation::createWithSpriteFrames(animFrames,0.2f); CCAnimate* action = CCAnimate::create(animation); CCSprite* fall = CCSprite::create(\"feng/fall1.png\"); fall->runAction(CCRepeatForever::create(action)); this->addChild(fall,1); fall->setAnchorPoint(CCPointZero); fall->setPosition(ccp(215,370)); fall->setScale(0.5f); 方法很傻，但是很有效。如果有高手知道更方便的方法或者知道test的方法应该如何破解，希望能在评论里给出解答。谢谢","title":"cocos2d-x 菜鸟实习生学习篇（七） 逐帧动画"},{"content":"<ContentControl     xmlns:Controls=\"using:WinRTXamlToolkit.Controls\"     x:Class=\"TSM.View.Control.HubTile\"    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"    xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"    xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"    mc:Ignorable=\"d\"     x:Name=\"gridViewItem\"    d:DesignHeight=\"150\"    d:DesignWidth=\"150\" IsTapEnabled=\"False\" IsRightTapEnabled=\"False\" IsHoldingEnabled=\"False\" IsDoubleTapEnabled=\"False\">    <ContentControl.Resources>        <Storyboard x:Name=\"UpperSecStoryboard\">            <DoubleAnimationUsingKeyFrames Storyboard.TargetProperty=\"Opacity\" Storyboard.TargetName=\"Img2\">                <DiscreteDoubleKeyFrame KeyTime=\"0:0:0.4\" Value=\"0\"/>                <DiscreteDoubleKeyFrame KeyTime=\"0:0:0.8\" Value=\"1\"/>            <\/DoubleAnimationUsingKeyFrames>            <DoubleAnimationUsingKeyFrames Storyboard.TargetProperty=\"(UIElement.Projection).(PlaneProjection.RotationX)\" Storyboard.TargetName=\"Img2\">                <EasingDoubleKeyFrame KeyTime=\"0:0:0.4\" Value=\"90\">                    <EasingDoubleKeyFrame.EasingFunction>                        <QuadraticEase EasingMode=\"EaseIn\"><\/QuadraticEase>                    <\/EasingDoubleKeyFrame.EasingFunction>                <\/EasingDoubleKeyFrame>                <EasingDoubleKeyFrame KeyTime=\"0:0:0.8\" Value=\"-90\">                    <EasingDoubleKeyFrame.EasingFunction>                        <QuadraticEase EasingMode=\"EaseIn\"><\/QuadraticEase>                    <\/EasingDoubleKeyFrame.EasingFunction>                <\/EasingDoubleKeyFrame>            <\/DoubleAnimationUsingKeyFrames>            <DoubleAnimationUsingKeyFrames Storyboard.TargetProperty=\"(UIElement.Projection).(PlaneProjection.RotationX)\" Storyboard.TargetName=\"Img1\">                <EasingDoubleKeyFrame KeyTime=\"0:0:0.4\" Value=\"-90\">                    <EasingDoubleKeyFrame.EasingFunction>                        <QuadraticEase EasingMode=\"EaseIn\"><\/QuadraticEase>                    <\/EasingDoubleKeyFrame.EasingFunction>                <\/EasingDoubleKeyFrame>                <EasingDoubleKeyFrame KeyTime=\"0:0:0.8\" Value=\"0\">                    <EasingDoubleKeyFrame.EasingFunction>                        <QuadraticEase EasingMode=\"EaseIn\"><\/QuadraticEase>                    <\/EasingDoubleKeyFrame.EasingFunction>                <\/EasingDoubleKeyFrame>            <\/DoubleAnimationUsingKeyFrames>        <\/Storyboard>        <Storyboard x:Name=\"UpperFirstStoryboard\">            <DoubleAnimationUsingKeyFrames Storyboard.TargetProperty=\"Opacity\" Storyboard.TargetName=\"Img1\">                <DiscreteDoubleKeyFrame KeyTime=\"0:0:0.4\" Value=\"0\"/>                <DiscreteDoubleKeyFrame KeyTime=\"0:0:0.8\" Value=\"1\"/>            <\/DoubleAnimationUsingKeyFrames>            <DoubleAnimationUsingKeyFrames Storyboard.TargetProperty=\"(UIElement.Projection).(PlaneProjection.RotationX)\" Storyboard.TargetName=\"Img1\">                <EasingDoubleKeyFrame KeyTime=\"0:0:0.4\" Value=\"90\">                    <EasingDoubleKeyFrame.EasingFunction>                        <QuadraticEase EasingMode=\"EaseIn\"><\/QuadraticEase>                    <\/EasingDoubleKeyFrame.EasingFunction>                <\/EasingDoubleKeyFrame>                <EasingDoubleKeyFrame KeyTime=\"0:0:0.8\" Value=\"-90\">                    <EasingDoubleKeyFrame.EasingFunction>                        <QuadraticEase EasingMode=\"EaseIn\"><\/QuadraticEase>                    <\/EasingDoubleKeyFrame.EasingFunction>                <\/EasingDoubleKeyFrame>            <\/DoubleAnimationUsingKeyFrames>            <DoubleAnimationUsingKeyFrames Storyboard.TargetProperty=\"(UIElement.Projection).(PlaneProjection.RotationX)\" Storyboard.TargetName=\"Img2\">                <EasingDoubleKeyFrame KeyTime=\"0:0:0.4\" Value=\"-90\">                    <EasingDoubleKeyFrame.EasingFunction>                        <QuadraticEase EasingMode=\"EaseIn\"><\/QuadraticEase>                    <\/EasingDoubleKeyFrame.EasingFunction>                <\/EasingDoubleKeyFrame>                <EasingDoubleKeyFrame KeyTime=\"0:0:0.8\" Value=\"0\">                    <EasingDoubleKeyFrame.EasingFunction>                        <QuadraticEase EasingMode=\"EaseIn\"><\/QuadraticEase>                    <\/EasingDoubleKeyFrame.EasingFunction>                <\/EasingDoubleKeyFrame>            <\/DoubleAnimationUsingKeyFrames>        <\/Storyboard>    <\/ContentControl.Resources>    <Grid Width=\"{Binding Width, ElementName=gridViewItem}\" Height=\"{Binding Height, ElementName=gridViewItem}\">        <Grid.Background>            <ImageBrush/>        <\/Grid.Background>        <Canvas x:Name=\"PART_LayoutRoot\" >            <Canvas x:Name=\"PART_Panel\">                <Canvas                     Height=\"{Binding Height, ElementName=gridViewItem}\"                     x:Name=\"FirstImg\">                    <Grid  x:Name=\"PART_FirstContent\">                        <Image x:Name=\"Img1\"                                Width=\"{Binding Width, ElementName=gridViewItem}\"                                Height=\"{Binding Height, ElementName=gridViewItem}\"                               Stretch=\"Fill\" VerticalAlignment=\"Center\"                               Canvas.ZIndex=\"1\">                            <Image.Projection>                                <PlaneProjection/>                            <\/Image.Projection>                        <\/Image>                    <\/Grid>                    <Canvas.RenderTransform>                        <CompositeTransform/>                    <\/Canvas.RenderTransform>                <\/Canvas>                <Canvas                     x:Name=\"SecImg\"                     Height=\"{Binding Height, ElementName=gridViewItem}\">                    <Canvas.RenderTransform>                        <CompositeTransform/>                    <\/Canvas.RenderTransform>                    <Grid x:Name=\"SecGrid\">                        <Image x:Name=\"Img2\"                \t\t\tWidth=\"{Binding Width, ElementName=gridViewItem}\"                 \t\t\tHeight=\"{Binding Height, ElementName=gridViewItem}\"                \t\t\tStretch=\"Fill\" VerticalAlignment=\"Center\">                            <Image.Projection>                                <PlaneProjection RotationX=\"-90\"/>                            <\/Image.Projection>                        <\/Image>                    <\/Grid>                <\/Canvas>            <\/Canvas>        <\/Canvas>    <\/Grid><\/ContentControl>   代码： using System;using System.Collections.Generic;using System.Collections.ObjectModel;using System.Diagnostics;using System.IO;using System.Linq;using System.Threading.Tasks;using TSM.Config;using TSM.Tools;using Windows.Foundation;using Windows.Foundation.Collections;using Windows.Storage;using Windows.Storage.BulkAccess;using Windows.Storage.Search;using Windows.Storage.Streams;using Windows.UI.Xaml;using Windows.UI.Xaml.Controls;using Windows.UI.Xaml.Controls.Primitives;using Windows.UI.Xaml.Data;using Windows.UI.Xaml.Input;using Windows.UI.Xaml.Media;using Windows.UI.Xaml.Media.Animation;using Windows.UI.Xaml.Media.Imaging;using Windows.UI.Xaml.Navigation;using WinRTXamlToolkit.AwaitableUI;using WinRTXamlToolkit.Controls;using WinRTXamlToolkit.Imaging;// “用户控件”项模板在 http://go.microsoft.com/fwlink/?LinkId=234236 上提供namespace TSM.View.Control{    public sealed partial class HubTile : ContentControl    {        private static Uri _baseUri = new Uri(\"ms-appx:///\");        #region propdp        #region ImgList        public ObservableCollection<string> ImgList        {            get { return (ObservableCollection<string>)GetValue(ImgListProperty); }            set { SetValue(ImgListProperty, value); }        }        // Using a DependencyProperty as the backing store for ImgList.  This enables animation, styling, binding, etc...        public static readonly DependencyProperty ImgListProperty =            DependencyProperty.Register(            \"ImgList\",            typeof(ObservableCollection<string>),            typeof(HubTile),            new PropertyMetadata(null, OnImgListChanged));        private static void OnImgListChanged(           DependencyObject d, DependencyPropertyChangedEventArgs e)        {            var target = (HubTile)d;        }        #endregion        #endregion        protected override void OnGotFocus(RoutedEventArgs e)        {            base.OnGotFocus(e);        }        public HubTile()        {            this.InitializeComponent();            Storyboard storySec = null;            Storyboard storyFir = null;            DispatcherTimer timer = new DispatcherTimer();            int index = 0;            bool isFirst = true;            this.Loaded += ((sender, e) =>            {                storySec = Resources[\"UpperSecStoryboard\"] as Storyboard;                storyFir = Resources[\"UpperFirstStoryboard\"] as Storyboard;                if (null != ImgList && ImgList.Count > 0)                {                    BitmapImage _source = new BitmapImage();                    var url = ImgList[0];                    Uri uri = null;                    if (null != url)                    {                        if (url.StartsWith(\".\") || url.StartsWith(\"ms\"))                        {                            uri = new Uri(HubTile._baseUri, url);                            _source.UriSource = uri;                        }                        else if (url.StartsWith(\"http://\"))                        {                            uri = new Uri(url);                            _source.UriSource = uri;                        }                        else                            SetSource(_source, url);                        this.Img1.Source = _source;                        if (ImgList.Count >= 2)                        {                            if (null != timer)                                timer.Start();                        }                    }                }            });            this.Unloaded += ((sender, e) =>            {                if (null != timer)                    timer.Stop();                this.Img1.Source = null;                this.Img2.Source = null;            });            Random r = new Random(Convert.ToInt32(DateTime.Now.Millisecond));            var second = r.Next(2000, 6000);            Debug.WriteLine(this.Name + \"间隔时间:\" + second);            timer.Interval = TimeSpan.FromMilliseconds(second);            timer.Tick += (async (o, b) =>            {                index++;                if (ImgList == null)                {                    timer.Stop();                }                else                {                    var count = ImgList.Count;                    if (null != ImgList && count != 0)                    {                        var url = ImgList[index % count];                        Uri uri = null;                        BitmapImage _source = new BitmapImage();                        _source.DecodePixelHeight = 200;                        _source.DecodePixelWidth = 200;                        if (url.StartsWith(\".\") || url.StartsWith(\"ms\"))                        {                            if (url.StartsWith(\".\"))                                uri = new Uri(HubTile._baseUri, url);                            else                                uri = new Uri(url);                            _source.UriSource = uri;                        }                        else if (url.StartsWith(\"http://\"))                        {                            _source.UriSource = new Uri(url);                        }                        else                            _source = await GetLocalImageSource(url);                        Debug.WriteLine(this.Name + \"加载图片...\" + url);                        if (isFirst)                        {                            isFirst = false;                            await storySec.BeginAsync();                            this.Img2.Source = _source;                            Canvas.SetZIndex(SecImg, 1);                            Canvas.SetZIndex(FirstImg, 2);                        }                        else                        {                            isFirst = true;                            await storyFir.BeginAsync();                            this.Img1.Source = _source;                            Canvas.SetZIndex(SecImg, 2);                            Canvas.SetZIndex(FirstImg, 1);                        }                    }                }            });        }        private async Task<BitmapImage> GetLocalImageSource(string url)        {            StorageFile file = await StorageFile.GetFileFromPathAsync(url);            var img = await file.GetThumbnailAsync(Windows.Storage.FileProperties.ThumbnailMode.PicturesView, 400, Windows.Storage.FileProperties.ThumbnailOptions.ResizeThumbnail);            BitmapImage bitmapImage = new BitmapImage();            await bitmapImage.SetSourceAsync(img);            return bitmapImage;        }        private async void SetSource(BitmapSource _source, string url)        {            try            {                _source = await GetLocalImageSource(url);            }            catch (Exception)            {                _source = null;            }        }    }}     通过 awaitable 事件 实现 动画切换完毕后 更换图片  达到 翻转效果  timer 时间为随机数  不会造成同屏幕 所有瓷砖同时翻转 http://download.csdn.net/detail/wangrenzhu2011/4946056  ","title":"SliderHubTile 用windows8 制作 仿wp8 翻转瓷砖"},{"content":"第一部分：基本图形绘制 cocos2dx封装了大量opengl函数，用于快速绘制基本图形，这些源代码在，cocos2dx\\draw_nodes\\CCDrawingPrimitives.cpp文件里面 注意，该方法是重载node的draw方法实现的，在智能机上，并不推荐直接绘制几何图形，因为大量的坐标编码会极大降低工作效率，应尽量使用Image。而且cocos2dx的渲染机制会造成前后遮挡问题，尤其是几何图形与图片等其他node混合绘制时。 void DrawPrimitivesTest::draw()  {          CCLayer::draw();        CCSize s = CCDirector::sharedDirector()->getWinSize();                    // draw a simple line          // The default state is:          // Line Width: 1          // color: 255,255,255,255 (white, non-transparent)          // Anti-Aliased          glEnable(GL_LINE_SMOOTH);          ccDrawLine( CCPointMake(0, 0), CCPointMake(s.width, s.height) );                    // line: color, width, aliased          // glLineWidth > 1 and GL_LINE_SMOOTH are not compatible            //注意：线宽>1 则不支持GL_LINE_SMOOTH          // GL_SMOOTH_LINE_WIDTH_RANGE = (1,1) on iPhone          glDisable(GL_LINE_SMOOTH);          glLineWidth( 5.0f );          /*glColor4ub(255,0,0,255);*/          glColor4f(1.0, 0.0, 0.0, 1.0);          ccDrawLine( CCPointMake(0, s.height), CCPointMake(s.width, 0) );            // TIP:          // If you are going to use always the same color or width, you don't          // need to call it before every draw          //          // Remember: OpenGL is a state-machine.                    // draw big point in the center          // 注意：cocos2dx绘制的是方块点          glPointSize(64);          /*glColor4ub(0,0,255,128);*/          glColor4f(0.0, 0.0, 1.0, 0.5);          ccDrawPoint( CCPointMake(s.width / 2, s.height / 2) );                    // draw 4 small points          // 注意：cocos2dx绘制的是方块点          CCPoint points[] = { CCPointMake(60,60), CCPointMake(70,70), CCPointMake(60,70), CCPointMake(70,60) };          glPointSize(4);          /*glColor4ub(0,255,255,255);*/          glColor4f(0.0, 1.0, 1.0, 1.0);          ccDrawPoints( points, 4);                    // draw a green circle with 10 segments          glLineWidth(16);          /*glColor4ub(0, 255, 0, 255);*/          glColor4f(0.0, 1.0, 0.0, 1.0);          //参数依次是：中心点，半径，角度，分段数，是否连接中心点          ccDrawCircle( CCPointMake(s.width/2,  s.height/2), 100, 0, 10, false);            // draw a green circle with 50 segments with line to center          glLineWidth(2);          /*glColor4ub(0, 255, 255, 255);*/          glColor4f(0.0, 1.0, 1.0, 1.0);          ccDrawCircle( CCPointMake(s.width/2, s.height/2), 50, CC_DEGREES_TO_RADIANS(90), 50, true);                      // open yellow poly          /*glColor4ub(255, 255, 0, 255);*/          glColor4f(1.0, 1.0, 0.0, 1.0);          glLineWidth(10);          CCPoint vertices[] = { CCPointMake(0,0), CCPointMake(50,50), CCPointMake(100,50), CCPointMake(100,100), CCPointMake(50,100) };          //参数依次是：点数组，点数量，是否封闭          ccDrawPoly( vertices, 5, false);                    // closed purple poly          /*glColor4ub(255, 0, 255, 255);*/          glColor4f(1.0, 0.0, 1.0, 1.0);          glLineWidth(2);          CCPoint vertices2[] = { CCPointMake(30,130), CCPointMake(30,230), CCPointMake(50,200) };          ccDrawPoly( vertices2, 3, true);                    // draw quad bezier path            //绘制有一个控制点的贝塞尔曲线          ccDrawQuadBezier(CCPointMake(0,s.height), CCPointMake(s.width/2,s.height/2), CCPointMake(s.width,s.height), 50);            // draw cubic bezier path            //绘制有两个控制点的贝塞尔曲线          ccDrawCubicBezier(CCPointMake(s.width/2, s.height/2), CCPointMake(s.width/2+30,s.height/2+50), CCPointMake(s.width/2+60,s.height/2-50),CCPointMake(s.width, s.height/2),100);            //恢复opengl的正常参数          // restore original values          glLineWidth(1);          /*glColor4ub(255,255,255,255);*/          glColor4f(1.0, 1.0, 1.0, 1.0);          glPointSize(1);  }  第二部分：字符串绘制 #1 cocos2dx的字符串绘制使用的是Label，cocos2dx并不直接支持在屏幕中绘制字符串（这是有道理的，因为我们不能直接把一个string做成一个节点，那样很难理解），如果要直接绘制的话，可以自己封装opengl函数（网上有很多例子，一般是用texture做）。 其实最简单的绘制例子就是最开始的那个Helloworld。核心代码如下： // Create a label and initialize with string \"Hello World\".  CCLabelTTF* pLabel = CCLabelTTF::labelWithString(\"Hello World\", \"Thonburi\", 64);  CC_BREAK_IF(! pLabel);    // Get window size and place the label upper.  CCSize size = CCDirector::sharedDirector()->getWinSize();  pLabel->setPosition(ccp(size.width / 2, size.height - 20));    // Add the label to HelloWorld layer as a child layer.  this->addChild(pLabel, 1);  建立一个CCLabelTTF并添加到子节点即可。 #2 绘制中文 但，如果绘制中文呢？           CCLabelTTF* pLabel = CCLabelTTF::labelWithString(\"你好，世界\", \"Thonburi\", 64); 这里的中文字符要是UTF-8的格式 注意：需要使用VS的另存为功能 ，将含有中文字符串的源代码，保存为UTF-8格式 。否则显示为乱码。 手动保存比较麻烦，可以使用批量转换工具，如：boomworks的“文件编码转换工具”     #3 文字锚点对齐与坐标计算 为了便于字体对齐，我们在很多游戏引擎中，都使用对齐锚点的功能，如j2me的anchor参数接口。 我们添加一个CCLayer，并重载他的draw函数，然后在draw中绘制十字线。 void HelloWorldLayer::draw()  {          CCLayer::draw();            CCSize s = CCDirector::sharedDirector()->getWinSize();            glEnable(GL_LINE_SMOOTH);          ccDrawLine( CCPointMake(0, s.height/2), CCPointMake(s.width, s.height/2) );          ccDrawLine( CCPointMake(s.width/2, 0), CCPointMake(s.width/2, s.height) );  }  然后，我们重写绘制字体函数，将坐标修改为屏幕正中 pLabel->setPosition(ccp(size.width / 2, size.height/2));  可以看到，cocos2d默认锚点是node的中心。 如果要采用其他方式对齐，如左上角，可以使用getContentSize()获取CCSize。然后调整位置。 注意：中文字符获取宽高似乎有bug，在win32上面获得不了准确的数值。 注意：由于手机不同平台的适配方案不同，我们在写坐标时，不要使用绝对坐标值的加减，而应使用比例，乘除等方法。否则，开启适配函数后，坐标值会被映射成多个像素点，造成渲染错位。 第三部分：绘制图片 cocos2dx中并没有直接绘制图片的概念，我们一般是使用CCSprite。核心代码如下： // 3. Add add a splash screen, show the cocos2d splash image.  CCSprite* pSprite = CCSprite::spriteWithFile(\"HelloWorld.png\");  CC_BREAK_IF(! pSprite);    // Place the sprite on the center of the screen  pSprite->setFlipX(true); //可以手动设置图形旋转和镜像，而不是使用Action，因为有许多Action是个过程，而不是直接显示结果  pSprite->setRotation(90);  pSprite->setPosition(ccp(size.width/2, size.height/2));    // Add the sprite to HelloWorld layer as a child layer.  this->addChild(pSprite, 0);  绘制后的效果如下：    ","title":"cocos2d-x学习笔记02：绘制基本图元"},{"content":"如果锤炼是一种炼狱，那么炼狱即是追逐光芒。没有一篇技术博文的创作不是艰辛的，看似轻松的文字背后，凝聚着博主无数个日夜的苦心。笔耕不辍，真正的炼狱，将技术不断重构，并痛快地分享，炼狱中的逐光。 十年之前，你不认识我，我不属于你。在186单片机上，我用汇编和C编写了全套的人机界面、驱动、通信模块软件。开始的雏型，是真正的谭浩强C“杰作”，没有很好的模块划分，没有面向对象的思想。在长达半年的时间里，我不断对这个软件进行重构，它有了很好的OO，而整个软件，也开始变得高内聚、低耦合。于是，我将这些心得，整理为《C语言嵌入式系统编程修炼之道》，该组文章，今天仍在互联网上口口相传。这算是我写博的开端吧。 其后，在工作和实践中，又陆续创作了《基于嵌入式操作系统VxWorks的多任务并发程序设计》、《深入浅出MFC“文档/视图”架构》、《深入浅出Win32多线程程序设计》、《VC++动态链接库(DLL)编程》、《黑客之旅――原始套接字（Raw Socket）透析》、《Cadence 高速PCB的时序分析》等博文，都是当时研发心路的记载。至今仍时常收到读者交流其中的问题，而其中的绝大多数技术领域，我已不再从事。每一个从那个年代走过来的人，似乎都经历了VC、VxWorks的时代。青春已逝，而过去的博文，就像一位位老朋友，每次见面，可以豪饮长谈。 从未在大学、任何一个培训班，上过一节Linux课的我，抱着对Linux的浓厚兴趣和技术人莫名的求知欲，总结自己玩Linux的小小心得创作了一组浅显的《深入浅出Linux设备驱动》，那是2007年。这一连载以最简单的globalvar案例描述Linux驱动的写法，成为很多人进入Linux内核领域的入门读物。是时候，把它转化为正式的出版物了，于是，便有了人民邮电出版社的《Linux设备驱动开发详解》。而《Linux设备驱动开发详解》何尝不是一篇更长的博文呢？很多事情，你只要稍微比别人认真一点点，就可以做到最好。中文的驱动书，唯有我的这一本，进得了厅堂，入不了厨房。其他的，都在厨房里面当柴火烧掉了。而《详解》这篇大博文，仍然有许多的bug需要fix，许多新的feature需要添加。于是，我仍然要在这个炼狱不断地逐光，形成了第3版的完整重构计划。 写一篇更大的博文，几乎没有利益的驱动。因为，最畅销的技术图书，在中国的版税，毫不夸张地讲，只够在京沪换一个厕所，与粪土共舞。如果在伟大的淘宝可以20元买到，为什么要以100元的高价去买正版呢？我不反感技术图书的盗版，如果盗版可以让更多的贫困学生读到你的文字，这何尝不是实现了心中的光芒？ “早晨从中午开始”，我想，更多的不是描述时间，而是一种形态。每一次辛苦的博文创作，你或者在午夜，或者在清晨，或者在黄昏，这何尝有任何的区别？因为，早晨总是从中午开始。在时空错乱中，飞快地弹奏着你的那幅海上的钢琴。远洋无边无际，旅人如斯过往。唯有文字，如流动的天籁音符，划破时空。  这些年，我走街串巷，在很多嵌入式领域企业流浪。所谓“布道”者，其实只是在创作一篇篇即时的口头博文。余深感很多人所从事的研发，实际是垃圾代码的不断演绎。何尝有停下你飞奔的脚步，等一等你的灵魂？让你的大脑对你的技术进行重构，从而提升技术的内涵？研发十年，等于一年？掩或研发一年，等于十年？而其中的关键，便在于是否在炼狱中锤炼，锤炼即重构，重构即博文。 宋宝华 2012年12月于上海浦东 (感谢51cto组织的2012年度十大杰出IT博客活动，借此活动的机会抒发对技术的感想 http://blog.51cto.com/contest2012/)","title":"炼狱与逐光——我的十杰博客获奖感言"},{"content":"Caused by: java.lang.IllegalArgumentException: Service not registered:com.broadcom.bt.app.settings.ServiceExtraSettingsActivity@414e11e0  at android.app.LoadedApk.forgetServiceDispatcher(LoadedApk.java:923)  at android.app.ContextImpl.unbindService(ContextImpl.java:1234)  at android.content.ContextWrapper.unbindService(ContextWrapper.java:405)  at com.broadcom.bt.app.settings.ServiceExtraSettingsActivity.onPause(ServiceExtraSettingsActivity.java:169)  at android.app.Activity.performPause(Activity.java:5108)  at android.app.Instrumentation.callActivityOnPause(Instrumentation.java:1225)  at android.app.ActivityThread.performPauseActivity(ActivityThread.java:2838)  ... 12 more   服务未注册，看到其他博客上是用this.getApplicationContext去获取的bindservice 但为了保险起见，我的做法是设置一个布尔型的变量 1、private boolean isBind = false ; 2、isBind = bindService(svcMgrIntent, this, Context.BIND_AUTO_CREATE);  3、if (isBind) {             unbindService(this);             isBind = false;         }","title":"Service not registered"},{"content":"2012年的最后一天，哥在为大家献礼，介绍技术小细节： 在.h文件的生命中     SystemSoundID  soundID; 在.m的文件中，第一次执行的DidViewLoad方法里面加入  NSString *path = [[NSBundle mainBundle] pathForResource:@\"happy\" ofType:@\"mp3\"]; AudioServicesCreateSystemSoundID((CFURLRef)[NSURL fileURLWithPath:path], &soundID); 这两行语句就把对应的音频文件绑定到了相关的SystemSoundID上面了。 在需要调用的方法里面加入下面的语句，就可以把声音调用出来了  AudioServicesPlaySystemSound (soundEgg); 非常简单好用 祝大家忘却2012的烦恼，带着2012的幸福，进入到充满前景的2013。 2013的任务还是需要多多积累实力，积攒力量，匍匐前进，忍着，忍住。还不是叫板的时候。","title":"ios 加入声音效果"},{"content":"   废话不多说，解决问题 看标题 直接修改 清单文件中的 或添加 AndroidManifest.xml添加<uses-sdk android:minSdkVersion=\"4\" />，即可解决问题","title":"RelativeLayout 布局底部的EditText会被弹出的键盘遮挡"},{"content":"现在WAP开发获得用户的访问信息都是通过对HTTP请求的头信息（WAP站的话就是手机请求头信息）分析来实现的，但是通过我们站点对这些请求信息的统计，发现手机的User_Agent不是一般的乱。相同浏览器的User_Agent存在不规范，这里面最恶心的当属UC浏览器，不同浏览器就更不用说。比如UC浏览器下，华为手机（huawei U9510e）的user_agent居然这样显示： HTTP_USER_AGENT:Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/534.31 (KHTML, like Gecko) Chrome/17.0.558.0 Safari/534.31 明明是Android手机，居然显示出来了windows的一些信息(Windonws和Windows NT)，这样的错误信息会大大影响程序的判断。 华为手机（huawei U9510e）的自带浏览器下，是这样显示的： HTTP_USER_AGENT:Mozilla/5.0 (Linux; U; Android 4.0.4; zh-cn; HUAWEI U9510E Build/HuaweiU9510E) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30 这个显示的就比较准确，android系统、华为手机。 由于User_Agent的不规范，程序不能正确的区分手机头，就不足为怪了。 强烈呼吁各大手机浏览器厂商联合起来，制定一套相关的手机HTTP头的标准，同时希望那些不太负责人的浏览器商好好审核下自己的产品后再发布，这样不光是对用户负责，也是对自己负责。","title":"手机浏览器User_Agent乱象"},{"content":"Android音频曲线调用从ui界面往下设置，根据stream音频有不同的UI，分为7步，15步，对应到实际的100步。这个转换过程可以参考AudioPolicyManagerBase.cpp中的volIndexToAmpl函数。   4.1上调用流程与之前的有所不同，原理还是一样的。之前的版本我看是直线型的，新的是3段折线的。为什么是直线，人耳对声音大小的感知程度并不是线性的，而是呈对数关系。这个可以和android原理对应起来  以10为底的对数。 下面是分贝公式的推导过程     音频当中db用加减表示调整音量大小。 目前采用3段折线，我觉得可以更方便的调整声音在不同区域的变化大小。最低声音和最高声音应该需要从更底层驱动来调整。 volIndexToAmpl这个函数实现了上面的转换关系。 该函数是通过响应音量键效益开始执行下面调用过程，完成音量大小调节的。 下面是音量键按下后的调用过程 Audiomanager.java handleKeyDown          adjustSuggestStreamVolume                     service. adjustSuggestStreamVolume AudioService.java adjustSuggestStreamVolume          adjustStreamVolum          sendMSG(mAudioHandler,MSG_SET_DEVICE_VOLUME,SND_QUEUE,device,0,streamstate,0); 消息机制 AudioService.java AudioHandler handleMessage          setDeviceVolume                    StreamState.applyDeviceVolume                             audioSystem.setStreamVolumeIndex JNI机制 Android_media_AudioSystem.cpp AudioPolicyManagerBase.cpp setStreamVolumeIndex          checkAndSetVolume                    computeVolume                             volIndexToAmpl   4.0之前版本可以参考 http://blog.csdn.net/droidphone/article/details/7477350","title":"android音量控制曲线和调用过程"},{"content":"\\frameworks\\base\\core\\res\\res\\layout\\preference_widget_seekbar.xml    <RelativeLayout         android:layout_width=\"match_parent\"         android:layout_height=\"wrap_content\"         android:layout_marginLeft=\"16dip\"         android:layout_marginRight=\"8dip\"         android:layout_marginTop=\"6dip\"         android:layout_marginBottom=\"6dip\"         android:layout_weight=\"1\">         <TextView android:id=\"@+android:id/title\"             android:layout_width=\"match_parent\"             android:layout_height=\"wrap_content\"             android:singleLine=\"true\"             android:textAppearance=\"?android:attr/textAppearanceMedium\"             android:ellipsize=\"marquee\"             android:fadingEdge=\"horizontal\" />           <!-- Preference should place its actual preference widget here. -->         <LinearLayout android:id=\"@+android:id/widget_frame\"             android:layout_width=\"wrap_content\"             android:layout_height=\"match_parent\"             android:layout_below=\"@android:id/summary\"             android:layout_alignRight=\"@android:id/title\"             android:minWidth=\"@dimen/preference_widget_width\"             android:gravity=\"right\"             android:orientation=\"vertical\" />         <SeekBar android:id=\"@+android:id/seekbar\"             android:layout_width=\"match_parent\"             android:layout_height=\"wrap_content\"             android:layout_below=\"@android:id/summary\"             android:layout_toLeftOf=\"@android:id/widget_frame\"             android:layout_alignParentRight=\"false\" />  ","title":"阿语波斯语问题二（Browser中的seekbar和百分比的位置调换）"},{"content":"在开发中需要用到引导页， 用的Google ViewPager类, 采用的方式是在将图片设置于layout，最后加载所有的layout，但是由于加载的较多，由于加载的时候一不小心就报了OutofMemoryError。 layout： <?xml version=\"1.0\" encoding=\"utf-8\"?><LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    android:layout_width=\"fill_parent\"    android:layout_height=\"fill_parent\"    android:orientation=\"vertical\"    android:background=\"@drawable/page01\"      ><\/LinearLayout>   最后优化一下，通过在instantiateItem中逐步加载layout的方式解决了该问题， 因为ViewPager自身有机制，回调destroyItem回收View资源。 PagerAdapter：   @Override\t\t\tpublic void destroyItem(ViewGroup container, int position,\t\t\t\t\tObject object) {\t\t\t\t// TODO Auto-generated method stub\t\t\t\tcontainer.removeView((View)object);\t\t\t}\t\t\t@Override\t\t\tpublic Object instantiateItem(ViewGroup container, int position) {\t\t\t\t// TODO Auto-generated method stub\t\t\t\tLayoutInflater mLayoutInflater = getLayoutInflater();\t\t\t\tint resId=0;\t\t\t\tswitch (position) {\t\t\t\tcase 0:\t\t\t\t\tresId = R.layout.page01;\t\t\t\t\tbreak;\t\t\t\tcase 1:\t\t\t\t\tresId = R.layout.page02;\t\t\t\t\tbreak;\t\t\t\tcase 2:\t\t\t\t\tresId = R.layout.page03;\t\t\t\tbreak;\t\t\t\tcase 3:\t\t\t\t\tresId = R.layout.page04;\t\t\t\tbreak;\t\t\t\tcase 4:\t\t\t\t\tresId = R.layout.page05;\t\t\t\tbreak;\t\t\t\tcase 5:\t\t\t\t\tresId = R.layout.page06;\t\t\t\tbreak;\t\t\t\tcase 6:\t\t\t\t\tresId = R.layout.page07;\t\t\t\tbreak;\t\t\t\tdefault:\t\t\t\t\tbreak;\t\t\t\t}\t\t\t\tView view = mLayoutInflater.inflate(resId, null);\t\t\t\tcontainer.addView(view, 0);\t\t\t\treturn view;\t\t\t}\t\t};","title":"引导页使用ViewPager遇到OutofMemoryError的解决方案"},{"content":"Android4.0之后，Android内置了一个搜索控件，配合ActionBar上面的搜索按钮，相当不错好看，这次使用了下，觉得很不错。 这个搜索的好处在于你点击后，他会自动弹出个搜索框，输入内容后会自动弹出匹配的内容，形成一个列表，选择后会弹到你想要去的界面。 类似这样的 你需要在代码中的onCreateOptionsMenu中加入    SearchManager searchManager = (SearchManager) getSystemService(Context.SEARCH_SERVICE);         SearchView searchView = (SearchView) menu.findItem(R.id.search).getActionView();         searchView.setSearchableInfo(searchManager.getSearchableInfo(getComponentName()));         searchView.setIconifiedByDefault(false); 然后在onOptionsItemSelected中加入  case R.id.search:                 onSearchRequested();                 return true; 这样才会执行搜索功能。 从开始看代码  handleIntent(getIntent());这个方法在onCreate中就执行了 并且在     @Override     protected void onNewIntent(Intent intent) {         handleIntent(intent);     } 也执行了，说明这个方法比算较重要，其实这个是一个搜索按钮用的因为在android4.0以上系统 输入法里有个“搜索”按钮或者是“前往”按钮 这样的搜索按钮，这个 handleIntent(getIntent())主要就是执行的这个搜索 看里面的代码：     private void handleIntent(Intent intent) {     //Intent.ACTION_VIEW  android:searchSuggestIntentAction=\"android.intent.action.VIEW\"  还在这个view中         if (Intent.ACTION_VIEW.equals(intent.getAction())) {             // handles a click on a search suggestion; launches activity to show word             Intent wordIntent = new Intent(this, WordActivity.class);             wordIntent.setData(intent.getData());             startActivity(wordIntent);             finish();                      } else if (Intent.ACTION_SEARCH.equals(intent.getAction())) {             // handles a search query  Intent.ACTION_SEARCH这个Intent是在当我点击系统的搜索框右面的按钮时触发的             String query = intent.getStringExtra(SearchManager.QUERY);             showResults(query);         }     } 上面就是handleIntent里面的代码   handleIntent里的代码有两个意思  一个就是当Intent是Intent.ACTION_VIEW.这个的时候跳到你指定的类中必然WordActivity，其实这个ntent.ACTION_VIEW就是你在搜索出建议后点击建议里面的列表进入的界面，比如你点击这个就执行的是这个intent，执行这个intent，会返回一个URI，可以使用intent.getData()这个方法得到这个返回的URI，这个URI是系统自己返回的。可以看配置文件searchable.xml这个文件，这个文件的代码如下： <searchable xmlns:android=\"http://schemas.android.com/apk/res/android\"         android:label=\"@string/search_label\"         android:hint=\"@string/search_hint\"         android:searchSettingsDescription=\"@string/settings_description\"         android:searchSuggestAuthority=\"com.example.android.searchabledict.DictionaryProvider\"         android:searchSuggestIntentAction=\"android.intent.action.VIEW\"         android:searchSuggestIntentData=\"content://com.example.android.searchabledict.DictionaryProvider/dictionary/sugger_que54r\"         android:searchSuggestSelection=\" ?\"         android:searchSuggestThreshold=\"1\"         android:includeInGlobalSearch=\"true\"         >  <\/searchable> 就是一个XML文件，里面配置的是android:searchSuggestAuthority这个是在AndroidManifest.xml里面配置的provider，比如         <provider android:name=\".DictionaryProvider\"                   android:authorities=\"com.example.android.searchabledict.DictionaryProvider\" /> 里面的android:searchSuggestIntentData配置的就是你要返回的intentData，比如这里面配的是content://com.example.android.searchabledict.DictionaryProvider/dictionary/sugger_que54r到时候你在  if (Intent.ACTION_VIEW.equals(intent.getAction())) {             // handles a click on a search suggestion; launches activity to show word             Intent wordIntent = new Intent(this, WordActivity.class);             wordIntent.setData(intent.getData());             startActivity(wordIntent);             finish();                      } 这个里面的intent.getData()就会是content://com.example.android.searchabledict.DictionaryProvider/dictionary/sugger_que54r/(你点击的那个Item的ID)也就是一个带ID的URI，至于这里的ID，是你在代码里赋值给他的 ，这个后面说。 当如果是你点击右下角的搜索按钮的时候执行的是ACTION_SEARCH这个intent，会执行showResults这个方法。    private void showResults(String query) {         Cursor cursor = managedQuery(DictionaryProvider.CONTENT_URI, null, selection,                                   new String[]{query}, null);         if (cursor == null) {             // There are no results             mTextView.setText(getString(R.string.no_results, new Object[] {query}));         } else {             // Display the number of results             int count = cursor.getCount();             String countString = getResources().getQuantityString(R.plurals.search_results,                                     count, new Object[] {count, query});             mTextView.setText(countString);             // Specify the columns we want to display in the result             String[] from = new String[] { DictionaryDatabase.KEY_WORD,                                            DictionaryDatabase.KEY_DEFINITION };             // Specify the corresponding layout elements where we want the columns to go             int[] to = new int[] { R.id.word,                                    R.id.definition };             // Create a simple cursor adapter for the definitions and apply them to the ListView             SimpleCursorAdapter words = new SimpleCursorAdapter(this,                                           R.layout.result, cursor, from, to);             mListView.setAdapter(words);             // Define the on-click listener for the list items             mListView.setOnItemClickListener(new OnItemClickListener() {                 public void onItemClick(AdapterView<?> parent, View view, int position, long id) {                     // Build the Intent used to open WordActivity with a specific word Uri                     Intent wordIntent = new Intent(getApplicationContext(), WordActivity.class);                     Uri data = Uri.withAppendedPath(DictionaryProvider.CONTENT_URI,                                                     String.valueOf(id));                     wordIntent.setData(data);                     startActivity(wordIntent);                 }             });         }     } 以上是showResult这个方法里穿进去的query这个字符串就是你搜索时候输入的字符串。managedQuery就是你自己想怎么搜索自己定义的搜索语句，然后搜索出结果。 接下来解释下 String countString = getResources().getQuantityString(R.plurals.search_results,                                     count, new Object[] {count, query}); 这段代码。这段代码只要是plurals，plurals是一个复数，是在String.xml文件中配置的，配置文件如下： <plurals name=\"search_results\">       <item quantity=\"one\">%1$d result for \\\"%2$s\\\": <\/item>       <item quantity=\"other\">%1$d results for \\\"%2$s\\\": <\/item>     <\/plurals> plurals的负数的意思是，如果要是查出的结果是一个也就是quantity=\"one\"，则提示%1$d result for \\\"%2$s\\\"这里的%1$d和 \\\"%2$s\\\"都是类似占位符，取的是前面new Object[] {count, query}传进来的值，这里主要是区分一个和多个，不如一个时候提示你搜索的结果是1个，多个的时候提示你搜索的结果有多个，可能英语中result和results这种复数的不同导致他们这样设计，你也可以设置   <item quantity=\"two\">这种根据自己的定义提示。 接下来就进入一个列表，然后点击列表中的数据，会执行你自己定义的方法，需要提示的是item的ID是你传值进去的 我们来看provider中，provider中buildUriMatcher这个方法主要是根据你的URI匹配来进行的，比如 matcher.addURI(AUTHORITY, SearchManager.SUGGEST_URI_PATH_QUERY, SEARCH_SUGGEST);就会返回一个SEARCH_SUGGEST这样的int值， 这个方法主要是在query这个方法中做判断： 如下： switch (sURIMatcher.match(uri)) {             case SEARCH_SUGGEST:                 if (selectionArgs == null) {                   throw new IllegalArgumentException(                       \"selectionArgs must be provided for the Uri: \" + uri);                 }                 return getSuggestions(selectionArgs[0]);             case SEARCH_WORDS:                 if (selectionArgs == null) {                   throw new IllegalArgumentException(                       \"selectionArgs must be provided for the Uri: \" + uri);                 }                 return search(selectionArgs[0]); 这样就会执行你的方法，这些方法，都是你输入关键字时候系统自动搜索的，你需要把你的自动赋值给系统定义好的字段，查询语句类似如下:  String[] columns = new String[] {   BaseColumns._ID,     BaseColumns._ID+\" AS \"+SearchManager.SUGGEST_COLUMN_INTENT_DATA_ID,     CorpInfoColumns.NAME+\" AS \"+SearchManager.SUGGEST_COLUMN_TEXT_1,     CorpInfoColumns.LEGAL_PERSON+\" AS \"+SearchManager.SUGGEST_COLUMN_TEXT_2            };    SQLiteDatabase db = mOpenHelper.getReadableDatabase();        String selection =  CorpInfoColumns.NAME + \" like ? OR \"+CorpInfoColumns.LEGAL_PERSON+ \" like ? \";        String[] selectionArgs = new String[] {\"%\"+query+\"%\",\"%\"+query+\"%\"};、 你需要把你自己的_id的行名必须为给SearchManager.SUGGEST_COLUMN_INTENT_DATA_ID，这样前面才会返回一个带ID的URI，把你搜索的第一行命名给SearchManager.SUGGEST_COLUMN_TEXT_1，第二行的行名必须为SearchManager.SUGGEST_COLUMN_TEXT_2，这样系统才会自动显示。否则会显示一片白色。 这个adapter其实应该可以自己定义的，只不过我没有定义过，有兴趣的可以试试。 欢迎程序员加群  169146045  扯淡 聊天  讨论技术","title":"Android中的Searchview以及SearchableDictionary项目和plurals详解"},{"content":"       2012年，是我在移动行业畅游的一年，这一年发生了很多事，人生三大事之一结婚，评选csdn专家荣誉称号，坚持写博客写了一年，对手机这个行业总算有了个大体的认识。但是还有一些不顺人意的事，这里就不说了。但有一件事不得不说，在这家公司上班以来，从来没迟到过，一年一次都没有。这个也是我比较骄傲的事！不过公司也没什么奖励。         2012的经历从工作，生活，学习三方面来说说取得了哪些进步？          先说说工作吧！这一年没有跳槽，继续在这家公司呆着了，因为我觉得我还有在公司呆的意义，因为android源码研究的还不是得心应手，和同事关系处得还行，所以就想坚持一年，看看这一年我能学到什么，毕竟刚毕业1年多，不能像去年那样心浮气躁了，要沉静下来学点东西。上半年： 先做了2个月的Browser模块，解决bug和做新功能。后来有了需求做Launcher的新功能，给韩国棒子做的手机。做了2,3个月，需求文档，功能评估我都参加了，了解了整个软件开发的过程，这个是很重要的。又做了一个锁屏界面，韩国棒子要求锁屏要炫一些。下半年：请了1个月的假（婚假+倒休+年假）9月份休息了一个月，快乐的时光总是很短暂的。10月份来了，换了Settings模块了，研究了pin，puk的流程，做了Settings的一些新需求，没需求的时候解决bug。11月份又来了一个中国电信的Launcher的开发需求，做了1个月，到12月份又让研究rom，ota升级。整体来说对android系统有了一个从微观到宏观，从宏观到微观的认识。遇到问题，不慌不忙，有条理地去分析问题，解决问题。基本都能按时完成任务，当然也包含加班。 在这一年中，我发现程序员有两个能力是很重要的，沟通能力和理解能力。能迅速地理解老大给你的任务或有疑难问题能理解自己在哪方面有疑惑，通过表达能力和别人沟通，这样别人听明白你的问题就能和你进行交流，帮助你解决问题。 另外平时要注意和同事搞关系（类似拉山头），经常和team技术骨干人员一起吃饭，聊天，这样你的能力也在潜移默化的提高。不仅仅是代码能力，还有遇到问题的分析能力和解决问题的能力等等吧。              生活上：上半年过得有点累，经常加班，尤其是7,8月份，还好平时我注意锻炼身体，比如：跑步，打篮球等等，身体基本锻炼的还行，不怎么生病；平时自己做点饭菜，学习怎么做菜好吃，等等。有时和同学聚会，k歌娱乐一下。下半年，休息了一个月，身心得到了放松，回家结婚，见见老同学和亲戚。帮爸妈做一些活。十一的时候去我老婆家弄玉米，把我累坏了，还好是机器收割玉米，我只是负责卸车，就把我累得够呛。在我家从没干过农活，不过身心那叫一个爽啊，呼吸着新鲜空气，没有电脑的辐射，眼睛得到了百分百的放松。我还是很高兴的！下半年天变冷了，户外运动就少了，变成了户内，每天回家爬爬楼，我住12层，每天下午3点半在公司爬楼一圈，锻炼一下身体，放松一下再去工作。晚上回家做做俯卧撑，总之今年冬天没怎么生病，只是吃得太好上过几次火。偶尔和老婆吵吵架，不过过两天就和好了！生活就是柴米油盐酱醋茶。        学习上：上半年每天早到公司，关注一下csdn博客，在自己的笔记本上写写东西，养成一个好的习惯受益终身，遇到不好解决的问题我就拿本记下来，等解决了我也记下来，万一哪天又碰到了，没有记住就翻翻本子，来公司一年多了，我的笔记本都用了6个了，有空看的时候发现当时那么简单的问题都不会，也挺有意思的。说明我有进步，这是我证明我进步的一种方式。上半年参加了csdn的移动开发者大会，听了听技术大牛的一些讲座，上半年写博客写的多，下半年因为结婚，10月份回来工作安排新功能开发，所以就懒得写了，好在12月份又开始写了，有时候真觉得没什么写的！平时也看看技术大牛的博客，给自己充充电。比如老罗的android之旅。等等。加了一些大牛的QQ群。聊聊技术什么的。          2012是我成长飞快的一年，从一个技术小菜鸟到一个中级程序员，遇到问题会分析，能做新功能，能解决bug，不过相对于解决bug，我还是喜欢做新功能。解决bug的时候有spm催着，心理很是不爽。做新功能没人打扰，不用关注bug，能专心致志研究，这个感觉也是挺爽的，也可以这么想“公司花钱让你学习，参加培训”，学到的东西和技术并且都是你的了！所以我还是蛮喜欢开发新功能的。          2012年，我主要精力都关注技术了，对社会的了解还是有些少，明年争取多了解一下社会，另外在明年找一下自己的发展方向，是一直技术做下去，还是向管理发展。看看哪条路才是最适合我的。坚持自己的移动发展方向。有可能会换家公司。继续写博客，最少每月写一篇博客。这个对我是很有帮助的。能把别人讲明白了才能说明你彻底对这块知识了解了，坚持锻炼身体。看一本书《乔布斯》，深入学习一下Linux系统！                                                                                                            2012年12月31日于北京","title":"我的2012移动开发年度总结——革命的一年"},{"content":"http://forums.codelite.org/viewtopic.php?f=13&t=1966&p=8779#p8779 Under Windows, you should do the following: - Compile the 'Win Release Unicode' - Open a CMD shell from within codelite - this is important, as CMD shell opened from within codelite will be using the environment variable deinfed in codelite (to open a CMD shell from within codelite, you can right click on any of the open files tab and seelct 'Open Shell at file path') - Close codelite - Open a CMD console CODE: SELECT ALL cd \\Path\\to\\codelite\\src\\Runtime  update.bat NOTE: you might need to change the 'update.bat' script to fit your actual installation paths just need to change the following in the update.bat: REM set TARGET_DIR=%ProgramFiles(x86)% set TARGET_DIR=c:\\Program Files\\","title":"how to update codelite"},{"content":"    元旦休息，闲来无事，又暂无睡意，写点东西捣鼓捣鼓吧！学的东西多了，就怕忘记以前的知识，所以还是记下来比较好。正所谓，好记性不如烂笔头！目前做的一个项目是移植android4.2，所以刚好可以把移植的经验跟大家分享分享，共同进步。尽管界面还没启动起来，但相信到那一天应该不远了。     标题自称为跨平台移植，那么究竟怎样跨平台了呢？出于公司利益的考虑，这里只透露一点点吧！我们现在所用的cpu（面向嵌入式）是公司自主研发的，市场上暂时还没有，其指令架构不同于市场上任何的cpu架构，例如arm、mips等。由于google谷歌官方不支持我们的cpu架构，而我们又想跑android系统，所以就需要把它移植到我们的平台上。架构不同，必然要使用不同的编译器，公司也自己开发了一个编译器，本人觉得开发编译器的这位老大好牛x的说，他还是美国斯坦福大学现任校长的得意门生。算了，题外话还是不多说了！我们继续！     android使用的kernel也是linux，所以在移植android之前，必须先把linux kernel移植好，这部份工作由kernel团队的成员完成，我很少参与，这里大概说个情况吧。首先就是要选择kernel的版本，在google官方，JellyBean（android 4.x版本的代号）搭配的kernel是3.0.x版本的，所以android4.2至少应该选择一个3.0或以上的kernel。我们选择的是3.4，为何要选择如此高版本的kernel？因为android与kernel的版本更新太快了，我们不想google官方出一个新版本，我们就要重新移植一次kernel，所以就选择版本比较高的kernel，用来兼容未来的android版本。版本定下来后，还要考虑用哪里的linux源代码，因为目前支持android的kernel有多种多样，这些都是被各大芯片厂商或者手机厂商修改过的，所以要选择最合适自己架构的kernel。kernel源码下载下来后，把里面架构相关的代码修改成自己平台的代码，其实主要是汇编级的代码。修改完毕后，做一个根文件系统，让kernel能启动到shell。最后就是开发各种驱动，不断地支持android的移植工作。     对于android这边的工作，首先下载4.2的源码，用git管理，源码里面有多个分支，我们一般不会跟着master分支走，因为master分支每天都有更新，所以很难维护。一般checkout到某个分支上，例如android-4.2_r1。android4.2里面支持3种架构：arm、mips、x86，它们的代码都混杂在一起，编译系统是如何区分它们的？是通过android自己的Makefile区分的，在一些目录下面的Android.mk文件中，可以看到里面有语句判断是哪个架构的；还有，在一些头文件（xx.h）里面也能看到#ifdef或者#ifndef等，这些架构信息都是在编译时通过读取环境变量得到的，编译系统会根据不同的环境变量来编译需要的代码。所以，我们需要修改android的编译脚本，把自己的架构添加进去，具体修改的地方有build/和device/目录下的编译脚本等。修改后的效果是，在编译前，执行source build/envsetup.sh，然后lunch，能看到自己的平台，这是最基本的一步。跟着，我们要了解有哪些模块涉及到架构相关的代码。经过一番摸索，终于知道了有哪些模块跟架构相关，这里给各位看官列出来： 1、bionic：仿生库，其实这个不用说大家也知道，bionic提供libc、libstdc++等函数库以及一些系统调用，里面很多头文件都由kernel导过来，所以必然有架构相关代码。要想android能够跑起来，bionic一定要移植成功。其实bionic的移植工作非常困难，公司是由一个有多年工具链开发经验的同事做的。 2、llvm：一个编译器的后端，前端是clang。涉及编译器相关知识，不太了解，clang是apple公司开发的一款编译器，貌似性能要比gcc好。 3、v8：JavaScript引擎，在浏览器中用到，分为解析执行和编译执行，解析执行时会产生汇编代码，所以要修改汇编代码生成器。 4、libbcc：RenderScript需要依赖于libbcc和llvm。 5、RenderScript：由于2和4的原因，所以RenderScript也涉及架构相关的代码。RenderScript是一个3D的画图库，功能类似于openGL，虽然没有openGL强大，但是其开发流程比较简单，而且拥有高性能的3D渲染效果。主要用在动态壁纸的实现等。 6、dalvik：android的java虚拟机，这家伙也是一大块啊，涉及很多编译原理。 可能还有些跟架构相关的模块没列出来，本人目前只记得这些了，欢迎补充！android的启动不需要依赖于上面所有的模块，所以我们的计划是先把必须的模块移植好，先让系统起来。在上面的模块中，我们只需要移植好bionic和dalvik就能把系统运行起来。     必要的架构相关的模块移植好后，下一步要做的是编译一个android的最小系统，并把镜像做出来。编译的话，只能编到哪里出错就解决哪里的问题了。如果人手足够的话，可以把最小系统的模块分工好，让其他人员一个模块一个模块地扫过去，把不能编译的都修复好。修复的内容主要是，缺少架构的定义，缺少头文件，缺少某些变量和宏的定义等。这些一般都是修改一些xx.mk文件添加架构支持，或者在bionic中导入所需要的头文件，定义变量、宏等。这样分工，能加快进展速度。     最小系统编译完成后，就要做image，烧到SD卡或者nanflash中启动，什么样的根文件系统格式配什么样的镜像，大家要弄清楚。     启动的第一步当然是启动init进程，接着是把必要的服务运行起来，直到shell能用。这时，就能调试servicemanager和surfaceflinger等服务了，幸运的话，一般起来都不会有太大的问题。surfaceflinger可以用bootanimation验证它的功能，如果看到android的文字logo，就证明surfaceflinger能工作。如果shell都不能启动的话，可以跑一下在android源码中system/extra/tests下面的测试程序，主要是测试kernel是否为启动android作了足够的准备。在jni层的服务都能启动后，接下来就是调试zygote了，zygote里面开始进入java世界，调试zygote是最难的一关，总会遇到各种segmentfault，很恐怖的说。。。。。     目前的进展只到这里，等到系统的界面出来后再跟大家接着分享吧！！","title":"Android跨平台移植经验之谈"},{"content":"在jquerymobile中我们可以将多个页面写到同一个html中，只要我们按照jquerymobile的要求加上对应的属性，jquerymobile会为我们将他们转变成几个分开的页面，每次显示的时候默认只会显示第一个。下面先看代码然后再解释： <!doctype html><html><head><meta charset=\"utf-8\"><title>data-role=\"page\"<\/title><meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" /> <link rel=\"stylesheet\" href=\"jqm/jquery.mobile-1.2.0.min.css\"/><script src=\"jqm/jquery-1.8.2.min.js\"><\/script><script src=\"jqm/jquery.mobile-1.2.0.min.js\"><\/script><\/head><body><div data-role=\"page\" id=\"home\">\t<div data-role=\"header\">    \t<h1>header<\/h1>    <\/div>    <div data-role=\"content\" id=\"homecontent\">    \tthis is home content!!        <a href=\"#ohter\">Other page<\/a><a href=\"helloJQM.html\" data-ajax=\"false\">helloJQM.html<\/a>    <\/div>    <div data-role=\"footer\" id=\"footer\">    \t<h4> Footer<\/h4>    <\/div><\/div><div data-role=\"page\" id=\"ohter\">\t<div data-role=\"header\" id=\"other_header\">    \t<h1>other_header<\/h1>    <\/div>    <div data-role=\"content\" id=\"other_content\">    \tthis is other content!!        <a href=\"#home\">Home page<\/a>    <\/div>    <div data-role=\"footer\" id=\"other_footer\">    \t<h4>Other footer<\/h4>    <\/div><\/div><\/body><\/html> 在上面代码中我们总共包含了两个页面，分别使用data-role来表示。在jquerymobile中使用data-role=“page”将会创建一个页面，一般会给它一个id值，在这些页面切换的时候会用到这个id值。 在jquerymobile中使用“data-”开头的属性去指定一些jquerymobile中特有的东西，我们使用的data-role只是其中的一个。这里我们使用的是data-role=“page”，jquerymobile将把它处理成为一个页面。 我们可以使用a标签，然后href使用paga的id就可以切换到其他的页面。这里有一个属性data-ajax，默认为true，表示我们是否使用ajax来加载新的网页，在jquerymobile中默认使用的是ajax方式去加载页面，如果将这个属性设置为false，将不会使用ajax方式加载，直接就是进入这个网页。可能大家感觉没什么不同，但是如果我们将这个属性设置为false后，在helloJQM.html(上一篇文章中的代码)将开始的对jquerymobile的引用去掉，显示的页面将不会被jquerymobile处理，如果设置成为true，则会进行处理。这里的原因就是加载方式，使用ajax加载jquerymobile还起作用，如果使用普通跳转，新跳转的网页中没有jquerymobile文件，将不会起作用。 我也是刚学jquerymobile，所以可能有些地方错误，还请指出。","title":"jquerymobile-2 多个页面一个文件"},{"content":"        在前面一篇文章中，我们分析了Android应用程序窗口的绘图表面的创建过程。Android应用程序窗口的绘图表面在创建完成之后，我们就可以从上到下地绘制它里面的各个视图了，即各个UI元素了。不过在绘制这些UI元素之前，我们还需要从上到下地测量它们实际所需要的大小，以及对它们的位置进行合适的安排，即对它们进行合适的布局。在本文中，我们就将详细地分析Android应用程序窗口的测量、布局以及绘制过程。         从前面Android应用程序与SurfaceFlinger服务的关系概述和学习计划这一系列的文章可以知道，Android应用程序窗口请求SurfaceFlinger服务创建了一个绘图表面之后，就可以接着请求为该绘图表面创建图形缓冲区，而当Android应用程序窗口往这些图形缓冲区填充好UI数据之后，就可以请求SurfaceFlinger服务将它们渲染到硬件帧缓冲区中去，这样我们就可以看到应用程序窗口的UI了。         Android应用程序窗口一般不会直接去操作分配给它的图形缓冲区，而是通过一些图形库API来操作。例如，在前面Android系统的开机画面显示过程分析一文中，使用C++来开发的开机动画应用程序bootanimation，它是通过OpenGL提供的API来绘制UI的。对于使用Java来开发的Android应用程序来说，它们一般是使用Skia图形库提供的API来绘制UI的。在Skia图库中，所有的UI都是绘制在画布（Canvas）上的，因此，Android应用程序窗口需要将它的图形缓冲区封装在一块画布里面，然后才可以使用Skia库提供的API来绘制UI。         我们知道，一个Android应用程序窗口里面包含了很多UI元素，这些UI元素是以树形结构来组织的，即它们存在着父子关系，其中，子UI元素位于父UI元素里面，因此，在绘制一个Android应用程序窗口的UI之前，我们首先要确定它里面的各个子UI元素在父UI元素里面的大小以及位置。确定各个子UI元素在父UI元素里面的大小以及位置的过程又称为测量过程和布局过程。因此，Android应用程序窗口的UI渲染过程可以分为测量、布局和绘制三个阶段，如图1所示： 图1 Android应用程序窗口渲染三步曲         从前面Android应用程序窗口（Activity）的视图对象（View）的创建过程分析一文可以知道，Android应用程序窗口的顶层视图是一个类型为DecorView的UI元素，而从前面Android应用程序窗口（Activity）的绘图表面（Surface）的创建过程分析一文的Step 3又可以知道，这个顶层视图最终是由ViewRoot类的成员函数performTraversals来启动测量、布局和绘制操作的，这三个操作分别由DecorView类的成员函数measure和layout以及ViewRoot类的成员函数draw来实现的。         接下来，我们就分别从DecorView类的成员函数measure和layout以及ViewRoot类的成员函数draw开始，分析Android应用程序窗口的测量、布局和绘制过程。         1. Android应用程序窗口的测量过程         DecorView类的成员函数measure是从父类View继承下来的，因此，我们就从View类的成员函数measure开始分析应用程序窗口的测量过程，如图2所示： 图2 Android应用程序窗口的测量过程         这个过程可以分为3个步骤，接下来我们就详细分析每一个步骤。         Step 1. View.measure public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource {    ......    int mPrivateFlags;    ......    int mOldWidthMeasureSpec = Integer.MIN_VALUE;    ......    int mOldHeightMeasureSpec = Integer.MIN_VALUE;    ......    public final void measure(int widthMeasureSpec, int heightMeasureSpec) {        if ((mPrivateFlags & FORCE_LAYOUT) == FORCE_LAYOUT ||                widthMeasureSpec != mOldWidthMeasureSpec ||                heightMeasureSpec != mOldHeightMeasureSpec) {            // first clears the measured dimension flag            mPrivateFlags &= ~MEASURED_DIMENSION_SET;            ......            // measure ourselves, this should set the measured dimension flag back            onMeasure(widthMeasureSpec, heightMeasureSpec);            // flag not set, setMeasuredDimension() was not invoked, we raise            // an exception to warn the developer            if ((mPrivateFlags & MEASURED_DIMENSION_SET) != MEASURED_DIMENSION_SET) {                throw new IllegalStateException(\"onMeasure() did not set the\"                        + \" measured dimension by calling\"                        + \" setMeasuredDimension()\");            }            mPrivateFlags |= LAYOUT_REQUIRED;        }        mOldWidthMeasureSpec = widthMeasureSpec;        mOldHeightMeasureSpec = heightMeasureSpec;    }    ......}        这个函数定义在文件frameworks/base/core/java/android/view/View.java中。         参数widthMeasureSpec和heightMeasureSpec用来描述当前正在处理的视图可以获得的最大宽度和高度。对于应用程序窗口的顶层视图来说，我们也可以认为这两个参数是用来描述应用程序窗口的宽度和高度。         ViewRoot类的成员变量mPrivateFlags的类型为int，如果它的某一个位的值不等于0，那么就隐含着当前视图有一个相应的操作在等待执行中。ViewRoot类的另外两个成员变量mOldWidthMeasureSpec和mOldHeightMeasureSpec用来保存当前视图上一次可以获得的最大宽度和高度。         当ViewRoot类的成员变量mPrivateFlags的FORCE_LAYOUT位不等于0时，就表示当前视图正在请求执行一次布局操作，这时候函数就需要重新测量当前视图的宽度和高度。此外，当参数widthMeasureSpec和heightMeasureSpec的值不等于ViewRoot类的成员变量mldWidthMeasureSpec和mOldHeightMeasureSpec的值时，就表示当前视图上一次可以获得的最大宽度和高度已经失效了，这时候函数也需要重新测量当前视图的宽度和高度。         当View类的成员函数measure决定要重新测量当前视图的宽度和高度之后，它就会首先将成员变量mPrivateFlags的MEASURED_DIMENSION_SET位设置为0，接着再调用另外一个成员函数onMeasure来真正执行测量宽度和高度的操作。View类的成员函数onMeasure执行完成之后，需要再调用另外一个成员函数setMeasuredDimension来将测量好的宽度和高度设置到View类的成员变量mMeasuredWidth和mMeasuredHeight中，并且将成员变量mPrivateFlags的EASURED_DIMENSION_SET位设置为1。这个操作是强制的，因为当前视图最终就是通过View类的成员变量mMeasuredWidth和mMeasuredHeight来获得它的宽度和高度的。为了保证这个操作是强制的，View类的成员函数measure再接下来就会检查成员变量mPrivateFlags的EASURED_DIMENSION_SET位是否被设置为1了。如果不是的话，那么就会抛出一个类型为IllegalStateException的异常来。         View类的成员函数measure最后就会把参数widthMeasureSpec和heightMeasureSpec的值保存在成员变量mldWidthMeasureSpec和mOldHeightMeasureSpec中，以便可以记录当前视图上一次可以获得的最大宽度和高度。         View类的成员函数onMeasure一般是由其子类来重写的。例如，对于用来应用程序窗口的顶层视图的DecorView类来说，它是通过父类FrameLayout来重写祖父类View的成员函数onMeasure的。因此，接下来我们就分析FrameLayout类的成员函数onMeasure的实现。         Step 2. rameLayout.onMeasure public class FrameLayout extends ViewGroup {    ......    @Override    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {        final int count = getChildCount();        int maxHeight = 0;        int maxWidth = 0;        // Find rightmost and bottommost child        for (int i = 0; i < count; i++) {            final View child = getChildAt(i);            if (mMeasureAllChildren || child.getVisibility() != GONE) {                measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);                maxWidth = Math.max(maxWidth, child.getMeasuredWidth());                maxHeight = Math.max(maxHeight, child.getMeasuredHeight());            }        }        // Account for padding too        maxWidth += mPaddingLeft + mPaddingRight + mForegroundPaddingLeft + mForegroundPaddingRight;        maxHeight += mPaddingTop + mPaddingBottom + mForegroundPaddingTop + mForegroundPaddingBottom;        // Check against our minimum height and width        maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());        maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());        // Check against our foreground's minimum height and width        final Drawable drawable = getForeground();        if (drawable != null) {            maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());            maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());        }        setMeasuredDimension(resolveSize(maxWidth, widthMeasureSpec),                resolveSize(maxHeight, heightMeasureSpec));    }    ......}        这个函数定义在文件frameworks/base/core/java/android/widget/FrameLayout.java中。         FrameLayout类是从ViewGroup类继承下来的，后者用来描述一个视图容器，它有一个类型为View的数组mChildren，里面保存的就是它的各个子视图。ViewGroup类所供了两个成员函数getChildCount和getChildAt，它们分别用来获得一个视图容器所包含的子视图的个数，以及获得每一个子视图。         FrameLayout类的成员函数onMeasure首先是调用另一个成员函数measureChildWithMargins来测量每一个子视图的宽度和高度，并且找到这些子视图的最大宽度和高度值，保存在变量maxWidth和maxHeight 中。         FrameLayout类的成员函数onMeasure接着再将前面得到的宽度maxWidth和高度maxHeight分别加上当前视图所设置的Padding值，其中，（mPaddingLeft，mPaddingRight，mPaddingTop，mPaddingBottom ）表示当前视图的内容区域的左右上下四条边分别到当前视图的左右上下四条边的距离，它们是父类View的四个成员变量，（mForegroundPaddingLeft，mForegroundPaddingRight，mForegroundPaddingTop，mForegroundPaddingBottom）表示当前视图的各个子视图所围成的区域的左右上下四条边到当前视视的前景区域的左右上下四条边的距离。从这里就可以看出，当前视图的内容区域的大小就等于前景区域的大小，而前景区域的大小大于等于各个子视图的所围成的区域，这是因为前景区域本来就是用来覆盖各个子视图所围成的区域的。        加上各个Padding值之后，得到的宽度maxWidth和高度maxHeight还不是最终的宽度和高度，还需要考虑以下两个因素：        1. 当前视图是否设置有最小宽度和高度。如果设置有的话，并且它们比前面计算得到的宽度maxWidth和高度maxHeight还要大，那么就将它们作为当前视图的宽度和高度值。        2. 当前视图是否设置有前景图。如果设置有的话，并且它们比前面计算得到的宽度maxWidth和高度maxHeight还要大，那么就将它们作为当前视图的宽度和高度值。        经过上述两步检查之后，FrameLayout类的成员函数onMeasure就得到了当前视图的宽度maxWidth和高度maxHeight。由于得到的宽度和高度又必须要限制在参数widthMeasureSpec和heightMeasureSpec所描述的宽度和高度规范之内，因此，FrameLayout类的成员函数onMeasure就会调用从View类继承下来的成员函数resolveSize来获得正确的大小。得到了当前视图的正确大小之后，FrameLayout类的成员函数onMeasure就可以调用从父类View继承下来的成员函数setMeasuredDimension来将它们为当前视图的大小了。        为了理解参数widthMeasureSpec和heightMeasureSpec的含义，我们继续分析View类的成员函数resolveSize的实现，如下所示： public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource {    ......    public static int resolveSize(int size, int measureSpec) {        int result = size;        int specMode = MeasureSpec.getMode(measureSpec);        int specSize =  MeasureSpec.getSize(measureSpec);        switch (specMode) {        case MeasureSpec.UNSPECIFIED:            result = size;            break;        case MeasureSpec.AT_MOST:            result = Math.min(size, specSize);            break;        case MeasureSpec.EXACTLY:            result = specSize;            break;        }        return result;    }    ......}        这个函数定义在文件rameworks/base/core/java/android/view/View.java中。         参数measureSpec的值其实是由两部分内容来组成的，最高2位表示一个测量规范，而低30位表示一个宽度值或者高度值。测量规范有三种，分别是0、1和2，使用常量MeasureSpec.UNSPECIFIED、MeasureSpec.EXACTLY和MeasureSpec.AT_MOST来表示。         当参数measureSpec描述的规范是MeasureSpec.UNSPECIFIED时，就表示当前视图没有指定它的大小测量模式，这时候就使用参数size的值；当参数measureSpec描述的规范是MeasureSpec.AT_MOST时，就表示当前视图的大小等于参数size和参数measureSpec所指定的值中的较小值；当参数measureSpec描述的规范是MeasureSpec.EXACTLY时，就表示当前视图的大小等于参数measureSpec中所指定的值。         回到FrameLayout类的成员函数onMeasure中，我们再来看一下View类的成员函数setMeasuredDimension是如何设置当前视图的大小的，如下所示： public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource {    ......    protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) {        mMeasuredWidth = measuredWidth;        mMeasuredHeight = measuredHeight;        mPrivateFlags |= MEASURED_DIMENSION_SET;    }    ......}       这个函数定义在文件rameworks/base/core/java/android/view/View.java中。        View类的成员函数setMeasuredDimension首先将参数measuredWidth和measuredHeight的值保存在成员变量mMeasuredWidth和mMeasuredHeight中，用来作为当前视图的宽度和高度，并且将成员变量mPrivateFlags的位MEASURED_DIMENSION_SET设置为1，这样返回到前面的Step 1时，就不会抛出一个类型为IllegalStateException的异常了。         FrameLayout类的另一个成员函数measureChildWithMargins是从父类ViewGroup继承下来的，接下来我们就继续分析它的实现，以便可以了解一个视图容器的各个子视图的大小的测量过程。         Step 3. ViewGroup.measureChildWithMargins public abstract class ViewGroup extends View implements ViewParent, ViewManager {    ......    protected void measureChildWithMargins(View child,            int parentWidthMeasureSpec, int widthUsed,            int parentHeightMeasureSpec, int heightUsed) {        final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin                        + widthUsed, lp.width);        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin                        + heightUsed, lp.height);        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);    }    ......}        这个函数定义在文件rameworks/base/core/java/android/view/ViewGroup.java中。         参数child用来描述当前要测量大小的子视图，参数parentWidthMeasureSpec和parentHeightMeasureSpec用来描述当前子视图可以获得的最大宽度和高度，参数widthUsed和heightUsed用来描述父窗口已经使用了的宽度和高度。ViewGroup类的成员函数measureChildWithMargins必须要综合考虑上述参数，以及当前正在测量的子视图child所设置的大小和Margin值，还有当前视图容器所设置的Padding值，来得到当前正在测量的子视图child的正确宽度childWidthMeasureSpec和高度childHeightMeasureSpec，这是通过调用ViewGroup类的另外一个成员函数getChildMeasureSpec来实现的。        得到了当前正在测量的子视图child的正确宽度childWidthMeasureSpec和高度childHeightMeasureSpec之后，就可以调用它的成员函数measure来设置它的大小了，即执行前面Step 1的操作。注意，如果当前正在测量的子视图child描述的也是一个视图容器，那么它又会重复执行Step 2和Step 3的操作，直到它的所有子孙视图的大小都测量完成为止。        至此，我们就分析完成Android应用程序窗口的测量过程了，接下来我们继续分析Android应用程序窗口的布局过程。        2. Android应用程序窗口的布局过程        DecorView类的成员函数layout是从父类View继承下来的，因此，我们就从View类的成员函数layout开始分析应用程序窗口的布局过程，如图3所示： 图3 Android应用程序窗口的布局过程          这个过程可以分为5个步骤，接下来我们就详细地分析每一个步骤。          Step 1. View.layout public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource {    ......     int mPrivateFlags;    ......    public final void layout(int l, int t, int r, int b) {        boolean changed = setFrame(l, t, r, b);        if (changed || (mPrivateFlags & LAYOUT_REQUIRED) == LAYOUT_REQUIRED) {            ......            onLayout(changed, l, t, r, b);            mPrivateFlags &= ~LAYOUT_REQUIRED;        }        mPrivateFlags &= ~FORCE_LAYOUT;    }    ......}         这个函数定义在文件frameworks/base/core/java/android/view/View.java中。         参数l、t、r和b分别用来描述当前视图的左上右下四条边与其父视图的左上右下四条边的距离，这样当前视图通过这四个参数就可以知道它在父视图中的位置以及大小。         View类的成员函数layout首先调用另外一个成员函数setFrame来设置当前视图的位置以及大小。设置完成之后，如果当前视图的大小或者位置与上次相比发生了变化，那么View类的成员函数setFrame的返回值changed就会等于true。在这种情况下， View类的成员函数layout就会继续调用另外一个成员函数onLayout重新布局当前视图的子视图。此外，如果此时View类的成员变量mPrivateFlags的LAYOUT_REQUIRED位不等于0，那么也表示当前视图需要重新布局它的子视图，因此，这时候View类的成员函数layout也会调用另外一个成员函数onLayout。         当前视图的子视图都重新布局完成之后，View类的成员函数layout就可以将成员变量mPrivateFlags的LAYOUT_REQUIRED位设置为0了，因为此时当前视图及其子视图都已经执行了一次布局操作了。         View类的成员函数layout最后还会将成员变量mPrivateFlags的FORCE_LAYOUT位设置为0，也是因为此时当前视图及其子视图的布局已经是最新的了。         接下来，我们就继续分析View类的成员函数setFrame和onLayout的实现，以便可以了解当前视图及其子视图是如何执行布局操作的。         Step 2. View.setFrame public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource {    ......     int mPrivateFlags;    ......    int mViewFlags;    ......    protected int mLeft;    ......    protected int mRight;    ......    protected int mTop;    ......    protected int mBottom;    ......    private boolean mBackgroundSizeChanged;    ......    protected boolean setFrame(int left, int top, int right, int bottom) {        boolean changed = false;        ......        if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) {            changed = true;            // Remember our drawn bit            int drawn = mPrivateFlags & DRAWN;            // Invalidate our old position            invalidate();            int oldWidth = mRight - mLeft;            int oldHeight = mBottom - mTop;            mLeft = left;            mTop = top;            mRight = right;            mBottom = bottom;            mPrivateFlags |= HAS_BOUNDS;            int newWidth = right - left;            int newHeight = bottom - top;            if (newWidth != oldWidth || newHeight != oldHeight) {                onSizeChanged(newWidth, newHeight, oldWidth, oldHeight);            }            if ((mViewFlags & VISIBILITY_MASK) == VISIBLE) {                // If we are visible, force the DRAWN bit to on so that                // this invalidate will go through (at least to our parent).                // This is because someone may have invalidated this view                // before this call to setFrame came in, therby clearing                // the DRAWN bit.                mPrivateFlags |= DRAWN;                invalidate();            }            // Reset drawn bit to original value (invalidate turns it off)            mPrivateFlags |= drawn;            mBackgroundSizeChanged = true;        }        return changed;    }    ......}        这个函数定义在文件frameworks/base/core/java/android/view/View.java中。        View类的成员变量mLeft、mRight、mTop和mBottom分别用来描述当前视图的左右上下四条边与其父视图的左右上下四条边的距离，如果它们的值与参数left、right、top和bottom的值不相等，那么就说明当前视图的大小或者位置发生变化了。这时候View类的成员函数setFrame就需要将参数left、right、top和bottom的值分别记录在成员变量mLeft、mRight、mTop和mBottom中。在记录之前，还会执行两个操作：        1. 将成员变量mPrivateFlags的DRAWN位记录在变量drawn中，并且调用另外一个成员函数invalidate来检查当前视图上次请求的UI绘制操作是否已经执行。如果已经执行了的话，那么就会再请求执行一个UI绘制操作，以便可以在修改当前视图的大小和位置之前，将当前视图在当前位置按照当前大小显示一次。在接下来的Step 3中，我们再详细分析View类的成员函数invalidate的实现。        2. 计算当前视图上一次的宽度oldWidth和oldHeight，以便接下来可以检查当前视图的大小是否发生了变化。        当前视图距离父视图的边距一旦设置好之后，它就是一个具有边界的视图了，因此，View类的成员函数setFrame接着还会将成员变量mPrivateFlags的HAS_BOUNDS设置为1。        View类的成员函数setFrame再接下来又会计算当前视图新的宽度newWidth和高度newHeight，如果它们与上一次的宽度oldWidth和oldHeight的值不相等，那么就说明当前视图的大小发生了变化，这时候就会调用另外一个成员函数onSizeChanged来让子类有机会处理这个变化事件。        View类的成员函数setFrame接下来继续判断当前视图是否是可见的，即成员变量mViewFlags的VISIBILITY_MASK位的值是否等于VISIBLE。如果是可见的话，那么就需要将成员变量mPrivateFlags的DRAWN位设置为1，以便接下来可以调用另外一个成员函数invalidate来成功地执行一次UI绘制操作，目的是为了将当前视图马上显示出来。        View类的成员变量mPrivateFlags的DRAWN位描述的是当前视图上一次请求的UI绘制操作是否已经执行过了。如果它的值等于1，就表示已经执行过了，否则的话，就表示还没在等待执行。前面第一次调用View类的成员函数invalidate来检查当前视图上次请求的UI绘制操作是否已经执行时，如果发现已经执行了，那么就会重新请求执行一次新的UI绘制操作，这时候会导致当前视图的成员变量mPrivateFlags的DRAWN位重置为0。注意，新请求执行的UI绘制只是为了在修改当前视图的大小以及大小之前，先将它在上一次设置的大小以及位置中绘制出来，这样就可以使得当前视图的大小以及位置出现平滑的变换。换句话说，新请求执行的UI绘制只是为了获得一个中间效果，它不应该影响当前视图的绘制状态，即不可以修改当前视图的成员变量mPrivateFlags的DRAWN位。因此，我们就需要在前面第一次调用View类的成员函数invalidate前，先将当前视图的成员变量mPrivateFlags的DRAWN位保存下来，即保存在变量drawn中，然后等到调用之后，再将变量drawn的值恢复到当前视图的成员变量mPrivateFlags的DRAWN位中去。         另一方面，如果当前视图的大小和位置发生了变化，View类的成员函数setFrame还会将成员变量mBackgroundSizeChanged的值设置为true，以便可以表示当前视图的背景大小发生了变化。         最后，View类的成员函数setFrame将变量changed的值返回给调用者，以便调用者可以知道当前视图的大小和位置是否发生了变化。         接下来，我们继续分析View类的成员函数invalidate的实现，以便可以了解当前视图是如何执行一次UI绘制操作的。         Step 3. View.invalidate public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource {    ......    protected ViewParent mParent;    ......     int mPrivateFlags;    ......        public void invalidate() {        ......        if ((mPrivateFlags & (DRAWN | HAS_BOUNDS)) == (DRAWN | HAS_BOUNDS)) {            mPrivateFlags &= ~DRAWN & ~DRAWING_CACHE_VALID;            final ViewParent p = mParent;            final AttachInfo ai = mAttachInfo;            if (p != null && ai != null) {                final Rect r = ai.mTmpInvalRect;                r.set(0, 0, mRight - mLeft, mBottom - mTop);                // Don't call invalidate -- we don't want to internally scroll                // our own bounds                p.invalidateChild(this, r);            }        }    }    ......}       这个函数定义在文件frameworks/base/core/java/android/view/View.java中。        View类的成员函数invalidate首先检查成员变量mPrivateFlags的DRAWN位和HAS_BOUNDS位是否都被设置为1。如果是的话，那么就说明当前视图上一次请求执行的UI绘制操作已经执行完成了，这时候View类的成员函数invalidate才可以请求执行新的UI绘制操作。         View类的成员函数invalidate在请求新的UI绘制操作之前，会将成员变量mPrivateFlags的DRAWN位和DRAWING_CACHE_VALID位重置为0，其中，后者表示当前视图正在缓存的一些绘图对象已经失效了，这是因为接下来就要重新开始绘制当前视图的UI了。         请求绘制当前视图的UI是通过调用View类的成员变量mParent所描述的一个ViewParent接口的成员函数invalidateChild来实现的。前面我们假设当前视图是应用程序窗口的顶层视图，即它是一个类型为DecoreView的视图，它的成员变量mParent指向的是与其所关联的一个ViewRoot对象。因此，绘制当前视图的UI的操作实际上是通过调用ViewRoot类的成员函数invalidateChild来实现的。        注意，在调用ViewRoot类的成员函数invalidateChild的成员函数invalidateChild来绘制当前视图的UI之前，会将当前视图即将要绘制的区域记录在View类的成员变量mAttachInfo所描述的一个AttachInfo对象的成员变量mTmpInvalRect中。        接下来，我们就继续分析ViewRoot类的成员函数invalidateChild的实现。        Step 4. ViewRoot.invalidateChild public final class ViewRoot extends Handler implements ViewParent,        View.AttachInfo.Callbacks {    ......    public void invalidateChild(View child, Rect dirty) {        checkThread();        ......        if (mCurScrollY != 0 || mTranslator != null) {            mTempRect.set(dirty);            dirty = mTempRect;            if (mCurScrollY != 0) {               dirty.offset(0, -mCurScrollY);            }            if (mTranslator != null) {                mTranslator.translateRectInAppWindowToScreen(dirty);            }            if (mAttachInfo.mScalingRequired) {                dirty.inset(-1, -1);            }        }        mDirty.union(dirty);        if (!mWillDrawSoon) {            scheduleTraversals();        }    }    ......}        这个函数定义在文件frameworks/base/core/java/android/view/ViewRoot.java中。         ViewRoot类的成员函数invalidateChild首先调用另外一个成员函数checkThread来检查当前正在执行的是否是一个UI线程。如果不是的话，ViewRoot类的成员函数checkThread就会抛出一个异常出来。这是因为所有的UI操作都必须要在UI线程中执行。         ViewRoot类的成员函数invalidateChild接下来还会检查当前正在处理的应用程序窗口在Y轴上是否出现有滚动条，即成员变量mCurScrollY的值不等于0， 或者前正在处理的应用程序窗口是否运行在兼容模式之下，即成员变量mTranslator的值不等于null。当一个应用程序窗口运行在兼容模式时，它显示出来的大小和它实际被设置的大小是不一样的，要经过相应的转换处理。对于上述这两种情况，ViewRoot类的成员函数invalidateChild都需要调整参数dirty所描述的一个需要重新绘制的区域的大小和位置。         调整好参数dirty所描述的一个需要重新绘制的区域之后， ViewRoot类的成员函数invalidateChild就将它所描述的一个区域与成员变量mDirty所描述的一区域执行一个合并操作，并且将得到的新区域保存在成员变量mDirty中。从这个操作就可以看出，ViewRoot类的成员变量mDirty描述的就是当前正在处理的应用程序窗口下一次所要重新绘制的总区域。         设置好当前正在处理的应用程序窗口下一次所要重新绘制的总区域之后，ViewRoot类的成员函数invalidateChild最后就检查成员变量mWillDrawSoon的值是否不等于true。如果ViewRoot类的成员mWillDrawSoon的值等于true的话，那么就说明UI线程的消息队列中已经有一个DO_TRAVERSAL消息在等待执行了，这时候就不需要调用ViewRoot类的成员函数scheduleTraversals来向UI线程的消息队列发送一个DO_TRAVERSAL消息了，否则的话，就需要调用ViewRoot类的成员函数scheduleTraversals来向UI线程的消息队列发送一个DO_TRAVERSAL消息。         ViewRoot类的成员函数scheduleTraversals在前面Android应用程序窗口（Activity）的绘图表面（Surface）的创建过程分析一文中已经分析过了，这里不再详述。         这一步执行完成之后，返回到前面的Step 1中，即View类的成员函数layout中，接下来它就会调用另外一个成员函数onLayout来重新布局当前视图的子视图的布局了。View类的成员函数onLayout是由子类来重写的，并且只有当该子类描述的是一个容器视图时，它才会重写父类View的成员函数onLayout。前面我们已经假设当前正在处理的是应用程序窗口的顶层视图，它的类型为DecorView，并且它描述的是一个容器视图，因此，接下来我们就会继续分析DecorView类的成员函数onLayout的实现。         事实上，DecorView类是通过FrameLayout类来间接继承View类的，并且它的成员函数onLayout是从FrameLayout类继承下来的，因此，接下来我们实际上要分析的是FrameLayout类的成员函数onLayout的实现。         Step 5. FrameLayout.onLayout public class FrameLayout extends ViewGroup {    ......    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {        final int count = getChildCount();        final int parentLeft = mPaddingLeft + mForegroundPaddingLeft;        final int parentRight = right - left - mPaddingRight - mForegroundPaddingRight;        final int parentTop = mPaddingTop + mForegroundPaddingTop;        final int parentBottom = bottom - top - mPaddingBottom - mForegroundPaddingBottom;        mForegroundBoundsChanged = true;        for (int i = 0; i < count; i++) {            final View child = getChildAt(i);            if (child.getVisibility() != GONE) {                final LayoutParams lp = (LayoutParams) child.getLayoutParams();                final int width = child.getMeasuredWidth();                final int height = child.getMeasuredHeight();                int childLeft = parentLeft;                int childTop = parentTop;                final int gravity = lp.gravity;                if (gravity != -1) {                    final int horizontalGravity = gravity & Gravity.HORIZONTAL_GRAVITY_MASK;                    final int verticalGravity = gravity & Gravity.VERTICAL_GRAVITY_MASK;                    switch (horizontalGravity) {                        case Gravity.LEFT:                            childLeft = parentLeft + lp.leftMargin;                            break;                        case Gravity.CENTER_HORIZONTAL:                            childLeft = parentLeft + (parentRight - parentLeft - width) / 2 +                                    lp.leftMargin - lp.rightMargin;                            break;                        case Gravity.RIGHT:                            childLeft = parentRight - width - lp.rightMargin;                            break;                        default:                            childLeft = parentLeft + lp.leftMargin;                    }                    switch (verticalGravity) {                        case Gravity.TOP:                            childTop = parentTop + lp.topMargin;                            break;                        case Gravity.CENTER_VERTICAL:                            childTop = parentTop + (parentBottom - parentTop - height) / 2 +                                    lp.topMargin - lp.bottomMargin;                            break;                        case Gravity.BOTTOM:                            childTop = parentBottom - height - lp.bottomMargin;                            break;                        default:                            childTop = parentTop + lp.topMargin;                    }                }                child.layout(childLeft, childTop, childLeft + width, childTop + height);            }        }    }    ......}        这个函数定义在文件frameworks/base/core/java/android/widget/FrameLayout.java中。         FrameLayout类的成员变量mPaddingLeft、mPaddingRight、mPaddingTop、mPaddingBottom和mForegroundPaddingLeft、mForegroundPaddingRight、mForegroundPaddingTop、mForegroundPaddingBottom的含义我们在前面分析Android应用程序窗品的测量过程时已经解释过了，它们描述的是当前视图的内边距，而参数left、top、right和bottom描述的是当前视图的外边距，即它与父窗口的边距。通过上述这些参数，我们就可以得到当前视图的子视图所能布局在的区域。         FrameLayout类的成员函数onLayout通过一个for循环来布局当前视图的每一个子视图。如果一个子视图child是可见的，那么FrameLayout类的成员函数onLayout就会根据当前视图可以用来显示子视图的区域以及它所设置的gravity属性来得到它在应用程序窗口中的左上角位置（childeLeft，childTop）。         当一个子视图child在应用程序窗口中的左上角位置确定了之后，再结合它在前面的测量过程中所确定的宽度width和高度height，我们就可以完全地确定它在应用程序窗口中的布局了，即可以调用它的成员函数layout来设置它的位置和大小了，这刚好就是前面的Step 1所执行的操作。注意，如果当前正在布局的子视图child描述的也是一个视图容器，那么它又会重复执行Step 5的操作，直到它的所有子孙视图都布局完成为止。        至此，我们就分析完成Android应用程序窗口的布局过程了，接下来我们继续分析Android应用程序窗口的绘制过程。        3. Android应用程序窗口的绘制过程        ViewRoot类的成员函数draw首先会创建一块画布，接着再在画布上绘制Android应用程序窗口的UI，最后再将画布的内容交给SurfaceFlinger服务来渲染，这个过程如图4所示： 图4 Android应用程序窗口的绘制过程         这个过程可以分为14个步骤，接下来我们就详细分析每一个步骤。         Step 1. ViewRoot.draw public final class ViewRoot extends Handler implements ViewParent,        View.AttachInfo.Callbacks {    ......    private void draw(boolean fullRedrawNeeded) {        Surface surface = mSurface;        ......        int yoff;        final boolean scrolling = mScroller != null && mScroller.computeScrollOffset();        if (scrolling) {            yoff = mScroller.getCurrY();        } else {            yoff = mScrollY;        }        if (mCurScrollY != yoff) {            mCurScrollY = yoff;            fullRedrawNeeded = true;        }        float appScale = mAttachInfo.mApplicationScale;        boolean scalingRequired = mAttachInfo.mScalingRequired;        Rect dirty = mDirty;        ......        if (mUseGL) {            if (!dirty.isEmpty()) {                Canvas canvas = mGlCanvas;                if (mGL != null && canvas != null) {                    ......                    int saveCount = canvas.save(Canvas.MATRIX_SAVE_FLAG);                    try {                        canvas.translate(0, -yoff);                        if (mTranslator != null) {                            mTranslator.translateCanvas(canvas);                        }                        canvas.setScreenDensity(scalingRequired                                ? DisplayMetrics.DENSITY_DEVICE : 0);                        mView.draw(canvas);                        ......                    } finally {                        canvas.restoreToCount(saveCount);                    }                    ......                }            }            if (scrolling) {                mFullRedrawNeeded = true;                scheduleTraversals();            }            return;        }        if (fullRedrawNeeded) {            ......            dirty.union(0, 0, (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f));        }        ......        if (!dirty.isEmpty() || mIsAnimating) {            Canvas canvas;            try {                ......                canvas = surface.lockCanvas(dirty);                ......            } catch (Surface.OutOfResourcesException e) {                ......                return;            } catch (IllegalArgumentException e) {                ......                return;            }            try {                if (!dirty.isEmpty() || mIsAnimating) {                    .....                    mView.mPrivateFlags |= View.DRAWN;                    ......                    int saveCount = canvas.save(Canvas.MATRIX_SAVE_FLAG);                    try {                        canvas.translate(0, -yoff);                        if (mTranslator != null) {                            mTranslator.translateCanvas(canvas);                        }                        canvas.setScreenDensity(scalingRequired                                ? DisplayMetrics.DENSITY_DEVICE : 0);                        mView.draw(canvas);                    } finally {                        ......                        canvas.restoreToCount(saveCount);                    }                    ......                }            } finally {                surface.unlockCanvasAndPost(canvas);            }        }        ......        if (scrolling) {            mFullRedrawNeeded = true;            scheduleTraversals();        }    }    ......}        这个函数定义在文件frameworks/base/core/java/android/view/ViewRoot.java中。         ViewRoot类的成员函数draw的执行流程如下所示：         1. 将成员变量mSurface所描述的应用程序窗口的绘图表面保存在变量surface中，以便接下来可以通过变量surface来操作应用程序窗口的绘图表面。         2. 调用成员变量mScroller所描述的一个Scroller对象的成员函数computeScrollOffset来计算应用程序窗口是否处于正在滚动的状态中。如果是的话，那么得到的变量scrolling就会等于true，这时候调用成员变量mScroller所描述的一个Scroller对象的成员函数getCurrY就可以得到应用程序窗口在Y轴上的即时滚动位置yoff。         3. 成员变量mScrollY用来描述应用程序窗口下一次绘制时在Y轴上应该滚动到的位置，因此，如果应用程序窗口不是处于正在滚动的状态，那么它在下一次绘制时，就应该直接将它在Y轴上的即时滚动位置yoff设置为mScrollY。         4. 成员变量mCurScrollY用来描述应用程序窗口上一次绘制时在Y轴上的滚动位置，如果它的值不等变量yoff的值，那么就表示应用程序窗口在Y轴上的滚动位置发生变化了，这时候就需要将变量yoff的值保存在成员变量mCurScrollY中，并且将参数fullRedrawNeeded的设置为true，表示要重新绘制应用程序窗口的所有区域。         5. 成员变量mAttachInfo所描述的一个AttachInfo对象的成员变量mScalingRequired表示应用程序窗口是否正在请求进行大小缩放，如果是的话，那么所请求的大小缩放因子就保存在这个AttachInfo对象的另外一个成员变量mApplicationScale中。函数将这两个值保存在变量scalingRequired和appScale中，以便接下来可以使用。         6. 成员变量mDirty描述的是一个矩形区域，表示应用程序窗口的脏区域，即需要重新绘制的区域。函数将这个脏区域保存变量dirty中，以便接下来可以使用。         7. 成员变量mUseGL用来描述应用程序窗口是否直接使用OpenGL接口来绘制UI。当应用程序窗口的绘图表面的内存类型等于WindowManager.LayoutParams.MEMORY_TYPE_GPU时，那么就表示它需要使用OpenGL接口来绘制UI，以便可以利用GPU来绘制UI。当应用程序窗口需要直接使用OpenGL接口来绘制UI时，另外一个成员变量mGlCanvas就表示应用程序窗口的绘图表面所使用的画布，这块画布同样是通过OpenGL接口来创建的。         8. 当应用程序窗口需要直接使用OpenGL接口来绘制UI时，函数接下来就会将它的UI绘制在成员变量mGlCanvas所描述的一块画布上，这是通过调用成员变量mView所描述的一个类型为DecorView的顶层视图的成员函数draw来实现的。注意，在绘制之前，还需要对画布进行适当的转换：A. 设置画布在Y轴上的偏移值yoff，以便可以正确反映应用程序窗口的滚动状态；B. 如果成员变量mTranslator的值不等于null，即它指向了一个Translator对象，那么就说明应用程序窗口运行在兼容模式下，这时候就需要相应对画布进行变换，以便可以正确反映应用程序窗口的大小；C. 当变量scalingRequired的值等于true时，同样说明应用程序窗口是运行在兼容模式下，这时候就需要修改画布在兼容模式下的点密度，以便可以正确地反映应用程序窗口的分辨率，注意，这时候屏幕在兼容模式下的点密度保存在DisplayMetrics类的静态成员变量DENSITY_DEVICE中。由于上述画布的转换操作只针对当前的这一次绘制操作有效，因此，函数就需要在绘制之后，调用画布的成员函数save来保存它在转换前的矩阵变换堆栈状态，以便在绘制完成之后，可以调用画布的成员函数restoreToCount来恢复之前的矩阵变换堆栈状态。        9. 使用OpenGL接口来绘制完成UI后，如果变量scrolling的值等于true，即应用程序窗口是处于正在滚动的状态，那么就意味着应用程序窗口接下来还需要马上进行下一次重绘，而且是所有的区域都需要重绘，因此，函数接下来就会将成员变量mFullRedrawNeeded的值设置为true，并且调用另外一个成员函数scheduleTraversals来请求执行下一次的重绘操作。       10. 以下的步骤针适用于使用非OpenGL接口来绘制UI的情况，也是本文所要关注的重点。       11. 参数fullRedrawNeeded用来描述是否需要绘制应用程序窗口的所有区域。如果需要的话，那么就会将应用程序窗口的脏区域的大小设置为整个应用程序窗口的大小（0，0，mWidth，mHeight），其中，成员变量mWidth和mHeight表示应用程序窗口的宽度和高度。注意，如果应用程序窗口的大小被设置了一个缩放因子，即变量appScale的值不等于1，那么就需要将应用程序窗口的宽度mWidth和高度mHeight乘以这个缩放因子，然后才可以得到应用程序窗口的实际大小。       12. 经过前面的一系列计算之后，如果应用程序窗口的脏区域dirty不等于空，或者应用程序窗口在正处于动画状态，即成员变量mIsAnimating的值等于true，那么函数接下来就需要重新绘制应用程序窗口的UI了。在绘制之前，首先会调用用来描述应用程序窗口的绘图表面的一个Surface对象surface的成员函数lockCanvas来创建一块画布canvas。有了这块画布之后，接下来就可以调用成员变量mView所描述的一个类型为DecorView的顶层视图的成员函数draw来在上面绘制应用程序窗口的UI了。 与前面的第8步一样，在绘制之前，还需要对画布进行适当的A、B和C转换，以及需要在绘制之后恢复画布在绘制之前的矩阵变换堆栈状态。       13. 绘制完成之后，应用程序窗口的UI就都体现在前面所创建的画布canvas上了，因此，这时候就需要将它交给SurfaceFlinger服务来渲染，这是通过调用用来描述应用程序窗口的绘图表面的一个Surface对象surface的成员函数unlockCanvasAndPost来实现的。       14. 在请求SurfaceFlinger服务渲染应用程序窗口的UI之后，函数同样是需要判断变量scrolling的值是否等于true。如果等于的话，那么就与前面的第9步一样，函数需要将成员变量mFullRedrawNeeded的值设置为true，并且调用另外一个成员函数scheduleTraversals来请求执行下一次的重绘操作。        在本文中，我们只关注使用非OpenGL接口来绘制应用程序窗口的UI的步骤，其中，第12步和第13步是关键所在。第12步调用了Java层的Surface类的成员函数lockCanvas来为应用程序窗口的绘图表面创建了一块画布，并且调用了DecorView类的成员函数draw来在这块画布上绘制了应用程序窗口的UI，而第13步调用了Java层的Surface类的成员函数unlockCanvasAndPost来将前面已经绘制了应用程序窗口UI的画布交给SurfaceFlinger服务来渲染。接下来，我们就分别分析Java层的Surface类的成员函数lockCanvas、DecorView类的成员函数draw和Java层的Surface类的成员函数unlockCanvasAndPost的实现。        Step 2. Surface.lockCanvas public class Surface implements Parcelable {    ......    public Canvas lockCanvas(Rect dirty) throws OutOfResourcesException, IllegalArgumentException    {        /* the dirty rectangle may be expanded to the surface's size, if         * for instance it has been resized or if the bits were lost, since         * the last call.         */        return lockCanvasNative(dirty);    }    private native Canvas lockCanvasNative(Rect dirty);    ......}         这个函数定义在文件frameworks/base/core/java/android/view/Surface.java中。         Surface类的成员函数lockCanvas调用另外一个成员函数lockCanvasNative来创建一块画布。Surface类的成员函数lockCanvasNative是一个JNI方法，它是由C++层的函数Surface_lockCanvas来实现的，如下所示： static jobject Surface_lockCanvas(JNIEnv* env, jobject clazz, jobject dirtyRect)  {      const sp<Surface>& surface(getSurface(env, clazz));      ......        // get dirty region      Region dirtyRegion;      if (dirtyRect) {          Rect dirty;          dirty.left  = env->GetIntField(dirtyRect, ro.l);          dirty.top   = env->GetIntField(dirtyRect, ro.t);          dirty.right = env->GetIntField(dirtyRect, ro.r);          dirty.bottom= env->GetIntField(dirtyRect, ro.b);          if (!dirty.isEmpty()) {              dirtyRegion.set(dirty);          }      }       ......        Surface::SurfaceInfo info;      status_t err = surface->lock(&info, &dirtyRegion);      ......        // Associate a SkCanvas object to this surface      jobject canvas = env->GetObjectField(clazz, so.canvas);      ......        SkCanvas* nativeCanvas = (SkCanvas*)env->GetIntField(canvas, no.native_canvas);      SkBitmap bitmap;      ......      if (info.w > 0 && info.h > 0) {          bitmap.setPixels(info.bits);      } else {          // be safe with an empty bitmap.          bitmap.setPixels(NULL);      }      ......        SkRegion clipReg;      if (dirtyRegion.isRect()) { // very common case          const Rect b(dirtyRegion.getBounds());          clipReg.setRect(b.left, b.top, b.right, b.bottom);      } else {          size_t count;          Rect const* r = dirtyRegion.getArray(&count);          while (count) {              clipReg.op(r->left, r->top, r->right, r->bottom, SkRegion::kUnion_Op);              r++, count--;          }      }        nativeCanvas->clipRegion(clipReg);        int saveCount = nativeCanvas->save();    env->SetIntField(clazz, so.saveCount, saveCount);        if (dirtyRect) {          const Rect& bounds(dirtyRegion.getBounds());          env->SetIntField(dirtyRect, ro.l, bounds.left);          env->SetIntField(dirtyRect, ro.t, bounds.top);          env->SetIntField(dirtyRect, ro.r, bounds.right);          env->SetIntField(dirtyRect, ro.b, bounds.bottom);      }        return canvas;  }          这个函数定义在文件frameworks/base/core/jni/android_view_Surface.cpp中。         参数clazz指向的是一个Java层的Surface对象。从前面Android应用程序窗口（Activity）的绘图表面（Surface）的创建过程分析一文可以知道，每一个Java层的Surface对象在C++层都对应有一个Surface对象。因此，函数首先调用另外一个函数getSurface来获得与参数clazz所对应的C++层的Surface对象surface。         参数dirtyRect指向的是一个Java层的Rect对象，它描述的是应用程序窗口即将要重绘的一块矩形区域，函数接下来就将它所描述的矩形区域转换成一个C++层的Region对象dirtyRegion来表示。         函数接下来就调用前面所获得的C++层的Surface对象surface的成员函数lock来获得一个图形缓冲区，这个图形缓冲区使用一个SurfaceInfo对象info来描述，其中，图形缓冲区的地址就保存在它的成员变量bits中。         获得图形缓冲区之后，我们就可以在上面绘制应用程序窗口的UI了。由于Java层的应用程序窗口是通Skia图形库来绘制应用程序窗口的UI的，而Skia图形库在绘制UI时，是需要一块画布的，因此，函数接下来就会将前面所获得的图形缓冲区封装在一块画布中。        从前面Android应用程序窗口（Activity）的绘图表面（Surface）的创建过程分析一文还可以知道，每一个Java层的Surface对象内部都有一块画布，这块画布是通过它的成员变量mCanvas所指向的一个Java层的CompatibleCanvas对象来描述的。so是一个类型为so_t的结构体，它的成员变量canvas描述的是Java层的Surface类的成员变量mCanva在类中的偏移量，因此，通过这个偏移量就可以获得参数clazz所指向的一个Java层的Surface对象的内部的一块类型为CompatibleCanvas的画布canvas。        画布canvas的类型为Java层的CompatibleCanvas，它是从Canvas类继承下来的。Canvas类有一个成员变量mNativeCanvas，它指向的是一个C++层的SkCanvas对象，这个C++层的SkCanvas对象描述的就是Skia图形库绘制应用程序窗口UI时所需要的画布。no是一个类型为no_t的结构体，它的成员变量native_canvas描述的是Java层的Canvas类的成员变量mNativeCanvas在类中的偏移量，因此，通过这个偏移量就可以获得变量canvas所指向的一个Java层的CompatibleCanvas对象的内部的一块类型为SkCanvas的画布nativeCanvas。        获得了Skia图形库所需要的画布nativeCanvas之后，函数就可以将前面所获得的图形缓冲区的地址，即SurfaceInfo对象info的成员变量bits封装到它内部去了，这是通过调用它的成员函数setPixels来实现的。        函数接下来还会设置画布nativeCanvas的裁剪区域。这个裁剪区域是通过Region对象dirtyRegion来描述的，不过Skia图形库需要使用另外一个类型为SkRegion的对象clipReg来描述它。Region对象dirtyRegion所描述的区域有可能是一个矩形区域，也可能是一个不规则的区域。如果Region对象dirtyRegion描述的是一个矩形区域，那么就可以直接将这个矩形区域设置到SkRegion的对象clipReg里面去。如果Region对象dirtyRegion描述的是一个不规则区域，那么这个不规则区域就是由一系列的矩形小区域来描述的，这时候就将这些矩形小区域合并起来，并且设置到kRegion的对象clipReg里面去。         设置好SkRegion的对象clipReg所包含的区域之后，函数就可以调用前面得到的SkCanvas画布nativeCanvas的成员函数clipRegion来将它设置为自己的裁剪区域了，接下来函数还会将该裁剪区域所围成的一个矩形区域的位置和大小设置到参数dirtyRect所描述的一个Java层的Rect对象中去，以便调用者可以知道现在正在创建的画布的大小。        函数在将与C++层的SkCanvas画布nativeCanvas所关联的一个Java层的CompatibleCanvas画布canvas返回给调用者之前，还会将画布的当前堆栈状态保存下来，以便在绘制完成应用程序窗口的UI之后，可以恢复回来，这是通过调用C++层的SkCanvas画布nativeCanvas的成员函数save来实现的。画布的当前堆栈状态是通过一个整数来描述的，这个整数即为C++层的SkCanvas画布nativeCanvas的成员函数save的返回值saveCount，它会被保存在参数clazz所描述的一个Java层的Surface对象的成员变量mSaveCount中，等到应用程序窗口的UI绘制完成之后，就可以通过这个整数来恢复画布的堆栈状态了。        接下来，我们继续分析C++层的Surface类的成员函数lock的实现，以便可以了解用来创建绘制应用程序窗口UI所需要的画布的图形缓冲区是如何获得的。        Step 3. Surface.lock status_t Surface::lock(SurfaceInfo* other, Region* dirtyIn, bool blocking){    ......    if (mApiLock.tryLock() != NO_ERROR) {        ......        return WOULD_BLOCK;    }    /* Here we're holding mApiLock */    if (mLockedBuffer != 0) {        ......        mApiLock.unlock();        return INVALID_OPERATION;    }    // we're intending to do software rendering from this point    setUsage(GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN);    android_native_buffer_t* out;    status_t err = dequeueBuffer(&out);    ......    if (err == NO_ERROR) {        sp<GraphicBuffer> backBuffer(GraphicBuffer::getSelf(out));        err = lockBuffer(backBuffer.get());        ......        if (err == NO_ERROR) {            const Rect bounds(backBuffer->width, backBuffer->height);            const Region boundsRegion(bounds);            Region scratch(boundsRegion);            Region& newDirtyRegion(dirtyIn ? *dirtyIn : scratch);            newDirtyRegion &= boundsRegion;            // figure out if we can copy the frontbuffer back            const sp<GraphicBuffer>& frontBuffer(mPostedBuffer);            const bool canCopyBack = (frontBuffer != 0 &&                    backBuffer->width  == frontBuffer->width &&                    backBuffer->height == frontBuffer->height &&                    backBuffer->format == frontBuffer->format &&                    !(mFlags & ISurfaceComposer::eDestroyBackbuffer));            ......            if (canCopyBack) {                // copy the area that is invalid and not repainted this round                const Region copyback(mOldDirtyRegion.subtract(newDirtyRegion));                if (!copyback.isEmpty())                    copyBlt(backBuffer, frontBuffer, copyback);            } else {                // if we can't copy-back anything, modify the user's dirty                // region to make sure they redraw the whole buffer                newDirtyRegion = boundsRegion;            }            ......            void* vaddr;            status_t res = backBuffer->lock(                    GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,                    newDirtyRegion.bounds(), &vaddr);            ......            mLockedBuffer = backBuffer;            other->w      = backBuffer->width;            other->h      = backBuffer->height;            other->s      = backBuffer->stride;            other->usage  = backBuffer->usage;            other->format = backBuffer->format;            other->bits   = vaddr;        }    }    mApiLock.unlock();    return err;}       这个函数定义在文件frameworks/base/libs/surfaceflinger_client/Surface.cpp中。        Surface类的成员变量mApiLock是一个类型为Mutex的互斥锁，它是用来保证Surface类的成员函数lock是线程安全的。如果调用Surface类的成员变量mApiLock所描述的一个Mutex对象的成员函数tryLock的返回值不等于NO_ERROR，那么就说明这个Mutex对象已经被另外一个线程获得了，因此，这时候函数就直接返回一个错误码WOULD_BLOCK给调用者了。        Surface类的成员变量mLockedBuffer的类型为GraphicBuffer，如果它的值不等于0，那么它指向的就是应用程序窗口当前正在使用的图形缓冲区。如果应用程序窗口正在使用一个图形缓冲区，那么它是不可以再请求分配另一个图形缓冲区的，因此，当Surface类的成员变量mLockedBuffer的值不等于0时，函数就直接返回一个错误码INVALID_OPERATION给调用者了。        通过了前面的检查之后，Surface类的成员函数lock接下来就开始要分配一个图形缓冲区了，不过在分配之后，首先调用另外一个成员函数setUsage来将当前正在处理的Surface对象所描述的应用程序窗口的绘图表面的属性设置为（GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN），表示该应用程序窗口的UI是需要通过软件方式来渲染的，这是相对于使用GPU来渲染而言的。        Surface类的成员函数lock接下来就调用另外一个成员函数dequeueBuffer来获得一个新的图形缓冲区了，这个新的图形缓冲区使用一个android_native_buffer_t对象out来描述的。在前面Android应用程序请求SurfaceFlinger服务渲染Surface的过程分析一文中，我们已经分析过Surface类的成员函数dequeueBuffer的实现了，它主要就是请求SurfaceFlinger服务来分配一个图形缓冲区。        前面获得的android_native_buffer_t对象out接下来又会被封装成一个GraphicBuffer对象backBuffer，这样，Surface类的成员函数lock接下来就会通过GraphicBuffer对象backBuffer来访问前面所获得的图形缓冲区。        Surface类是使用一种称为双缓冲的技术来渲染应用程序窗口的UI的。这种双缓冲技术需要两个图形缓冲区，其中一个称为前端缓冲区，另外一个称为后端缓冲区。前端缓冲区是正在渲染的图形缓冲区，而后端缓冲区是接下来要渲染的图形缓冲区，它们分别通过Surface类的成员变量mPostedBuffer和mLockedBuffer所指向的两个GraphicBuffer对象来描述。前面所获得的图形缓冲区backBuffer是作为后端缓冲区来使用的，即接下来它所指向的图形缓冲区也需要保存在Surface类的成员变量mLockedBuffer中。        在将图形缓冲区backBuffer返回给调用者之前，Surface类的成员函数lock还需要对它进行进一步的处理，即判断是否需要前端缓冲区mPostedBuffer的内容拷贝回它里面去，以便可以支持部分更新应用程序窗口UI的功能。在满足以下三个条件下，Surface类的成员函数lock可以将前端缓冲区的内容拷贝到后端缓冲区中去：        1. 前端缓冲区的内容拷贝到后端缓冲区所描述的区域的宽度和高度相同。        2. 前端缓冲区和后端缓冲区的像素格式相同。        3. 应用程序窗口绘图表面的属性值mFlags的ISurfaceComposer::eDestroyBackbuffer位等于0，即在渲染了应用程序窗口的UI之后，应该保留正在渲染的图形缓冲区的内容。        如果能将前端缓冲区的内容拷贝到后端缓冲区中去，那么就不用重新绘制应用程序窗口的所有区域，而只需要绘制那些脏的区域，即Region对象newDirtyRegion所描述的区域。注意，参数dirtyIn所描述的区域是原先指定的脏区域，但是在分配了新的后端缓冲区backBuffer之后，我们需要将新的图形缓冲区backBuffer所描述的区域boundsRegion与原先指定的脏区域作一个与操作，得到才是最后需要重绘的脏区域newDirtyRegion。由于在这种情况下，我们只在后端缓冲区backBuffer绘制中绘制应用程序窗口的脏区域，因此，就需要将那些干净的区域从前端缓冲区frontBuffer拷贝到图形缓冲区backBuffer的对应位置去，这是通过调用函数copyBlt来实现的。应用程序窗口的干净区域使用Region对象copyback来描述，它是从应用程序窗口上一次所重绘的区域减去接下来需要重绘的脏区域newDirtyRegion得到的，而应用程序窗口上一次所重绘的区域是保存在Surface类的成员变量mOldDirtyRegion中的。        如果不能将前端缓冲区的内容拷贝到后端缓冲区中去，那么接下来就需要重新绘制应用程序窗口的所有区域了，这时候应用程序窗口的脏区域newDirtyRegion就会被修改为后端缓冲区backBuffer所描述的区域boundsRegion。        Surface类的成员函数lock处理完成前后端缓冲区的拷贝问题之后，接下来就会调用后端缓冲区backBuffer所指向的一个GraphicBuffer对象的成员函数lock来获得它的地址vaddr，以便接下来保存在参数other所描述的一个SurfaceInfo对象的成员变量bits中，这样调用者就获得后端缓冲区backBuffer的地址值了。注意，同时保存在SurfaceInfo对象中的信息还包括后端缓冲区backBuffer的宽度width、高度height、每行像素点stride、用途usage和像素格式format。        Surface类的成员函数lock还会将接下来要重绘的脏缓冲区newDirtyRegion保存在Surface类的成员变量mOldDirtyRegion中，以便再下一次为应用程序窗口分配图形缓冲区时，可以知道应用程序窗口的上一次重绘区域，即上一次干净区域。        此外，Surface类的成员函数lock还会将后端缓冲区backBuffer保存在Surface类的成员变量mLockedBuffer，这样就可以知道应用程序窗口当前正在使用的图形缓冲区，即下一次要请求SurfaceFlinger服务渲染的图形缓冲区。        最后，Surface类的成员函数lock首先调用成员变量mApiLock所指向的一个Mutex对象的成员函数unlock，以便中可以释放前面所获得的锁，然后再返回到上一步去。        接下来，我们继续分析GraphicBuffer类的成员函数lock的实现，以便可以了解一个图形缓冲区的地址是如何获得的。        Step 4. GraphicBuffer.lock status_t GraphicBuffer::lock(uint32_t usage, const Rect& rect, void** vaddr){    ......    status_t res = getBufferMapper().lock(handle, usage, rect, vaddr);    return res;}       这个函数定义在文件frameworks/base/libs/ui/GraphicBuffer.cpp中。        GraphicBuffer类的成员变量handle是从父类android_native_buffer_t继承下来的，它的类型为buffer_handle_t，用来作为一个图形缓冲区的句柄，这个知识点可以参考前面Android应用程序请求SurfaceFlinger服务渲染Surface的过程分析一文。        GraphicBuffer类的成员函数lockGraphicBuffer首先调用另外一个成员函数getBufferMapper来获得一个GraphicBufferMapper对象，然后再调用这个GraphicBufferMapper对象的成员函数lock来获得成员变量handle所描述的一个图形缓冲区的地址，并且保存在输出参数vaddr中。        接下来，我们就继续分析GraphicBufferMapper类的成员函数lock的实现。        Step 5. GraphicBufferMapper.lock status_t GraphicBufferMapper::lock(buffer_handle_t handle,        int usage, const Rect& bounds, void** vaddr){    status_t err;    if (sw_gralloc_handle_t::validate(handle) < 0) {        err = mAllocMod->lock(mAllocMod, handle, usage,                bounds.left, bounds.top, bounds.width(), bounds.height(),                vaddr);    } else {        err = sw_gralloc_handle_t::lock((sw_gralloc_handle_t*)handle, usage,                bounds.left, bounds.top, bounds.width(), bounds.height(),                vaddr);    }    LOGW_IF(err, \"lock(...) failed %d (%s)\", err, strerror(-err));    return err;}        这个函数定义在文件frameworks/base/libs/ui/GraphicBufferMapper.cpp。         GraphicBufferMapper类的成员函数lock首先调用sw_gralloc_handle_t类的静态成员函数validate来验证参数andle所描述的一个图形缓冲区是否是在w_gralloc_handle_t模块中分配的。如果是的话，那么就需要调用sw_gralloc_handle_t类的静态成员函数lock来获得参数andle所描述的一个图形缓冲区的地址，否则的话，就需要调用GraphicBufferMapper类的成员变量mAllocMod所描述的一个HAL模块Gralloc的成员函数lock来获得参数andle所描述的一个图形缓冲区的地址。         从前面Android应用程序请求SurfaceFlinger服务渲染Surface的过程分析一文可以知道，应用程序窗口所使用的图形缓冲区一般都是在HAL模块Gralloc中分配的，因此，GraphicBufferMapper类的成员函数lock接下来就会调用成员变量mAllocMod所描述的一个HAL模块Gralloc的成员函数lock来获得参数andle所描述的一个图形缓冲区的地址，并且保存在输出参数vaddr中。HAL模块Gralloc的成员函数lock的实现可以参考前面Android帧缓冲区（Frame Buffer）硬件抽象层（HAL）模块Gralloc的实现原理分析一文，这里不再详述。         这一步执行完成之后，返回到前面的Step 1中，即ViewRoot类的成员函数draw中，接下来就会继续调用其成员变量mView所描述的一个DecorView对象的成员函数draw来在前面所获得一块画布上面绘制应用程序窗口的UI。         Step 6. DecorView.draw public class PhoneWindow extends Window implements MenuBuilder.Callback {    ......    private final class DecorView extends FrameLayout implements RootViewSurfaceTaker {        ......        private Drawable mMenuBackground;        ......        @Override        public void draw(Canvas canvas) {            super.draw(canvas);            if (mMenuBackground != null) {                mMenuBackground.draw(canvas);            }        }        ......    }    ......}         这个函数定义在文件frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindow.java中。         DecorView类的成员函数draw首先调用父类FrameLayout的成员函数draw来绘制它的UI内容，然后再检查它是否设置了菜单背景，即成员变量mMenuBackground的值是否不等于null。如果不等于null的话，那么就会调用它所指向的一个Drawable对象的成员函数draw来在画布canvas上绘制这个菜单背景。        接下来，我们就继续分析FrameLayout的成员函数draw的实现，以便可以了解应用程序窗口UI的绘制过程。        Step 7. FrameLayout.draw public class FrameLayout extends ViewGroup {    ......      private Drawable mForeground;    ......    public void draw(Canvas canvas) {        super.draw(canvas);        if (mForeground != null) {            final Drawable foreground = mForeground;            if (mForegroundBoundsChanged) {                mForegroundBoundsChanged = false;                final Rect selfBounds = mSelfBounds;                final Rect overlayBounds = mOverlayBounds;                final int w = mRight-mLeft;                final int h = mBottom-mTop;                if (mForegroundInPadding) {                    selfBounds.set(0, 0, w, h);                } else {                    selfBounds.set(mPaddingLeft, mPaddingTop, w - mPaddingRight, h - mPaddingBottom);                }                Gravity.apply(mForegroundGravity, foreground.getIntrinsicWidth(),                        foreground.getIntrinsicHeight(), selfBounds, overlayBounds);                foreground.setBounds(overlayBounds);            }            foreground.draw(canvas);        }    }    ......}         这个函数定义在文件frameworks/base/core/java/android/widget/FrameLayout.java中。         FrameLayout类的成员函数draw首先调用父类View的成员函数draw来绘制它的UI内容，然后再检查它是否设置了一个前景图，即成员变量mForeground的值是否等于null。如果不等于null的话，那么就会先设置这个前景图的大小和位置，然后再调用用成员变量mForeground所指向的一个Drawable对象的成员函数draw来在画布canvas上绘制这个前景图。         接下来，我们就继续分析View类的成员函数draw的实现，以便可以了解应用程序窗口UI的绘制过程。         Step 8. View.draw         这个函数定义在文件frameworks/base/core/java/android/view/View.java中，它主要是完成以下六个操作：         1. 绘制当前视图的背景。         2. 保存当前画布的堆栈状态，并且在在当前画布上创建额外的图层，以便接下来可以用来绘制当前视图在滑动时的边框渐变效果。         3. 绘制当前视图的内容。         4. 绘制当前视图的子视图的内容。         5. 绘制当前视图在滑动时的边框渐变效果。         6. 绘制当前视图的滚动条。         在上面六个操作中，有些是可以优化的。例如，如果当前视图的某一个子视图是不透明的，并且覆盖了当前视图的内容，那么当前视图的背景以及内容就不会绘制了，即不用执行第1和第3个操作。又如，如果当前视图不是处于滑动的状态，那么第2和第5个操作也是不用执行的。         接下来我们就分段来阅读View类的成员函数draw的代码： public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource {    ......    public void draw(Canvas canvas) {        ......        final int privateFlags = mPrivateFlags;        final boolean dirtyOpaque = (privateFlags & DIRTY_MASK) == DIRTY_OPAQUE &&                (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);        mPrivateFlags = (privateFlags & ~DIRTY_MASK) | DRAWN;        这段代码检查View类的成员变量mPrivateFlags的DIRTY_OPAQUE位是否等于1。如果等于1的话，那么就说明当前视图的某一个子视图请求了一个不透明UI绘制操作。在这种情况下，当前视图会被子视图覆盖，因此，就不需要执行前面所说的第1和第3个操作了。不过，不用执行第1和第3个操作还有一个前提，那就是View类的成员变量mAttachInfo所指向的一个AttachInfo对象的成员变量mIgnoreDirtyState的值等于false，这表示当前视图不可以忽略成员变量mPrivateFlags的DIRTY_OPAQUE位。满足了上述两个条件之后，变量dirtyOpaque的值就会等于true。          View类的成员函数在继续往下执行之前，还会将成员变量mPrivateFlags的DIRTY_MASK位重置为0，以及将DRAWN位设置为1，因为接下来就要开始绘制当前视图的UI了。          我们继续往下阅读代码：         // Step 1, draw the background, if needed        int saveCount;        if (!dirtyOpaque) {            final Drawable background = mBGDrawable;            if (background != null) {                final int scrollX = mScrollX;                final int scrollY = mScrollY;                if (mBackgroundSizeChanged) {                    background.setBounds(0, 0,  mRight - mLeft, mBottom - mTop);                    mBackgroundSizeChanged = false;                }                if ((scrollX | scrollY) == 0) {                    background.draw(canvas);                } else {                    canvas.translate(scrollX, scrollY);                    background.draw(canvas);                    canvas.translate(-scrollX, -scrollY);                }            }        }        这段代码用来执行上述的第1个操作，但是它只会变量dirtyOpaque的值等于false的情况下才会执行。当前视图的背景是通过成员变量mBGDrawable所指向的一个Drawable对象来描述的。在绘制当前视图的背景之前，还会先设置它的大小和位置。         我们继续往下阅读代码：         // skip step 2 & 5 if possible (common case)        final int viewFlags = mViewFlags;        boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;        boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;        if (!verticalEdges && !horizontalEdges) {            // Step 3, draw the content            if (!dirtyOpaque) onDraw(canvas);            // Step 4, draw the children            dispatchDraw(canvas);            // Step 6, draw decorations (scrollbars)            onDrawScrollBars(canvas);            // we're done...            return;        }        这段代码检查是否可以跳过上述的第2和第5个操作。当View类的成员变量mViewFlags的FADING_EDGE_HORIZONTAL位等于1的时候，就说明当前视图正在处于水平滑动状态，并且需要绘制水平边框的渐变效果。同样，当View类的成员变量mViewFlags的FADING_EDGE_VERTICAL位等于1的时候，就说明当前视图正在处于垂直滑动状态，并且需要绘制垂直边框的渐变效果。但是，如果当前视图不是处于滑动状态，即变量horizontalEdges和verticalEdges的值均等于false的时候，那么就不需要执行上述的第2和第5个操作了，而只需要执行第3、第4和第6个操作。注意，当变量dirtyOpaque的值等于true的时候，第3个操作也是不需要执行的。         我们继续往下分析代码：         boolean drawTop = false;        boolean drawBottom = false;        boolean drawLeft = false;        boolean drawRight = false;        float topFadeStrength = 0.0f;        float bottomFadeStrength = 0.0f;        float leftFadeStrength = 0.0f;        float rightFadeStrength = 0.0f;        // Step 2, save the canvas' layers        int paddingLeft = mPaddingLeft;        int paddingTop = mPaddingTop;        final boolean offsetRequired = isPaddingOffsetRequired();        if (offsetRequired) {            paddingLeft += getLeftPaddingOffset();            paddingTop += getTopPaddingOffset();        }        int left = mScrollX + paddingLeft;        int right = left + mRight - mLeft - mPaddingRight - paddingLeft;        int top = mScrollY + paddingTop;        int bottom = top + mBottom - mTop - mPaddingBottom - paddingTop;        if (offsetRequired) {            right += getRightPaddingOffset();            bottom += getBottomPaddingOffset();        }        final ScrollabilityCache scrollabilityCache = mScrollCache;        int length = scrollabilityCache.fadingEdgeLength;        // clip the fade length if top and bottom fades overlap        // overlapping fades produce odd-looking artifacts        if (verticalEdges && (top + length > bottom - length)) {            length = (bottom - top) / 2;        }        // also clip horizontal fades if necessary        if (horizontalEdges && (left + length > right - length)) {            length = (right - left) / 2;        }        if (verticalEdges) {            topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));            drawTop = topFadeStrength >= 0.0f;            bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));            drawBottom = bottomFadeStrength >= 0.0f;        }        if (horizontalEdges) {            leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));            drawLeft = leftFadeStrength >= 0.0f;            rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));            drawRight = rightFadeStrength >= 0.0f;        }        saveCount = canvas.getSaveCount();        int solidColor = getSolidColor();        if (solidColor == 0) {            final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;            if (drawTop) {                canvas.saveLayer(left, top, right, top + length, null, flags);            }            if (drawBottom) {                canvas.saveLayer(left, bottom - length, right, bottom, null, flags);            }            if (drawLeft) {                canvas.saveLayer(left, top, left + length, bottom, null, flags);            }            if (drawRight) {                canvas.saveLayer(right - length, top, right, bottom, null, flags);            }        } else {            scrollabilityCache.setFadeColor(solidColor);        }        这段代码用来检查是否需要保存参数canvas所描述的一块画布的堆栈状态，并且创建额外的图层来绘制当前视图在滑动时的边框渐变效果。视图的边框是绘制在内容区域的边界位置上的，而视图的内容区域是需要排除成员变量mPaddingLeft、mPaddingRight、mPaddingTop和mPaddingBottom所描述的视图内边距的。此外，视图的边框有四个，分别位于视图的左、右、上以及下内边界上。因此，这段代码首先需要计算出当前视图的左、右、上以及下内边距的大小，以便得到边框所要绘制的区域。         本来通过View类的成员变量mPaddingLeft、mPaddingRight、mPaddingTop和mPaddingBottom就可以得到当视图的左、右、上以及下内边距的大小的，但是有时候我们在定制一个视图的时候，可能会需要在视图的内边距上绘制其它额外的东西，这时候就有扩展视图的内边距的需求。如果有扩展视图的内边距的需求，那么就需要重写View类的成员函数isPaddingOffsetRequired，即将它的返回值设置为true，并且重载另外四个成员函数getLeftPaddingOffset、getRightPaddingOffset、getTopPaddingOffset和getBottomPaddingOffset来提供额外的左、右、上以及下内边距。        这段代码经过计算后，就得到四个值left、right、top和bottom，它们分别表示当前视图可以用来绘制的内容区域，这个区域已经将内置的和扩展的内边距排除之外。        计算好left、right、top和bottom这四个值之后，就相当于得到左、右、上以及下边框的起始位置了，但是我还需要知道边框的长度，才能确定左、右、上以及下边框所要绘制的区域。        边框的长度length设置在View类的成员变量mScrollCache所指向的一个ScrollabilityCache对象的成员变量fadingEdgeLength中。但是，这个预先设置的边框长度length不一定适合当前视图使用。这是因为视图的大小是可以随时改变的，一旦发生了改变之后，原先设置的边框长度length可能就会显得过长。具体来说，就是当上下两个边框或者左右两个边框发生重叠时，就说明原先设置的边框长度过长了。在这种情况下，就要将边框长度length修改为当前视图的内容区域的高度和宽度的较小者的一半，以便可以保证上下两个边框或者左右两个边框不会发生重叠。        左、右、上以及下边框都对应有一个强度值，强度值的取值范围为[0.0, 1.0]。如果一个边框的强度值等于0.0，那么它就是不可见的，这时候就不需要绘制它的渐变效果。另一方面，如果一个边框的强度值等于1.0，那么它的长度等于原来设置的长度。我们可以将这个强度值理解为一个缩放因子。左、右、上以及下边框的强度值可以分别通过调用View类的成员函数getLeftFadingEdgeStrength、getRightFadingEdgeStrength、getTopFadingEdgeStrength以及getBottomFadingEdgeStrength来获得。注意，只有在变量verticalEdges的值等于true的时候，这段代码才会计算上下两个边框的强度值topFadeStrength和bottomFadeStrength；同样，只有变量horizontalEdges的值等于true的时候，这代码才会计算左右两个边框的强度值leftFadeStrength和rightFadeStrength。          计算好左、右、上以及下边框的强度值leftFadeStrength、rightFadeStrength、topFadeStrength以及bottomFadeStrength之后，这段代码就会判断它们的值是否大于0。如果大于0，那么与它们所对应的四个变量drawLeft、drawRight、drawTop以及drawBottom的值就会等于true，表示需要绘制左、右、上以及下四个边框的渐变效果。         View类的成员函数getSolidColor返回的是当前视图的背景颜色。如果当前视图的背景颜色是纯色的，即变量solidColor的值不等于0，那么这时候就会使用这个背景颜色来绘制边框的渐变效果，即调用变量scrollabilityCache所指向的一个ScrollabilityCache对象的成员函数setFadeColor来将将边框的渐变效果颜色设置为solidColor，这种情况是比较简单的。如果当前视图的背景颜色不是纯色的，即变量solidColor的值等于0，这种情况就比较复杂了，我们需要创建在参数canvas所描述的一块画布上来创建额外的图层来绘制边框的渐变效果，这样做是为了能够使用背景颜色来绘制边框的渐变效果。         参数canvas所描述的一块画布上来创建额外的图层是通过调用它的成员函数saveLayer来实现的。我们注意到在调用参数canvas所指向的一个Canvas对象的成员函数saveLayer的时候，最后一个参数指定为Canvas.HAS_ALPHA_LAYER_SAVE_FLAG，这表示在将额外创建的图层合成到参数canvas所描述的一块画布上去，要给额外创建的图层设置一个透明度值。同时，我们还可以看出，当前视图的左、右、上和下边框所占据的范围分别为（left, top, left + length, bottom）、（right - length, top, right, bottom）、（left, top, right, top + length）和（left, bottom - length, right, bottom）。还有另外一个地方需要注意的是，在参数canvas所描述的一块画布上来创建额外的图层之前，这段代码首先会获得画布的当前堆栈状态，这是通过一个整数saveCount来描述的，并且这个整数是通过调用参数canvas所指向的一个Canvas对象的成员函数getSaveCount来获得的。这样，后面在额外创建的图层上绘制了边框的渐变效果之后，就可以通过前面得到的整数saveCount将恢复画布的堆栈状态，也就是将前面额外创建的图层合成到画布上来。         我们接着往下阅读代码：         // Step 3, draw the content        if (!dirtyOpaque) onDraw(canvas);        // Step 4, draw the children        dispatchDraw(canvas);        这段代码用来执行上述的第3和第4个操作，即绘制当前视图的内容，以及当前视图的子视图的内容，它们分别是通过调用View类的成员函数onDraw和dispatchDraw来实现的。本文主要关注当前视图的子视图的绘制过程，因此，在接下来的Step 9中，我们再详细分析View类的成员函数dispatchDraw的实现。        我们接着往下阅读代码：         // Step 5, draw the fade effect and restore layers        final Paint p = scrollabilityCache.paint;        final Matrix matrix = scrollabilityCache.matrix;        final Shader fade = scrollabilityCache.shader;        final float fadeHeight = scrollabilityCache.fadingEdgeLength;        if (drawTop) {            matrix.setScale(1, fadeHeight * topFadeStrength);            matrix.postTranslate(left, top);            fade.setLocalMatrix(matrix);            canvas.drawRect(left, top, right, top + length, p);        }        if (drawBottom) {            matrix.setScale(1, fadeHeight * bottomFadeStrength);            matrix.postRotate(180);            matrix.postTranslate(left, bottom);            fade.setLocalMatrix(matrix);            canvas.drawRect(left, bottom - length, right, bottom, p);        }        if (drawLeft) {            matrix.setScale(1, fadeHeight * leftFadeStrength);            matrix.postRotate(-90);            matrix.postTranslate(left, top);            fade.setLocalMatrix(matrix);            canvas.drawRect(left, top, left + length, bottom, p);        }        if (drawRight) {            matrix.setScale(1, fadeHeight * rightFadeStrength);            matrix.postRotate(90);            matrix.postTranslate(right, top);            fade.setLocalMatrix(matrix);            canvas.drawRect(right - length, top, right, bottom, p);        }       canvas.restoreToCount(saveCount);        这段代码是用来绘制当前视图的左、右、上以及下边框的渐变效果。注意，只有左、右、上以及下边框所对应的四个变量drawLeft、drawRight、drawTop以及drawBottom的值等于true时，左、右、上以及下边框的渐变效果才需要绘制。同时，左、右、上以及下边框在绘制的时候，都会被设置一个缩放因子，即前面计算得到的左、右、上以及下边框的强度值leftFadeStrength、rightFadeStrength、topFadeStrength以及bottomFadeStrength。         由于当前视图的左、右、上以及下边框的渐变效果是在参数canvas所描述的一块画布的额外创建的图层上绘制的，因此，在绘制完之后，这段代码需要调用参数canvas所指向的一个Canvas对象来恢复参数canvas所描述的一块画布在创建额外图层时的堆栈状态，即相当于是将前面所绘制的边框渐变效果合成到参数canvas所描述的一块画布来。         我们继续往下阅读最后一段代码：         // Step 6, draw decorations (scrollbars)        onDrawScrollBars(canvas);    }    ......}       这段代码用来执行上述的第6个操作，即调用View类的成员函数onDrawScrollBars来绘制当前视图的滚动条。        接下来，我们就主要关注当前视图的子视图的绘制过程，即View类的成员函数dispatchDraw的实现。注意，View类的成员函数dispatchDraw是一个空实现，它是由子类ViewGroup来重写的，也就是说，只有当一个视图描述的是一个视图容器时，它才会重写父类View的成员函数dispatchDraw。        前面我们已经假设当前正在处理的视图是应用程序窗口的顶层视图，即它是一个类型为DecorView视图。DecorView类是从ViewGroup类继承下来的，并且在ViewGroup类中重写了父类View类的成员函数dispatchDraw。因此，接下来我们就继续分析ViewGroup的成员函数dispatchDraw的实现。        Step 9. ViewGroup.dispatchDraw        这个函数定义在文件frameworks/base/core/java/android/view/ViewGroup.java中，它的实现比较长，我们分段来阅读： public abstract class ViewGroup extends View implements ViewParent, ViewManager {    ......    @Override    protected void dispatchDraw(Canvas canvas) {        final int count = mChildrenCount;        final View[] children = mChildren;        int flags = mGroupFlags;       ViewGroup类的成员变量mChildrenCount描述的是当前视图组的子视图的个数，另外一个成员变量mChildren是一个类型为View的数组，用来保存当前视图组的子视图。此外，ViewGroup类的成员变量mGroupFlags用来描述当前视图组的标志位。这段代码将上述ViewGroup类的三个成员变量分别保存在变量count、children和flags中，以便接下来可以访问。        我们继续往下阅读代码：         if ((flags & FLAG_RUN_ANIMATION) != 0 && canAnimate()) {            ......            for (int i = 0; i < count; i++) {                final View child = children[i];                if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE) {                    ......                    bindLayoutAnimation(child);                    ......                }            }            final LayoutAnimationController controller = mLayoutAnimationController;            ......            controller.start();            ......            if (mAnimationListener != null) {                mAnimationListener.onAnimationStart(controller.getAnimation());            }        }         这段代码用来检查当前视图组的子视图是否需要显示动画。如果变量flags的FLAG_RUN_ANIMATION位等于1，并且ViewGroup类的成员函数canAnimate的返回值等于true，即当前当前视图组允许其子视图显示动画，那么这段代码接下来就要开始显示动画了。         这段代码首先检查当前视图组的每一个子视图child，如果它是可见的，那么就会调用ViewGroup类的另外一个成员函数bindLayoutAnimation来设置它的动画。设置完成子视图的动画之后，这段代码接下来再调用ViewGroup类的成员变量mLayoutAnimationController所指向的一个LayoutAnimationController对象的成员函数start来启动动画，并且调用ViewGroup类的成员变量mAnimationListener所指向的一个AnimationListener对象的成员函数onAnimationStart来通知那些注册到当前视图组的动画监听者，当前视图组开始显示动画了。         我们继续往下阅读代码：         int saveCount = 0;        final boolean clipToPadding = (flags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;        if (clipToPadding) {            saveCount = canvas.save();            canvas.clipRect(mScrollX + mPaddingLeft, mScrollY + mPaddingTop,                    mScrollX + mRight - mLeft - mPaddingRight,                    mScrollY + mBottom - mTop - mPaddingBottom);        }        这段代码检查变量flags的CLIP_TO_PADDING_MASK位是否不等于1。如果不等于1的话，那么就说明需要设置参数canvas所描述的一块画布的剪裁区域，使得这个裁剪区域不包含当前视图组的内边距。注意，当前视图组的内边距是通过从父类View继承下来的四个成员变量mPaddingLeft、mPaddingRight、mPaddingTop和mPaddingBottom来描述的。此外，当前视图组的区域是通过从父类继承下来的四个成员变量量mLeft、mRight、mTop和mBottom描述的。再结合当前视图的当前滚动位置mScrollX的mScrollY，就可以计算出参数canvas所描述的一块画布的剪裁区域。         在设置参数canvas所描述的一块画布的剪裁区域之前，这段代码会先调用参数canvas所指向的一个Canvas对象的成员函数save来保存它的堆栈状态，以便在绘制完成当前视图组的UI之后，可以恢复canvas所描述的一块画布的堆栈状态。         我们继续往下阅读代码：         boolean more = false;        final long drawingTime = getDrawingTime();        if ((flags & FLAG_USE_CHILD_DRAWING_ORDER) == 0) {            for (int i = 0; i < count; i++) {                final View child = children[i];                if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {                    more |= drawChild(canvas, child, drawingTime);                }            }        } else {            for (int i = 0; i < count; i++) {                final View child = children[getChildDrawingOrder(count, i)];                if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {                    more |= drawChild(canvas, child, drawingTime);                }            }        }       这段代码用来绘制当前视图组的子视图。如果一个子视图child是可见的，即它的成员变量mViewFlags的VISIBLE位等于1，或者它有一个动画需要显示，即它的成员函数getAnimation的返回值不等于null，那么这个子视图就是需要绘制的。绘制一个子视图是通过调用ViewGroup类的成员函数drawChild来实现的。ViewGroup类的成员函数drawChild在绘制一个子视图的时候，如果这个子视图的动画还没有结束，那么它的返回值就等于true，并且会被设置到变量more中去。        注意，当变量flags的FLAG_USE_CHILD_DRAWING_ORDER位等于0的时候，就表示当前视图组的子视图按照它们在数组children中的位置从小到在三类绘制，否则的话，就需要通过ViewGroup类的成员函数getChildDrawingOrder来决定这些子视图的绘制顺序。        我们接着往下阅读代码：         // Draw any disappearing views that have animations        if (mDisappearingChildren != null) {            final ArrayList<View> disappearingChildren = mDisappearingChildren;            final int disappearingCount = disappearingChildren.size() - 1;            // Go backwards -- we may delete as animations finish            for (int i = disappearingCount; i >= 0; i--) {                final View child = disappearingChildren.get(i);                more |= drawChild(canvas, child, drawingTime);            }        }       ViewGroup类的成员变量mDisappearingChildren用来保存那些正在消失的子视图，但是这些子视图正在显示动画的过程中，因此，这些子视图也是需要绘制的，这段代码同样是通过调用ViewGroup类的成员函数drawChild来绘制它们。       我们继续往下阅读最后一段代码：         if (clipToPadding) {            canvas.restoreToCount(saveCount);        }        // mGroupFlags might have been updated by drawChild()        flags = mGroupFlags;        if ((flags & FLAG_INVALIDATE_REQUIRED) == FLAG_INVALIDATE_REQUIRED) {            invalidate();        }        if ((flags & FLAG_ANIMATION_DONE) == 0 && (flags & FLAG_NOTIFY_ANIMATION_LISTENER) == 0 &&                mLayoutAnimationController.isDone() && !more) {            // We want to erase the drawing cache and notify the listener after the            // next frame is drawn because one extra invalidate() is caused by            // drawChild() after the animation is over            mGroupFlags |= FLAG_NOTIFY_ANIMATION_LISTENER;            final Runnable end = new Runnable() {               public void run() {                   notifyAnimationListener();               }            };            post(end);        }    }    ......}        这段代码执行以下三个操作：         1. 检查变量clipToPadding的值是否等于true。如果是的话，那么就说明前面设置过参数canvas所描述的一块画布的裁剪区域。由于现在已经在这块画布上绘制完成当前视图组的UI了，因此，就需要恢复参数canvas所描述的一块画布堆栈状态。这是通过调用参数canvas所指向的一个Canvas对象的成员函数restoreToCount来实现的。         2. 前面在绘制当前视图组的子视图的UI的时候，有可能会需要修改当前视图组的标志位，即修改ViewGroup类的成员变量mGroupFlags的值。如果修改后的mGroupFlags的FLAG_INVALIDATE_REQUIRED位等于1，那么就说明当前视图组需要重新发起一个绘制UI的请求。这是通过调用ViewGroup类的另外一个成员函数invalidate来实现的。         3. 如果当前视图组的动画已经显示完成，并且当前视图组的子视图的动画也已经显示完成，再并且当前视图组注册有动画监听者，那么就是会调用ViewGroup类的另外一个成员函数notifyAnimationListener来通知这些动画监听者，当前视图组的动画已经显示结束。注意，ViewGroup类的成员函数notifyAnimationListener是以消息的形式来调用的，即ViewGroup类的成员函数dispatchDraw不是在动画一显示结束，就马上通知那些动画监听者。         接下来，我们就继续分析ViewGroup类的成员函数drawChild的实现，以便可以了解一个视图组的子视图的绘制过程。         Step 10. ViewGroup.drawChild         这个函数定义在文件frameworks/base/core/java/android/view/ViewGroup.java中，它的实现比较长，我们分段来阅读： public abstract class ViewGroup extends View implements ViewParent, ViewManager {    ......    protected boolean drawChild(Canvas canvas, View child, long drawingTime) {        boolean more = false;        final int cl = child.mLeft;        final int ct = child.mTop;        final int cr = child.mRight;        final int cb = child.mBottom;        final int flags = mGroupFlags;        这段代码首先获得子视图child的区域（cl, ct, cr, cb），以及当前视图组的标志位flags，以便接下来可以使用。另外，变量more的值用来表示子视图child是否还在显示动画。        我们接着往下阅读代码：         Transformation transformToApply = null;        final Animation a = child.getAnimation();        ......        if (a != null) {            ......            if (mChildTransformation == null) {                mChildTransformation = new Transformation();            }            more = a.getTransformation(drawingTime, mChildTransformation);            transformToApply = mChildTransformation;            ......        } else if ((flags & FLAG_SUPPORT_STATIC_TRANSFORMATIONS) ==                FLAG_SUPPORT_STATIC_TRANSFORMATIONS) {            if (mChildTransformation == null) {                mChildTransformation = new Transformation();            }            final boolean hasTransform = getChildStaticTransformation(child, mChildTransformation);            if (hasTransform) {                final int transformType = mChildTransformation.getTransformationType();                transformToApply = transformType != Transformation.TYPE_IDENTITY ?                        mChildTransformation : null;                ......            }        }        这段代码用来获得子视图child的变换矩阵transformToApply。获得了子视图child的变换矩阵transformToApply之后，我们就可以知道如何来显示它了。 在两种情况下，子视图child会被设置一个变换矩阵。第一种情况子视图child正在显示动画的过程中，第二种情况是当前视图组给每一个子视图设置了一个变换矩阵。下面我们就分别讨论这两种情况。        对于第一种情况，子视图child的成员函数getAnimation的返回值a不等于null，并且它所指向的一个Animation对象就是用来描述子视图child的动画的。获得了子视图的动画对象a之后，我们就可以调用它的成员函数getTransformation来继续执行它的动画了。如果该动画还需要继续执行，那么调用Animation对象a的成员函数getTransformation的返回值more就会等于true，并且会返回子视图child的接下来需要使用的变换矩阵，保存在ViewGroup类的成员变量mChildTransformation中。ViewGroup类的成员变量mChildTransformation最后又会保存在变量transformToApply中。        对于第二种情况，变量flags的FLAG_SUPPORT_STATIC_TRANSFORMATIONS位等于1，这时候调用ViewGroup类的成员函数getChildStaticTransformation就可以知道子视图child是否被设置了一个变换矩阵。如果设置了的话，那么ViewGroup类的成员函数getChildStaticTransformation的返回值hasTransform就会等于true。在这种情况下，ViewGroup类的成员变量mChildTransformation所描述的变换矩阵就是要应用在子视图child中的。不过有一个前提，即ViewGroup类的成员变量mChildTransformation所描述的变换矩阵不是一个单位矩阵，这是因为单位矩阵是没有变换效果的。如果ViewGroup类的成员变量mChildTransformation所描述的变换矩阵不是一个单位矩阵，那么它同样会被保存在变量transformToApply中。        我们继续往下阅读代码：         // Sets the flag as early as possible to allow draw() implementations        // to call invalidate() successfully when doing animations        child.mPrivateFlags |= DRAWN;        ......        child.computeScroll();        final int sx = child.mScrollX;        final int sy = child.mScrollY;        boolean scalingRequired = false;        Bitmap cache = null;        if ((flags & FLAG_CHILDREN_DRAWN_WITH_CACHE) == FLAG_CHILDREN_DRAWN_WITH_CACHE ||                (flags & FLAG_ALWAYS_DRAWN_WITH_CACHE) == FLAG_ALWAYS_DRAWN_WITH_CACHE) {            cache = child.getDrawingCache(true);            if (mAttachInfo != null) scalingRequired = mAttachInfo.mScalingRequired;        }        final boolean hasNoCache = cache == null;        这段代码执行以下三个操作：         1. 将子视图child的标志值mPrivateFlags的DRAWN设置为1，因为接下来它就会被绘制了。         2. 计算子视图child的滚动位置，这是通过调用子视图child的成员函数computeScroll来实现的。计算好子视图child的滚动位置之后，我们就可以通过它的成员变量mScrollX和mScrollY来获得它在X轴和Y轴上的偏移了。这两个偏移值保存在变量sx和sy中。         3. 检查变量flags的FLAG_CHILDREN_DRAWN_WITH_CACHE位或者FLAG_ALWAYS_DRAWN_WITH_CACHE位是否等于1。如果其中的一个等于1的话，那么就说明子视图是使用缓冲方式来绘制，即它的UI来缓冲在一个Bitmap里面，通过调用子视图child的成员函数getDrawingCache就可以获得这个Bitmap，并且保存在变量cache中。同时，通过ViewGroup类的成员变量mAttachInfo所指向的一个AttachInfo对象的成员变量mScalingRequired还可以知道子视图是否要进行缩放。如果需要缩放，那么变量scalingRequired的值就会等于true。另外，如果子视图child有一个缓冲的Bitmap，那么变量hasNoCache的值就会等于false。         我们继续往下阅读代码：         final int restoreTo = canvas.save();        if (hasNoCache) {            canvas.translate(cl - sx, ct - sy);        } else {            canvas.translate(cl, ct);            if (scalingRequired) {                // mAttachInfo cannot be null, otherwise scalingRequired == false                final float scale = 1.0f / mAttachInfo.mApplicationScale;                canvas.scale(scale, scale);            }        }        float alpha = 1.0f;        if (transformToApply != null) {            ......            alpha = transformToApply.getAlpha();                        ......        }        ......        if ((flags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {            if (hasNoCache) {                canvas.clipRect(sx, sy, sx + (cr - cl), sy + (cb - ct));            } else {                if (!scalingRequired) {                    canvas.clipRect(0, 0, cr - cl, cb - ct);                } else {                    canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());                }            }        }        这段代码用来设置子视图child的偏移、Alpha通道以及裁剪区域：         1. 如果子视图child不是以缓冲的方式来绘制的，那么它的偏移值就需要同时考虑它在X轴和Y轴上的起始位置（cl, ct）以及滚动值sx、sy；如果子视图child是以缓冲的方式来绘制的，那么就不需要考虑它在X轴和Y轴上的滚动位置sx和sy，而只需要考虑它在X轴和Y轴上的起始位置（cl, ct），这是因为它所缓冲的Bitmap已经包含了滚动信息。注意，在子视图child是以缓冲的方式来绘制的情况中，如果变量scalingRequired的值等于true，那么这段代码同时还需要为子视图child设置一个缩放因子，以便接下来可以同步缓冲的Bitmap的所表示的大小。         2. 如果子视图child此时被设置了一个变换矩阵transformToApply，那么一般它就会有一个Alpha值。例如，前面提到，当子视图child还处理动画显示的状态时，它就会有一个变换矩阵，而这个动画一般会有透明的效果，因此，就会有一个Alpha值。通过调用变量transformToApply所指向的一个Transformation对象的成员函数getAlpha就可以获得子视图child的Alpha值，保存在变量alpha中。如果子视图child此时没有被设置变换矩阵的话，那么它的Alpha值alpha就会等于1.0，表示不是透明的。        3. 如果变量flags的FLAG_CLIP_CHILDREN位等于1，那么就说明需要为子视图child设置一个剪裁区域。在设置子视图child的剪裁区域时，同样是需要考虑子视图child是否使用缓冲方式来绘制。如果不使用缓冲方式来会绘制，那么子视图child的剪裁区域就需要同时考虑它在X轴和Y轴上的起始位置（cl, ct）以及滚动值sx、sy；如果不是使用缓冲方式来会绘制，那么就不需要考虑它在X轴和Y轴上的滚动位置sx和sy。注意，在子视图child是以缓冲的方式来绘制的情况中，如果变量scalingRequired的值等于false，那么它的剪裁区域的宽度和高度就分别为（cr - cl）和（cb - ct），否则的话，它的剪裁区域的宽度和高度就等于上一次的缓冲Bitmap的宽度和宽度，这是因为对于后者来说，前面在设置子视图child的偏移时，已经同时设置过它的缩放因子了。        注意，在子视图child的偏移、Alpha通道以及裁剪区域之前，这段代码首先会保存在参数canvas所描述的一块画布的堆栈状态，以便在绘制完成子视图child的UI之后，可以恢复这块画布的堆栈状态来绘制其它子视图的UI。保存在参数canvas所描述的一块画布的堆栈状态是通过调用参数canvas所指向的一个Canvas对象的成员函数save来实现的。        我们继续往下阅读代码：         if (hasNoCache) {            // Fast path for layouts with no backgrounds            if ((child.mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {                ......                child.dispatchDraw(canvas);            } else {                child.draw(canvas);            }        } else {            final Paint cachePaint = mCachePaint;            if (alpha < 1.0f) {                cachePaint.setAlpha((int) (alpha * 255));                mGroupFlags |= FLAG_ALPHA_LOWER_THAN_ONE;            } else if  ((flags & FLAG_ALPHA_LOWER_THAN_ONE) == FLAG_ALPHA_LOWER_THAN_ONE) {                cachePaint.setAlpha(255);                mGroupFlags &= ~FLAG_ALPHA_LOWER_THAN_ONE;            }            ......            canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);        }        这段代码就是用来绘制子视图child的UI的了，分为两种情况来考虑：         1. 以非缓冲的方式来绘制。这时候需要检查子视图child的标志值mPrivateFlags的SKIP_DRAW位是否等于1。如果等于1的话，那么就说明需要跳过子视图child的绘制，但是需要绘制子视图child的子视图，否则的话，就需要先绘制子视图child的UI，再绘制它的子视图的UI。绘制子视图child的子视图是通过调用它的成员函数dispatchDraw来实现的，而绘制子视图child本身及其子视图是通过调用它的成员函数draw来实现的。         2. 以缓冲的方式来绘制。这时候只需要将上一次的缓冲的Bitmap对象cache绘制到参数canvas所描述的一块画布上面就行了。在绘制之前，需要先设置用来绘制Bitmap对象cache的一个Paint对象的Alpha值，这个Paint对象保存在ViewGroup类的成员变量mCachePaint中。这个Alpha值保存在变量alpha中，如果它的值小于1.0，那么就说明子视图child有一个透明值，因此，就需要将它设置到ViewGroup类的成员变量mCachePaint所指向的一个Paint对象中去，并且将ViewGroup类的成员变量mGroupFlags的FLAG_ALPHA_LOWER_THAN_ONE位设置为1。另一方面，如果变量alpha的值大于等于1.0，那么就说明不需要设置子视图child的透明值，但是如果之前设置过子视图child的透明值，即ViewGroup类的成员变量mGroupFlags的FLAG_ALPHA_LOWER_THAN_ONE位等于1，那么还需要修改ViewGroup类的成员变量mCachePaint所指向的一个Paint对象是不透明的，即将它的透明值设置为255，并且将ViewGroup类的成员变量mGroupFlags的FLAG_ALPHA_LOWER_THAN_ONE位重置为0。最后，就可以调用参数canvas所指向的一个Canvas对象的成员函数drawBitmap来绘制子视图child的UI了。        我们继续往下阅读最后一段代码：         canvas.restoreToCount(restoreTo);        ......        return more;    }    ......}       绘制完成子视图child的UI之后，就可以恢复参数canvas所描述的一块画布的堆栈状态了，这是通过调用参数canvas所指向的一个Canvas对象的成员函数restoreToCount来实现的。        ViewGroup类的成员函数drawChild最后就将变量more的值返回给调用者了，以便调用者可以知道当前正在绘制的子视图child是否还处于动画状态中。        从上面的分析就可以知道，当子视图child不是以非缓冲模式来绘制，并且它需要绘制自己及其子视图时，它的成员函数draw就会被调用，这时候就会重复执行Step 8、Step 9和Step 10，直到所有子孙视图都绘制完成为止。        这一步执行完成之后，应用程序窗口的UI就全部绘制到在前面的Step 2中所获得的一块画布上面去了，返回到前面的Step 1中，即ViewRoot类的成员函数draw中，接下来就会Java层的Surface类的成员函数unlockCanvasAndPost来请求SurfaceFlinger服务渲染这块画布里面所包含的一个图形缓冲区了。        接下来，我们就继续分析Java层的Surface类的成员函数unlockCanvasAndPost的实现。        Step 11. Surface.unlockCanvasAndPost public class Surface implements Parcelable {    ......    /** unlock the surface and asks a page flip */    public native   void unlockCanvasAndPost(Canvas canvas);     ......}       这个函数定义在文件frameworks/base/core/java/android/view/Surface.java中。        Surface类的成员函数unlockCanvasAndPost是一个JNI方法，它是由C++层的函数Surface_unlockCanvasAndPost来实现的，如下所示： static void Surface_unlockCanvasAndPost(        JNIEnv* env, jobject clazz, jobject argCanvas){    jobject canvas = env->GetObjectField(clazz, so.canvas);    if (canvas != argCanvas) {        doThrow(env, \"java/lang/IllegalArgumentException\", NULL);        return;    }    const sp<Surface>& surface(getSurface(env, clazz));    if (!Surface::isValid(surface))        return;    // detach the canvas from the surface    SkCanvas* nativeCanvas = (SkCanvas*)env->GetIntField(canvas, no.native_canvas);    int saveCount = env->GetIntField(clazz, so.saveCount);    nativeCanvas->restoreToCount(saveCount);    nativeCanvas->setBitmapDevice(SkBitmap());    env->SetIntField(clazz, so.saveCount, 0);    // unlock surface    status_t err = surface->unlockAndPost();    if (err < 0) {        doThrow(env, \"java/lang/IllegalArgumentException\", NULL);    }}         这个函数定义在文件frameworks/base/core/jni/android_view_Surface.cpp中。         参数clazz指向的是一个Java层的Surface对象，用来描述当前正在绘制的应用程序窗口的绘图表面，而参数argCanvas指向的是一个Java层的Canvas对象。         参数clazz指向的是一个Java层的Surface对象的成员变量mCanvas所指向的一个Canvas对象canvas应当等于参数argCanvas指向的是一个Java层的Canvas对象，否则的话，函数就会抛出一个异常。        从前面Android应用程序窗口（Activity）的绘图表面（Surface）的创建过程分析一文可以知道，每一个Java层的Surface对象在C++层都有一个对应的Surface对象。因此，函数t就可以通过调用另外一个函数getSurface来获得与参数clazz所指向的是一个Java层的Surface对象所对应的C++层的Surface对象surface。C++层的Surface类的静态成员函数isValid用来验证Surface对象surface是否已经连接到SurfaceFlinger服务中。如果还没有连接到，那么函数就会出错返回了。        通过了上述的合法性检查之后，函数接下来主要就是做两件事情：        1. 恢复变量canvas所描述的一块画布的堆栈状态。变量canvas所描述的一块画布是在前面的Step 2中开始初始化的，每次应用程序窗口在上面绘制完成UI之后，我们都应该恢复它的堆栈状态，以便下一次使用时不会受上一次影响。变量canvas指向的是一个Java层的Canvas对象，函数首先找到与它所对应的一个C++层的SkCanvas对象nativeCanvas，然后就可以调用这个SkCanvas对象nativeCanvas的成员函数restoreToCount来恢复它所描述的一块画布的堆栈状态了。这块画布在绘制应用程序窗口UI前的堆栈状态保存在参数clazz所指向的一个Java层的Surface对象的成员变量mSaveCount中。因此，函数就先获得参数clazz所指向的一个Java层的Surface对象的成员变量mSaveCount的值，然后再以它为参数来调用SkCanvas对象nativeCanvas的成员函数restoreToCount，这样就可以恢复画布的堆栈状态了。        2. 请求SurfaceFlinger服务渲染Surface对象surface所描述的应用程序窗口的绘图表面。应用程序窗口的UI是绘制在SkCanvas对象nativeCanvas所描述的一块画布上的，而这块画布所使用的图形缓冲区是保存在Surface对象surface的内部的，因此，函数就调用Surface对象surface的成员函数unlockAndPost来请求SurfaceFlinger服务渲染这块图形缓冲区。        接下来，我们就继续分析C++层的Surface类的成员函数unlockAndPost的实现，以便可以了解用来绘制应用程序窗口UI的图形缓冲区是如何渲染的。        Step 12. Surface.unlockAndPost status_t Surface::unlockAndPost(){    if (mLockedBuffer == 0) {        LOGE(\"Surface::unlockAndPost failed, no locked buffer\");        return INVALID_OPERATION;    }    status_t err = mLockedBuffer->unlock();    LOGE_IF(err, \"failed unlocking buffer (%p)\", mLockedBuffer->handle);    err = queueBuffer(mLockedBuffer.get());    LOGE_IF(err, \"queueBuffer (idx=%d) failed (%s)\",            getBufferIndex(mLockedBuffer), strerror(-err));    mPostedBuffer = mLockedBuffer;    mLockedBuffer = 0;    return err;}        这个函数定义在文件frameworks/base/libs/surfaceflinger_client/Surface.cpp中。         从前面的Step 3可以知道，应用程序窗口当前正在使用的图形缓冲区保存在Surface类的成员变量mLockedBuffer中，因此，Surface类的成员函数unlockAndPost的目标就是要将它交给SurfaceFlinger服务来渲染，这是通过调用另外一个成员函数queueBuffer来实现的。在前面Android应用程序请求SurfaceFlinger服务渲染Surface的过程分析一文中，我们已经分析过Surface类的成员函数queueBuffer的实现了，它主要就是向应用程序窗口的待渲染图形缓冲区队列中添加一个图形缓冲区，然后再请请求SurfaceFlinger服务来渲染这个图形缓冲区。         在渲染成员变量mLockedBuffer所描述的一个图形缓冲区之前，Surface类的成员函数unlockAndPost还会调用它的成员函数unlock来执行一个“解锁”操作。从前面的Step 3可以知道，成员变量mLockedBuffer所描述的一个图形缓冲区在交给应用程序窗口使用之前，它会被执行一个“锁定”的操作，即它的成员函数lock会被调用，因此，这里执行的“解锁”操作是与前面的“锁定”操作相对应的。事实上，对成员变量mLockedBuffer所描述的一个图形缓冲区进行锁定，主要是为了获得这个图形缓冲区的地址，是否真的要对个图形缓冲区进行锁定，是由HAL层模块Gralloc的实现来决定的。        在请求SurfaceFlinger服务渲染了成员变量mLockedBuffer所描述的一个图形缓冲区之后，Surface类的成员函数unlockAndPost还会把成员变量mLockedBuffer所描述的一个图形缓冲区保存在另外一个成员变量mPostedBuffer中，表示这个图形缓冲区已经变成是正在渲染的图形缓冲区了，或者说是前端缓冲区了。        最后，Surface类的成员函数unlockAndPost就把成员变量mLockedBuffer的值设置为0，这样就可以将应用程序窗口下一次请求分配和使用的图形缓冲区保存在它里面。        Surface类的成员变量mLockedBuffer指向的是一个GraphicBuffer对象，接下来我们就继续分析它的成员函数unlock的实现，以便可以了解它所描述的图形缓冲区的“解锁”过程。        Step 13. GraphicBuffer.unlock status_t GraphicBuffer::unlock(){    status_t res = getBufferMapper().unlock(handle);    return res;}        这个函数定义在文件frameworks/base/libs/ui/GraphicBuffer.cpp中。         从前面的Step 4可以知道，GraphicBuffer类的成员变量handle用来描述当前正在处理的图形缓冲区的句柄，而GraphicBuffer类的成员函数getBufferMapper返回的是一个GraphicBufferMapper对象。有了这个GraphicBufferMapper对象之后，就可以调用它的成员函数unlock解锁成员变量handle所描述的一个图形缓冲区了。         接下来，我们就继续分析GraphicBufferMapper类的成员函数unlock的实现。         Step 14. GraphicBufferMapper.unlock status_t GraphicBufferMapper::unlock(buffer_handle_t handle){    status_t err;    if (sw_gralloc_handle_t::validate(handle) < 0) {        err = mAllocMod->unlock(mAllocMod, handle);    } else {        err = sw_gralloc_handle_t::unlock((sw_gralloc_handle_t*)handle);    }    LOGW_IF(err, \"unlock(...) failed %d (%s)\", err, strerror(-err));    return err;}       这个函数定义在文件frameworks/base/libs/ui/GraphicBufferMapper.cpp。        从前面的Step 5可以知道，参数handle所描述的图形缓冲区是在HAL模块Gralloc中分配的，这个HAL模块Gralloc是由GraphicBufferMapper类的成员变量mAllocMod来描述的，因此，函数就终就会调用GraphicBufferMapper类的成员变量mAllocMod所描述的一个HAL模块Gralloc的成员函数unlock来解锁参数andle所描述的一个图形缓冲区。HAL模块Gralloc的成员函数unlock的实现可以参考前面Android帧缓冲区（Frame Buffer）硬件抽象层（HAL）模块Gralloc的实现原理分析一文，这里不再详述。        至此，我们就分析完成Android应用程序窗口的渲染过程了，从中就可以看出：        1. 渲染Android应用程序窗口UI需要经过三步曲：测量、布局、绘制。        2. Android应用程序窗口UI首先是使用Skia图形库API来绘制在一块画布上，实际地是绘制在这块画布里面的一个图形缓冲区中，这个图形缓冲区最终会被交给SurfaceFlinger服务，而SurfaceFlinger服务再使用OpenGL图形库API来将这个图形缓冲区渲染到硬件帧缓冲区中。        Android应用程序窗口的渲染过程分析完成之后，Android应用程序窗口的实现框架就分析完成了，重新学习请回到Android应用程序窗口（Activity）实现框架简要介绍和学习计划一文中。        在Android应用程序窗口（Activity）实现框架简要介绍和学习计划这一系列文章中，我们主要是从单个应用程序窗口的角度来分析的。但是，Android系统在运行的过程中，需要管理的是一系列的应用程序窗口，并且这些应用程序窗口的类型可能各不相同，并且相互影响。因此，Android的窗口管理系统是非常复杂的。在接下来的一个系列的文章中，我们就将详细地分析Android窗口管理服务WindowManagerService的实现，以便可以从系统的角度来分析应用程序窗口的实现。敬请关注！","title":"Android应用程序窗口（Activity）的测量（Measure）、布局（Layout）和绘制（Draw）过程分析"},{"content":"【木头Cocos2d-x 030】Lua篇（第05章）：C++调用Lua的函数   唉，今天心情有点糟糕，我就少说一些啰嗦的话了。 （旁白：太好了...）   上一章传送门：http://blog.csdn.net/musicvs/article/details/8445079 笨木头花心贡献，啥？花心？不呢，是用心~ 转载请注明，原文地址：http://blog.csdn.net/musicvs/article/details/8451361   正文：   经过前面几章的介绍，相信大家对Lua的堆栈已经比较熟悉了，如果还不是很熟悉的朋友，建议多看几遍前面的教程，或者多敲几次代码。 那么，如果已经对Lua的堆栈比较熟悉，接下来的内容就很简单了。 今天我们来看看C++如何调用Lua的函数，先看看现在Lua文件是什么样的： -- helloLua.lua文件myName = \"beauty girl\"helloTable = {name = \"mutou\", IQ = 125}function helloAdd(num1, num2)\treturn (num1 + num2)end;   我们看到多了个helloAdd函数，那么，现在我们要用C++调用这个函数。 （旁白：肯定又要用到getglobal了，每次都有它~！= =）   直接上代码了： /* C++调用lua的函数 */void HelloLua::demo3() {    lua_State* pL = lua_open();    luaopen_base(pL);    /* 执行脚本 */    luaL_dofile(pL, \"helloLua.lua\");    /* 把helloAdd函数对象放到栈中 */    lua_getglobal(pL, \"helloAdd\");    /* 把函数所需要的参数入栈 */    lua_pushnumber(pL, 10);    lua_pushnumber(pL, 5);    /*         执行函数，第一个参数表示函数的参数个数，第二个参数表示函数返回值个数 ，        Lua会先去堆栈取出参数，然后再取出函数对象，开始执行函数    */    lua_call(pL, 2, 1);    int iResult = lua_tonumber(pL, -1);    CCLOG(\"iResult = %d\", iResult);}   简单说明一下步骤： 1） 执行脚本（旁白：我就知道你会说废话。。。） 2） 将helloAdd函数放到栈中：lua_getglobal(pL, “helloAdd”) 。（旁白：看吧，我就知道~！） 3） helloAdd有2个参数，我们要把参数传递给lua，所以2个参数都要放到栈里。 4） 第2和第3步已经把函数所需要的数据都放到栈里了，接下来只要告诉lua去栈里取数据，执行函数~！ 调用lua_call即可，注释已经很详细了，这里就不重复了。 （旁白：太简单了点吧，反正不管做什么事情，把东西丢到栈里，然后从栈里取东西，就OK了~你可以滚了，以后教程我来写，你负责吐槽~）   来，大家忽略旁白，教程什么的还是我来写比较好，主要是，吐槽这工作，不符合我的身份~ （旁白：...我有种被打击了的感觉）   本章到此结束，很简单吧？~ 下一章我们介绍在Lua中调用C++的函数~！ （旁白：这个我喜欢~！）     .","title":"【木头Cocos2d-x 030】Lua篇（第05章）：C++调用Lua的函数"},{"content":"Objective-C中的@property、@synthesize及点语法都是与两个函数有关的，一是setter函数，另一个是getter函数 以前我们是这样来定义setter与getter函数的 @interface Dog:NSObject{\tint age;}-(void)setAge:(int)newAge;-(void)age;@end@implementation Dog-(void)setAge:(int)newAge{\tage = newAge;}-(void)age{\treturn age;}@end而如今我们有了更好的方法： @property是让编译器自动产生setter与getter的函数声明 @sythesize就是让编译器自动实现setter与getter函数 现如今我们这样写就可以了 @interface Dog:NSObject{\tint age;}@property int age;@end@implementation Dog@synthesize age;}@end 当@properpty后是非基本数据类型时，可以加参数 有关点语法： dog.age = 10; dogAge = [dog ahe]; 编译器会把dog.age = 10;展开成【dog setAge:10]; 会把dogAge = dog.age;展开成dogAge = [dog age]; 点语法在等号的左边，它就是一个setter函数，点语法在等号的右边就是一个getter函数。 参考一下前辈们的总结： 声明property的语法为：@property (参数1,参数2) 类型 名字; @property(nonatomic,retain) UIWindow *window;  其中参数主要分为三类： 读写属性： （readwrite/readonly） setter语意：（assign/retain/copy） 原子性： （atomicity/nonatomic）   各参数意义如下：   readwrite: 产生setter\\getter方法 readonly: 只产生简单的getter,没有setter。 assign: 默认类型,setter方法直接赋值，而不进行retain操作 retain: setter方法对参数进行release旧值，再retain新值。 copy: setter方法进行Copy操作，与retain一样 nonatomic: 禁止多线程，变量保护，提高性能   参数类型 参数中比较复杂的是retain和copy，具体分析如下：   getter 分析 1、 @property(nonatomic,retain)test* thetest;  @property(nonatomic ,copy)test* thetest;  等效代码： -(void)thetest  {  　　return thetest;  }  2、 @property(retain)test* thetest;  @property(copy)test* thetest; 等效代码： -(void)thetest  {      [thetest retain];      return [thetest autorelease];  }  setter分析 @property(nonatomic,retain)test* thetest;  @property(retain)test* thetest; 等效于： -(void)setThetest:(test *)newThetest {      if (thetest!= newThetest) {  　　      [thetestrelease];  　　      thetest= [newThetest retain];      }  }   2、 @property(nonatomic,copy)test* thetest;  @property(copy)test* thetest;   等效于： -(void)setThetest:(test *)newThetest {      if (thetest!= newThetest) {  　　      [thetest release];  　　      thetest= [newThetest copy];  nonatomic 如果使用多线程，有时会出现两个线程互相等待对方导致锁死的情况（具体可以搜下线程方面的注意事项去了解）。在没有(nonatomic)的情况下，即默认(atomic)，会防止这种线程互斥出现，但是会消耗一定的资源。所以如果不是多线程的程序，打上(nonatomic)即可   retain 代码说明 如果只是@property NSString*str; 则通过@synthesize自动生成的setter代码为： -(void)setStr:(NSString*)value{      str=value;  }  如果是@property(retain)NSString*str; 则自动的setter内容为： -(void)setStr:(NSString*)v{      if(v!=str){          [str release];          str=[v retain];      }  }  在这个看到的一个比较纠结的地方 @synthesize window=_window; 意思是说，window 属性为 _window 实例变量合成访问器方法。 也就是说，window属性生成存取方法是setWindow，这个setWindow方法就是_window变量的存取方法，它操作的就是_window这个变量。 下面是一个常见的例子 @interface MyClass:NSObject{ 　　MyObjecct *_myObject; } @property(nonamtic, retain) MyObjecct *myObject; @end @implementatin MyClass @synthesize myObject=_myObject; 这个类中声明了一个变量_myObject，又声明了一个属性叫myObject,然后用@synthesize生成了属性myObject的存取方法，这个存取方法的名字应该是：setmyObject和getmyObject。@synthesize myObject=_myObject的含义就是属性myObject的存取方法是做用于_myObject这个变量的。 这种用法在Apple的Sample Code中很常见","title":"[置顶] Objective-C中的@property、@synthesize及点语法"},{"content":"1、gps测试显示：能搜到11个星，五个信号超过40！这说明GPS的性能是不用怀疑的！ 2、30W摄像头测试 3、wifi测试 4、3G测试 5、HDMI测试 没有实际拍摄图片，但是测试友坚的这款exynos4412开发板不仅画面能同步了，而且还同步了声音！ 6、支持两路sd卡，5个usbhost，支持32Gu盘，鼠标等挂载！ 7、此外还支持蓝牙！这些模块除3G外都是提供驱动源码的，3G只有bin文件！ 总而言之：这块开发板在软件方面调试了比较多的模块，系统功能调试比较强，能大大的缩短开发周期~","title":"三星exynos4412开发板评测"},{"content":"packages\\apps\\Browser\\src\\com\\android\\browser\\BrowserBookmarksPage.java   Display newDisplay = getActivity().getWindowManager().getDefaultDisplay();   int width = newDisplay.getWidth();   mGrid.setIndicatorBounds(width-50, width);   mGrid为Expandablelistview 的对象","title":"阿语波斯语问题三（Browser中Expandablelistview 图标应该在右边显示（应在APK中修改））"},{"content":"D:\\linux\\linuxkernel\\WORKING_DIRECTORY\\android-omap-20111108-gingerbread\\dalvik\\vm\\mterp\\out>gcc -c InterpAsm-x86.S -o InterpAsm-x86.o InterpAsm-x86.S: Assembler messages: InterpAsm-x86.S:6291: Warning: .size pseudo-op used outside of .def/.endef ignored. InterpAsm-x86.S:6291: Error: junk at end of line, first unrecognized character is `d' http://code.ohloh.net/search?s=.def%20%20.size%20%20%09.endef&p=3&browser=Default&pp=0&fe=S&mp=1&ml=1&me=0&md=1&ff=1&filterChecked=true http://code.ohloh.net/file?fid=11GdDFv2c7RhQQDUSssC_CXDZ2w&cid=vzrgujR7aEs&s=.def%20%20.size%20%20%09.endef&browser=Default#L223 d:\\linux\\linuxkernel\\WORKING_DIRECTORY\\ango\\libdvm\\doc\\inffast.S #if defined( GAS_COFF ) /* coff externals have underscores */ #define inflate_fast _inflate_fast #define inflate_fast_use_mmx _inflate_fast_use_mmx #endif /* GAS_COFF */ #if defined( GAS_COFF ) /* coff info: scl 2 = extern, type 32 = function */ .def inflate_fast; .scl 2; .type 32; .endef #endif no .size for COFF #if defined( GAS_ELF ) /* elf info */ .type inflate_fast,@function .size inflate_fast,.-inflate_fast #endif when compiled, put InterpAsm-x86.o into the linker options. Done.","title":"diff between coff and elf"},{"content":"cocos2d-x作为目前非常火热的开源跨平台游戏引擎解决方案，个人非常看好。 c++虽然开发速度较慢，但是由于每个平台都支持c++和opengles，所以节省了大量的代码移植时间，因此是首选的跨平台开发解决方案。 cocos2d-x的大致开发流程是，首先使用win32版进行代码编写并完成游戏，然后将代码迁移到对应的开发环境上进行交叉编译完成游戏打包，如iphone上是mac+xcode，android是eclipse+ADK+NDK。实现一处编码，到处编译。 因为主要开发都是在win32环境下进行的，所以我们首先研究如何配置win32开发环境。只讨论在windows下，用vs开发的环境，其他交叉编译需要的环境，后面讲到。     第一部分：如何运行helloworld #1.安装visual studio2008 vs2010是cocos2d-x运行最稳定的版本。 官方下载vs2010 visual assist x自备，vs序列号自备  #2.安装cocos2d-x引擎 http://cocos2d-x.org/projects/cocos2d-x/wiki/Download 从网站上下载cocos2d-x，并解压到自定义的路径下 #3.测试helloworld 我们使用windows版的helloworld，打开cocos2d-x引擎安装目录下的cocos2d-win32.vc2010.sln 将helloworld设为启动项目 -》生成 -》调试-启动新实例，如图所示   第二部分：如何添加新项目 #1 安装应用程序向导 运行 install-templates-msvc.bat，cocos2d-x 应用程序向导就会自动安装到VS环境下 #2 建立新项目 右键单击解决方案-》添加-》新项目-》cocos2d-x-win32 application 注意：目录层级关系，缺省情况下，应该设置在cocos2d-x引擎安装的目录下，否则在编译链接时可能会找不到文件     然后，按照之前的步骤编译运行即可，运行效果同上一部分的图   参考资料： http://www.cocos2d-x.org  《cocos2d-x手机游戏开发》","title":"cocos2d-x学习笔记01:VS开发环境windows平台搭建"},{"content":"三星四核开发板UT-Exynos 4412 调试android4.0.4 GPS 功能，信号超强 硬件平台：UT-Exynos 4412SamSung A9四核4412开发平台【友坚提供】 软件平台：Kernel3.0.15                     Android4.0.4 调试：www.urbetter.com 简介；UT-Exynos 4412开发板，SamSung ARM Cortex-A9四核 4412开发平台，功能强大，接口齐全，是A8/A9(双核4212 )的升级产品。主频1.4-1.6GHZ，标配内存2GB DDR3，标配8GB iNand存储；配置10.1寸 1024*800 LVDS屏+多点电容屏；稳定快速流畅运行android4.0.4，并支持 无线wifi 蓝牙 摄像头 GPS 联通3G等功能，做到功能齐全 接口丰富的4412开发平台，适合高校 培训机构 方案评估认证等参考使用。 日前调试UT-Exynos 4412开发板android4.0.4调试GPS稳定，信号超强，有三个超过40，其中有一个猛冲50，以下是实测图片，分享给给位嵌入式开发人员以及网友 以下是接口介绍 www.urbetter.com,欢迎交流","title":"UT-Exynos 4412SamSung A9四核4412开发平台调试android4.0.4 GPS 功能，信号超强"},{"content":"主要参考网络文章MINIGUI移植到2440嵌入式网络博客，作者：刘溯奇 MiniGUI 1.3.3 移植详解，作者：大漠孤狼 说明： 因为要用MINIGUI做PDA，得把MINIGUI移植到我的开发板MINIGUI上，移植成功，支持PNG， JPG，鼠标和触摸屏可以用，但触摸屏不准，需要较正，较正本打算用tslib.1.3，移植成功 后，MINIGUI要使用它做为IAL，还需对libminigui1.6.10/res/ial/2410.c进行修改并用 SMDK2410做为它的IAL，但经查1.6.10里己经没有发布2410.c，V1.3.3里是有的。 硬件环境： Host：X86PC Target：友善之臂mini2440开发板 软件环境： Host：VMware虚拟机下的redhat linux 9.0(完全安装) Target：arm-linux             kernel:linux-2.6.13 Crosstool: arm-linux-gcc-3.4.1 2.    准备以下源码包（下载） http://www.minigui.org/downloads 开发库：libminigui-1.6.10.tar.gz 资源文件：minigui-res-1.6.10.tar.gz 示例程序：mg-samples-str-1.6.10.tar.gz 3.    编译安装 (1) 准备工作 在redhat linux 9.0下新建工作目录 [root@localhost /]# mkdir /minigui              工作目录   [root@localhost /]# mkdir /minigui/compressed /minigui/source [root@localhost /]# cd /minigui/compressed        进入工作目录 说明：把第2步下载的源码包放到该目录中，即/minigui/compressed (2)编译安装minigui-res-1.6.10.tar.gz 说明：minigui 所使用的资源，包括基本字体、图标、位图和鼠标光标。 [root@localhost compressed]# tar xzvf minigui-res-1.6.10.tar.gz –C ../source [root@localhost compressed]# cd ../source/minigui-res-1.6.10 [root@localhost minigui-res-1.6.10]# make install 把生成的……/minigui/res目录下的所有文件拷贝到开发板上，其开发板上的目录如下形式/usr/local/lib/minigui/res/……，实际上这个目录与配置文件MiniGUI.cfg里的相应内容的目录一致，以便找到相应的资源。 （3）支持jpeg和png 首先安装 zlib 库，这个是后面的库的编译基础。 http://www.zlib.net/zlib-1.2.3.tar.gz  400多K，去下载吧， 下载到目录 /opt/mini2440 下 [user]# tar zxf zlib-1.2.3.tar.gz 由于 zlib 库的configure 脚本不支持交叉编译选项，只好自己动用了，手动临时把 gcc 修改成指向我们的交叉编译器 arm-linux-gcc [Root]# cd /usr/bin [Root]# mv gcc gcc_back [Root]# ln -s /usr/local/arm/3.4.1/bin/arm-linux-gcc ./gcc [Root]# mv ld ld_back [Root]# ln -s /usr/local/arm/3.4.1/bin/arm-linux-ld ./ld OK ，修改完成后回到 /opt/mini2410/zlib-1.2.3 目录下 [user]#  ./configure --prefix=/usr/local/arm/3.4.1/arm-linux/ --shared   注意：这里配置指向 /usr/local/arm/3.4.1/arm-linux/ 目录，会自动安装在 /usr/local/arm/3.4.1/arm-linux/ [include,lib] 目录下，千万不要装错目录了，不然后面会找不到这个库的 [user]#  make [Root]# make install 安装完后检查一下目录 /usr/local/arm/3.4.1/arm-linux/ [include,lib] ，假如 include 中没有 zlib.h 之类的头文件，lib 中没有 libz.so.1.2.3 ，那就自己手动拷到这些目录下去，记着拷的时候把所有的 *.h  都需要拷过去，在拷库的时候用 cp –a libz.* /…./lib  就行，要用上 –a 选项 记着把刚才改过的 gcc 再改回去，不然后面会出错的！！！！！ 改回的命令是： cd /usr/bin rm gcc mv gcc_back gcc 安装 png 库，这个是用来显示 png 图形的，MiniGUI 里很多图都是 png 的，如果没有这个库，你的 MiniGUI 将无法正常工作，切记切记！ http://superb-east.dl.sourceforge.net/sourceforge/libpng/libpng-1.0.10rc1.tar.gz 还是那句话，库不要用最新的，最新的容易有问题，用这个老一点的就没问题了，呵 [user]# tar zxf libpng-1.0.10rc1.tar.gz [user]# cd libpng-1.0.10rc1 Libpng 不提供有效的 configure 脚本，所以只好自己动手改 Makefile 文件了 [user]# cp scripts/makefile.linux  Makefile   //把 Scripts  下的一个 makefile 拷出来自己动手改 [user]# vi Makefile    // 自己动手改 CC=arm-linux-gcc    //修改这里 # where \"make install\" puts libpng.a, libpng.so*, png.h and pngconf.h prefix=/usr/local/arm/3.4.1/arm-linux     //修改这里 # Where the zlib library and include files are located #ZLIBLIB=/usr/local/lib #ZLIBINC=/usr/local/include ZLIBLIB=/usr/local/arm/3.4.1/arm-linux/lib   //修改这里 ZLIBINC=/usr/local/arm/3.4.1/arm-linux/include   //修改这里 好了，保存，然后去编译吧 [user]#  make [user]#  make install 如果有错误，检查你前面的步骤哪个没做对 ：） 尤其是 zlib 的安装 还是前面说的，检查 /usr/local/arm/3.4.1/arm-linux/ [include,lib] 目录中有成功安装否，如果没有安装成功，那就自己把编译出来的东西拷过去。记着，*.h 和 .so 的文件都要拷。 OK，现在来安装 jpeg 库 http://www.minigui.org/downloads    自己去下载 [user]# tar zxf jpegsrc.v6b.tar.gz [user]# cd jpeg-6b [user]# ./configure --help    //可以查看它的配置选项 （首先在本机上编译一下，主要是它的 configure 文件设计得有问题，得先用 gcc 编译一个 dummy.c 的文件，然后才能后面编译，不然的话就会出现 libtool 找不到之类的错误） [user]# ./configure --enable-shared --enable-static [user]# make [user]# make clean 本机正常编译通过以后，[user]# make clean 清除掉，然后执行交叉编译 一般情况下用 [cdp@cdpserver jpeg-6b]$ ./configure --prefix=/usr/local/arm/3.4.1/arm-linux/ --host=arm-linux --enable-shared --enable-static --host=arm-linux   来指定交叉编译选项，可是这里死活它不认，所以改用别的方法，如下 [user]# ./configure --prefix=/usr/local/arm/3.4.1/arm-linux/ CC=arm-linux-gcc --enable-shared --enable-static [user]# make 安装前需要在 arm-linux 下建个目录，不然安装会出错 [Root]# mkdir –p /usr/local/arm/3.4.1/arm-linux/man/man1 [Root]# make install    // OK 了 一样，自己去检查一下安装是否成功 ：） 接下来就可以编译libminigui了 (4)安装 popt 库 PDA中的记事本程序要用到Popt,参考minigui1.3.3移植详步骤如下： 这个库在编译 mde 程序时需要使用，不然编译没法通过 ：） http://gd.tuwien.ac.at/utils/rpm.org/dist/rpm-4.1.x/popt-1.7.tar.gz  我是从这里下载的 [user]#  tar zxf popt-1.7.tar.gz [user]# cd popt-1.7 [user]# ./configure --prefix=/usr/local/arm/3.4.1/arm-linux/ --host=arm-linux --enable-shared --enable-static [user]# make [Root]# make install 一切很顺利，搞定了。 交叉编译环境设置好了！ (5)编译安装libminigui-1.6.10.tar.gz 说明：minigui函数库源代码。 [root@localhost minigui-res-1.6.10]# cd /minigui/compressed [root@localhost compressed]# tar xzvf libminigui-1.6.10.tar.gz –C ../source [root@localhost compressed]# cd ../source/libminigui-1.6.10 [root@localhost libminigui-1.6.10]# ./configure --prefix=/home/ --host=arm-linux --target=arm-linux --build=i386-linux CC=arm-linux-gcc --with-osname=linux --with-style=classic  --with-targetname=fbcon --enable-autoial --enable-rbf16 --disable-vbfsupport [root@localhost libminigui-1.6.10]# make [root@localhost libminigui-1.6.10]# make install 把/home/lib目录下的所有库文件（注：--prefix=/home/）拷贝到开发板上的/lib目录下，把/home/etc下的MiniGUI.cfg拷贝到开发板上的/etc目录下。 注：--disable-vbfsupport ，一定要注意这个选项，否则在开发板上运行示例程序时，提示找不到var bitmap font，实际上在开发板上的/usr/local/lib/minigui/res/font目录下没有var bitmap font字体库，至于如何支持它，没有深究。其他选项可通过./configure –h帮助查看，根据自己的开发板及项目需要控制相应的功能。 (6)编译 mg-samples-str-1.6.10.tar.gz 同上原理： 解压 [………]# ./configure –host=arm-linux [………]# make 把生成的可执行文件helloworld拷贝到开发板上的/usr/local/sbin目录下 (7) 配置 第一处：在开发板的/etc目录下建立ld.so.conf文件，并添加如下内容： /usr/local/lib /usr/lib /lib    #实际上添加这个库文件目录就行了，目的是运行PDA的时候，能找到相应的库文件，其他两个库目录可选，我加上了它，是为了系统扩展。 第二处：修改开发板上的/etc/MiniGUI.cfg文件 用编辑器打开，更改如下内容： [system] # GAL engine and default options gal_engine=fbcon #IAL engine ial_engine=cosole mdev=/dev/input/mice mtype=IMSP2 [fbcon] Defaultmode=240x320-16bpp    #我的LCD显示器是240x320像素的竖屏 与上述内容不一致的，请结合自己的开发板进行比较后，修改。 第三处： 在/etc/init.d/rcS脚本文件里添加如下内容： /bin/ln –s /dev/vc/0 /dev/tty0 如不加，则出现如下问题：NEWGAL>FBCON: Can''''''''''''''''t open /dev/tty0: No such file or directory NEWGAL: Set video mode failure. InitGUI: Can not initialize graphics engine! 注：就是使FBCON与你的FramBuffer设备关联 4.    测试 在超级终端运行交叉编译自己修改制作的PDA,命令如下： [………]# /usr/local/sbin/pda 或 在/etc/init.d/rcS脚本文件里添加如下内容： /usr/local/sbin/pda & 呵呵，minigui的PDA跑起来了，感觉超爽的。移植成功，MINIGUI的开源真不错，让我学到了不少东西，支持MINIGUI，支持飞漫！","title":"交叉编译移植MiniGUI1.6.10"},{"content":"广播： 主机之间一对所有的通讯模式，网络对其中每一台主机发出的信号都进行无条件复制并转发，所有主机都可以接收到所有信息（不管你是否需要），由于其不用路径选择，所以其网络成本可以很低廉。有线电视网就是典型的广播型网络，我们的电视机实际上是接受到所有频道的信号，但只将一个频道的信号还原成画面。在数据网络中也允许广播的存在，但其被限制在二层交换机的局域网范围内，禁止广播数据穿过路由器，防止广播数据影响大面积的主机。 广播的优点： 1）网络设备简单，维护简单，布网成本低廉 2）由于服务器不用向每个客户机单独发送数据，所以服务器流量负载极低。 广播的缺点： 1）无法针对每个客户的要求和时间及时提供个性化服务。 2）网络允许服务器提供数据的带宽有限，客户端的最大带宽＝服务总带宽。例如有线电视的客户端的线路支持100个频道（如果采用数字压缩技术，理论上可以提供500个频道），即使服务商有更大的财力配置更多的发送设备、改成光纤主干，也无法超过此极限。也就是说无法向众多客户提供更多样化、更加个性化的服务。 3）广播禁止允许在Internet宽带网上传输。 组播： 主机之间一对一组的通讯模式，也就是加入了同一个组的主机可以接受到此组内的所有数据，网络中的交换机和路由器只向有需求者复制并转发其所需数据。主机可以向路由器请求加入或退出某个组，网络中的路由器和交换机有选择的复制并传输数据，即只将组内数据传输给那些加入组的主机。这样既能一次将数据传输给多个有需要（加入组）的主机，又能保证不影响其他不需要（未加入组）的主机的其他通讯。 组播的优点： 1）需要相同数据流的客户端加入相同的组共享一条数据流，节省了服务器的负载。具备广播所具备的优点。 2）由于组播协议是根据接受者的需要对数据流进行复制转发，所以服务端的服务总带宽不受客户接入端带宽的限制。IP协议允许有2亿6千多万个组播，所以其提供的服务可以非常丰富。 3）此协议和单播协议一样允许在Internet宽带网上传输。 组播的缺点： 1）与单播协议相比没有纠错机制，发生丢包错包后难以弥补，但可以通过一定的容错机制和QOS加以弥补。 2）现行网络虽然都支持组播的传输，但在客户认证、QOS等方面还需要完善，这些缺点在理论上都有成熟的解决方案，只是需要逐步推广应用到现存网络当中 假设X代表所有的机器，Y代表X中的一部分机器，Z代表一组机器，1代表源机器，那么 1：1（也可以说1-1），那就是单播； 1：Y（也可以说1-Y），那就是多播 1：X 那就是广播； 1：Z 那就是组播。 泛播也叫任意播，是指某组中任意发送方对应拓朴结构中几个最接近的接收方之间的通信。而组播是指单个发送方对应一组选定接收方的一种通信。 冲突域（物理分段）：连接在同一导线上的所有工作站的集合，或者说是同一物理网段上所有节点的集合或以太网上竞争同一带宽的节点集合。也就是说，用Hub或者Repeater连接的所有节点可以被认为是在同一个冲突域内，它不会划分冲突域。由于广播域被认为是OSI中的第二层概念，所以象 Hub，交换机等第一，第二层设备连接的节点被认为都是在同一个广播域。 冲突域（Collision Domain）：一组与同一条物理介质相连的设备，其中任何两台设备同时访问该介质都将导致冲突，冲突域中同一时间内只有一台机器能够发送数据。 广播域（Broadcast Domain）：网络中一组相互接收广播消息的设备。 第一层设备如集线器，与之连接的所有设备都属于同一个冲突域和同一个广播域； 第二层设备如交换机和网桥，将网络划分成多个网段，每个网段是一个独立的冲突域，但是相连的所有设备是一个广播域，交换机的每个端口就是一个冲突域； 第三层设备如路由器，将网络划分为多个冲突域和广播域。 以太网使用载波侦听多路访问/冲突检测（Carrier Sense Multi-Access/Collision Detection）技术以减少冲突的发生。     单播： 主机之间“一对一”的通讯模式，网络中的交换机和路由器对数据只进行转发不进行复制。 单播的优点： 1. 服务器及时响应客户机的请求 2. 服务器针对每个客户不同请求发送不同数据，容易实现个性化服务。 单播的缺点： 1. 在客户数量大、每个客户机流量大的流媒体应用中服务器不堪重负。 2. 现有的网络带宽是金字塔结构，如果全部使用单播协议，将造成网络主干不堪重负。 广播： 主机之间“一对所有”的通讯模式，网络对其中每一台主机发出的信号都进行无条件复制并转发，所有主机都可以接收到所有信息（不管你是否需要），由于其不用路径选择，所以其网络成本可以很低廉。 广播的优点： 1. 网络设备简单，维护简单，布网成本低廉 2. 服务器不用向每个客户机单独发送数据，所以服务器流量负载极低。 广播的缺点： 1.无法针对每个客户的要求和时间及时提供个性化服务。 2. 网络允许服务器提供数据的带宽有限，客户端的最大带宽＝服务总带宽。也就是说无法向众多客户提供更多样化、更加个性化的服务。 3. 广播禁止在Internet宽带网上传输。 组播： 主机之间“一对一组”的通讯模式，也就是加入了同一个组的主机可以接受到此组内的所有数据，网络中的交换机和路由器只向有需求者复制并转发其所需数据。 组播的优点： 1. 需要相同数据流的客户端加入相同的组共享一条数据流，节省了服务器的负载。具备广播所具备的优点。 2. 由于组播协议是根据接受者的需要对数据流进行复制转发，所以服务端的服务总带宽不受客户接入端带宽的限制。所以其提供的服务可以非常丰富。 3. 此协议和单播协议一样允许在Internet宽带网上传输。 组播的缺点： 1．与单播协议相比没有纠错机制，发生丢包错包后难以弥补，但可以通过一定的容错机制和QOS加以弥补。 2．现行网络虽然都支持组播的传输，但在客户认证、QOS等方面还需要完善，这些缺点在理论上都有成熟的解决方案，只是需要逐步推广应用到现存网络当中。","title":"广播 组播 单播"},{"content":"刚买了一个mac book pro 13.3‘， 作为一个developer，闲着无聊，学学ios，见了同学卖弄一下自己开发的小程序。 万事开头Hello World 1 安装Xcode ， xcode 继承了全部开发所需。 2 打开Xcode  3 IOS --》 Application 4 Utility Application 5 Product Name  不要勾选下面的四个单选框 6 create git 仓库 7 点击MainViewController.xib (类似与android的main.xml) 8  拖动LIbrary的 Label 到界面。 9 Run 启动模拟器。 10 恭喜你成功看到  HelloWorld。 IOS 开发中文文档比较少。所有的API在Xcode都有。 mac book pro刚到手， 还在适应。暂时没有截图。","title":"iOS--01--Hello World"},{"content":"PS： 最近调试程序，由于某种原因，换了一台android设备， 可当我试图编译安装apk时，系统却不识别这台设备。 在网上苦游半天后终于总结出了一个相对简洁又高效的方法，现在在此分享与大家！ 〇、输入命令：lsusb ；列出以USB方式连接到电脑的设备信息。 Bus 008 Device 003: ID 12d1:103a Huawei Technologies Co., Ltd. Bus 008 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub Bus 007 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub ... ... 一、切换到 root权限 sudo -s 二、打开文件 vim /etc/udev/rules.d/51-android.rules 三、在文件中添加一行信息(注意红色字体：与你的设备ID对应)： SUBSYSTEM==”usb”, SYSFS{“Google Inc. ”}==”12d1″, MODE=”103a″ 四、保存并退出，并退到普通用户模式，运行以下命令： sudo chmod a+rx /etc/udev/rules.d/51-android.rules sudo /etc/init.d/udev restart 五、在你的SDK的platform-tools 目录下运行： sudo ./adb kill-server sudo ./adb devices OK,大功告成！！！现在就可以连上你的android设备了。怎么样，简单吧？","title":"Ubuntu下不能识别android设备的解决方案"},{"content":"/**  将传入的小时和分钟 转换成当日的date  例如传入 8：00 的str 返回 2013-01-01 08：00 的nsdate  **/ -(NSDate *)CurrentDayTime:(NSString *)dataStr {     //设置转换的format     NSDateFormatter *dateFormatter = [[[NSDateFormatter alloc] init]autorelease];     [dateFormatter setLocale:[NSLocale currentLocale]];          [dateFormatter setDateFormat:@\"yyyy-MM-dd HH:mm\"];     //获取当前年月日      NSDate *currentdate = [NSDate date];     NSCalendar *calendar = [NSCalendar currentCalendar];     NSDateComponents *components = [calendar components:(                                                          NSYearCalendarUnit  |                                                          NSMonthCalendarUnit |                                                          NSDayCalendarUnit |                                                          NSHourCalendarUnit |                                                          NSMinuteCalendarUnit                                                          ) fromDate:currentdate];    NSInteger year = [components year];    NSInteger month = [components month];    NSInteger day = [components day];    NSString *strDate = [NSString stringWithFormat:@\"%d-%d-%d %@\",year,month,day,dataStr];    NSDate *date = [dateFormatter dateFromString:strDate];    return date;      }   NSLog(@\"%@\\n%@\",[self CurrentDayTime:@\"18:00\"] ,[NSDate date]);     NSDate *date = [NSDate date];     if ([date compare:[self CurrentDayTime:@\"18:00\"]] == NSOrderedDescending)     {         NSLog(@\"date1 is later than date2\");              } else if ([date compare:[self CurrentDayTime:@\"18:00\"]] == NSOrderedAscending)     {         NSLog(@\"date1 is earlier than date2\");              } else     {         NSLog(@\"dates are the same\");              }","title":"nsdate 的比较"},{"content":"依稀还记得在学java的时候，面向对象的三大特性：封装性，多态性，还有继承性，上节课主要说的是多态性，这节课来说说继承性。 继承从属性继承和方法继承来说： 原先我们在一个类中定义的属性要么是在implemetion的kaitou｛｝中定义，要么通过@property定义，这些方法属性都是private的，子类是无法继承到的，下面的例子就可以让子类继承到：大家先看： 一看就懂了，就是在interface中声明属性就行了，只不过大家得注意son继承的类不是NSObject了是father 继承方法写法和原来一样，不再详述","title":"objective-c(八)－面向对象之继承"},{"content":"在LINUX上进行编码转换时,既可以利用iconv函数族编程实现,也可以利用iconv命令来实现,只不过后者是针对文件的,即将指定文件从一种编码转换为另一种编码。 一、利用iconv函数族进行编码转换 iconv函数族的头文件是iconv.h,使用前需包含之。 #include <iconv.h> iconv函数族有三个函数,原型如下: (1) iconv_t iconv_open(const char *tocode, const char *fromcode); 此函数说明将要进行哪两种编码的转换,tocode是目标编码,fromcode是原编码,该函数返回一个转换句柄,供以下两个函数使用。 (2) size_t iconv(iconv_t cd,char **inbuf,size_t *inbytesleft,char **outbuf,size_t *outbytesleft); 此函数从inbuf中读取字符,转换后输出到outbuf中,inbytesleft用以记录还未转换的字符数,outbytesleft用以记录输出缓冲的剩余空间。 (3) int iconv_close(iconv_t cd); 此函数用于关闭转换句柄,释放资源。 例子1: 用C语言实现的转换示例程序 /* f.c : 代码转换示例C程序 */具体讲，自己的验证实现是根据文中的f.c实现的 #include <iconv.h> #define OUTLEN 255 main() { char *in_utf8 = \"姝ｅ?ㄥ??瑁?\";<=======此字符串似乎并不是“正在安装”四个字的UTF8的对照串， char *in_gb2312 = \"正在安装\"; char out[OUTLEN]; //unicode码转为gb2312码 rc = u2g(in_utf8,strlen(in_utf8),out,OUTLEN); printf(\"unicode-->gb2312 out=%sn\",out); //gb2312码转为unicode码 rc = g2u(in_gb2312,strlen(in_gb2312),out,OUTLEN); printf(\"gb2312-->unicode out=%sn\",out); } //代码转换:从一种编码转为另一种编码 int code_convert(char *from_charset,char *to_charset,char *inbuf,int inlen,char *outbuf,int outlen) { iconv_t cd; int rc; char **pin = &inbuf; char **pout = &outbuf; cd = iconv_open(to_charset,from_charset); if (cd==0) return -1; memset(outbuf,0,outlen); if (iconv(cd,pin,&inlen,pout,&outlen)==-1) return -1; iconv_close(cd); return 0; } //UNICODE码转为GB2312码 int u2g(char *inbuf,int inlen,char *outbuf,int outlen) { return code_convert(\"utf-8\",\"gb2312\",inbuf,inlen,outbuf,outlen); } //GB2312码转为UNICODE码 int g2u(char *inbuf,size_t inlen,char *outbuf,size_t outlen) { return code_convert(\"gb2312\",\"utf-8\",inbuf,inlen,outbuf,outlen); } 例子2: 用C++语言实现的转换示例程序 /* f.cpp : 代码转换示例C++程序 */ #include <iconv.h> #include <iostream> #define OUTLEN 255 using namespace std; // 代码转换操作类 class CodeConverter { private: iconv_t cd; public: // 构造 CodeConverter(const char *from_charset,const char *to_charset) { cd = iconv_open(to_charset,from_charset); } // 析构 ~CodeConverter() { iconv_close(cd); } // 转换输出 int convert(char *inbuf,int inlen,char *outbuf,int outlen) { char **pin = &inbuf; char **pout = &outbuf; memset(outbuf,0,outlen); return iconv(cd,pin,(size_t *)&inlen,pout,(size_t *)&outlen); } }; int main(int argc, char **argv) { char *in_utf8 = \"姝ｅ?ㄥ??瑁?\"; char *in_gb2312 = \"正在安装\"; char out[OUTLEN]; // utf-8-->gb2312 CodeConverter cc = CodeConverter(\"utf-8\",\"gb2312\"); cc.convert(in_utf8,strlen(in_utf8),out,OUTLEN); cout << \"utf-8-->gb2312 in=\" << in_utf8 << \",out=\" << out << endl; // gb2312-->utf-8 CodeConverter cc2 = CodeConverter(\"gb2312\",\"utf-8\"); cc2.convert(in_gb2312,strlen(in_gb2312),out,OUTLEN); cout << \"gb2312-->utf-8 in=\" << in_gb2312 << \",out=\" << out << endl; } 二、利用iconv命令进行编码转换 iconv命令用于转换指定文件的编码,默认输出到标准输出设备,亦可指定输出文件。 用法： iconv [选项...] [文件...] 有如下选项可用: 输入/输出格式规范： -f, --from-code=名称 原始文本编码 -t, --to-code=名称 输出编码 信息： -l, --list 列举所有已知的字符集 输出控制： -c 从输出中忽略无效的字符 -o, --output=FILE 输出文件 -s, --silent 关闭警告 --verbose 打印进度信息 -?, --help 给出该系统求助列表 --usage 给出简要的用法信息 -V, --version 打印程序版本号 例子: iconv -f utf-8 -t gb2312 aaa.txt >bbb.txt 这个命令读取aaa.txt文件，从utf-8编码转换为gb2312编码,其输出定向到bbb.txt文件。","title":"Linux下转换字符集(UTF8转换) 借鉴此文自己已成功在LInux上实现gtk中 从UTF8到GB2312"},{"content":"1. ICP算法的一些网络资源 2. 经典ICP算法的步骤 3. fast ICP算法 ICP（Iterative closest points）算法是点集配准的经典算法，算法基本原理是在A method for registration of 3-D shapes文章中提出。后人也在此基础上不断和补充ICP算法。 1. 下面是介绍ICP算法的一些网络资源： ICP算法基本介绍： http://en.wikipedia.org/wiki/Iterative_closest_point http://plum.eecs.jacobs-university.de/download/3dim2007/node2.html http://baike.baidu.com/view/1954001.htm 经典ICP算法论文： http://eecs.vanderbilt.edu/courses/cs359/other_links/papers/1992_besl_mckay_ICP.pdf Fast ICP论文地址： http://docs.happycoders.org/orgadoc/graphics/imaging/fasticp_paper.pdf 算法的一些实现总结： http://www.mrpt.org/Iterative_Closest_Point_(ICP)_and_other_matching_algorithms 2. 经典ICP算法介绍。 ICP算法有较多的数学公式和概念，数学公式总归看起来费劲，这里只简要的理解下其算法步骤： 两个点集P1，P2，每一步迭代，都朝着距离最小的目标进行。 a. 筛选点对：由P1中的点，在P2中搜索出其最近的点，组成一个点对；找出两个点集中所有的点对。点对集合相当于进行有效计算的两个新点集。 b. 根据点集对，即两个新点集，计算两个重心。 c. 由新点集，计算出下一步计算的旋转矩阵R，和平移矩阵t(其实来源于重心的差异)。 d. 得到旋转矩阵和平移矩阵Rt，就可以计算点集P2进行刚体变换之后的新点集P2`，由计算P2到P2`的距离平方和，以连续两次距离平方和之差绝对值，作为是否收敛的依据。若小于阈值，就收敛，停止迭代。 e. 重复a-e，直到收敛或达到既定的迭代次数。 --其中，计算旋转矩阵R时，需要矩阵方面的运算。 由新的点集，每个点到重心的距离关系，计算正定矩阵N，并计算N的最大特征值及其最大特征向量；其特征向量等价于旋转的四元数（且是残差和最小的旋转四元数），将四元数就可以转换为旋转矩阵。 数学概念： 四元数：http://baike.soso.com/v113161.htm?ch=ch.bk.innerlink 正定矩阵：特征值都大于0的矩阵。 这些是矩阵理论，最优化原理方面的一些概念。 3. fast ICP解析： Fast ICP是对ICP的改进与扩展。论文Efficient Variants of the ICPalgorithm详细给出了影响ICP算法的各种因素，且每种因素都哪些算法，其结果与性能如何。 Fast ICP根据这些因素将ICP算法分为6个步骤： a. 筛选：点集或曲面的筛选（滤波） b. 匹配：两个点集之间的点进行配对 c. 权重：给每个匹配的点对分配权重 d. 去除：去除不符合条件的点对 e. 误差度量：基于以上点对，给出每个点对的误差计算方法 f. 最小化：最小化误差度量 为测试以上阶段中不同算法的性能和结果，论文提供了三个测试场景，并在这些点集（曲面）上加上噪声： 比较平滑的波纹： 比较简单的场景，几何尺度变换不是很大 较复杂的不规则的草原地形： 相对复杂的，包含不同尺度的细节 仅含有突出一个十字形雕刻面的平面： 对匹配而言，最困难的场景，因为特征太少 下面是每个阶段的算法的比较： a. 筛选：点集或曲面的筛选（滤波） 筛选也有以下几种策略： * 应用点集内所有可用的点：  无疑是性能最差的方法 * 采用均匀分布的方式筛选（或是距离等间隔筛选） * 随机筛选法 * 根据点的密度，颜色来筛选 * 对一个点集进行筛选，或者两个点集都进行筛选：对于一般的点集，两种方法收敛率和结果基本相同，但仅对一个点集筛选的算法，数据运算量相对比较大。 * 另外一个筛选策略是依据向量的分布情况： 筛选哪些能使点的向量的分布尽量大的点，这样的目的是突出 特征很少的 点集的特征 （如十字雕刻面） 如下图 a  随机采用法，  图b是向量空间分布法 的示意图。 由图可以明显看出，空间向量分布法对点集的较少的特征有着比较好的提取能力。 Fast ICP暂不考虑一个点的密度颜色信息。 对均匀分布法、随机法、向量空间分布法比较。 对水波等简单场景下：其收敛速度和收敛效果都差别不大。但对于特征点较少的场景，向量空间分布法的收敛速度和结果很好，而对于另外两种方法，基本不能收敛。如下：     b. 匹配：两个点集之间的点进行配对 匹配的策略有以下几种： * 最邻近点法：此方法还可以应用k-d树或最邻近点缓存进行加速 * Normal shooting：点集P1中取一点，沿其点法向量，到点集P2（曲面的）的交点，形成一个点对 * 投影法：将源点集P1投影到目的点集P2上，沿着P2的相机的视角方向，又称“reverse calibration”，搜索度量方法包括点对点距离，点对线距离，密度，颜色等。 * 基于向量间角度或颜色的兼容度量方法（Compatibility metric） Fast ICP中不考虑颜色，密度信息。 这里先给出投影法（b）与最近邻法（b）的示意图： 从图上看，可以看出最邻近点法容易受到噪声的干扰，而投影法不受噪声的干扰。 比较Normal shooting、最邻近点法和投影法三种方法： 在雕刻十字面的场景下： 虽然最邻近点法容易受到噪声干扰，但对于特征比较少的场景下，最邻近点（兼容）法是唯一能完全收敛的方法。效果最好。对于投影法，收敛很快，但是效果不是很好。Normal shooting法在这两方面都表现平平。 对于复杂的草原场景，几种方法的收敛结果最终都基本相同，但其收敛速度和计算速度却有很大的差别：    从上图来看，投影法的计算速度非常快，这是因为不仅投影法的收敛速度快，而且其算法复杂度为O(1),而其他的算法复杂度为O(logN)。 c. 权重：给每个匹配的点对分配权重 权重分配的策略有以下几种： * 均匀分配，即常数加权。 * 根据点对距离加权，点对间距大，权重就小，反之，权重就大。 * 根据向量的一致性（compability）进行加权，weight = n1 * n2 * 不确定性 这几种方法的收敛速度和效果都差别大。总体上来讲，向量一致（兼容）的方法 适应性和速度比其他方法好点。 d. 去除：去除不符合条件的点对 这个阶段的策略包括 * 固定阈值法：当间距大于一个值时，就去除这个点对 * 固定比例法：每次迭代，去除最差的%n的点对 * 标准差法：将阈值设置为所有点对间距的标准差*2.5 * 去除曲面边界的点对，如下图，曲面边界点的点对是不合理的，在两个点集做部分匹配的时候。 这几种方法的收敛速度差别不大，而且收敛效果也差别不大。但是去除outlier点对这个步骤 对收敛结果 的作用还是明显的。 e. 误差度量和最小化：基于以上点对，给出每个点对的误差计算方法 误差度量的策略： * 点对的距离平方和 * 点到面的距离平方和 * 点到点和点到面的外推法    比较其收敛速率和效果，点到面和点到面外推法的度量方式效果更好。 Fast ICP分析了不同阶段里，各种因素或策略对算法性能和结果的影响。应可以根据不同的需求，来选取不同的算法对点集或曲面进行配准。 在算法效果差别不大的情况下，尽量选择简单的算法，来提高运行速度，如随机采样，常数加权，固定阈值等。 Fast ICP在网上有开源的代码，研究一下对此算法会有更深的理解。","title":"应用Fast ICP进行点集或曲面配准 算法解析"},{"content":"在Browser中叶需要修改相应的packages\\apps\\Browser\\res\\layout\\webview_preview.xml    <RelativeLayout         android:layout_width=\"match_parent\"         android:layout_height=\"wrap_content\"         android:layout_marginLeft=\"16dip\"         android:layout_marginRight=\"8dip\"         android:layout_marginTop=\"6dip\"         android:layout_marginBottom=\"6dip\"         android:layout_weight=\"1\">         <TextView android:id=\"@android:id/title\"             android:layout_width=\"match_parent\"             android:layout_height=\"wrap_content\"             android:singleLine=\"true\"             android:textAppearance=\"?android:attr/textAppearanceMedium\"             android:ellipsize=\"marquee\"             android:gravity=\"right\"             android:fadingEdge=\"horizontal\" />","title":"阿语波斯语问题一（Browser中预览的文字居右是在Browser里面控制的）"},{"content":"在wiki上有对STL图形文件格式的详细描述。 http://en.wikipedia.org/wiki/STL_(file_format) STL文件格式分为两种：ASCII字符格式，及二进制格式。 ASCII字符格式的格式如下： 开头一行： solid name         // 文件名是可选的字符串 接下来，是三角片的数据格式： facet normal ni nj nkouter loopvertex v1x v1y v1zvertex v2x v2y v2zvertex v3x v3y v3zendloopendfacet 结束行标志： endsolid name 二进制格式数据： 因为字符格式的STL文件比较大，占空间，因为有了二进制格式，且二进制的存储格式与ASCII的格式不同。二进制有80个字节作为文件头，一般都忽略掉，但开头不能使solid，不然就不能与ASCII格式相区分了。 另外，接下来4个字节是存放的三角片的个数，这个是ASCII格式所没有 的。 UINT8[80] – HeaderUINT32 – Number of trianglesforeach triangleREAL32[3] – Normal vectorREAL32[3] – Vertex 1REAL32[3] – Vertex 2REAL32[3] – Vertex 3UINT16 – Attribute byte countend 读取STL文件，首先，程序要区别读取的是那种格式的STL。然后根据格式，来读取数据。 先定义如下数据类型： template <int D, class T = float> class Vec { private: T v[D]; public: ... }; typedef Vec<3,float> Vec3f; 用于存放点坐标数据和法向量数据，这里将点坐标和法向量都读到一个数组中。 bool ReadSTLFile(const char *cfilename){    if (cfilename == NULL)    {        return false;    }    ifstream in(cfilename, ios::in);    if (!in)    {        return false;    }    string headStr;    getline(in, headStr, ' ');    in.close();    if (headStr.empty())    {        return false;    }    if (headStr[0] == 's')    {        ReadASCII(cfilename);    }    else    {        ReadBinary(cfilename);    }    return true;} bool CStLReader::ReadASCII(const char *cfilename){    int i=0,j=0,cnt=0 ,pCnt=4;    char a[100];    char str[100];    double x=0,y=0,z=0;    Vec3f tPoint;     Vector<Vec3f> pointList; // todo: 可以预先计算出pointList的大小，节省空间     ifstream in;     in.open(cfilename, ios::in); if (!in) { return false; } do { i=0; cnt=0; in.getline(a,100, '\\n'); while(a[i]!='\\0') { if(!islower((int)a[i]) && !isupper((int)a[i]) && a[i]!=' ') break; cnt++; i++; } while(a[cnt]!='\\0') { str[j]=a[cnt]; cnt++; j++; } str[j]='\\0'; j=0; if(sscanf(str,\"%lf%lf%lf\",&x,&y,&z)==3) { tPoint.SetParam(x,y,z);               pointList.push_back(tPoint);        }        pCnt++;    }while(!in.eof());    return true;}  bool CStLReader::ReadBinary(const char *cfilename){    char str[80];    ifstream in;    //三角形数目    int unTriangles(0);    in.open(cfilename, ios::in);    if (!in)    {        return false;    }    in.read(str, 80);    in >> unTriangles;    if(unTriangles==0)    {\t        return false;    }    Vec3f tPoint;     vector<Vec3f> pointList(unTriangles); // 预留足够的空间     float x(0.f), y(0.f), z(0.f);    char unusedByte;    //Binary    for(int i=0;i<(int)unTriangles;i++)    {        for (int pointIdx=0; pointIdx<4; pointIdx++)        {            in >> x >> y >> z;            tPoint.SetParam(x, y, z);            pointList.push_back(tPoint);        }        in >> unusedByte >> unusedByte;    }    in.close();    return true;}","title":"三维图形数据格式 STL的 读取"},{"content":"前几章参考： 1-引言 2-Objective-C 编程 3-类、对象和方法 4-数据类型和表达式 5-循环结构 6-选择结构 7-类 8-继承 9-多态、动态类型和动态绑定 枚举数据类型可以为只存储一些值的链表这种数据类型定义名称。Objective-C语言的typedef语句允许你为内置或派生的数据类型指定自己的名称。 对象的初始化 常见的编程习惯是类中所有的初始化方法都以init开头。 如果希望在类对象初始化时做一些事情。可以通过覆写init方法达到这个目的。 -(id)init {     self = [super init];     if (self) {         //初始化代码     }     return self； } 必须将父类init方法的执行结果赋值给self，因为初始化过程改变了对象在内存中的位置（意味着引用将要改变）。如果父类的初始化过程成功，返回的值是非空的，通过if语句可以验证，注释说明可以在这个代码块的位置放入自定义的初始化代码。通常可以在这个位置创建并初始化实例变量。 注意，init被定义为返回id类型，这是编写可能会被继承的类init方法的一般规则。 程序开始执行时，它向所有的类发送initialize调用方法。如果存在一个类及相关的子类，则父类首先得到这条消息。该消息只向每个类发送一次，并且向该类发送其它任何消息之前，保证向其发送初始化消息。 作用域： 在接口中声明的实例变量可以通过子类进行继承。 可以把下面指令放在实例变量之前，以便更精确地控制其作用域： 1) @protected,可以被类及任何子类中定义的方法直接访问。在接口部分定义的实例变量默认是这种作用域。 2）@private，只能本类访问，不能被子类直接访问。在实现部分定义的实例变量默认属于这种作用域。 3）@public，可以被本类、其他类或者模块中定义的方法直接访问。 4）@package，对于64位映像，可以在实现该类的映像中的任何地方访问这个实例变量。 @public指令使得其他方法或函数可以通过使用指针运算符（->）访问实例变量。但，实例变量声明为public并不是良好的编程习惯，因为这违背了数据封装的思想（即一个类需要隐藏它的实例变量）。 关于属性、存储方法和实例变量： 编码规范（Xcode4已经采用的）目前的趋势是使用下划线（_）作为实例变量名的起始字符。 @synthesize window = _window; 表明合成（synthesize）属性window的取值方法和设置方法，并将属性与实例变量_window（实例变量并没有显性声明）关联起来。这对区别属性和实例变量的使用是有帮助的。 [window makeKeyAndVisible]; //错误 [_window makeKeyAndVisible];//正确 [self.window makeKeyAndVisible];//正确 全局变量： 在程序的开始处（所有的方法、类定义）编写一下语句： int gMoveNumber = 0; 那么这个模块中的任何位置都可以引用这个变量的值。这种情况下，我们说gMoveNumber被定义为全局变量。 按照惯例，用小写的g作为全局变量的首字母。 外部变量是可被其他任何方法或函数访问和更改其值的变量。在需要访问外部变量的模块中，变量声明和普通方式一样，只是需要在声明前加上关键字extern。 使用外部变量时，必须遵循下面这条重要的原则：变量必须定义在源文件中的某个位置。即在所有的方法和函数之外声明变量，并且前面不加关键字extern，如：int gMoveNumber; 确定外部变量的第二种方式是在所有的函数之外声明变量，在声明前面加上关键字extern，同时显式地为变量指派初始值。 记住，声明不会引起分配变量的内存空间，而定义会引起变量内存空间分配。 处理外部变量时，变量可以在许多地方声明为extern，但是只能定义一次。 注意，如果变量定义在包含访问该变量的文件中，那么不需要单独进行extern声明。（这个意思是，可能你import了） 静态变量： 在方法之外定义的变量不仅是全局变量，而且是外部变量。如果希望定义全局变量且只在特定模块（文件）中是全局的，就可以使用static来修饰。 注意，重载alloc并不是好的编程实践，因为这个方法处理内存的物理分配。 枚举数据类型： 枚举数据类型的定义以关键字enum开头，之后是枚举数据类型的名称，然后是标识符序列（包含在一对花括号内），它们定义了可以给该类型指派的所以的允许值。 在代码中定义的枚举类型的作用域限于块的内部。另外，在程序的开始及所有块之外定义的枚举数据类型对于该文件是全局的。 定义枚举数据类型时，必须确保枚举标识符与定义在相同作用域之内的变量名和其他标识符不同。 typedef语句： 通俗点说就是别名。 数据类型转换： Bool，char，short int，bit field，枚举和int都转为int型，其他的强转为谁就是谁。 位运算符就不啰嗦了。","title":"10-变量和数据类型"},{"content":"当开发基于软件模式的游戏时，通过缩放视频缓冲区来适应显示尺寸是最棘手的问题之一。当面对众多不同的分辨率时(比如开放环境下的Android)，该问题会变得更加麻烦，作为开发人员，我们必须尝试在性能与显示质量之间找到最佳平衡点。正如我们在第2章中看到的，缩放视频缓冲区从最慢到最快共有3种类型。 软件模拟：3中类型中最慢，但最容易实现，是没有GPU的老款设备上的最佳选择。但是现在大部分智能手机都支持硬件加速。 混合模式：这种方式混合使用软件模拟(创建图像缓冲区)和硬件渲染(向显示屏绘制)两种模式。这种方法速度很快，而且可以在分辨率大于256×256的任意屏幕上渲染图像。 硬件加速模式：3种类型中最快，但最难实现。这取决于游戏的复杂程度，需要更加强劲的GPU。如果有好的硬件，这种方法就可以创造出令人震撼的质量和效果。但在终端设备比较分裂的平台上，比如Android，这将是十分艰难的选择。 这里，我们选择第二种方式，也是在终端设备分裂的平台上的最佳选择。你拥有软件渲染器，并希望将游戏适配到任意分辨率的显示屏上。此方法非常适合模拟器游戏、街机游戏、简单的射击游戏等。它在各种低端、中端、高端设备上都表现很好。 下面我们开始介绍混合模式并探讨为什么这种方法更加可行。然后，将深入研究这种方法的实现，包括如何初始化surface并通过实际缩放来绘制到纹理。 1. 为什么使用混合缩放 这种缩放技术背后的原理很简单： 你的游戏根据给定的尺寸创建图像缓冲区(通常采用像素格式RGB565，即移动设备最常用的格式)。例如320×240，这是典型的模拟器尺寸。 当一张分辨率为320×240的图像需要被缩放至平板电脑的尺寸(1024×768)或其他任意相同屏幕的设备时，我们可以使用软件模拟的方式来完成缩放，但会慢的令人无法忍受。而采用混合模式进行缩放，需要创建OpenGL ES纹理并将图片(320×240)渲染到GL四边形上。  纹理会通过硬件被缩放到适合显示屏的尺寸(1024×768)，从而你的游戏性能将得到显著提升。 从实现的角度看，这个过程可描述如下： 初始化OpenGL ES纹理：在游戏视频被初始化的阶段，必须创建硬件surface。其中包含简单的纹理，要显示的视频图像会被渲染至到该纹理(详见代码清单1与代码清单2)。 将图像缓冲区绘制到纹理：在游戏循环的末端，渲染要显示的视频图像到纹理，该纹理会自动缩放至适合显示屏的尺寸(详见代码清单3)。 代码清单1  创建RGB656格式的空纹理 // 纹理ID static unsigned int mTextureID;  // 被用来计算图片绘制在纹理上的X、Y偏移量 static int xoffset; static int yoffset;  /**  * 创建RGB565格式的空纹理 * 参数: (w,h) 纹理的宽, 高 * (x_offsety_offset): 图片绘制在纹理上的X、Y偏移量  */ static void CreateEmptyTextureRGB565 (int w, int h, int x_offset, int y_offset)  {   int size = w * h * 2;      xoffset = x_offset;   yoffset = y_offset;    // 缓冲区  unsigned short * pixels = (unsigned short *)malloc(size);   memset(pixels, 0, size);      // 初始化GL状态  glDisable(GL_DITHER);   glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_FASTEST);      glClearColor(.5f, .5f, .5f, 1);   glShadeModel(GL_SMOOTH);   glEnable(GL_DEPTH_TEST);   glEnable(GL_TEXTURE_2D);      // 创建纹理  glGenTextures(1, &mTextureID);   glBindTexture(GL_TEXTURE_2D, mTextureID);      // 纹理参数   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,GL_NEAREST);   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,GL_LINEAR);    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);  // RGB565格式的纹理  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, w, h, 0, GL_RGB, GL_UNSIGNED_SHORT_5_6_5 , pixels);       free (pixels); } 代码清单2展示了CreateEmptyTextureRGB565的实现过程，创建RGB656格式的空纹理用于绘制，参数如下： w和h：要显示的视频图片的尺寸。 x_offset和y_offset：坐标系中X轴、Y轴的偏移量，视频图片将会按照这个坐标被渲染到纹理。但是为什么我们需要这些参数？请继续阅读。 在OpenGL中创建纹理，我们只需要调用： glGenTextures(1, &mTextureID); glBindTexture(GL_TEXTURE_2D, mTextureID); 这里的mTextureID是整型变量，用于存储纹理的ID。然后需要设置下面这些纹理参数： GL_TEXTURE_MIN_FILTER：指定纹理缩小的方式，当像素被纹理化后并映射到某个大于单个纹理元素的区域时使用的缩小方式为GL_NEAREST，返回距离像素被纹理化后的中心最近(曼哈顿距离)的纹理元素的值。 GL_TEXTURE_MAG_FILTER：指定纹理放大的方式，当像素被纹理化后并映射到某个小于或等于单个纹理元素的区域时使用的放大方式为GL_LINEAR，返回4个距离像素被纹理化后的中心最近的纹理元素的加权平均值。 GL_TEXTURE_WRAP_S：用于设置纹理坐标系中S轴方向上的纹理映射方式为GL_CLAMP，将纹理坐标限制在(0,1)范围内，当映射单张图像到对象时，可以有效防止画面重叠。 GL_TEXTURE_WRAP_T：用于设置纹理坐标系中T轴方向上的纹理映射的方式为GL_CLAMP。 最后，我们通过glTexImage2D函数及以下参数来指定二维纹理： GL_TEXTURE_2D：指定目标纹理的类型为二维纹理。 Level：指定图像纹理的详细程度。0是最基本的图像纹理层。 Internal format：指定纹理的颜色成分，在这个例子中是RGB格式。 Width and height：纹理的尺寸，必须是2的幂。 Format：指定像素数据的格式，同时也必须与内部格式相同。 Type：指定像素数据的数据类型，在本例中使用RGB565(16位)格式。 Pixels：指向内存中图像数据的指针，必须使用RGR656编码。 注意：纹理的尺寸必须是2的幂，如256、512、1024等。但是，要显示的视频图像的尺寸可以是任意尺寸。这就意味着，纹理的尺寸必须是大于或等于要显示的视频图像尺寸的2的幂。稍后我们将进行详细介绍。 现在，让我们来看一看混合视频缩放的实际实现，接下来的两个小节将介绍如何初始化用来缩放的surface以及如何实现实际的绘制。 2. 初始化surface 要进行缩放，就必须保证纹理的尺寸大于或等于要显示的视频图像的尺寸。否则，当图像渲染的时候，会看到白色或黑色的屏幕。在代码清单2中，JNI_RGB565_SurfaceInit函数将确保产生有效的纹理尺寸。使用图像的宽度和高度为参数，然后调用getBestTexSize函数来获取最接近要求的纹理尺寸，最后通过调用CreateEmptyTextureRGB565函数来创建空的纹理。注意，如果图像尺寸小于纹理尺寸，就通过计算X、Y坐标的偏移量来将其置于屏幕的中心。 代码清单2  初始化surface // 获取下一个POT纹理尺寸，该尺寸大于或等于图像尺寸(WH)static void getBestTexSize(int w, int h, int *tw, int *th)  {   int width = 256, height = 256;      #define MAX_WIDTH 1024   #define MAX_HEIGHT 1024      while ( width < w && width < MAX_WIDTH) { width *= 2; }   while ( height < h && height < MAX_HEIGHT) { height *= 2; }   *tw = width;   *th = height; }  /*** 初始化RGB565 surface * 参数: (w,h) 图像的宽高 */ void JNI_RGB565_SurfaceInit(int w, int h) {   //最小纹理的宽高  int texw = 256;    int texh  = 256;      // 得到纹理尺寸 (必须是POT) >= WxH   getBestTexSize(w, h, &texw, &texh);  // 图片在屏幕中心？  int offx = texw > w ? (texw - w)/2 : 0;   int offy = texh > h ? (texh - h)/2 : 0;   if ( w > texw || h > texh)     printf (\"Error: Invalid surface size %sx%d\", w, h);   // 创建OpenGL纹理，用于渲染  CreateEmptyTextureRGB565 (texw, texh, offx, offy); }  3. 绘制到纹理 最后，为了将图像显示到屏幕上(也称作surface翻转)，我们调用JNI_RGB565_Flip函数，其参数是像素数组(使用RGR656编码)和要显示的图像尺寸。JNI_RGB565_Flip函数通过调用DrawIntoTextureRGB565将图像绘制到纹理并交换缓冲区。注意交换缓冲区的函数是用Java编码的，而不是用C语言编码的，因此我们需要一个方法来调用Java的交换函数。我们可以通过使用JNI方法调用某个Java方法来完成缓冲区的交换工作(见代码清单3)。 代码清单3  用四边形将图像缓冲区绘制到纹理 // 四边形顶点的X、Y和Z坐标static const float vertices[] = {           -1.0f, -1.0f, 0,      1.0f, -1.0f, 0,      1.0f,  1.0f, 0,      -1.0f, 1.0f, 0 }; // 四边形坐标(0-1) static const float coords[] = {      0.0f, 1.0f,      1.0f, 1.0f,      1.0f, 0.0f,      0.0f, 0.0f,  };  // 四边形顶点索引static const unsigned short indices[] = { 0, 1, 2, 3};  /**  * 使用四边形像素(RGB565的unsigned short)将像素数组绘制到全部屏幕 * */ static void DrawIntoTextureRGB565 (unsigned short * pixels, int w, int h)  {   // 清除屏幕  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);      // 启用顶点和纹理坐标   glEnableClientState(GL_VERTEX_ARRAY);   glEnableClientState(GL_TEXTURE_COORD_ARRAY);    glActiveTexture(GL_TEXTURE0);   glBindTexture(GL_TEXTURE_2D, mTextureID);      glTexSubImage2D(GL_TEXTURE_2D, 0, xoffset, yoffset, w, h, GL_RGB, GL_UNSIGNED_SHORT_5_6_5 , pixels);       // 绘制四边形  glFrontFace(GL_CCW);   glVertexPointer(3, GL_FLOAT, 0, vertices);   glEnable(GL_TEXTURE_2D);   glTexCoordPointer(2, GL_FLOAT, 0, coords);   glDrawElements(GL_TRIANGLE_FAN, 4, GL_UNSIGNED_SHORT, indices); }  // 翻转surface (绘制到纹理中) void JNI_RGB565_Flip(unsigned short *pixels , int width, int height) {   if ( ! pixels) {     return;   }   DrawIntoTextureRGB565 (pixels, width, height);     // 在这里必须交换GLES缓冲区  jni_swap_buffers (); } 使用OpenGL渲染到纹理： (1) 使用glClear(GL_COLOR_BUFFER_BIT |GL_DEPTH_BUFFER_BIT)清除颜色与深度缓冲区。 (2) 启用客户端状态：当glDrawElements函数被调用时，写入顶点数组与纹理坐标数组。 (3) 通过glActiveTexture函数选择要激活的纹理单元，初始值是GL_TEXTURE0。 (4) 将已经生成的纹理绑定到等待被纹理化的目标。GL_TEXTURE_2D (一个二维纹理)是默认的纹理绑定目标，mTextureID是纹理的ID。 (5) 通过glTexSubImage2D函数来指定二维纹理子图，参数如下： GL_TEXTURE_2D：指定目标纹理类型。 level：指定图像的详细程度(即层数)。0是基本的图像纹理层。 Xoffset：指定纹理像素在X轴方向上、纹理数组内的偏移量。 Yoffset：指定纹理像素在Y轴方向上、纹理数组内的偏移量。 width：指定纹理子图的宽度。 height：指定纹理子图的高度 format：指定像素数据的格式。 Type：指定像素数据的数据类型。 data：指定指向内存中图像数据的指针。 (6) 通过调用以下函数绘制四边形顶点、坐标与索引： glFrontFace：启用四边形的正面。 glVertexPointer：定义四边形的顶点数据数组，顶点数据大小为3，数据类型是GL_FLOAT，数组中每个顶点间的间隔(步长)为0。 glTexCoordPointer：定义四边形的纹理数组，纹理坐标大小为2，数据类型是GL_FLOAT，间隔为0。 glDrawElements：通过数据数组以三角形扇(GL_TRIANGLE_FAN)的方式渲染多边形，有4个顶点，类型为短整型(GL_UNSIGNED_SHORT)，外加指向索引的指针。 注意，从代码清单3中我们可以看到四边形的两个轴坐标都在[−1,1]区间内。这是因为OpenGL的坐标系统在(−1，1)之间，原点(0,0)在窗口中心(如图3-10所示)。 图3-10  OpenGL坐标系统 在理想的世界里，我们不应该过多地担心视频缓冲区的尺寸(尤其是使用软件模拟仅有的定标器/渲染器)。当在Android中使用OpenGL缩放视频时，这却是事实。在这个示例中，缓冲区的尺寸至关重要。接下来你将学习如何处理任意尺寸的视频，这一点在OpenGL中工作得不是很好。 4. 当图像的尺寸不是2的幂时会发生什么 如前所述，当图像的尺寸是2的幂时混合缩放会非常完美。但是，也有可能图像缓冲区不是2的幂。例如，在处理Demo引擎的章节中有一段320×240尺寸的视频。在这种情况下，图像仍然被缩放，但是会缩放到纹理尺寸的百分比大小。在图2和3中可以看到这个效果。 图2缩放非2的幂尺寸的图像 在图2中，有以下尺寸： 设备显示器：859×480 纹理：512×256 图像：320×240 正如我们看到的一样，图像被缩放到纹理宽度的62%(320/512*100)和高度的93% (240/256*100)。因此，在任何分辨率大于256的设备上，图像都会被缩放到设备提供分辨率的62%×93%。现在我们来看看图3。 图3 缩放尺寸为2的幂的图像 在图3中，有以下尺寸： 设备显示器：859×480 纹理：512×256 图像：512×256 缩放和绘制 在图3中，我们看见图像被缩放到设备提供分辨率的100%，这正是我们想要的。但是如果图像不是2的幂，那么我们要如何做呢？为了解决这个问题，我们应该： (1) 用软件缩放器将320×240尺寸的图像缩放到接近2的幂(这里是512×256)。 (2) 将已缩放的surface转换成RGB656格式的图像，以兼容前面介绍的DrawInto-TextureRGB565。 (3) 绘制到纹理，从而使用硬件将其缩放到显示屏的分辨率。 这种解决办法可能比前面介绍的方法慢，但仍然比纯软件缩放快，尤其是运行在高分辨率设备时更明显(如平板电脑)。 代码清单4展示了如何使用流行的SDL_gfx库来缩放SDL surface。 代码清单4  用SDL_gfx库缩放图像 void JNI_Flip(SDL_Surface *surface ) {    if ( zoom ) {     // 如果surface是8位缩放，就是8位，否则surface就是32的RGBA!     SDL_Surface * sized = zoomSurface( surface, zoomx, zoomy, SMOOTHING_OFF);          JNI_FlipByBPP (sized);          // 必须清理掉！SDL_FreeSurface(sized);    }    else {     JNI_FlipByBPP (surface);   } } 缩放和绘制实现 要放大/缩小SDL surface，需要简单地调用SDL_gfx库的zoomSurface： (1) 一个SDL surface。 (2) 水平缩放因子：(0-1) (3) 垂直缩放因子：(0-1) (4) SMOOTHING_OFF：为了能快速绘制，禁用反锯齿处理。 接下来，让我们基于分辨率(每个像素的位数)来翻转SDL surface。代码清单5展示了如何完成8位RBG格式的surface。 代码清单5  根据分辨率翻转SDL surface /**  * 通过每个像素的位数翻转SDL surface  */ static void JNI_FlipByBPP (SDL_Surface *surface) {   int bpp = surface->format->BitsPerPixel;      switch ( bpp ) {     case 8:       JNI_Flip8Bit (surface);       break;     case 16:       // 替换16位RGB (surface);       break;     case 32:       // 替换32为RGB (surface);       break;     default:       printf(\"Invalid depth %d for surface of size %dx%d\", bpp, surface->w, surface->h);   } }  /**  * 替换8位SDL surface */ static void JNI_Flip8Bit(SDL_Surface *surface ) {   int i;   int size = surface->w * surface->h;   int bpp = surface->format->BitsPerPixel;      unsigned short pixels [size]; // RGB565   SDL_Color * colors = surface->format->palette->colors;      for ( i = 0 ; i < size ; i++ ) {     unsigned char pixel =   ((unsigned char *)surface->pixels)[i];           pixels[i] =  ( (colors[pixel].r >> 3) << 11)        | ( (colors[pixel].g >> 2) << 5)        | (colors[pixel].b >> 3);   // RGB565          }    DrawIntoTextureRGB565 (pixels, surface->w,  surface->h);      jni_swap_buffers (); } 指定SDL surface，然后检查每个像素的格式：surface->format->BitsPerPixel，并根据该值创建能够被DrawIntoTextureRGB565使用的RGB565像素数组： for ( i = 0 ; i < size ; i++ ) {      unsigned char pixel =   ((unsigned char *)surface->pixels)[i];            // RGB565      pixels[i] =  ( (colors[pixel].r >> 3) << 11)         | ( (colors[pixel].g >> 2) << 5)         | (colors[pixel].b >> 3);            } 从surface调色板上提取每个像素包含的红、绿和蓝值： SDL_Color * colors = surface->format->palette->colors; RED: colors[pixel].r GREEN: colors[pixel].g BLUE: colors[pixel].b 为了构建RGB565像素，需要从每个颜色组件中抛弃最低有效位： colors[pixel].r >> 3 (8 -3 = 5) colors[pixel].g >> 2 (8 – 2 = 6) colors[pixel].b >> 3 (8 – 3 = 5) 然后移动每个组件到16位值的正确位置(5+6+5= 16——因此是RGB656)： pixels[i] = (RED << 11) | (GREEN << 5) | BLUE 最后将新的数组和图像宽度、高度一起发送到DrawIntoTextureRGB565。最后一个问题，我们需要一种方式来告诉surface是否需要缩放。当surface在第一次被创建时将完成视频初始化。代码清单6展示了如何用SDL创建软件surface。 代码清单6 初始化缩放surface // 应该被缩放？ static char zoom = 0;  // 缩放范围[0,1] static double zoomx = 1.0; static double zoomy = 1.0;  /**********************************************************  * 图像的构造函数  * 图像必须是2的幂 (256×256, 512×256,...)   * 以便用OpenGL纹理进行全屏渲染。如果图像不是 * POT (320×240)，那么它将被缩放 **********************************************************/ SDL_Surface * JNI_SurfaceNew(int width, int height, int bpp, int flags)  {   Uint32 rmask = 0, gmask = 0, bmask =0 , amask = 0;      // 纹理尺寸和偏移量  int realw = 256, realh = 256, offx = 0, offy = 0;      // 图像必须是2的幂以便OpenGL能缩放它   if ( width > 512 ) {     Sys_Error(\"ERROR: INVALID IMAGE WIDTH %d (max POT 512×512)\", width);   }      // 真实的W/H必须接近POT值的w/h  // 将要缩放到512×256   // 应该是256，但是512的分辨率更高(更慢)  if ( width > 256 ) realw = 512;       // 大小不是POT，就缩放到接近于POT，可选择:   // 256×256 (快/分辨率低) 512×256 (分辨率较高/较慢)   // 512×512 最慢  if ( ( width != 512 && width != 256) || ( height != 256 ) ) {     zoom = 1;     zoomx = realw / (float)width;     zoomy = realh / (float)height;          offx = offy = 0;          printf(\"WARNING Texture of size %dx%d will be scaled to %dx%d zoomx=%.3f zoomy=%.3f\"       , width, height, realw, realh, zoomx, zoomy);   }      // 创建渲染器使用的OpenGL纹理   CreateEmptyTextureRGB565 (realw, realh, offx, offy);      // 这是真正的被用于客户端渲染视频的surface  return SDL_CreateRGBSurface (SDL_SWSURFACE, width, height, bpp, rmask, gmask, bmask, amask); } 如果图像的尺寸不是2的幂，那么缩放标志将被设为1，并且水平和垂直方向的缩放因子将开始计算。然后，通过调用CreateEmptyTextureRGB565，根据宽度、高度和纹理的X、Y位移量来创建空纹理。最后调用SDL_CreateRGBSurface以创建SDL surface： SDL_SWSURFACE：告诉SDL创建软件surface。 width和height：定义surface的尺寸。 bpp：定义surface中每个像素(分辨率)的位数(8、16、24和32)。 rmask、gmask、bmask和amask：这些是每个像素格式的红、绿、蓝和alpha(透明度)的掩码值。设置为0来让SDL注意到它(译者注：设置为0，OpenGL就可以写入；设置为1，则不能写入)。 混合缩放的经验法则 总而言之，当在游戏中像这样使用混合缩放时，请牢记以下经验法则： 如果可以，就总是设置视频的大小为2的幂：256×256或512×56。高于512对于这种技术来说代价太高。 如果不想设置视频的尺寸，但又想全屏显示，就可以像前面提到的那样，用SDL软件缩放到最接近的2的幂，然后再使用硬件进行缩放。 如果视频的尺寸大于512×512，混合缩放技术就未必有效(性能需要)。 《Android 4 游戏高级编程(第2版)》试读电子书免费提供，有需要的留下邮箱，一有空即发送给大家。 别忘啦顶哦！","title":"通过OpenGL ES混合模式缩放视频缓冲区-Android 4游戏编程高级篇"},{"content":"【木头Cocos2d-x 029】Lua篇（第04章）：来点高难度的，获取Lua表结构数据   只是获取一个全局变量什么的太没意思了，今天我们来玩个高难度的——获取Lua表结构的数据。 （旁白：O O！我是不是该说点什么？）   上一章传送门：http://blog.csdn.net/musicvs/article/details/8445027   笨木头花心贡献，啥？花心？不呢，是用心~ 转载请注明，原文地址：http://blog.csdn.net/musicvs/article/details/8445079 正文：     1. 什么是table table是Lua里最强大的数据类型，我们可以当成是数组，但是它又和数组有点不一样，建议大家看看Lua的语法教程，因为我对table也没有熟悉到可以给大家解释的程度。 （旁白：那你还写什么教程。。。）   2. 获取table变量 现在，我们给helloLua.lua文件添加一个table全局变量： -- helloLua.lua文件myName = \"beauty girl\"helloTable = {name = \"mutou\", IQ = 125}   我们看到，多了一个helloTable的变量，它和数组十分相似，又和HashMap有点类似，总之它很强大。 （旁白：我觉得亮点是，你的IQ有125？我觉得乘以2的话，还有点可能~！） 话说，125乘以2等于多少？...250 ....O O！ 获取helloTable变量的方式和以前是一样的： /* 取得table变量，在栈顶 */    lua_getglobal(pL, \"helloTable\");   这样，helloTable变量就被存放到栈顶。 可我们并不是要取table变量，因为C++中是无法识别Lua的table类型的，所以我们要取得table中具体的值，也就是name和IQ的值。   3. lua_gettable函数 有一个和lua_getglobal类似的函数，叫做lua_gettable，顾名思义，它是用来取得table相关的数据的。 （旁白：废话少点好吧= =）   lua_gettable函数会从栈顶取得一个值，然后根据这个值去table中寻找对应的值，最后把找到的值放到栈顶。 lua_pushstring()函数可以把C++中的字符串存放到Lua的栈里； 然后再用lua_gettable()取执行前面所说的步骤，lua_gettable的第二个参数是指定的table变量在栈中的索引。 （旁白：小笨木，我被你绕晕了。。。）   为了照顾旁白这个笨蛋，我们画个图来理解： 这是初始状态，堆栈里还没有任何东西，那么，现在要先把helloTable变量放到栈顶： /* 取得table变量，在栈顶 */    lua_getglobal(pL, \"helloTable\");   然后就变成了这样： 接着，我们要取得table的name对应的值，那么，先要做的就是把”name”字符串入栈： /* 将C++的字符串放到Lua的栈中，此时，栈顶变为“name”， helloTable对象变为栈底 */    lua_pushstring(pL, \"name\");   然后变成这样： （旁白：不带这样啊，你偷偷加上了栈的索引~！）   注意了，我把栈的索引也加上了，因为我们即将要使用，这次我们用负数索引（不了解负数的索引的朋友请阅读第03章的教程哈~）。 由于”name”的入栈，现在helloTable变量已经不在栈顶了。 接着，我们调用要做最重要的一步了，取得name在table中对应的值： /*         从table对象寻找“name”对应的值（table对象现在在索引为-2的栈中，也就是当前的栈底）,        取得对应值之后，将值放回栈顶    */    lua_gettable(pL, -2);   此时，栈变成这样： （旁白：发生什么事？为什么“mutou”突然出现在栈顶？！为毛！是你自己画上去的吧！）   lua_gettable倒底做了什么事情？ 首先，我们来解释一下lua_gettable的第二个参数，-2是什么意思，-2就是刚刚helloTable变量在栈中的索引。 然后，Lua会去取得栈顶的值（之前的栈顶是”name”），然后拿着这个值去helloTable变量中寻找对应的值，当然就找到”mutou”了。 最后，Lua会把找到的值入栈，于是”mutou”就到了栈顶了。 （旁白：你妹纸的。。。没事，我就骂骂人）   最后我们只需要取出栈顶的数据就可以了，完整代码如下： /* 初始化 */    lua_State* pL = lua_open();    luaopen_base(pL);    /* 执行脚本 */    luaL_dofile(pL, \"helloLua.lua\");    /* 取得table变量，在栈顶 */    lua_getglobal(pL, \"helloTable\");    /* 将C++的字符串放到Lua的栈中，此时，栈顶变为“name”， helloTable对象变为栈底 */    lua_pushstring(pL, \"name\");    /*         从table对象寻找“name”对应的值（table对象现在在索引为-2的栈中，也就是当前的栈底）,        取得对应值之后，将值放回栈顶    */    lua_gettable(pL, -2);    /* 现在表的name对应的值已经在栈顶了，直接取出即可 */    const char* sName = lua_tostring(pL, -1);    CCLOG(\"name = %s\", sName);   好了，本章到此结束。     .","title":"【木头Cocos2d-x 029】Lua篇（第04章）：来点高难度的，获取Lua表结构数据"},{"content":"                  一直以为dpad not enabled in avd是我的AVD出问题了，其实不是，解决办法很简单的（我也一直没注意，今天分享下，希望帮助大家搞定难题）          有可能大家都跟我犯同一个错误，就是不希望AVD真用的内存多而把512M改小，其实没必要，下面是图解安装AVD的过程，注意内存设置得一致啊   当上面的步骤没有成功时，再做下面的操作，不过我的已经成功了       愿君试验成功！","title":"andriod dpad not enabled in avd\"你不用再纠结最新版的难题"},{"content":"AppWidget应用小部件详解（一）           App Widget就是一个能够嵌入到别的应用程序（比如说Home screen）的应用小部件，而我们android手机也自带了一些这样的小部件，通过如下的步骤就能将手机自带的应用小部件添加到手机桌面：         1、长按手机桌面没有应用快捷键的空白区域，就会出现如下的小窗口：                   2、从窗口中选择 WIDGETS  的选项，接着也会出现一个手机所有应用小部件列表的窗口：                   3、选择需要添加应用小部件，该应用小部件就会添加到手机桌面上。                    知道了怎样将应用小部件添加到手机桌面之后，接下来开始讲如何创建自定义的App Widget，编写App Widget之前需要知道的一些概念信息：          1、AppWidgetProviderInfo对象：用来描述App Widget的元数据，比如App Widget的布局、更新频率等，这个类并不需要我们创建，只需定义一个xml文件，android系统会根据这个xml创建这个AppWidgetProviderInfo对象。          2、AppWidgetProvider的实现类：是基于Broadcast事件的类，通过定义一些基本的方法与App Widget进行交互；当App Widget更新、激活、失效、删除的时候都会通过广播的形式通知这个类。          3、View的布局：App Widget初始化的布局文件。                    知道这些概念之后，接下来进行进行自定义数字时钟的App Widget创建（基于android系统2.2）          1、首先创建AppWidgetProviderInfo对象，即在res/xml目录下创建一个appwidget_provider_time.xml，其代码如下：         <!-- android:minWidth:App Widget的最小宽度\tandroid:minHeight:App Widget的最小高度\tandroid:updatePeriodMillis:App Widget的更新频率android:initialLayout:App Widget的初始化界面--><appwidget-provider xmlns:android=\"http://schemas.android.com/apk/res/android\"    android:minWidth=\"50dp\"    android:minHeight=\"25dp\"    android:updatePeriodMillis=\"86400000\"    android:initialLayout=\"@layout/appwidget_provider_clock\" />         2、接着创建App Widget的布局文件，用于显示App Widget，其文件如下： <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:tools=\"http://schemas.android.com/tools\"    android:layout_width=\"200dp\"    android:layout_height=\"70dp\"    android:background=\"@drawable/shape\"    android:orientation=\"horizontal\" >    <TextView        android:id=\"@+id/txt_time\"        android:layout_width=\"0dp\"        android:layout_height=\"fill_parent\"        android:layout_margin=\"7dp\"        android:layout_weight=\"2\"        android:background=\"#FFFFFF\"        android:gravity=\"center\"        android:textColor=\"#000000\"        android:textStyle=\"bold\"        android:textSize=\"25sp\" />    <RelativeLayout        android:layout_width=\"0dp\"        android:layout_height=\"fill_parent\"        android:layout_weight=\"1.5\"        android:layout_marginTop=\"6dp\"        android:layout_marginBottom=\"5dp\"        android:layout_marginRight=\"3dp\" >        <TextView            android:id=\"@+id/txt_week\"            android:layout_width=\"fill_parent\"            android:layout_height=\"wrap_content\"            android:gravity=\"center\"            android:textColor=\"#FFFFFF\"            android:layout_alignParentTop=\"true\" />        <TextView            android:id=\"@+id/txt_day\"            android:layout_width=\"fill_parent\"            android:layout_height=\"wrap_content\"            android:gravity=\"center\"            android:textColor=\"#FFFFFF\"            android:textSize=\"25sp\"            android:layout_centerInParent=\"true\" />        <TextView            android:id=\"@+id/txt_month\"            android:layout_width=\"fill_parent\"            android:layout_height=\"wrap_content\"            android:gravity=\"center\"            android:textColor=\"#FFFFFF\"            android:layout_alignParentBottom=\"true\" />    <\/RelativeLayout><\/LinearLayout>        3、然后创建AppWidgetProvider的实现类ClockAppWidgetProvider，用来接收App Widget发布的广播，根据广播进行相关的创建、更新App Widget等操作，其核心代码如下：  private Context context;\tprivate AppWidgetManager appWidgetManager;\tprivate Timer timer;\t\t//月份\tprivate String[] months = new String[]{\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"};\t//星期\tprivate String[] weeks = new String[]{\"Monday\", \"Tuesday\", \"Wednesday \", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"};\t@Override\tpublic void onUpdate(Context context, AppWidgetManager appWidgetManager,\t\t\tint[] appWidgetIds) {\t\t\t\t//创建定时器\t\ttimer = new Timer();\t\t\t\tthis.context = context;\t\tthis.appWidgetManager = appWidgetManager;\t\t\t\t//进行周期性调度: 1s更新一次界面\t\ttimer.schedule(new TimerTask() {\t\t\t\t\t\t@Override\t\t\tpublic void run() {\t\t\t\t//通知更新界面\t\t\t\thandler.sendEmptyMessage(0x123);\t\t\t}\t\t}, 0, 1000);\t}\tprivate Handler handler = new Handler()\t{\t\t@Override\t\tpublic void handleMessage(Message msg) {\t\t\tsuper.handleMessage(msg);\t\t\t\t\t\tif(msg.what == 0x123)\t\t\t{\t\t\t\t//构造RemoteViews对象\t\t\t\tRemoteViews views = new RemoteViews(context.getPackageName(), R.layout.appwidget_provider_clock);\t\t\t\t\t\t\t\t//构造显示时间日期\t\t\t\tCalendar calendar = Calendar.getInstance(Locale.CHINA);\t\t\t\tcalendar.setTimeInMillis(System.currentTimeMillis());\t\t\t\t\t\t\t\t//构造当期显示时间\t\t\t\tStringBuffer currentTime = new StringBuffer(\"\");\t\t\t\tint temp = calendar.get(Calendar.HOUR_OF_DAY);\t\t\t\tif(temp < 10)\t\t\t\t{\t\t\t\t\tcurrentTime.append(\"0\").append(temp);\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\tcurrentTime.append(temp);\t\t\t\t}\t\t\t\ttemp = calendar.get(Calendar.MINUTE);\t\t\t\tif(temp < 10)\t\t\t\t{\t\t\t\t\tcurrentTime.append(\":\").append(\"0\").append(temp);\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\tcurrentTime.append(\":\").append(temp);\t\t\t\t}\t\t\t\ttemp = calendar.get(Calendar.SECOND);\t\t\t\tif(temp < 10)\t\t\t\t{\t\t\t\t\tcurrentTime.append(\":\").append(\"0\").append(temp);\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\tcurrentTime.append(\":\").append(temp);\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t//设置显示当前时间\t\t\t\tviews.setTextViewText(R.id.txt_time, currentTime.toString());\t\t\t\t//设置显示当前月份\t\t\t\tviews.setTextViewText(R.id.txt_month, months[calendar.get(Calendar.MONTH)]);\t\t\t\t//设置显示当前星期\t\t\t\tviews.setTextViewText(R.id.txt_week, weeks[calendar.get(Calendar.WEEK_OF_MONTH)]);\t\t\t\t//设置显示当前日期\t\t\t\tviews.setTextViewText(R.id.txt_day, String.valueOf(calendar.get(Calendar.DAY_OF_MONTH)));\t\t\t\t\t\t\t\t//将当前的ClockAppWidgetProvider包装成ComponentName对象\t\t\t\tComponentName componentName = new ComponentName(context, ClockAppWidgetProvider.class);\t\t\t\t\t\t\t\t//更新App Widget\t\t\t\tappWidgetManager.updateAppWidget(componentName, views);\t\t\t}\t\t}\t\t\t};         4、最后将ClockAppWidgetProvider类注册到AndroidManifest.xml配置文件中，其文件如下： <!-- 注册ClockAppWidgetProvider广播接收器 -->        <receiver android:name=\".ClockAppWidgetProvider\">            <!-- 广播接收的action：当appwidget改变时 -->            <intent-filter>                <action android:name=\"android.appwidget.action.APPWIDGET_UPDATE\"/>            <\/intent-filter>            <!-- 设置元数据：将ClockAppWidgetProvider类和AppWidgetProviderInfo对象appwidget_provider_time关联起来 -->            <meta-data android:name=\"android.appwidget.provider\"                android:resource=\"@xml/appwidget_provider_time\"/>        <\/receiver>         5、通过以上几步，自定义数字时钟的App Widget就创建成功了，根据之前如何将应用小部件添加到手机桌面的步骤，在WIDGETS列表中就会找到我们自定义的这个数字时钟的App Widget，如果选择该小部件，就会将其添加到手机桌面，运行结果如下所示：    ","title":"AppWidget应用小部件详解（一）"},{"content":"AppWidget应用小部件详解（二） 在上一篇的AppWidget应用小部件详解（一）中，介绍了如何自定义实现一个简单的App Widget应用小部件的步骤，而在本篇中将继续介绍自定义App Widget的创建，这次将介绍在应用小部件中显示一个列表容器视图，比如ListView、GridView、StackView、AdapterViewFlipper。接下来就实现一个基于该模式的图片浏览的App Widget。                   其实创建应用小部件的步骤都一样，只是在呈现小部件内容的处理方式上面不同罢了，现在就开始实现该图片浏览的小部件（基于android系统4.1）。         1、首先创建AppWidgetProviderInfo对象，即在res/xml目录下创建一个appwidget_provider_image.xml，该文件的内容对于所有的App Widget基本上大体相同，其代码如下： <?xml version=\"1.0\" encoding=\"utf-8\"?><appwidget-provider xmlns:android=\"http://schemas.android.com/apk/res/android\"\t\tandroid:minWidth=\"93dp\"\t\tandroid:minHeight=\"93dp\"\t\tandroid:updatePeriodMillis=\"86400000\"\t\tandroid:initialLayout=\"@layout/appwidget_provider_image\" />2、接着创建App Widget的布局文件，用于显示App Widget，该文件中有两个显示的view，StackView就是图片浏览的主要view，ImageView只是当StackView中没有内容时才会显示出来，其文件如下： <FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:tools=\"http://schemas.android.com/tools\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\" >    <StackView         android:id=\"@+id/stack_image\"        android:layout_width=\"match_parent\"        android:layout_height=\"match_parent\"        android:loopViews=\"true\" />        <ImageView         android:id=\"@+id/empty_image\"        android:layout_width=\"match_parent\"        android:layout_height=\"match_parent\"        android:src=\"@drawable/stack_img_empty\"        android:contentDescription=\"@string/app_name\"/><\/FrameLayout> 3、然后创建AppWidgetProvider的实现类StackViewAppWidgetProvider，用来接收App Widget发布的广播，根据广播进行相关的创建、更新App Widget等操作，与之前数字时钟的AppWidgetProvider实现类有所不同，StackView中显示的数据不能在当前的StackViewAppWidgetProvider类中去设置，必须通过设置RemoteAdapter来启动一个提供数据的StackRemoteViewsService服务；并且如果需要使StackView中的每一个子view都有自己独立的行为动作，就必须首先在承载该StackView的RemoteViews中设置一个PenddingIntentTemplate，对于触发的子view就可以通过这个PenddingIntentTemplate去执行其中的Intent，然后在StackRemoteViewsFactory类的getViewAt方法中为每一个子view设置一个FillInIntent，从而携带不同的数据，这样就可以在每一个子view上触发事件，通过相应的处理类进行处理，其核心代码如下： public static final String TOAST_ACTION = \"com.android.stackviewappwidget.TOAST_ACTION\";\tpublic static final String EXTRA_ITEM = \"com.android.stackviewappwidget.EXTRA_ITEM\";\t /**\t  * 广播接收处理\t  * 当intent的 action为TOAST_ACTION时，就进行相应的界面更新处理？\t  * （点击stackview的哪一个子view就将其显示在最前面）\t  */\t@Override\tpublic void onReceive(Context context, Intent intent) {\t\tsuper.onReceive(context, intent);\t\tif(intent.getAction().equals(TOAST_ACTION))\t\t{\t\t\t// 创建AppWidgetManager对象\t\t\tAppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);\t\t\t\t\t\t// 获得应用小部件的id\t\t\tint appWidgetId = intent.getIntExtra(\t\t\t\t\tAppWidgetManager.EXTRA_APPWIDGET_ID,\t\t\t\t\tAppWidgetManager.INVALID_APPWIDGET_ID);\t\t\t// 获取当前点击的stackview子view的位置\t\t\tint viewIndex = intent.getIntExtra(EXTRA_ITEM, 0);\t\t\t// 根据view的位置进行界面的更新，将该view显示在stackview的最前面\t\t\t// 创建RemoteViews对象\t\t\tRemoteViews views = createRemoteViews(context, appWidgetId);\t\t\t// 显示当前点击的子view\t\t\tviews.setDisplayedChild(R.id.stack_image, viewIndex);\t\t\t// 更新AppWidget\t\t\tappWidgetManager.updateAppWidget(appWidgetId, views);\t\t}\t}\t@Override\tpublic void onUpdate(Context context, AppWidgetManager appWidgetManager,\t\t\tint[] appWidgetIds) {\t\tsuper.onUpdate(context, appWidgetManager, appWidgetIds);\t\t\t\tfor(int i=0;i<appWidgetIds.length;i++)\t\t{\t\t\t// 构造展示图片浏览的RemoteViews对象\t\t\tRemoteViews views = createRemoteViews(context, appWidgetIds[i]);\t\t\t// 更新当前的App Widget\t\t\tappWidgetManager.updateAppWidget(appWidgetIds[i], views);\t\t}\t\t\t}\t\t/**\t * 构造展示图片浏览的RemoteViews对象\t * @return\t */\tprivate RemoteViews createRemoteViews(Context context, int appWidgetId)\t{\t\t// 创建RemoteViews对象，用于widget布局\t\tRemoteViews views = new RemoteViews(context.getPackageName(), R.layout.appwidget_provider_image);\t\t\t\t// 创建启动v\t\tIntent intent = new Intent(context, StackRemoteViewsService.class);\t\t// 将app widget id 添加到intent extras中\t\tintent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);\t\tintent.setData(Uri.parse(intent.toUri(Intent.URI_INTENT_SCHEME)));\t\t\t\t// 给views设置RemoteViews适配器\t\t// 该适配器通过intent来连接RemoteViewsService，获得展示的数据\t\tviews.setRemoteAdapter(R.id.stack_image, intent);\t\t\t\t// 如果StackView的数据为空，则显示empty_image视图\t\tviews.setEmptyView(R.id.stack_image, R.id.empty_image);\t\t\t\t/**\t\t * 创建PendingIntent模版：给子view添加独立的触发事件\t\t * 一旦点击子view之后就会发送一个带TOAST_ACTION的广播\t\t */\t\t// 创建Intent对象，用来启动StackViewAppWidgetProvider\t\tIntent toastIntent = new Intent(context, StackViewAppWidgetProvider.class);\t\t\t\t// 设置Intent的Action，启动相应组件的标识\t\ttoastIntent.setAction(TOAST_ACTION);\t\t// 将app widget id 添加到intent extras中\t\ttoastIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);\t\ttoastIntent.setData(Uri.parse(intent.toUri(Intent.URI_INTENT_SCHEME)));\t\t// 根据toastIntent创建一个启动广播接收器的PendingIntent模版\t\tPendingIntent toastPendingIntent = PendingIntent.getBroadcast(context, 0, toastIntent, PendingIntent.FLAG_UPDATE_CURRENT);\t\t// 将PendingIntent模版添加到RemoteViews中\t\tviews.setPendingIntentTemplate(R.id.stack_image, toastPendingIntent);\t\t\t\treturn views;\t} 4、创建为RemoteViewsAdapter提供数据的StackRemoteViewsService服务，该服务中的核心就是RemoteViewsFactory的实现类StackRemoteViewsFactory，该类其实类似于一个自定义的BaseAdapter，为了让StackRemoteViewsFactory能够生成显示一个view就必须实现几个核心的方法getCount、getViewAt、onCreate等。其核心代码如下： public class StackRemoteViewsService extends RemoteViewsService {\t\t// 创建RemoteViewsFactory对象\t@Override\tpublic RemoteViewsFactory onGetViewFactory(Intent intent) {\t\treturn new StackRemoteViewsFactory(this.getApplicationContext(), intent);\t}\t/**\t * StackView中RemoteViews构造器\t * @author Administrator\t *\t */\tclass StackRemoteViewsFactory implements RemoteViewsFactory\t{\t\tprivate Context mContext;\t\t// stack图片\t\tprivate int[] stackImages;\t\t\t\tpublic StackRemoteViewsFactory(Context applicationContext, Intent intent) {\t\t\tthis.mContext = applicationContext;\t\t}\t\t@Override\t\tpublic int getCount() {\t\t\treturn stackImages.length;\t\t}\t\t@Override\t\tpublic long getItemId(int position) {\t\t\treturn 0;\t\t}\t\t@Override\t\tpublic RemoteViews getLoadingView() {\t\t\treturn null;\t\t}\t\t@Override\t\tpublic RemoteViews getViewAt(int position) {\t\t\t// 创建RemoteViews对象\t\t\tRemoteViews views = new RemoteViews(mContext.getPackageName(), R.layout.appwidget_provider_item);\t\t\t\t\t\t// 设置RemoteViews中显示的图片信息\t\t\tviews.setImageViewResource(R.id.image_item, stackImages[position]);\t\t\t\t\t\t// 创建Intent对象，用来为每一个子view携带相关的数据\t\t\tIntent fillInIntent = new Intent();\t\t\tfillInIntent.putExtra(StackViewAppWidgetProvider.EXTRA_ITEM, position);\t\t\t// 通过设置setOnClickFillInIntent方法，结合PengdingIntentTemplate就可以实现子view的触发事件\t\t\tviews.setOnClickFillInIntent(R.id.image_item, fillInIntent);\t\t\t\t\t\treturn views;\t\t}\t\t@Override\t\tpublic int getViewTypeCount() {\t\t\treturn 0;\t\t}\t\t@Override\t\tpublic boolean hasStableIds() {\t\t\treturn false;\t\t}\t\t@Override\t\tpublic void onCreate() {\t\t\t// 初始化stack图片\t\t\tstackImages = new int[]{R.drawable.stack_img_1, R.drawable.stack_img_2, R.drawable.stack_img_3,\t\t\t\t\t \t\t\t\tR.drawable.stack_img_4, R.drawable.stack_img_5, R.drawable.stack_img_6,\t\t\t\t\t \t\t\t\tR.drawable.stack_img_7};\t\t}\t\t@Override\t\tpublic void onDataSetChanged() {\t\t\t\t\t}\t\t@Override\t\tpublic void onDestroy() {\t\t\t\t\t}\t\t\t}} 5、最后将StackViewAppWidgetProvider类以及StackRemoteViewsService注册到AndroidManifest.xml配置文件中，其文件如下： <!-- 处理StackViewAppWidget的广播接收器 --><receiver android:name=\".StackViewAppWidgetProvider\"            android:label=\"@string/image_view\"            android:icon=\"@drawable/image_view\">                        <intent-filter>                <action android:name=\"android.appwidget.action.APPWIDGET_UPDATE\" />                <action android:name=\"com.android.stackviewappwidget.TOAST_ACTION\" />            <\/intent-filter>                        <meta-data android:name=\"android.appwidget.provider\"                android:resource=\"@xml/appwidget_provider_image\"/>        <\/receiver>                <!-- 提供集合数据的服务：用于绑定remoteviews视图 --> <service android:name=\".StackRemoteViewsService\"             android:permission=\"android.permission.BIND_REMOTEVIEWS\"/> 6、通过以上几步，自定义图片浏览的App Widget就创建成功了，由于是运行在android4.1系统上面的，将应用小部件添加到手机桌面的方式和将应用快捷键添加到手机桌面的方式一样，其步骤以及运行结果如下所示：         点击手机屏幕下方的菜单按钮，进入所有显示应用界面：                 通过向右滑动屏幕，一般到最后一个屏幕的界面就可以找到我们自定义的图片浏览的App Widget：                  通过长按该自定义的图片浏览的App Widget的图标，就可以将其拖到手机桌面进行显示：         ","title":"AppWidget应用小部件详解（二）"},{"content":"一，问题解决 参考          1）/bin/bash: prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin/arm-eabi-gcc: 权限不够                  解决：chmod a+x prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin/arm-eabi-gcc          2）/bin/bash: build/core/find-jdk-tools-jar.sh: 权限不够                /bin/bash: build/tools/findleaves.py: 权限不够                chmod  a+x   build/core/find-jdk-tools-jar.sh                chmod  a+x   build/tools/findleaves.py          3）Your version is: java version \"1.5.0\".               The correct version is: 1.6.                解决：    新立得 上 openjdk-6-jdk                                或到这里下： http://www.oracle.com/technetwork/java/javase/downloads/jdk7u9-downloads-1859576.html          4）/bin/bash: g++: 未找到命令                解决：apt-get    install  g++          5）external/clearsilver/cgi/cgi.c:22:18: 致命错误： zlib.h：没有那个文件或目录               解决：apt-get install zlib1g-dev          6）out/host/linux-x86/obj/STATIC_LIBRARIES/libutils_intermediates/RefBase.o] 错误 1                         解决方法：                         gedit frameworks/base/libs/utils/Android.mk                         Change the line:                         LOCAL_CFLAGS += -DLIBUTILS_NATIVE=1 $(TOOL_CFLAGS)                    To:                         LOCAL_CFLAGS += -DLIBUTILS_NATIVE=1 $(TOOL_CFLAGS)  -fpermissive         7）/bin/bash: flex: 未找到命令               解决：apt-get install flex         8）out/host/linux-x86/obj/EXECUTABLES/adb_intermediates/adb] 错误 1                           apt-get install libncurses5-dev         9）out/host/linux-x86/obj/EXECUTABLES/obbtool_intermediates/Main.o] 错误                                解决：  修改源码目录下/build/core/combo/HOST_linux-x86.mk文件：                         将以下语句                   HOST_GLOBAL_CFLAGS += -D_FORTIFY_SOURCE=0                        修改为                   HOST_GLOBAL_CFLAGS += -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=0                或者 原因： 因机器上的gcc版本过高，需替换成4.4.6重新进行编译。 解决方法： 1、安装4.4版本的gcc和g++  $ sudo apt-get install gcc-4.4$ sudo apt-get install g++-4.4 2、设置gcc版本，使gcc链接到gcc-4.4 $ ls -l /usr/bin/gcc*lrwxrwxrwx 1 root root      7 2011-11-01 23:56 /usr/bin/gcc -> gcc-4.6-rwxr-xr-x 1 root root 224544 2011-10-06 05:47 /usr/bin/gcc-4.4-rwxr-xr-x 1 root root 302104 2011-09-17 05:43 /usr/bin/gcc-4.6$ cd /usr/bin$ sudo mv gcc gcc.bak$ sudo ln -s gcc-4.4 gcc 3、设置g++版本，使g++链接到g++-4.4 $ sudo mv g++ g++.bak$ sudo ln -s g++-4.4 g++ 复制代码 4、设置完毕后，重新进行编译即可      10） sh: gperf: not found               calling gperf failed: 32512 at ./makeprop.pl line 96.                make: *** [out/target/product/generic/obj/STATIC_LIBRARIES/libwebcore_intermediates/WebCore/css/CSSPropertyNames.h] 错误 25                make: *** 正在删除文件“out/target/product/generic/obj/STATIC_LIBRARIES/libwebcore_intermediates/WebCore/css/CSSPropertyNames.h”               解决方法：apt-get install libgl1-mesa-dev               结果：Android 编译完成后,将在根目录中生成一个 out 文件夹,所有生成的内容均放置在这个文件夹中。               out 文件夹如下所示: out/ |-- CaseCheck.txt |-- casecheck.txt |-- host |    |-- common |    `-- linux-x86 `-- target       |-- common       `-- product            主要的两个目录为 host 和 target，前者表示在主机(x86)生成的工具,后者表示目标机(模认为 ARMv5)运行的内容。 host 目录的结构如下所示: out/host/ |-- common |     `-- obj  (JAVA 库) `-- linux-x86      |-- bin   (二进制程序)      |-- framework     (JAVA 库,*.jar 文件)      |-- lib       (共享库*.so)      `-- obj      (中间生成的目标文件) host 目录是一些在主机上用的工具,有一些是二进制程序,有一些是 JAVA 的程序。 target 目录的结构如下所示: out/target/ |-- common |     |-- R   (资源文件) |     |-- docs |     `-- obj   (目标文件) `-- product       `-- generic     其中 common 目录表示通用的内容,product 中则是针对产品的内容。     在 common 目录的 obj 中,包含两个重要的目录:           APPS 中包含了 JAVA 应用程序生成的目标,每个应用程序对应其中一个子目录,将结合每个应用程序的原始文件生成 Android 应用程序的 APK 包。          JAVA_LIBRARIES 中包含了 JAVA 的库,每个库对应其中一个子目录。 在默认的情况下,Android 编译将生成 generic 目录,如果选定产品还可以生成其他的目录。 generic 包含了以下内容:            out/target/product/generic/ |-- android-info.txt |-- clean_steps.mk |-- data |-- obj |-- ramdisk.img |-- root |-- symbols |-- system |-- system.img |-- userdata-qemu.img `-- userdata.img 编译也可以：$ make -j4                    这里-j4表示用四个线程编译，4表示线程数，读者可根据自己机器的情况设置（如机器为单CPU双核处理器，可设置为-j2或-j4，即该数为CPU内核总数或内核总数的2倍。） 成功后：         Install: out/target/product/generic/system/app/Contacts.apk         Finding NOTICE files: out/target/product/generic/obj/NOTICE_FILES/hash-timestamp         Combining NOTICE files: out/target/product/generic/obj/NOTICE.html         Target system fs image: out/target/product/generic/obj/PACKAGING/systemimage_intermediates/system.img         Install system fs image: out/target/product/generic/system.img         Installed file list: out/target/product/generic/installed-files.txt 运行编译成功的文件： $ vi .bashrc  添加：         export Android_PRODUCT_OUT=~/桌面/android2.3.4_32bit/out/target/product/generic           Android_PRODUCT_OUT_BIN=~/桌面/android2.3.4_32bit/out/host/linux-x86/bin           export PATH=${PATH}:${ANDROID_PRODUCT_OUT_BIN}:${ANDROID_PRODUCT_OUT}; $ source .bashrc $ emulator -image system.img -data userdata.img -ramdisk ramdisk.img 错误： emulator: ERROR: You did not specify a virtual device name, and the system directory could not be found. If you are an Android SDK user, please use '@<name>' or '-avd <name>' to start a given virtual device (see -help-avd for details). Otherwise, follow the instructions in -help-disk-images to start the emulator 原因是你没有建立avd，建立方法如下： 1、cd到bin 目录下，终端中输入 ./android 执行该脚本，启动 Android SDK Manager -> Tools -> Manage AVDs -> 打开 Android Virtual Device Manager 后，新建一个avd，然后再执行emulator -avd my_avd -partition-size 512 便可正常 错误：          SWT folder '/root/桌面/android2.3.4_32bit/out/host/linux-x86/framework/x86' does not exist.          Please export ANDROID_SWT to point to the folder containing swt.jar for your platform. 错误：Error: Error parsing the sdk.             Error: /root/桌面/android2.3.4_32bit/out/host/linux-x86/platforms is missing.             Error: Unable to parse SDK content.             但在out/host/linux-x86/sdk/android-sdk_eng.lawrencekang_linux-x86/tools目录下 ./android 则可以              原来在out/host/linux-x86/sdk/android-sdk_eng.lawrencekang_linux-x86/下面有platforms目录，可见android会查找上一级目录下的platforms目录     将platforms 和add-ons copy到 out/host/linux-x86下面然后运行 android就可以了 二，编译SDK          $ make  sdk                  生成：out/host/linux-x86/sdk/android-sdk_eng.root_linux-x86.zip                  将 out/host/linux-x86/sdk/android-sdk_eng.huangjx_linux-x86.zip 解压到本地目录。进入tools 目录,输入下面的命令创建 AVD: $ ./android create avd -t 1 -c 128M -n froyo -s HVGA           //建立目标机器 froyo        出现错误：Error: Target id is not valid. Use 'android list targets' to get the target ids.       Android 2.2 is a basic Android platform.       Do you wish to create a custom hardware profile [no]       Created AVD 'froyo' based on Android 2.2, with the following hardware config:        hw.lcd.density=160        输入下面的命令,启动模拟器: $ ./emulator -avd froyo -partition-size 160 & 三，编译完成SDK 就要启动模拟器         Android list 查看可以用的 sdk 和 avd  发现 为空自己编译的android sdk无法识别各版本platform的问题         进入编译结果目录 out/host/linux-x86/sdk/android-sdk_eng.cmoaciopm_linux-x86/tools 发现android-2.3是存在的，那为什么SDKManager检测不到呢？         SDKManager无法检测到Installpackages的原因了，我所检出的androidgingerbread源代码编译出的sdk目录结构与SDKManager检测逻辑是不一致的。         调整： android在2.3对sdk目录结构进行了调整，将platform下面的tools文件夹移动到SDK根目录下，命名为platform-tools（里面包含了该platform的aapt和adb等工具。这样，platform在各操作系统下都统一了，不需要再为不同操作系统发布不同的platform，仅发布不同的platform-tools即可）。          可见gingerbreak代码分支中sdkmanager的代码不是“最新的”，没有与编译出来的sdk目录结构保持一致。          做了软链接，骗过sdkmanager，重启检测一切正常          ln  -sf   /home/justin/android/src/out/host/linux-x86/sdk/android-sdk_eng.justin_linux-x86/tools        ~/android/sdk         根据自己的路径设置吧         启动虚拟机出现             SDL init failure, reason is: No available video device: OnUbuntu64         问题需要安装                  apt-get install ia32-libs lib32stdc++6        问题Cannot load 32-bit SWT libraries on 64-bit JVM                  1.For Eclipse, go to Eclipse -> Preferences -> Java -> Installed JRE                   2.For Flash Builder, go to Flash Builder -> Preferences -> Java ->Installed JREs Then, edit the selected Java VM, adding the following value forthe Default VM Arguments field -d32 启动编译好的源码（模拟器） 1）自己有一个可以运行的 SDK库，将编译好的 SDK 版本拷贝到platforms 文件夹下面","title":"【Android源码】源码编译"},{"content":"Android开发工控软件--蓝牙控制 最近一直在忙android的工控软件设计，写一点心得，希望对这方面开发的有一点带你帮助。 1）从蓝牙接收了数据又如何保存？ 之前没有想过接收的数据如何保存，就简单的用一个字节数组进行保存，后来处理数据的时候就遇到了一堆问题，不是指令处理不对，就是接收的数据少了一部分，或是接收的数据还没有处理又被覆盖了，最后只能采用队列的方式保存数据，然后再根据定义的数据格式进行提取数据，再进行处理。 2）设备与手机终端之间的通信协议如何设计？ 项目已开始也没有好好考虑这个通信协议，通信格式不规范，这样会增加数据处理的难度，还会造成数据处理出错，工控软件还讲究的是实时性，所以 这个处理速度还是必须的，一个很好的通信协议对整个软件构架都有影响，设计不好，只能是不是得打补丁，建议使用TLV的格式，设计设备与终端之间的通信协议。 3）设备与终端之间是否需要心跳？ 这个毫无疑问是必须的，如果没有心跳，那蓝牙断开连接了双方都不知道，这样一直开着终端是毫无意义的。 4）如何增强用户体验？ android软件不单单是界面需要用户体验高，工控软件内部处理流程也需要处理好，内部的流程直接影响到用户体验，比如说终端与设备之间自动关联，设备与终端断开连接以后，提醒用户去关联设备，或是内部进行自动连接","title":"Android开发工控软件--蓝牙控制"},{"content":"1、类目（Category）的基本概念        封装是面向对象的一个特征，oc也不例外，但是有的时候我们会碰到一种情况，比如我们封装了一个类，不想再动它了，但是我们又需要在那个类中增加一个方法，这时候我们就不必在那个类中做修改或者再定义一个它的子类，只需要添加一个类目（Category）即可。      （1） 在类目中定义的方法，会成为原始类的一部分，与其他方法的调用没有区别       （2）通过给父类定义类目方法，其子类也会继承这些方法。 类目的应用：（1）对现有的类进行扩展（2）作为子类的替代手段（3）对类中的方法归类 类目的局限性：         无法想类目中添加新的实例变量，类目没有位置来容纳实例变量，如果想增加类的实例变量，只能通过定义子类的方式         如果在类目中覆盖现有类的方法，这样会引起super的消息的断裂，因为类目中的方法具有更高的优先级，因此，一般不要覆盖现有类中的方法 类目的定义、 类目的命名规则：类名（扩展方法名） 类目不继承父类，只需要一个括号表明该类目的用途即可 #import <Foundation/Foundation.h>@interface NSString (MyCompare)-(void)test;@end #import \"NSString+MyCompare.h\"@implementation NSString (MyCompare)-(void)test{    }@end","title":"[置顶] Objective-c中Category的用法"},{"content":"    xaml开发是为win8平板电脑专门做的一个开发框架。个人理解，不知对不对。     容易上手，先说说平台的搭建。       1、安装win8。 这是必须的，要不你连调试环境都没有。先不要着急”激活“，你懂的。       2、安装vs2012。据说vs2010安装插件也能开发，有兴趣的可以百度。推荐安装2012，速度比2010快。       3、在”新建项目“中选择\"Windows 应用商店\" ->”空白应用程序（xaml）\"写好项目名，点确定。       4、要求更新开发许可证。这个让你干啥你干啥就行，也不要钱。没有windows的邮箱就注册一个，反正不会怀孕。另外有人可能会弹一个“无法获得您的许可证\"。记得我让你不要着急激活吗？       5、许可证发下来后，程序创建完成。双击资源管理器中”MainPage.xaml\"。第一次运行可能会向你要管理员权限，给它就是了。       6、出现一个图形化界面，拽个控件进去，随便设置下属性，比如text什么的。       7、抬头找到工具调中的绿箭头。旁边下拉菜单中选模拟器。然后点绿箭头调试。       8、会弹出一个虚拟机。这个跟Android虚拟机不太一样。它跟你正运行的系统共用资源的，相当于另一个视图。换句话说，你没必要把他关上，因为他不是另运行起来的虚拟机。       9、画面一闪，你看到那个控件了，Hello XAML。       本篇博客出自阿修罗道，转载请注明出处：http://blog.csdn.net/fansongy/article/details/8455800  ","title":"xaml开发环境快速配置"},{"content":"一、    添加分区信息并启动jffs2文件系统 烧写之前的内核看输出分区信息 TQ2440 # tftp 32000000uImage dm9000 i/o: 0x20000000, id:0x90000a46 DM9000: running in 16 bitmode MAC: 00:0c:29:4d:e4:f4 Using dm9000 device TFTP from server172.28.12.60; our IP address is 172.28.12.10 Filename 'uImage'. Load address: 0x32000000 Loading: T#################################################################         #################################################################          ################ done Bytes transferred = 2138388(20a114 hex) TQ2440 # bootm 32000000 ………… Creating 4 MTD partitions on\"NAND\": 0x000000000000-0x000000040000: \"u-boot\" 0x000000040000-0x000000060000: \"params\" 0x000000060000-0x000000360000: \"kernel\" 0x000000360000-0x000010000000: \"rootfs\" ………… 修改配置文件include\\configs\\tq2440.h打开之前屏蔽的MTDPARTS命令的宏 #if 0 #define CONFIG_CMD_FAT #define CONFIG_CMD_EXT2 #define CONFIG_CMD_UBI #define CONFIG_CMD_UBIFS #endif #define CONFIG_CMD_MTDPARTS #if 0 #define CONFIG_MTD_DEVICE #defineCONFIG_MTD_PARTITIONS #define CONFIG_YAFFS2 #define CONFIG_RBTREE #endif 添加如下分区信息 #define CONFIG_MTD_DEVICE #defineMTDIDS_DEFAULT              \"nand0=tq2440-0\"  /*哪一个设备 */ #defineMTDPARTS_DEFAULT  \"mtdparts=tq2440-0:256k(u-boot),\"       \\                                      \"128k(params),\"          \\                                      \"3m(kernel),\"  \\                                      \"-(rootfs)\"        \\ 重新编译，烧到开发板并启动 U-Boot 2012.04.01 (Dec 312012 - 16:52:29) CPUID: 32440001 FCLK:      400 MHz HCLK:      100 MHz PCLK:       50 MHz DRAM:  64 MiB WARNING: Caches not enabled Flash: *** failed *** NAND:  256 MiB In:    serial Out:   serial Err:   serial Net:   dm9000 TQ2440 # mtdparts default第一次启动首先执行mtdparts default TQ2440 # save Saving Environment to NAND... Erasing Nand... Erasing at 0x40000 -- 100% complete. Writing to Nand... done TQ2440 # mtdparts device nand0<tq2440-0>, # parts = 4  #: name                size            offset          mask_flags  0: u-boot              0x00040000      0x00000000      0  1: params              0x00020000      0x00040000      0  2: kernel              0x00300000      0x00060000      0  3: rootfs              0x0fca0000      0x00360000      0 active partition: nand0,0 -(u-boot) 0x00040000 @ 0x00000000 defaults: mtdids  : nand0=tq2440-0 mtdparts:mtdparts=tq2440-0:256k(u-boot),128k(params),3m(kernel),-(rootfs) TQ2440 # nand erase.part kernel NAND erase.part: device 0offset 0x60000, size 0x400000 Erasing at 0x440000 -- 100%complete. OK TQ2440 # tftp 32000000 uImage dm9000 i/o: 0x20000000, id:0x90000a46 DM9000: running in 16 bitmode MAC: 00:0c:29:4d:e4:f4 Using dm9000 device TFTP from server172.28.12.60; our IP address is 172.28.12.10 Filename 'uImage'. Load address: 0x32000000 Loading: T#################################################################         #################################################################          ################ done Bytes transferred = 2138388(20a114 hex) TQ2440 # nand write 32000000 kernel NAND write: device 0 offset0x60000, size 0x400000  4194304 bytes written: OK 设置启动参数 TQ2440 # set bootcmd nand read 32000000 kernel\\;bootm 32000000 TQ2440 # save Saving Environment toNAND... Erasing Nand... Erasing at 0x40000 -- 100%complete. Writing to Nand... done 烧写jffs2文件系统 TQ2440 # tftpboot 32000000 rootfs.jffs2 dm9000 i/o: 0x20000000, id:0x90000a46 DM9000: running in 16 bitmode MAC: 00:0c:29:4d:e4:f4 Using dm9000 device TFTP from server172.28.12.60; our IP address is 172.28.12.10 Filename 'rootfs.jffs2'. Load address: 0x32000000 Loading: T#################################################################         #################################################################         #################################################################          ############################ done Bytes transferred = 3262836(31c974 hex) TQ2440 # nand erase.part rootfs NAND erase.part: device 0offset 0x460000, size 0xfba0000 Skipping bad block at  0x08260000                                          Erasing at 0xffe0000 -- 100%complete. OK TQ2440 # nand write 32000000 rootfs $filesize NAND write: device 0 offset0x460000, size 0x31c974  3262836 bytes written: OK 设置启动参数 TQ2440 # set bootargs root=/dev/mtdblock3 rootfstype=jffs2init=/linuxrc console=ttySAC0,115200 TQ2440 # save Saving Environment toNAND... Erasing Nand... Erasing at 0x40000 -- 100%complete. Writing to Nand... done TQ2440 # res  重启 resetting ... U-Boot 2012.04.01 (Dec 31 2012- 16:52:29)   CPUID: 32440001 FCLK:      400 MHz HCLK:      100 MHz PCLK:       50 MHz DRAM:  64 MiB WARNING: Caches not enabled Flash: *** failed *** NAND:  256 MiB In:    serial Out:   serial Err:   serial Net:   dm9000 Hit any key to stopautoboot:  0   NAND read: device 0 offset0x60000, size 0x300000  3145728 bytes read: OK ## Booting kernel fromLegacy Image at 32000000 ...    Image Name:  Linux-2.6.36.4    Created:     2012-12-31   8:37:05 UTC    Image Type:  ARM Linux Kernel Image (uncompressed)    Data Size:   2138324 Bytes = 2 MiB    Load Address: 30008000    Entry Point: 30008000    Verifying Checksum ... OK    Loading Kernel Image ... OK OK   Starting kernel ...   Uncompressing Linux... done,booting the kernel. Linux version 2.6.36.4(root@zjh) (gcc version 4.4.3 (ctng-1.6.1) ) #4 Mon Dec 31 16:36:50 CST 2012 CPU: ARM920T [41129200]revision 0 (ARMv4T), cr=c0007177 CPU: VIVT data cache, VIVTinstruction cache Machine: SMDK2440 Memory policy: ECC disabled,Data cache writeback CPU S3C2440A (id 0x32440001) S3C24XX Clocks, Copyright2004 Simtec Electronics S3C244X: core 400.000 MHz,memory 100.000 MHz, peripheral 50.000 MHz CLOCK: Slow mode (1.500MHz), fast, MPLL on, UPLL on Built 1 zonelists in Zoneorder, mobility grouping on.  Totalpages: 16256 Kernel command line:root=/dev/mtdblock3 rootfstype=jffs2 init=/linuxrc console=ttySAC0,115200 PID hash table entries: 256(order: -2, 1024 bytes) Dentry cache hash table entries:8192 (order: 3, 32768 bytes) Inode-cache hash tableentries: 4096 (order: 2, 16384 bytes) Memory: 64MB = 64MB total Memory: 60620k/60620kavailable, 4916k reserved, 0K highmem Virtual kernel memorylayout:     vector : 0xffff0000 - 0xffff1000   (   4 kB)     fixmap : 0xfff00000 - 0xfffe0000   ( 896kB)     DMA    : 0xffc00000 - 0xffe00000   (   2 MB)     vmalloc : 0xc4800000 - 0xe0000000   ( 440 MB)     lowmem : 0xc0000000 - 0xc4000000   (  64 MB)     modules : 0xbf000000 - 0xc0000000   (  16MB)       .init : 0xc0008000 - 0xc0028000   ( 128 kB)       .text : 0xc0028000 - 0xc03d1000   (3748 kB)       .data : 0xc03ea000 - 0xc040cac0   ( 139 kB) Hierarchical RCUimplementation.         RCU-based detection of stalled CPUs isdisabled.         Verbose stalled-CPUs detection isdisabled. NR_IRQS:85 irq: clearing subpendingstatus 00000002 Console: colour dummy device80x30 console [ttySAC0] enabled Calibrating delay loop...199.47 BogoMIPS (lpj=498688) pid_max: default: 32768minimum: 301 Mount-cache hash tableentries: 512 CPU: Testing write buffercoherency: ok gpiochip_add: gpios 288..303(GPIOK) failed to register gpiochip_add: gpios 320..334(GPIOL) failed to register gpiochip_add: gpios 352..353(GPIOM) failed to register NET: Registered protocolfamily 16 S3C Power Management,Copyright 2004 Simtec Electronics S3C2440: Initialisingarchitecture S3C2440: IRQ Support S3C24XX DMA Driver,Copyright 2003-2006 Simtec Electronics DMA channel 0 at c4808000,irq 33 DMA channel 1 at c4808040, irq34 DMA channel 2 at c4808080,irq 35 DMA channel 3 at c48080c0,irq 36 S3C244X: Clock Support, DVSoff bio: create slab<bio-0> at 0 SCSI subsystem initialized usbcore: registered newinterface driver usbfs usbcore: registered newinterface driver hub usbcore: registered newdevice driver usb s3c-i2c s3c2440-i2c: slaveaddress 0x10 s3c-i2c s3c2440-i2c: busfrequency set to 97 KHz s3c-i2c s3c2440-i2c: i2c-0:S3C I2C adapter Advanced Linux SoundArchitecture Driver Version 1.0.23. NET: Registered protocolfamily 2 IP route cache hash tableentries: 1024 (order: 0, 4096 bytes) TCP established hash tableentries: 2048 (order: 2, 16384 bytes) TCP bind hash table entries:2048 (order: 1, 8192 bytes) TCP: Hash tables configured(established 2048 bind 2048) TCP reno registered UDP hash table entries: 256(order: 0, 4096 bytes) UDP-Lite hash table entries:256 (order: 0, 4096 bytes) NET: Registered protocolfamily 1 RPC: Registered udptransport module. RPC: Registered tcptransport module. RPC: Registered tcp NFSv4.1backchannel transport module. NetWinder Floating PointEmulator V0.97 (extended precision) JFFS2 version 2.2. (NAND)(SUMMARY)  © 2001-2006 Red Hat, Inc. ROMFS MTD (C) 2007 Red Hat,Inc. msgmni has been set to 118 io scheduler noop registered io scheduler deadlineregistered io scheduler cfq registered(default) Console: switching to colourframe buffer device 30x40 fb0: s3c2410fb frame bufferdevice lp: driver loaded but nodevices found ppdev: user-space parallelport driver Serial: 8250/16550 driver, 4ports, IRQ sharing enabled s3c2440-uart.0:s3c2410_serial0 at MMIO 0x50000000 (irq = 70) is a S3C2440 s3c2440-uart.1:s3c2410_serial1 at MMIO 0x50004000 (irq = 73) is a S3C2440 s3c2440-uart.2:s3c2410_serial2 at MMIO 0x50008000 (irq = 76) is a S3C2440 brd: module loaded loop: module loaded Uniform Multi-Platform E-IDEdriver ide-gd driver 1.18 ide-cd driver 5.00 S3C24XX NAND Driver, (c)2004 Simtec Electronics s3c24xx-nand s3c2440-nand:Tacls=1, 10ns Twrph0=3 30ns, Twrph1=1 10ns s3c24xx-nand s3c2440-nand:NAND soft ECC NAND device: ManufacturerID: 0xec, Chip ID: 0xda (Samsung NAND 256MiB 3,3V 8-bit) Scanning device for badblocks Bad eraseblock 1043 at0x000008260000 Creating 4 MTD partitions on\"NAND\": 0x000000000000-0x000000040000: \"u-boot\" 0x000000040000-0x000000060000: \"params\" 0x000000060000-0x000000360000: \"kernel\" 0x000000360000-0x000010000000: \"rootfs\" dm9000 Ethernet Driver,V1.31 usbmon: debugfs is notavailable ohci_hcd: USB 1.1 'Open'Host Controller (OHCI) Driver s3c2410-ohci s3c2410-ohci:S3C24XX OHCI s3c2410-ohci s3c2410-ohci:new USB bus registered, assigned bus number 1 s3c2410-ohci s3c2410-ohci:irq 42, io mem 0x49000000 hub 1-0:1.0: USB hub found hub 1-0:1.0: 2 portsdetected usbcore: registered newinterface driver libusual usbcore: registered newinterface driver usbserial USB Serial supportregistered for generic usbcore: registered newinterface driver usbserial_generic usbserial: USB Serial Drivercore USB Serial supportregistered for FTDI USB Serial Device usbcore: registered newinterface driver ftdi_sio ftdi_sio: v1.6.0:USB FTDISerial Converters Driver USB Serial supportregistered for pl2303 usbcore: registered newinterface driver pl2303 pl2303: Prolific PL2303 USBto serial adaptor driver mice: PS/2 mouse devicecommon for all mice S3C24XX RTC, (c) 2004,2006Simtec Electronics S3C2410 Watchdog Timer, (c)2004 Simtec Electronics s3c2410-wdt s3c2410-wdt:watchdog inactive, reset disabled, irq enabled No device for DAI UDA134X No device for DAIs3c24xx-i2s ALSA device list:   No soundcards found. TCP cubic registered NET: Registered protocolfamily 17 drivers/rtc/hctosys.c:unable to open rtc device (rtc0) VFS: Mounted root (jffs2filesystem) on device 31:3. Freeing init memory: 128K   Please press Enter toactivate this console. Processing /etc/profile... Done [root@tq2440 /]#","title":"u-boot-2012.04.01移植到TQ2440(七)：添加分区信息并启动jffs2文件系统"},{"content":"http://forums.codelite.org/viewtopic.php?f=13&t=1966&p=8775#p8775 codelite\\LiteEditor> svn diff quickfindbar*.* > quickfindbar.patch the attached is my patch for quickfindbar. It just simply change the textctrl into combobox. Index: quickfindbar.cpp =================================================================== --- quickfindbar.cpp (revision 5950) +++ quickfindbar.cpp (working copy) @@ -33,7 +33,11 @@  #include <wx/stc/stc.h>  #include \"stringsearcher.h\"  #include \"quickfindbar.h\" +#include <wx/config.h>   +//to store and load config like find/replacewith  +wxConfig *config = new wxConfig(\"CodeLite\"); +  DEFINE_EVENT_TYPE(QUICKFIND_COMMAND_EVENT)    #define CHECK_FOCUS_WIN() {\\ @@ -82,6 +86,16 @@      wxTheApp->Connect(XRCID(\"find_next_at_caret\"),     wxEVT_COMMAND_MENU_SELECTED, wxCommandEventHandler(QuickFindBar::OnFindNextCaret),     NULL, this);      wxTheApp->Connect(XRCID(\"find_previous_at_caret\"), wxEVT_COMMAND_MENU_SELECTED, wxCommandEventHandler(QuickFindBar::OnFindPreviousCaret), NULL, this);      Connect(QUICKFIND_COMMAND_EVENT, wxCommandEventHandler(QuickFindBar::OnQuickFindCommandEvent), NULL, this); + + //load config like find/replace list + wxString str; + for(int i=0;i<10;i++){ + if ( config->Read(wxString::Format(wxT(\"find%i\"),i), &str) )  + m_findWhat->Append(str); + if ( config->Read(wxString::Format(wxT(\"replace%i\"),i), &str) )  + m_replaceWith->Append(str); + + }  }    bool QuickFindBar::Show(bool show) @@ -160,12 +174,20 @@  void QuickFindBar::OnNext(wxCommandEvent &e)  {      wxUnusedVar(e); + int tmppos= m_findWhat->FindString(m_findWhat->GetValue(), false); + if ( tmppos != wxNOT_FOUND ) m_findWhat->Delete( tmppos ); + m_findWhat->Insert(m_findWhat->GetValue(), 0); + if (m_findWhat->GetCount()>10) m_findWhat->Delete(10);      DoSearch(true, false);  }    void QuickFindBar::OnPrev(wxCommandEvent &e)  {      wxUnusedVar(e); + int tmppos= m_findWhat->FindString(m_findWhat->GetValue(), false); + if ( tmppos != wxNOT_FOUND ) m_findWhat->Delete( tmppos ); + m_findWhat->Insert(m_findWhat->GetValue(), 0); + if (m_findWhat->GetCount()>10) m_findWhat->Delete(10);      DoSearch(false, false);  }   @@ -206,7 +228,8 @@    void QuickFindBar::OnCopy(wxCommandEvent& e)  { -    wxTextCtrl *ctrl = GetFocusedControl(); +//    wxTextCtrl *ctrl = GetFocusedControl(); +    wxComboBox *ctrl = GetFocusedControl();      if ( !ctrl ) {          e.Skip();          return; @@ -218,7 +241,8 @@    void QuickFindBar::OnPaste(wxCommandEvent& e)  { -    wxTextCtrl *ctrl = GetFocusedControl(); +//    wxTextCtrl *ctrl = GetFocusedControl(); +    wxComboBox *ctrl = GetFocusedControl();      if ( !ctrl ) {          e.Skip();          return; @@ -230,7 +254,8 @@    void QuickFindBar::OnSelectAll(wxCommandEvent& e)  { -    wxTextCtrl *ctrl = GetFocusedControl(); +//    wxTextCtrl *ctrl = GetFocusedControl(); +    wxComboBox *ctrl = GetFocusedControl();      if ( !ctrl ) {          e.Skip();      } else { @@ -240,7 +265,8 @@    void QuickFindBar::OnEditUI(wxUpdateUIEvent& e)  { -    wxTextCtrl *ctrl = GetFocusedControl(); +//    wxTextCtrl *ctrl = GetFocusedControl(); +    wxComboBox *ctrl = GetFocusedControl();      if ( !ctrl ) {          e.Skip();          return; @@ -272,6 +298,16 @@      wxString find          = m_findWhat->GetValue();      wxString replaceWith   = m_replaceWith->GetValue();   + int tmppos= m_findWhat->FindString(m_findWhat->GetValue(), false); + if ( tmppos != wxNOT_FOUND ) m_findWhat->Delete( tmppos ); + m_findWhat->Insert(m_findWhat->GetValue(), 0); + if (m_findWhat->GetCount()>10) m_findWhat->Delete(10); + + tmppos= m_replaceWith->FindString(m_replaceWith->GetValue(), false); + if ( tmppos != wxNOT_FOUND ) m_replaceWith->Delete( tmppos ); + m_replaceWith->Insert(m_replaceWith->GetValue(), 0); + if (m_replaceWith->GetCount()>10) m_replaceWith->Delete(10); +  #ifndef __WXMAC__      int re_flags = wxRE_ADVANCED;  #else @@ -329,7 +365,8 @@                  !m_findWhat->GetValue().IsEmpty());  }   -wxTextCtrl* QuickFindBar::GetFocusedControl() +//wxTextCtrl* QuickFindBar::GetFocusedControl() +wxComboBox* QuickFindBar::GetFocusedControl()  {      wxWindow *win = wxWindow::FindFocus();   @@ -679,4 +716,12 @@      wxTheApp->Disconnect(XRCID(\"find_previous\"),          wxEVT_COMMAND_MENU_SELECTED, wxCommandEventHandler(QuickFindBar::OnFindPrevious),      NULL, this);      wxTheApp->Disconnect(XRCID(\"find_next_at_caret\"),     wxEVT_COMMAND_MENU_SELECTED, wxCommandEventHandler(QuickFindBar::OnFindNextCaret),     NULL, this);      wxTheApp->Disconnect(XRCID(\"find_previous_at_caret\"), wxEVT_COMMAND_MENU_SELECTED, wxCommandEventHandler(QuickFindBar::OnFindPreviousCaret), NULL, this); + + //store config like find/replace list + for(int i=0;i<m_findWhat->GetCount();i++){ + config->Write(wxString::Format(wxT(\"find%i\"),i), m_findWhat->GetString(i) ); + } + for(int i=0;i<m_replaceWith->GetCount();i++){ + config->Write(wxString::Format(wxT(\"replace%i\"),i), m_replaceWith->GetString(i) ); + }  } Index: quickfindbar.h =================================================================== --- quickfindbar.h (revision 5950) +++ quickfindbar.h (working copy) @@ -42,7 +42,8 @@      void     DoMarkAll();      wchar_t* DoGetSearchStringPtr();   -    wxTextCtrl *GetFocusedControl(); +//    wxTextCtrl *GetFocusedControl(); +    wxComboBox *GetFocusedControl();      void DoShowControls();        // General events Index: quickfindbarbase.cpp =================================================================== --- quickfindbarbase.cpp (revision 5950) +++ quickfindbarbase.cpp (working copy) @@ -71,7 +71,8 @@   m_staticTextFind->Wrap( -1 );   fgSizer1->Add( m_staticTextFind, 0, wxALIGN_CENTER_VERTICAL|wxALL, 2 );   - m_findWhat = new wxTextCtrl( this, wxID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxTE_PROCESS_ENTER|wxTE_RICH2 ); +// m_findWhat = new wxTextCtrl( this, wxID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxTE_PROCESS_ENTER|wxTE_RICH2 ); + m_findWhat = new wxComboBox( this, wxID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, 0, NULL, wxTE_PROCESS_ENTER|wxCB_DROPDOWN );   m_findWhat->SetToolTip( _(\"Hit ENTER to search, or Shift + ENTER to search backward\") );     fgSizer1->Add( m_findWhat, 1, wxALIGN_CENTER_VERTICAL|wxALL|wxEXPAND, 2 ); @@ -92,7 +93,8 @@   m_replaceStaticText->Wrap( -1 );   fgSizer1->Add( m_replaceStaticText, 0, wxALIGN_CENTER_VERTICAL|wxALL, 2 );   - m_replaceWith = new wxTextCtrl( this, wxID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxTE_PROCESS_ENTER|wxTE_RICH2 ); +// m_replaceWith = new wxTextCtrl( this, wxID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxTE_PROCESS_ENTER|wxTE_RICH2 ); + m_replaceWith = new wxComboBox( this, wxID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, 0, NULL, wxTE_PROCESS_ENTER|wxCB_DROPDOWN );   fgSizer1->Add( m_replaceWith, 1, wxALIGN_CENTER_VERTICAL|wxALL|wxEXPAND, 2 );     m_toolBarReplace = new clToolBar( this, wxID_ANY, wxDefaultPosition, wxDefaultSize, clTB_DEFAULT_STYLE ); Index: quickfindbarbase.h =================================================================== --- quickfindbarbase.h (revision 5950) +++ quickfindbarbase.h (working copy) @@ -25,6 +25,7 @@  #include <wx/sizer.h>  #include <wx/checkbox.h>  #include <wx/panel.h> +#include <wx/combobox.h>  #include \"cl_defs.h\"    //#ifdef USE_AUI_TOOLBAR @@ -60,10 +61,12 @@   clToolBar*    m_toolBar1;   wxStaticLine* m_staticline3;   wxStaticText* m_staticTextFind; - wxTextCtrl*   m_findWhat; +// wxTextCtrl*   m_findWhat; + wxComboBox*   m_findWhat;   clToolBar*    m_toolBar2;   wxStaticText* m_replaceStaticText; - wxTextCtrl*   m_replaceWith; +// wxTextCtrl*   m_replaceWith; + wxComboBox*   m_replaceWith;   clToolBar*    m_toolBarReplace;   wxStaticLine* m_staticline1;   wxCheckBox*   m_checkBoxCase;","title":"quickfindbar.patch for codelite"},{"content":"首先在google.com搜索关键字“Android Maven”，可得到如下信息 http://code.google.com/p/maven-android-plugin/ 打开该网页，点击 GettingStarted 跳转到http://code.google.com/p/maven-android-plugin/wiki/GettingStarted 该页面 该连接下有一片整理得非常完善的文档，当然，全英文，本人英语没过B级阅读起来非常痛苦，此时此刻，非常羡慕那些看英文跟我看天朝文字一样流利的孩子 可以看一下关于Android项目的介绍 众所周知，一般Android的项目可以使用Eclipse+adt来构建 单独使用ant也可以进行项目的打包编译集成，adt其实也是基于ant android-maven-plugin也是可以的 搭建环境 安装jdk 略过  我的是这个版本Java(TM) SE Runtime Environment (build 1.6.0_38-b05)  如需ubuntu 安装配置jdk的教程，请点击  http://hi.baidu.com/xingfukaixin/item/fa85176ad76dba34ad3e8364 安装Android-sdk   http://developer.android.com/sdk/index.html 到Maven的官方下载最新版本的Maven 下载地址 http://maven.apache.org/download.html 我下载的是 Maven 3.0.4 找个文件夹解压，并配置到系统的环境变量 /home/wuyexiong/Android/tool/maven/apache-maven-3.0.4/bin 配置到/etc/environment ANDROID_HOME=\"/home/wuyexiong/Android/android-linux/adt-bundle-linux-x86_64/sdk\" 想编译Android项目还差最后一部 ，用git把 Maven AndroidSDK Deployer  项目载到本地 在此之前的环境都搭建完毕的前提下，进入该项目的跟目录 执行 mvn clean install 。 就会自动构建Android-maven的编译环境 中途会下载一些东西，检查你的sdk等等，稍作等候即可 [INFO] ------------------------------------------------------------------------[INFO] Reactor Summary:[INFO] [INFO] Maven Android SDK Deployer ........................ SUCCESS [0.232s][INFO] Android Platforms ................................. SUCCESS [0.007s][INFO] Android Platform 1.5 API 3 ........................ SUCCESS [0.065s][INFO] Android Platform 1.6 API 4 ........................ SUCCESS [0.013s][INFO] Android Platform 2.1 API 7 ........................ SUCCESS [0.012s][INFO] Android Platform 2.2 API 8 ........................ SUCCESS [0.013s][INFO] Android Platform 2.3.3 API 10 ..................... SUCCESS [0.013s][INFO] Android Platform 3.0 API 11 ....................... SUCCESS [0.028s][INFO] Android Platform 3.1 API 12 ....................... SUCCESS [0.013s][INFO] Android Platform 3.2 API 13 ....................... SUCCESS [0.013s][INFO] Android Platform 4.0 API 14 ....................... SUCCESS [0.012s][INFO] Android Platform 4.0.3 API 15 ..................... SUCCESS [0.013s][INFO] Android Platform 4.1 API 16 ....................... SUCCESS [0.013s][INFO] Android Platform 4.2 API 17 ....................... SUCCESS [0.012s][INFO] Android Add-Ons ................................... SUCCESS [0.006s][INFO] Android Add-On Google Platform 1.5 API 3 (Maps) ... SUCCESS [0.018s][INFO] Android Add-On Google Platform 1.6 API 4 (Maps) ... SUCCESS [0.013s][INFO] Android Add-On Google Platform 2.1 API 7 (Maps) ... SUCCESS [0.013s][INFO] Android Add-On Google Platform 2.2 API 8 (Maps) ... SUCCESS [0.014s][INFO] Android Add-On Google Platform 2.3.3 API 10 (Maps and USB)  SUCCESS [0.017s][INFO] Android Add-On Google Platform 3.0 API 11 (Maps) .. SUCCESS [0.013s][INFO] Android Add-On Google Platform 3.1 API 12 (Maps and USB)  SUCCESS [0.017s][INFO] Android Add-On Google Platform 3.2 API 13 (Maps and USB)  SUCCESS [0.016s][INFO] Android Add-On Google Platform 4.0 API 14 (Maps and USB)  SUCCESS [0.017s][INFO] Android Add-On Google Platform 4.0.3 API 15 (Maps and USB)  SUCCESS [0.018s][INFO] Android Add-On Google Platform 4.1 API 16 (Maps and USB)  SUCCESS [0.019s][INFO] Android Add-On Google Platform 4.2 API 17 (Maps and USB)  SUCCESS [0.018s][INFO] Android Extras .................................... SUCCESS [0.009s][INFO] Android Compatibility Extra V4 .................... SUCCESS [0.013s][INFO] Android Compatibility Extra V7 Gridlayout Library . SUCCESS [1.999s][INFO] Android Compatibility Extra V13 ................... SUCCESS [0.009s][INFO] Android Google Analytics Extra .................... SUCCESS [0.009s][INFO] Android Google AdMob Ads Extra .................... SUCCESS [0.009s][INFO] Android Google Cloud Messaging Library Extra Parent  SUCCESS [0.006s][INFO] Android Google Cloud Messaging Client Library Extra  SUCCESS [0.010s][INFO] Android Google Cloud Messaging Server Library Extra  SUCCESS [0.010s][INFO] Android Google Play Services Extra ................ SUCCESS [0.460s][INFO] Android Google Play Licensing Extra ............... SUCCESS [0.297s][INFO] Android Extras - Apk Expansion .................... SUCCESS [0.006s][INFO] Android Google Play APK Expansion Extra - ZIP ..... SUCCESS [0.240s][INFO] Android Google Play APK Expansion Extra - Downloader  SUCCESS [0.314s][INFO] Android Tools ..................................... SUCCESS [0.004s][INFO] Android Annotations ............................... SUCCESS [0.007s][INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 5.277s[INFO] Finished at: Mon Dec 31 16:42:23 CST 2012[INFO] Final Memory: 24M/298M[INFO] ------------------------------------------------------------------------ 出现以上，就代表 android-maven的初步环境构建完毕 cd ~/.m2/ 到该目录下打开repository的文件夹即可查看到已经配置好相关的Android环境了 测试android-maven 下载可供给打包测试的例子代码 Download samples from the stable branch 解压该项目，进入 jayway-maven-android-plugin-samples-b17572a 文件夹 drwxrwxr-x  4 wuyexiong wuyexiong  4096 12月 31 15:49 apidemos-android-10/-rw-rw-r--  1 wuyexiong wuyexiong   136 12月 19 10:25 .gitignoredrwxrwxr-x  4 wuyexiong wuyexiong  4096 12月 19 10:25 helloflashlight/drwxrwxr-x  6 wuyexiong wuyexiong  4096 12月 19 10:25 libraryprojects/-rw-rw-r--  1 wuyexiong wuyexiong 10173 12月 19 10:25 LICENSE.txtdrwxrwxr-x  5 wuyexiong wuyexiong  4096 12月 19 10:25 morseflash/drwxrwxr-x 13 wuyexiong wuyexiong  4096 12月 19 10:25 native/-rw-rw-r--  1 wuyexiong wuyexiong  7548 12月 19 10:25 pom.xml-rw-rw-r--  1 wuyexiong wuyexiong   942 12月 19 10:25 README.txtdrwxrwxr-x  4 wuyexiong wuyexiong  4096 12月 19 10:25 scala/drwxrwxr-x  5 wuyexiong wuyexiong  4096 12月 31 15:34 support4demos/ 可以看到都是一些例子的代码。 这时候可以进入具体的一个项目，比如进入support4demos -rw-rw-r--  1 wuyexiong wuyexiong 10630 12月 19 10:25 AndroidManifest.xml-rw-rw-r--  1 wuyexiong wuyexiong  1909 12月 19 10:25 pom.xml-rw-rw-r--  1 wuyexiong wuyexiong   377 12月 19 10:25 README.txtdrwxrwxr-x 10 wuyexiong wuyexiong  4096 12月 19 10:25 res/drwxrwxr-x  3 wuyexiong wuyexiong  4096 12月 19 10:25 src/ 这是完整项目的文件了 打开模拟器，或者链接上手机，执行 mvn clean install 即可编该程序了 也可以只是执行 mvn package 来进行打包， 即可在项目下生成一个target的目录，目录底下都是一些目标文件 这两种默认都是以debug签名的，更多待研究了。。。 最后执行 mvn android:deploy 即可安装到模拟器或者手机 编译并安装是执行 mvn clean install android:deploy [INFO]                                                                         [INFO] ------------------------------------------------------------------------[INFO] Building Android Support V4 Demos 1.0.0-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO] [INFO] --- android-maven-plugin:3.5.0:deploy (default-cli) @ support4demos ---[INFO] Waiting for initial device list from the Android Debug Bridge[INFO] Found 1 devices connected with the Android Debug Bridge[INFO] android.device parameter not set, using all attached devices[INFO] Successfully installed /home/wuyexiong/Android/tool/maven/jayway-maven-android-plugin-samples-b17572a/support4demos/target/support4demos.apk to MX3ACA1ALGVA8Q1125_Meizu_M031[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 8.965s[INFO] Finished at: Mon Dec 31 16:55:09 CST 2012[INFO] Final Memory: 17M/146M[INFO] ------------------------------------------------------------------------         本章到此了,我也是刚研究这个，因为发现github上面很多开源项目都是带有pom.xml这个文件的，所以下了解一下，最好能深入一下。                  循序渐进吧。等待研究更深入的东西，把笔记都记到这上面        ","title":"Android-Maven-入门初试[ubuntud]"},{"content":"效果图 LayOut文件 <RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:tools=\"http://schemas.android.com/tools\"    android:id=\"@+id/root\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\"    android:background=\"@color/red\" >    <GridView        android:id=\"@+id/gridview\"        android:layout_width=\"fill_parent\"        android:layout_height=\"fill_parent\"        android:layout_margin=\"10dp\"        android:background=\"@color/blue\"        android:columnWidth=\"90dp\"        android:gravity=\"center\"        android:horizontalSpacing=\"10dp\"        android:numColumns=\"auto_fit\"        android:stretchMode=\"columnWidth\"        android:verticalSpacing=\"10dp\"         /><\/RelativeLayout> <TextView xmlns:android=\"http://schemas.android.com/apk/res/android\"    android:id=\"@android:id/text1\"    android:layout_width=\"match_parent\"    android:layout_height=\"wrap_content\"    android:background=\"@android:color/black\"    android:gravity=\"center_vertical\"    android:minHeight=\"?android:attr/listPreferredItemHeight\"    android:paddingLeft=\"6dip\"    android:textAppearance=\"?android:attr/textAppearanceLarge\" /> Activity文件 public class Example extends Activity {    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.main);        String[] array = new String[] {\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\"};        List<String> list = new ArrayList<String>(Arrays.asList(array));        GridView grid = (GridView) findViewById(R.id.gridview);        grid.setAdapter(new ArrayAdapter<String>(this, R.layout.list_item, list));    }}","title":"Android中GridView设置边框"},{"content":"博客出自：http://blog.csdn.net/liuxian13183，转载注明出处！ All Rights Reserved ! 纸上得来终觉浅，绝知此事要躬行！看别人的翻译，总是觉得不清不楚，特意把API中Activity原文翻译下来，觉得脱落呢！借此分享给大家！ 以下文章它代指“Activity”，创建代指\"onCreate\"，中止代指\"onPause\"，恢复代指\"onResume\"，销毁代指\"onDestroy\" Activity是一个应用程序组件，它提供了一个屏幕，用户可以参与互动做一些事情，比如打电话、拍照、发送电子邮件或者查看地图。每个 Activity都有一个窗体，用来绘制用户界面。通常情况下，窗口会填满整个屏幕，但也可能比屏幕小而浮在它的顶部。 一个应用程序通常是由多个彼此松散的Activity绑定在一起。通常情况下，一个Activity在应该程序中被指定为“main”，那么首次启动应用 程序时，它将展现给用户。然后每个Activity都可以通过动作来启动其他Activity，每次一个新Activity启动时，上一个活动就会停止，但系 统会把这个Activity保存在堆栈里（“后退堆栈”）。当一个新的Activity启动时，它被推入后退堆栈并成为用户操作对象。后退堆栈遵循 “后进先出”的原则，这样用户按下后退键时，它被弹出堆栈（销毁），并恢复到以前的Activity（后退堆栈会在“任务和后退堆栈文档里讲 述）。 当一个活动因一个新活动的启动而停止时，它通过生命周期的回调查方法来改变通知。有几种Activity可能因改变其状态而会接收的回调方法 ，无论是处于系统创建(create)、停止(stop)、恢复(resume)还是销毁(destroy)状态，每一个回调方法都提供执行具体工作的机会。例如，当 Activity停止(stop)时，它需要翻译大数据对象，如网络或数据库连接。当它恢复（resume）时，你可以去获取必要的资源和恢复被中断的操 作，这些状态转变是生命周期的所有组成部分。 接下来将基础的讲述如果创建并使用它，包括一个完整的生命周期是如何工作的，这样你就能正确的管理它的各种状态之间的过渡。 创建它 要创建它，你必须创建一个它的子类（或现有的子类）。在子类中，你要实现当它的各种状态发生改变时系统所调用的回调方法，比如它的创 建(oncreate)、停止(onstop)、恢复(onresume)和销毁(ondestroy)，以下是两个最重要的回调方法： onCreate() 你必须实现这个方法，当你创建它的时候系统会调用这个方法。在你的实现方法中，你应该初始化它所需要的各种重要组件，最重要的你必须 调用 setContentView()方法来定义用户界面的布局。 onPause() 系统调用这个方法的第一个迹象是，用户离开了当前的Activity（尽管这并不意味着它已经被销毁）。在这里应用提交用户的所有更改，因为 超过了当前的会话时间（用户可能不回来了）。还有其它几个需要用到的生命周期的回调方法，主要用来提供一个流畅的用户体验，处理它可 能被停止或者销毁的一些突发事件。所有的生命周期回调方法将在稍后的“管理生命周期”部分有讲。 实现用户界面 一个用户界面的Activity，提供从view类派生的视图对象层次结构。每个视图都控件着一个特定矩形的活动窗口，用来响应用户的交互。例如 ，一个视图可能是一个按钮，用户触摸它启动一个动作。 安卓提供了一系列现成的view用来设计和组织布局，“Widgets”是一种为屏幕提供可视化互动元素的组件，提供如按钮,文本字段，复选框， 或只是一张图片。布局是一些来自己ViewGroup的视图，为其子类提供独特的布局模型，如线性布局，网格布局，或相对布局。你还可以使用 View或ViewGroup的子类（或现有的子类）来创建自己的\"widgets\"和布局，将它们应用到Activity的布局。 最常用定义布局的方法是使用一个保存在应用程序中资源的xml文件。通过这种方式，你可以保持你的用户界面设计与定义Activity行为的源代 码分开。你可以通过setContentView（）来加载UI设置的布局，通过资源的ID来定义操作布局。但是，你也可以在Activity里通过代码创建新 的视图，并创建一个视图层次结构，通过使用通过根结点ViewGroup的setContentView（）方法来插入新的视图。 创建用户界面的详细信息，请参见用户接口文档。 在manifest声明Activity 你必须在manifest文件中声明它，以便它可以访问系统。声明它的时候，需要打开manifest文件，并为<application>添加子元素<activity>， 例如： <manifest ... >   <application ... >       <activity android:name=\".ExampleActivity\" />       ...   <\/application ... >   ... <\/manifest > 还有其它几个属性可以包含在此元素中，来定义它的属性，如它的标签，它的图标，它的主题样式。android:name这个属性是必须的，用来区 别它的名字。一旦你发布了你的应用程序，你就不能去改变它了，因为这么可能会破坏一些功能，如应用程序的快捷方式（阅读记录以及其它 一些无法改变的事情）。 参阅<activity>元素的引用，获得更多关于在manifest文件中声明你的Activity的信息。 使用intent filters <activity>元素可以指定，使用<intent-filter>元素声明的不同意图的过滤器，以使其他组件能够激活它。 当你使用Android SDK工具创建一个新的应用，自动创建的子Activity会为你创建一个过滤器，用来声明主活动，并放入\"launcher\"类别。 <activity android:name=\".ExampleActivity\" android:icon=\"@drawable/app_icon\">     <intent-filter>         <action android:name=\"android.intent.action.MAIN\" />         <category android:name=\"android.intent.category.LAUNCHER\" />     <\/intent-filter> <\/activity> <action>元素指定这是主程序入口，<category>元素指定，它可以在系统应用程序中列出来（允许用户启动它）。 如果你打算让你的应用程序是独立的，不让其他应用程序激活其activity，那就没有必要设置过滤器，就像前面的例子，设置一个主动作 和\"launch\"就行。如果你不想让其他应用看到你的activities，就不要设置过滤器，你可以自己用显式启动（在下面的章节中讨论）。 但是如果你希望你的Activity可以响应来自其它或自己的intent，那么你必须为你的Activity定义一个附加过滤器。对于每一个你想响应的 intent，必须包含一个 <intent-filter> 元素和一个<action>元素，同时<category>和<data>元素是可选的。这些元素用来区别activity响应 的不同意图。 想要了解更更多关于意图的信息，请参阅意图和意图过滤器（Intent and Intent Filters）文件。 启动它 你可以传递一个intent，说明启动Activity的类型，并通过startActivity（）方法来启动另一个Activity。intent用于指定确切的Activity， 并描述执行的操作类型（系统会选中合适的Activity，甚至不同应用程序的Activity）。用Intent启动另外一个活动时，也可以携带少量数据 。 在自己的应用程序中，你经常需要启动一个已知的Activity。你可以通过类名来创建一个intent启动确定的Activity。例如，下面是如何启动 一个叫SignInActivity的Activity。 Intent intent = new Intent(this, SignInActivity.class); startActivity(intent); 但是，你的应用程序可能想通过当前Activity的数据，执行一些操作如发邮件、短信，或状态更新。在这种情况下，应用程序可能没有相应的 Activity来执行这些操作，这样你可以利用设备上的其他应用程序所包含的Activity来执行相应操作。这就是intent有用的地方--你可以创建 一个你想执行动作的intent，系统就会启动相应其他程序的activity。如果有很多可以处理这个意图的应用程序，那么用户可以选择一个使用 。例如，如果你想发邮件，你可以使用下面的intent： Intent intent = new Intent(Intent.ACTION_SEND); intent.putExtra(Intent.EXTRA_EMAIL, recipientArray); startActivity(intent); 添加到intent上的 EXTRA_EMAIL数据是一个字符串的电邮地址。当一个电邮程序响应这个意图时，它读取这个字符串作为电邮的接收方。在这 种情况下，电邮程序启动，完成后activity就会恢复。","title":"Android高级开发第二讲--Android中API翻译之Activity"},{"content":"感觉cocos2d/x的各种编辑器还是挺丰富的，但由于都是免费的软件，其中有各种隐患，cocos2d/x在不断的更新，但如果相应的编辑器没更新的话，这软件就不能用了，或者有些软件的bug层出不穷，所以自己能动手开发相应的编辑器还是有必要的。一开始想用windows的GDI开发，后来再想了一下为啥不直接用cocos2d-x来开发呢，将cocos2d-x嵌入到MFC里，就可以将windows各种强大的控件跟cocos2d-x各种动画结合起来了。          原理很简单，cocos2d-x在windows上运行的时候其实也是依赖于窗口的，但那是一个顶层窗口，要稍微修改一下，将cocos2d-x运行在一个子窗口里，这样就能嵌入到编辑器里。          打开cocos2d-x的libcoco2d库里的platform/win32/CCEGLView.cpp，替换bool CCEGLView::Create()的代码： bool bRet = false;    do    {        CC_BREAK_IF(m_hWnd);        HINSTANCE hInstance = GetModuleHandle( NULL );        WNDCLASS  wc;        // Windows Class Structure        // Redraw On Size, And Own DC For Window.        wc.style          = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;        wc.lpfnWndProc    = _WindowProc;                    // WndProc Handles Messages        wc.cbClsExtra     = 0;                              // No Extra Window Data        wc.cbWndExtra     = 0;                                // No Extra Window Data        wc.hInstance      = hInstance;                        // Set The Instance        wc.hIcon          = LoadIcon( NULL, IDI_WINLOGO );    // Load The Default Icon        wc.hCursor        = LoadCursor( NULL, IDC_ARROW );    // Load The Arrow Pointer        wc.hbrBackground  = NULL;                           // No Background Required For GL        wc.lpszMenuName   = m_menu;                         //        wc.lpszClassName  = kWindowClassName;               // Set The Class Name        CC_BREAK_IF(! RegisterClass(&wc) && 1410 != GetLastError());        // center window position        RECT rcDesktop;        GetWindowRect(GetDesktopWindow(), &rcDesktop);        WCHAR wszBuf[50] = {0};        MultiByteToWideChar(CP_UTF8, 0, m_szViewName, -1, wszBuf, sizeof(wszBuf));        // create window        m_hWnd = CreateWindowEx(            WS_EX_APPWINDOW | WS_EX_WINDOWEDGE,    // Extended Style For The Window            kWindowClassName,                                    // Class Name            wszBuf,                                                // Window Title            WS_CAPTION | WS_POPUPWINDOW | WS_MINIMIZEBOX,        // Defined Window Style            0, 0,                                                // Window Position            //TODO: Initializing width with a large value to avoid getting a wrong client area by 'GetClientRect' function.            1000,                                               // Window Width            1000,                                               // Window Height            NULL,                                                // No Parent Window            NULL,                                                // No Menu            hInstance,                                            // Instance            NULL );        CC_BREAK_IF(! m_hWnd);        bRet = initGL();\t\tif(!bRet) destroyGL();        CC_BREAK_IF(!bRet);        s_pMainWindow = this;        bRet = true;    } while (0);#if(_MSC_VER >= 1600)    m_bSupportTouch = CheckTouchSupport();    if(m_bSupportTouch)\t{\t    m_bSupportTouch = (s_pfRegisterTouchWindowFunction(m_hWnd, 0) != 0);    }#endif /* #if(_MSC_VER >= 1600) */    return bRet; 替换为 bool bRet = false;    do    {        CC_BREAK_IF(m_hWnd);        HINSTANCE hInstance = GetModuleHandle( NULL );        WNDCLASS  wc;        // Windows Class Structure        // Redraw On Size, And Own DC For Window.        wc.style          = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;        wc.lpfnWndProc    = _WindowProc;                    // WndProc Handles Messages        wc.cbClsExtra     = 0;                              // No Extra Window Data        wc.cbWndExtra     = 0;                                // No Extra Window Data        wc.hInstance      = hInstance;                        // Set The Instance        wc.hIcon          = LoadIcon( NULL, IDI_WINLOGO );    // Load The Default Icon        wc.hCursor        = LoadCursor( NULL, IDC_ARROW );    // Load The Arrow Pointer        wc.hbrBackground  = NULL;                           // No Background Required For GL        wc.lpszMenuName   = NULL;                         //        wc.lpszClassName  = kWindowClassName;               // Set The Class Name        CC_BREAK_IF(! RegisterClass(&wc) && 1410 != GetLastError());        // center window position        RECT rcDesktop;        //GetWindowRect(GetDesktopWindow(), &rcDesktop);\t\tGetClientRect(mParentHwnd,&rcDesktop);        WCHAR wszBuf[50] = {0};        MultiByteToWideChar(CP_UTF8, 0, m_szViewName, -1, wszBuf, sizeof(wszBuf));        // create window        m_hWnd = CreateWindowEx(            WS_EX_APPWINDOW | WS_EX_WINDOWEDGE,    // Extended Style For The Window            kWindowClassName,                                    // Class Name            wszBuf,                                                // Window Title            WS_CHILDWINDOW|WS_VISIBLE,        // Defined Window Style            0, 0,                                                // Window Position            //TODO: Initializing width with a large value to avoid getting a wrong client area by 'GetClientRect' function.            1000,                                               // Window Width            1000,                                               // Window Height            mParentHwnd,                                                // No Parent Window            NULL,                                                // No Menu            hInstance,                                            // Instance            NULL );        CC_BREAK_IF(! m_hWnd);        bRet = initGL();\t\tif(!bRet) destroyGL();        CC_BREAK_IF(!bRet);        s_pMainWindow = this;        bRet = true;    } while (0);#if(_MSC_VER >= 1600)    m_bSupportTouch = CheckTouchSupport();    if(m_bSupportTouch)\t{\t    m_bSupportTouch = (s_pfRegisterTouchWindowFunction(m_hWnd, 0) != 0);    }#endif /* #if(_MSC_VER >= 1600) */    return bRet; 在libcocos2d项目下增加一个文件，里面存放MFC跟cocos2d-x交互的C函数。 extern \"C\"{\tCC_DLL bool M2InitializeApplication( HWND hwnd )\t{\t\tcocos2d::CCEGLView::SetParentHwnd(hwnd);\t\t// create the application instance\t\tAppDelegate app;\t\tcocos2d::CCEGLView* eglView = cocos2d::CCEGLView::sharedOpenGLView();\t\teglView->setFrameSize(480, 320);\t\t// The resolution of ipad3 is very large. In general, PC's resolution is smaller than it.\t\t// So we need to invoke 'setFrameZoomFactor'(only valid on desktop(win32, mac, linux)) to make the window smaller.\t\t//eglView->setFrameZoomFactor(0.4f);\t\tcocos2d::CCApplication::sharedApplication()->run();\t\treturn true;\t}\tCC_DLL bool M2GameCleanUp()\t{\t\tcocos2d::CCDirector::sharedDirector()->end();\t\tcocos2d::CCEGLView* eglView = cocos2d::CCEGLView::sharedOpenGLView();\t\teglView->Destroy();\t\treturn true;\t}\tCC_DLL bool M2GameLoop( float interval )\t{\t\tcocos2d::CCDirector::sharedDirector()->mainLoop();\t\treturn true;\t}} 后在MFC的对话框或View的初始化函数里增加如下代码，以绑定cocos2d的句柄并设置cocos2d视口的大小： HWND hCocos = ::GetDlgItem(this->m_hWnd, IDC_PANEL);\tCRect rect;\t::GetWindowRect(hCocos, &rect);\tScreenToClient(&rect);\t::MoveWindow(hCocos, rect.left, rect.top, 480, 320, TRUE);\t::M2InitializeApplication(hCocos); 增加一个定时器辅助cocos2d进行重绘： SetTimer(1,16,NULL); 在OnTimer函数里刷新cocos2d-x: ::M2GameLoop(16); DEMO可以在这里下载：http://download.csdn.net/detail/visualcatsharp/4947482","title":"使用cocos2d-x开发各种编辑器"},{"content":"Android菜单详解——理解android中的Menu 前言 今天看了pro android 3中menu这一章，对Android的整个menu体系有了进一步的了解，故整理下笔记与大家分享。 PS：强烈推荐《Pro Android 3》，是我至今为止看到的最好的一本android书，中文版出到《精通Android 2》。 理解Android的菜单 菜单是许多应用程序不可或缺的一部分，Android中更是如此，所有搭载Android系统的手机甚至都要有一个\"Menu\"键，由此可见菜单在Android程序中的特殊性。Android SDK提供的菜单有如下几种： 选项菜单：最常规的菜单，android中把它叫做option menu 子菜单：android中点击子菜单将弹出悬浮窗口显示子菜单项。子菜单不支持嵌套，即子菜单中不能再包括其他子菜单。 上下文菜单：android中长按视图控件后出现的菜单，windows点击右键弹出的菜单即上下文菜单 图标菜单：这个比较简单，就是带icon的菜单项，需要注意的是子菜单项、上下文菜单项、扩展菜单项均无法显示图标。 选择菜单(alternative menu)：用的比较少，以后单独介绍，本文先跳过（其实是我还没弄明白啦o(≧v≦)o~~） 扩展菜单：选项菜单最多只能显示6个菜单项，超过6个时，第6个菜单项会被系统替换为一个叫“更多”的子菜单，原来显示不下的菜单项都作为“更多”菜单的子菜单项。如下图： 　　    　　 　　　　　　　　第6个菜单项自动变为“更多”　　　　　　　　　　　　　　点击“更多”显示其他菜单项 Android3.0又引入了一个叫action bar的东西，本文不做讲解，大家自己google。 android.view.Menu接口代表一个菜单，android用它来管理各种菜单项。注意我们一般不自己创建menu，因为每个Activity默认都自带了一个，我们要做的是为它加菜单项和响应菜单项的点击事件。android.view.MenuItem代表每个菜单项，android.view.SubMenu代表子菜单。其三者的关系可以用下图来表示 　　 上面说过，每个activity包含一个菜单，一个菜单又能包含多个菜单项和多个子菜单，子菜单其实也是菜单（因为它实现了Menu接口），因此子菜单也可以包含多个菜单项。SubMenu继承了Menu的addSubMenu()方法，但调用时会抛出运行时错误。OnCreateOptionsMenu()和OnOptionsMenuSelected()是activity中提供了两个回调方法，用于创建菜单项和响应菜单项的点击。 创建options menu 之前提到，Android的activity已经为我们提前创建好了android.view.Menu对象，并提供了回调方法onCreateOptionsMenu(Menu menu)供我们初始化菜单的内容。该方法只会在选项菜单第一次显示的时候被执行，如果你需要动态改变选项菜单的内容，请使用 onPrepareOptionsMenu(Menu)。   @Overridepublicboolean onCreateOptionsMenu(Menu menu) {    // 调用父类方法来加入系统菜单    // 虽然目前android还没有系统菜单，但是为了兼容到以后的版本，最好加上super.onCreateOptionsMenu(menu);       // 添加菜单项（多种方式）    // 1.直接指定标题    menu.add(\"菜单项1\");    // 2.通过资源指定标题    menu.add(R.string.menuitem2);    // 3.显示指定菜单项的组号、ID、排序号、标题    menu.add(            1,            //组号            Menu.FIRST, //唯一的ID号            Menu.FIRST, //排序号\"菜单项3\"); //标题       // 如果希望显示菜单，请返回truereturntrue;} 上面的代码演示了添加菜单项的3种方法，下面解释下第三种方法add(int groupId, int itemId, int order, CharSequence title)。其中，第一个参数是组号，android中你可以给菜单分组，以便快速地操作同一组的菜单。第二个参数指定每个菜单项的唯一ID号，你可以自己指定，也可以让系统来自动分配，在响应菜单时你需要通过ID号来判断哪个菜单被点击了。因此常规的做法是定义一些ID常量，但在android中有更好的方法，就是通过资源文件来引用，这个之后介绍。第三个参数代表菜单项显示顺序的编号，编号小的显示在前面。 给菜单项分组 @Overridepublicboolean onCreateOptionsMenu(Menu menu) {    super.onCreateOptionsMenu(menu);    // 添加4个菜单项，分成2组int group1 =1;    int gourp2 =2;    menu.add(group1, 1, 1, \"item 1\");    menu.add(group1, 2, 2, \"item 2\");    menu.add(gourp2, 3, 3, \"item 3\");    menu.add(gourp2, 4, 4, \"item 4\");    // 显示菜单returntrue;}   你可以向上面这样给菜单项分组，分组之后就能使用menu中提供的方法对组进行操作了，如下：   menu.removeGroup(group1);    //删除一组菜单menu.setGroupVisible(gourp2, visible);    //设置一组菜单是否可见menu.setGroupEnabled(gourp2, enabled);    //设置一组菜单是否可点menu.setGroupCheckable(gourp2, checkable, exclusive);    //设置一组菜单的勾选情况   响应菜单项 android提供了多种响应菜单项的方式，下面一一介绍 1、通过onOptionsItemSelected方法 使用的最多方法是重写activity类的 onOptionsItemSelected(MenuItem)回调方法，每当有菜单项被点击时，android就会调用该方法，并传入被点击菜单项。   @Overridepublicboolean onOptionsItemSelected(MenuItem item) {    switch (item.getItemId()) {    //响应每个菜单项(通过菜单项的ID)case1:        // do something herebreak;    case2:        // do something herebreak;    case3:        // do something herebreak;    case4:        // do something herebreak;    default:        //对没有处理的事件，交给父类来处理returnsuper.onOptionsItemSelected(item);    }    //返回true表示处理完菜单项的事件，不需要将该事件继续传播下去了returntrue;}   以上代码可作为使用onOptionsItemSelected方法响应菜单的模板来使用，这里为了方便起见将菜单ID硬编码在程序里，你可以使用常量或资源ID来使代码更健壮。 2.使用监听器 虽然第一种方法是推荐使用的方法，android还是提供了类似java swing的监听器方式来响应菜单。使用监听器的方式分为两步:   //第一步：创建监听器类class MyMenuItemClickListener implements OnMenuItemClickListener {    @Override    publicboolean onMenuItemClick(MenuItem item) {        // do something here...returntrue;    //finish handling    }}//第二步：为菜单项注册监听器menuItem.setOnMenuItemClickListener(new MyMenuItemClickListener());   android文档对onMenuItemClick(MenuItem item)回调方法的说明是\"Called when a menu item has been invoked. This is the first code that is executed; if it returns true, no other callbacks will be executed.\" 可见该方法先于onOptionsItemSelected执行。 3.使用Intent响应菜单 第3种方式是直接在MenuItem上调用setIntent(Intent intent)方法，这样android会自动在该菜单被点击时调用 startActivity(Intent)。但是个人认为与其这样还不如直接在onOptionsItemSelected的case里手动调用 startActivity(Intent)来的直观。 Android菜单详解（三）——SubMenu和IconMenu   我们在上一篇介绍了如何在Android中创建和响应选项菜单，今天我们将探索子菜单和图标菜单。 子菜单Sub Menu   子菜单提供了一种自然的组织菜单项的方式，它被大量地运用在windows和其他OS的GUI设计中。Android同样支持子菜单，你可以通过addSubMenu(int groupId, int itemId, int order, int titleRes)方法非常方便的创建和响应子菜单。 @Overridepublicboolean onCreateOptionsMenu(Menu menu) {    int base = Menu.FIRST;    // 一个menu可以包括多个子菜单    SubMenu subMenu = menu.addSubMenu(base, base+1, Menu.NONE, \"系统设置\");    // 子菜单可以包括多个菜单项    MenuItem menuitem1 = subMenu.add(base, base+1, base+1, \"显示设置\");    subMenu.add(base, base+2, base+2, \"网络设置\");    subMenu.add(base, base+3, base+3, \"高级设置\");    subMenu.add(base, base+4, base+4, \"安全设置\");        // 子菜单项不支持显示图标，这样做是没意义的，尽管不会报错！    menuitem1.setIcon(R.drawable.displaysettings);        //但是子菜单本身是支持图标的    subMenu.setIcon(R.drawable.settings);        // 显示菜单请返回truereturntrue;} 上面的代码演示了如何创建子菜单，其菜单项的响应其实就是普通菜单项的响应，上一篇已经作了详细介绍，这里不再赘述。Android中可以为子菜单添加图标，但是不会显示其菜单项的图标，这一点需要留意。除了代码中的setIcon(int iconRes)方法，还有一个setHeaderIcon(int iconRes)方法可以添加子菜单项栏目的标题图标，效果如上面第三张图。 最后需要强调的是，Menu可以包含多个SubMenu，SubMenu可以包含多个MenuItem（这三者之间的关系见Android菜单详解（一）——理解Android中的Menu），但是SubMenu不能包含SubMenu，及子菜单不能嵌套！！！下面的代码能通过编译，但会在运行时出错。 subMenu.addSubMenu(\"又一个子菜单\"); 图标菜单Icon Menu Android支持在菜单上显示各种各样的图标，这一点我们在上面创建子菜单时已经用到了。图标菜单严格上说并不算是一种菜单的新类型，它的使用也很简单，之所以单独设一节是为了说明使用Icon的一些限制。Android中并不是所谓的菜单项都能加上图标，以下菜单项都是不可以的（这并不意味着程序会报错，而是运行时图标得不到显示）： 扩展的菜单项。如果不理解什么是扩展的菜单，可以参考Android菜单详解（一）——理解Android中的Menu 子菜单的菜单项 上下文菜单的菜单项 除此以外，带Icon的菜单项不能加上复选框(check mark)。总之，虽然精美的图标能给我们的应用增色不少，但是滥用图标也是会适得其反的，Android SDK给图标菜单加的这些限制也算是有效的防止我们滥用图标了吧。 结语 本篇介绍了Android中的子菜单和给菜单项加Icon时需要注意的几点，下一篇《Android菜单详解（四）——使用上下文菜单ContextMenu》将介绍上下文菜单Context Menu的使用。 之前在《Android菜单详解（二）——创建并响应选项菜单》和《Android菜单详解（三）——SubMenu和IconMenu》中详细讲解了选项菜单，子菜单和图标菜单。今天接着细说另一种被广泛使用的菜单——上下文菜单Context Menu。 ContextMenu简介 在Windows中，我们已经习惯了在文件上单击右键来执行“打开”、“重名名”、“剪切”、“删除”等操作，这个右键弹出的菜单就是上下文菜单。你可能会笑道：“哈哈，你不会连快捷键都不会用吧？”。咳咳，这个。。。举个例子嘛。没错，windows中快捷键能帮助我们提高操作的效率，但是android中这招可不管用喽，注意：android的上下文菜单项是不能用快捷键的。因为手机的操作方式与使用鼠标的PC操作方式不同，android是通过长按某个视图元素来弹出上下文菜单的（PS：现在大多数智能机是全触屏的，没有物理键盘，更没有使用快捷键的需要了，这项革新要归功于乔布斯在07发布的革命手机iPhone，老乔退休了，向他致敬！）。除此之外，甚至连图标和子菜单都无法用在Android的上下文菜单项中。那么，Android的上下文菜单到底如何使用？见下图 如图，上下文菜单继承了android.view.Menu，因此我们可以像操作Options Menu那样给上下文菜单增加菜单项。上下文菜单与Options Menu最大的不同在于，Options Menu的拥有者是Activity，而上下文菜单的拥有者是Activity中的View。每个Activity有且只有一个Options Menu，它为整个Activity服务。而一个Activity往往有多个View，并不是每个View都有上下文菜单，这就需要我们显示地通过registerForContextMenu(View view)来指定。 尽管上下文菜单的拥有者是View，生成上下文菜单却是通过Activity中的onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo)方法，该方法很像生成Options Menu的onCreateOptionsMenu(Menu menu)方法。两者的不同在于，onCreateOptionsMenu只在用户第一次按“Menu”键时被调用，而onCreateContextMenu会在用户每一次长按View时被调用，而且View必须已经注册了上下文菜单。 另一个值得注意的就是上图中的ContextMenuInfo，该类的对象被传入onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo)方法，那么它有什么用呢？有时候，视图元素需要向上下文菜单传递一些信息，比如该View对应DB记录的ID等，这就要使用ContextMenuInfo。需要传递额外信息的View需要重写getContextMenuInfo()方法，返回一个带有数据的ContextMenuInfo实现类对象。 介绍了这么多，下面给出一个demo演示如何创建和响应上下文菜单： 1.在activity的onCreate(...)方法中为一个view注册上下文菜单 2.在onCreateContextMenuInfo(...)中生成上下文菜单。 3.在onContextItemSelected(...)中响应上下文菜单项。 Demo:使用上下文菜单 1）注册上下文菜单 /** * 上下文菜单演示Demo *  * @author CodingMyWorld 2011-8-27 下午03:22:39 */publicclass SampleContextMenuActivity extends ListActivity {    privatestaticfinal String TAG =\"SampleContextMenuActivity\";    @Override    protectedvoid onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        // 显示列表        simpleShowList();        // 为所有列表项注册上下文菜单this.registerForContextMenu(getListView());    }    privatevoid simpleShowList() {        // list item        String[] files =new String[] {            \"文件1\",            \"文件2\",            \"文件3\",            \"文件4\"        };        // simple array adapter        ArrayAdapter<String> adapter =new ArrayAdapter<String>(                this,                 android.R.layout.simple_list_item_1,                files);        // set adapterthis.setListAdapter(adapter);        Log.v(TAG, \"show simple list\");    }}   2）生成上下文菜单 在activity中重写方法。 @Overridepublicvoid onCreateContextMenu(ContextMenu menu, View v,        ContextMenuInfo menuInfo) {    Log.v(TAG, \"populate context menu\");    // set context menu title    menu.setHeaderTitle(\"文件操作\");    // add context menu item    menu.add(0, 1, Menu.NONE, \"发送\");    menu.add(0, 2, Menu.NONE, \"标记为重要\");    menu.add(0, 3, Menu.NONE, \"重命名\");    menu.add(0, 4, Menu.NONE, \"删除\");}   3）响应上下文菜单项 与响应options menu类似，唯一的不同是可以通过menu info获得额外的信息。 @Overridepublicboolean onContextItemSelected(MenuItem item) {    // 得到当前被选中的item信息    AdapterContextMenuInfo menuInfo = (AdapterContextMenuInfo) item.getMenuInfo();    Log.v(TAG, \"context item seleted ID=\"+ menuInfo.id);        switch(item.getItemId()) {    case1:        // do somethingbreak;    case2:        // do somethingbreak;    case3:        // do somethingbreak;    case4:        // do somethingbreak;    default:        returnsuper.onContextItemSelected(item);    }    returntrue;} 运行程序，多次唤出上下文菜单，注意LogCat的输出，onCreateContextMenu每一次都被调用了。 结语 至此，我们介绍完了android中的各种常用菜单，但是目前为止我们都是通过硬编码来增加菜单项的，android为此提供了一种更便利的方式，将在下一节“使用XML生成菜单”中介绍。 Android菜单详解（五）——使用XML生成菜单   回顾前面的几篇，我们都是直接在代码中添加菜单项，给菜单项分组等，这是比较传统的做法，它存在着一些不足。比如说，为了响应每个菜单项，我们需要用常量来保存每个菜单项的ID等。为此，Android提供了一种更好的方式，就是把menu也定义为应用程序的资源，通过android对资源的本地支持，使我们可以更方便地实现菜单的创建与响应。这一篇就介绍如何使用XML文件来加载和响应菜单，我们需要做这几步： 在/res目录下创建menu文件夹 在menu目录下使用与menu相关的元素定义xml文件，文件名是随意的，android会自动为其生成资源ID。例如：R.menu.mainmenu对应menu目录的mainmenu.xml资源文件 使用xml文件的资源ID，将xml文件中定义的菜单项添加到menu对象中 响应菜单项时，使用每个菜单项对应的资源ID 下面就使用xml的方式完成《Android菜单详解（二）——创建并响应选项菜单》中的options menu。 定义菜单资源文件 在res目录下创建menu文件夹，在menu下创建一个xml资源文件，我这里叫做mainmenu.xml 编写mainmenu.xml如下： <?xml version=\"1.0\" encoding=\"utf-8\"?><menu  xmlns:android=\"http://schemas.android.com/apk/res/android\">  <!-- group1 -->  <group android:id=\"@+id/group1\">      <item android:id=\"@+id/mi1\"          android:title=\"item1\"/>      <item android:id=\"@+id/mi2\"          android:title=\"item2\"/>  <\/group>  <!-- group 2 -->  <group android:id=\"@+id/group2\">      <item android:id=\"@+id/mi3\"          android:title=\"item3\"/>      <item android:id=\"@+id/mi4\"          android:title=\"item4\"/>  <\/group>  <\/menu> 这里简单的添加了4个菜单项，并将其分为2组。item元素的android:title值可以引用values中的string资源。 使用MenuInflater添加菜单项 inflater在android中建立了从资源文件到对象的桥梁，MenuInflater即把菜单xml资源转换为对象并添加到menu对象中，它可以通过activity的getMenuInflater()得到。我们在MainActivity中重写onCreateOptionsMenu(...)方法。 @Overridepublicboolean onCreateOptionsMenu(Menu menu) {    MenuInflater inflater = getMenuInflater();    inflater.inflate(R.menu.mainmenu, menu);    returntrue;} 响应菜单项 最后重写onOptionsItemSeleted(...)方法。 @Overridepublicboolean onOptionsItemSelected(MenuItem item) {    switch(item.getItemId()) {    case R.id.mi1:        // do sthbreak;    case R.id.mi2:        // do sthbreak;    case R.id.mi3:        // do sthbreak;    case R.id.mi4:        // do sthbreak;    }    returntrue;} 这一步最大的体现了使用XML生成菜单的好处。android不仅为我们定义的xml文件生成了资源ID，同样可以为group,menu item来自动生成ID（就像为布局中定义的view生成id那样）。这样菜单项ID的创建与管理就不用我们操心了，全部交给android去做吧！ 至此，我们完成了一个简单的“使用XML生成菜单”的demo，并从中体会到了使用资源文件的好处，因此这是android中创建菜单的推荐方式。实际上，我们在代码中对菜单项或分组的操作都能在xml文件中完成，下面就简单介绍一些比较常用的功能。（谷歌提供的API demos中有最全面的示例） 更多菜单资源文件的功能 1.资源文件实现子菜单 子菜单通过在item元素中嵌套menu来实现。 <item android:title=\"系统设置\">    <menu>        <item android:id=\"@+id/mi_display_setting\"            android:title=\"显示设置\"/>        <item android:id=\"@+id/mi_network_setting\"            android:title=\"网络设置\"/>        <!-- 别的菜单项 -->    <\/menu><\/item> 2.为菜单项添加图标 <item android:id=\"@+id/mi_exit\"    android:title=\"退出\"    android:icon=\"@drawable/exit\"/> 3.设置菜单项的可选出现 使用android:checkableBehavior设置一组菜单项的可选策略，可选值为：none, all, single <group android:id=\"...\"    android:checkableBehavior=\"all\">    <!-- 菜单项 --><\/group> 使用android:checked设置特定菜单项 <item android:id=\"...\"    android:title=\"sometitle\"    android:checked=\"true\"/> 4.设置菜单项可用/不可用 <item android:id=\"...\"    android:title=\"sometitle\"    android:enabled=\"false\"/> 5.设置菜单项可见/不可见 <item android:id=\"...\"    android:title=\"sometitle\"    android:visible=\"false\"/> 结语 本篇是Android菜单详解系列的最后一篇，本系列详细介绍了android中各种常用菜单的使用技巧和注意事项，希望能帮助大家更好的理解，也期待与各位交流开发中的心得：）","title":"Android菜单详解——理解android中的Menu"},{"content":"本文简单分析，android启动之后，锁屏界面启动过程。 android系统开机后会运行PhoneWindowManage管理系统相关按键和事件， 看下PhoneWindowManager锁屏相关 1.Pwm初始化KeyguardViewMediator类，用来接受PhoneWindowManager传递相关事件      /** {@inheritDoc} */    public void init(Context context, IWindowManager windowManager,            WindowManagerFuncs windowManagerFuncs,            LocalPowerManager powerManager) {        mContext = context;        mWindowManager = windowManager;        mWindowManagerFuncs = windowManagerFuncs;        mPowerManager = powerManager;        mKeyguardMediator = new KeyguardViewMediator(context, this, powerManager); ........}   2.系统启动完成会调用SystemReady函数，进入锁屏流程   /** {@inheritDoc} */    public void systemReady() {        // tell the keyguard        mKeyguardMediator.onSystemReady();        android.os.SystemProperties.set(\"dev.bootcomplete\", \"1\");         synchronized (mLock) {            updateOrientationListenerLp();            mSystemReady = true;            mHandler.post(new Runnable() {                public void run() {                    updateSettings();                }            });        }    } 3.KeyguradMediator中onSystemReady函数  /**     * Let us know that the system is ready after startup.     */    public void onSystemReady() {        synchronized (this) {            if (DBG_WAKE) Log.d(TAG, \"onSystemReady\");            mSystemReady = true;            doKeyguardLocked();        }    } 4.doKeyguardLocked进入锁屏判断，是否有第三方锁屏应用文件。     /**     * Enable the keyguard if the settings are appropriate.  Return true if all     * work that will happen is done; returns false if the caller can wait for     * the keyguard to be shown.     */    private void doKeyguardLocked() {        // if another app is disabling us, don't show        if (!mExternallyEnabled && !mUpdateMonitor.DM_IsLocked()) {            if (DEBUG) Xlog.d(TAG, \"doKeyguard: not showing because externally disabled\");            // note: we *should* set mNeedToReshowWhenReenabled=true here, but that makes            // for an occasional ugly flicker in this situation:            // 1) receive a call with the screen on (no keyguard) or make a call            // 2) screen times out            // 3) user hits key to turn screen back on            // instead, we reenable the keyguard when we know the screen is off and the call            // ends (see the broadcast receiver below)            // TODO: clean this up when we have better support at the window manager level            // for apps that wish to be on top of the keyguard            return;        }        // if the keyguard is already showing, don't bother        if (mKeyguardViewManager.isShowing()) {            if (DEBUG) Xlog.d(TAG, \"doKeyguard: not showing because it is already showing\");            return;        }        // if the setup wizard hasn't run yet, don't show        final boolean requireSim = !SystemProperties.getBoolean(\"keyguard.no_require_sim\",                false);        final boolean provisioned = mUpdateMonitor.isDeviceProvisioned();        final IccCard.State state = mUpdateMonitor.getSimState(Phone.GEMINI_SIM_1);        final IccCard.State stateGemini = mUpdateMonitor.getSimState(Phone.GEMINI_SIM_2);        boolean lockedOrMissing = state.isPinLocked()                || state == IccCard.State.PERM_DISABLED                && requireSim;                boolean lockedOrMissingGemini = stateGemini.isPinLocked()                || stateGemini == IccCard.State.PERM_DISABLED                && requireSim;                if (FeatureOption.MTK_GEMINI_SUPPORT){            lockedOrMissing = lockedOrMissing || lockedOrMissingGemini;        }        boolean keyguardisable = mLockPatternUtils.isLockScreenDisabled();                Log.i(TAG, \"lockedOrMissing is \"+lockedOrMissing+\", requireSim=\"+requireSim            +\", provisioned=\"+provisioned+\", keyguardisable=\"+keyguardisable);                if (!lockedOrMissing && !provisioned) {            if (DEBUG) Log.d(TAG, \"doKeyguard: not showing because device isn't provisioned\"                    + \" and the sim is not locked or missing\");            return;        }        if (keyguardisable && !lockedOrMissing) {            if (DEBUG) Log.d(TAG, \"doKeyguard: not showing because lockscreen is off\");            return;        }        if (DEBUG) Log.d(TAG, \"doKeyguard: showing the lock screen\");        showLocked();    } 5.没有第三方锁屏应用或禁用锁屏，则进入showLocked函数   /**     * Send message to keyguard telling it to show itself     * @see #handleShow()     */    private void showLocked() {        if (DEBUG) Xlog.d(TAG, \"showLocked\");        // ensure we stay awake until we are finished displaying the keyguard        mShowKeyguardWakeLock.acquire();        Message msg = mHandler.obtainMessage(SHOW);                 if (isAlarmBoot() && !mChecked) {            mChecked = true;            Log.i(TAG, \"it's alarm boot, delay 3s to show\");            mHandler.sendMessageDelayed(msg, 5000);         } else {            mHandler.sendMessage(msg);         }    } 6.showLocked函数通过handler，发送显示锁屏信息或延时处理，handler接受消息，直接调用handleShow处理    /**     * Handle message sent by {@link #showLocked}.     * @see #SHOW     */    private void handleShow() {        synchronized (KeyguardViewMediator.this) {            if (DEBUG) Xlog.d(TAG, \"handleShow\");            if (!mSystemReady) return;            if (mShowing == true) return;            mShowCount++;            //avoid the int overflow            if (mShowCount == (int)Math.pow(2, 32)){                mShowCount=2;            }            Xlog.d(TAG, \"handleShow, count=\"+mShowCount);            mKeyguardViewManager.show();            mShowing = true;            adjustUserActivityLocked();            adjustStatusBarLocked();                        try {                ActivityManagerNative.getDefault().closeSystemDialogs(\"lock\");            } catch (RemoteException e) {            }            // Do this at the end to not slow down display of the keyguard.            playSounds(true);            mShowKeyguardWakeLock.release();        }    } 7.进入KeyguardViewManager中的show（）；KeyguardViewManager是锁屏管理处理类，该类在KeyguraMeditor初始化     /**     * Show the keyguard.  Will handle creating and attaching to the view manager     * lazily.     */    public synchronized void show() {        if (DEBUG) Xlog.d(TAG, \"show(); mKeyguardView==\" + mKeyguardView);        Resources res = mContext.getResources();        boolean enableScreenRotation =                SystemProperties.getBoolean(\"lockscreen.rot_override\",false)                || res.getBoolean(R.bool.config_enableLockScreenRotation);        if (mKeyguardHost == null) {            if (DEBUG) Xlog.d(TAG, \"keyguard host is null, creating it...\");            mKeyguardHost = new KeyguardViewHost(mContext, mCallback);            final int stretch = ViewGroup.LayoutParams.MATCH_PARENT;            int flags = WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN                    | WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER                    | WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING                    | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN                    | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR;            if (mUpdateMonitor.DM_IsLocked()) {//in the first created                flags &= ~WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN;                flags |= WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;                flags |= WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR;            } else {                flags &= ~WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;                flags &= ~WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR;                flags |= WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN;            }            if (!mNeedsInput) {                flags |= WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;            }            if (ActivityManager.isHighEndGfx(((WindowManager)mContext.getSystemService(                    Context.WINDOW_SERVICE)).getDefaultDisplay())) {                flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;            }            WindowManager.LayoutParams lp = new WindowManager.LayoutParams(                    stretch, stretch, WindowManager.LayoutParams.TYPE_KEYGUARD,                    flags, PixelFormat.TRANSLUCENT);            lp.softInputMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;            lp.windowAnimations = com.android.internal.R.style.Animation_LockScreen;            if (ActivityManager.isHighEndGfx(((WindowManager)mContext.getSystemService(                    Context.WINDOW_SERVICE)).getDefaultDisplay())) {                lp.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;                lp.privateFlags |=                        WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_HARDWARE_ACCELERATED;            }            lp.setTitle(\"Keyguard\");            mWindowLayoutParams = lp;            mViewManager.addView(mKeyguardHost, lp);        }        if (enableScreenRotation || FeatureOption.MTK_TB_APP_LANDSCAPE_SUPPORT) {            if (DEBUG) Log.d(TAG, \"Rotation sensor for lock screen On!\");            mWindowLayoutParams.screenOrientation = ActivityInfo.SCREEN_ORIENTATION_SENSOR;        } else {            if (DEBUG) Log.d(TAG, \"Rotation sensor for lock screen Off!\");            mWindowLayoutParams.screenOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR;        }        mViewManager.updateViewLayout(mKeyguardHost, mWindowLayoutParams);        if (mKeyguardView == null) {            if (DEBUG) Xlog.d(TAG, \"keyguard view is null, creating it...\");            mKeyguardView = mKeyguardViewProperties.createKeyguardView(mContext, mUpdateMonitor, this);            mKeyguardView.setId(R.id.lock_screen);            mKeyguardView.setCallback(mCallback);            final ViewGroup.LayoutParams lp = new FrameLayout.LayoutParams(                    ViewGroup.LayoutParams.MATCH_PARENT,                    ViewGroup.LayoutParams.MATCH_PARENT);            mKeyguardHost.addView(mKeyguardView, lp);            if (mScreenOn) {                mKeyguardView.show();            }        }        // Disable aspects of the system/status/navigation bars that are not appropriate or        // useful for the lockscreen but can be re-shown by dialogs or SHOW_WHEN_LOCKED activities.        // Other disabled bits are handled by the KeyguardViewMediator talking directly to the        // status bar service.        int visFlags = ( View.STATUS_BAR_DISABLE_BACK                | View.STATUS_BAR_DISABLE_HOME);                mKeyguardHost.setSystemUiVisibility(visFlags);        mViewManager.updateViewLayout(mKeyguardHost, mWindowLayoutParams);        mKeyguardHost.setVisibility(View.VISIBLE);        mKeyguardView.requestFocus();    }   show函数主要锁屏界面添加到ViewManager中显示，主要看下KeyguardView创建工程  mKeyguardView = mKeyguardViewProperties.createKeyguardView(mContext, mUpdateMonitor, this); 看下mKeyguraViewProperties 通过源码可知KeyViewMediator初始化创建，传入KeyguardViewManager mKeyguardViewProperties = new LockPatternKeyguardViewProperties(mLockPatternUtils, mUpdateMonitor); mKeyguardViewManager = new KeyguardViewManager( context, WindowManagerImpl.getDefault(), this, mKeyguardViewProperties, mUpdateMonitor); 8.LockPatternKeyguardViewProperties类中CreateKeyGuardView函数，初始化LockPatternKeyguardView,LockPatternKeyguardView便是我们的锁屏界面 /** * Knows how to create a lock pattern keyguard view, and answer questions about * it (even if it hasn't been created, per the interface specs). */public class LockPatternKeyguardViewProperties implements KeyguardViewProperties {    private final LockPatternUtils mLockPatternUtils;    private final KeyguardUpdateMonitor mUpdateMonitor;    /**     * @param lockPatternUtils Used to know whether the pattern enabled, and passed     *   onto the keygaurd view when it is created.     * @param updateMonitor Used to know whether the sim pin is enabled, and passed     *   onto the keyguard view when it is created.     */    public LockPatternKeyguardViewProperties(LockPatternUtils lockPatternUtils,            KeyguardUpdateMonitor updateMonitor) {        mLockPatternUtils = lockPatternUtils;        mUpdateMonitor = updateMonitor;    }    public KeyguardViewBase createKeyguardView(Context context,            KeyguardUpdateMonitor updateMonitor,            KeyguardWindowController controller) {        return new LockPatternKeyguardView(context, updateMonitor,                mLockPatternUtils, controller);    }    public boolean isSecure() {        return mLockPatternUtils.isSecure() || isSimPinSecure();    }    private boolean isSimPinSecure() {        final IccCard.State simState = mUpdateMonitor.getSimState(Phone.GEMINI_SIM_1);        final IccCard.State sim2State = mUpdateMonitor.getSimState(Phone.GEMINI_SIM_2);        return (simState == IccCard.State.PIN_REQUIRED                || simState == IccCard.State.PUK_REQUIRED                || simState == IccCard.State.PERM_DISABLED                || sim2State == IccCard.State.PIN_REQUIRED                || sim2State == IccCard.State.PUK_REQUIRED                || sim2State == IccCard.State.PERM_DISABLED                || simState == IccCard.State.ABSENT                && sim2State == IccCard.State.ABSENT);    }} 9.看下LockPatternKeyguardView初始流程     /**     * @param context Used to inflate, and create views.     * @param updateMonitor Knows the state of the world, and passed along to each     *   screen so they can use the knowledge, and also register for callbacks     *   on dynamic information.     * @param lockPatternUtils Used to look up state of lock pattern.     */    public LockPatternKeyguardView(            Context context,            KeyguardUpdateMonitor updateMonitor,            LockPatternUtils lockPatternUtils,            KeyguardWindowController controller) {        super(context);        mHandler = new Handler(this);        mConfiguration = context.getResources().getConfiguration();        mEnableFallback = false;        mRequiresSim = TextUtils.isEmpty(SystemProperties.get(\"keyguard.no_require_sim\"));        mUpdateMonitor = updateMonitor;        mLockPatternUtils = lockPatternUtils;        mWindowController = controller;        mHasOverlay = false;        mUpdateMonitor.registerDeviceInfoCallback(this);        mUpdateMonitor.registerPhoneStateCallback(this);        mKeyguardScreenCallback = new KeyguardScreenCallback() {            public void goToLockScreen() {                mForgotPattern = false;                if (mIsVerifyUnlockOnly) {                    // navigating away from unlock screen during verify mode means                    // we are done and the user failed to authenticate.                    mIsVerifyUnlockOnly = false;                    getCallback().keyguardDone(false);                } else {                    updateScreen(Mode.LockScreen, false);                }            }            public void goToUnlockScreen() {                final IccCard.State simState = mUpdateMonitor.getSimState(Phone.GEMINI_SIM_1);                final IccCard.State sim2State = mUpdateMonitor.getSimState(Phone.GEMINI_SIM_2);                if (stuckOnLockScreenBecauseSimMissing()                    || (simState == IccCard.State.PUK_REQUIRED                     && !mLockPatternUtils.isPukUnlockScreenEnable())                    || (sim2State == IccCard.State.PUK_REQUIRED                     && !mLockPatternUtils.isPukUnlockScreenEnable())){                    // stuck on lock screen when sim missing or                    // puk'd but puk unlock screen is disabled                    return;                }                if (!isSecure()) {                    getCallback().keyguardDone(true);                } else {                    updateScreen(Mode.UnlockScreen, false);                }            }            public void forgotPattern(boolean isForgotten) {                if (mEnableFallback) {                    mForgotPattern = isForgotten;                    updateScreen(Mode.UnlockScreen, false);                }            }            public boolean isSecure() {                return LockPatternKeyguardView.this.isSecure();            }            public boolean isVerifyUnlockOnly() {                return mIsVerifyUnlockOnly;            }            public void recreateMe(Configuration config) {                removeCallbacks(mRecreateRunnable);                post(mRecreateRunnable);            }            public void takeEmergencyCallAction() {                mHasOverlay = true;                // Continue showing FaceLock area until dialer comes up or call is resumed                if (mLockPatternUtils.usingBiometricWeak() &&                        mLockPatternUtils.isBiometricWeakInstalled() && mFaceLockServiceRunning) {                    showFaceLockAreaWithTimeout(FACELOCK_VIEW_AREA_EMERGENCY_DIALER_TIMEOUT);                }                // FaceLock must be stopped if it is running                stopAndUnbindFromFaceLock();                pokeWakelock(EMERGENCY_CALL_TIMEOUT);                if (TelephonyManager.getDefault().getCallState()                        == TelephonyManager.CALL_STATE_OFFHOOK) {                    mLockPatternUtils.resumeCall();                } else {                    Intent intent = new Intent(ACTION_EMERGENCY_DIAL);                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK                            | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);                    getContext().startActivity(intent);                }            }            public void pokeWakelock() {                getCallback().pokeWakelock();            }            public void pokeWakelock(int millis) {                getCallback().pokeWakelock(millis);            }            public void keyguardDone(boolean authenticated) {                getCallback().keyguardDone(authenticated);                mSavedState = null; // clear state so we re-establish when locked again            }            public void keyguardDoneDrawing() {                // irrelevant to keyguard screen, they shouldn't be calling this            }            public void reportFailedUnlockAttempt() {                mUpdateMonitor.reportFailedAttempt();                final int failedAttempts = mUpdateMonitor.getFailedAttempts();                if (DEBUG) Xlog.d(TAG, \"reportFailedPatternAttempt: #\" + failedAttempts +                    \" (enableFallback=\" + mEnableFallback + \")\");                final boolean usingPattern = mLockPatternUtils.getKeyguardStoredPasswordQuality()                        == DevicePolicyManager.PASSWORD_QUALITY_SOMETHING;                final int failedAttemptsBeforeWipe = mLockPatternUtils.getDevicePolicyManager()                        .getMaximumFailedPasswordsForWipe(null);                final int failedAttemptWarning = LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET                        - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT;                final int remainingBeforeWipe = failedAttemptsBeforeWipe > 0 ?                        (failedAttemptsBeforeWipe - failedAttempts)                        : Integer.MAX_VALUE; // because DPM returns 0 if no restriction                if (remainingBeforeWipe < LockPatternUtils.FAILED_ATTEMPTS_BEFORE_WIPE_GRACE) {                    // If we reach this code, it means the user has installed a DevicePolicyManager                    // that requests device wipe after N attempts.  Once we get below the grace                    // period, we'll post this dialog every time as a clear warning until the                    // bombshell hits and the device is wiped.                    if (remainingBeforeWipe > 0) {                        showAlmostAtWipeDialog(failedAttempts, remainingBeforeWipe);                    } else {                        // Too many attempts. The device will be wiped shortly.                        Slog.i(TAG, \"Too many unlock attempts; device will be wiped!\");                        showWipeDialog(failedAttempts);                    }                } else {                    boolean showTimeout =                        (failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0;                    if (usingPattern && mEnableFallback) {                        if (failedAttempts == failedAttemptWarning) {                            showAlmostAtAccountLoginDialog();                            showTimeout = false; // don't show both dialogs                        } else if (failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {                            mLockPatternUtils.setPermanentlyLocked(true);                            updateScreen(mMode, false);                            // don't show timeout dialog because we show account unlock screen next                            showTimeout = false;                        }                    }                    if (showTimeout) {                        showTimeoutDialog();                    }                }                mLockPatternUtils.reportFailedPasswordAttempt();            }            public boolean doesFallbackUnlockScreenExist() {                return mEnableFallback;            }            public void reportSuccessfulUnlockAttempt() {                mFailedFaceUnlockAttempts = 0;                mLockPatternUtils.reportSuccessfulPasswordAttempt();            }        };        /**         * We'll get key events the current screen doesn't use. see         * {@link KeyguardViewBase#onKeyDown(int, android.view.KeyEvent)}         */        setFocusableInTouchMode(true);        setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);        updateScreen(getInitialMode(), false);        maybeEnableFallback(context);    } 一些CallBack函数的实现，updateScreen函数才是初始更新锁屏  10.updateScreen，根据当前锁屏模式，更新显示相应的锁屏界面，  private void updateScreen(Mode mode, boolean force) {        Log.v(TAG, \"**** UPDATE SCREEN: mode=\" + mode                + \" last mode=\" + mMode + \", force = \" + force);        mMode = mode;        // Re-create the lock screen if necessary        if (mode == Mode.LockScreen || mShowLockBeforeUnlock) {            if (force || mLockScreen == null) {                recreateLockScreen();            }        }        // Re-create the unlock screen if necessary. This is primarily required to properly handle        // SIM state changes. This typically happens when this method is called by reset()        if (mode == Mode.UnlockScreen) {            final UnlockMode unlockMode = getUnlockMode();            if (force || mUnlockScreen == null || unlockMode != mUnlockScreenMode) {                recreateUnlockScreen(unlockMode);            }        }        // visibleScreen should never be null        final View goneScreen = (mode == Mode.LockScreen) ? mUnlockScreen : mLockScreen;        final View visibleScreen = (mode == Mode.LockScreen) ? mLockScreen : mUnlockScreen;        // do this before changing visibility so focus isn't requested before the input        // flag is set        mWindowController.setNeedsInput(((KeyguardScreen)visibleScreen).needsInput());        if (DEBUG_CONFIGURATION) {            Xlog.v(TAG, \"Gone=\" + goneScreen);            Xlog.v(TAG, \"Visible=\" + visibleScreen);        }        if (mScreenOn) {            if (goneScreen != null && goneScreen.getVisibility() == View.VISIBLE) {                ((KeyguardScreen) goneScreen).onPause();            }            if (visibleScreen.getVisibility() != View.VISIBLE) {                ((KeyguardScreen) visibleScreen).onResume();            }        }        if (goneScreen != null) {            goneScreen.setVisibility(View.GONE);        }        visibleScreen.setVisibility(View.VISIBLE);        requestLayout();        if (!visibleScreen.requestFocus()) {            throw new IllegalStateException(\"keyguard screen must be able to take \"                    + \"focus when shown \" + visibleScreen.getClass().getCanonicalName());        }    } 11.recreateLockScreen（），创建锁屏      private void recreateLockScreen() {        Log.i(TAG, \"recreateLockScreen\");        if (mLockScreen != null) {            ((KeyguardScreen) mLockScreen).onPause();            ((KeyguardScreen) mLockScreen).cleanUp();            removeView(mLockScreen);        }         mLockScreen = createLockScreen();        mLockScreen.setVisibility(View.INVISIBLE);        addView(mLockScreen);    }这里可以自己在framework中写一个锁屏文件，替换系统原理的锁屏， 很简单，最后调用show显示锁屏界面","title":"android锁屏创建流程"},{"content":"    原型模式（Prototype）：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。换句话说，原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需知道任何创建的细节。     原型模式最大的特点是克隆一个现有的对象，一般是由对象的内部提供克隆方法。     原型模式的结构图：     基本的原型模式的代码：  //原型类    abstract class Prototype    {        private string id;        public Prototype(string id)        {            this.id = id;        }        public string Id        {            get { return id; }        }    }    //具体原型类    class ConcretePrototype1 : Prototype    {        public ConcretePrototype1(string id)            : base(id)        {        }        public override Prototype Clone()        {            return (Prototype)this.MemberwiseClone();        }    }\t//客户端代码 \tstatic void Main(string[] AssemblyLoadEventArgs) \t{\t    ConcretePrototype1 p1=new ConcretePrototype(\"I\");        \t    ConcretePrototype1 c1=(ConcretePrototype)p1.Clone();        \t    Console.WriteLine(\"Cloned:{0}\",c1 .Id );        \t    Console.Read();  \t}         例子：要求有一个简历类，必须要有姓名，可以设置性别和年龄，可以设置工作经历。最终需要三份简历。     结构图：       代码： //原型模式，简历类    class Resume : ICloneable    {        private string name;        private string sex;        private string age;        private string timeArea;        private string company;        public Resume(string name)        { this.name = name; }        //设置个人信息        public void SetPersonalInfo(string sex, string age)        {            this.sex = sex;            this.age = age;        }        //设置工作经历        public void SetWorkExperience(string timeArea, string company)        {            this.timeArea = timeArea;            this.company = company;        }        //显示        public void Display()        {            Console.WriteLine(\"{0} {1} {2}\", name, sex, age);            Console.WriteLine(\"{0} {1}\", timeArea, company);        }        public Object Clone()        {            return (Object)this.MemberwiseClone();        }    }\t \t//客户端代码\t     static void Main(string[] args)        {            Resume a = new Resume(\"大鸟\");            a.SetPersonalInfo(\"男\",\"29\");            a.SetWorkExperience(\"1998-2000\",\"XX公司\");             Resume b = （Resume）a.Clone();            b.SetWorkExperience(\"1998-2006\", \"YY公司\");                        Resume c = （Resume）a.Clone();            c.SetPersonalInfo(\"男\", \"24\");            a.Display();            b.Display();            c.Display();                                                    Console.Read();\t}     结果显示： 大鸟  男  29 工作经历  1998-2000 XX公司 大鸟 男 29 工作经历 1998-2006 YY公司 大鸟 男 24 工作经历 1998-2000 XX公司         深复制：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。     浅复制：把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。     举个例子区分一下，现在，“简历”类中有个设置工作经历的方法，一般会再有一个工作经历类，当中有时间区间和公司名称等属性，简历类直接调用这个对象即可。     结构图：       浅复制代码： //浅复制    //工作经历类    class WorkExperience    {        private string workDate;        public string WorkDate        {            get { return workDate ; }            set { workDate = value; }        }        private string company;        public string Company        {            get { return company;}            set { company = value; }        }    }    //简历类    class Resume : ICloneable    {        private string name;        private string sex;        private string age;        private WorkExperience work;        public Resume(string name)        { this.name = name;        work = new WorkExperience();        }        //设置个人信息        public void SetPersonalInfo(string sex, string age)        {            this.sex = sex;            this.age = age;        }        //设置工作经历        public void SetWorkExperience(string workDate, string company)        {            work.WorkDate = workDate;            work.Company = company;        }        //显示        public void Display()        {            Console.WriteLine(\"{0} {1} {2}\", name, sex, age);            Console.WriteLine(\"{0} {1}\", work.WorkDate , work.Company );        }        public Object Clone()        {            return (Object)this.MemberwiseClone();                    }    }      //客户端代码     static void Main(string[] args)        {            Resume a = new Resume(\"大鸟\");            a.SetPersonalInfo(\"男\",\"29\");            a.SetWorkExperience(\"1998-2000\",\"XX公司\");                                                                          \t\t               Resume b = (Resume)a.Clone();            b.SetWorkExperience(\"1998-2006\", \"YY公司\");                                                                         \t\t               Resume c = (Resume)a.Clone();            c.SetPersonalInfo(\"男\", \"24\");            c.SetWorkExperience(\"1998-2003\",\"zz企业\");                                                                       \t   \t               a.Display();            b.Display();            c.Display();             Console.Read();}         结果显示： 大鸟 男 29 工作经历 1998-2003 ZZ企业 大鸟 男 29 工作经历 1998-2003 ZZ企业 大鸟 男 24 工作经历 1998-2003 ZZ企业       深复制代码： //工作经历类    //深复制    class WorkExperience:ICloneable     {        private string workDate;        public string WorkDate        {            get { return workDate ; }            set { workDate = value; }        }        private string company;        public string Company        {            get { return company;}            set { company = value; }        }        public Object Clone()        {            return (Object)this.MemberwiseClone();        }    }    //简历类    class Resume : ICloneable    {        private string name;        private string sex;        private string age;        private WorkExperience work;        public Resume(string name)        { this.name = name;        work = new WorkExperience();        }        //深复制区别于浅复制        private Resume(WorkExperience work)        {            this.work = (WorkExperience)work.Clone();        }        //设置个人信息        public void SetPersonalInfo(string sex, string age)        {            this.sex = sex;            this.age = age;        }        //设置工作经历        public void SetWorkExperience(string workDate, string company)        {            work.WorkDate = workDate;            work.Company = company;        }        //显示        public void Display()        {            Console.WriteLine(\"{0} {1} {2}\", name, sex, age);            Console.WriteLine(\"{0} {1}\", work.WorkDate , work.Company );        }        public Object Clone()        {            //深复制区别于浅复制            Resume obj = new Resume(this.work);            obj .name =this .name ;            obj .sex =this .sex ;            obj .age =this .age ;            return obj ;        }    }     客户端代码一样，但是结果： 大鸟 男 29 工作经历 1998-2000 XX公司 大鸟 男 29 工作经历 1998-2006 YY公司 大鸟 男 24 工作经历 1998-2003 ZZ企业        浅复制和深复制的结果显然不一样，就是因为，浅复制复制的对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象，这里三次的结果都是最后一次设置的值。而深复制将引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。             ","title":"设计模式之原型模式"},{"content":"【木头Cocos2d-x】Lua篇（第03章）：简单解析Lua的堆栈   上一章传送门：http://blog.csdn.net/musicvs/article/details/8440919   经过上一章的讲解，相信大家也看到了，Lua的堆栈是很重要不可或缺的，就像我的旁白一样（旁白：他竟然赞我了。。。好羞涩~）。虽然看起来没什么用，但是少了又绝对不行。 （旁白：你妹纸的，你这算是赞人吗？）   笨木头花心贡献，啥？花心？不呢，是用心~ 转载请注明，原文地址：http://blog.csdn.net/musicvs/article/details/8445027   正文：   在这里我仅简单解释一下Lua堆栈的索引，因为我们在很多操作里都涉及到堆栈的索引，比如上一章中我们要从堆栈中取得一个字符串，就必须给出堆栈索引： /* 获取栈顶的值 */    const char* str = lua_tostring(pL, 1); 如果对堆栈索引不清晰的话，将会很纠结。 《游戏人工智能编程案例精粹》一书的200页，有一张图，很好地表达了Lua的堆栈索引是如何定义的，我照着画了一张： （旁白：好丑~！而且还打了一个广告，别以为我不知道~！）   我们很明显的看到堆栈的索引方式有两种，一种是正数索引，一种是负数索引。 并且咋一看，好像两种索引方式的规则是相反的，其实不然，我们来认真数数： 1. 正数索引，栈底是1，然后一直到栈顶是逐渐+1，最后变成9（9大于1） 2. 负数索引，栈底是-9，然后一直到栈顶是逐渐+1，最后变成-1（-1大于-9） （旁白：这，这还真的是一样的~！好神奇！）   对吧，一般像旁白那种人才会认为是相反的规则。 （旁白：吐槽是我的专利= =！）   大家不觉得奇怪吗？为什么要用两种方式？好混乱~！ 我也觉得，但是有一点好处，看看它们各自的好处： 1. 正数索引，不需要知道栈的大小，我们就能知道栈底在哪，栈底的索引永远是1 2. 负数索引，不需要知道栈的大小，我们就能知道栈顶在哪，栈顶的索引永远是-1 （旁白：又好像有那么一点道理。。。）     OK，本章到此结束。   .  ","title":"【木头Cocos2d-x 028】Lua篇（第03章）：简单解析Lua的堆栈"},{"content":"关键词：android 4.0默认语言蓝牙名称 MTP名称默认时区关于平板电脑 内核版本号 平台信息: 内核：linux2.6/linux3.0 系统：android/android4.0  平台：S5PV310(samsungexynos4210) 1、开关机logo； 2、用户模式、工程模式； 3、更改默认语言； 5、更改蓝牙名称； 6、更MTP名称； 7、更改“关于平板电脑”中的信息； 8、更改默认时区； ……………… 以三星平台为基础，如果是其它平台，只做参考。 下面只是一些做订单时候经常要改动的地方，没什么技术含量，不过我觉得这一部分也比较重要，研发出来的东西，卖出去换回钱，才是到我们最大的回报。这一部分会持续更新，指不定一个“极品”的客户要更改什么不靠谱的东西，记录下来，节省大家的时间，知道在那个地方改就行了。 1、开关机logo        现在好多公司就是个皮包公司，自己不做研发，在外面买，开机画面要做成他们特有的，所以这一点在工作中用的也是比较多的。中国的产品，那叫“泛滥”呀。 这篇文章中对logo有详细描述：android logo：内核、android开机动画 2、用户模式、工程模式 产品出去的时候，要用用户模式，这时串口终端是不能操作的，只能显示。三星平台有一个问题就是，在工程模式下，如果系统有点卡，会有一个红色的边框出现，这个问题我们老大叫它“BUG”，这个没法跟他去理论，总之不应该出现的东西都是BUG，那就转换成user模式，把这个问题解了。 这篇文章中有关于usr eng的描述：android 4.0 编译模式 eng -- > user 时遇到的问题 3、更改默认语言         做产品服务要周道，不能出到别的国家的东西，一开机会是中文的，那就有点不太友好了，英文好多地方可以接受，可是现在中文还是没有那么广泛应用的。其实android默认是En的，我们内单的就是改过来的。下面看我们怎么把默认的英文改成中文，为没过“CET4”的同学服务。 android/device/samsung/smdk4x12/full_smdk4x12.mk PRODUCT_LOCALES := zh_CN \\       en_US \\       zh_TW \\       en_GB \\       fr_FR \\       it_IT \\       cs_CZ \\       de_DE \\       da_DK \\       el_GR \\ 用那个语言，把它放到早前面，就可以，如： zh_CN：中文简体 zh_TW：中文繁体 en_US：英文（美国） Android 地区语言和简写对照表 5、更改蓝牙名称 android/external/bluetooth/bluez/src/main.c static void init_defaults(void){        /* Default HCId settings */        memset(&main_opts, 0, sizeof(main_opts));        main_opts.mode  = MODE_CONNECTABLE;        main_opts.name  = g_strdup(\"W42\");//更改这里的名称        main_opts.discovto      = DEFAULT_DISCOVERABLE_TIMEOUT;        main_opts.remember_powered = TRUE;        main_opts.reverse_sdp = TRUE;        main_opts.name_resolv = TRUE;        main_opts.link_mode = HCI_LM_ACCEPT;        main_opts.link_policy = HCI_LP_RSWITCH | HCI_LP_SNIFF |                                                HCI_LP_HOLD | HCI_LP_PARK;        if (gethostname(main_opts.host_name, sizeof(main_opts.host_name) - 1) < 0)                strcpy(main_opts.host_name, \"noname\");} 6、更MTP名称 android/system/vold/Volume.cpp int Volume::formatVol() {    if (getState() == Volume::State_NoMedia) {        errno = ENODEV;        return -1;    } else if (getState() != Volume::State_Idle) {        errno = EBUSY;        return -1;    }    if (isMountpointMounted(getMountpoint())) {        SLOGW(\"Volume is idle but appears to be mounted - fixing\");        setState(Volume::State_Mounted);        // mCurrentlyMountedKdev = XXX        errno = EBUSY;        return -1;    }    bool formatEntireDevice = (mPartIdx == -1);    char devicePath[255];    char *label = NULL;    dev_t diskNode = getDiskDevice();    dev_t partNode = MKDEV(MAJOR(diskNode), (formatEntireDevice ? 1 : mPartIdx));    setState(Volume::State_Formatting);    int ret = -1;    // Only initialize the MBR if we are formatting the entire device    if (formatEntireDevice) {        sprintf(devicePath, \"/dev/block/vold/%d:%d\",                MAJOR(diskNode), MINOR(diskNode));        if (initializeMbr(devicePath)) {            SLOGE(\"Failed to initialize MBR (%s)\", strerror(errno));            goto err;        }    }    sprintf(devicePath, \"/dev/block/vold/%d:%d\",            MAJOR(partNode), MINOR(partNode));    if (mDebug) {        SLOGI(\"Formatting volume %s (%s)\", getLabel(), devicePath);    }\tlabel=\"W42\";//更改这个名称    if (Fat::format(devicePath, 0, label)) {        SLOGE(\"Failed to format (%s)\", strerror(errno));        goto err;    }    ret = 0;err:    setState(Volume::State_Idle);    return ret;} 7、更改“关于平板电脑”中的信息 （1）、型号 android/device/samsung/smdk4x12/full_smdk4x12.mk PRODUCT_MANUFACTURER := full_smdk4x12PRODUCT_BRAND := full_smdk4x12PRODUCT_MODEL := W42(QuadCore) （2）、内核版本 这个有点不太好找，一个同事跟我说的，内核路径为： kernel/scripts/mkcompile_h # Generate a temporary compile.h( echo /\\* This file is auto generated, version $VERSION \\*/  if [ -n \"$CONFIG_FLAGS\" ] ; then echo \"/* $CONFIG_FLAGS */\"; fi    echo \\#define UTS_MACHINE \\\"$ARCH\\\"  echo \\#define UTS_VERSION \\\"`echo $UTS_VERSION | $UTS_TRUNCATE`\\\"  echo \\#define LINUX_COMPILE_BY \\\"`echo $LINUX_COMPILE_BY | $UTS_TRUNCATE`\\\"  //更改者两个echo的值  echo \\#define LINUX_COMPILE_HOST \\\"`echo $LINUX_COMPILE_HOST | $UTS_TRUNCATE`\\\"  echo \\#define LINUX_COMPILER \\\"`$CC -v 2>&1 | tail -n 1`\\\") > .tmpcompile （3）、版本号 android/out/target/product/w42/system/build.prop ro.build.display.id=w42.eng.tim.20121224.093047ro.build.version.incremental=eng.tim.20121224.093047 其实在build.prop目录中有许多，关于系统的信息，有兴趣的话可以看下。 8、更改默认时区 除的语言外，外单产品默认时区也要改动。找到相应的system.prop，加入下面语句。 android/device/samsung/smdk4x12/system.prop #default time zonepersist.sys.timezone=Asia/Shanghai 9、在桌面放一图标，点击链接到一指定网址 10、把应用程序的图标默认放到桌面","title":"android 量产软件改动信息（持续更新）"},{"content":"iOS 支持多个层次的多线程编程，层次越高的抽象程度越高，使用起来也越方便，也是苹果最推荐使用的方法。下面根据抽象层次从低到高依次列出iOS所支持的多线程编程范式： 1, Thread; 2, Cocoa operations; 3, Grand Central Dispatch (GCD) (iOS4 才开始支持) 下面简要说明这三种不同范式： Thread 是这三种范式里面相对轻量级的，但也是使用起来最负责的，你需要自己管理thread的生命周期，线程之间的同步。线程共享同一应用程序的部分内存空间，它们拥有对数据相同的访问权限。你得协调多个线程对同一数据的访问，一般做法是在访问之前加锁，这会导致一定的性能开销。在 iOS 中我们可以使用多种形式的 thread: Cocoa threads: 使用NSThread 或直接从 NSObject 的类方法 performSelectorInBackground:withObject: 来创建一个线程。如果你选择thread来实现多线程，那么 NSThread 就是官方推荐优先选用的方式。 POSIX threads: 基于 C 语言的一个多线程库， Cocoa operations是基于 Obective-C实现的，类 NSOperation 以面向对象的方式封装了用户需要执行的操作，我们只要聚焦于我们需要做的事情，而不必太操心线程的管理，同步等事情，因为NSOperation已经为我们封装了这些事情。 NSOperation 是一个抽象基类，我们必须使用它的子类。iOS 提供了两种默认实现：NSInvocationOperation 和 NSBlockOperation。 Grand Central Dispatch (GCD): iOS4 才开始支持，它提供了一些新的特性，以及运行库来支持多核并行编程，它的关注点更高：如何在多个 cpu 上提升效率。 有了上面的总体框架，我们就能清楚地知道不同方式所处的层次以及可能的效率，便利性差异。下面我们先来看看 NSThread 的使用，包括创建，启动，同步，通信等相关知识。这些与 win32/Java 下的 thread 使用非常相似。 线程创建与启动 NSThread的创建主要有两种直接方式： [NSThread detachNewThreadSelector:@selector(myThreadMainMethod:) toTarget:self withObject:nil]; 和 NSThread* myThread = [[NSThread alloc] initWithTarget:self                                         selector:@selector(myThreadMainMethod:)                                         object:nil]; [myThread start]; 这两种方式的区别是：前一种一调用就会立即创建一个线程来做事情；而后一种虽然你 alloc 了也 init了，但是要直到我们手动调用 start 启动线程时才会真正去创建线程。这种延迟实现思想在很多跟资源相关的地方都有用到。后一种方式我们还可以在启动线程之前，对线程进行配置，比如设置 stack 大小，线程优先级。 还有一种间接的方式，更加方便，我们甚至不需要显式编写 NSThread 相关代码。那就是利用 NSObject 的类方法 performSelectorInBackground:withObject: 来创建一个线程： [myObj performSelectorInBackground:@selector(myThreadMainMethod) withObject:nil]; 其效果与 NSThread 的 detachNewThreadSelector:toTarget:withObject: 是一样的。 线程同步 线程的同步方法跟其他系统下类似，我们可以用原子操作，可以用 mutex，lock等。 iOS的原子操作函数是以 OSAtomic开头的，比如：OSAtomicAdd32, OSAtomicOr32等等。这些函数可以直接使用，因为它们是原子操作。 iOS中的 mutex 对应的是 NSLock，它遵循 NSLooking协议，我们可以使用 lock, tryLock, lockBeforeData:来加锁，用 unLock来解锁。使用示例： BOOL moreToDo = YES; NSLock *theLock = [[NSLock alloc] init]; ... while (moreToDo) {     /* Do another increment of calculation */     /* until there’s no more to do. */     if ([theLock tryLock]) {         /* Update display used by all threads. */         [theLock unlock];     } } 我们可以使用指令 @synchronized 来简化 NSLock的使用，这样我们就不必显示编写创建NSLock,加锁并解锁相关代码。 - (void)myMethod:(id)anObj {     @synchronized(anObj)     {         // Everything between the braces is protected by the @synchronized directive.     } }   还有其他的一些锁对象，比如：循环锁NSRecursiveLock，条件锁NSConditionLock，分布式锁NSDistributedLock等等，在这里就不一一介绍了，大家去看官方文档吧。 用NSCodition同步执行的顺序 NSCodition 是一种特殊类型的锁，我们可以用它来同步操作执行的顺序。它与 mutex 的区别在于更加精准，等待某个 NSCondtion 的线程一直被 lock，直到其他线程给那个 condition 发送了信号。下面我们来看使用示例： 某个线程等待着事情去做，而有没有事情做是由其他线程通知它的。 [cocoaCondition lock]; while (timeToDoWork <= 0)     [cocoaCondition wait];   timeToDoWork--;  // Do real work here. [cocoaCondition unlock]; 其他线程发送信号通知上面的线程可以做事情了： [cocoaCondition lock]; timeToDoWork++; [cocoaCondition signal]; [cocoaCondition unlock]; 线程间通信 线程在运行过程中，可能需要与其它线程进行通信。我们可以使用 NSObject 中的一些方法： 在应用程序主线程中做事情： performSelectorOnMainThread:withObject:waitUntilDone: performSelectorOnMainThread:withObject:waitUntilDone:modes: 在指定线程中做事情： performSelector:onThread:withObject:waitUntilDone: performSelector:onThread:withObject:waitUntilDone:modes: 在当前线程中做事情： performSelector:withObject:afterDelay: performSelector:withObject:afterDelay:inModes: 取消发送给当前线程的某个消息 cancelPreviousPerformRequestsWithTarget: cancelPreviousPerformRequestsWithTarget:selector:object: 如在我们在某个线程中下载数据，下载完成之后要通知主线程中更新界面等等，可以使用如下接口：- (void)myThreadMainMethod {     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];     // to do something in your thread job     ...     [self performSelectorOnMainThread:@selector(updateUI) withObject:nil waitUntilDone:NO];     [pool release]; } RunLoop 说到 NSThread 就不能不说起与之关系相当紧密的 NSRunLoop。Run loop 相当于 win32 里面的消息循环机制，它可以让你根据事件/消息（鼠标消息，键盘消息，计时器消息等）来调度线程是忙碌还是闲置。 系统会自动为应用程序的主线程生成一个与之对应的 run loop 来处理其消息循环。在触摸 UIView 时之所以能够激发 touchesBegan/touchesMoved 等等函数被调用，就是因为应用程序的主线程在 UIApplicationMain 里面有这样一个 run loop 在分发 input 或 timer 事件。","title":"[iOS]深入浅出 iOS 之多线程 NSThread (转)"},{"content":"尽管iPhone不允许同时运行两个应用程序，我们可以从自己的应用程序中启动另一个应用程序，并且可以在应用程序之间共享数据。我们可以使用UIApplication类的openURL:方法从一个应用程序来启动另一个应用程序。例如，要在Safari应用程序中打开Google主页，我们可以编写如下代码： NSURL *url = [NSURL URLWithString:@\"http://google.com\"];  [[UIApplication sharedApplication]openURL:url];  [这里的http://部分叫做URL方案（URL scheme），它表示想要载入的应用程序。 还有几种用于本地iPhone应用程序的URL方案，并且可以使用类似的方式来启动它们。 例如，要启动Mail应用程序（如图3-15所示），我们可以使用： NSURL *url = [NSURL URLWithString:@\"mailto:steve@apple.com subject= test\"];  [[UIApplication sharedApplication] openURL:url];  要启动SMS应用程序，我们可以编写如下代码： NSURL *url = [NSURL URLWithString:  -\"sms:555-1234\"];  [[UIApplication sharedApplication]  -penURL:url];  要拨打一个电话号码，我们可以使用如下代码： NSURL *url=[NSURL URLWithString:@\"tel://555-1234\"];  [[UIApplication sharedApplication]openURL:url];  要启动Maps应用程序来查找一个披萨店（如图3-16所示），我们使用如下代码： NSURL *url = [NSURL URLWithString:@\"http://maps.google.com/maps?q=pizza\"];  [[UIApplication sharedApplication]openURL:url];  我们也可以使用URL方案来启动自己的应用程序： 用一个定制的URL方案来启动应用程序： 1）创建一个新的基于视图的应用程序，将其保存为URLSchemeExample。 2）在Xcode Groups & Files面板中，展开Resource部分，并且选择<app>-Info.plist文件。 3）鼠标右键点击Information Property List键，并点击添加箭头从列表中选择“URL types”（如图3-17所示）。 4）展开Item 1，用鼠标右键点击URL identifier，并且再次选择添加箭头从列表中选择URL Schemes（如图3-18所示）。   图3-16   启动Maps应用程序并查找披萨店   （点击查看大图）图3-17   添加一个URL类型   图3-18   添加一个URL方案   图3-19   设置URL方案的名称 5）选择Item 1，并且将其值设置为myapplication（如图3-19所示）。 6）打开URLSchemeExampleView Controller.m，取消对viewDidLoad方法的注释，并且编写如下代码： [self.view setBackgroundColor:[UIColor redColor]];  7）构建并运行应用程序。应该看到一个没有内容的红色屏幕。应用程序此时不会做任何事情，但是通过运行它（安装在iPhone或者模拟器上的应用程序），我们只是注册在步骤5中创建的URL方案（myapplication）。 8）我们可以使用如下代码，从另一个不同的应用程序启动该应用程序： NSURL *url = [NSURL URLWithString:@\"myapplication:\"];  [[UIApplication sharedApplication] openURL:url]; ","title":"IOS在一个程序中启动另一个程序"},{"content":"    项目介绍： 在windows8 下 基于 metro 研发的一个 公共信息发布平台， 演示视频： http://v.youku.com/v_show/id_XNDk0NzgyMDk2.html   截图：   后期会陆续将项目资源给大家 共享，互相学习 互相进步   如有其他意向请联系我","title":"项目展示： 基于windows8 平台下研发的互动数字标牌 （旅游公共信息查询)"},{"content":"  模拟HOME键 public boolean onKeyDown(int keyCode, KeyEvent event) {     // TODO Auto-generated method stub     if(keyCode == KeyEvent.KEYCODE_BACK){         Intent intent = new Intent(Intent.ACTION_MAIN);         intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);// 注意         intent.addCategory(Intent.CATEGORY_HOME);         this.startActivity(intent);         return true;     }     return super.onKeyDown(keyCode, event); } 特别注意 intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); 这句，一定要加上，因为Activity 的 launchMode 默认是以 standard 执行的，如果不添加这个标记则 会创建新的Activity 并放在与当前Activity相同的Task中。以下是 FLAG_ACTIVITY_NEW_TASK 的说明 // 屏蔽Home键         // @Override         // public void onAttachedToWindow() {         // this.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD);         // super.onAttachedToWindow();         // }","title":"android 关于HOME键"},{"content":"拼写检查器的清单和元数据 除代码之外，你还需要给拼写检查器提供对应的清单文件和元数据文件。 清单文件定义了应用程序、服务以及用于控制设置的Activity，如： <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"     package=\"com.example.android.samplespellcheckerservice\" >     <application         android:label=\"@string/app_name\" >         <service             android:label=\"@string/app_name\"             android:name=\".SampleSpellCheckerService\"             android:permission=\"android.permission.BIND_TEXT_SERVICE\" >             <intent-filter >                 <action android:name=\"android.service.textservice.SpellCheckerService\" />             <\/intent-filter>               <meta-data                 android:name=\"android.view.textservice.scs\"                 android:resource=\"@xml/spellchecker\" />         <\/service>           <activity             android:label=\"@string/sample_settings\"             android:name=\"SpellCheckerSettingsActivity\" >             <intent-filter >                 <action android:name=\"android.intent.action.MAIN\" />             <\/intent-filter>         <\/activity>     <\/application> <\/manifest> 注意，对于要使用的服务组件，必须申请BIND_TEXT_SERVICE权限来确保只有系统绑定到这个服务。该服务的定义还指定了spellchecker.xml元数据文件，该文件内容如下： <spell-checker xmlns:android=\"http://schemas.android.com/apk/res/android\"         android:label=\"@string/spellchecker_name\"         android:settingsActivity=\"com.example.SpellCheckerSettingsActivity\">     <subtype             android:label=\"@string/subtype_generic\"             android:subtypeLocale=\"en”     />     <subtype             android:label=\"@string/subtype_generic\"             android:subtypeLocale=\"fr”     /> <\/spell-checker>   该元数据指定了拼写检查器用来控制设置的Activity。它还给拼写检查器定义了子类型，在本例中，子类型定义了拼写检查器能够处理的语言环境。 从客户端访问拼写检查器服务 使用TextView的应用程序会自动接收拼写检查，因为TextView会自动的使用拼写检查器，如下图所示： 图2.TextView中的拼写检查 但是，在某些情况下，你可能想要直接与拼写检查器的服务进行交互，下图显示了与拼写检查器的服务进行交互的控制流： 图3.与拼写检查器的服务进行交互  ","title":"Android的文本和输入---拼写检查器（二）"},{"content":"原文：<http://developer.Android.com/resources/articles/painless-threading.html> 安全多线程 本文将要讨论Android应用程序所使用的线程模型以及Android应用程序是怎样通过产生工作线程来完成那些耗时的工作，而不是在主线程里处理这些工作来保证UI的性能的。同时本文还会对 应用程序与主线程中的Android UI toolkit组件交互以及产生托管工作线程的API进行解释。  Android UI线程 　　当一个应用程序运行时，Android系统自动的为该应用程序创建一个叫做“Main”的主线程。“Main”线程，也叫UI线程，是一个十分重要的线程，他负责把包括UI绘制在内的所有事件分发到适当的Widget（UI组件）上面。同时，它还是你的应用程序与Android UI toolkit中运行的组件进行交互的线程。 　　例如，我们在屏幕上对某一个按钮进行了触摸，主（UI）线程就会把这个事件分发给Button（button是一个widget），此时该按钮就会变为被按下的状态并且向事件队列中发送一个重绘请求。主线程从队列中取出该请求然后告诉按钮重绘自己。（这样按钮就表现为被按下的状态了） 　　除非你的应用正确的实现了，否则这样的单线程模式可能使应用程序产生很坏的表现。特别是，如果把所有的事件都放在主线程中来处理，需要长时间来处理的事件比如网络访问或者数据库查询，会阻塞整个UI。此时，在那些耗时的操作结束之前UI都不会分发任何事件，包括绘制事件。从用户的角度来看，应用程序就是挂掉了，不再响应了。更坏的是，如果应用程序UI线程被阻塞超过几秒钟（现在大概是5秒），用户就会看到一个让人不高兴的“应用程序没有响应”（ANR）对话框。 　　如果你想看看这样到底有多坏，写一个简单的按钮，并在其单击事件中添加Thread.sleep(2000)这段代码。此时按下按钮后2秒钟内按钮都会保持按下的状态。当发生这样的事情时，用户很容易认为这个应用程序是一个十分慢的应用。 总而言之，保证你的UI不被阻塞对于应用程序的响应来说是十分重要 的。如果有耗时的操作，你应该把这些操作放在另外的线程中进行处理（后台线程或者工作线程）。 下面是一个通过点击下载图片并显示到ImageView中的例子： public void onClick(View v) {   new Thread(new Runnable() {     public void run() {       Bitmap b = loadImageFromNetwork();       mImageView.setImageBitmap(b);     }   }).start(); } 乍一看，上面的代码似乎没有什么问题，因为他并没有阻塞UI线程。但不幸的是，上面的代码违背了UI线程的单线程模式：Android UI toolkit不是线程安全的，所以对UI的操作都应该在主UI线程中进行。在上面的代码中ImageView被工作线程所操作了，这样可能会导致十分奇怪的问题，寻找或者解决这样的Bug都将十分困难且耗时。 Android提供了几种不同的方式来通过其它线程访问UI线程。其中的一些你可能已经见过，下面是一个比较完全的列表： l Activity.runOnUiThread(Runnable) <http://developer.android.com/reference/android/app/Activity.html> l View.post(Runnable) <http://developer.android.com/reference/android/view/View.html> l View.postDelayed(Runnable, long) <http://developer.android.com/reference/android/view/View.html> l Handler <http://developer.android.com/reference/android/os/Handler.html> 你可以使用任何一种方式来修正上面的代码： public void onClick(View v) {   new Thread(new Runnable() {     public void run() {       final Bitmap b = loadImageFromNetwork();       mImageView.post(new Runnable() {         public void run() {           mImageView.setImageBitmap(b);         }       });     }   }).start(); } 不幸的是，这些类和方法会使你的代码更加的复杂且不容易理解。在某些需要频繁使用UI的操作中这样的操作将会更加的复杂和难以理解。 为了解决这样的问题，Android在1.5以及以后的版本中提供了一个辅助类：AsyncTask。这个类简化了创建需要与UI长时间交互的线程的过程。 在Android1.0和1.1中也有一个与AsyncTask相同的类，UserTask，它提供了与AsyncTask相同的API。 AsyncTask的目的是替你管理应用程序中的线程。前面的例子可以简单的使用下面的代码来完成： public void onClick(View v) {   new DownloadImageTask().execute(\"http://example.com/image.png\"); } private class DownloadImageTask extends AsyncTask {      protected Bitmap doInBackground(String... urls) {          return loadImageFromNetwork(urls[0]);      }      protected void onPostExecute(Bitmap result) {          mImageView.setImageBitmap(result);      }  } 如您所见，我们必须通过继承AsyncTask类来使用AsyncTask。同时，AsyncTask实例只能在UI线程中创建且只能执行一次。你可以通过阅读AsyncTask documentation <http://developer.android.com/reference/android/os/AsyncTask.html> 来完全的了解AsyncTask类，下面是一个关于他怎样工作的概述。 l 你可以定义AsyncTask的参数类型和最终的返回值类型。 l 方法doInBackground()会自动的在工作线程中执行。 l onPreExecute(),onPostExecute()以及onProgressUpdate()都是在主线程中调用的。 l doInBackground()的返回值被发送到onPostExecute()中。 l 你可以在doInBackground()的任何时间调用publishProgress()来在主线程执行onProgressUpdate(). l 你可以在任何时间，通过任何线程结束这个任务。 做为官方文件的补充，你可以在Shelves (ShelvesActivity.java <http://code.google.com/p/shelves/source/browse/trunk/Shelves/src/org/curiouscreature/android/shelves/activity/ShelvesActivity.java> and AddBookActivity.java <http://code.google.com/p/shelves/source/browse/trunk/Shelves/src/org/curiouscreature/android/shelves/activity/AddBookActivity.java>) 和Photostream(LoginActivity.java <http://code.google.com/p/apps-for-android/source/browse/trunk/Photostream/src/com/google/android/photostream/LoginActivity.java>, PhotostreamActivity.java <http://code.google.com/p/apps-for-android/source/browse/trunk/Photostream/src/com/google/android/photostream/PhotostreamActivity.java> and ViewPhotoActivity.java <http://code.google.com/p/apps-for-android/source/browse/trunk/Photostream/src/com/google/android/photostream/ViewPhotoActivity.java>)的源代码中阅读几个复杂的例子。我们强烈推荐您阅读 Shelves <http://code.google.com/p/shelves/> 的源码来了解怎样在配置改变的情况下保证任务执行以及怎样在Activity被销毁时正确的取消这些任务。 无论您是否使用 AsyncTask <http://developer.android.com/reference/android/os/AsyncTask.html>,，都要记住单线程模型的两个规则： 1.不要阻塞UI线程  2.保证只在UI线程中访问Android UI toolkit.  AsyncTask类只是把上面的两件事情变得简单了。 Finish Whatever U've Started !!! 转自：http://www.189works.com/article-15837-1.html 原文：<http://developer.Android.com/resources/articles/painless-threading.html> 安全多线程 本文将要讨论Android应用程序所使用的线程模型以及Android应用程序是怎样通过产生工作线程来完成那些耗时的工作，而不是在主线程里处理这些工作来保证UI的性能的。同时本文还会对 应用程序与主线程中的Android UI toolkit组件交互以及产生托管工作线程的API进行解释。  Android UI线程 　　当一个应用程序运行时，Android系统自动的为该应用程序创建一个叫做“Main”的主线程。“Main”线程，也叫UI线程，是一个十分重要的线程，他负责把包括UI绘制在内的所有事件分发到适当的Widget（UI组件）上面。同时，它还是你的应用程序与Android UI toolkit中运行的组件进行交互的线程。 　　例如，我们在屏幕上对某一个按钮进行了触摸，主（UI）线程就会把这个事件分发给Button（button是一个widget），此时该按钮就会变为被按下的状态并且向事件队列中发送一个重绘请求。主线程从队列中取出该请求然后告诉按钮重绘自己。（这样按钮就表现为被按下的状态了） 　　除非你的应用正确的实现了，否则这样的单线程模式可能使应用程序产生很坏的表现。特别是，如果把所有的事件都放在主线程中来处理，需要长时间来处理的事件比如网络访问或者数据库查询，会阻塞整个UI。此时，在那些耗时的操作结束之前UI都不会分发任何事件，包括绘制事件。从用户的角度来看，应用程序就是挂掉了，不再响应了。更坏的是，如果应用程序UI线程被阻塞超过几秒钟（现在大概是5秒），用户就会看到一个让人不高兴的“应用程序没有响应”（ANR）对话框。 　　如果你想看看这样到底有多坏，写一个简单的按钮，并在其单击事件中添加Thread.sleep(2000)这段代码。此时按下按钮后2秒钟内按钮都会保持按下的状态。当发生这样的事情时，用户很容易认为这个应用程序是一个十分慢的应用。 总而言之，保证你的UI不被阻塞对于应用程序的响应来说是十分重要 的。如果有耗时的操作，你应该把这些操作放在另外的线程中进行处理（后台线程或者工作线程）。 下面是一个通过点击下载图片并显示到ImageView中的例子： public void onClick(View v) {   new Thread(new Runnable() {     public void run() {       Bitmap b = loadImageFromNetwork();       mImageView.setImageBitmap(b);     }   }).start(); } 乍一看，上面的代码似乎没有什么问题，因为他并没有阻塞UI线程。但不幸的是，上面的代码违背了UI线程的单线程模式：Android UI toolkit不是线程安全的，所以对UI的操作都应该在主UI线程中进行。在上面的代码中ImageView被工作线程所操作了，这样可能会导致十分奇怪的问题，寻找或者解决这样的Bug都将十分困难且耗时。 Android提供了几种不同的方式来通过其它线程访问UI线程。其中的一些你可能已经见过，下面是一个比较完全的列表： l Activity.runOnUiThread(Runnable) <http://developer.android.com/reference/android/app/Activity.html> l View.post(Runnable) <http://developer.android.com/reference/android/view/View.html> l View.postDelayed(Runnable, long) <http://developer.android.com/reference/android/view/View.html> l Handler <http://developer.android.com/reference/android/os/Handler.html> 你可以使用任何一种方式来修正上面的代码： public void onClick(View v) {   new Thread(new Runnable() {     public void run() {       final Bitmap b = loadImageFromNetwork();       mImageView.post(new Runnable() {         public void run() {           mImageView.setImageBitmap(b);         }       });     }   }).start(); } 不幸的是，这些类和方法会使你的代码更加的复杂且不容易理解。在某些需要频繁使用UI的操作中这样的操作将会更加的复杂和难以理解。 为了解决这样的问题，Android在1.5以及以后的版本中提供了一个辅助类：AsyncTask。这个类简化了创建需要与UI长时间交互的线程的过程。 在Android1.0和1.1中也有一个与AsyncTask相同的类，UserTask，它提供了与AsyncTask相同的API。 AsyncTask的目的是替你管理应用程序中的线程。前面的例子可以简单的使用下面的代码来完成： public void onClick(View v) {   new DownloadImageTask().execute(\"http://example.com/image.png\"); } private class DownloadImageTask extends AsyncTask {      protected Bitmap doInBackground(String... urls) {          return loadImageFromNetwork(urls[0]);      }      protected void onPostExecute(Bitmap result) {          mImageView.setImageBitmap(result);      }  } 如您所见，我们必须通过继承AsyncTask类来使用AsyncTask。同时，AsyncTask实例只能在UI线程中创建且只能执行一次。你可以通过阅读AsyncTask documentation <http://developer.android.com/reference/android/os/AsyncTask.html> 来完全的了解AsyncTask类，下面是一个关于他怎样工作的概述。 l 你可以定义AsyncTask的参数类型和最终的返回值类型。 l 方法doInBackground()会自动的在工作线程中执行。 l onPreExecute(),onPostExecute()以及onProgressUpdate()都是在主线程中调用的。 l doInBackground()的返回值被发送到onPostExecute()中。 l 你可以在doInBackground()的任何时间调用publishProgress()来在主线程执行onProgressUpdate(). l 你可以在任何时间，通过任何线程结束这个任务。 做为官方文件的补充，你可以在Shelves (ShelvesActivity.java <http://code.google.com/p/shelves/source/browse/trunk/Shelves/src/org/curiouscreature/android/shelves/activity/ShelvesActivity.java> and AddBookActivity.java <http://code.google.com/p/shelves/source/browse/trunk/Shelves/src/org/curiouscreature/android/shelves/activity/AddBookActivity.java>) 和Photostream(LoginActivity.java <http://code.google.com/p/apps-for-android/source/browse/trunk/Photostream/src/com/google/android/photostream/LoginActivity.java>, PhotostreamActivity.java <http://code.google.com/p/apps-for-android/source/browse/trunk/Photostream/src/com/google/android/photostream/PhotostreamActivity.java> and ViewPhotoActivity.java <http://code.google.com/p/apps-for-android/source/browse/trunk/Photostream/src/com/google/android/photostream/ViewPhotoActivity.java>)的源代码中阅读几个复杂的例子。我们强烈推荐您阅读 Shelves <http://code.google.com/p/shelves/> 的源码来了解怎样在配置改变的情况下保证任务执行以及怎样在Activity被销毁时正确的取消这些任务。 无论您是否使用 AsyncTask <http://developer.android.com/reference/android/os/AsyncTask.html>,，都要记住单线程模型的两个规则： 1.不要阻塞UI线程  2.保证只在UI线程中访问Android UI toolkit.  AsyncTask类只是把上面的两件事情变得简单了。 Finish Whatever U've Started !!! 转自：http://www.189works.com/article-15837-1.html","title":"【Android】 Painless Thread"},{"content":"本文译自：http://developer.android.com/training/basics/supporting-devices/screens.html Android使用通常使用两个属性来对设备的屏幕进行分类：尺寸和密度。你应该设想安装你的应用程序的设备屏幕的尺寸和密度的范围。如，你应该包含一些可选的资源，来优化你的应用程序在不同尺寸和密度屏幕上的显示外观。 1. 四种一般性的尺寸：small、normal、large、xlarge 2. 四种一般性的密度：low(ldpi)、medium(mdpi)、high(hdpi)、extra high（xhdpi） 对于不同的屏幕所使用的布局和位图，你必须把它放到独立的目录中，类似于多语言支持。 还要注意屏幕方向（横屏或竖屏）给屏幕尺寸所带来的变化，因此很多应用程序需要修改布局，以便优化在每个方向中的用户体验。 创建不同的布局 要优化在不同屏幕尺寸上的用户体验，你应该给每种要支持的屏幕尺寸创意一个唯一的布局XML文件。每种布局文件都应该保存在其对应的资源目录中，目录名称要用_<screen_size>作为后缀。例如，针对大屏幕的唯一布局应该被保存在res/layout_large/目录下。 注意：为了正确的填充屏幕，Android会自动缩放你的布局。这样，不同屏幕尺寸的布局就不必担心UI元素的绝对尺寸，而是要关注影响用户体验的布局结构（如重要的View相对与兄弟View的尺寸或位置） 例如，包含默认布局和针对large屏幕的可选布局的项目： MyProject/     res/         layout/             main.xml         layout-large/             main.xml 布局文件名必须完全相同，但是为了提供对应屏幕尺寸的UI，它们的内容是不同的。 跟通常一样，在你的应用程序中简单的应用布局文件即可： @Override  protected void onCreate(Bundle savedInstanceState) {      super.onCreate(savedInstanceState);      setContentView(R.layout.main); } Android系统会基于运行你的应用程序的设备的屏幕尺寸，来加载对应的布局文件。更多的信息，请参照“Providing Resources”指南。   下例是针对横向屏幕的可选布局： MyProject/     res/         layout/             main.xml         layout-land/             main.xml 默认layout/main.xml被用于纵向布局。   如果你要给纵向提供特殊的布局，同时适用于大屏幕，那么你需要使用large和land修饰词： MyProject/     res/         layout/              # default (portrait)             main.xml         layout-land/         # landscape             main.xml         layout-large/        # large (portrait)             main.xml         layout-large-land/   # large landscape             main.xml 注意：Android3.2以后，支持一种先进的定义屏幕尺寸的方法，它允许你使用基于密度无关的像素术语中的宽度和高度来给屏幕尺寸指定资源。本节课不包含这项新技术，更多信息，请阅读：Designing for Multiple Screens. 创建不同的位图 你应该始终给每种一般性密度提供正确缩放的位图资源：low、medium、high和extra-high。这有助于在所有屏幕密度上都获得良好的图形质量和性能。 要生成这些图片，你应该用矢量格式的原始资源，并且按照以下缩放比来生成每种密度下的图片： 1. xhdpi：2.0 2. hdpi：1.5 3. mdpi：1.0（基线） 4. ldpi：0.5 这意味着，如果要给xhdpi设备生成200x200的图片，那么相同的资源还有分别生成以下尺寸的图片：用于hdpi的150x150；用于mdpi的100x100；用于ldpi的75x75. 然后把它们分别放到对应的可绘制资源目录中： MyProject/     res/         drawable-xhdpi/             awesomeimage.png         drawable-hdpi/             awesomeimage.png         drawable-mdpi/             awesomeimage.png         drawable-ldpi/             awesomeimage.png 不管何时引用@drawable/awesomeimage资源，系统都会基于屏幕的密度来选择对应的位图。 注意：ldpi资源不总是必要的。在你提供hdpi资源时，系统会把它们缩小一半来填充ldpi屏幕。 有关给应用程序创建图标资产的提示和指南，请看Iconography design guide.  ","title":"Android培训---支持不同的屏幕"},{"content":"对象的复制就是复制一个对象作为副本，他会开辟一块新的内存（堆内存）来存储副本对象，就像复制文件一样，即源对象和副本对象是两块不同的内存区域。对象要具备复制功能，必须实现<NSCopying>协议或者<NSMutableCopying>协议，常用的可复制对象有：NSNumber、NSString、NSMutableString、NSArray、NSMutableArray、NSDictionary、NSMutableDictionary copy：产生对象的副本是不可变的 mutableCopy：产生的对象的副本是可变的 浅拷贝和深拷贝       浅拷贝值复制对象本身，对象里的属性、包含的对象不做复制       深拷贝则既复制对象本身，对象的属性也会复制一份 Foundation中支持复制的类，默认是浅复制 对象的自定义拷贝     对象拥有复制特性，须实现NSCopying，NSMutableCopying协议，实现该协议的CopyWithZone：方法或MutableCopyWithZone：方法。 浅拷贝实现  -（id）copyWithZone:(NSZone *)zone{                        Person *person = [[[self Class]allocWithZone:zone]init];            p.name = _name;            p.age = _age;            return person;        } 深拷贝的实现 -(void)copyWithZone:(NSZone *)zone{            Person *person = [[[self Class]allocWithZone:zone]init];            person.name = [_name copy];            person.age = [_age copy];            return person;                    } 深浅拷贝和retain之间的关系    copy、mutableCopy和retain之间的关系    Foundation中可复制的对象，当我们copy的是一个不可变的对象的时候，它的作用相当与retain（cocoa做的内存优化）    当我们使用mutableCopy的时候，无论源对象是否可变，副本是可变的     当我们copy的 是一个可变对象时，复本不可变","title":"[置顶] Objective-c中对象的Copy、MutableCopy、浅拷贝、深拷贝"},{"content":"/**********************************************************************************\t2012.12.29 -->> Linux下用Socket检测设备的挂载(实现设备的自动挂载) \t关于Wifi网络名称和密码配置:\t\t  方案一:\t  \t\t在硬盘的根目录下新建一个文件:wifi_cfg.txt.\t\t内容(模板)如下:\t\tWLAN_NAME=TEST WLan\t\tWLAN_PASSWORD=23456789\t\t其中\"TEST WLan\"可以替换为其他的名称作为“Wifi网络名”。\t\t\"23456789\"为连接本网络的密码。\t\t系统在检测到USB Wifi之后，就会去探测这个文件，如果有，并且数据有效，\t\t就会按照本配置来设置网络，否则系统使用方案二。\t\t\t\t  \t方案二:\t\t  如果在硬盘的根目录下没有找到文件:wifi_cfg.txt.\t  则系统会使用一个默认的Wifi网络名和密码.\t  默认的网络名称为:HACK WLan\t  默认的网络密码为:12345678\t  (本默认网络名和密码，你们可以提出更改为其他名称 作为默认)\t  \t注意:\t\t1.在系统中，我限制了网络名称为64个字节以内。\t\t2.设置网络密码时，如果位数小于8位，视为无效密码，则系统使用默认配置。***********************************************************************************/#define TMP_BUF_LEN\t(64)#define WifiConfigName\t\"/mnt/hd1/wifi_cfg.txt\"char pFixedUSBWifiName[TMP_BUF_LEN]={0};char pFixedUSBWifiPassWord[TMP_BUF_LEN]={0};static void CheckStringNULL(char *pInputString,int len){\tint i=0;\tfor(i=0;i<len;++i)\t{\t\tif(pInputString[i]=='\\r')\t\t\tpInputString[i]='\\0';\t\tif(pInputString[i]=='\\n')\t\t\tpInputString[i]='\\0';\t}\tpInputString[len]='\\0';}static int get_file_line(char *pInputName, char *pOutputBuf,int bufferLen, int line_idx){\tFILE * fp;\tint i=0;\tchar *p;\tchar * line = NULL;\tsize_t len = 0;\tssize_t read;\t\tfp = fopen(pInputName, \"r\");\tif (fp == NULL)\t\treturn -1;\t\tif(pOutputBuf && (line_idx<=0))\t{\t\tfclose(fp);\t\treturn -2;\t}\t\twhile ((read = getline(&line, &len, fp)) != -1) {\t\t//printf(\"line ==== %s \\n\",line);\t\tp=line;\t\tif(line[0]=='#')\t\t\tcontinue;\t\t++i;\t\t\t\tif(pOutputBuf && (i>=line_idx))\t\t\tbreak;\t}\tif(pOutputBuf && (i==line_idx))\t{\t\tint length=strlen(line)>bufferLen?bufferLen:strlen(line);\t\tmemcpy(pOutputBuf,line,length);\t}else\t{\t\ti=-1;\t}\tif (line != NULL)\tfree(line);\tif (fp   != NULL)\tfclose(fp);\treturn i;}/*\treturn :\t-1 : name or password is invalid.\t 0 : name and password are valid.*/static int GetWifiNameAndPassword(){\t\tchar *p=NULL;\tchar *pTempBuffer=NULL;\t\t\tif ( access(WifiConfigName, F_OK ) == 0 )\t{\t\tmemset(pFixedUSBWifiName,0,TMP_BUF_LEN);\t\tmemset(pFixedUSBWifiPassWord,0,TMP_BUF_LEN);\t\t\t\tif( (1==get_file_line(WifiConfigName,pFixedUSBWifiName,TMP_BUF_LEN,1))\t\t\t&& (2==get_file_line(WifiConfigName,pFixedUSBWifiPassWord,TMP_BUF_LEN,2)) )\t\t{\t// name and password exist.\t\t\tif(NULL!=(pTempBuffer=malloc(sizeof(char)*TMP_BUF_LEN)))\t\t\t{\t\t\t\tmemcpy(pTempBuffer,pFixedUSBWifiName,TMP_BUF_LEN);\t\t\t\tmemset(pFixedUSBWifiName,0,TMP_BUF_LEN);\t\t\t\tp=strchr(pTempBuffer,'=');\t\t\t\tif(NULL!=p)\tmemcpy(pFixedUSBWifiName,p+1,pTempBuffer+TMP_BUF_LEN-p);\t\t\t\telse \t\t\t\t\tgoto ret_error;\t\t\t\t\t\t\t\tCheckStringNULL(pFixedUSBWifiName,pTempBuffer+TMP_BUF_LEN-p);\t\t\t\t//printf(\"000 pFixedUSBWifiName === [%s] \\n\",pFixedUSBWifiName);\t\t\t\t\t\t\t\t\t\t\t\tmemcpy(pTempBuffer,pFixedUSBWifiPassWord,TMP_BUF_LEN);\t\t\t\tmemset(pFixedUSBWifiPassWord,0,TMP_BUF_LEN);\t\t\t\tp=strchr(pTempBuffer,'=');\t\t\t\tif(NULL!=p)\tmemcpy(pFixedUSBWifiPassWord,p+1,pTempBuffer+TMP_BUF_LEN-p);\t\t\t\telse \t\t\t\t\tgoto ret_error;\t\t\t\t//pFixedUSBWifiPassWord[pTempBuffer+TMP_BUF_LEN-p]=\"\\0\";\t\t\t\tCheckStringNULL(pFixedUSBWifiPassWord,pTempBuffer+TMP_BUF_LEN-p);\t\t\t\t//printf(\"000 pFixedUSBWifiPassWord === [%s] [%d]\\n\",pFixedUSBWifiPassWord,strlen(pFixedUSBWifiPassWord));\t\t\t\t\tif(strlen(pFixedUSBWifiPassWord)<8)\tgoto ret_error;\t\t\t\t\t\t\t\tif(NULL!=pTempBuffer)\tfree(pTempBuffer);\t\t\t\treturn 0;\t\t\t\t\t\t\t}else\t\t\t\tgoto ret_error;\t\t}else\t\t\tgoto ret_error;\t}else \t{\t// donot exist wifi config file.\t\tgoto ret_error;\t}\tret_error:\t//printf(\"111 pFixedUSBWifiName === [%s] \\n\",pFixedUSBWifiName);\t//printf(\"111 pFixedUSBWifiPassWord === [%s] \\n\",pFixedUSBWifiPassWord);\tif(NULL!=pTempBuffer)\tfree(pTempBuffer);\treturn -1;}static void MountUSBWiFi(void){\tchar *pTempCmdString=NULL;\t\tsystem(\"killall dhcpd\");\tsystem(\"ifconfig ra0 192.168.0.1 netmask 255.255.255.0\");\tsystem(\"/etc/Wireless/RT2870AP/iwpriv ra0 set AuthMode=WPA2PSK\");\tsystem(\"/etc/Wireless/RT2870AP/iwpriv ra0 set EncrypType=TKIP\");\t#if 1\t\t\t\tif(0==GetWifiNameAndPassword())\t{\t// use fixed name and password.\t\tif(NULL!=(pTempCmdString=malloc(sizeof(char)*TMP_BUF_LEN*2)))\t\t{\t\t\tmemset(pTempCmdString,0,TMP_BUF_LEN*2);\t\t\tsprintf(pTempCmdString,\"/etc/Wireless/RT2870AP/iwpriv ra0 set SSID=\\\"%s\\\"\",pFixedUSBWifiName);\t\t\t\t\t\t//printf(\" pTempCmdString ========== [%s] \\n\",pTempCmdString);\t\t\tsystem(pTempCmdString);\t\t\t\t\t\tmemset(pTempCmdString,0,TMP_BUF_LEN*2);\t\t\tsprintf(pTempCmdString,\"/etc/Wireless/RT2870AP/iwpriv ra0 set WPAPSK=%s\",pFixedUSBWifiPassWord);\t\t\t\t\t\t//printf(\" pTempCmdString ========== [%s] \\n\",pTempCmdString);\t\t\tsystem(pTempCmdString);\t\t\t\t\t\tmemset(pTempCmdString,0,TMP_BUF_LEN*2);\t\t\tsprintf(pTempCmdString,\"/etc/Wireless/RT2870AP/iwpriv ra0 set SSID=\\\"%s\\\"\",pFixedUSBWifiName);\t\t\t//printf(\" pTempCmdString ========== [%s] \\n\",pTempCmdString);\t\t\tsystem(pTempCmdString);\t\t\t\t\t\tfree(pTempCmdString);\t\t\tpTempCmdString=NULL;\t\t}\t}\telse#endif\t\t\t\t{\t// use default name and password.\t\tsystem(\"/etc/Wireless/RT2870AP/iwpriv ra0 set SSID=\\\"HACK WLan\\\"\");\t\tsystem(\"/etc/Wireless/RT2870AP/iwpriv ra0 set WPAPSK=12345678\");\t\tsystem(\"/etc/Wireless/RT2870AP/iwpriv ra0 set SSID=\\\"HACK WLan\\\"\");\t}\tsystem(\"/etc/Wireless/RT2870AP/dhcpd &\");\treturn 0;}static int InitHotplugSock(void){\t    struct sockaddr_nl snl;    const int buffersize = 16 * 1024;    int retval;\t    memset(&snl, 0x00, sizeof(struct sockaddr_nl));    snl.nl_family = AF_NETLINK;    snl.nl_pid = getpid();    snl.nl_groups = 1;\t    int hotplug_sock = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT);    if (hotplug_sock == -1) {        printf(\"error getting socket: %s\", strerror(errno));        return -1;    }\t    /* set receive buffersize */    setsockopt(hotplug_sock, SOL_SOCKET, SO_RCVBUFFORCE, &buffersize, sizeof(buffersize));    retval = bind(hotplug_sock, (struct sockaddr *) &snl, sizeof(struct sockaddr_nl));\t    if (retval < 0) {        printf(\"bind failed: %s\", strerror(errno));        close(hotplug_sock);        hotplug_sock = -1;        return -1;    }\t    return hotplug_sock;}void CheackUSBWiFi(void){#define UEVENT_BUFFER_SIZE 2048\tint hotplug_sock;\tchar buf_cache[UEVENT_BUFFER_SIZE],*pTempSeekPt,*pTempSeek2;\tint tTempNum,tMntValue;\tint tMntFlag;\tint tRemoveFlag = 0;\t\thotplug_sock = InitHotplugSock();\t\tmemset(buf_cache, 0 ,sizeof(buf_cache));\t\twhile(1)\t{\t\ttTempNum=recv(hotplug_sock,buf_cache, sizeof(buf_cache), 0);\t\tif( tTempNum<0  )\t\t{\t\t\tprintf(\"======usb hot plug error!!!=======\\n\");\t\t\tbreak;\t\t}\t\tif( tTempNum!=0 )\t\t{\t\t\tbuf_cache[tTempNum]=0;\t\t\t//printf(\"buf_cache (pinggle print): %s \\n\", buf_cache);\t\t\t\t\t\tif( NULL!=strstr(buf_cache,\"add@/devices/virtual/net/ra0\") )\t\t\t{\t\t\t\t\tprintf(\"usb ==== ADD pinggle print \\n\");\t\t\t\tMountUSBWiFi();\t\t\t}\t\t\tif( NULL!=strstr(buf_cache,\"remove@/devices/virtual/net/ra0\") )\t\t\t{\t\t\t\t\tprintf(\"usb ==== Remove pinggle print \\n\");\t\t\t} \t\t\t\t\t\t}\t}}","title":"Linux下用Socket检测设备的挂载(实现设备的自动挂载)"},{"content":"[OpenGL ES 07-1]光照原理 罗朝辉 (http://blog.csdn.net/kesalin/) 本文遵循“署名-非商业用途-保持一致”创作公用协议   这是《OpenGL ES 教程》的第七篇，前六篇请参考如下链接： [OpenGL ES 01]iOS上OpenGL ES之初体验 [OpenGL ES 02]OpenGL ES渲染管线与着色器 [OpenGL ES 03]3D变换：模型，视图，投影与Viewport [OpenGL ES 04]3D变换实践篇：平移，旋转，缩放 [OpenGL ES 05]相对空间变换与颜色 [OpenGL ES 06]使用VBO:顶点缓存 前言 在前文《[OpenGL ES 05]相对空间变换及颜色》中讲到人的眼睛捕捉色彩的过程：在光照的作用下，物体表面反射不同频率的光子到人的眼睛中刺激感光细胞从而形成视觉。在那一篇文章中，演示了如何使用颜色，但没有提及光照，在接下来的文章中，我将来详细介绍光的特性，物体的材质属性，光照原理以及在 OpenGL ES 2.0中的应用示例。   一，光照的基本概念 运行 OpenGL 程序在屏幕上显示的最终颜色，受场景中光线的特性以及物体反射和吸收光的属性（即材质）影响。光线可能来自特定的位置与方向，也可能是散布在整个场景中（环境光）；而物体表面能够吸收，反射光线，有些物体本身还能够发射光线，物体的这些属性被称为材质。在 OpenGL 中，物体的材质属性通过反射不同方向的环境光，漫反射光，镜面光的RGB颜色来表示的。光照计算就是将发射光，泛射光，漫反射光以及镜面高光四个成分分别计算，然后再累加起来。 光特性 发射光（emission）：由物体自身发射的光。如果物体本身不发光，则无此属性； 环境光（ambient）：就是哪些在环境中进行了充分散射的光，而无法分辨其方向的光。光线在物体表面上向各个方向上均匀泛射，场景中的物体都会泛射光，这些泛射光又会照射到其他物体上继续被泛射，直到光子能量耗尽为止，这样整个场景中散布着这样的泛射光。在编程时，可通过设置一个颜色常量来表示环境光或使用 ambient occlusion map （环境闭包贴图）来处理环境光。在 OpenGL 中，全局环境光的强度为 (0.2, 0.2, 0.2, 1.0)，这弱弱的白色全局环境光确保即使没有额外的光源，场景中的物体依然是可见的。 漫反射光（diffuse）：光线来自某个方向，但在物体表面上向各个方向上反射，无论在何处观察，散射光看上去亮度都相同。我们之所以能看到物体，就是因为物体将入射的光然后向各个方向反射（所以称之为漫反射）。物体的漫反射材质属性对物体的颜色起着决定性作用。 镜面高光（specular）：光线来自一个特定的方向，然后在物体表面上以一个特定的方向反射出去（镜面反射）。正是由于镜面高光让物体看起来有光泽，如台球，金属表面的光泽。镜面反射与物体的镜面反射材质属性有很大关系，如金属表面能产生很高的镜面发射，而地毯几乎没有镜面反射。在 OpenGL 中，镜面光的强度可通过光泽度（shininess）来调节。 材质属性 物体的材质属性取决于物体反射的红绿蓝光的比例。与光源的特性相似，材质也分为泛射材质，漫反射材质，镜面材质和反射材质，分别表示反射相应类型光的反射率。 泛射材质：环境光的反射率影响物体的整体颜色，因为直射到物体上的漫反射光最亮，而没有被直射的物体的环境反射光最明显。一个物体的泛射光反射率受全局环境光和来自光源的环境光的双重影响。泛射光的反射率不受观察点点位置的影响。 漫反射材质：漫反射的反射率对物体的颜色起着最重要的作用，它受入射的漫反射光颜色以及入射光与法线的夹角的影响，但不受观察点位置的影响。 镜面反射材质：表面较为光洁的物体由于反射光线而会产生亮斑（看起来有光泽），在这种亮斑被称为镜面反射光。在 OpenGL 中物体对光的镜面反射材质属性决定了光泽的颜色、大小和亮度。镜面反射光的强度还取决于观察点的位置，当观察点正好处于入射光的反射光线上，亮斑的亮度到达最大值。 发射材质：前面提到的三种材质都是被动地反射来自外界的光线，而有些物体本身可以发射光。在 OpenGL 中是通过给物体设置发射材质颜色来模拟的，物体表面的发射颜色可以增加物体的强度，但不受任何光源的影响。此外，在整个场景中，发射光并没有被当作一种额外的光照。   二，光照的计算 前面说了，光照效果是由发射光，环境光，漫反射光以及镜面高光四部分组成，这四部分各自独立计算，然后再累加起来得到最终的光照效果。下面就来详细介绍这些组成部分是如何计算的。 发射光计算 前面说过，在 OpenGL 中是给物体材质设置发射颜色来模拟发射光的，因此它的计算非常简单： 发射颜色 = 物体的发射材质颜色 环境光计算 前面说到，一般我们是设置一个颜色常量来表示环境光（或来自 ambient occlusion map），因此环境光的计算也是很简单的。 环境颜色 = 光源的环境光颜色 × 物体的环境材质颜色 漫反射光计算 漫反射如下图所示： 漫反射颜色 = 光源的漫反射光颜色 × 物体的漫反射材质颜色 × DiffuseFactor 其中漫反射因子 DiffuseFactor 是光线与顶点法线向量的点积： DiffuseFactor = max(0, dot(N, L)) 在图形学中，点积几何意义其实就是表示两个向量之间夹角的 cos 值。因此这个公式直观地揭示了漫反射的规律：顶点法线正对入射光线，漫反射效果最强，顶点法线背对入射光线（角度大于等于90度）就完全没有漫反射效果。 注意：在光照计算中，顶点法线必须是经过规范化的（normalize）。 我们可以设置一个颜色常量来表示漫反射材质颜色，来得到平滑颜色的表面。但有些物体表面是很粗糙的，如裂缝，隆起，刮痕等。为了获得这样的粗糙表面效果，可以使用 displaced polygon 技术，但这需要大量的计算，效率低下。另外一种更为高效的方式就是使用凹凸贴图（bump map）。凹凸贴图就是一种纹理，其内容包含编码在RGB颜色空间中的经过扰动的顶点法线。在使用凹凸贴图进行漫反射计算时时，首先和前面一样用正常法线计算出 NormalDiffuseFactor，再根据扰动的顶点法线计算出 PerturbedDiffuseFactor，然后将两者相乘作为最终的 DiffuseFactor。如下图所示： 普通漫反射 凹凸贴图 镜面反射 镜面反射如下图所示: 镜面反射颜色 = 光源的镜面光颜色 × 物体的镜面材质颜色 × SpecularFactor SpecularFactor = power(max(0, dot(N, H)), shininess) H = normalise(L + E) 与漫反射不同，镜面反射受观察者的位置影响，这一点在上面的计算公式中可以清楚地看出来。H 向量是视线向量 E 与光线向量 L 的半向量（注意：它经过规划化的），其几何意义就是视线与光线夹角的平分线。而 H 和 N 的点积的几何意义就是说这个平分线与法线的夹角的 cos 值，然后将这个 cos 值进行 shininess 次乘方计算得到最终的镜面反射因子 Specularfactor。 这里的关键点在于视线与光线的平分线与法线的点积计算上，这表示，当视线与光线在表面处的反射光线夹角（可看成是N与H的夹角）越少时，镜面反射效果最明显(角度越小，cos 值越大)。 一般可使用常量颜色作为镜面材质颜色，但这样得到的效果有时候并不理想。同漫反射一样，我们也可以使用镜面贴图来获得更好的镜面反射效果。镜面贴图通过控制物体表示上特定像素允许的镜面反射强度来获得较为真实的效果。 普通镜面反射 镜面贴图纹理 镜面贴图反射 衰减因子 光源发射的光线在其传播过程中，会与空气中的其他粒子碰撞，其能量会逐渐衰减。在 OpenGL 中，这是通过将光照强度乘以随传播距离变化的衰减因子来模拟实现的。这个衰减因子的计算公式如下： 衰减因子 = 1.0/(距离衰减常量 + 线性衰减常量 × 距离 + 二次衰减常量 × 距离的平方) 其中距离衰减常量，线性衰减常量和二次衰减常量均为常量值。 注意：环境光，漫反射光和镜面光的强度都会受随着距离的增大而衰减，只有发射光和全局环境光的强度不会受此影响。 聚光灯因子 在这里，我们讨论聚光灯的发射光照计算（也即位置型光源：如台灯，相对方向性光源：如太阳）。聚光灯就是朝某个特定发射发射光线的光源。你可以想象下漆黑的夜晚里，一个手电筒给与你光明的这个场景，手电筒就是一个很好的聚光灯示例。聚光灯的计算分为两部分：在光线照射角度范围之外的部分被忽略，只有在照射角度范围之内的部分需要计算。 聚光灯夹角cos值 = power(max(0, dot(单位光源向量, 单位光线向量)), 聚光灯指数) 其中单位光线向量是从光源指向顶点的单位向量，聚光灯指数表示聚光灯的亮度程度。前面说过点积的几何意义就是表示角度的，这里聚光灯因子就表示光源向量与光线向量之间的夹角。 而为了模拟真实聚光灯光环效果，在照射角度范围之内与之外的接壤处，设置一个渐变过渡区域，以避免光照从有到无巨变： 无过渡 有过渡 增加过渡区之后的计算如下： 内环是完全光照的，而过渡区域（中环）是从完全光照到完全没有光照的渐变过渡，外环是完全没有光照的。 聚光灯因子 = clamp((外环的聚光灯角度cos值 - 当前顶点的聚光灯角度cos值)/(外环的聚光灯角度cos值 - 内环聚光灯角度cos值), 0, 1) clamp 函数是将聚光灯因子限定在[0, 1]之间，这样，内环是完全光照的，而中环是从完全光照到没有光照的渐变过渡，外环是没有光照的。因此： 聚光灯效果 = 聚光灯光源颜色  × 聚光灯因子 光照计算的终极公式 光照颜色 = 发射颜色 + 全局环境颜色 + (环境颜色 + 漫反射颜色 + 镜面反射颜色) × 聚光灯效果 × 衰减因子 如果场景中有多个光源（包括环境光），那么分别计算来每个光源的光照颜色，然后把这些光照颜色累加即可。如果物体不发射光，则没有发射颜色这一成分。 三，高洛德着色（Gouraud Shading）与冯氏着色（Phong Shading） 在图形渲染中有两种着色方式，高洛德着色与冯氏着色。高洛德着色也被称为Per-Vertex着色，它是在顶点着色阶段对顶点进行颜色计算，然后在光栅化阶段对这些顶点颜色进行线性插值形成片元的颜色；冯氏着色也被称为Per-Pixel像素着色，它是在片元着色阶段对每一个片元（像素）进行颜色计算。无疑，插值的颜色效果没有针对每一个片元进行颜色计算的效果好（除非你的图元切分到像素近似大小，不过这样 GPU 肯定吃不消，计算量巨大！）。 Gouraud 着色 Phong 着色 四，结语 光照是个很复杂的话题，尤其是多光源，阴影的计算。在这篇文章中，我详细介绍了不同类型光的性质以及物体的材质属性，以及光照计算的过程。这些都是光照的基石，掌握了这些才有可能继续攀登高峰。在下一篇文章中，我将演示一个 Gouraud 着色的光照示例。   五，参考 1. \"Lambertian reflectance\". Wikipedia 2. \"Phong shading\" . Wikipedia. 3. Devmaster.net. The basics of 3d lighting 4. OpenGL 编程指南","title":"[OpenGL ES 07-1]光照原理"},{"content":"本人博客原文 第一部分 Android进程 1.1、Android进程简介     每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例,而每一个虚拟机实例都是一个独立的进程空间,不同的应用在不同的进程空间里运行，当一个虚拟机关闭或意外中止时不会对其它虚拟机造成影响，可以最大程度的保护应用的安全和独立运行.     关于此的更多内容可参考《Android Dalvik虚拟机简介》 1.2、Android进程间内存的不可见性 Android中进程之间的内存并不是直接可见。 关于此内容参考阅读《Android中单APK应用多进程》 1.3、Android进程内存占用的最大值 Android进程内存占用的默认最大值为16M或32M ，该值只是指dalvik上分配的内存，它不包括在native上分配的内存值. 更多内容请参考《Android应用程序的默认最大内存值》 1.4、单APK多进程技术     默认一个APK包就对应一个进程，其进程名就为AndroidManifest.xml文件中 指定的package名。我们可以通过Activity, Service, BroadCastReceiver, ContentProvider的android:process属性来实现单APK多进程 关于此的更多内容请阅读《Android中单APK应用多进程》和《如何在Android中取得当前进程名》 第二部分 Android内存 2.1、Android中如何查看内存 像Linux这种现代操作系统的内存使用是很复杂的，因此很难准确的知道你的应用程序使用了好多内存。查看内存使用的方式有很多种，但是各个方式查看到的结果可能会有微略不同。 关于此的详细内容请阅读《Android中如何查看内存(上)》和《Android中如何查看内存(下)》 2.2、对象的强引用，软应用，弱应用 关于此的详细内容请阅读《对象的强、软、弱和虚引用》 2.3、Android中图片占用内存的计算 详细内容请阅读《Android中图片占用内存的计算》 2.4、使用LinkedHashMap来实现高效的内存缓冲 详细内容请阅读《LinkedHashMap简介》 第三部分 Android内存泄漏 3.1、Android内存泄漏简介 在java程序中，如果已经不再使用某个对象，但是因为仍然有引用指向它，垃圾回收器就无法回收它，当然该对象占用的内存就无法被使用，这就造成了内存泄露。 更多内容请阅读《Android内存泄漏简介》 3.2、Android中如何查找内存泄露 我们可以在MAT中，对进程的hprof文件进行分析，以便找到内存泄露。 更多内容请参考《Android中如何查找内存泄露》","title":"Android进程与内存及内存泄露"},{"content":"//获得某个window的某个subViewUIView *view = [[[[[UIApplication sharedApplication] windows] objectAtIndex:0] subviews] lastObject];NSInteger index = 0;//用来给保存的png命名for (UIView *subView in [view subviews]) {//遍历这个view的subViewsif ([subView isKindOfClass:NSClassFromString(@\"MKMapView\")]) {//找到自己需要的subViewNSLog(@\"fund\");//支持retina高分的关键if(UIGraphicsBeginImageContextWithOptions != NULL){UIGraphicsBeginImageContextWithOptions(subView.frame.size, NO, 0.0);} else {UIGraphicsBeginImageContext(subView.frame.size);}//获取图像[subView.layer renderInContext:UIGraphicsGetCurrentContext()];UIImage *image = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();//保存图像NSString *path = [NSHomeDirectory() stringByAppendingFormat:@\"/%d.png\",index];if ([UIImagePNGRepresentation(image) writeToFile:path atomically:YES]) {index += 1;NSLog(@\"Succeeded! %@\",path);}else {NSLog(@\"Failed!\");}}}","title":"IOS给任意UIView截屏"},{"content":"uitableview 无需关联delegate 只需要再uitabviewcontrller 中添加上 UIScrollViewDelegate int lastContentOffset; -(void)scrollViewWillBeginDragging:(UIScrollView *)scrollView {     lastContentOffset = scrollView.contentOffset.y; } -(void)scrollViewDidScroll:(UIScrollView *)scrollView {     if (scrollView.contentOffset.y<lastContentOffset)     {         [self.navigationController setNavigationBarHidden:NO animated:YES]; //向上     } else if (scrollView.contentOffset.y>lastContentOffset)     {         [self.navigationController setNavigationBarHidden:YES animated:YES]; //向下     } }","title":"uitableview scrollview 判断滑动方向"},{"content":"应用程序对Nand Flash的读写操作 接上篇继续分析Nand Flash驱动：Nand Flash的设备探测函数s3c24xx_nand_probe的动作。 s3c24xx_nand_probe函数首先创建代表MTD原始设备的数据结构体struct mtd_info *mtd，并将其初始化，源代码如下所示： /* s3c24xx_nand_probe  * called by device layer when it finds a device matching one our driver can handled. This code checks to see if  * it can allocate all necessary resources then calls the nand layer to look for devices */ static int s3c24xx_nand_probe(struct platform_device *pdev) {  struct s3c2410_platform_nand *plat = to_nand_plat(pdev);  enum s3c_cpu_type cpu_type;  struct s3c2410_nand_info *info;  struct s3c2410_nand_mtd *nmtd;  struct s3c2410_nand_set *sets;  struct resource *res;  int err = 0;  int size;  int nr_sets;  int setno;  cpu_type = platform_get_device_id(pdev)->driver_data; //获取设备ID  pr_debug(\"s3c2410_nand_probe(%p)\\n\", pdev);  info = kmalloc(sizeof(*info), GFP_KERNEL);    //创建代表Nand Flash控制器的struct s3c2410_nand_info *info结构体变量  if (info == NULL) {   dev_err(&pdev->dev, \"no memory for flash info\\n\");   err = -ENOMEM;   goto exit_error;  }  memset(info, 0, sizeof(*info));  platform_set_drvdata(pdev, info);  spin_lock_init(&info->controller.lock);      //使用自旋锁、初始化等待队列  init_waitqueue_head(&info->controller.wq);  /* get the clock source and enable it */  //初始化struct s3c2410_nand_info *info结构体变量  info->clk = clk_get(&pdev->dev, \"nand\");  if (IS_ERR(info->clk)) {   dev_err(&pdev->dev, \"failed to get clock\\n\");   err = -ENOENT;   goto exit_error;  }  clk_enable(info->clk);  /* allocate and map the resource */  /* currently we assume we have the one resource */  res  = pdev->resource;  size = res->end - res->start + 1;  info->area = request_mem_region(res->start, size, pdev->name);  if (info->area == NULL) {   dev_err(&pdev->dev, \"cannot reserve register region\\n\");   err = -ENOENT;   goto exit_error;  }  info->device     = &pdev->dev;  info->platform   = plat;  info->regs       = ioremap(res->start, size);  info->cpu_type   = cpu_type;  if (info->regs == NULL) {   dev_err(&pdev->dev, \"cannot reserve register region\\n\");   err = -EIO;   goto exit_error;  }  dev_dbg(&pdev->dev, \"mapped registers at %p\\n\", info->regs);  /* initialise the hardware */  err = s3c2410_nand_inithw(info);  if (err != 0)   goto exit_error;  sets = (plat != NULL) ? plat->sets : NULL;  nr_sets = (plat != NULL) ? plat->nr_sets : 1;  info->mtd_count = nr_sets;  /* allocate our information */  size = nr_sets * sizeof(*info->mtds);   //创建Nand Flash硬件设备驱动层的MTD结构体变量struct s3c2410_nand_mtd *mtds  info->mtds = kmalloc(size, GFP_KERNEL);  if (info->mtds == NULL) {   dev_err(&pdev->dev, \"failed to allocate mtd storage\\n\");   err = -ENOMEM;   goto exit_error;  }  memset(info->mtds, 0, size);  /* initialise all possible chips */  nmtd = info->mtds;  for (setno = 0; setno < nr_sets; setno++, nmtd++) {   pr_debug(\"initialising set %d (%p, info %p)\\n\", setno, nmtd, info);   s3c2410_nand_init_chip(info, nmtd, sets); //初始化struct nand_chip chip结构体nand芯片底层接口操作函数   nmtd->scan_res = nand_scan_ident(&nmtd->mtd, //读取Nand Flash设备ID，并与驱动中的Nand Flash ID表比较是否存在        (sets) ? sets->nr_chips : 1);   if (nmtd->scan_res == 0) {    s3c2410_nand_update_chip(info, nmtd);    nand_scan_tail(&nmtd->mtd);    s3c2410_nand_add_partition(info, nmtd, sets);  //把创建并初始化好的MTD原始设备添加到MTD原始设备列表中   }   if (sets != NULL)    sets++;  }  err = s3c2410_nand_cpufreq_register(info);  if (err < 0) {   dev_err(&pdev->dev, \"failed to init cpufreq support\\n\");   goto exit_error;  }  if (allow_clk_stop(info)) {   dev_info(&pdev->dev, \"clock idle support enabled\\n\");   clk_disable(info->clk);  }  pr_debug(\"initialised ok\\n\");  return 0;  exit_error:  s3c24xx_nand_remove(pdev);  if (err == 0)   err = -EINVAL;  return err; } 二、应用程序对Nand Flash设备的读写 1、s3c2440_nand_hwcontrol函数 直接操作S3C2440 Nand Flash控制器的COMMAND寄存器和ADDRESS寄存器。 static void s3c2440_nand_hwcontrol(struct mtd_info *mtd, int cmd,          unsigned int ctrl)   //cmd表示要写到nand flash控制器的命令或地址                                       //ctrl表示要写的是命令还是地址 {  struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);  if (cmd == NAND_CMD_NONE)   return;  if (ctrl & NAND_CLE)  //命令   writeb(cmd, info->regs + S3C2440_NFCMD);  else   writeb(cmd, info->regs + S3C2440_NFADDR); } 2、nand_command函数 具体命令要看芯片手册，包括操作序列 /**  * nand_command - [DEFAULT] Send command to NAND device  * @mtd: MTD device structure  * @command: the command to be sent  * @column: the column address for this command, -1 if none  * @page_addr: the page address for this command, -1 if none  *  * Send command to NAND device. This function is used for small page  * devices (256/512 Bytes per page)  */ static void nand_command(struct mtd_info *mtd, unsigned int command,     int column, int page_addr) {  register struct nand_chip *chip = mtd->priv;  int ctrl = NAND_CTRL_CLE | NAND_CTRL_CHANGE;  /*   * Write out the command to the device.   */  if (command == NAND_CMD_SEQIN) {   int readcmd;   if (column >= mtd->writesize) {    /* OOB area */    column -= mtd->writesize;    readcmd = NAND_CMD_READOOB;   } else if (column < 256) {    /* First 256 bytes --> READ0 */    readcmd = NAND_CMD_READ0;   } else {    column -= 256;    readcmd = NAND_CMD_READ1;   }   chip->cmd_ctrl(mtd, readcmd, ctrl);   ctrl &= ~NAND_CTRL_CHANGE;  }  chip->cmd_ctrl(mtd, command, ctrl);  /*   * Address cycle, when necessary   */  ctrl = NAND_CTRL_ALE | NAND_CTRL_CHANGE;  /* Serially input address */  if (column != -1) {   /* Adjust columns for 16 bit buswidth */   if (chip->options & NAND_BUSWIDTH_16)    column >>= 1;   chip->cmd_ctrl(mtd, column, ctrl);   ctrl &= ~NAND_CTRL_CHANGE;  }  if (page_addr != -1) {   chip->cmd_ctrl(mtd, page_addr, ctrl);   ctrl &= ~NAND_CTRL_CHANGE;   chip->cmd_ctrl(mtd, page_addr >> 8, ctrl);   /* One more address cycle for devices > 32MiB */   if (chip->chipsize > (32 << 20))    chip->cmd_ctrl(mtd, page_addr >> 16, ctrl);  }  chip->cmd_ctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);  /*   * program and erase have their own busy handlers   * status and sequential in needs no delay   */  switch (command) {  case NAND_CMD_PAGEPROG:  case NAND_CMD_ERASE1:  case NAND_CMD_ERASE2:  case NAND_CMD_SEQIN:  case NAND_CMD_STATUS:   return;  case NAND_CMD_RESET:   if (chip->dev_ready)    break;   udelay(chip->chip_delay);   chip->cmd_ctrl(mtd, NAND_CMD_STATUS,           NAND_CTRL_CLE | NAND_CTRL_CHANGE);   chip->cmd_ctrl(mtd,           NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);   while (!(chip->read_byte(mtd) & NAND_STATUS_READY)) ;   return;   /* This applies to read commands */  default:   /*    * If we don't have access to the busy pin, we apply the given    * command delay    */   if (!chip->dev_ready) {    udelay(chip->chip_delay);    return;   }  }  /* Apply this short delay always to ensure that we do wait tWB in   * any case on any machine. */  ndelay(100);  nand_wait_ready(mtd); } 3、nand_command_lp函数 由于本开发板Mini2440的Nand Flash 256M而且page容量是2Kbytes，用nand_command_lp函数代替nand_command函数。 static void nand_command_lp(struct mtd_info *mtd, unsigned int command,        int column, int page_addr) {  register struct nand_chip *chip = mtd->priv;  /* Emulate NAND_CMD_READOOB */  if (command == NAND_CMD_READOOB) {   column += mtd->writesize;   command = NAND_CMD_READ0;  }  /* Command latch cycle */  chip->cmd_ctrl(mtd, command & 0xff,          NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);  if (column != -1 || page_addr != -1) {   int ctrl = NAND_CTRL_CHANGE | NAND_NCE | NAND_ALE;   /* Serially input address */   if (column != -1) {    /* Adjust columns for 16 bit buswidth */    if (chip->options & NAND_BUSWIDTH_16)     column >>= 1;    chip->cmd_ctrl(mtd, column, ctrl);    ctrl &= ~NAND_CTRL_CHANGE;    chip->cmd_ctrl(mtd, column >> 8, ctrl);   }   if (page_addr != -1) {    chip->cmd_ctrl(mtd, page_addr, ctrl);    chip->cmd_ctrl(mtd, page_addr >> 8,            NAND_NCE | NAND_ALE);    /* One more address cycle for devices > 128MiB */    if (chip->chipsize > (128 << 20))     chip->cmd_ctrl(mtd, page_addr >> 16,             NAND_NCE | NAND_ALE);   }  }  chip->cmd_ctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);  /*   * program and erase have their own busy handlers   * status, sequential in, and deplete1 need no delay   */  switch (command) {  case NAND_CMD_CACHEDPROG:  case NAND_CMD_PAGEPROG:  case NAND_CMD_ERASE1:  case NAND_CMD_ERASE2:  case NAND_CMD_SEQIN:  case NAND_CMD_RNDIN:  case NAND_CMD_STATUS:  case NAND_CMD_DEPLETE1:   return;   /*    * read error status commands require only a short delay    */  case NAND_CMD_STATUS_ERROR:  case NAND_CMD_STATUS_ERROR0:  case NAND_CMD_STATUS_ERROR1:  case NAND_CMD_STATUS_ERROR2:  case NAND_CMD_STATUS_ERROR3:   udelay(chip->chip_delay);   return;  case NAND_CMD_RESET:   if (chip->dev_ready)    break;   udelay(chip->chip_delay);   chip->cmd_ctrl(mtd, NAND_CMD_STATUS,           NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);   chip->cmd_ctrl(mtd, NAND_CMD_NONE,           NAND_NCE | NAND_CTRL_CHANGE);   while (!(chip->read_byte(mtd) & NAND_STATUS_READY)) ;   return;  case NAND_CMD_RNDOUT:   /* No ready / busy check necessary */   chip->cmd_ctrl(mtd, NAND_CMD_RNDOUTSTART,           NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);   chip->cmd_ctrl(mtd, NAND_CMD_NONE,           NAND_NCE | NAND_CTRL_CHANGE);   return;  case NAND_CMD_READ0:   chip->cmd_ctrl(mtd, NAND_CMD_READSTART,           NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);   chip->cmd_ctrl(mtd, NAND_CMD_NONE,           NAND_NCE | NAND_CTRL_CHANGE);   /* This applies to read commands */  default:   /*    * If we don't have access to the busy pin, we apply the given    * command delay    */   if (!chip->dev_ready) {    udelay(chip->chip_delay);    return;   }  }  /* Apply this short delay always to ensure that we do wait tWB in   * any case on any machine. */  ndelay(100);  nand_wait_ready(mtd); }  ","title":"友善之臂Mini2440之嵌入式Linux下应用程序对Nand Flash的读写操作"},{"content":"              今天解cts测试的bug，但是它是random fail，于是希望通过自动执行多遍，并抓下fail时的log进行解析。 1.编写脚本 自动执行的脚本如下： #!/sbin/sh chmod +x /system/bin/input i=0 while [ \"$i\" != \"10\" ] do am instrument -e class android.animation.cts.ValueAnimatorTest#testCurrentPlayTime -w -r com.android.cts.animation/android.test.InstrumentationTestRunner echo \"testCurrentPlayTime\" i=$(($i+1)) sleep 2 done 把这段code粘贴到文本文档中并保存为后缀名为.sh的文件，我是把它命名为3.sh。 2.把脚本push到测试环境中 命令如下： >adb push \"D:\\holdrise的专栏\\Tablet study\\自动化测试例子\\3.sh\" /system/bin 0 KB/s (274 bytes in 1.000s) 3.执行这个脚本 首先进入adb shell，然后到脚本所在的目录中去执行这个脚本，命令如下： >adb shell shell@android:/ $ cd /system/bin cd /system/bin shell@android:/system/bin $ sh 3.sh 2>&1|busybox tee test.log (这里是利用busybox这个工具来执行tee命令，以把执行脚本的过程中的log保存到指定的文件中) sh 3.sh 2>&1|busybox tee test.log （下面就是自动执行脚本中的命令啦～） Bad mode INSTRUMENTATION_STATUS: id=InstrumentationTestRunner INSTRUMENTATION_STATUS: current=1 INSTRUMENTATION_STATUS: class=android.animation.cts.ValueAnimatorTest INSTRUMENTATION_STATUS: stream= android.animation.cts.ValueAnimatorTest: INSTRUMENTATION_STATUS: numtests=1 INSTRUMENTATION_STATUS: test=testCurrentPlayTime INSTRUMENTATION_STATUS_CODE: 1 INSTRUMENTATION_STATUS: id=InstrumentationTestRunner INSTRUMENTATION_STATUS: current=1 INSTRUMENTATION_STATUS: class=android.animation.cts.ValueAnimatorTest INSTRUMENTATION_STATUS: stream=. INSTRUMENTATION_STATUS: numtests=1 INSTRUMENTATION_STATUS: test=testCurrentPlayTime INSTRUMENTATION_STATUS_CODE: 0 INSTRUMENTATION_RESULT: stream= Test results for InstrumentationTestRunner=. Time: 0.697 OK (1 test) （只提供其中一遍的log，它会自动执行指定的遍数。） 另外说明一下，busybox是一个工具集，因为这里不能直接用tee命令，所以为了保存log，在这里用了busybox这个工具。","title":"自动化测试脚本的编写和执行——自动执行cts测试10遍"},{"content":">adb shell pm list instrumentation（该命令会列出所有已经安装的apk） instrumentation:com.android.cts.stub/android.content.pm.cts.TestPmInstrumentation (target=android) instrumentation:com.android.cts.animation/android.test.InstrumentationTestRunner (target=com.android.cts.anima tion) instrumentation:com.android.cts.app/android.test.InstrumentationCtsTestRunner (target=com.android.cts.stub) instrumentation:com.android.cts.os/android.test.InstrumentationCtsTestRunner (target=com.android.cts.stub) 用该命令列出之后，测试单个函数或测试包时要与这里的相对应，如下面的例子所示： 1.cts测试单个函数： eg： a.测试testCurrentPlayTime方法 >adb shell am instrument -e class android.animation.cts.ValueAnimatorTest#te stCurrentPlayTime -w -r com.android.cts.animation/android.test.InstrumentationTestRunner b.测试testGetMemoryClass方法 >adb shell am instrument -e class android.app.cts.ActivityManagerMemoryClass Test#testGetMemoryClass -w -r com.android.cts.app/android.test.InstrumentationCtsTestRunner 2.测试整个包 eg: a.测试Android.animation这个包： >adb shell am instrument  -w -r com.android.cts.animation/android.test.InstrumentationTestRunner b.测试Android.app这个包： >adb shell am instrument  -w -r com.android.cts.app/android.test.InstrumentationCtsTestRunner","title":"Android cts测试命令"},{"content":"     1. Most of the great ideas we have in life are born out of the fleeting moments(转瞬间) of stillness(沉思). 我们生命中很多伟大的想法，都来源于沉思的一瞬间。     2. The biggest adventure you can take is to live the life of your dreams. 你能经历的最大冒险，就是过你梦想的生活。     3. Nothing great was evr achieved without enthusiasm. 没有热情就成不了伟业。     4. Beauty has no limits and change happens everyday. 美丽无极限，看我七十二变。       5. There is a good memory behind every pair of shoes 每一双鞋子背后都有一个美好的回忆。       6. A person is not lovely for beautiful but beautiful for being lovely. 不是因为美丽才可爱，是因为可爱才美丽。       7. Mama always said you could tell an awful about a person by the kind of shoes they wear. 妈妈总是说通过看人们穿的鞋子，可以了解他们很多。      8. I still have my feet on the ground. I'm just wearing better shoes. 我仍然脚踏实地，只是穿了双更好的鞋子。     9. The best shoes in the whole world, are those that look good on you! 适合你的鞋子，才是世界上最美的鞋子。     10. Where these are the most comfortable shoes on your feet, where there is the most wonderful life right now. 最舒适的鞋子在你脚上，最美好的生活就在当下。      11. Life is not lack of beauty, but lack of the eyes to find beauty. 生活中并不缺少美，而是缺少发现美的眼睛。     12. Meeting you was fate, and falling in love with you was out of my control. 遇见你是命中注定，而爱上你是我情不自禁。     13. If you spend too much time thinking about a thing, you wil never get it done. 如果你花费太多的时间去思考一件事，那你永远也不会完成它。","title":"cheer up"},{"content":"对于一个毫无JAVA和Android开发经验，甚至不久前才对2G、3G有点粗略概念，几天前才用上智能手机的码农来说，千辛万苦拼凑出来的apk，放到真机里安装、执行，结果老实不客气地弹出一个“意外停止执行”的对话框，这种打击是多么的沉重！ 那一刻，我觉得天都倒塌了。 这是一个多么简陋的安卓客户端，它只有一个重要的功能，就是开启后，自动打开我们网站。我用的是WebView。 可问题偏偏出现在这里。就是这一句： WebView.loadUrl(url); 什么状况？在模拟器里执行得好好的。 我怀疑是版本的问题，开发默认用的是Android4.2，但我的手机是2.3。 于是在开发环境将版本调回2.1，够低了吧。问题依旧。 难道我写错了什么？是在主线程访问了网络报错吗？明明是放在 new Thread 里的。 难道是在非主线程描绘了UI？也没有啊。 再次疯狂搜索，个个大牛都说的差不多，要么在xml里定义一个啦，要么在代码里new一个啦，然后记得开启 javascript 功能喔。。。问题是我照抄这些代码，放到真机里运行，一样会报错。 该不会是我这个手机不支持WebView吧。天哪，没有WebView，我简直不能活，谁那么牛可以去写一个浏览器，或者直接去处理那些HTML标记？ 我想起不久前用过一个自动生成网站安卓客户端的软件，生成了一个apk，于是拿到我的手机上安装，结果人家一切都很正常，可以打开我们网站。问题是，它用的是什么控件呢？ 反编译这个apk，代码看不懂，但它里面也是用到了WebView！我精神大振！不过它的AndroidMainifest.xml里面有这么几句：     <uses-sdk android:minSdkVersion=\"4\" />    <uses-permission android:name=\"android.permission.RESTART_PACKAGES\" />    <uses-permission android:name=\"android.permission.INTERNET\" />    <uses-permission android:name=\"android.permission.READ_PHONE_STATE\" />    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />    <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />    <uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" />    <uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" /> 其中 <uses-permission android:name=\"android.permission.INTERNET\" /> 我是有的，其他就没有。结果将这几句加上以后，问题解决。 其实这几条语句中，只须补加后面这3条：     <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />    <uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" />    <uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" /> 就可以。也许中间     <uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" />这条不用也可以，但我嫌麻烦，没有继续测试。这个权限好像是获取大致GPS位置的，主要用于加强手机广告的地域性。 鸣谢，参考文章： Android APK反编译详解（附图） http://blog.csdn.net/sunboy_2050/article/details/6727581 网站Android客户端制作软件绿色版.zip http://vdisk.weibo.com/s/44B7L 我的手机：酷派8180，安卓：2.3.7，中移动。","title":"WebView.loadUrl()在真机环境中执行即报错的问题"},{"content":"注：LinearLayout中的TextView按比例显示的时候，layout_width=\"0dp\"或者layout_height=\"0dp\"   在android开发中LinearLayout很常用，LinearLayout的内控件的android:layout_weight在某些场景显得非常重要，比如我们需要按比例显示。android并没用提供table这样的控件，虽然有TableLayout，但是它并非是我们想象中的像html里面的table那么好用，我们常用ListView实现table的效果，但是列对齐确比较麻烦，现在用LinearLayout及属性android:layout_weight能很好地解决。下面我们共同体验下layout_weight这个属性。 　　一、LinearLayout内的控件的layout_width设置为\"wrap_content\"，请看一下xml配置：  <LinearLayout      android:orientation=\"horizontal\"      android:layout_width=\"fill_parent\"      android:layout_height=\"fill_parent\"      android:layout_weight=\"1\"     >      <TextView          android:layout_width=\"wrap_content\"          android:layout_height=\"fill_parent\"          android:layout_weight=\"1\"          android:background=\"#aa0000\"          android:gravity=\"center\"          android:text=\"1\"/>      <TextView          android:layout_width=\"wrap_content\"          android:layout_height=\"fill_parent\"          android:layout_weight=\"2\"          android:background=\"#00aa00\"          android:gravity=\"center\"          android:text=\"1\"/>      <TextView          android:layout_width=\"wrap_content\"          android:layout_height=\"fill_parent\"          android:layout_weight=\"3\"          android:background=\"#0000aa\"          android:gravity=\"center\"          android:text=\"1\"/>  <\/LinearLayout> 效果如下： 可以看到这三个TextView是按照1:2:3的比例进行显示的，这样看来似乎可以实现按照比例显示了，但是有个问题，如果TextView内的文本长度一同那么较长文本的TextView会宽度会有所增加，见下面配置及效果： 配置：  <LinearLayout      android:orientation=\"horizontal\"      android:layout_width=\"fill_parent\"      android:layout_height=\"fill_parent\"      android:layout_weight=\"1\">      <TextView          android:layout_width=\"wrap_content\"          android:layout_height=\"fill_parent\"          android:layout_weight=\"1\"          android:background=\"#aa0000\"          android:gravity=\"center\"          android:text=\"1111111111111111111111111111111111111111111\"/>      <TextView          android:layout_width=\"wrap_content\"          android:layout_height=\"fill_parent\"          android:layout_weight=\"2\"          android:background=\"#00aa00\"          android:gravity=\"center\"          android:text=\"2\"/>      <TextView          android:layout_width=\"wrap_content\"          android:layout_height=\"fill_parent\"          android:layout_weight=\"3\"          android:background=\"#0000aa\"          android:gravity=\"center\"          android:text=\"3\"/>  <\/LinearLayout> 效果： 这样看来我们所需要的按比例又无法实现了，经过满天地google终于找到了解决方案，就是设置layout_width设置为\"wrap_content\"。配置及效果见下：  <LinearLayout      android:orientation=\"horizontal\"      android:layout_width=\"fill_parent\"      android:layout_height=\"fill_parent\"      android:layout_weight=\"1\">      <TextView          android:layout_width=\"0dp\"          android:layout_height=\"fill_parent\"          android:layout_weight=\"1\"          android:background=\"#aa0000\"          android:gravity=\"center\"          android:text=\"1111111111111111111111111111111111111111111\"/>      <TextView          android:layout_width=\"0dp\"          android:layout_height=\"fill_parent\"          android:layout_weight=\"2\"          android:background=\"#00aa00\"          android:gravity=\"center\"          android:text=\"2\"/>      <TextView          android:layout_width=\"0dp\"          android:layout_height=\"fill_parent\"          android:layout_weight=\"3\"          android:background=\"#0000aa\"          android:gravity=\"center\"          android:text=\"3\"/>  <\/LinearLayout> 效果： 这样终于达到我们的按比例显示的效果了，感觉很是奇怪，android开发框架的大佬们有时候设计确实有点匪夷所思。 　　二、LinearLayout内的控件的layout_width设置为\"fill_parent\"，请看一下xml配置：  <LinearLayout      android:orientation=\"horizontal\"      android:layout_width=\"fill_parent\"      android:layout_height=\"fill_parent\"      android:layout_weight=\"1\">      <TextView          android:layout_width=\"fill_parent\"          android:layout_height=\"fill_parent\"          android:layout_weight=\"1\"          android:background=\"#aa0000\"          android:gravity=\"center\"          android:text=\"1\"/>      <TextView          android:layout_width=\"fill_parent\"          android:layout_height=\"fill_parent\"          android:layout_weight=\"2\"          android:background=\"#00aa00\"          android:gravity=\"center\"          android:text=\"2\"/>  <\/LinearLayout> 效果如下： 奇怪吧，整个宽度平分3块，第一个TextView占了两块，这样看来weight值越小的优先级越大。只有两个TextView似乎看出些道理，那么让我们看看三个是什么效果： <LinearLayout      android:orientation=\"horizontal\"      android:layout_width=\"fill_parent\"      android:layout_height=\"fill_parent\"      android:layout_weight=\"1\">      <TextView          android:layout_width=\"fill_parent\"          android:layout_height=\"fill_parent\"          android:layout_weight=\"1\"          android:background=\"#aa0000\"          android:gravity=\"center\"          android:text=\"1\"/>      <TextView          android:layout_width=\"fill_parent\"          android:layout_height=\"fill_parent\"          android:layout_weight=\"2\"          android:background=\"#00aa00\"          android:gravity=\"center\"          android:text=\"2\"/>      <TextView          android:layout_width=\"fill_parent\"          android:layout_height=\"fill_parent\"          android:layout_weight=\"3\"          android:background=\"#0000aa\"          android:gravity=\"center\"          android:text=\"3\"/>  <\/LinearLayout> 效果： 什么意思？第三个TextView丢掉了，很是奇怪，让我们再试一个，把weight分别改为2,3,4的看看效果： 这个效果让人很困惑，我一直想寻求出一个确切的比例公式，但是至今未找到。有哪位大神能搞定的话忘不吝赐教。 虽然这个android:layout_weight属性很怪异，但幸运的是我们达到了目标： 　　按比例显示LinearLayout内各个子控件，需设置android:layout_width=\"0dp\"，如果为竖直方向的设置android:layout_height=\"0dp\"。在这种情况下某子个控件占用LinearLayout的比例为：本控件weight值 / LinearLayout内所有控件的weight值的和。 注：原文链接http://www.cnblogs.com/zhmore/archive/2011/11/04/2236514.html 祝：http://www.52hwz.com 成功励志","title":"layout_weight体验(实现按比例显示)"},{"content":"1。普通的Menu 　　先来看看最简单的Menu怎样实现。 　　在主Activity中覆盖onCreateOptionsMenu(Menu menu)方法。 代码 @Override    public boolean onCreateOptionsMenu(Menu menu) {        // TODO Auto-generated method stub        menu.add(0, 1, 1, \"苹果\");        menu.add(0, 2, 2, \"香蕉\");        return super.onCreateOptionsMenu(menu);    } 这样就有了两个菜单选项。如果要添加点击事件，则要覆盖onOptionsItemSelected(MenuItem item)方法。 代码 @Override    public boolean onOptionsItemSelected(MenuItem item) {        // TODO Auto-generated method stub        if(item.getItemId() == 1){            Toast t = Toast.makeText(this, \"你选的是苹果\", Toast.LENGTH_SHORT);            t.show();        }        else if(item.getItemId() == 2){            Toast t = Toast.makeText(this, \"你选的是香蕉\", Toast.LENGTH_SHORT);            t.show();        }         return true;    }   2。SubMenu 　　SubMenu的制作也同样简单，在第一段代码onCreateOptionsMenu(Menu menu)方法中加入几句，成下面这样： 代码 @Override    public boolean onCreateOptionsMenu(Menu menu) {        // TODO Auto-generated method stub        menu.add(0, 1, 1, \"苹果\");        menu.add(0, 2, 2, \"香蕉\");        SubMenu subMenu = menu.addSubMenu(1, 100, 100, \"桃子\");        subMenu.add(2, 101, 101, \"大桃子\");        subMenu.add(2, 102, 102, \"小桃子\");        return true;    } 点击“桃子”后就会出现子菜单，有两个子选项，分别是“大桃子”和“小桃子”。 3。Context Menu 　　类似于电脑上的右键，长按某个View之后弹出来的菜单。 　　首先在main.xml里定义若干个按钮。然后覆盖onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo)方法。里面的代码如下： 首先要注册一下，在onCreate方法里，如下代码： 代码 @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.main);        b1 = (Button) findViewById(R.id.b1);        b2 = (Button) findViewById(R.id.b2);        registerForContextMenu(b1);        registerForContextMenu(b2);    }   代码 @Override    public void onCreateContextMenu(ContextMenu menu, View v,            ContextMenuInfo menuInfo) {        // TODO Auto-generated method stub        if(v==b1){            menu.setHeaderTitle(\"这是1\");            menu.add(200, 200, 200, \"Context Menu 1\");            menu.add(200, 201, 201, \"Context Menu 2\");        }        else if(v==b2){            menu.setHeaderTitle(\"这是2\");            menu.add(300, 300, 300, \"C 1\");            menu.add(300, 301, 301, \"C 2\");        }        super.onCreateContextMenu(menu, v, menuInfo);    } 4。动态Menu 　　动态菜单就是根据不同的界面有不同的菜单。下面的代码实现这样的功能：当主界面的某个TextView的值是“M“和“N”时，弹出不同的菜单。 代码 @Override    public boolean onPrepareOptionsMenu(Menu menu) {        // TODO Auto-generated method stub        String currentText = tv1.getText().toString();        if(\"M\".equals(currentText)){            menu.clear();//先清掉菜单            MenuItem item = menu.add(0, 400, 401, \"to N\");//可以通过点击这个菜单项来改变tv1的值这样(变成N)就可以测试了            item.setIcon(android.R.drawable.alert_dark_frame);//android自带的图标        }        if(\"N\".equals(currentText)){            menu.clear();//先清掉菜单            MenuItem item = menu.add(0, 401, 402, \"to M\");//可以通过点击这个菜单项来改变tv1的值这样(变成M)就可以测试了            item.setIcon(android.R.drawable.alert_light_frame);        }        menu.add(0, 402, 403, \"Now is \" + currentText);//现在共有两个菜单子项        return super.onPrepareOptionsMenu(menu);    } 　　 5。用xml文件方式创建Menu 之前都是用代码的方法创建Menu,用xml配置文件也可以相当方便地制作菜单。 要res/目录下建一个文件夹，名为menu，下面建一个xml文件，名为menu_xml_file.xml，代码如下： 代码 <?xml version=\"1.0\" encoding=\"utf-8\"?><menu xmlns:android=\"http://schemas.android.com/apk/res/android\"><group android:id=\"@+id/grout_main\">    <item android:id=\"@+id/menu_1\"                android:title=\"This 1\"/>    <item android:id=\"@+id/menu_2\"             android:title=\"This 2\" /> <\/group><\/menu> 在Activity中覆盖onCreateOptionsMenu(Menu menu)方法，代码如下： 代码 @Override    public boolean onCreateOptionsMenu(Menu menu) {        // TODO Auto-generated method stub        MenuInflater inflater = getMenuInflater();        inflater.inflate(R.menu.menu_xml_file, menu);        return true;    } 其他的都和在Activity中制作菜单一样。","title":"android的Menu使用"},{"content":"上一篇写了TabActivity的基本用法，这节来讲诉TabActivity的界面定制。很多项目都需要重新设计标签的位置和样式，比如将标签放到下方，使用图片而不是文字来显示等等。 界面的结构 下面这幅图展示了TabActivity的结构： 其中，TabHost是根元素，其id为@android:id/tabhost，包含了TabWidget和TabContent。TabWidget就是标签所在的位置，id为@android:id/tabs；TabContent的id为@android:id/tabcontent，则是每个标签的内容，使用FrameLayout的布局，每次只显示一个子元素。 自定义布局 知道了界面的结构，我们只要定义一个类似的标签，将id设置好就行了。下面是一个示例： <?xml version=\"1.0\" encoding=\"utf-8\"?><TabHost xmlns:android=\"http://schemas.android.com/apk/res/android\"    android:id=\"@android:id/tabhost\"    android:layout_width=\"fill_parent\"    android:layout_height=\"fill_parent\"    android:background=\"@drawable/background\" >    <LinearLayout        android:orientation=\"vertical\"        android:layout_width=\"fill_parent\"        android:layout_height=\"fill_parent\"        android:padding=\"0dp\">       <FrameLayout            android:id=\"@android:id/tabcontent\"            android:layout_width=\"fill_parent\"            android:layout_height=\"wrap_content\"            android:padding=\"0dp\"            android:layout_weight=\"1\">        <\/FrameLayout>        <TabWidget            android:id=\"@android:id/tabs\"            android:layout_width=\"fill_parent\"            android:layout_height=\"wrap_content\"            android:layout_marginBottom=\"-4dp\"            android:layout_weight=\"0\"            android:background=\"@color/transparent\"             android:visibility=\"gone\"/>                <LinearLayout            android:layout_width=\"fill_parent\"            android:layout_height=\"wrap_content\"            android:layout_gravity=\"bottom|center_horizontal\"            android:gravity=\"bottom|center_horizontal\"            android:orientation=\"horizontal\" >            <ImageView                android:id=\"@+id/stopwatch_tabwidget_stopwatchTab\"                android:layout_width=\"wrap_content\"                android:layout_height=\"wrap_content\"                android:background=\"@color/transparent\"                android:clickable=\"true\"                android:scaleType=\"center\"                android:src=\"@drawable/stopwatch_sd\"                android:tag=\"stopwatch\" />            <ImageView                android:id=\"@+id/stopwatch_tabwidget_reviewTab\"                android:layout_width=\"wrap_content\"                android:layout_height=\"wrap_content\"                android:background=\"@color/transparent\"                android:clickable=\"true\"                android:scaleType=\"center\"                android:src=\"@drawable/review\"                android:tag=\"review\" />            <ImageView                android:id=\"@+id/stopwatch_tabwidget_chartTab\"                android:layout_width=\"wrap_content\"                android:layout_height=\"wrap_content\"                android:background=\"@color/transparent\"                android:clickable=\"true\"                android:scaleType=\"center\"                android:src=\"@drawable/chart\"                android:tag=\"chart\" />            <ImageView                android:id=\"@+id/stopwatch_tabwidget_cloudTab\"                android:layout_width=\"wrap_content\"                android:layout_height=\"wrap_content\"                android:background=\"@color/transparent\"                android:clickable=\"true\"                android:scaleType=\"center\"                android:src=\"@drawable/cloud\"                android:tag=\"cloud\" />            <ImageView                android:id=\"@+id/stopwatch_tabwidget_shareTab\"                android:layout_width=\"wrap_content\"                android:layout_height=\"wrap_content\"                android:background=\"@color/transparent\"                android:clickable=\"true\"                android:scaleType=\"center\"                android:src=\"@drawable/share\"                android:tag=\"share\" />        \t            <\/LinearLayout>    <\/LinearLayout><\/TabHost> 这个示例将标签一到下面，并且使用图片而不是文字来显示。 相应的Java代码 这里只显示对图片的设置。 \t\tfor (int i = 0; i < imageViews.size(); i++) {\t\t\tfinal int currentTabIndex = i;\t\t\timageViews.get(i).setOnClickListener(new View.OnClickListener() {\t\t\t\tpublic void onClick(View v) {\t\t\t\t\tswitchToTab(currentTabIndex);\t\t\t\t}\t\t\t});\t\t}即当图片被点击时，将会显示相应的标签。 显示效果","title":"Android下TabActivity的使用（2）"},{"content":"-optimizationpasses 5 -dontusemixedcaseclassnames 【混淆时不会产生形形色色的类名 】 -dontskipnonpubliclibraryclasses 【指定不去忽略非公共的库类。 】 -dontpreverify 【不预校验】 -verbose -optimizations !code/simplification/arithmetic,!field/*,!class/merging/* 【优化】 -keep public class * extends android.app.Activity　　【不进行混淆保持原样】 -keep public class * extends android.app.Application -keep public class * extends android.app.Service -keep public class * extends android.content.BroadcastReceiver -keep public class * extends android.content.ContentProvider -keep public class * extends android.app.backup.BackupAgentHelper -keep public class * extends android.preference.Preference -keep public class com.android.vending.licensing.ILicensingService -keep public abstract interface com.asqw.android.Listener{ public protected <methods>;  【所有方法不进行混淆】 } -keep public class com.asqw.android{ public void Start(java.lang.String); 【对该方法不进行混淆】 } -keepclasseswithmembernames class * { 【保护指定的类和类的成员的名称，如果所有指定的类成员出席（在压缩步骤之后）】 native <methods>; } -keepclasseswithmembers class * { 【保护指定的类和类的成员，但条件是所有指定的类和类成员是要存在。】 public <init>(android.content.Context, android.util.AttributeSet); } -keepclasseswithmembers class * { public <init>(android.content.Context, android.util.AttributeSet, int); } -keepclassmembers class * extends android.app.Activity {【保护指定类的成员，如果此类受到保护他们会保护的更好 】 public void *(android.view.View); } -keepclassmembers enum * { public static **[] values(); public static ** valueOf(java.lang.String); } -keep class * implements android.os.Parcelable {【保护指定的类文件和类的成员】 public static final android.os.Parcelable$Creator *; } 参考：http://blog.csdn.net/vrix/article/details/7100841 加入第三方jar包之后常出现的几个异常： proguard returned with error code 1.See console 情况1： Proguard returned with error code 1. See console  Error: C:/Documents (系统找不到指定文件)  后来发现是因为将整个工程放到了桌面上，而桌面的目录是C:/Documents and Settings/Administrator/桌面，在这里面有空格，而proguard进行发编译的时候是不允许有空格的 如果换了正确路径还不好用的话，直接删除proguard就好了 注意：SDK和程序路径最好不要有空格符 情况2： Proguard returned with error code 1. See console  异常： java.lang.ArrayIndexOutOfBoundsException 解决办法：将proguard.cfg中的\"-dontpreverify\"改成“-dontoptimize” 参考文章：http://groups.google.com/group/android-developers/browse_thread/thread/eca3b0f5ce6ad00f 我把项目中生成的proguard文件夹（此时文件夹是空的）删掉，然后再重新运行项目，就OK 了。   情况3：  第三方jar的引用路径不对，没有找到这个需要忽略混淆的jar包。 参考：http://stackoverflow.com/questions/4884456/android-proguard-java-io-ioexception-cant-read-proguard-classpathentry","title":"android混淆proguard.cfg详解"},{"content":"现如今还是菜菜，如若有错误的地方还望指正！ 如若转载，请注明源地址：http://blog.csdn.net/shinilaobababa/article/details/8453434 首先还是来一句OC中的内存管理的黄金法则比较好       如果对一个对象使用了alloc、[Mutable]copy，retain，那么你必须使用相应的realease或者autorelease。（黄金法则就应该有金黄色的背景来衬托） Objective-C的内存管理机制是比较灵活的，即可以完全的手动进行内存的管理，也可以用AutoreleasePool让它升级为半自动化的内存管理模式 1、cocoa中的内存管理机制——引用计数       引用计数（reference counting）又称为保留计数（retain counting），引用计数的数值表示有几个其它对象在使用它。 每一个对象都拥有一个引用计数         当对象被创建的时候，引用计数的值为1         当发送retain消息的时候，该对象的引用计数加1，该对象的引用计数为2         当这个对象发送release消息的时候，该对象的引用计数减1         当一个对象的引用计数为0时，系统自动调用dealloc方法，销毁该对象。 Dog *dog = [[Dog alloc]init];//此时引用计数为1NSLog(@\"  %d\",[dog retainCount]);[dog retain];//引用计数变成2[dog release];//引用计数变成1[dog release];//引用计数变成0，系统会自动调用dealloc方法，销毁对象，回收内存 引用计数是实例对象的内存回收唯一参考 引用计数(retainCount)是Objective-C管理对象引用的唯一依据。调用实例的release方法后，此属性减一，减到为零时对象的dealloc方法被自动调用，进行内存回收操作，也就是说我们永不该手动调用对象的dealloc方法。 关于dealloc方法        它的作用是，当对象的引用计数为0时，系统会自动调用dealloc方法，回收内存，它的一般写法为： -（void）dealloc                                                   -(void)dealloc {                                                                                {        [super  dealloc];                                                     [person release]; }                                                                                       [super dealloc];                                                                                   } 在这里为什么要调用父类的dealloc方法呢            子类的某些实例是继承自父类的，因此，我们需要调用父类的dealloc方法，来释放父类拥有的这些对象。 一般来说调用的顺序是，当子类的对象释放完时，然后再释放父类的所拥有的实例，这一点与调用初始化方法，正好相反。 2、对象所有权       当一个所有者（可以是任何一个OC对象）做了以下某个动作的时候，它就拥有了对一个对象的所有权。       （1）如果创建或者复制某个对象时，则拥有了该对象的所有权,即包含下列关键词时：                alloc，allocWithZone：，copy，copyWithZone：，mutableCopy，mutableCopyWithZone：       （2）如果没有创建或复制对象，而是保留引用，同样拥有该对象的使用权               retain       （3）当拥有了某个对象的所有权，在不需要某一个对象时，需要释放他们，用              release，autoRelease 3、自动释放池的相关用法         （1）cocoa中的自动释放池（Autorelease pool），是能够自动释放赤忠的对象的。NSObject类提供了一个autorelease消息，当我们想一个对象发送autorelease消息的时候，这个对象就会随着释放池的销毁而释放。如果要向使用使用自动释放池释放对象，我们首先要有一个入池操作： //创建自动释放池@autoreleasepool {            //入池对象5.0之后的写法            } NSAutoreleasePool *pool = [[NSAutoreleasePool alloc]init];   //入池对象5.0之前写法[pool release]; 自动释放池是以栈的形式实现的，当某个对象调用了autorelease方法时，该对象会被加入自动释放池的栈顶。对于发送了autorelease消息的对象，当自动释放池销毁时，自动释放池会对这些对象发送一条release消息，来释放他们。         （2）向自动释放池发送release及drain消息的区别            当我们向自动释放池pool发送release消息时，它会向池中的每一个发送了autorelease消息的对象发送一条release消息，并且自身也会销毁。当向它发送drain消息时，只会释放里面吧的对象，而不会销毁自己。 4、关于ARC（Auto reference counting）自动引用计数                  当你在编译程序的时候提供自动管理内存的功能，它会自动加入内存的控制代码，控制对象的生命周期，大大简化了内存管理的步骤，ARC管理内容的原理就是，编译器会在适当的地方自动插入retain、release和autorelease消息，但是注意版本，是在ios4及以上（不是很确定）。要使用此方法，可以在Xcode中创建项目时勾选，如图 如图： 在新建MAC的命令行程序时： 当在创建IOS工程时： 5、垃圾回收机制        类似与java中的垃圾回收机制，Objective-c在2.0以后也提供了垃圾回收机制，但是在IOS 中并不支持。但是我们要明白的是垃圾回收机制并不是ARC，ARC也是需要管理内存的，只不过是隐式的管理内存","title":"[置顶] Objective-c中的内存管理的黄金法则，OC中最重要的部分"},{"content":"NSString *path = [[NSBundle mainBundle] pathForResource:nameString ofType:@\"mp3\"];       if ([path length]>0)     {         //有这个文件     }    else    {        //没有有这个文件    }     ","title":"判断NSBundle本地是否包含有某个文件"},{"content":"最近在调试android串口使用，做下笔记。 Google给出了个Demo，网址: http://code.google.com/p/android-serialport-api/  ，这里可以下到APK及对应的源码。上面还有些开发者的提问及问题反馈。 以下是我使用过程中遇到的，也是很多开发者遇到的问题，希望对后来者有帮助。 Bug: java.lang.ClassCastException: android.app.Application Fixed: 运行时会出现类型转换异常，子类转换为父类，所以报错 在AndroidManifest.xml中配置： <application  android:name=\".XxxApplication\"         android:icon=\"@drawable/ic_launcher\"         android:label=\"@string/app_name\"> ........ <\/application> Bug:串口读写权限问题，提示 You do not have read/write permission to the serial port Fixed: 这里提供两种方法 方法一，修改系统启动初始化文件*.rc 针对target版(MTK平台)，可以在mediatek/config/$ProjectName/init.project.rc文件后面添加     chmod 0777 /dev/ttyMT1 针对模拟器版本有2种办法，     1.模拟器启动后用adb操作修改权限             # adb remount             # adb shell             # chmod 0777 /dev/ttyS0          此种方法的一个很大弊端，每次启动后都要去修改。     2. 修改 ramdisk.img          不同的SDK版本，路径不同，像Android 2.3.3的位于$SDK_ROOT/platforms/android-10/images/ramdisk.img, 而Android 4.0.3的位于$SDK_ROOT/system-images/android-15/armeabi-v7a/ramdisk.img。           解压出ramdisk.img后在根目录下有个ueventd.goldfish.rc文件，里面有如下内容:           # These settings are specific to running under the Android emulator           /dev/qemu_trace           0666   system     system           /dev/qemu_pipe            0666   system     system           /dev/ttyS*                      0666  system    system           /proc                             0666   system     system         各项含义对应如下：目录    权限    user     group         修改红色项为：/dev/ttyS*    0777   nobody    nobody         如果ueventd.goldfish.rc为空的，在该文件添加  /dev/ttyS*    0777   nobody    nobody   即可，保存后，重新压缩生成ramdisk.img。这样就无需每次都去修改串口权限了。ttyS0, ttyS1, ttyS2 都可以读写了。 注：不妨去看看以下两篇文章，可能对为什么如此修改有帮助         http://blog.csdn.net/wavemcu/article/details/7820070         http://www.cnblogs.com/idiottiger/archive/2012/05/23/2513494.html 解压缩ramdisk.img的方法，如下: ----------------------------------------------------------------------------------------------------------------------------          增加后缀.gz,执行 gzip -d ramdisk.img.gz          mkdir ramdisk          cd ramdisk          cpio -i -d < ../ramdisk.img #解开上层目录中的ramdisk.img          修改后压缩：          find . | cpio -o -H newc > ../myramdisk.img #打包当前目录中的所有目录和文件，到上层目录中的myramdisk.img          cd .. #回到上层目录          gzip -9 myramdisk.img #gzip的最高级压缩          将生成的文件去掉后缀.gz即可 ----------------------------------------------------------------------------------------------------------------------------- 方法二，遵循Google serial port demo里的写法，通过执行su获取修改串口读写权限。         1. 需修改/system/extras/su/su.c,屏蔽这段代码                 if (myuid != AID_ROOT && myuid != AID_SHELL) {                      fprintf(stderr,\"su: uid %d not allowed to su\\n\", myuid);                      return 1;                 }         2.在AndroidManifest.xml中配置android:sharedUserId=\"android.uid.system\"，         在对应的Android.mk中添加LOCAL_CERTIFICATE := platform这一项。         这时如果是独立的apk，安装时会报错，信息如下         Installation error: INSTALL_FAILED_SHARED_USER_INCOMPATIBLE         Please check logcat output for more details.         Launch canceled!         这个需要将apk内置，即直接编译到system.img，怎么在系统中内置带源码的apk这里就不写了。 如果发送或者接收数据有问题，确认以下几项：          1.确认串口号，波特率，校验方式，停止位等所需的设置是否正确          2.短接TX和RX看是否可以进行自发自收          3.如果是连接电脑通过串口调试工具/超级终端调试，请确认串口线是否可以正常接收，发送数据。可以短接，看能不能自发自收。 我自个写的测试程序，可以在我的资源中下载：http://download.csdn.net/detail/jerome_home/4944000 程序界面如下： 你也可以根据自己的需要，将程序改成Service，或者用JNI方式实现，生成so库文件供第三方使用。","title":"Android之串口(serial port)"},{"content":"转载请注明出处，原文网址：http://blog.csdn.net/m_changgong/article/details/8435094 作者：张燕广 实现的功能：1）演示使用CoreData持久化数据（仅显示基本操作，不包括很多复杂的操作）。 关键词：数据持久化 CoreData 1、新建一空工程，命名为：Persistence_CoreData： 2、选中“Use Core Data”后创建的工程中，AppDelegate.h中多了三个property，如下： #import <UIKit/UIKit.h>@interface AppDelegate : UIResponder <UIApplicationDelegate>@property (strong, nonatomic) UIWindow *window;//备注1@property (readonly, strong, nonatomic) NSManagedObjectContext *managedObjectContext;@property (readonly, strong, nonatomic) NSManagedObjectModel *managedObjectModel;@property (readonly, strong, nonatomic) NSPersistentStoreCoordinator *persistentStoreCoordinator;- (void)saveContext;- (NSURL *)applicationDocumentsDirectory;@end 代码解释 //备注1 NSManagedObjectContext：相当于数据库操作 NSManagedObjectModel：相当于数据库中的表及它们之间的关系 persistentStoreCoordinator：相当于数据库存放方式 以上比较不一定准确，但是可以更容易理解CoreData的应用。 3、AppDelegate.m中多了三个方法，如下： #import \"AppDelegate.h\"#import \"ViewController.h\"@implementation AppDelegate@synthesize managedObjectContext = _managedObjectContext;@synthesize managedObjectModel = _managedObjectModel;@synthesize persistentStoreCoordinator = _persistentStoreCoordinator;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions{    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];    // Override point for customization after application launch.    //设置根视图控制器    self.window.rootViewController = [[ViewController alloc]initWithNibName:@\"ViewController\" bundle:nil];    self.window.backgroundColor = [UIColor whiteColor];    [self.window makeKeyAndVisible];    return YES;}- (void)applicationWillResignActive:(UIApplication *)application{    // Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.    // Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.}- (void)applicationDidEnterBackground:(UIApplication *)application{    // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later.     // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.}- (void)applicationWillEnterForeground:(UIApplication *)application{    // Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.}- (void)applicationDidBecomeActive:(UIApplication *)application{    // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.}- (void)applicationWillTerminate:(UIApplication *)application{    // Saves changes in the application's managed object context before the application terminates.    [self saveContext];}- (void)saveContext{    NSError *error = nil;    NSManagedObjectContext *managedObjectContext = self.managedObjectContext;    if (managedObjectContext != nil) {        if ([managedObjectContext hasChanges] && ![managedObjectContext save:&error]) {             // Replace this implementation with code to handle the error appropriately.             // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.             NSLog(@\"Unresolved error %@, %@\", error, [error userInfo]);            abort();        }     }}//备注2 #pragma mark - Core Data stack// Returns the managed object context for the application.// If the context doesn't already exist, it is created and bound to the persistent store coordinator for the application.- (NSManagedObjectContext *)managedObjectContext{    if (_managedObjectContext != nil) {        return _managedObjectContext;    }        NSPersistentStoreCoordinator *coordinator = [self persistentStoreCoordinator];    if (coordinator != nil) {        _managedObjectContext = [[NSManagedObjectContext alloc] init];        [_managedObjectContext setPersistentStoreCoordinator:coordinator];    }    return _managedObjectContext;}// Returns the managed object model for the application.// If the model doesn't already exist, it is created from the application's model.- (NSManagedObjectModel *)managedObjectModel{    if (_managedObjectModel != nil) {        return _managedObjectModel;    }    NSURL *modelURL = [[NSBundle mainBundle] URLForResource:@\"Persistence_CoreData\" withExtension:@\"momd\"];    _managedObjectModel = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL];    return _managedObjectModel;}// Returns the persistent store coordinator for the application.// If the coordinator doesn't already exist, it is created and the application's store added to it.- (NSPersistentStoreCoordinator *)persistentStoreCoordinator{    if (_persistentStoreCoordinator != nil) {        return _persistentStoreCoordinator;    }        NSURL *storeURL = [[self applicationDocumentsDirectory] URLByAppendingPathComponent:@\"Persistence_CoreData.sqlite\"];        NSError *error = nil;    _persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:[self managedObjectModel]];    if (![_persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:storeURL options:nil error:&error]) {        /*         Replace this implementation with code to handle the error appropriately.                  abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.                   Typical reasons for an error here include:         * The persistent store is not accessible;         * The schema for the persistent store is incompatible with current managed object model.         Check the error message to determine what the actual problem was.                           If the persistent store is not accessible, there is typically something wrong with the file path. Often, a file URL is pointing into the application's resources directory instead of a writeable directory.                  If you encounter schema incompatibility errors during development, you can reduce their frequency by:         * Simply deleting the existing store:         [[NSFileManager defaultManager] removeItemAtURL:storeURL error:nil]                  * Performing automatic lightweight migration by passing the following dictionary as the options parameter:         @{NSMigratePersistentStoresAutomaticallyOption:@YES, NSInferMappingModelAutomaticallyOption:@YES}                  Lightweight migration will only work for a limited set of schema changes; consult \"Core Data Model Versioning and Data Migration Programming Guide\" for details.                  */        NSLog(@\"Unresolved error %@, %@\", error, [error userInfo]);        abort();    }            return _persistentStoreCoordinator;}#pragma mark - Application's Documents directory// Returns the URL to the application's Documents directory.- (NSURL *)applicationDocumentsDirectory{    return [[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask] lastObject];}@end //备注2 //这三个方法，对应返回备注1中声明的3个变量 4、新建视图控制器ViewController（带xib） 修改AppDelegate.m中- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions 设置根视图控制器 5、修改ViewController.xib，如下： 6、修改Persistence_CoreData.xcdatamodeld，添加Entity，名称为User，如下 7、修改ViewController，ViewController.h如下： #import <UIKit/UIKit.h>#import \"AppDelegate.h\"@interface ViewController : UIViewController{    AppDelegate *appDelegate;}@property(strong,nonatomic)IBOutlet UITextField *serverIp;@property(strong,nonatomic)IBOutlet UITextField *userName;@end ViewController.m如下： #import \"ViewController.h\"#import \"AppDelegate.h\"@interface ViewController ()@end@implementation ViewController- (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil{    self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil];    if (self) {        // Custom initialization    }    return self;}- (void)viewDidLoad{    [super viewDidLoad];    // Do any additional setup after loading the view from its nib.        //获取App代理    appDelegate = [[UIApplication sharedApplication] delegate];        //订阅通知    UIApplication *app = [UIApplication sharedApplication];    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationWillResignActive:) name:UIApplicationWillResignActiveNotification object:app];        [self loadData];}//加载数据-(void)loadData{    //1)获取托管对象上下文（相当于数据库操作）    NSManagedObjectContext *context = [appDelegate managedObjectContext];//备注3    //2)创建NSFetchRequest对象（相当于数据库中的SQL语句）    NSFetchRequest *request = [[NSFetchRequest alloc] init];    //3)创建查询实体（相当于数据库中要查询的表）    NSEntityDescription *entityDescription = [NSEntityDescription entityForName:@\"User\" inManagedObjectContext:context];    //设置查询实体    [request setEntity:entityDescription];    //4)创建排序描述符,ascending：是否升序（相当于数据库中排序设置）。此处仅为演示，本实例不需要排序    NSSortDescriptor *sortDiscriptor = [[NSSortDescriptor alloc] initWithKey:@\"userName\" ascending:NO];    NSArray *sortDiscriptos = [[NSArray alloc] initWithObjects:sortDiscriptor, nil];    [request setSortDescriptors:sortDiscriptos];    //5)创建查询谓词（相当于数据库中查询条件） 此处仅为演示，本实例不需要查询条件    NSPredicate *pred = [NSPredicate predicateWithFormat:@\"(serverIp like %@)\",@\"192\"];    [request setPredicate:pred];        NSError *error;    NSArray *objects = [context executeFetchRequest:request error:&error];    if(objects == nil){        NSLog(@\"There has a error!\");        //做错误处理    }else{        if([objects count]>0){            NSManagedObject *oneObject = [objects objectAtIndex:0];            NSString *serverIp = [oneObject valueForKey:@\"serverIp\"];            NSString *userName = [oneObject valueForKey:@\"userName\"];            self.serverIp.text = serverIp;            self.userName.text = userName;        }        }}//应用界面退出时，保存数据-(void)applicationWillResignActive:(NSNotification *)notification{    NSLog(@\"applicationWillResignActive\");    //创建托管对象上下文    NSManagedObjectContext *context = [appDelegate managedObjectContext];    NSFetchRequest *request = [[NSFetchRequest alloc]init];    NSEntityDescription *entityDescription = [NSEntityDescription entityForName:@\"User\" inManagedObjectContext:context];    [request setEntity:entityDescription];        NSManagedObject *user = nil;    NSError *error;    NSArray *objets = [context executeFetchRequest:request error:&error];    if(objets==nil){        NSLog(@\"There has a error!\");        //做错误处理    }        if([objets count]>0){        //非第一次，更新数据        NSLog(@\"更新操作\");        user = [objets objectAtIndex:0];    }else{        NSLog(@\"插入操作\");        //第一次保存，插入新数据        user = [NSEntityDescription insertNewObjectForEntityForName:@\"User\" inManagedObjectContext:context];    }        [user setValue:self.serverIp.text forKeyPath:@\"serverIp\"];    [user setValue:self.userName.text forKeyPath:@\"userName\"];        [context save:&error];}- (void)didReceiveMemoryWarning{    [super didReceiveMemoryWarning];    // Dispose of any resources that can be recreated.}@end //备注3 //通过 delegate调用方法managedObjectContext，得到NSManagedObjectContext对象， //NSManagedObjectContext对象会跟NSPersistentStoreCoordinator对象交互，NSPersistentStoreCoordinator对象负责处理底层的存储，sqlite3数据库名称默认为工程名称,Persistence_CoreData.sqlite 8、CoreData使用的数据库存储的位置是： /Users/duobianxing/Library/Application Support/iPhone Simulator/5.0/Applications/BCCE1DDC-F50F-4A52-9678-991AC6DFBC7C/Documents 虽然该博文演示的创建“Use Core Data”的工程，其实只要搞明白选中“Use Core Data”后该工程模板都添加了哪些内容以及其作用？那么在一个已存在的工程（没有使用CorData）的加入CoreData的支持也非常方便。 下一篇将IOS中5种数据持久化的技术稍作对比，做个小结。","title":"iPhone开发【二十六】数据持久化总结之第5篇—CoreData技术"},{"content":"第一种：      WebSetting settings = webView.getSettings();      settings.setLayoutAlgorithm(LayoutAlgorithm.SINGLE_COLUMN);      把所有内容放在webview等宽的一列中。（可能会出现页面中链接失效） 第二种：      settings.setUseWideViewPort(true);      settings.setLoadWithOverviewMode(true); 第三种：      DisplayMetrics metrics = new DisplayMetrics();      getWindowManager().getDefaultDisplay().getMetrics(metrics);      int mDensity = metrics.densityDpi;      if (mDensity == 120) {                settings.setDefaultZoom(ZoomDensity.CLOSE);           }else if (mDensity == 160) {                settings.setDefaultZoom(ZoomDensity.MEDIUM);           }else if (mDensity == 240) {                settings.setDefaultZoom(ZoomDensity.FAR);           }","title":"Android中Webview自适应屏幕"},{"content":"<ScrollView            android:layout_width=\"fill_parent\"            android:layout_height=\"wrap_content\"            android:layout_alignParentBottom=\"true\"            android:layout_alignParentTop=\"true\"            android:layout_marginBottom=\"50dp\"            android:scrollbars=\"vertical\"             >            <HorizontalScrollView                android:layout_width=\"fill_parent\"                android:layout_height=\"fill_parent\"                android:orientation=\"horizontal\"                android:layout_gravity=\"center_horizontal\" >                <LinearLayout                    android:id=\"@+id/allnum\"                    android:layout_width=\"fill_parent\"                    android:layout_height=\"wrap_content\"                    android:gravity=\"center\"                    android:layout_gravity=\"center\"                    android:orientation=\"vertical\" >                <\/LinearLayout>            <\/HorizontalScrollView>        <\/ScrollView>","title":"Android ScrollViewy与HorizontalScrollView实现上下左右滚动"},{"content":"在Windows mobile系统中，用户可以通过设置来访问控制面板的应用程序，软件开发人员也可以通过Windows mobile提供的API函数来访问控制面板的一些信息，例如可以向其中增加一个控制面板的应用。   控制面板应用程序实现为一个Dll中，但必须以cpl为后缀，它导出一个回调函数： LONG CPlApplet(HWND hwndCPl, UINT msg, LPARAM lParam1, LPARAM lParam2); 在用户点击设置时，ctlpnl.exe进程会通过调用CPlApplet来发送一些消息，一个cpl可以支持多个控制面板的小程序（applets）： hwndCPl：控制面板窗口句柄，即是小程序的父窗口。 Msg：控制面板程序（ctlpnl.exe）向我们的应用程序发送的消息，这些消息决定了应用程序初始化、启动、停止、退出，主要包括： CPL_INIT、CPL_GETCOUNT、CPL_NEWINQUIRE、CPL_IDNAME、CPL_DBLCLK、CPL_STOP、CPL_EXIT。 CPL_INIT：初始化消息，即ctlpnl.exe通知控制面板应用程序做一些全局的初始化工作，如内存分配。 CPL_GETCOUNT：获取控制面板应用程序支持的小程序个数。 CPL_NEWINQUIRE：查询控制面板应用程序的小程序的信息。这些信息包含在NEWCPLINFO结构中。 CPL_IDNAME：获得控制面板应用程序的名称，通过设置下面的注册表键值可以改变应用位于控制面板属性页的位置。   [HKEY_LOCAL_MACHINE/ControlPanel/<ID name>]. \"Group\" = dword:1 Group value Settings tab where CPL exists 0 Personal 1 (default value) System 2 Connections CPL_DBLCLK：此消息表明用户点击了控制面板应用，可以在此启动一个进程，进而完成相应的工作。 CPL_STOP、CPL_EXIT：分别是停止和退出消息。 下面给出一个简单的实例: 首先建立一个Smart Device的Win32 Smart Device Project DLL工程， 加入下面的代码：   // TestCPL.cpp : Defines the entry point for the DLL application. #include \"stdafx.h\" #include <cpl.h> #define NUM_APPLETS                1 HINSTANCE g_hInstance   = NULL; typedef struct tagApplets {     int icon;           // icon resource identifier     int namestring;     // name-string resource identifier     int descstring;     // description-string resource identifier } APPLETS; const APPLETS SystemApplets[] = {     APPLET_ICON, APPLET_NAME, APPLET_DESC     // add more struct members here if supporting more than on applet }; BOOL APIENTRY DllMain( HANDLE hModule,                     DWORD ul_reason_for_call,                     LPVOID lpReserved                     ) {     if (DLL_PROCESS_ATTACH == ul_reason_for_call)        g_hInstance = (HINSTANCE)hModule;     return TRUE; } BOOL InitApplet(HWND hwndParent) {    return TRUE; } void TermApplet() {     return; } //////////////////////////////////////////////////////// // This is the entry point called by ctlpnl.exe //////////////////////////////////////////////////////// LONG CALLBACK CPlApplet (HWND hwndCPL, UINT uMsg, LONG lParam1, LONG lParam2) {     int           iApplet;     LPNEWCPLINFO lpNewCPlInfo;     static int    iInitCount = 0;     switch (uMsg)     {        // First message sent. It is sent only once to        // allow the dll to initialize it's applet(s)     case CPL_INIT:        if (!iInitCount)        {            if (!InitApplet(hwndCPL))               return FALSE;        }        iInitCount++;        return TRUE;        // Second message sent. Return the count of applets supported        // by this dll     case CPL_GETCOUNT:        return (LONG)NUM_APPLETS;        // Third message sent. Sent once for each applet supported by this dll.        // The lParam1 contains the number that indicates which applet this is        // for, from 0 to 1 less than the count of applets.        // lParam2 is a NEWCPLINFO that should be filled with information about        // this applet before returning     case CPL_NEWINQUIRE:        lpNewCPlInfo             = (LPNEWCPLINFO)lParam2;        iApplet                     = (int)lParam1;        lpNewCPlInfo->dwSize     = (DWORD)sizeof(NEWCPLINFO);        lpNewCPlInfo->dwFlags       = 0;        lpNewCPlInfo->dwHelpContext = 0;        lpNewCPlInfo->lData         = SystemApplets[iApplet].icon;        lpNewCPlInfo->hIcon         = LoadIcon(g_hInstance,(LPCTSTR)MAKEINTRESOURCE(SystemApplets[iApplet].icon));        lpNewCPlInfo->szHelpFile[0] = '/0';        LoadString(g_hInstance,SystemApplets[iApplet].namestring,lpNewCPlInfo->szName,32);        LoadString(g_hInstance,SystemApplets[iApplet].descstring,lpNewCPlInfo->szInfo,64);        break;     case CPL_IDNAME:        _tcscpy((LPWSTR)lParam2, _T(\"Device Information\"));        break;        // This is sent whenever the user clicks an icon in Settings for one of        // the applets supported by this dll. lParam1 contains the number indicating        // which applet. Return 0 if applet successfully launched, non-zero otherwise     case CPL_DBLCLK:        iApplet = (UINT)lParam1;        //LoadDialog(g_hInstance, hwndCPL); CreateProcess(_T(\"DeviceInfo.exe\"),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);        break;        // Sent once per applet, before CPL_EXIT     case CPL_STOP:        break;        // Sent once before the dll is unloaded     case CPL_EXIT:        iInitCount--;        if (!iInitCount)            TermApplet();        break;     default:        break;     }     return 0; } //TestCPL.def LIBRARY    \"TestCPL\" EXPORTS DllMain        CPlApplet 另外,添加注册表键值，如下： [HKEY_LOCAL_MACHINE/ControlPanel/ Device Information]. \"Group\" = dword:1   下面是摘自另外一篇文章，作为补充：     默认工程生成的是dll，而希望生成的是Control Panel (.cpl) files，需要做如下配置： 1.myBackLight (工程名)右键—〉Properties—〉Configuration Properties—〉Debugging。 Linker—〉General—〉Output File设置为$(OutDir)/myBacklight.cpl（即把后缀dll改成cpl） 2.Remote Executable设置为 \"/Windows/ctlpnl.exe\"；Command Arguments设置为 \"myBackLight.cpl\"。 （可以不设，但通过这个可以加深对cpl程序的理解）     配置完成，新增的AP图标添加到Setting—〉System中，如果需要指定图片到Personal或Connection中，需要在CPlApplet处理CPL_IDNAME消息，主要是设置注册表中的Group值，0 -- Personal， 1 -- System（默认）， 2 -- Connection。 上面的程序写注册表是在reg文件（比如platform.reg)中直接改，这里是写在程序里，我只试过前一种，下面这种做参考。          case CPL_IDNAME:              {              UINT uApp = lParam1;              LPWSTR pszName = (LPTSTR)lParam2;              TCHAR szKey[100];               _tcscpy(pszName, TEXT(\"myBacklight\"));               swprintf(szKey, L\"ControlPanel//%s\", pszName);                   DWORD dwSize = sizeof(DWORD);              HKEY hKey;              DWORD dwDisp;              DWORD dwGroup;              dwGroup = 0;              RegCreateKeyExW(HKEY_LOCAL_MACHINE, szKey, 0, NULL, 0, KEY_ALL_ACCESS, NULL, &hKey, &dwDisp);              RegSetValueExW(hKey, L\"Group\", 0, REG_DWORD, (LPBYTE)&dwGroup, sizeof(DWORD));              return 0;             } —————————————————————————————————————————————————— 补充： 1. windows mobile 6 sdk 里有个例子叫mybacklight，代码可以参考那里面的。 2. 绝大多数代码是不用改的，只要更改有： （1）在项目属性里将Output Files后缀dll 改成cpl （2）CPL_DBLCLK下的 （3）CPL_IDNAME下的 （4）注册表项。来确定你的cpl程序出现的位置。 [HKEY_LOCAL_MACHINE/ControlPanel/ Device Information]. \"Group\" = dword:1 3. 刚开始的时候对cpl程序出现的位置怎么设置理解错误，以为只要设置注册表就可以了。 而实际上，设置注册表只是其中一步，还有一步便是处理CPL_IDNAME消息， 该消息下来设置控制面板小程序的名称，这个名称可以不跟程序本身的名称相同， 但必须跟注册表里设置的名字相同，这便是程序跟注册表里的设置联系的纽带。   4. 样例的cpl.h文件中没有定义CPL_IDNAME，在里面加上如下语句便可以了： #define CPL_IDNAME 100","title":"Windows mobile添加控制面板程序"},{"content":"方法1：用工具直接获取 iPhone 设备上 var/mobile/Library/Logs/CrashReporter  中的 Crash 报告文件。（Mac 下用 PhoneView/iTools/iExplorer，Windows下用、iFunBox、iTools、91助手等）。 方法2：如果 iTunes 同步，则同步后Crash日志会同步到电脑上，把以下目录中的Crash提取打包即可： Mac OS X：~/Library/Logs/CrashReporter/MobileDevice Windows XP：C:\\Documents and Settings\\Application Data\\Apple computer\\Logs\\CrashReporter Windows 7/Vista: C:\\Users\\AppData\\Roaming\\Apple computer\\Logs\\CrashReporter/MobileDevice/","title":"非开发人员获取ios crashlog方法"},{"content":"前几章参考： 1-引言 2-Objective-C 编程 3-类、对象和方法 4-数据类型和表达式 5-循环结构 6-选择结构 7-类 8-继承 多态这个其它语言也有。动态类型有类似的，但不完全相同。动态绑定别的语言也有类似，但没有objective-c用的这么多。 红色部分你就能看出这三个概念最终针对的是什么东西： 多态能够使来自不同类的对象定义相同名称的方法。 动态类型能使程序直到执行时才确定对象所属的类。 动态绑定则能使程序直到执行时才确定实际要调用的对象方法。 多态：相同的名称，不同的类 系统总是携带有关“一个对象属于哪个类”这样的信息。该信息能使系统在运行时做出这些关键性的决定，而不是在编译时。 使不同的类共享相同方法名称的能力称为多态。 动态绑定和id类型： id dataValue； 变量dataValue被声明为id对象类型。因此，dataValue可用来保存程序中任何类型的对象。务必注意，声明中并没有使用星号。 id数据类型和静态类型： 不要养成滥用id这种通用数据类型的习惯。下面告诉你为什么要使用静态类型： 1）将一个变量定义为特定类的对象时，使用的是静态类型。“静态”指的是对存储在变量中对象的类型进行显示声明。这样存储在这种形态中的对象的类是预定义的，也就是静态的。使用静态类型时，编译尽可能确保变量的用法在程序中始终保持一致。编译器能够通过检查来确定应用于对象的方法是由该类定义的还是由该类继承的，否则它将显示警告信息。 2）使用静态类型的另一个原因是它能够提高程序的可读性。 动态类型的参数和返回类型： 如何使用动态类型来调用一个方法，需要注意如下规则：如果在多个类中实现名称相同的方法，那么每个方法都必须符合各个参数的类型和返回值类型。这样编译器才能为消息表达式生成正确的代码。编译器会对它所遇到的每个类声明执行一致性检查。 当一个方法选取对象作为它的参数，而另一个方法选取浮点数作为参数时，或者一个方法以对象作为返回值，而另一个以整型数作为返回值。编译器可能生成不正确的代码来向方法传递参数或处理返回值。 处理动态类型的方法： -(BOOL) isKindOf:class-object（判断对象是否是class-object或其子类的成员）   -(BOOL) isMenberOfClass:class-object（判断对象是否是class-object的成员）   -(BOOL) respondsToSelector:selector（判断对象是否能够响应selector所指定的方法）   +(BOOL) instancesRespondToSelector:selector（判断指定的类实例是否能响应selector所指定的方法）   +(BOOL) isSubclassOfClass:class-object（判断对象是否是指定类的子类）   -(id) performSelector:selector（应用selector指定的方法）   -(id) performSelector:selector withObject:object（应用selector指定的方法，传递参数object）    -(id) performSelector:selector withObject:object1 withObject:object2（应用selector指定的方法，传递参数object1和object2 可以对一个方法名应用@selector指令。例如：@selector （alloc）为名为alloc的方法生成一个SEL类型的值，该方法是从NSObject类继承的。 记住，测试包含继承的方法，并不是只测试直接定义在类中的方法。 performSelector：方法和它的变体允许你向对象发送消息，这个消息可以是存储在变量中的selector。 在iOS中，respondsToSelector：方法广泛用于实现委托（delegation）的概念。为了让系统能够检查你确实实现了特定的方法，使用respondsToSelector：判断是否可以将事件的处理委托给你的方法。如果你没有实现这个方法，它会自己处理该事件，按定义的默认行为来执行。 @try @catch @finally @throw 这些和java的或者其它语言差不多。Apple反对非必要的使用异常（谁都反对。哈哈）。","title":"9-多态、动态类型和动态绑定  8-继承 "},{"content":"项目中有用到在TabHost中嵌套子Activity,然而TabHost的子Activity中startActivityForResult调用其他Activity时候遭遇到onActivityResult方法不响应的问题. 解决办法如下: 1.通过父Activity启动其他Activity; 2.实现父Activity的onActivityResult方法,将该处接收到的请求转发给当前活动的子Activity; 3.自定义一个转发接口用来实现第2步中的转发功能; 4.子Activity中实现第3步接口中的方法用来接收返回信息;   代码如下: 1.通过父Activity启动其他Activity getParent().startActivityForResult(new Intent(...), REQUEST_CODE); 2.实现父Activity的onActivityResult方法 @Override     protected void onActivityResult(int requestCode, int resultCode, Intent data) {         // 获取当前活动的Activity实例         Activity subActivity = getLocalActivityManager().getCurrentActivity();         //判断是否实现返回值接口         if (subActivity instanceof OnTabActivityResultListener) {             //获取返回值接口实例             OnTabActivityResultListener listener = (OnTabActivityResultListener) subActivity;             //转发请求到子Activity             listener.onTabActivityResult(requestCode, resultCode, data);         }         super.onActivityResult(requestCode, resultCode, data);     }3.自定义接口 /** * 解决子Activity无法接收Activity回调的问题 * @author Administrator * */public interface OnTabActivityResultListener {    public void onTabActivityResult(int requestCode, int resultCode, Intent data);}4.子Activity需要实现onTabActivityResult方法 @Override    public void onTabActivityResult(int requestCode, int resultCode, Intent data) {        if (requestCode == REQUEST_CODE && resultCode == RESULT_OK) {            //实现该处逻辑　　　　　　　　...        }    }注意子Activity一定要实现implements   OnTabActivityResultListener  然后重写 public void onTabActivityResult(int requestCode, int resultCode, Intent data) {\t\tif (resultCode == RESULT_OK) {\t\t\tswitch (requestCode) {\t\t\tcase SUB_REQUEST_CODE:\t\t\t\t//Sub_History_visit();\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tbreak;\t\t\t}\t\t}\t} 这样就OK了！","title":"TabHost的子Activity中onActivityResult 不响应解决方案"},{"content":"1.CCMenu是由菜单项CCMenuItem (或其子类如CCMenuItemImage)组成的，通常先创建菜单项，然后使用1个或多个菜单项生成菜单 2.菜单项的位置是相对于菜单的偏移位置，默认情况下菜单的位置在屏幕中点，方向为x向右，y向上（跟主窗口方向一样），菜单项默认偏移为（0,0），即不偏移  pMenu->setPosition( CCPointZero );  pCloseItem->setPosition(CCPointMake( s.width - 30, s.height - 30)); 上述代码把菜单原点设置在（0,0），即屏幕原点，菜单项相对菜单偏移到屏幕右上角向下30，向左30 3.CCMenuItem三个子类： CCMenuItemImage：图片按钮菜单项，通过指定图片资源来创建菜单项 CCMenuItemLabel：文本菜按钮单项，通过指定文本标签（实现CCLabelProtocol接口的类，如CCLabelTTF）来创建菜单项 CCMenuItemToggle ：开关按钮菜单项,这种类型的按钮一次只有一个菜单项显示出来，当你单击它的时候，它就会切换到另外一个菜单项，它的create函数：                                  CCMenuItemToggle * CCMenuItemToggle::create(CCObject* target, SEL_MenuHandler selector, CCMenuItem* item, ...) CCMenuItemFont：文本菜按钮单项，直接指定文本标签 /************************************************************************************************************************************************************** m_pItemMenu = CCMenu::create();   for (int i = 0; i < TESTS_COUNT; ++i)   {    CCLabelTTF* label = CCLabelTTF::create(g_aTestNames[i].c_str(), \"Arial\", 24);     CCMenuItemLabel* pMenuItem = CCMenuItemLabel::create(label, this, menu_selector(HelloWorld::menuCallback));    //pMenuItem->setZOrder(i + 10000);    m_pItemMenu->addChild(pMenuItem,i + 10000);    pMenuItem->setPosition(ccp( VisibleRect::center().x, (VisibleRect::top().y - (i + 1) * LINE_SPACE) ));   }   m_pItemMenu->setContentSize(CCSizeMake(VisibleRect::getVisibleRect().size.width, (TESTS_COUNT + 1) * (LINE_SPACE)));   m_pItemMenu->setPosition(s_tCurPos);   this->addChild(m_pItemMenu,1);   setTouchEnabled(true); ***************************************************************************************************************************************************************/ pMenuItem->setZOrder(int zorder)来制定菜单选项的ZOrder                        可见它是可以加入多个菜单项的，这些菜单项按顺序在上一个菜单项点击后出现下一个菜单项                        典型的应用场景是播放器的播放/暂停按钮                       它跟CCMenuItemImage不一样，CCMenuItemImage只能指定两者图片，并且不是点击后变成另一张，而是按下的时候变一下而已 4.CCMenuItem的点击响应回调函数一般是一个CCMenu的所有菜单项共用的，在回调函数里面可以得到点击的是哪个菜单项（可以把每个菜单项的ZOrder设成不一样，然后在回调函数里判断当前点击菜单项的ZOrder值） void HelloWorld::menuCallback(CCObject * pSender) {  CCLog(\"cocos2dx::%s\",\"menuCallback\");  CCMenuItem* pMenuItem = (CCMenuItem *)(pSender);  int nIdx = pMenuItem->getZOrder() - 10000;  CCLog(\"cocos2dx::The select index is %d\",nIdx); } 1.CCMenu是由菜单项CCMenuItem (或其子类如CCMenuItemImage)组成的，通常先创建菜单项，然后使用1个或多个菜单项生成菜单 2.菜单项的位置是相对于菜单的偏移位置，默认情况下菜单的位置在屏幕中点，方向为x向右，y向上（跟主窗口方向一样），菜单项默认偏移为（0,0），即不偏移  pMenu->setPosition( CCPointZero );  pCloseItem->setPosition(CCPointMake( s.width - 30, s.height - 30)); 上述代码把菜单原点设置在（0,0），即屏幕原点，菜单项相对菜单偏移到屏幕右上角向下30，向左30 3.CCMenuItem三个子类： CCMenuItemImage：图片按钮菜单项，通过指定图片资源来创建菜单项 CCMenuItemLabel：文本菜按钮单项，通过指定文本标签（实现CCLabelProtocol接口的类，如CCLabelTTF）来创建菜单项 CCMenuItemToggle ：开关按钮菜单项,这种类型的按钮一次只有一个菜单项显示出来，当你单击它的时候，它就会切换到另外一个菜单项，它的create函数：                                  CCMenuItemToggle * CCMenuItemToggle::create(CCObject* target, SEL_MenuHandler selector, CCMenuItem* item, ...) CCMenuItemFont：文本菜按钮单项，直接指定文本标签 /************************************************************************************************************************************************************** m_pItemMenu = CCMenu::create();   for (int i = 0; i < TESTS_COUNT; ++i)   {    CCLabelTTF* label = CCLabelTTF::create(g_aTestNames[i].c_str(), \"Arial\", 24);     CCMenuItemLabel* pMenuItem = CCMenuItemLabel::create(label, this, menu_selector(HelloWorld::menuCallback));    //pMenuItem->setZOrder(i + 10000);    m_pItemMenu->addChild(pMenuItem,i + 10000);    pMenuItem->setPosition(ccp( VisibleRect::center().x, (VisibleRect::top().y - (i + 1) * LINE_SPACE) ));   }   m_pItemMenu->setContentSize(CCSizeMake(VisibleRect::getVisibleRect().size.width, (TESTS_COUNT + 1) * (LINE_SPACE)));   m_pItemMenu->setPosition(s_tCurPos);   this->addChild(m_pItemMenu,1);   setTouchEnabled(true); ***************************************************************************************************************************************************************/ pMenuItem->setZOrder(int zorder)来制定菜单选项的ZOrder                        可见它是可以加入多个菜单项的，这些菜单项按顺序在上一个菜单项点击后出现下一个菜单项                        典型的应用场景是播放器的播放/暂停按钮                       它跟CCMenuItemImage不一样，CCMenuItemImage只能指定两者图片，并且不是点击后变成另一张，而是按下的时候变一下而已 4.CCMenuItem的点击响应回调函数一般是一个CCMenu的所有菜单项共用的，在回调函数里面可以得到点击的是哪个菜单项（可以把每个菜单项的ZOrder设成不一样，然后在回调函数里判断当前点击菜单项的ZOrder值）","title":"cocos2d-x CCMenu菜单选项"},{"content":"一、PC到底是多少呢？        “然后PC=PC+1”，老师经常这么说。        这不完全正确，PC自增一的情况指出现在无流水（non-pipeline）的情况下，这个时候取指，译码，执指都是顺序执行的。而在有流水的情况下就比较复杂了这里用arm7的三级流水线为例。         流水线使用三个阶段，因此指令分为三个阶段执行：1.取指（从存储器装载一条指令）；2.译码（识别将要被执行的指令）；3.执行（处理指令并将结果写回寄存器）。     而R15（PC）总是指向“正在取指”的指令，而不是指向“正在执行”的指令或正在“译码”的指令。一般来说，人们习惯性约定将“正在执行的指令作为参考点”，称之为当前第一条指令，因此PC总是指向第三条指令。当ARM状态时，每条指令为4字节长，所以PC始终指向该指令地址加8字节的地址，即：PC值=当前程序执行位置+8； 其余流水线类比此处。 二、ARM流水线概述 引 言     流水线技术通过多个功能部件并行工作来缩短程序执行时间，提高处理器核的效率和吞吐率，从而成为微处理器设计中最为重要的技术之一。ARM7处理器核使用了典型三级流水线的冯·诺伊曼结构，ARM9系列则采用了基于五级流水线的哈佛结构。通过增加流水线级数简化了流水线各级的逻辑，进一步提高了处理器的性能。     ARM7的三级流水线在执行单元完成了大量的工作，包括与操作数相关的寄存器和存储器读写操作、ALU操作以及相关器件之间的数据传输。执行单元的工作往往占用多个时钟周期，从而成为系统性能的瓶颈。ARM9采用了更为高效的五级流水线设计，增加了2个功能部件分别访问存储器并写回结果，且将读寄存器的操作转移到译码部件上，使流水线各部件在功能上更平衡；同时其哈佛架构避免了数据访问和取指的总线冲突。     然而不论是三级流水线还是五级流水线，当出现多周期指令、跳转分支指令和中断发生的时候，流水线都会发生阻塞，而且相邻指令之间也可能因为寄存器冲突导致流水线阻塞，降低流水线的效率。本文在对流水线原理及运行情况详细分析的基础上，研究通过调整指令执行序列来提高流水线运行性能的方法。   1 ARM7／ARM9流水线技术 1．1 ARM7流水线技术     ARM7系列处理器中每条指令分取指、译码、执行三个阶段，分别在不同的功能部件上依次独立完成。取指部件完成从存储器装载一条指令，通过译码部件产生下一周期数据路径需要的控制信号，完成寄存器的解码，再送到执行单元完成寄存器的读取、ALU运算及运算结果的写回，需要访问存储器的指令完成存储器的访问。流水线上虽然一条指令仍需3个时钟周期来完成，但通过多个部件并行，使得处理器的吞吐率约为每个周期一条指令，提高了流式指令的处理速度，从而可达到 O．9 MIPS／MHz的指令执行速度。     在三级流水线下，通过R15访问PC(程序计数器)时会出现取指位置和执行位置不同的现象。这须结合流水线的执行情况考虑，取指部件根据PC取指，取指完成后PC+4送到PC，并把取到的指令传递给译码部件，然后取指部件根据新的PC取指。因为每条指令4字节，故PC值等于当前程序执行位置+8。 1．2 ARM9流水线技术     ARM9系列处理器的流水线分为取指、译码、执行、访存、回写。取指部件完成从指令存储器取指；译码部件读取寄存器操作数，与三级流水线中不占有数据路径区别很大；执行部件产生ALU运算结果或产生存储器地址(对于存储器访问指令来讲)；访存部件访问数据存储器；回写部件完成执行结果写回寄存器。把三级流水线中的执行单元进一步细化，减少了在每个时钟周期内必须完成的工作量，进而允许使用较高的时钟频率，且具有分开的指令和数据存储器，减少了冲突的发生，每条指令的平均周期数明显减少。     2 三级流水线运行情况分析     三级流水线在处理简单的寄存器操作指令时，吞吐率为平均每个时钟周期一条指令；但是在存在存储器访问指令、跳转指令的情况下会出现流水线阻断情况，导致流水线的性能下降。图1给出了流水线的最佳运行情况，图中的MOV、ADD、SUB指令为单周期指令。从T1开始，用3个时钟周期执行了3条指令，指令平均周期数(CPI)等于1个时钟周期。           流水线中阻断现象也十分普遍，下面就各种阻断情况下的流水线性能进行详细分析。 2．1 带有存储器访问指令的流水线     对存储器的访问指令LDR就是非单周期指令，如图2所示。这类指令在执行阶段，首先要进行存储器的地址计算，占用控制信号线，而译码的过程同样需要占用控制信号线，所以下一条指令(第一个SUB)的译码被阻断，并且由于LDR访问存储器和回写寄存器的过程中需要继续占用执行单元，所以下一条(第一个 SUB)的执行也被阻断。由于采用冯·诺伊曼体系结构，不能够同时访问数据存储器和指令存储器，当LDR处于访存周期的过程中时，MOV指令的取指被阻断。因此处理器用8个时钟周期执行了6条指令，指令平均周期数(CPI)=1．3个时钟周期。     2．2 带有分支指令的流水线     当指令序列中含有具有分支功能的指令(如BL等)时，流水线也会被阻断，如图3所示。分支指令在执行时，其后第1条指令被译码，其后第2条指令进行取指，但是这两步操作的指令并不被执行。因为分支指令执行完毕后，程序应该转到跳转的目标地址处执行，因此在流水线上需要丢弃这两条指令，同时程序计数器就会转移到新的位置接着进行取指、译码和执行。此外还有一些特殊的转移指令需要在跳转完成的同时进行写链接寄存器、程序计数寄存器，如BL执行过程中包括两个附加操作——写链接寄存器和调整程序指针。这两个操作仍然占用执行单元，这时处于译码和取指的流水线被阻断了。 2．3 中断流水线     处理器中断的发生具有不确定性，与当前所执行的指令没有任何关系。在中断发生时，处理器总是会执行完当前正被执行的指令，然后去响应中断。如图4所示，在 Ox90000处的指令ADD执行期间IRQ中断发生，这时要等待ADD指令执行完毕，IRQ才获得执行单元，处理器开始处理IRQ中断，保存程序返回地址并调整程序指针指向Oxl8内存单元。在Oxl8处有IRO中断向量(也就是跳向IRQ中断服务的指令)，接下来执行跳转指令转向中断服务程序，流水线又被阻断，执行0x18处指令的过程同带有分支指令的流水线。   3 五级流水线技术     五级流水线技术在多种RISC处理器中被广泛使用，被认为是经典的处理器设计方式。五级流水线中的存储器访问部件(访存)和寄存器回写部件，解决了三级流水线中存储器访问指令在指令执行阶段的延迟问题。图5为五级流水线的运行情况(五级流水线也存在阻断)。       3．1 五级流水线互锁分析     五级流水线只存在一种互锁，即寄存器冲突。读寄存器是在译码阶段，写寄存器是在回写阶段。如果当前指令(A)的目的操作数寄存器和下一条指令(B)的源操作数寄存器一致，B指令就需要等A回写之后才能译码。这就是五级流水线中的寄存器冲突。如图6所示，LDR指令写R9是在回写阶段，而MOV中需要用到的 R9正是LDR在回写阶段将会重新写入的寄存器值，MOV译码需要等待，直到LDR指令的寄存器回写操作完成。(注：现在处理器设计中，可以通过寄存器旁路技术对流水线进行优化，解决流水线的寄存器冲突问题。)       虽然流水线互锁会增加代码执行时间，但是为初期的设计者提供了巨大的方便，可以不必考虑使用的寄存器会不会造成冲突；而且编译器以及汇编程序员可以通过重新设计代码的顺序或者其他方法来减少互锁的数量。另外分支指令和中断的发生仍然会阻断五级流水线。 3．2 五级流水线优化     采用重新设计代码顺序在很多情况下可以很好地减少流水线的阻塞，使流水线的运行流畅。下面详细分析代码优化对流水线的优化和效率的提高。     要实现把内存地址0x1000和Ox2000处的数据分别拷贝到0x8000和0x9000处。     Oxl000处的内容：1，2，3，4，5，6，7，8，9，10     Ox2000处的内容：H，e，l，l，o，W，o，r，l，d     实现第一个拷贝过程的程序代码及指令的执行时空图如图7所示。       全部拷贝过程由两个结构相同的循环各自独立完成，分别实现两块数据的拷贝，并且两个拷贝过程极为类似，分析其中一个即可。     T1～T3是3个单独的时钟周期；T4～T11是一个循环，在时空图中描述了第一次循环的执行情况。在T12的时候写LR的同时，开始对循环的第一条语句进行取指，所以总的流水线周期数为3+10×10+2×9=121。整个拷贝过程需要121×2+2=244个时钟周期完成。     考虑到通过减少流水线的冲突可以提高流水线的执行效率，而流水线的冲突主要来自寄存器冲突和分支指令，因此对代码作如下两方面调整：     ①将两个循环合并成一个循环能够充分减少循环跳转的次数，减少跳转带来的流水线停滞；     ②调整代码的顺序，将带有与临近指令不相关的寄存器插到带有相关寄存器的指令之间，能够充分地避免寄存器冲突导致的流水线阻塞。     对代码调整和流水线的时空图如图8所示。       调整之后，T1～T5是5个单独的时钟周期，T6～T13是一个循环，同样在T14的时候BNE指令在写LR的同时，循环的第一条指令开始取指，所以总的指令周期数为5+10×10+2×9+2=125。     通过两段代码的比较可看出：调整之前整个拷贝过程总共使用了244个时钟周期，调整了循环内指令的顺序后，总共使用了125个时钟周期就完成了同样的工作，时钟周期减少了119个，缩短了119／244=48．8％，效率提升十分明显。     代码优化前后执行周期数对比的情况如表1所列。          因此流水线的优化问题主要应从两方面考虑：     ①通过合并循环等方式减少分支指令的个数，从而减少流水线的浪费；     ②通过交换指令的顺序，避免寄存器冲突造成的流水线停滞。     4 结 论     流水线技术提高了处理器的并行性，与串行CPU相比大大提高了处理器性能。通过调节指令序列的方法又能够有效地避免流水线冲突的发生，从而提高了流水线的执行效率。因此如何采用智能算法进行指令序列的自动调节以提高流水线的效率和进一步提高处理器的并行性将是以后研究的主要方向。 三、冯诺依曼体系结构、哈佛体系结构 1、冯·诺依曼结构 　　冯·诺依曼结构又称作普林斯顿体系结构（Princetionarchitecture）。 　　1945年，冯·诺依曼首先提出了“存储程序”的概念和二进制原理，后来，人们把利用这种概念和原理设计的电子计算机系统统称为“冯·诺依曼型结构”计算机。冯·诺依曼结构的处理器使用同一个存储器，经由同一个总线传输。 　　冯·诺依曼结构处理器具有以下几个特点： 　　必须有一个存储器； 　　必须有一个控制器； 　　必须有一个运算器，用于完成算术运算和逻辑运算； 　　必须有输入和输出设备，用于进行人机通信。 　　冯·诺依曼的主要贡献就是提出并实现了“存储程序”的概念。由于指令和数据都是二进制码，指令和操作数的地址又密切相关，因此，当初选择这种结构是自然的。但是，这种指令和数据共享同一总线的结构，使得信息流的传输成为限制计算机性能的瓶颈，影响了数据处理速度的提高。 　　在典型情况下，完成一条指令需要3个步骤，即：取指令、指令译码和执行指令。从指令流的定时关系也可看出冯·诺依曼结构与哈佛结构处理方式的差别。举一个最简单的对存储器进行读写操作的指令，指令1至指令3均为存、取数指令，对冯·诺依曼结构处理器，由于取指令和存取数据要从同一个存储空间存取，经由同一总线传输，因而它们无法重叠执行，只有一个完成后再进行下一个。 　　arm7系列的CPU有很多款，其中部分CPU没有内部cache的，比如arm7TDMI，就是纯粹的冯·诺依曼结构，其他有内部cache且数据和指令的cache分离的cpu则使用了哈弗结构。 2、哈佛结构  　　哈佛结构是一种将程序指令存储和数据存储分开的存储器结构，如图1所示。中央处理器首先到程序指令存储器中读取程序指令内容，解码后得到数据地址，再到相应的数据存储器中读取数据，并进行下一步的操作（通常是执行）。程序指令存储和数据存储分开，可以使指令和数据有不同的数据宽度，如Microchip公司的PIC16芯片的程序指令是14位宽度，而数据是8位宽度。   图1 哈佛体系结构框图 　　哈佛结构的微处理器通常具有较高的执行效率。其程序指令和数据指令分开组织和存储的，执行时可以预先读取下一条指令。  　　目前使用哈佛结构的中央处理器和微控制器有很多，除了Microchip公司的PIC系列芯片，还有摩托罗拉公司的MC68系列、Zilog公司的Z8系列、ATMEL公司的AVR系列和ARM公司的ARM9、ARM10和ARM11。  　　哈佛结构是指程序和数据空间独立的体系结构， 目的是为了减轻程序运行时的访存瓶颈。 　　例如最常见的卷积运算中， 一条指令同时取两个操作数， 在流水线处理时， 同时还有一个取指操作， 如果程序和数据通过一条总线访问， 取指和取数必会产生冲突， 而这对大运算量的循环的执行效率是很不利的。 　　哈佛结构能基本上解决取指和取数的冲突问题。 　　而对另一个操作数的访问， 就只能采用Enhanced哈佛结构了， 例如像TI那样，数据区再split， 并多一组总线。 或向AD那样，采用指令cache， 指令区可存放一部分数据。 　　在典型情况下，完成一条指令需要3个步骤，即：取指令、指令译码和执行指令。从指令流的定时关系也可看出冯·诺依曼结构与哈佛结构处理方式的差别。举一个最简单的对存储器进行读写操作的指令，指令1至指令3均为存、取数指令，对冯·诺依曼结构处理器，由于取指令和存取数据要从同一个存储空间存取，经由同一总线传输，因而它们无法重叠执行，只有一个完成后再进行下一个。 　　如果采用哈佛结构处理以上同样的3条存取数指令，由于取指令和存取数据分别经由不同的存储空间和不同的总线，使得各条指令可以重叠执行，这样，也就克服了数据流传输的瓶颈，提高了运算速度。 3、冯·诺依曼体系和哈佛总线体系的区别  　　二者的区别就是程序空间和数据空间是否是一体的。冯·诺依曼结构数据空间和地址空间不分开，哈佛结构数据空间和地址空间是分开的。 　　早期的微处理器大多采用冯·诺依曼结构，典型代表是Intel公司的X86微处理器。取指和取操作数都在同一总线上，通过分时服用的方式进行的。缺点是在高速运行时，不能达到同时取指令和取操作数，从而形成了传输过程的瓶颈。 　　哈佛总线技术应用是以DSP和ARM为代表的。采用哈佛总线体系结构的芯片内部程序空间和数据空间是分开的，这就允许同时取指和取操作数，从而大大提高了运算能力。 　　DSP芯片硬件结构有冯·诺依曼结构和哈佛结构，两者区别是地址空间和数据空间分开与否。一般DSP都是采用改进型哈佛结构，就是分开的数据空间和地址空间都不只是一条，而是有多条，这根据不同的生产厂商的DSP芯片有所不同。在对外寻址方面从逻辑上来说也是一样，因为外部引脚的原因，一般来说都是通过相应的空间选取来实现的。本质上是同样的道理。 4.改进型的哈佛结构 与 哈佛体系结构差别 与冯.诺曼结构处理器比较，哈佛结构处理器有两个明显的特点： (1).使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存；  (2).使用独立的两条总线，分别作为CPU与每个存储器之间的专用通信路径，而这两条总线之间毫无关联。 后来，又提出了改进的哈佛结构，其结构特点为：  (1).使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存；  (2).具有一条独立的地址总线和一条独立的数据总线，利用公用地址总线访问两个存储模块（程序存储模块和数据存储模块），公用数据总线则被用来完成程序存储模块或数据存储模块与CPU之间的数据传输；  (3).两条总线由程序存储器和数据存储器分时共用。 5.总结 体系结构与采用的独立与否的总线无关，与指令空间和数据空间的分开独立与否有关。51单片机虽然数据指令存储区是分开的，但总线是分时复用得，所以属于改进型的哈佛结构。ARM9虽然是哈佛结构，但是之前的版本(例如ARM7)也还是冯·诺依曼结构。早期的X86能迅速占有市场，一条很重要的原因，正是靠了冯·诺依曼这种实现简单，成本低的总线结构。现在的处理器虽然外部总线上看是诺依曼结构的，但是由于内部CACHE的存在，因此实际上内部来看已经 类似 改进型哈佛结构的了。至于优缺点，哈佛结构就是复杂，对外围设备的连接与处理要求高，十分不适合外围存储器的扩展。所以早期通用CPU难以采用这种结构。而单片机，由于内部集成了所需的存储器，所以采用哈佛结构也未尝不可。现在的处理器，依托CACHE的存在，已经很好的将二者统一起来了。","title":"PC值、ARM流水线、超流水线和冯诺依曼、哈佛结构"},{"content":"到官网http://ftp.denx.de/pub/u-boot/下载u-boot-2012.04.01.tar.bz2 解压后在board/samsung/目录下任然没有2440,虽然没有直接支持2440开发板,但其代码已经支持,只需添加相关配置即可。新版u-boot要使用较新的交叉编译器，我使用的是4.4.3 一、    首先建立自己的开发板 拷贝board/samsung/smdk2410/目录到board/tq2440 root@zjh:/home/work/u-boot-2012.04.01#cp -a board/samsung/smdk2410/ board/tq2440 进入board/tq2440目录修改 root@zjh:/home/work/u-boot-2012.04.01/board/tq2440#mv smdk2410.c tq2440.c 修改该目录下的Makefile COBJS   := tq2440.o 拷贝配置文件 root@zjh:/home/work/u-boot-2012.04.01#cp include/configs/smdk2410.h include/configs/tq2440.h 增加开发板配置选项 在顶层目录下的Makefile中搜索不到smdk2410 在顶层目录执行如下命令 root@zjh:/home/work/u-boot-2012.04.01#grep \"smdk2410\" . –nR ./boards.cfg:65:smdk2410                     arm         arm920t     -                   samsung        s3c24x0 ./MAINTAINERS:750:    smdk2410 ARM920T ./board/samsung/smdk2410/Makefile:28:COBJS       := smdk2410.o ./arch/arm/include/asm/mach-types.h:1644:#define machine_is_smdk2410()  (machine_arch_type== MACH_TYPE_SMDK2410) ./arch/arm/include/asm/mach-types.h:1646:#define machine_is_smdk2410()      (0) 知道在顶层目录下的boards.cfg文件中定义了smdk2410开发板的配置选项，仿照它定义TQ2440开发板的配置选项 # Target   ARCH       CPU         Board name          Vendor         SoC         Options ######################################################################################## tq2440    arm         arm920t     -                   -              s3c24x0 由于我们在board目录下创建开发板目录，所以Vendor指定为空","title":"u-boot-2012.04.01移植到TQ2440(一)：建立自己的开发板"},{"content":"一、    移植NOR FLASH 去掉配置文件include\\configs\\tq2440.h中的宏并修改代码段基地址 #define CONFIG_SYS_TEXT_BASE 0x0 //#defineCONFIG_SKIP_LOWLEVEL_INIT 在board\\tq2440\\lowlevel_init.S修改SDRAM’刷新频率 #define REFCNT                     0x4f4 该文件中的这三条指令其实可以用一条指令替换adrl r0, SMRDATA ldr     r0, =SMRDATA ldr    r1, _TEXT_BASE sub  r0, r0, r1 进入/drivers/mtd/cfi_flash.c中的flash_init()函数 在该文件开头定义宏DEBUG打开调试信息 #define DEBUG 1 #define _DEBUG     1 重新编译 用原先的u-boot从NOR FLASH启动，将新u-boot.bin烧到NOR FLASH TQ2440 # tftp 32000000u-boot.bin dm9000 i/o: 0x20000000, id:0x90000a46 DM9000: running in 16 bitmode MAC: 00:0c:29:4d:e4:f4 Using dm9000 device TFTP from server172.28.12.60; our IP address is 172.28.12.10 Filename 'u-boot.bin'. Load address: 0x32000000 Loading: T ############# done Bytes transferred = 180828(2c25c hex) TQ2440 # protect off all Un-Protect Flash Bank # 1 TQ2440 # erase 0 +30000   ...... done Erased 6 sectors TQ2440 # cp.b 32000000 030000 Copy to Flash...9....8....7....6....5....4....3....2....1....done TQ2440 # 重启开发板 U-Boot 2012.04.01 (Dec 292012 - 14:25:05)   CPUID: 32440001 FCLK:      400 MHz HCLK:      100 MHz PCLK:       50 MHz DRAM:  64 MiB WARNING: Caches not enabled Flash: fwc addr (null) cmdf0 00f0 16bit x 16 bit fwc addr 0000aaaa cmd aa00aa 16bit x 16 bit fwc addr 00005554 cmd 550055 16bit x 16 bit fwc addr 0000aaaa cmd 900090 16bit x 16 bit fwc addr (null) cmd f0 00f016bit x 16 bit JEDEC PROBE: ID 1c2249 0 fwc addr (null) cmd ff 00ff16bit x 16 bit fwc addr (null) cmd 90 009016bit x 16 bit fwc addr (null) cmd ff 00ff16bit x 16 bit JEDEC PROBE: ID 13 ea00 0 *** failed *** ### ERROR ### Please RESETthe board ### 搜索“JEDEC PROBE:”   flash_read_jedec_ids(info);                        debug(\"JEDECPROBE: ID %x %x %x\\n\",                                      info->manufacturer_id,                                      info->device_id,                                      info->device_id2);                        if (jedec_flash_match(info,info->start[0]))                               break;                        else                               unmap_physmem((void*)info->start[0],                                            MAP_NOCACHE); drivers\\mtd\\jedec_flash.c中的jedec_flash_match()函数： /*-----------------------------------------------------------------------  * match jedec ids against table. If a match isfound, fill flash_info entry  */ intjedec_flash_match(flash_info_t *info, ulong base) {   int ret = 0;   int i;   ulong mask = 0xFFFF;   if (info->chipwidth == 1)          mask = 0xFF;     for (i = 0; i < ARRAY_SIZE(jedec_table); i++) {          if ((jedec_table[i].mfr_id & mask) ==(info->manufacturer_id & mask) &&             (jedec_table[i].dev_id & mask) == (info->device_id & mask)) {                 fill_info(info, &jedec_table[i], base);                 ret = 1;                 break;          }   }   return ret; } flash_read_jedec_ids(info)读出了我们的开发板的NOR FLASH的厂商ID为0x1c,设备ID为0x2249 jedec_flash_match(info,info->start[0])将读出的信息与jedec_table[]数组进行匹配，如果有匹配成功则填充flashin信息并返回1，否则返回0。说明这里没有匹配成功，需要在jedec_table[]数组中添加我们自己开发板的NOR FLASH信息。 修改配置文件include\\configs\\tq2440.h #defineCONFIG_SYS_FLASH_LEGACY_1024Kx16 在drivers\\mtd\\jedec_flash.c文件中jedec_table[]数组中增加EN29LV160AB的配置根据芯片手册。 #ifdefCONFIG_SYS_FLASH_LEGACY_1024Kx16     /* TQ2440 EN29LV160AB */     {               .mfr_id     = 0x1c,  /* 厂商ID */             .dev_id     = 0x2249,  /* 设备ID */             .name      = \"EON EN29LV160AB\",             .uaddr      = {/* 因为NOR FLASH的ADDR0接到了S3C2440的ADDR1 */                 [1] = MTD_UADDR_0x0555_0x02AA/* x16 */             },              .DevSize    = SIZE_2MiB,             .CmdSet     = P_ID_AMD_STD,             .NumEraseRegions= 4,             .regions    = {                 ERASEINFO(0x04000, 1),                 ERASEINFO(0x02000, 2),                  ERASEINFO(0x08000, 1),                  ERASEINFO(0x10000, 31),             }           },  #endif 重新编译通过工具将u-boot.bin烧写到NOR FLASH U-Boot 2012.04.01 (Dec 292012 - 15:26:09)   CPUID: 32440001 FCLK:      400 MHz HCLK:      100 MHz PCLK:       50 MHz DRAM:  64 MiB WARNING: Caches not enabled Flash: fwc addr (null) cmdf0 00f0 16bit x 16 bit fwc addr 0000aaaa cmd aa00aa 16bit x 16 bit fwc addr 00005554 cmd 550055 16bit x 16 bit fwc addr 0000aaaa cmd 900090 16bit x 16 bit fwc addr (null) cmd f0 00f016bit x 16 bit JEDEC PROBE: ID 1c 2249 0 ERROR: too manyflash sectors 2 MiB *** Warning - bad CRC, usingdefault environment   In:    serial Out:   serial Err:   serial Net:   No ethernet found. TQ2440 # 出现一个错误ERROR: too many flash sectors 修改配置文件include\\configs\\tq2440.h #defineCONFIG_SYS_MAX_FLASH_SECT (35) 取消调试信息drivers\\mtd\\cfi_flash.c //#define DEBUG    1 //#define _DEBUG  1 重新编译 U-Boot 2012.04.01 (Dec 292012 - 15:33:09)   CPUID: 32440001 FCLK:      400 MHz HCLK:      100 MHz PCLK:       50 MHz DRAM:  64 MiB WARNING: Caches not enabled Flash: 2 MiB *** Warning - bad CRC, usingdefault environment   In:    serial Out:   serial Err:   serial Net:   No ethernet found. TQ2440 # fflinfo   Bank # 1: EON EN29LV160ABflash (16 x 16)  Size: 2 MB in 35 Sectors   AMD Legacy command set, Manufacturer ID:0x1C, Device ID: 0x2249   Erase timeout: 30000 ms, write timeout: 100ms     Sector Start Addresses:   00000000  RO   00004000   RO  00006000   RO   00008000  RO   00010000   RO   00020000  RO   00030000        00040000        00050000        00060000        00070000  RO   00080000        00090000        000A0000        000B0000        000C0000        000D0000        000E0000        000F0000        00100000        00110000       00120000        00130000        00140000        00150000        00160000        00170000        00180000        00190000        001A0000        001B0000        001C0000        001D0000        001E0000        001F0000      TQ2440 # md.b 32000000 a 32000000: 13 00 00 ea 14 f09f e5 14 f0    .......... TQ2440 # erase 100000 +a   . done Erased 1 sectors TQ2440 # cp.b 32000000100000 a Copy to Flash... done TQ2440 # md.b 100000 a 00100000: 13 00 00 ea 14 f09f e5 14 f0    ..........","title":"u-boot-2012.04.01移植到TQ2440（三）：移植NOR FLASH"},{"content":"一、    修改时钟 在配置文件include/configstq2440.h中加入S3C2440的配置，屏蔽掉S3C2410的配置 //#defineCONFIG_S3C2410        /* specifically aSAMSUNG S3C2410 SoC */  #define CONFIG_S3C2440 //#defineCONFIG_SMDK2410       /* on a SAMSUNGSMDK2410 Board */ 屏蔽一些暂时不用的支持 #if 0 #define CONFIG_CS8900          /* we have a CS8900 on-board */ #define CONFIG_CS8900_BASE     0x19000300 #define CONFIG_CS8900_BUS16  /* the Linux driver does accesses as shorts */ #endif #if 0 #define CONFIG_USB_OHCI #define CONFIG_USB_KEYBOARD #define CONFIG_USB_STORAGE #define CONFIG_DOS_PARTITION #endif //#defineCONFIG_CMD_DHCP //#defineCONFIG_CMD_NAND //#defineCONFIG_CMD_USB #if 0 #define CONFIG_CMD_FAT #define CONFIG_CMD_EXT2 #define CONFIG_CMD_UBI #define CONFIG_CMD_UBIFS #define CONFIG_CMD_MTDPARTS #define CONFIG_MTD_DEVICE #defineCONFIG_MTD_PARTITIONS #define CONFIG_YAFFS2 #define CONFIG_RBTREE #endif 在arch/arm/cpu/arm920t/start.S添加如下代码 # if defined(CONFIG_S3C2410)   ldr  r1, =0x3ff   ldr  r0, =INTSUBMSK   str  r1, [r0] # endif   # ifdefined(CONFIG_S3C2440)   ldr  r1,=0x7fff   ldr  r0,=INTSUBMSK   str  r1,[r0] # endif # ifdefined(CONFIG_S3C2440) # define MPLLCON 0x4C000004    //系统主频配置寄存器 # define UPLLCON  0x4C000008 //USB频率配置寄存器 # define CAMDIVN 0x4C000018 //照相机时钟分频寄存器   ldr r0, =CAMDIVN   mov r1, #0   str r1, [r0]   ldr r0, =CLKDIVN   mov r1, #0x05   str r1, [r0]   /*如果HDIVN不等于0，CPU必须设置为异步总线模式*/   mrc p15,0,r0,c1,c0,0   orr r0,r0,#0xc0000000   mcr p15,0,r0,c1,c0,0   ldr r0, =UPLLCON   ldr r1, =0x38022  // 48MHZ   str r1, [r0]   /*   **When you set MPLL&UPLL values, you haveto set the UPLL   **value first and then the MPLL value. (Needsintervals   **approximately 7 NOP)   */   nop   nop   nop   nop   nop   nop   nop   ldr r0, =MPLLCON   ldr r1, =0x5c011 //400MHZ   str r1, [r0] # else   /* FCLK:HCLK:PCLK = 1:2:4 */   /* default FCLK is 120 MHz ! */   ldr  r0, =CLKDIVN   mov      r1, #3   str  r1, [r0] # endif /*CONFIG_S3C2440 */ #endif    /* CONFIG_S3C24X0 */ 屏蔽board/tq2440/tq2440.c中board_early_init_f()函数对时钟的设置 #if 0   struct s3c24x0_clock_power * const clk_power =                               s3c24x0_get_base_clock_power(); #endif   struct s3c24x0_gpio * const gpio =s3c24x0_get_base_gpio(); #if 0   /* to reduce PLL lock time, adjust the LOCKTIME register */   writel(0xFFFFFF, &clk_power->locktime);     /* configure MPLL */   writel((M_MDIV << 12) + (M_PDIV << 4) + M_SDIV,         &clk_power->mpllcon);     /* some delay between MPLL and UPLL */   pll_delay(4000);     /* configure UPLL */   writel((U_M_MDIV << 12) + (U_M_PDIV << 4) + U_M_SDIV,         &clk_power->upllcon);     /* some delay between MPLL and UPLL */   pll_delay(8000); #endif 在board_init函数中修改机器码 gd->bd->bi_arch_number= MACH_TYPE_S3C2440; 修改代码以支持直接烧到SDRAM运行 修改配置文件include\\configs\\tq2440.h #define CONFIG_SYS_TEXT_BASE 0x32000000 #define CONFIG_SKIP_LOWLEVEL_INIT #defineCONFIG_AUTO_COMPLETE  //开启命令自动补全 修改命令提示符 #define CONFIG_SYS_PROMPT      \"TQ2440# \" 修改顶层目录Makefile(根据自己的tftp服务器目录修改，这只是为了以后方便) $(obj)u-boot.bin:   $(obj)u-boot         $(OBJCOPY) ${OBJCFLAGS} -O binary $<$@         $(BOARD_SIZE_CHECK)         cp u-boot.bin/home/tftpboot 配置 root@zjh:/home/work/u-boot-2012.04.01#make tq2440_config Configuring for tq2440board... 编译 root@zjh:/home/work/u-boot-2012.04.01#make 将u-boot.bin烧到0x32000000地址然后执行 TQ2440 # tftp 32000000u-boot.bin dm9000 i/o: 0x20000000, id:0x90000a46 DM9000: running in 16 bitmode MAC: 00:0c:29:4d:e4:f4 Using dm9000 device TFTP from server172.28.12.60; our IP address is 172.28.12.10 Filename 'u-boot.bin'. Load address: 0x32000000 Loading: T ############# done Bytes transferred = 180536(2c138 hex) TQ2440 # go 32000000 ## Starting application at0x32000000 ...     U-Boot 2012.04.01 (Dec 292012 - 14:00:52)   CPUID: 32440001 FCLK:      400 MHz HCLK:      100 MHz PCLK:       50 MHz DRAM:  64 MiB WARNING: Caches not enabled Flash: *** failed *** ### ERROR ### Please RESETthe board ###卡在这里不动了 搜索“Flash:”   puts(\"Flash: \");     flash_size = flash_init();   if (flash_size > 0) { # ifdefCONFIG_SYS_FLASH_CHECKSUM          char *s = getenv(\"flashchecksum\");            print_size(flash_size, \"\");          /*           * Compute and printflash CRC if flashchecksum is set to 'y'           *           * NOTE: Maybe weshould add some WATCHDOG_RESET()? XXX           */          if (s && (*s == 'y')) {                 printf(\" CRC: %08X\", crc32(0,                        (const unsigned char *) CONFIG_SYS_FLASH_BASE,                        flash_size));          }          putc('\\n'); # else     /* !CONFIG_SYS_FLASH_CHECKSUM */          print_size(flash_size, \"\\n\"); # endif /*CONFIG_SYS_FLASH_CHECKSUM */   } else {          puts(failed);          hang();   } 在看下hang()函数 void hang(void) {   puts(\"### ERROR ### Please RESET the board ###\\n\");   for (;;); } 从这里可以知道是Flash初始化失败","title":"u-boot-2012.04.01移植到TQ2440（二）：修改时钟"},{"content":"在Activity中静态使用fragment的时候，要注意两个地方。 Fragment引用的包是： import android.support.v4.app.Fragment; 而不是： import android.app.Fragment; 然后Activity必须是继承FragmentActivity import android.support.v4.app.FragmentActivity; 不然就会出现这个错误。","title":"Android中error inflating class fragment"},{"content":"一、    移植网卡DM9000 在配置文件include\\configs\\tq2440.h中添加DM9000的配置信息 #if 0 #define CONFIG_CS8900          /* we have a CS8900 on-board */ #define CONFIG_CS8900_BASE     0x19000300 #define CONFIG_CS8900_BUS16  /* the Linux driver does accesses as shorts */ #endif #defineCONFIG_DRIVER_DM9000 #defineCONFIG_DM9000_NO_SROM   1 #defineCONFIG_DM9000_BASE             0x20000000 #defineDM9000_IO                      CONFIG_DM9000_BASE #defineDM9000_DATA                    (CONFIG_DM9000_BASE + 4) 修改IP地址，添加MAC地址(也可在u-boot启动后通过setenv命令设置) #define CONFIG_NETMASK      255.255.255.0 #define CONFIG_IPADDR       192.168.2.100 #define CONFIG_SERVERIP     192.168.2.209 #define CONFIG_ETHADDR      00:0c:29:4d:e4:f4 修改board\\tq2440\\tq2440.c int board_eth_init(bd_t*bis) {   int rc = 0; #ifdef CONFIG_CS8900   rc = cs8900_initialize(0, CONFIG_CS8900_BASE); #endif #ifdefCONFIG_DRIVER_DM9000   rc = dm9000_initialize(bis); #endif   return rc; } 重新编译烧到NOR FLASH执行 U-Boot 2012.04.01 (Dec 292012 - 15:58:53)   CPUID: 32440001 FCLK:      400 MHz HCLK:      100 MHz PCLK:       50 MHz DRAM:  64 MiB WARNING: Caches not enabled Flash: 2 MiB *** Warning - bad CRC, usingdefault environment   In:    serial Out:   serial Err:   serial Net:   dm9000 TQ2440 # 现在可以用tftpboot命令通过网络下载文件了，前提是确保服务器IP和开发板u-boot的IP在同一个网段。 TQ2440 # pri    baudrate=115200 bootdelay=5 ethact=dm9000 ethaddr=00:0c:29:4d:e4:f4 ipaddr=172.28.12.10 netmask=255.255.255.0 serverip=172.28.12.60 stderr=serial stdin=serial stdout=serial   Environment size: 194/65532bytes TQ2440 # tftp 32000000 u-boot.bin dm9000 i/o: 0x20000000, id:0x90000a46 DM9000: running in 16 bitmode MAC: 00:0c:29:4d:e4:f4 could notestablish link Using dm9000 device TFTP from server172.28.12.60; our IP address is 172.28.12.10 Filename 'u-boot.bin'. Load address: 0x32000000 Loading: ############# done Bytes transferred = 183576(2cd18 hex) 出现一个错误could not establish link 解决错误并加快速度 修改drivers\\net\\dm9000x.c #if 0   i = 0;   while (!(dm9000_phy_read(1) & 0x20)) {     /* autonegation complete bit */          udelay(1000);          i++;          if (i == 10000) {                 printf(\"could not establish link\\n\");                 return 0;          }   }     /* see what we've got */   lnk = dm9000_phy_read(17) >> 12;   printf(\"operating at \");   switch (lnk) {   case 1:          printf(\"10M half duplex \");          break;   case 2:          printf(\"10M full duplex \");          break;   case 4:          printf(\"100M half duplex \");          break;   case 8:          printf(\"100M full duplex \");          break;   default:          printf(\"unknown: %d \", lnk);          break;   }   printf(\"mode\\n\"); #endif 重新编译烧到NOR FLASH运行 U-Boot 2012.04.01 (Dec 292012 - 17:14:04)   CPUID: 32440001 FCLK:      400 MHz HCLK:      100 MHz PCLK:       50 MHz DRAM:  64 MiB WARNING: Caches not enabled Flash: 2 MiB *** Warning - bad CRC, usingdefault environment   In:    serial Out:   serial Err:   serial Net:   dm9000 TQ2440 # tftp 32000000u-boot.bin dm9000 i/o: 0x20000000, id:0x90000a46 DM9000: running in 16 bitmode MAC: 00:0c:29:4d:e4:f4 Using dm9000 device TFTP from server172.28.12.60; our IP address is 172.28.12.10 Filename 'u-boot.bin'. Load address: 0x32000000 Loading: T ############# done Bytes transferred = 182996(2cad4 hex) TQ2440 #","title":"u-boot-2012.04.01移植到TQ2440（四）：移植网卡DM9000"},{"content":"tableview的每个cell里面都要去从服务器获取数据，导致每次滑动的时候都是先加载好数据再显示出cell，这样系统运行的就很卡，运用第三方的库SDWebImage就能解决这个问题。 （1、）之前我用的获取图片的方法是： NSData *data = [NSData dataWithContentsOfURL:url];    if(data!=nil)    {        UIImage *aimage = [[UIImage alloc] initWithData:data];            cell.hotelImage.image = aimage;        } 这种方式是获取到图片以后再显示cell，导致系统卡的要死。。。 （2、）后来用了下面的方法： 1、把库加入到工程当中； 2、导入库的头文件：#import\"UIImageView+WebCache.h\"； 3、在 -(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath函数中加载图片的时候使用 [cell.imageViewsetImageWithURL:[NSURLURLWithString:url]placeholderImage:nil];这里的nil也可以换成默认的一张图片，这样系统运行起来就比较流畅，因为图片是异步加载的，加载好了直接放到缓存里了，下次的时候就不再去跟服务器通讯了。 这个方法需要添加几个framework： ImageIO.framework； CoreImage.framework； MapKit.framework。 （3、）网上有前辈说用- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath方法，但是我测试之后每次都是只加载1,2张图片，大部分图片都加载不出来，不知道是我自己的代码原因是这个方法的原因。。。","title":"iOStableview滑动时图片加载缓慢解决办法"},{"content":"   在应用中，总要对用户的一些操作进行记录，比如播放历史记录，搜索历史记录等，方便用户再次使用。但是这些记录又不能无限的存储，只需要记录最新的50条或者100条就可以了，所以要求应用每插入一条新数据之后，对超过50条的数据进行清理。     本文以搜索历史记录为例，主要介绍sqlite中limit ，offset关键字的使用，最后给出此复合语句的写法。 建表     搜索历史记录只需要记录搜索关键词和搜索时间即可。所以我们需要这样的一张表：     表中只有两个字段（keyword , time）:其中keyword是唯一的，不允许重复；时间默认为写入数据库的默认时间，我们可是使用sqlite数据的datetime(‘now’)函数     好了，给出搜索历史记录（search_history）建表语句： CREATE TABLE [search_history] ([keyword] CHAR UNIQUE,[time] TIMESTAMP NOT NULL ON CONFLICT REPLACE DEFAULT (datetime(‘now’))) Sqlite之limit ，offset关键词   limit 语法有两种写法s   1. 一个参数 ： limit x      其中x是一个整数，表示返回x条目记录。    2.两个参数： limit x , y        其中x , y 都是整数，表示跳过x 条记录，返回 y 条记录，即 LIMIT <skip>, <count>     此外limit 还与offset关键词结合，语法是： limit x offset y      表示跳过 y 条记录，返回 x 条记录 ，即 LIMIT <count> OFFSET <skip>     乍一看 limit x , y 和limit x offset y  的语义很接近，千万不要搞混了。 复合SQL语句演练：     由于我们的表中只有上图所示4条数据，为了演示方便，我们将最大数量定位2，超过2条以上的数据将被删除。     在这里我们选用offset关键词，一步步获得超过2以后的记录。     1：首先计算keyword的数量，确保数据库中的条目大于最大值2 ，这是重要的条件之一。条件不成立，不进行删除操作。 select * from search_history where (select count(keyword) from search_history) >2     因为4>2 ,所以返回全部数据结果：   2：接下来，我们将按照时间(time字段)降序排列数据，筛选所有的关键词 select keyword from search_history order by time desc      返回结果：     3.  扩展第2步 ， 在按照时间(time字段)降序，获得超过最大值2以上的所有关键词。也就是在第2步的基础，加入limit关键词 select keyword from search_history order by time desc limit (select count(keyword) from search_history) offset 2    返回结果：     现在我们已经将超过最大值2以上的时间较早的搜索关键词查询出来了，大功即将搞成。接下下将这些数据删除即可，当然不要忘了加入我们第1步的条件。     4. 结合第一步的条件，最终复合sql语句就是：    delete from search_history where (select count(keyword) from search_history )> 2 and keyword in (select keyword from search_history order by time desc limit (select count(keyword) from search_history) offset 2 )   执行之后，可以看到超过最大值2的数据，也就是第3步中的数据都被删除了。重新查询之后的结果如下：   说明执行结果是正确的。   最后将最大值2改为50就可以了：   最终语句如下：    delete from search_history where (select count(keyword) from search_history )> 50 and keyword in (select keyword from search_history order by time desc limit (select count(keyword) from search_history) offset 50 )   原文链接：http://www.67tgb.com/?p=530   转载请注明出处：望月听涛","title":"Sqlite之删除超过50条的数据"},{"content":"一、基本概念 作用和网页开发中的CSS是一样的。样式用在单个控件上，主题应用在整个应用或一个或多个Activity上。   二、实例代码 在res/values文件夹下建立style.xml文件，该文件中体现了样式的继承。样式的覆盖和CSS一样，也是就近原则。 <?xml version=\"1.0\" encoding=\"utf-8\"?><resources>\t<!-- 样式中设置的属性针对某个控件 -->\t<style name=\"xyStyle\">\t\t<item name=\"android:textSize\">18dp<\/item>\t\t<item name=\"android:textColor\">#FF0000<\/item>\t<\/style>\t<!-- 继承方式1 -->\t<style name=\"txtViewStyle\" parent=\"xyStyle\">\t\t<item name=\"android:layout_width\">fill_parent<\/item>\t\t<item name=\"android:layout_height\">wrap_content<\/item>\t<\/style>\t<!-- 继承方式2 -->\t<style name=\"txtViewStyle.child\">\t\t<item name=\"android:textColor\">#0D9DF0<\/item>\t<\/style>\t\t<!-- 主题中设置的属性针对整个应用或某个Activity-->\t<style name=\"xyTheme\">\t\t<item name=\"android:windowNoTitle\">true<\/item>\t\t<!-- 表示引用android:windowNoTitle的值 -->\t\t<item name=\"android:windowFullscreen\">?android:windowNoTitle<\/item>\t<\/style><\/resources> <?xml version=\"1.0\" encoding=\"utf-8\"?><LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    android:orientation=\"vertical\"    android:layout_width=\"fill_parent\"    android:layout_height=\"fill_parent\">\t<TextView android:text=\"@string/hello\" style=\"@style/txtViewStyle.child\" /><\/LinearLayout>      <application android:icon=\"@drawable/icon\" android:label=\"@string/app_name\" android:theme=\"@style/xyTheme\">        <activity android:name=\".MainActivity\"                  android:label=\"@string/app_name\">            <intent-filter>                <action android:name=\"android.intent.action.MAIN\" />                <category android:name=\"android.intent.category.LAUNCHER\" />            <\/intent-filter>        <\/activity>    <\/application>    <uses-sdk android:minSdkVersion=\"8\" />","title":"Android开发23——样式和主题"},{"content":"            今天来实现以下大众点评客户端的横向listview二级列表，先看一下样式。    这种横向的listview二级列表在手机软件上还不太常见，但是使用过平板的都应该知道，在平板上市比较常见的。可能是因为平板屏幕比较大，而且也能展现更多的内容。     下面来看一下我的实现步骤。     首先自定义一个listview，代码如下： public class MyListView extends ListView implements Runnable {\tprivate float mLastDownY = 0f;     private int mDistance = 0;     private int mStep = 10;     private boolean mPositive = false;      public MyListView (Context context, AttributeSet attrs) {           super(context, attrs);     }      public MyListView (Context context, AttributeSet attrs, int defStyle) {           super(context, attrs, defStyle);     }      public MyListView (Context context) {           super(context);     }      @Override     public boolean onTouchEvent(MotionEvent event) {          switch (event.getAction()) {               case MotionEvent.ACTION_DOWN:                    if (mLastDownY == 0f && mDistance == 0) {                          mLastDownY = event.getY();                    return true;               }               break;      case MotionEvent.ACTION_CANCEL:            break;    case MotionEvent.ACTION_UP:           if (mDistance != 0) {            mStep = 1;            mPositive = (mDistance >= 0);            this.post(this);            return true;         }         mLastDownY = 0f;         mDistance = 0;         break;      case MotionEvent.ACTION_MOVE:         if (mLastDownY != 0f) {               mDistance = (int) (mLastDownY - event.getY());               if ((mDistance < 0 && getFirstVisiblePosition() == 0 && getChildAt(0).getTop() == 0) || (mDistance > 0 && getLastVisiblePosition() == getCount() - 1)) {                    mDistance /= 2;                    scrollTo(0, mDistance);                    return true;                }         }         mDistance = 0;         break;         }         return super.onTouchEvent(event);     }      public void run() {           mDistance += mDistance > 0 ? -mStep : mStep;           scrollTo(0, mDistance);           if ((mPositive && mDistance <= 0) || (!mPositive && mDistance >= 0)) {                 scrollTo(0, 0);                 mDistance = 0;                 mLastDownY = 0f;                 return;            }           mStep += 1;           this.postDelayed(this, 10);      } }     然后看一下xml的布局： <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:tools=\"http://schemas.android.com/tools\"    android:orientation=\"horizontal\"    android:layout_width=\"fill_parent\"    android:layout_height=\"fill_parent\" >   \t<com.example.multilistview.MyListView    \t\t    android:id=\"@+id/listView\"    \t\t    android:layout_width=\"wrap_content\"    \t\t    android:layout_height=\"wrap_content\"    \t\t    android:layout_weight=\"1\"     \t\t    android:choiceMode=\"singleChoice\"    \t\t    android:scrollbars=\"none\"    \t\t    android:divider=\"@drawable/listitem_divide\"    \t\t    android:listSelector=\"#00000000\"    \t\t    android:background=\"#e4e3de\"    \t\t    >    \t\t<\/com.example.multilistview.MyListView>       \t\t           \t\t <com.example.multilistview.MyListView       \t\t    android:id=\"@+id/subListView\"       \t\t    android:layout_width=\"wrap_content\"    \t\t    android:layout_height=\"wrap_content\"     \t\t    android:layout_weight=\"1\"    \t\t    android:background=\"#e4e3de\"    \t\t     >       \t\t               \t\t    <\/com.example.multilistview.MyListView>     <\/LinearLayout>      两个自定义的listview  横向布局，然后是父listview的适配器 public class MyAdapter extends BaseAdapter {\tContext context;\tLayoutInflater inflater;\tString [] foods;\tint last_item;\tint [] images;\tprivate int selectedPosition = -1;     \tpublic MyAdapter(Context context,String [] foods,int[] images){\t\tthis.context = context;\t\tthis.foods = foods;\t\tthis.images = images;\t\tinflater=LayoutInflater.from(context);\t}\t\t@Override\tpublic int getCount() {\t\t// TODO Auto-generated method stub\t\treturn foods.length;\t}\t@Override\tpublic Object getItem(int position) {\t\t// TODO Auto-generated method stub\t\treturn position;\t}\t@Override\tpublic long getItemId(int position) {\t\t// TODO Auto-generated method stub\t\treturn position;\t}\t@Override\tpublic View getView(int position, View convertView, ViewGroup parent) {\t\t// TODO Auto-generated method stub\t\tViewHolder  holder = null;\t    if(convertView==null){\t    convertView = inflater.inflate(R.layout.mylist_item, null);\t    holder = new ViewHolder();        holder.textView =(TextView)convertView.findViewById(R.id.textview);        holder.imageView =(ImageView)convertView.findViewById(R.id.imageview);        holder.layout=(LinearLayout)convertView.findViewById(R.id.colorlayout);        convertView.setTag(holder);\t    }\t    else{\t    holder=(ViewHolder)convertView.getTag();\t    }\t    // 设置选中效果    \t     if(selectedPosition == position)   \t    {   \t    \t holder.textView.setTextColor(Color.BLUE);   \t    \t     holder.layout.setBackgroundColor(Color.LTGRAY);   \t   } else {   \t\t   holder.textView.setTextColor(Color.WHITE);   \t    holder.layout.setBackgroundColor(Color.TRANSPARENT);   \t     }   \t   \t    holder.textView.setText(foods[position]);\t    holder.textView.setTextColor(Color.BLACK);\t    holder.imageView.setBackgroundResource(images[position]);\t    \t\treturn convertView;\t}\tpublic static class ViewHolder{\t\tpublic TextView textView;\t\tpublic ImageView  imageView;\t\tpublic LinearLayout layout;\t}\tpublic void setSelectedPosition(int position) {   \t   selectedPosition = position;   \t}   }  对应的 item布局： <?xml version=\"1.0\" encoding=\"utf-8\"?><LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    android:id=\"@+id/colorlayout\"    android:layout_width=\"fill_parent\"    android:layout_height=\"fill_parent\" >    <ImageView    android:id=\"@+id/imageview\"    android:layout_width=\"wrap_content\"    android:layout_height=\"wrap_content\"    android:layout_marginLeft=\"10dip\"    android:layout_marginTop=\"5dip\"    />    <TextView     android:id=\"@+id/textview\"    android:layout_width=\"wrap_content\"    android:layout_height=\"wrap_content\"    android:text=\"\"    android:textSize=\"16dip\"    android:layout_marginTop=\"8dip\"    android:layout_marginLeft=\"8dip\"    android:layout_marginBottom=\"8dip\"/>   <!--  android:background=\"@drawable/selector\"  自定义listview 样式--><\/LinearLayout>     然后是子适配器代码： public class SubAdapter extends BaseAdapter {\t\tContext context;\tLayoutInflater layoutInflater;\tString[][] cities;\tpublic int foodpoition;\tpublic SubAdapter(Context context, String[][] cities,int position) {\t\tthis.context = context;\t\tthis.cities = cities;\t\tlayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\t\tthis.foodpoition = position;\t}\t@Override\tpublic int getCount() {\t\t// TODO Auto-generated method stub\t\treturn cities.length;\t}\t@Override\tpublic Object getItem(int position) {\t\t// TODO Auto-generated method stub\t\treturn getItem(position);\t}\t@Override\tpublic long getItemId(int position) {\t\t// TODO Auto-generated method stub\t\treturn position;\t}\t@Override\tpublic View getView(int position, View convertView, ViewGroup parent) {\t\t// TODO Auto-generated method stub\t\tViewHolder viewHolder = null;\t\tfinal int location=position;\t\tif (convertView == null) {\t\t\tconvertView = layoutInflater.inflate(R.layout.sublist_item, null);\t\t\tviewHolder = new ViewHolder();\t\t\tviewHolder.textView = (TextView) convertView\t\t\t\t\t.findViewById(R.id.textview1);\t\t\tconvertView.setTag(viewHolder);\t\t} else {\t\t\tviewHolder = (ViewHolder) convertView.getTag();\t\t}\t\tviewHolder.textView.setText(cities[foodpoition][position]);\t\tviewHolder.textView.setTextColor(Color.BLACK);\t\t\t\treturn convertView;\t}\tpublic static class ViewHolder {\t\tpublic TextView textView;\t}}    对应的xml布局：    <?xml version=\"1.0\" encoding=\"utf-8\"?><LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    android:layout_width=\"wrap_content\"    android:layout_height=\"wrap_content\"       >     <TextView     android:id=\"@+id/textview1\"    android:layout_width=\"wrap_content\"    android:layout_height=\"wrap_content\"    android:text=\"aaaaa\"    android:textSize=\"16dip\"    android:layout_marginTop=\"10dip\"    android:layout_marginLeft=\"8dip\"    android:layout_marginBottom=\"8dip\"/><\/LinearLayout>         最后看下主activity的实现代码 public class MainActivity extends Activity {    \tprivate MyListView listView; \tprivate MyListView subListView;\tprivate MyAdapter myAdapter;\tprivate SubAdapter subAdapter;\t\tString cities[][] = new String[][] {            new String[] {\"全部美食\", \"本帮江浙菜\", \"川菜\", \"粤菜\", \"湘菜\",\"东北菜\",\"台湾菜\",\"新疆/清真\",\"素菜\",\"火锅\",\"自助餐\",\"小吃快餐\",\"日本\",\"韩国料理\",            \"东南亚菜\",\"西餐\",\"面包甜点\",\"其他\"},            new String[] {\"全部休闲娱乐\",\"咖啡厅\",\"酒吧\",\"茶馆\",\"KTV\",\"电影院\",\"游乐游艺\",\"公园\",\"景点/郊游\",\"洗浴\",\"足浴按摩\",\"文化艺术\",          \t\t\"DIY手工坊\",\"桌球馆\",\"桌面游戏\",\"更多休闲娱乐\"},            new String[] {\"全部购物\", \"综合商场\", \"服饰鞋包\", \"运动户外\",\"珠宝饰品\",\"化妆品\",\"数码家电\",\"亲子购物\",\"家居建材\"          \t\t,\"书店\",\"书店\",\"眼镜店\",\"特色集市\",\"更多购物场所\",\"食品茶酒\",\"超市/便利店\",\"药店\"},            new String[] {\"全部休闲娱乐\",\"咖啡厅\",\"酒吧\",\"茶馆\",\"KTV\",\"电影院\",\"游乐游艺\",\"公园\",\"景点/郊游\",\"洗浴\",\"足浴按摩\",\"文化艺术\",            \t\t\"DIY手工坊\",\"桌球馆\",\"桌面游戏\",\"更多休闲娱乐\"},            new String[] {\"全\",\"咖啡厅\",\"酒吧\",\"茶馆\",\"KTV\",\"游乐游艺\",\"公园\",\"景点/郊游\",\"洗浴\",\"足浴按摩\",\"文化艺术\",            \t\t\"DIY手工坊\",\"桌球馆\",\"桌面游戏\",\"更多休闲娱乐\"},            new String[] {\"全部\",\"咖啡厅\",\"酒吧\",\"茶馆\",\"电影院\",\"游乐游艺\",\"公园\",\"景点/郊游\",\"洗浴\",\"足浴按摩\",\"文化艺术\",            \t\t\"DIY手工坊\",\"桌球馆\",\"桌面游戏\",\"更多休闲娱乐\"},            new String[] {\"全部休\",\"咖啡厅\",\"酒吧\",\"茶馆\",\"KTV\",\"电影院\",\"游乐游艺\",\"公园\",\"景点/郊游\",\"洗浴\",\"足浴按摩\",\"文化艺术\",            \t\t\"DIY手工坊\",\"桌球馆\",\"桌面游戏\",\"更多休闲娱乐\"},            new String[] {\"全部休闲\",\"咖啡厅\",\"酒吧\",\"茶馆\",\"KTV\",\"电影院\",\"游乐游艺\",\"公园\",\"景点/郊游\",\"洗浴\",\"足浴按摩\",\"文化艺术\",            \t\t\"DIY手工坊\",\"桌球馆\",\"桌面游戏\",\"更多休闲娱乐\"},            new String[] {\"全部休闲娱\",\"咖啡厅\",\"酒吧\",\"茶馆\",\"KTV\",\"电影院\",\"游乐游艺\",\"公园\",\"景点/郊游\",\"洗浴\",\"足浴按摩\",\"文化艺术\",            \t\t\"DIY手工坊\",\"桌球馆\",\"桌面游戏\"},            new String[] {\"全部休闲娱乐\",\"咖啡厅\",\"酒吧\",\"茶馆\",\"KTV\",\"电影院\",\"游乐游艺\",\"公园\",\"景点/郊游\",\"洗浴\",\"足浴按摩\",\"文化艺术\",            \t\t\"DIY手工坊\",\"桌球馆\",\"桌面游戏\",\"更多休闲娱乐\"},            new String[] {\"全部休闲aaa\",\"咖啡厅\",\"酒吧\",\"茶馆\",\"KTV\",\"电影院\",\"游乐游艺\",\"公园\",\"景点/郊游\",\"洗浴\",\"足浴按摩\",\"文化艺术\",            \t\t\"DIY手工坊\",\"桌球馆\",\"桌面游戏\"},            };\t\tString foods[] =new String []{\"全部频道\",\"美食\",\"休闲娱乐\",\"购物\",\"酒店\",\"丽人\",\"运动健身\",\"结婚\",\"亲子\",\"爱车\",\"生活服务\"};\t\tint images[] = new int[]{R.drawable.ic_category_0,R.drawable.ic_category_10,R.drawable.ic_category_30,R.drawable.ic_category_20\t\t\t\t,R.drawable.ic_category_60,R.drawable.ic_category_50,R.drawable.ic_category_45,R.drawable.ic_category_50,R.drawable.ic_category_70,\t\t\t\tR.drawable.ic_category_65,R.drawable.ic_category_80};\t    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);                init();        myAdapter=new MyAdapter(getApplicationContext(), foods, images);        listView.setAdapter(myAdapter);            selectDefult();                listView.setOnItemClickListener(new OnItemClickListener() {\t\t\t@Override\t\t\tpublic void onItemClick(AdapterView<?> arg0, View arg1, int position,\t\t\t\t\tlong arg3) {\t\t\t\t// TODO Auto-generated method stub\t\t\t\tfinal int location=position;\t\t\t\tmyAdapter.setSelectedPosition(position);\t\t\t\tmyAdapter.notifyDataSetInvalidated();\t\t\t\tsubAdapter=new SubAdapter(getApplicationContext(), cities, position);\t\t\t\tsubListView.setAdapter(subAdapter);\t\t\t\tsubListView.setOnItemClickListener(new OnItemClickListener() {\t\t\t\t\t@Override\t\t\t\t\tpublic void onItemClick(AdapterView<?> arg0, View arg1,\t\t\t\t\t\t\tint position, long arg3) {\t\t\t\t\t\t// TODO Auto-generated method stub\t\t\t\t\t\tToast.makeText(getApplicationContext(), cities[location][position], Toast.LENGTH_SHORT).show();\t\t\t\t\t}\t\t\t\t});\t\t\t}\t\t});            }   private void init(){\t   listView=(MyListView) findViewById(R.id.listView);\t   subListView=(MyListView) findViewById(R.id.subListView);   }      private void selectDefult(){\t   final int location=0;\t \t\tmyAdapter.setSelectedPosition(0);\t \t\tmyAdapter.notifyDataSetInvalidated();\t \t\tsubAdapter=new SubAdapter(getApplicationContext(), cities, 0);\t \t\tsubListView.setAdapter(subAdapter);\t \t\tsubListView.setOnItemClickListener(new OnItemClickListener() {\t \t\t\t@Override\t \t\t\tpublic void onItemClick(AdapterView<?> arg0, View arg1,\t \t\t\t\t\tint position, long arg3) {\t \t\t\t\t// TODO Auto-generated method stub\t \t\t\t\tToast.makeText(getApplicationContext(), cities[location][position], Toast.LENGTH_SHORT).show();\t \t\t\t}\t \t\t});   }  }         默认我选中了第0个，下面看一下运行效果：      代码下载地址：点击打开链接","title":"android二级listview列表"},{"content":"[Cocos2d-x相关教程来源于红孩儿的游戏编程之路CSDN博客地址：http://blog.csdn.net/honghaier] 红孩儿Cocos2d-X学习园地QQ2群：44208467 加群写：Cocos2d-x  红孩儿Cocos2d-X学习园地QQ群：249941957 [暂满]加群写：Cocos2d-x  本章为我的Cocos2d-x教程一书初稿。望各位看官多提建议！ Cocos2d-x 2.0 网格动画深入分析 另：本章所用Cocos2d-x版本为: cocos2d-2.0-x-2.0.2 @ Aug 30 2012 http://cn.cocos2d-x.org/download         写在前面：请各位大大在转载博文时注明来源，红孩儿每天熬夜写博实属不易，但屡有一些同学拿来主义，把本博的文章去头掐尾，抹掉作者，然后赤裸裸的改成自已的 \" 原创  \"，实在令人气愤。在此特声明：本博博文，欢迎您收藏，转载，如果有需要，也可以借用段落或插图，请您经我同意，我不是一个刻板吝啬的人。但如果直接剽窃，我将奋起反击！                 在TestCpp中的EffectsTest示例中展示了一些屏幕特效，它是将屏幕划分为多个格子，并对这些格子进行了动画处理从而产生出相应的屏幕特效。今天我们来学习一下这些动画。 主要是涉及到以下几个文件： CCGrid.h /cpp :网格数据及渲染，包括基本网格数据和3D网格数据，这是数据的基础。 CCActionGrid.h /cpp :网格基本动画，这是动画的基础。 CCActionGrid3D.h/cpp: 3D网格基本动画，这是3D网格动画的基础。 CCActionTiledGrid.h / cpp :网格衍生动画，这是最终的特效实现。 咱们首先来看 关于网格数据及渲染的文件：CCGrid.h   #ifndef __EFFECTS_CCGRID_H__#define __EFFECTS_CCGRID_H__#include \"cocoa/CCObject.h\"#include \"base_nodes/CCNode.h\"#include \"CCCamera.h\"#include \"ccTypes.h\"#include \"textures/CCTexture2D.h\"#include \"CCDirector.h\"#include \"kazmath/mat4.h\"//使用Cocos2d命名空间NS_CC_BEGIN//当前.h文件要用到以下三个类的指针。class CCTexture2D;class CCGrabber;class CCGLProgram;//网格基类。由CCObject派生。class CC_DLL CCGridBase : public CCObject{public:\t//析构    virtual ~CCGridBase(void);    //是否激活状态。inline bool isActive(void) { return m_bActive; }//设置为激活状态。    void setActive(bool bActive);    //取得    inline int getReuseGrid(void) { return m_nReuseGrid; }    inline void setReuseGrid(int nReuseGrid) { m_nReuseGrid = nReuseGrid; }    //取得网格的大小。inline const ccGridSize& getGridSize(void) { return m_sGridSize; }//设置网格的大小。    inline void setGridSize(const ccGridSize& gridSize) { m_sGridSize = gridSize; }    //取得每个格子占用的图像点数。即图像大于与格子大小的比值。    inline const CCPoint& getStep(void) { return m_obStep; }    inline void setStep(const CCPoint& step) { m_obStep = step; }    //取得纹理是否上下反转inline bool isTextureFlipped(void) { return m_bIsTextureFlipped; }//设置纹理是否上下反转。    void setTextureFlipped(bool bFlipped);\t//初始化网格，参一为网格大小，参二为对应的纹理，参三为设置纹理是否反转。bool initWithSize(const ccGridSize& gridSize, CCTexture2D *pTexture, bool bFlipped);////初始化网格，参数为网格大小。    bool initWithSize(const ccGridSize& gridSize);\t\t//在渲染之前要做的处理。void beforeDraw(void);//在渲染之后要做的处理。void afterDraw(CCNode *pTarget);//渲染处理virtual void blit(void);//还原到原顶点位置virtual void reuse(void);//计算顶点缓冲    virtual void calculateVertexPoints(void);public:    //详细创建函数，参一为网格大小，参二为对应的纹理，参三为设置纹理是否反转。内部调用create实现。CC_DEPRECATED_ATTRIBUTE static CCGridBase* gridWithSize(const ccGridSize& gridSize, CCTexture2D *texture, bool flipped);    //简单创建函数，参数为网格大小。内部调用create实现。    CC_DEPRECATED_ATTRIBUTE static CCGridBase* gridWithSize(const ccGridSize& gridSize);    //对应详细创建函数的create实现。    static CCGridBase* create(const ccGridSize& gridSize, CCTexture2D *texture, bool flipped);//对应简单创建函数的create实现。static CCGridBase* create(const ccGridSize& gridSize);\t//设置2D投影矩阵。    void set2DProjection(void);protected:\t//是否被激活。    bool m_bActive;int  m_nReuseGrid;//格子大小ccGridSize m_sGridSize;//所用纹理CCTexture2D *m_pTexture;//每格的图像点数CCPoint m_obStep;//将屏幕画面渲染到纹理的处理器。CCGrabber *m_pGrabber;//纹理是否上下反转。bool m_bIsTextureFlipped;//Shader代码片段指针。CCGLProgram* m_pShaderProgram;//投影方式    ccDirectorProjection m_directorProjection;};对应CPP：//简单创建函数，参一为网格大小，参二为对应的纹理，参三为设置纹理是否反转。内部调用create实现。CCGridBase* CCGridBase::gridWithSize(const ccGridSize& gridSize){    return CCGridBase::create(gridSize);}//对应简单创建函数的create实现。CCGridBase* CCGridBase::create(const ccGridSize& gridSize){\t//先new出一个当前类实例。    CCGridBase *pGridBase = new CCGridBase();\t//如果成功    if (pGridBase){\t //进行初始化。        if (pGridBase->initWithSize(gridSize))        {\t\t\t //如果初始化成功交由内存管理器进行管理。            pGridBase->autorelease();        }        else        {\t\t\t //如果失败释放并置空。            CC_SAFE_RELEASE_NULL(pGridBase);        }    }\t//如果成功返回创建的类实例，否则反回NULL。    return pGridBase;}//详细创建函数，参数为网格大小。内部调用create实现。CCGridBase* CCGridBase::gridWithSize(const ccGridSize& gridSize, CCTexture2D *texture, bool flipped){    return CCGridBase::create(gridSize, texture, flipped);}//对应详细创建函数的create实现。CCGridBase* CCGridBase::create(const ccGridSize& gridSize, CCTexture2D *texture, bool flipped){\t//先new出一个当前类实例。    CCGridBase *pGridBase = new CCGridBase();\t//如果成功    if (pGridBase)    {\t//进行初始化。        if (pGridBase->initWithSize(gridSize, texture, flipped))        {   //如果初始化成功交由内存管理器进行管理。            pGridBase->autorelease();        }        else        {  //如果失败释放并置空。            CC_SAFE_RELEASE_NULL(pGridBase);        }    }\t//如果成功返回创建的类实例，否则反回NULL。    return pGridBase;}//初始化函数。bool CCGridBase::initWithSize(const ccGridSize& gridSize, CCTexture2D *pTexture, bool bFlipped){    bool bRet = true;\t//未激活。    m_bActive = false;m_nReuseGrid = 0;//保存格子大小。    m_sGridSize = gridSize;\t//保存纹理。m_pTexture = pTexture;//占用纹理，对其引用计数器加一操作。CC_SAFE_RETAIN(m_pTexture);//保存是否进行纹理反转的变量。    m_bIsTextureFlipped = bFlipped;\t//取得纹理中的图像大小。const CCSize& texSize = m_pTexture->getContentSize();//计算出一个格子所占的纹理寻址长度。    m_obStep.x = texSize.width / m_sGridSize.x;    m_obStep.y = texSize.height / m_sGridSize.y;\t//新建一个屏幕图像获取器，这家伙是干嘛的？其实就是一个获取屏幕图像的类，可以将屏幕上渲染出的图像输出到一张指定的纹理中，类似DX中的RTT。    m_pGrabber = new CCGrabber();    if (m_pGrabber){\t //将纹理设置为输出纹理。        m_pGrabber->grab(m_pTexture);    }    else{\t //如果图像获取器创建失败，做下返回值处理。        bRet = false;    }    //取得对应的Shader代码片段。m_pShaderProgram = CCShaderCache::sharedShaderCache()->programForKey(kCCShader_PositionTexture);//计算所要用到的顶点数据并创建顶点缓冲区。    calculateVertexPoints();    return bRet;}//初始化。bool CCGridBase::initWithSize(const ccGridSize& gridSize){\t//取得设备指针，并通过它取得屏幕大小。    CCDirector *pDirector = CCDirector::sharedDirector();    CCSize s = pDirector->getWinSizeInPixels();    //计算相应大小对应的2次幂大小。    unsigned long POTWide = ccNextPOT((unsigned int)s.width);    unsigned long POTHigh = ccNextPOT((unsigned int)s.height);    // 使用ARGB8888格式。    CCTexture2DPixelFormat format = kCCTexture2DPixelFormat_RGBA8888;\t//创建相应的像素绘冲区。    void *data = calloc((int)(POTWide * POTHigh * 4), 1);    if (! data)    {        CCLOG(\"cocos2d: CCGrid: not enough memory.\");        this->release();        return false;}\t//创建一个纹理。CCTexture2D *pTexture = new CCTexture2D();//使用像素数据初始化纹理。    pTexture->initWithData(data, format, POTWide, POTHigh, s);    //释放像素数据。    free(data);\t//如果失败，返回false。    if (! pTexture)    {        CCLOG(\"cocos2d: CCGrid: error creating texture\");        delete this;        return false;    }\t//使用创建的纹理初始化    initWithSize(gridSize, pTexture, false);\t//释放纹理。pTexture->release();    return true;}//析构。CCGridBase::~CCGridBase(void){    CCLOGINFO(\"cocos2d: deallocing %p\", this);//释放纹理。CC_SAFE_RELEASE(m_pTexture);//释放屏幕    CC_SAFE_RELEASE(m_pGrabber);}//设置激活。void CCGridBase::setActive(bool bActive){\t//保存激活设置    m_bActive = bActive;    if (! bActive){\t //如果未激活，复原投影矩阵。        CCDirector *pDirector = CCDirector::sharedDirector();        ccDirectorProjection proj = pDirector->getProjection();        pDirector->setProjection(proj);    }}//设置纹理反转。void CCGridBase::setTextureFlipped(bool bFlipped){\t//如果参数与原设置不同，更新设置并计算顶点缓冲。    if (m_bIsTextureFlipped != bFlipped)    {        m_bIsTextureFlipped = bFlipped;        calculateVertexPoints();    }}//设置2D投影。void CCGridBase::set2DProjection(){\t//取得窗口大小    CCDirector *director = CCDirector::sharedDirector();    CCSize    size = director->getWinSizeInPixels();\t//重新设置视口大小glViewport(0, 0, (GLsizei)(size.width * CC_CONTENT_SCALE_FACTOR()), (GLsizei)(size.height * CC_CONTENT_SCALE_FACTOR()) );//开始设置投影矩阵。kmGLMatrixMode(KM_GL_PROJECTION);//先将投影矩阵单位化。    kmGLLoadIdentity();\t//创建一个矩阵变量。kmMat4 orthoMatrix;//通过参数生成出投影矩阵变量的值，此处使用的是正交投影矩阵。kmMat4OrthographicProjection(&orthoMatrix, 0, size.width * CC_CONTENT_SCALE_FACTOR(), 0, size.height * CC_CONTENT_SCALE_FACTOR(), -1, 1);//将原单位化矩阵与正交投影矩阵相乘，当然还是正交投影矩阵了，做为投影矩阵的结果。    kmGLMultMatrix( &orthoMatrix );\t//下面开始设置模型观察矩阵。kmGLMatrixMode(KM_GL_MODELVIEW);//将矩阵单位化。    kmGLLoadIdentity();\t//设置投影矩阵。    ccSetProjectionMatrixDirty();}//在开始渲染前的处理。void CCGridBase::beforeDraw(void){    // 先取得当前的投影矩阵保存到变量中    CCDirector *director = CCDirector::sharedDirector();    m_directorProjection = director->getProjection();    // 设置新的投影矩阵。set2DProjection();// 设置开启屏幕渲染到纹理。    m_pGrabber->beforeRender(m_pTexture);}//在渲染结束后的处理。void CCGridBase::afterDraw(cocos2d::CCNode *pTarget){\t//设置完成屏幕渲染到纹理。    m_pGrabber->afterRender(m_pTexture);    //恢复原投影矩阵。    CCDirector *director = CCDirector::sharedDirector();    director->setProjection(m_directorProjection);\t//    if (pTarget->getCamera()->isDirty()){\t //取得演示的锚点做为摄像机的矩阵转换中心点。        const CCPoint& offset = pTarget->getAnchorPointInPoints();\t\t//注意：下面三句的意义是对摄像机进行矩阵变换，这个矩阵变换是相对于自身中心点位置，俗称自身矩阵变换。        //先将当前模型矩阵偏移到这个中心点。        kmGLTranslatef(offset.x, offset.y, 0);\t\t //进行本地矩阵的转换        pTarget->getCamera()->locate();\t\t //恢复原位置。        kmGLTranslatef(-offset.x, -offset.y, 0);\t\t    }\t//设置使用纹理。    ccGLBindTexture2D(m_pTexture->getName());    // restore projection for default FBO .fixed bug #543 #544//TODO:         CCDirector::sharedDirector()->setProjection(CCDirector::sharedDirector()->getProjection());//TODO:         CCDirector::sharedDirector()->applyOrientation();\t//进行渲染    blit();}//进行渲染void CCGridBase::blit(void){    CCAssert(0, \"\");}//还原到原来顶点位置。void CCGridBase::reuse(void){    CCAssert(0, \"\");}//计算顶点缓冲区。void CCGridBase::calculateVertexPoints(void){    CCAssert(0, \"\");}//3D网格类，派生于格子基类，class CC_DLL CCGrid3D : public CCGridBase{public:\t//构造CCGrid3D();//析构    ~CCGrid3D(void);    //返回对应位置的顶点。    ccVertex3F vertex(const ccGridSize& pos);    //返回对应位置的原始顶点。    ccVertex3F originalVertex(const ccGridSize& pos);    //设置对应位置的顶点。    void setVertex(const ccGridSize& pos, const ccVertex3F& vertex);\t//重载基类的函数。\t//渲染。virtual void blit(void);//还原到原来顶点位置virtual void reuse(void);//计算顶点缓冲。    virtual void calculateVertexPoints(void);public:    //静态函数：详细参数的创建3D网格，参一为格子大小，参二为纹理指针，参三为是否进行纹理反转,内部调用create实现。    CC_DEPRECATED_ATTRIBUTE static CCGrid3D* gridWithSize(const ccGridSize& gridSize, CCTexture2D *pTexture, bool bFlipped);    //静态函数：简单参数的创建3D网格，参数为格子大小,内部调用create实现。    CC_DEPRECATED_ATTRIBUTE static CCGrid3D* gridWithSize(const ccGridSize& gridSize);        //详细参数的创建3D网格    static CCGrid3D* create(const ccGridSize& gridSize, CCTexture2D *pTexture, bool bFlipped);    //简单参数的创建3D网格    static CCGrid3D* create(const ccGridSize& gridSize);    protected:\t//顶点缓冲指针_纹理UVGLvoid *m_pTexCoordinates;//顶点缓冲指针_位置GLvoid *m_pVertices;//原始顶点缓冲指针_位置GLvoid *m_pOriginalVertices;//索引缓冲指针    GLushort *m_pIndices;};对应CPP：//静态函数：详细参数的创建3D网格，参一为格子大小，参二为纹理指针，参三为是否进行纹理反转,内部调用create实现。CCGrid3D* CCGrid3D::gridWithSize(const ccGridSize& gridSize, CCTexture2D *pTexture, bool bFlipped){    return CCGrid3D::create(gridSize, pTexture, bFlipped);}//上面的create实现CCGrid3D* CCGrid3D::create(const ccGridSize& gridSize, CCTexture2D *pTexture, bool bFlipped){\t//先new出一个当前类实例    CCGrid3D *pRet= new CCGrid3D();\t//如果成功    if (pRet){\t//初始化并交由内存管理器进行引用计数器的管理        if (pRet->initWithSize(gridSize, pTexture, bFlipped))        {            pRet->autorelease();        }        else        {\t//如果失败，则释放并置空。            delete pRet;            pRet = NULL;        }    }\t//返回结果。    return pRet;}//简单参数的创建3D网格,内部调用create实现。CCGrid3D* CCGrid3D::gridWithSize(const ccGridSize& gridSize){    return CCGrid3D::create(gridSize);}//上面函数的create实现。CCGrid3D* CCGrid3D::create(const ccGridSize& gridSize){\t//先new出一个当前类实例    CCGrid3D *pRet= new CCGrid3D();\t//如果成功    if (pRet){\t//初始化并交由内存管理器进行引用计数器的管理        if (pRet->initWithSize(gridSize))        {            pRet->autorelease();        }        else        {\t//如果失败，则释放并置空。            delete pRet;            pRet = NULL;        }    }//返回结果。    return pRet;}//构造CCGrid3D::CCGrid3D()    : m_pTexCoordinates(NULL)    , m_pVertices(NULL)    , m_pOriginalVertices(NULL)    , m_pIndices(NULL){}//析构CCGrid3D::~CCGrid3D(void){\t//释放各缓冲区    CC_SAFE_FREE(m_pTexCoordinates);    CC_SAFE_FREE(m_pVertices);    CC_SAFE_FREE(m_pIndices);    CC_SAFE_FREE(m_pOriginalVertices);}//进行渲染处理void CCGrid3D::blit(void){\t//计算格子的数量    int n = m_sGridSize.x * m_sGridSize.y;    //设置渲染顶点的格式ccGLEnableVertexAttribs( kCCVertexAttribFlag_Position | kCCVertexAttribFlag_TexCoords );//开启使用Shaderm_pShaderProgram->use();//设置Shader中的 顶点矩阵，其值 = 投影矩阵X模型矩阵X观察矩阵的结果，用于在Shader中进行顶点的最终位置计算。    m_pShaderProgram->setUniformForModelViewProjectionMatrix();;    //顶点缓冲中位置属性的指定。    glVertexAttribPointer(kCCVertexAttrib_Position, 3, GL_FLOAT, GL_FALSE, 0, m_pVertices);    //顶点缓冲中纹理贴图UV属性的指定。    glVertexAttribPointer(kCCVertexAttrib_TexCoords, 2, GL_FLOAT, GL_FALSE, 0, m_pTexCoordinates);\t//绘制三角形，每个格子两个三角形，使用GL_TRIANGLES方式进行绘制，则每个格子需要6个顶点。所以顶点数为n*6,渲染时按照索引绘冲m_pIndices所指定的三角形顶点索引来进行绘制。glDrawElements(GL_TRIANGLES, (GLsizei) n*6, GL_UNSIGNED_SHORT, m_pIndices);//增加一次DP统计值。    CC_INCREMENT_GL_DRAWS(1);}//计算顶点缓冲数据void CCGrid3D::calculateVertexPoints(void){\t//取得纹理的宽高。    float width = (float)m_pTexture->getPixelsWide();float height = (float)m_pTexture->getPixelsHigh();//取得纹理中图像区域的高度。    float imageH = m_pTexture->getContentSizeInPixels().height;\t//定义临时变量。int x, y, i;//如果相应的顶点缓冲数据有值，先释放干净并置空。    CC_SAFE_FREE(m_pVertices);    CC_SAFE_FREE(m_pOriginalVertices);    CC_SAFE_FREE(m_pTexCoordinates);    CC_SAFE_FREE(m_pIndices);\t//计算总顶点数，每一行的顶点数为格子列数+1，每一列的顶点数为格子行数+1。    unsigned int numOfPoints = (m_sGridSize.x+1) * (m_sGridSize.y+1);\t//为相应的顶点缓冲区申请相应大小的内存。\t//m_pVertices中存入的是顶点位置，使用ccVertex3F来存储。所申请的内存大小即为顶点数乘以ccVertex3F的字节数大小。m_pVertices = malloc(numOfPoints * sizeof(ccVertex3F));//同上。m_pOriginalVertices = malloc(numOfPoints * sizeof(ccVertex3F));//纹理UV使用ccVertex2F来存储。m_pTexCoordinates = malloc(numOfPoints * sizeof(ccVertex2F));//索引缓冲m_pIndices使用GLushort来存储绘制三角形所用的顶点的索引值，因为每个面3个索引，一个格子就需要6个索引。    m_pIndices = (GLushort*)malloc(m_sGridSize.x * m_sGridSize.y * sizeof(GLushort) * 6);\t\t//为了方便填充数据，将缓冲区地址转换成相应的指针变量。    GLfloat *vertArray = (GLfloat*)m_pVertices;    GLfloat *texArray = (GLfloat*)m_pTexCoordinates;    GLushort *idxArray = m_pIndices;\t//双循环遍历每个格子。    for (x = 0; x < m_sGridSize.x; ++x)    {        for (y = 0; y < m_sGridSize.y; ++y)        {\t\t\t //取得格子索引。            int idx = (y * m_sGridSize.x) + x;\t\t\t //取得格子的左上角和右下角在图像中的相应位置。m_obStep是每个格子占用的图像点数。            GLfloat x1 = x * m_obStep.x;            GLfloat x2 = x1 + m_obStep.x;            GLfloat y1 = y * m_obStep.y;            GLfloat y2= y1 + m_obStep.y;\t\t\t //取得格子的四个顶点的索引。            GLushort a = (GLushort)(x * (m_sGridSize.y + 1) + y);            GLushort b = (GLushort)((x + 1) * (m_sGridSize.y + 1) + y);            GLushort c = (GLushort)((x + 1) * (m_sGridSize.y + 1) + (y + 1));            GLushort d = (GLushort)(x * (m_sGridSize.y + 1) + (y + 1));\t\t\t //按照三角形的绘制方式将格子顶点的索引组成两个三角形的顶点索引。            GLushort tempidx[6] = {a, b, d, b, c, d};\t\t\t //填充到相应的索引缓冲中。            memcpy(&idxArray[6*idx], tempidx, 6*sizeof(GLushort));\t\t\t  //格子四个顶点的位置。            int l1[4] = {a*3, b*3, c*3, d*3};            ccVertex3F e = {x1, y1, 0};            ccVertex3F f = {x2, y1, 0};            ccVertex3F g = {x2, y2, 0};            ccVertex3F h = {x1, y2, 0};            ccVertex3F l2[4] = {e, f, g, h};            int tex1[4] = {a*2, b*2, c*2, d*2};            CCPoint tex2[4] = {ccp(x1, y1), ccp(x2, y1), ccp(x2, y2), ccp(x1, y2)};\t\t\t //遍历放入相应的顶点位置和纹理UV中。            for (i = 0; i < 4; ++i)            {\t\t\t\t  //顶点的x,y,z                vertArray[l1[i]] = l2[i].x;                vertArray[l1[i] + 1] = l2[i].y;                vertArray[l1[i] + 2] = l2[i].z;\t\t\t\t  //纹理U值                texArray[tex1[i]] = tex2[i].x / width;\t\t\t\t  //纹理V值                if (m_bIsTextureFlipped)                {\t\t\t\t\t  //上下反转                    texArray[tex1[i] + 1] = (imageH - tex2[i].y) / height;                }                else                {\t\t\t\t\t  //正常                    texArray[tex1[i] + 1] = tex2[i].y / height;                }            }        }    }\t//将顶点位置数据填充到保存原始顶点位置的内存中。    memcpy(m_pOriginalVertices, m_pVertices, (m_sGridSize.x+1) * (m_sGridSize.y+1) * sizeof(ccVertex3F));}//返回对应网格位置的顶点。ccVertex3F CCGrid3D::vertex(const ccGridSize& pos){\t//通过网格位置计算出起始顶点的索引。int index = (pos.x * (m_sGridSize.y+1) + pos.y) * 3;//为方便获取顶点数据，将顶点缓冲地址转换为相应的指针变量。    float *vertArray = (float*)m_pVertices;\t//通过索引取得相应的顶点x,y,z。    ccVertex3F vert = {vertArray[index], vertArray[index+1], vertArray[index+2]};\t//返回顶点    return vert;}//返回网格对应位置的原始顶点。ccVertex3F CCGrid3D::originalVertex(const ccGridSize& pos){\t//通过格子位置计算出起始顶点的索引。    int index = (pos.x * (m_sGridSize.y+1) + pos.y) * 3; //为方便获取顶点数据，将顶点缓冲地址转换为相应的指针变量。float *vertArray = (float*)m_pOriginalVertices;\t//通过索引取得相应的顶点x,y,z。    ccVertex3F vert = {vertArray[index], vertArray[index+1], vertArray[index+2]};\t//返回顶点    return vert;}//设置对应网格位置的顶点。void CCGrid3D::setVertex(const ccGridSize& pos, const ccVertex3F& vertex){\t//通过格子位置计算出起始顶点的索引。int index = (pos.x * (m_sGridSize.y + 1) + pos.y) * 3;//为方便获取顶点数据，将顶点缓冲地址转换为相应的指针变量。float *vertArray = (float*)m_pVertices;设置对应索引位置的顶点的x,y,z。    vertArray[index] = vertex.x;    vertArray[index+1] = vertex.y;    vertArray[index+2] = vertex.z;}//还原原来位置。void CCGrid3D::reuse(void){\t//如果还原格子的变量大于0。    if (m_nReuseGrid > 0){\t //将原始顶点位置拷贝到顶点缓冲中。        memcpy(m_pOriginalVertices, m_pVertices, (m_sGridSize.x+1) * (m_sGridSize.y+1) * sizeof(ccVertex3F));\t\t//还原格子的变量做减1操作。        --m_nReuseGrid;    }}//这也是一个网格类，但它在网格的每个位置点存的不是一个顶点，而是一个四边形格子。class CC_DLL CCTiledGrid3D : public CCGridBase{public:\t//构造CCTiledGrid3D();//析构    ~CCTiledGrid3D(void);    //返回相应位置的格子数据    ccQuad3 tile(const ccGridSize& pos);    //返回原始位置的格子数据。    ccQuad3 originalTile(const ccGridSize& pos);    //设置相应位置的格子数据。    void setTile(const ccGridSize& pos, const ccQuad3& coords);\t//重载相应基类函数。    virtual void blit(void);    virtual void reuse(void);    virtual void calculateVertexPoints(void);public:\t//静态函数：创建一个当前类的实例。参一为格子大小，参二为对应的纹理，参三为是否进行纹理反转。内部调用create实现。CC_DEPRECATED_ATTRIBUTE static CCTiledGrid3D* gridWithSize(const ccGridSize& gridSize, CCTexture2D *pTexture, bool bFlipped);//上面函数的简化版本。    CC_DEPRECATED_ATTRIBUTE static CCTiledGrid3D* gridWithSize(const ccGridSize& gridSize);    //对应创建函数的实现。    static CCTiledGrid3D* create(const ccGridSize& gridSize, CCTexture2D *pTexture, bool bFlipped);    //对应创建函数的实现。    static CCTiledGrid3D* create(const ccGridSize& gridSize);    protected:\t//所要用到的顶点数据缓冲区。    GLvoid *m_pTexCoordinates;    GLvoid *m_pVertices;    GLvoid *m_pOriginalVertices;    GLushort *m_pIndices;};对应CPP：//构造函数。CCTiledGrid3D::CCTiledGrid3D()    : m_pTexCoordinates(NULL)    , m_pVertices(NULL)    , m_pOriginalVertices(NULL)    , m_pIndices(NULL){}//析构函数。CCTiledGrid3D::~CCTiledGrid3D(void){\t//释放各顶点所用的数据缓冲区。    CC_SAFE_FREE(m_pTexCoordinates);    CC_SAFE_FREE(m_pVertices);    CC_SAFE_FREE(m_pOriginalVertices);    CC_SAFE_FREE(m_pIndices);}//静态函数：创建一个当前类的实例。参一为格子大小，参二为对应的纹理，参三为是否进行纹理反转。内部调用create实现。CCTiledGrid3D* CCTiledGrid3D::gridWithSize(const ccGridSize& gridSize, CCTexture2D *pTexture, bool bFlipped){    return CCTiledGrid3D::create(gridSize, pTexture, bFlipped);}//上面函数的具体实现。CCTiledGrid3D* CCTiledGrid3D::create(const ccGridSize& gridSize, CCTexture2D *pTexture, bool bFlipped){\t//先用new创建一个当前类的实例。    CCTiledGrid3D *pRet= new CCTiledGrid3D();\t//如果成功。    if (pRet){\t//进行初始化并交由内存管理器进行引用计数器的管理。        if (pRet->initWithSize(gridSize, pTexture, bFlipped))        {            pRet->autorelease();        }        else        {\t\t\t //如果失败，释放new出来的实例指针并置空。            delete pRet;            pRet = NULL;        }    }\t//返回实例指针。    return pRet;}//静态函数：创建一个当前类的实例。简化版本。CCTiledGrid3D* CCTiledGrid3D::gridWithSize(const ccGridSize& gridSize){    return CCTiledGrid3D::create(gridSize);}//上面函数的具体实现。CCTiledGrid3D* CCTiledGrid3D::create(const ccGridSize& gridSize){\t//先用new创建一个当前类的实例。    CCTiledGrid3D *pRet= new CCTiledGrid3D();    if (pRet){\t/进行初始化并交由内存管理器进行引用计数器的管理。        if (pRet->initWithSize(gridSize))        {            pRet->autorelease();        }        else        {\t\t\t//如果失败，释放new出来的实例指针并置空。            delete pRet;            pRet = NULL;        }    }\t//返回实例指针。    return pRet;}//实际渲染处理。void CCTiledGrid3D::blit(void){\t//取得格子的数量。    int n = m_sGridSize.x * m_sGridSize.y;    //开启使用shader片段m_pShaderProgram->use();//设置Shader中的 顶点矩阵，其值 = 投影矩阵X模型矩阵X观察矩阵的结果，用于在Shader中进行顶点的最终位置计算。    m_pShaderProgram->setUniformForModelViewProjectionMatrix();    //设置顶点缓冲的结构，由位置和纹理坐构构成。ccGLEnableVertexAttribs( kCCVertexAttribFlag_Position | kCCVertexAttribFlag_TexCoords );    //顶点缓冲中位置属性的指定       glVertexAttribPointer(kCCVertexAttrib_Position, 3, GL_FLOAT, GL_FALSE, 0, m_pVertices);    //纹理坐标通道    glVertexAttribPointer(kCCVertexAttrib_TexCoords, 2, GL_FLOAT, GL_FALSE, 0, m_pTexCoordinates);//绘制图形    glDrawElements(GL_TRIANGLES, (GLsizei)n*6, GL_UNSIGNED_SHORT, m_pIndices);\t//更新DP统计    CC_INCREMENT_GL_DRAWS(1);}//计算顶点缓冲的数据void CCTiledGrid3D::calculateVertexPoints(void){\t//取得纹理的宽高    float width = (float)m_pTexture->getPixelsWide();float height = (float)m_pTexture->getPixelsHigh();//取得纹理中图像区域的高度。    float imageH = m_pTexture->getContentSizeInPixels().height;    //定义临时变量。    int numQuads = m_sGridSize.x * m_sGridSize.y;//如果相应的顶点缓冲数据有值，先释放干净并置空。 CC_SAFE_FREE(m_pVertices);    CC_SAFE_FREE(m_pOriginalVertices);    CC_SAFE_FREE(m_pTexCoordinates);    CC_SAFE_FREE(m_pIndices);//为相应的顶点缓冲区申请相应大小的内存。    m_pVertices = malloc(numQuads*4*sizeof(ccVertex3F));    m_pOriginalVertices = malloc(numQuads*4*sizeof(ccVertex3F));    m_pTexCoordinates = malloc(numQuads*4*sizeof(ccVertex2F));    m_pIndices = (GLushort*)malloc(numQuads*6*sizeof(GLushort));\t//为了方便填充数据，将缓冲区地址转换成相应的指针变量。    GLfloat *vertArray = (GLfloat*)m_pVertices;    GLfloat *texArray = (GLfloat*)m_pTexCoordinates;    GLushort *idxArray = m_pIndices;        int x, y;       //双循环遍历每个格子。    for (x = 0; x < m_sGridSize.x; ++x)    {        for (y = 0; y < m_sGridSize.y; ++y)        {\t\t\t //取得格子的左上角和右下角在图像中的位置。            float x1 = x * m_obStep.x;            float x2 = x1 + m_obStep.x;            float y1 = y * m_obStep.y;            float y2 = y1 + m_obStep.y;            //填充数据            *vertArray++ = x1;            *vertArray++ = y1;            *vertArray++ = 0;            *vertArray++ = x2;            *vertArray++ = y1;            *vertArray++ = 0;            *vertArray++ = x1;            *vertArray++ = y2;            *vertArray++ = 0;            *vertArray++ = x2;            *vertArray++ = y2;            *vertArray++ = 0;                        float newY1 = y1;            float newY2 = y2;            //如果纹理V值上下反转，则做下处理。            if (m_bIsTextureFlipped)             {                newY1 = imageH - y1;                newY2 = imageH - y2;            }\t\t\t //填充数据。            *texArray++ = x1 / width;            *texArray++ = newY1 / height;            *texArray++ = x2 / width;            *texArray++ = newY1 / height;            *texArray++ = x1 / width;            *texArray++ = newY2 / height;            *texArray++ = x2 / width;            *texArray++ = newY2 / height;        }    }    //索引缓冲数据填充。    for (x = 0; x < numQuads; x++)    {        idxArray[x*6+0] = (GLushort)(x * 4 + 0);        idxArray[x*6+1] = (GLushort)(x * 4 + 1);        idxArray[x*6+2] = (GLushort)(x * 4 + 2);                idxArray[x*6+3] = (GLushort)(x * 4 + 1);        idxArray[x*6+4] = (GLushort)(x * 4 + 2);        idxArray[x*6+5] = (GLushort)(x * 4 + 3);    }    //填充原始位置顶点缓冲    memcpy(m_pOriginalVertices, m_pVertices, numQuads * 12 * sizeof(GLfloat));} //设置相应位置的格子数据。void CCTiledGrid3D::setTile(const ccGridSize& pos, const ccQuad3& coords){\t//先计算出对应格子的顶点索引int idx = (m_sGridSize.y * pos.x + pos.y) * 4 * 3;//为了方便填充数据，将缓冲区地址转换成相应的指针变量。float *vertArray = (float*)m_pVertices;//填充对应的数据    memcpy(&vertArray[idx], &coords, sizeof(ccQuad3));}//返回原始位置的格子数据。ccQuad3 CCTiledGrid3D::originalTile(const ccGridSize& pos){\t//先计算出对应格子的顶点索引    int idx = (m_sGridSize.y * pos.x + pos.y) * 4 * 3;//为了方便取得数据，将缓冲区地址转换成相应的指针变量。float *vertArray = (float*)m_pOriginalVertices;\t//定义变量值做为返回结果。ccQuad3 ret;//由索引取得数据填充到返回值中。    memcpy(&ret, &vertArray[idx], sizeof(ccQuad3));    return ret;}//返回相应位置的格子数据ccQuad3 CCTiledGrid3D::tile(const ccGridSize& pos){\t//先计算出对应格子的顶点索引int idx = (m_sGridSize.y * pos.x + pos.y) * 4 * 3;//为了方便取得数据，将缓冲区地址转换成相应的指针变量。    float *vertArray = (float*)m_pVertices;\t//定义变量值做为返回结果。ccQuad3 ret;//由索引取得数据填充到返回值中。    memcpy(&ret, &vertArray[idx], sizeof(ccQuad3));    return ret;}//恢复为原始顶点void CCTiledGrid3D::reuse(void){\t//如果还原格子的变量大于0。    if (m_nReuseGrid > 0)    {        int numQuads = m_sGridSize.x * m_sGridSize.y;\t\t//将原始顶点位置拷贝到顶点缓冲中。        memcpy(m_pOriginalVertices, m_pVertices, numQuads * 12 * sizeof(GLfloat));//还原格子的变量做减1操作。        --m_nReuseGrid;    }} 上面讲的是网格的的数据和渲染基类CCGridBase及其派生CCGrid3D和CCTiledGrid3D，CCGridBase的关键是处理了将屏幕渲染到纹理这个功能。 它有两个重要的函数： //在渲染之前要做的处理。 voidbeforeDraw(void); //在渲染之后要做的处理。 voidafterDraw(CCNode *pTarget); 我们来看一下这两个函数是在哪里调用的。 经过搜索，我们可以在CCNode.h中发现这一句：     /** A CCGrid object that is used when applying effects */     CC_PROPERTY(CCGridBase *, m_pGrid, Grid) 即每个CCNode有一个CCGridBase类型的成员指针变量。在其cpp的visit中发现了要找的东西。 void CCNode::visit(){    if (!m_bIsVisible)    {        return;    }     kmGLPushMatrix();     //如果m_pGrid有值并且被激活则开启渲染到纹理。     if (m_pGrid && m_pGrid->isActive())     {         m_pGrid->beforeDraw(); } //相应结点的渲染处理。 …    //如果m_pGrid有值并且被激活则关闭渲染到纹理，这样当前结点上所有绘制的图像都被输出到m_pGrid中对应的纹理中了。     if (m_pGrid && m_pGrid->isActive())     {         m_pGrid->afterDraw(this);    }     kmGLPopMatrix();} 而CCGrid3D是一个基本的网格渲染类，他内部有所需要的顶点缓冲区。可以实现带纹理贴图的网格渲染功能。 CCTiledGrid3D比较有趣，它与CCGrid3D的不同之处是它的网格不是由一个个顶点构成，而是由一个个四边形构成，CCGrid3D所表现的是网格各顶点的动画，而CCTiledGrid3D是表现每个格子中的四边形的动画。 OK,下面我们来看一下操控网格数据表现一些基本动画的类。 打开CCActionGrid.h: #ifndef __ACTION_CCGRID_ACTION_H__#define __ACTION_CCGRID_ACTION_H__#include \"CCActionInterval.h\"#include \"CCActionInstant.h\"//使用Cocos2d命名空间NS_CC_BEGIN//用到CCGridBase类的指针。class CCGridBase;//网格动画基类class CC_DLL CCGridAction : public CCActionInterval{public:\t//产生一个当前类的实例拷贝virtual CCObject* copyWithZone(CCZone* pZone);//设定演示当前动画的演员。virtual void startWithTarget(CCNode *pTarget);//创建一个反向播放的动画。    virtual CCActionInterval* reverse(void);    //初始化网格的大小和动画的时长。    virtual bool initWithSize(const ccGridSize& gridSize, float duration);    //返回网格    virtual CCGridBase* getGrid(void);public:    //静态创建函数。参数一为格子大小，参数二为动画时长，内部调用create实现。    CC_DEPRECATED_ATTRIBUTE static CCGridAction* actionWithSize(const ccGridSize& gridSize, float duration);    //同上    static CCGridAction* create(const ccGridSize& gridSize, float duration);protected:\t//格子大小。    ccGridSize m_sGridSize;};对应CPP：//静态创建函数。参数一为格子大小，参数二为动画时长，内部调用create实现。CCGridAction* CCGridAction::actionWithSize(const ccGridSize& gridSize, float duration){    return CCGridAction::create(gridSize, duration);}//同上CCGridAction* CCGridAction::create(const ccGridSize& gridSize, float duration){\t//先new出一个CCGridAction    CCGridAction *pAction = new CCGridAction();    if (pAction){\t//初始化并放入内存管理器中。        if (pAction->initWithSize(gridSize, duration))        {            pAction->autorelease();        }        else        {\t\t\t //如果初始化失败，释放并置空。            CC_SAFE_DELETE(pAction);        }    }\t//返回创建的实例指针，当然，也可能返回NULL。    return pAction;}//初始化函数。bool CCGridAction::initWithSize(const ccGridSize& gridSize, float duration){\t//调用时间动画基类的初始化函数保存动画时长。    if (CCActionInterval::initWithDuration(duration)){\t//保存格子大小。        m_sGridSize = gridSize;        return true;    }    return false;}//设置演示当前动画的演员，注意这个演员是什么？不是精灵，而是void CCGridAction::startWithTarget(CCNode *pTarget){\t//调用时间动画基类的相应函数。    CCActionInterval::startWithTarget(pTarget);\t//取得网格数据类。    CCGridBase *newgrid = this->getGrid();    CCNode *t = m_pTarget;    //取得演员的对应网格数据。CCGridBase *targetGrid = t->getGrid();\t//有效性判断，如果演员有网格数据并且已经填充了数据。    if (targetGrid && targetGrid->getReuseGrid() > 0){\t//如果网格数据被激活并且其格子大小与本类实例的网格大小相同。        if (targetGrid->isActive() && targetGrid->getGridSize().x == m_sGridSize.x            && targetGrid->getGridSize().y == m_sGridSize.y /*&& dynamic_cast<CCGridBase*>(targetGrid) != NULL*/)        {\t\t\t //演员的网格数据恢复为原始数据。            targetGrid->reuse();        }        else        {            CCAssert(0, \"\");        }    }    else{\t//如果演员没有创建网格数据或者网格数据已经恢复为原始顶点。\t //如果演员的网格数据有效并且是激活状态。        if (targetGrid && targetGrid->isActive())        {\t\t\t //将其设为未激活。            targetGrid->setActive(false);        }\t\t //将当前类实例的网格数据设置给演员之后激活。        t->setGrid(newgrid);        t->getGrid()->setActive(true);    }}//纯虚函数：取得网格。做为基类没做任何处理。CCGridBase* CCGridAction::getGrid(void){    // Abstract class needs implementation    CCAssert(0, \"\");    return NULL;}//创建一个反向播放的动画。CCActionInterval* CCGridAction::reverse(void){    return CCReverseTime::create(this);}//创建一个当前类实例的拷贝。CCObject* CCGridAction::copyWithZone(CCZone *pZone){    CCZone* pNewZone = NULL;CCGridAction* pCopy = NULL;//如果pZone有效且已有拷贝数据。    if(pZone && pZone->m_pCopyObject)     {        //直接取用        pCopy = (CCGridAction*)(pZone->m_pCopyObject);    }    else{\t//否则新建一个当前类实例并设为pNewZone的拷贝数据。        pCopy = new CCGridAction();        pZone = pNewZone = new CCZone(pCopy);    }\t//调用基类的相应函数。    CCActionInterval::copyWithZone(pZone);\t//初始化拷贝    pCopy->initWithSize(m_sGridSize, m_fDuration);    //释放临时变量    CC_SAFE_DELETE(pNewZone);    return pCopy;}//3D网格动画基类class CC_DLL CCGrid3DAction : public CCGridAction{public:    //取得网格数据。    virtual CCGridBase* getGrid(void);    //返回对应网格位置的顶点。    ccVertex3F vertex(const ccGridSize& pos);    //返回对应网格位置的原始顶点。    ccVertex3F originalVertex(const ccGridSize& pos);    //设置对应网格位置的顶点。    void setVertex(const ccGridSize& pos, const ccVertex3F& vertex);public:    //静态创建函数:参一为格子大小，参二为动画时长，内部调用create实现。    CC_DEPRECATED_ATTRIBUTE static CCGrid3DAction* actionWithSize(const ccGridSize& gridSize, float duration);    //上面的create实现。    static CCGrid3DAction* create(const ccGridSize& gridSize, float duration);};对应CPP：//取得网格数据。CCGridBase* CCGrid3DAction::getGrid(void){\t//创建一个对应大小的3D网格数据。    return CCGrid3D::create(m_sGridSize);}//返回对应网格位置的顶点。ccVertex3F CCGrid3DAction::vertex(const ccGridSize& pos){\t//取得演员的网格数据，调用网格数据的相应函数。    CCGrid3D *g = (CCGrid3D*)m_pTarget->getGrid();    return g->vertex(pos);}//返回对应网格位置的原始顶点。ccVertex3F CCGrid3DAction::originalVertex(const ccGridSize& pos){\t//取得演员的网格数据，调用网格数据的相应函数。    CCGrid3D *g = (CCGrid3D*)m_pTarget->getGrid();    return g->originalVertex(pos);}//设置对应网格位置的顶点。void CCGrid3DAction::setVertex(const ccGridSize& pos, const ccVertex3F& vertex){\t//取得演员的网格数据，调用网格数据的相应函数。    CCGrid3D *g = (CCGrid3D*)m_pTarget->getGrid();    g->setVertex(pos, vertex);}//派生于CCGridAction的3D格子动画类。class CC_DLL CCTiledGrid3DAction : public CCGridAction{public:    //返回对应位置的格子顶点数据。    ccQuad3 tile(const ccGridSize& pos);    //返回对应位置的原始格子顶点数据。    ccQuad3 originalTile(const ccGridSize& pos);    //设置对应位置的格子数据。    void setTile(const ccGridSize& pos, const ccQuad3& coords);    //返回网格数据。    virtual CCGridBase* getGrid(void);public:    //静态创建函数：参一为格子大小，参二为动画时长，内部调用creat来实现。    CC_DEPRECATED_ATTRIBUTE static CCTiledGrid3DAction* actionWithSize(const ccGridSize& gridSize, float duration);    //上面的create实现。    static CCTiledGrid3DAction* create(const ccGridSize& gridSize, float duration);};//取得网格数据。CCGridBase* CCTiledGrid3DAction::getGrid(void){    return CCTiledGrid3D::create(m_sGridSize);}//返回对应位置的格子顶点数据。ccQuad3 CCTiledGrid3DAction::tile(const ccGridSize& pos){\t//取得演员的网格数据，调用网格数据的相应函数。    CCTiledGrid3D *g = (CCTiledGrid3D*)m_pTarget->getGrid();    return g->tile(pos);}//返回对应位置的原始格子顶点数据。ccQuad3 CCTiledGrid3DAction::originalTile(const ccGridSize& pos){\t//取得演员的网格数据，调用网格数据的相应函数。    CCTiledGrid3D *g = (CCTiledGrid3D*)m_pTarget->getGrid();    return g->originalTile(pos);}//设置对应位置的格子数据。void CCTiledGrid3DAction::setTile(const ccGridSize& pos, const ccQuad3& coords){\t//取得演员的网格数据，调用网格数据的相应函数。    CCTiledGrid3D *g = (CCTiledGrid3D*)m_pTarget->getGrid();    return g->setTile(pos, coords);}//网格所用的变速动画基类：先加速再减速。class CC_DLL CCAccelDeccelAmplitude : public CCActionInterval{public:\t//析构    virtual ~CCAccelDeccelAmplitude(void);    //初始化    bool initWithAction(CCAction *pAction, float duration);\t//设置演示动画的演员。virtual void startWithTarget(CCNode *pTarget);//更新动画。virtual void update(float time);//创建一个当前类的反向动画实例。    virtual CCActionInterval* reverse(void);    //取得速率    inline float getRate(void) { return m_fRate; }    //设置速率    inline void setRate(float fRate) { m_fRate = fRate; }public:    //静态创建函数:参一为动画实例指针，参二为动画时长，内部调用create实现。    CC_DEPRECATED_ATTRIBUTE static CCAccelDeccelAmplitude* actionWithAction(CCAction *pAction, float duration);    //上面函数的create实现。    static CCAccelDeccelAmplitude* create(CCAction *pAction, float duration);protected:\t//速率float m_fRate;//所控制的时间动画。    CCActionInterval *m_pOther;};对应CPP://静态创建函数:参一为动画实例指针，参二为动画时长，内部调用create实现。CCAccelDeccelAmplitude* CCAccelDeccelAmplitude::actionWithAction(CCAction *pAction, float duration){    return CCAccelDeccelAmplitude::create(pAction, duration);}//上面函数的create实现。CCAccelDeccelAmplitude* CCAccelDeccelAmplitude::create(CCAction *pAction, float duration){\t//先new出一个当前类的实例。    CCAccelDeccelAmplitude *pRet = new CCAccelDeccelAmplitude();    if (pRet){\t//初始化并交由内存管理器去进行引用计数器的管理。        if (pRet->initWithAction(pAction, duration))        {            pRet->autorelease();        }        else        {\t\t\t //如果失败，释放并置空。            CC_SAFE_DELETE(pRet);        }    }\t//返回创建的当前类实例，当然可能为NULL。    return pRet;}//初始化处理。bool CCAccelDeccelAmplitude::initWithAction(CCAction *pAction, float duration){\t//调用基类的初始化函数。    if (CCActionInterval::initWithDuration(duration)){\t//保存相应的变量值，占用控制的动画故对其引用计数加一。        m_fRate = 1.0f;        m_pOther = (CCActionInterval*)(pAction);        pAction->retain();        return true;    }    return false;}//析构CCAccelDeccelAmplitude::~CCAccelDeccelAmplitude(void){\t//不再占用控制的时间动画，对其引用计数器减一。    CC_SAFE_RELEASE(m_pOther);}//设置演示当前动画的演员。void CCAccelDeccelAmplitude::startWithTarget(CCNode *pTarget){\t//先调用基类的相应函数。CCActionInterval::startWithTarget(pTarget);//设置控制动画使用此演员。    m_pOther->startWithTarget(pTarget);}//更新动画。void CCAccelDeccelAmplitude::update(float time){\t//创建一个f值变为进度的2倍。    float f = time * 2;\t//如果动画时间大于一半，让进度由1再变为0。    if (f > 1)    {        f -= 1;        f = 1 - f;    }\t//使用powf处理来形成一个变速曲线公式来达到变速目的。    ((CCAccelDeccelAmplitude*)(m_pOther))->setAmplitudeRate(powf(f, m_fRate));}//创建当前类的反向动画实例。CCActionInterval* CCAccelDeccelAmplitude::reverse(void){    return CCAccelDeccelAmplitude::create(m_pOther->reverse(), m_fDuration);}//网格所用的变速动画基类：加速动画。class CC_DLL CCAccelAmplitude : public CCActionInterval{public:\t//析构    ~CCAccelAmplitude(void);    //初始化处理。    bool initWithAction(CCAction *pAction, float duration);    //取得速率    inline float getRate(void) { return m_fRate; }    //设置速率    inline void setRate(float fRate) { m_fRate = fRate; }\t//设置演示当前动画的演员。virtual void startWithTarget(CCNode *pTarget);//更新动画virtual void update(float time);//创建一个当前动画的反向动画实例。    virtual CCActionInterval* reverse(void);public:    //静态创建函数：参一为一个时间动画，参二为时长。内部调用create实现。    CC_DEPRECATED_ATTRIBUTE static CCAccelAmplitude* actionWithAction(CCAction *pAction, float duration);    //上面函数的create实现。    static CCAccelAmplitude* create(CCAction *pAction, float duration);protected:\t//速率float m_fRate;//控制动画。    CCActionInterval *m_pOther;};对应CPP：//静态创建函数：参一为一个时间动画，参二为时长。内部调用create实现。CCAccelAmplitude* CCAccelAmplitude::actionWithAction(CCAction *pAction, float duration){    return CCAccelAmplitude::create(pAction, duration);}//上面函数的create实现。CCAccelAmplitude* CCAccelAmplitude::create(CCAction *pAction, float duration){\t//创建三部曲，new,初始化,autorelease，一个不少。    CCAccelAmplitude *pRet = new CCAccelAmplitude();    if (pRet)    {        if (pRet->initWithAction(pAction, duration))        {            pRet->autorelease();        }        else        {\t\t\t //当然，要有失败处理。            CC_SAFE_DELETE(pRet);        }    }    return pRet;}//初始化bool CCAccelAmplitude::initWithAction(CCAction *pAction, float duration){\t//先调用基类的初始化函数。    if (CCActionInterval::initWithDuration(duration)){\t//速率设为1.0。        m_fRate = 1.0f;\t\t//保存动画。占用对其引用计数加一。        m_pOther = (CCActionInterval*)(pAction);        pAction->retain();        return true;    }    return false;}//析构函数。CCAccelAmplitude::~CCAccelAmplitude(void){\t//不占用，对其引用计数减一。    CC_SAFE_DELETE(m_pOther);}//设置演示当前动画的演员。void CCAccelAmplitude::startWithTarget(CCNode *pTarget){\t//调用基类的相应函数。CCActionInterval::startWithTarget(pTarget);//设置控制动画使用此演员。    m_pOther->startWithTarget(pTarget);}//动画更新处理。void CCAccelAmplitude::update(float time){\t//创建变速曲线来设置控制动画的速率。((CCAccelAmplitude*)(m_pOther))->setAmplitudeRate(powf(time, m_fRate));//更新控制动画。    m_pOther->update(time);}//创建一个当前类的反向动画实例。CCActionInterval* CCAccelAmplitude::reverse(void){    return CCAccelAmplitude::create(m_pOther->reverse(), m_fDuration);}//网格所用的变速动画基类：减速动画。class CC_DLL CCDeccelAmplitude : public CCActionInterval{public:\t//析构函数。    ~CCDeccelAmplitude(void);    //初始化    bool initWithAction(CCAction *pAction, float duration);    //取得速率    inline float getRate(void) { return m_fRate; }    //设置速率    inline void setRate(float fRate) { m_fRate = fRate; }\t\t//设置演示当前动画的演员。virtual void startWithTarget(CCNode *pTarget);//更新处理。virtual void update(float time);//创建一个当前类的反向播放的实例。    virtual CCActionInterval* reverse(void);public:    //静态创建函数，参一为一个动画，参二为动画时长。内部调用create实现。    CC_DEPRECATED_ATTRIBUTE static CCDeccelAmplitude* actionWithAction(CCAction *pAction, float duration);    //上面的create实现。    static CCDeccelAmplitude* create(CCAction *pAction, float duration);protected:\t//速率float m_fRate;//控制动画。    CCActionInterval *m_pOther;};对应CPP：//静态创建函数，参一为一个动画，参二为动画时长。内部调用create实现。CCDeccelAmplitude* CCDeccelAmplitude::actionWithAction(CCAction *pAction, float duration){    return CCDeccelAmplitude::create(pAction, duration);}//上面的create实现。CCDeccelAmplitude* CCDeccelAmplitude::create(CCAction *pAction, float duration){\t//new, initWithAction, autorelease三部曲，当然别忘了失败处理。    CCDeccelAmplitude *pRet = new CCDeccelAmplitude();    if (pRet)    {        if (pRet->initWithAction(pAction, duration))        {            pRet->autorelease();        }        else        {            CC_SAFE_DELETE(pRet);        }    }    return pRet;}//初始化处理。bool CCDeccelAmplitude::initWithAction(CCAction *pAction, float duration){\t//先调用基类的初始化处理。    if (CCActionInterval::initWithDuration(duration)){\t//速率置1。        m_fRate = 1.0f;\t\t//占用控制动画，对其引用计数器加一。        m_pOther = (CCActionInterval*)(pAction);        pAction->retain();        return true;    }    return false;}//析构CCDeccelAmplitude::~CCDeccelAmplitude(void){\t//不再占用控制动画，对其引用计数器减一。    CC_SAFE_RELEASE(m_pOther);}//设置演示当前动画的演员。void CCDeccelAmplitude::startWithTarget(CCNode *pTarget){\t//调用基类的相应函数。CCActionInterval::startWithTarget(pTarget);//调用控制动画的相应函数。    m_pOther->startWithTarget(pTarget);}//更新动画。void CCDeccelAmplitude::update(float time){\t//与加速动画有什么不同?很容易明白。    ((CCDeccelAmplitude*)(m_pOther))->setAmplitudeRate(powf((1 - time), m_fRate));    m_pOther->update(time);}//创建一个当前类的反向动画实例。CCActionInterval* CCDeccelAmplitude::reverse(void){    return CCDeccelAmplitude::create(m_pOther->reverse(), m_fDuration);}//停止网格动画。class CC_DLL CCStopGrid : public CCActionInstant{public:\t//设置演示该动画的演员。    virtual void startWithTarget(CCNode *pTarget);public:    //静态函数:创建一个当前类的实例动画，内部调用create实现。    CC_DEPRECATED_ATTRIBUTE static CCStopGrid* action(void);    //上面的create实现。    static CCStopGrid* create(void);};对应CPP：//设置演示当前动画的演员。void CCStopGrid::startWithTarget(CCNode *pTarget){\t//调用基类的相应函数。    CCActionInstant::startWithTarget(pTarget);\t//取得演员所用的网格数据。    CCGridBase *pGrid = m_pTarget->getGrid();    if (pGrid && pGrid->isActive()){\t//如果是激活状态，取消激活。        pGrid->setActive(false);    }}//静态函数:创建一个当前类的实例动画，内部调用create实现。CCStopGrid* CCStopGrid::action(void){    return CCStopGrid::create();}//上面的create实现。CCStopGrid* CCStopGrid::create(void){    CCStopGrid* pAction = new CCStopGrid();    pAction->autorelease();    return pAction;}//恢复网格动画。class CC_DLL CCReuseGrid : public CCActionInstant{public:    //初始化    bool initWithTimes(int times);\t//设置演示当前动画的演员。    virtual void startWithTarget(CCNode *pTarget);public:    //静态函数：创建一个当前类的实例。参数为，内部调用create实现。    CC_DEPRECATED_ATTRIBUTE static CCReuseGrid* actionWithTimes(int times);    //上面函数的create实现。    static CCReuseGrid* create(int times);protected:\t//    int m_nTimes;};对应CPP：//CCReuseGrid* CCReuseGrid::actionWithTimes(int times){    return CCReuseGrid::create(times);}//上面函数的create实现。CCReuseGrid* CCReuseGrid::create(int times){\t//先new出一个当前类的实例。    CCReuseGrid *pAction = new CCReuseGrid();    if (pAction){\t//进行初始化，成功后交由内存管理器进行引用计数器的管理。        if (pAction->initWithTimes(times))        {            pAction->autorelease();        }        else        {\t\t\t //初始化失败则释放并置空。            CC_SAFE_DELETE(pAction);        }    }\t//返回创建的动画实例，当然，也可能为NULL。    return pAction;}//初始化。bool CCReuseGrid::initWithTimes(int times){    m_nTimes = times;    return true;}//设置演示当前动画的演员。void CCReuseGrid::startWithTarget(CCNode *pTarget){\t//调用基类的相应函数。    CCActionInstant::startWithTarget(pTarget);\t//如果演员有正在使用的网格动画。    if (m_pTarget->getGrid() && m_pTarget->getGrid()->isActive())    {//取得这个网格动画并激活。     m_pTarget->getGrid()->setReuseGrid(m_pTarget->getGrid()->getReuseGrid() + m_nTimes);    }}   有了网格基本动画，我们再来看一下3D网格基本动画 CCActionGrid3D.h/cpp: #include \"CCActionGrid.h\"NS_CC_BEGIN//波浪动画class CC_DLL CCWaves3D : public CCGrid3DActionpublic:\t//取得和设置振幅    inline float getAmplitude(void) { return m_fAmplitude; }    inline void setAmplitude(float fAmplitude) { m_fAmplitude = fAmplitude; }\t//取得和设置频率    inline float getAmplitudeRate(void) { return m_fAmplitudeRate; }    inline void setAmplitudeRate(float fAmplitudeRate) { m_fAmplitudeRate = fAmplitudeRate; }    //初始化    bool initWithWaves(int wav, float amp, const ccGridSize& gridSize, float duration);\t//产生一个实例的拷贝。virtual CCObject* copyWithZone(CCZone* pZone);//动画更新。    virtual void update(float time);public:    //创建一个波浪动画，参一为波浪动画摇动的次数，参二为波浪的振幅，参三为格子的大小，参四为动画时长。    CC_DEPRECATED_ATTRIBUTE static CCWaves3D* actionWithWaves(int wav, float amp, const ccGridSize& gridSize, float duration);    //上面的create实现。    static CCWaves3D* create(int wav, float amp, const ccGridSize& gridSize, float duration);protected:\t//波浪摇动的次数。    int m_nWaves;\t//摇动的振幅。    float m_fAmplitude;\t//摇动的频率。    float m_fAmplitudeRate;};CPP实现：//创建一个波浪动画，参一为波浪动画摇动的次数，参二为波浪的振幅，参三为格子的大小，参四为动画时长。CCWaves3D* CCWaves3D::actionWithWaves(int wav, float amp, const ccGridSize& gridSize, float duration){    return CCWaves3D::create(wav, amp, gridSize, duration);}//上面的create实现。CCWaves3D* CCWaves3D::create(int wav, float amp, const ccGridSize& gridSize, float duration){\t//new,初始化，autorelease，失败处理。    CCWaves3D *pAction = new CCWaves3D();    if (pAction)    {        if (pAction->initWithWaves(wav, amp, gridSize, duration))        {            pAction->autorelease();        }        else        {            CC_SAFE_RELEASE_NULL(pAction);        }    }    return pAction;    }//初始化。bool CCWaves3D::initWithWaves(int wav, float amp, const ccGridSize& gridSize, float duration){\t//先调用基类的初始化函数。    if (CCGrid3DAction::initWithSize(gridSize, duration))    {\t\t //保存相应的参数。        m_nWaves = wav;        m_fAmplitude = amp;        m_fAmplitudeRate = 1.0f;        return true;    }    return false;}//产生一个当前类的实例。CCObject* CCWaves3D::copyWithZone(CCZone *pZone){    CCZone* pNewZone = NULL;    CCWaves3D* pCopy = NULL;    if(pZone && pZone->m_pCopyObject)     {        //in case of being called at sub class        pCopy = (CCWaves3D*)(pZone->m_pCopyObject);    }    else    {        pCopy = new CCWaves3D();        pZone = pNewZone = new CCZone(pCopy);    }    CCGrid3DAction::copyWithZone(pZone);    pCopy->initWithWaves(m_nWaves, m_fAmplitude, m_sGridSize, m_fDuration);    CC_SAFE_DELETE(pNewZone);    return pCopy;}//更新动画。void CCWaves3D::update(float time){\t//双循环遍历格子。    int i, j;    for (i = 0; i < m_sGridSize.x + 1; ++i)    {        for (j = 0; j < m_sGridSize.y + 1; ++j)        {\t\t\t //取出当前格子原始顶点，对z值进行sin曲线的变化加值。形成来回摇动的效果。            ccVertex3F v = originalVertex(ccg(i ,j));            v.z += (sinf((float)M_PI * time * m_nWaves * 2 + (v.y+v.x) * .01f) * m_fAmplitude * m_fAmplitudeRate);            CCLog(\"v.z offset is %f\\n\", (sinf((float)M_PI * time * m_nWaves * 2 + (v.y+v.x) * .01f) * m_fAmplitude * m_fAmplitudeRate));\t\t\t //将顶点设置到格子中。            setVertex(ccg(i, j), v);        }    }}对应图： //绕X轴翻转。class CC_DLL CCFlipX3D : public CCGrid3DAction{public:    //初始化动画。bool initWithDuration(float duration);//初始化格子大小。virtual bool initWithSize(const ccGridSize& gridSize, float duration);//产生一个当前类的实例拷贝。virtual CCObject* copyWithZone(CCZone* pZone);//动画更新。    virtual void update(float time);public:    //创建一个绕X轴翻转的3D网格动画。参数为动画时长。    CC_DEPRECATED_ATTRIBUTE static CCFlipX3D* actionWithDuration(float duration);    //上面的create实现。    static CCFlipX3D* create(float duration);};对应的CPP实现：//创建一个绕X轴翻转的3D网格动画。参数为动画时长。CCFlipX3D::actionWithDuration(float duration){    return CCFlipX3D::create(duration);}//上面的create实现。CCFlipX3D* CCFlipX3D::create(float duration){//new ,初始化, autorelease,失败处理。    CCFlipX3D *pAction = new CCFlipX3D();    if (pAction)    {        if (pAction->initWithSize(ccg(1, 1), duration))        {            pAction->autorelease();        }        else        {            CC_SAFE_RELEASE_NULL(pAction);        }    }    return pAction;}//初始化动画。bool CCFlipX3D::initWithDuration(float duration){    return CCGrid3DAction::initWithSize(ccg(1, 1), duration);}//初始化格子大小。bool CCFlipX3D::initWithSize(const ccGridSize& gridSize, float duration){    if (gridSize.x != 1 || gridSize.y != 1)    {        // Grid size must be (1,1)        CCAssert(0, \"Grid size must be (1,1)\");        return false;    }    return CCGrid3DAction::initWithSize(gridSize, duration);}//产生一个当前类的实例拷贝。CCObject* CCFlipX3D::copyWithZone(CCZone *pZone){    CCZone* pNewZone = NULL;    CCFlipX3D* pCopy = NULL;    if(pZone && pZone->m_pCopyObject)     {        //in case of being called at sub class        pCopy = (CCFlipX3D*)(pZone->m_pCopyObject);    }    else    {        pCopy = new CCFlipX3D();        pZone = pNewZone = new CCZone(pCopy);    }    CCGrid3DAction::copyWithZone(pZone);    pCopy->initWithSize(m_sGridSize, m_fDuration);    CC_SAFE_DELETE(pNewZone);    return pCopy;}//动画更新。void CCFlipX3D::update(float time){    //角度，从0~180变化。    float angle = (float)M_PI * time; // 180 degrees    //计算其sin值    float mz = sinf(angle);    //对基除2后计算cos值。    angle = angle / 2.0f; // x calculates degrees from 0 to 90    float mx = cosf(angle);    //定义临时变量。    ccVertex3F v0, v1, v, diff;    //    v0 = originalVertex(ccg(1, 1));    v1 = originalVertex(ccg(0, 0));    //    float    x0 = v0.x;    float    x1 = v1.x;    float x;    ccGridSize    a, b, c, d;    //    if ( x0 > x1 )    {        // Normal Grid        a = ccg(0,0);        b = ccg(0,1);        c = ccg(1,0);        d = ccg(1,1);        x = x0;    }    else    {        // Reversed Grid        c = ccg(0,0);        d = ccg(0,1);        a = ccg(1,0);        b = ccg(1,1);        x = x1;    }    //    diff.x = ( x - x * mx );    diff.z = fabsf( floorf( (x * mz) / 4.0f ) );    //取得左下角顶点，设置X和Z值。    v = originalVertex(a);    v.x = diff.x;    v.z += diff.z;    setVertex(a, v);    //取得左上角顶点。计算X和Z值。    v = originalVertex(b);    v.x = diff.x;    v.z += diff.z;    setVertex(b, v);    //取得右下角顶点。计算X和Z值。    v = originalVertex(c);    v.x -= diff.x;    v.z -= diff.z;    setVertex(c, v);    //取得右上角顶点。计算X和Z值。    v = originalVertex(d);    v.x -= diff.x;    v.z -= diff.z;    setVertex(d, v);}对应图： //绕Y轴反转的3D网格动画。class CC_DLL CCFlipY3D : public CCFlipX3D{public:\t//动画更新。    virtual void update(float time);\t//产生一个当前类的实例拷贝。    virtual CCObject* copyWithZone(CCZone* pZone);public:    //创建一个绕Y轴反转的3D网格动画，内部调用create实现。    CC_DEPRECATED_ATTRIBUTE static CCFlipY3D* actionWithDuration(float duration);    //上面的create实现。    static CCFlipY3D* create(float duration);};对应CPP实现：//创建一个绕Y轴反转的3D网格动画，内部调用create实现。CCFlipY3D* CCFlipY3D::actionWithDuration(float duration){    return CCFlipY3D::create(duration);}//上面的create实现。CCFlipY3D* CCFlipY3D::create(float duration){//new ,初始化, autorelease,失败处理。    CCFlipY3D *pAction = new CCFlipY3D();    if (pAction)    {        if (pAction->initWithSize(ccg(1, 1), duration))        {            pAction->autorelease();        }        else        {            CC_SAFE_RELEASE_NULL(pAction);        }    }    return pAction;}//产生一个当前类的实例拷贝。CCObject* CCFlipY3D::copyWithZone(CCZone* pZone){    CCZone* pNewZone = NULL;    CCFlipY3D* pCopy = NULL;    if(pZone && pZone->m_pCopyObject)     {        //in case of being called at sub class        pCopy = (CCFlipY3D*)(pZone->m_pCopyObject);    }    else    {        pCopy = new CCFlipY3D();        pZone = pNewZone = new CCZone(pCopy);    }    CCFlipX3D::copyWithZone(pZone);    pCopy->initWithSize(m_sGridSize, m_fDuration);    CC_SAFE_DELETE(pNewZone);    return pCopy;}//动画更新。void CCFlipY3D::update(float time){//角度从0~180float angle = (float)M_PI * time; // 180 degrees//对其进行sin计算。float mz = sinf( angle );//对其做除2计算。angle = angle / 2.0f;     // x calculates degrees from 0 to 90//对其进行cos计算。    float my = cosf(angle);        ccVertex3F    v0, v1, v, diff;        v0 = originalVertex(ccg(1, 1));    v1 = originalVertex(ccg(0, 0));        float    y0 = v0.y;    float    y1 = v1.y;    float y;    ccGridSize    a, b, c, d;        if (y0 > y1)    {        // Normal Grid        a = ccg(0,0);        b = ccg(0,1);        c = ccg(1,0);        d = ccg(1,1);        y = y0;    }    else    {        // Reversed Grid        b = ccg(0,0);        a = ccg(0,1);        d = ccg(1,0);        c = ccg(1,1);        y = y1;    }        diff.y = y - y * my;    diff.z = fabsf(floorf((y * mz) / 4.0f));        // bottom-left    v = originalVertex(a);    v.y = diff.y;    v.z += diff.z;    setVertex(a, v);        // upper-left    v = originalVertex(b);    v.y -= diff.y;    v.z -= diff.z;    setVertex(b, v);        // bottom-right    v = originalVertex(c);    v.y = diff.y;    v.z += diff.z;    setVertex(c, v);        // upper-right    v = originalVertex(d);    v.y -= diff.y;    v.z -= diff.z;    setVertex(d, v);}对应图： //球体3D网格动画。class CC_DLL CCLens3D : public CCGrid3DAction{public:    //    inline float getLensEffect(void) { return m_fLensEffect; }    //    inline void setLensEffect(float fLensEffect) { m_fLensEffect = fLensEffect; }    //设置中心位置。    inline const CCPoint& getPosition(void) { return m_position; }    void setPosition(const CCPoint& position);    //初始化。bool initWithPosition(const CCPoint& pos, float r, const ccGridSize& gridSize, float duration);//创建一个当前类的实例拷贝。virtual CCObject* copyWithZone(CCZone* pZone);//动画更新。    virtual void update(float time);public:    //创建一个球体的3D网格动画。参一为中心点位置，参二为半径，参三为格子大小，参四为动画时长。    CC_DEPRECATED_ATTRIBUTE static CCLens3D* actionWithPosition(const CCPoint& pos, float r, const ccGridSize& gridSize, float duration);    //上面的create实现。    static CCLens3D* create(const CCPoint& pos, float r, const ccGridSize& gridSize, float duration);protected:    //球体的中心位置。    CCPoint m_position;\t//球体的半径。    float m_fRadius;    //效果公式的参数。    float m_fLensEffect;\t//这个命名本意是使用脏矩形，即相同的矩形没有改变就不要重新更新。但可惜它在使用时的true与false应该反过来。这里可以理解成是否更新中心点位置，需要重新计算。    bool    m_bDirty;};对应的CPP：//创建一个球体的3D网格动画。参一为中心点位置，参二为半径，参三为格子大小，参四为动画时长。CCLens3D* CCLens3D::actionWithPosition(const CCPoint& pos, float r, const ccGridSize& gridSize, float duration){    return CCLens3D::create(pos, r, gridSize, duration);}//上面的create实现。CCLens3D* CCLens3D::create(const CCPoint& pos, float r, const ccGridSize& gridSize, float duration){\t//new,初始化，autorelease，失败处理。    CCLens3D *pAction = new CCLens3D();    if (pAction)    {        if (pAction->initWithPosition(pos, r, gridSize, duration))        {            pAction->autorelease();        }        else        {            CC_SAFE_RELEASE_NULL(pAction);        }    }    return pAction;}//初始化。bool CCLens3D::initWithPosition(const CCPoint& pos, float r, const ccGridSize& gridSize, float duration){\t//先调用基类的相应函数。    if (CCGrid3DAction::initWithSize(gridSize, duration)){\t//保存参数到成员变量。        m_position = ccp(-1, -1);        setPosition(pos);        m_fRadius = r;        m_fLensEffect = 0.7f;        //设置需要重新计算。        m_bDirty = true;        return true;    }    return false;}//产生一个当前类的实例拷贝。CCObject* CCLens3D::copyWithZone(CCZone *pZone){    CCZone* pNewZone = NULL;    CCLens3D* pCopy = NULL;    if(pZone && pZone->m_pCopyObject)     {        //in case of being called at sub class        pCopy = (CCLens3D*)(pZone->m_pCopyObject);    }    else    {        pCopy = new CCLens3D();        pZone = pNewZone = new CCZone(pCopy);    }    CCGrid3DAction::copyWithZone(pZone);    pCopy->initWithPosition(m_position, m_fRadius, m_sGridSize, m_fDuration);        CC_SAFE_DELETE(pNewZone);    return pCopy;}//设置球体的中心位置。void CCLens3D::setPosition(const CCPoint& pos){    if( !pos.equals(m_position))    {//位置有更新，则设置需要重新计算。        m_position = pos;        m_bDirty = true;    }}//动画更新。void CCLens3D::update(float time){CC_UNUSED_PARAM(time);//如果需要重新计算。    if (m_bDirty)    {        int i, j;        //双循环遍历格子。        for (i = 0; i < m_sGridSize.x + 1; ++i)        {            for (j = 0; j < m_sGridSize.y + 1; ++j)            {                //取出格子对应的顶点。                ccVertex3F v = originalVertex(ccg(i, j));               //计算格子顶点与中心点的差。                CCPoint vect = ccpSub(m_position, ccp(v.x, v.y));                //计算格子顶点与中心点的距离。                float r = ccpLength(vect);                //如果距离在半径内。                if (r < m_fRadius)                {                    r = m_fRadius - r;                    float pre_log = r / m_fRadius;                    if ( pre_log == 0 )                     {                        pre_log = 0.001f;                    }                    //通过一些函数来取得相应的顶点影响值。                    float l = logf(pre_log) * m_fLensEffect;                    float new_r = expf( l ) * m_fRadius;                    //如果不是中心点，就进行位置的更新。                    if (ccpLength(vect) > 0)                    {                        vect = ccpNormalize(vect);                        CCPoint new_vect = ccpMult(vect, new_r);                        v.z += ccpLength(new_vect) * m_fLensEffect;                    }                }                //设置格子的新顶点。                setVertex(ccg(i, j), v);            }        }                m_bDirty = false;    }}对应图： //涟漪3D网格特效。class CC_DLL CCRipple3D : public CCGrid3DAction{public:    //取得和设置中心位置。    inline const CCPoint& getPosition(void) { return m_position; }    void setPosition(const CCPoint& position);\t//取得和设置振幅。    inline float getAmplitude(void) { return m_fAmplitude; }    inline void setAmplitude(float fAmplitude) { m_fAmplitude = fAmplitude; }\t//取得和设置频率。    inline float getAmplitudeRate(void) { return m_fAmplitudeRate; }    inline void setAmplitudeRate(float fAmplitudeRate) { m_fAmplitudeRate = fAmplitudeRate; }    //初始化位置。bool initWithPosition(const CCPoint& pos, float r, int wav, float amp,         const ccGridSize& gridSize, float duration);    virtual CCObject* copyWithZone(CCZone* pZone);    virtual void update(float time);public:    //创建一个涟漪3D网格特效。参一为中心位置，参二为半径，参三为振幅，参四为格子大小，参五为动画时长。    CC_DEPRECATED_ATTRIBUTE static CCRipple3D* actionWithPosition(const CCPoint& pos, float r, int wav, float amp,         const ccGridSize& gridSize, float duration);    //上面的create实现。    static CCRipple3D* create(const CCPoint& pos, float r, int wav, float amp,         const ccGridSize& gridSize, float duration);protected:    //中心位置。CCPoint m_position;//半径。float m_fRadius;//振动次数。int m_nWaves;//振幅。float m_fAmplitude;//振动频率。    float m_fAmplitudeRate;};CPP实现：//创建一个涟漪3D网格特效。CCRipple3D* CCRipple3D::actionWithPosition(const CCPoint& pos, float r, int wav, float amp, const ccGridSize& gridSize, float duration){    return CCRipple3D::create(pos, r, wav, amp, gridSize, duration);}//上面的create实现。CCRipple3D* CCRipple3D::create(const CCPoint& pos, float r, int wav, float amp, const ccGridSize& gridSize, float duration){//先new出一个当前类的实例。    CCRipple3D *pAction = new CCRipple3D();//如果成功。    if (pAction){//进行初始化。        if (pAction->initWithPosition(pos, r, wav, amp, gridSize, duration))        {\t//如果初始化成功，交由内存管理器进行引用计数管理。            pAction->autorelease();        }        else        {\t//如果失败，释放并置空。            CC_SAFE_RELEASE_NULL(pAction);        }    }    return pAction;}//初始化。bool CCRipple3D::initWithPosition(const CCPoint& pos, float r, int wav, float amp, const ccGridSize& gridSize, float duration){//先调用基类的初始化处理。    if (CCGrid3DAction::initWithSize(gridSize, duration)){//设置中心点位置。        setPosition(pos);        //将参数保存到成员变量中。        m_fRadius = r;        m_nWaves = wav;        m_fAmplitude = amp;        m_fAmplitudeRate = 1.0f;        return true;    }    return false;}//设置中心点位置。void CCRipple3D::setPosition(const CCPoint& position){    m_position = position;}//产生一个当前类的实例拷贝。CCObject* CCRipple3D::copyWithZone(CCZone *pZone){    CCZone* pNewZone = NULL;    CCRipple3D* pCopy = NULL;    if(pZone && pZone->m_pCopyObject)    {        //in case of being called at sub class        pCopy = (CCRipple3D*)(pZone->m_pCopyObject);    }    else    {        pCopy = new CCRipple3D();        pZone = pNewZone = new CCZone(pCopy);    }    CCGrid3DAction::copyWithZone(pZone);    pCopy->initWithPosition(m_position, m_fRadius, m_nWaves, m_fAmplitude, m_sGridSize, m_fDuration);        CC_SAFE_DELETE(pNewZone);    return pCopy;}//更新动画处理。void CCRipple3D::update(float time){    int i, j;//双循环遍历每个格子。    for (i = 0; i < (m_sGridSize.x+1); ++i)    {        for (j = 0; j < (m_sGridSize.y+1); ++j)        {            //取得格子的原始顶点。            ccVertex3F v = originalVertex(ccg(i, j));            //计算顶点与中心点的位置之差。            CCPoint vect = ccpSub(m_position, ccp(v.x,v.y));            //计算出顶点与中心点的距离。            float r = ccpLength(vect);            //如果在半径范围内。通过距离做为参数按照sin曲线公式计算出相应的Z值偏移。            if (r < m_fRadius)            {                   r = m_fRadius - r;                float rate = powf(r / m_fRadius, 2);                v.z += (sinf( time*(float)M_PI * m_nWaves * 2 + r * 0.1f) * m_fAmplitude * m_fAmplitudeRate * rate);            }            //将偏移后的顶点设置给格子。            setVertex(ccg(i, j), v);        }    }}效果图： //3D摇动的网格动画。class CC_DLL CCShaky3D : public CCGrid3DAction{public:    //初始化。bool initWithRange(int range, bool shakeZ, const ccGridSize& gridSize, float duration);//产生一个实例的拷贝。virtual CCObject* copyWithZone(CCZone* pZone);//更新动画。    virtual void update(float time);public:    //创建一个3D摇动的网格动画。参一是随机范围，参二指定是否在Z值上摇动，参三为格子大小，参四为动画时长。    CC_DEPRECATED_ATTRIBUTE static CCShaky3D* actionWithRange(int range, bool shakeZ, const ccGridSize& gridSize, float duration);    //上面的create实现。    static CCShaky3D* create(int range, bool shakeZ, const ccGridSize& gridSize, float duration);protected:    //随机范围。    int m_nRandrange;    //是否在Z值上摇动。    bool m_bShakeZ;};//创建一个3D摇动的网格动画。参一是随机范围，参二指定是否在Z值上摇动，参三为格子大小，参四为动画时长。CCShaky3D* CCShaky3D::actionWithRange(int range, bool shakeZ, const ccGridSize& gridSize, float duration){    return CCShaky3D::create(range, shakeZ, gridSize, duration);}//上面的create实现。CCShaky3D* CCShaky3D::create(int range, bool shakeZ, const ccGridSize& gridSize, float duration){//先new出一个当前类的实例，    CCShaky3D *pAction = new CCShaky3D();    if (pAction){//如果成功，对其进行初始化。        if (pAction->initWithRange(range, shakeZ, gridSize, duration))        { //如果初始化成功，交由内存管理器进行引用计数的管理。            pAction->autorelease();        }        else        {               //如果失败，释放并置空。            CC_SAFE_RELEASE_NULL(pAction);        }    }    return pAction;}//初始化。bool CCShaky3D::initWithRange(int range, bool shakeZ, const ccGridSize& gridSize, float duration){//先调用基类的初始化函数。    if (CCGrid3DAction::initWithSize(gridSize, duration)){        //如果成功，保存参数到成员变量中。        m_nRandrange = range;        m_bShakeZ = shakeZ;        return true;    }    return false;}//产生一个当前类的实例。CCObject* CCShaky3D::copyWithZone(CCZone *pZone){    CCZone* pNewZone = NULL;    CCShaky3D* pCopy = NULL;    if(pZone && pZone->m_pCopyObject)    {        //in case of being called at sub class        pCopy = (CCShaky3D*)(pZone->m_pCopyObject);    }    else    {        pCopy = new CCShaky3D();        pZone = pNewZone = new CCZone(pCopy);    }    CCGrid3DAction::copyWithZone(pZone);    pCopy->initWithRange(m_nRandrange, m_bShakeZ, m_sGridSize, m_fDuration);        CC_SAFE_DELETE(pNewZone);    return pCopy;}//动画更新。void CCShaky3D::update(float time){    CC_UNUSED_PARAM(time);    int i, j;    //双循环遍历所有格子。    for (i = 0; i < (m_sGridSize.x+1); ++i)    {        for (j = 0; j < (m_sGridSize.y+1); ++j)        {            //取得格子的原始顶点。            ccVertex3F v = originalVertex(ccg(i ,j));            //对顶点的x,y进行随机的的加成。            v.x += (rand() % (m_nRandrange*2)) - m_nRandrange;            v.y += (rand() % (m_nRandrange*2)) - m_nRandrange;            //如果需要Z值的摇动，对顶点的z进行随机的的加成。            if (m_bShakeZ)            {                v.z += (rand() % (m_nRandrange*2)) - m_nRandrange;            }            //将顶点设置到相应格子中。            setVertex(ccg(i, j), v);        }    }}对应图： //流体效果的3D网格动画。class CC_DLL CCLiquid : public CCGrid3DAction{public:    //取得和设置振幅。    inline float getAmplitude(void) { return m_fAmplitude; }    inline void setAmplitude(float fAmplitude) { m_fAmplitude = fAmplitude; }    //取得和设置频率。    inline float getAmplitudeRate(void) { return m_fAmplitudeRate; }    inline void setAmplitudeRate(float fAmplitudeRate) { m_fAmplitudeRate = fAmplitudeRate; }//初始化    bool initWithWaves(int wav, float amp, const ccGridSize& gridSize, float duration);    //产生一个当前类的实例。    virtual CCObject* copyWithZone(CCZone* pZone);    //更新动画。    virtual void update(float time);public://创建一个流体效果的3D网格动画。参一为动画的次数，参二为振幅，参三为格子大小，参四为动画时长。    CC_DEPRECATED_ATTRIBUTE static CCLiquid* actionWithWaves(int wav, float amp, const ccGridSize& gridSize, float duration);    //上面的create实现。    static CCLiquid* create(int wav, float amp, const ccGridSize& gridSize, float duration);protected:    //动画的次数。    int m_nWaves;    //振幅。    float m_fAmplitude;    //频率。    float m_fAmplitudeRate;};对应的CPP://创建一个流体效果的3D网格动画。参一为动画的次数，参二为振幅，参三为格子大小，参四为动画时长。CCLiquid* CCLiquid::actionWithWaves(int wav, float amp, const ccGridSize& gridSize, float duration){    return CCLiquid::create(wav, amp, gridSize, duration);}//上面的create实现。CCLiquid* CCLiquid::create(int wav, float amp, const ccGridSize& gridSize, float duration){    //先new出一个当前类的实例动画。    CCLiquid *pAction = new CCLiquid();    if (pAction)    {        //如果成功，进行初始化。        if (pAction->initWithWaves(wav, amp, gridSize, duration))        {            //初始化成功交由内存管理器进行引用计数器的管理。            pAction->autorelease();        }        else        {            //如果失败，释放并置空。            CC_SAFE_RELEASE_NULL(pAction);        }    }    return pAction;}//初始化bool CCLiquid::initWithWaves(int wav, float amp, const ccGridSize& gridSize, float duration){    //先调用基类的初始化函数。    if (CCGrid3DAction::initWithSize(gridSize, duration))    {        //将相应的参数保存到成员变量中。        m_nWaves = wav;        m_fAmplitude = amp;        m_fAmplitudeRate = 1.0f;        return true;    }    return false;}//产生一个当前类的实例拷贝。CCObject* CCLiquid::copyWithZone(CCZone *pZone){    CCZone* pNewZone = NULL;    CCLiquid* pCopy = NULL;    if(pZone && pZone->m_pCopyObject)     {        //in case of being called at sub class        pCopy = (CCLiquid*)(pZone->m_pCopyObject);    }    else    {        pCopy = new CCLiquid();        pZone = pNewZone = new CCZone(pCopy);    }    CCGrid3DAction::copyWithZone(pZone);    pCopy->initWithWaves(m_nWaves, m_fAmplitude, m_sGridSize, m_fDuration);    CC_SAFE_DELETE(pNewZone);    return pCopy;}//动画更新。void CCLiquid::update(float time){    int i, j;    //双循环遍历所有的格子。    for (i = 1; i < m_sGridSize.x; ++i)    {        for (j = 1; j < m_sGridSize.y; ++j)        {            //取出格子的原始顶点位置。            ccVertex3F v = originalVertex(ccg(i, j));            //设置顶点的x,y值。            v.x = (v.x + (sinf(time * (float)M_PI * m_nWaves * 2 + v.x * .01f) * m_fAmplitude * m_fAmplitudeRate));            v.y = (v.y + (sinf(time * (float)M_PI * m_nWaves * 2 + v.y * .01f) * m_fAmplitude * m_fAmplitudeRate));            //将顶点数据设置给相应格子。            setVertex(ccg(i, j), v);        }    }}对应图： //波浪效果的网格动画，与CCWaves3D的区别是少了Z值的变化。class CC_DLL CCWaves : public CCGrid3DAction{public:    //设置振幅。    inline float getAmplitude(void) { return m_fAmplitude; }    inline void setAmplitude(float fAmplitude) { m_fAmplitude = fAmplitude; }    //设置频率。    inline float getAmplitudeRate(void) { return m_fAmplitudeRate; }    inline void setAmplitudeRate(float fAmplitudeRate) { m_fAmplitudeRate = fAmplitudeRate; }    //初始化。    bool initWithWaves(int wav, float amp, bool h, bool v, const ccGridSize& gridSize,        float duration);    //产生一个当前类的实例拷贝。    virtual CCObject* copyWithZone(CCZone* pZone);    //更新动画。    virtual void update(float time);public:    //创建一个波浪效果的网格动画，参一为波浪的次数，参二为振幅，参三为是否进行横向运动，参四为是否进行竖向运动,参五为格子大小，参六为动画时长。    CC_DEPRECATED_ATTRIBUTE static CCWaves* actionWithWaves(int wav, float amp, bool h, bool v, const ccGridSize& gridSize,         float duration);    //上面的create实现。    static CCWaves* create(int wav, float amp, bool h, bool v, const ccGridSize& gridSize,        float duration);protected:    //波浪次数。    int m_nWaves;    //振幅。    float m_fAmplitude;    //频率。    float m_fAmplitudeRate;    //竖向    bool m_bVertical;    //横向。    bool m_bHorizontal;};//创建一个波浪效果的网格动画，参一为波浪的次数，参二为振幅，参三为是否进行横向运动，参四为是否进行竖向运动,参五为格子大小，参六为动画时长。CCWaves* CCWaves::actionWithWaves(int wav, float amp, bool h, bool v, const ccGridSize& gridSize, float duration){    return CCWaves::create(wav, amp, h, v, gridSize, duration);}//上面的create实现。CCWaves* CCWaves::create(int wav, float amp, bool h, bool v, const ccGridSize& gridSize, float duration){   //先new出一个当前类的实例。    CCWaves *pAction = new CCWaves();    //如果成功。    if (pAction)    {  //进行初始化。        if (pAction->initWithWaves(wav, amp, h, v, gridSize, duration))        {  //初始化成功，则交给内存管理器进行引用计数器的管理。            pAction->autorelease();        }        else        {            //否则释放并置空。            CC_SAFE_RELEASE_NULL(pAction);        }    }    return pAction;}//初始化。bool CCWaves::initWithWaves(int wav, float amp, bool h, bool v, const ccGridSize& gridSize, float duration){    if (CCGrid3DAction::initWithSize(gridSize, duration))    {        m_nWaves = wav;        m_fAmplitude = amp;        m_fAmplitudeRate = 1.0f;        m_bHorizontal = h;        m_bVertical = v;        return true;    }    return false;}//产生一个当前类的实例拷贝。CCObject* CCWaves::copyWithZone(CCZone *pZone){    CCZone* pNewZone = NULL;    CCWaves* pCopy = NULL;    if(pZone && pZone->m_pCopyObject)     {        //in case of being called at sub class        pCopy = (CCWaves*)(pZone->m_pCopyObject);    }    else    {        pCopy = new CCWaves();        pZone = pNewZone = new CCZone(pCopy);    }    CCGrid3DAction::copyWithZone(pZone);    pCopy->initWithWaves(m_nWaves, m_fAmplitude, m_bHorizontal, m_bVertical, m_sGridSize, m_fDuration);        CC_SAFE_DELETE(pNewZone);    return pCopy;}//动画更新。void CCWaves::update(float time){    int i, j;    //双循环遍历所有格子。    for (i = 0; i < m_sGridSize.x + 1; ++i)    {        for (j = 0; j < m_sGridSize.y + 1; ++j)        {            //取得对应格子的顶点。            ccVertex3F v = originalVertex(ccg(i, j));            //如果进行横向运动。            if (m_bVertical)            {               //计算X值。                v.x = (v.x + (sinf(time * (float)M_PI * m_nWaves * 2 + v.y * .01f) * m_fAmplitude * m_fAmplitudeRate));            }            //如果进行竖向运动。            if (m_bHorizontal)            {   //计算Y值。                v.y = (v.y + (sinf(time * (float)M_PI * m_nWaves * 2 + v.x * .01f) * m_fAmplitude * m_fAmplitudeRate));            }            //将顶点数据设置到相应格子中。            setVertex(ccg(i, j), v);        }    }}对应图： //盘旋扭曲效果的3D网格动画。class CC_DLL CCTwirl : public CCGrid3DAction{public:    //取得中心位置。    inline const CCPoint& getPosition(void) { return m_position; }    //设置中心位置。    void setPosition(const CCPoint& position);    //取得振幅。    inline float getAmplitude(void) { return m_fAmplitude; }    //设置振幅。    inline void setAmplitude(float fAmplitude) { m_fAmplitude = fAmplitude; }    //取得和设置频率。    inline float getAmplitudeRate(void) { return m_fAmplitudeRate; }    inline void setAmplitudeRate(float fAmplitudeRate) { m_fAmplitudeRate = fAmplitudeRate; }    //初始化。    bool initWithPosition(const CCPoint& pos, int t, float amp, const ccGridSize& gridSize,        float duration);    //产生一个当前类的实例拷贝。virtual CCObject* copyWithZone(CCZone* pZone);//更新动画。    virtual void update(float time);public:    //创建一个盘旋扭曲效果的3D网格动画。参一为中心位置，参二为盘旋扭曲的次数，参三为振幅，参四为格子大小，参五为动画时长。    CC_DEPRECATED_ATTRIBUTE static CCTwirl* actionWithPosition(CCPoint pos, int t, float amp, const ccGridSize& gridSize,         float duration);    //上面的create实现。    static CCTwirl* create(CCPoint pos, int t, float amp, const ccGridSize& gridSize,        float duration);protected:    //中心点位置。    CCPoint m_position;    //盘旋扭曲的次数。    int m_nTwirls;    //振幅。    float m_fAmplitude;    //频率。    float m_fAmplitudeRate;}; //创建一个盘旋扭曲效果的3D网格动画。参一为中心位置，参二为盘旋扭曲的次数，参三为振幅，参四为格子大小，参五为动画时长。CCTwirl* CCTwirl::actionWithPosition(CCPoint pos, int t, float amp, const ccGridSize& gridSize, float duration){    return CCTwirl::create(pos, t, amp, gridSize, duration);}//上面的create实现。CCTwirl* CCTwirl::create(CCPoint pos, int t, float amp, const ccGridSize& gridSize, float duration){    //先new出一个当前类的实例。    CCTwirl *pAction = new CCTwirl();    if (pAction){    //进行初始化。        if (pAction->initWithPosition(pos, t, amp, gridSize, duration))        {            //成功则交由内存管理器进行引用计数器管理。            pAction->autorelease();        }        else        {   //失败则释放并置空。            CC_SAFE_RELEASE_NULL(pAction);        }    }    return pAction;}//初始化。bool CCTwirl::initWithPosition(const CCPoint& pos, int t, float amp, const ccGridSize& gridSize, float duration){    if (CCGrid3DAction::initWithSize(gridSize, duration))    {        setPosition(pos);        m_nTwirls = t;        m_fAmplitude = amp;        m_fAmplitudeRate = 1.0f;        return true;    }    return false;}//设置中心点位置。void CCTwirl::setPosition(const CCPoint& position){    m_position = position;}//产生一个当前类的实例拷贝。CCObject* CCTwirl::copyWithZone(CCZone *pZone){    CCZone* pNewZone = NULL;    CCTwirl* pCopy = NULL;    if(pZone && pZone->m_pCopyObject)    {        //in case of being called at sub class        pCopy = (CCTwirl*)(pZone->m_pCopyObject);    }    else    {        pCopy = new CCTwirl();        pZone = pNewZone = new CCZone(pCopy);    }    CCGrid3DAction::copyWithZone(pZone);    pCopy->initWithPosition(m_position, m_nTwirls, m_fAmplitude, m_sGridSize, m_fDuration);    CC_SAFE_DELETE(pNewZone);    return pCopy;}//更新动画。void CCTwirl::update(float time){int i, j;//将动画的中心点位置保存到点c中。    CCPoint    c = m_position;    //双循环遍历每个格子。    for (i = 0; i < (m_sGridSize.x+1); ++i)    {        for (j = 0; j < (m_sGridSize.y+1); ++j)        {            //取得对应格子的顶点。            ccVertex3F v = originalVertex(ccg(i ,j));            //取得当前格子与格子中心位置的差。            CCPoint    avg = ccp(i-(m_sGridSize.x/2.0f), j-(m_sGridSize.y/2.0f));            //计算当前格子与中心点位置的距离。            float r = ccpLength(avg);            //计算振幅。            float amp = 0.1f * m_fAmplitude * m_fAmplitudeRate;            //使用cos公式来计算出曲线变化值。            float a = r * cosf( (float)M_PI/2.0f + time * (float)M_PI * m_nTwirls * 2 ) * amp;            //计算出一个偏移。            CCPoint d = ccp(                sinf(a) * (v.y-c.y) + cosf(a) * (v.x-c.x),                cosf(a) * (v.y-c.y) - sinf(a) * (v.x-c.x));            //当前顶点位置为动画中心点位置加上偏移。            v.x = c.x + d.x;            v.y = c.y + d.y;            //将顶点设置给相应的格子。            setVertex(ccg(i ,j), v);        }    }}对应图：     上面讲的是操控网格数据表现一些基本动画的类。下面我们来看一下由这些基本动画的类衍生出来的复杂动画。   打开CCActionTiledGrid.h: #ifndef __ACTION_CCTILEDGRID_ACTION_H__#define __ACTION_CCTILEDGRID_ACTION_H__#include \"CCActionGrid.h\"//使用Cocos2d命名空间NS_CC_BEGIN//摇动的3D格子动画。class CC_DLL CCShakyTiles3D : public CCTiledGrid3DAction{public://初始化，参数一为范围大小，参数2为是否在Z值上摇动，参数3为格子的大小，参数4为动画的持续时间。    bool initWithRange(int nRange, bool bShakeZ, const ccGridSize& gridSize,        float duration);\t//创建一个当前类的实例拷贝virtual CCObject* copyWithZone(CCZone* pZone);//更新动画。    virtual void update(float time);public:    //静态函数：创建一个摇动的3D格子动画。参一为范围大小，参数2为是否在Z值上摇动，参数3为格子的大小，参数4为动画的持续时间。内部调用create实现。    CC_DEPRECATED_ATTRIBUTE static CCShakyTiles3D* actionWithRange(int nRange, bool bShakeZ, const ccGridSize& gridSize, float duration);    //上面的create实现。    static CCShakyTiles3D* create(int nRange, bool bShakeZ, const ccGridSize& gridSize, float duration);protected:\t//随机范围。int m_nRandrange;//是否在Z值上摇动    bool m_bShakeZ;};struct Tile{    CCPoint    position;    CCPoint    startPosition;    ccGridSize    delta;};//静态函数：创建一个摇动的3D格子动画。参一为范围大小，参数2为是否在Z值上摇动，参数3为格子的大小，参数4为动画的持续时间。内部调用create实现。CCShakyTiles3D* CCShakyTiles3D::actionWithRange(int nRange, bool bShakeZ,const ccGridSize& gridSize, float duration){    return CCShakyTiles3D::create(nRange, bShakeZ, gridSize, duration);    }//上面的create实现。CCShakyTiles3D* CCShakyTiles3D::create(int nRange, bool bShakeZ,const ccGridSize& gridSize, float duration){\t//先new出一个当前类的实例。    CCShakyTiles3D *pAction = new CCShakyTiles3D();\t//如果成功。初始化并交由内存管理器进行引用计数管理。    if (pAction)    {        if (pAction->initWithRange(nRange, bShakeZ, gridSize, duration))        {            pAction->autorelease();        }        else        {\t//失败处理。            CC_SAFE_RELEASE_NULL(pAction);        }    }\t//返回结果。    return pAction;    }//初始化。bool CCShakyTiles3D::initWithRange(int nRange, bool bShakeZ, const ccGridSize& gridSize, float duration){\t//先调用基类的相应函数。    if (CCTiledGrid3DAction::initWithSize(gridSize, duration)){\t//保存相应的值到成员变量。        m_nRandrange = nRange;        m_bShakeZ = bShakeZ;        return true;    }    return false;}//产生一个当前类的实例拷贝。讲的太多，略过。CCObject* CCShakyTiles3D::copyWithZone(CCZone *pZone){    CCZone* pNewZone = NULL;    CCShakyTiles3D* pCopy = NULL;    if(pZone && pZone->m_pCopyObject)     {        //in case of being called at sub class        pCopy = (CCShakyTiles3D*)(pZone->m_pCopyObject);    }    else    {        pCopy = new CCShakyTiles3D();        pZone = pNewZone = new CCZone(pCopy);    }        CCTiledGrid3DAction::copyWithZone(pZone);    pCopy->initWithRange(m_nRandrange, m_bShakeZ, m_sGridSize, m_fDuration);        CC_SAFE_DELETE(pNewZone);    return pCopy;}//更新动画。void CCShakyTiles3D::update(float time){    CC_UNUSED_PARAM(time);    int i, j;\t//双循环遍历每个格子。    for (i = 0; i < m_sGridSize.x; ++i)    {        for (j = 0; j < m_sGridSize.y; ++j)        {\t\t\t//取得格子的位置。            ccQuad3 coords = originalTile(ccg(i, j));            // 计算格子四个顶点的X坐标。            coords.bl.x += ( rand() % (m_nRandrange*2) ) - m_nRandrange;            coords.br.x += ( rand() % (m_nRandrange*2) ) - m_nRandrange;            coords.tl.x += ( rand() % (m_nRandrange*2) ) - m_nRandrange;            coords.tr.x += ( rand() % (m_nRandrange*2) ) - m_nRandrange;            // 计算格子四个顶点的Y坐标。            coords.bl.y += ( rand() % (m_nRandrange*2) ) - m_nRandrange;            coords.br.y += ( rand() % (m_nRandrange*2) ) - m_nRandrange;            coords.tl.y += ( rand() % (m_nRandrange*2) ) - m_nRandrange;            coords.tr.y += ( rand() % (m_nRandrange*2) ) - m_nRandrange;\t\t\t // 是否在Z轴上摇动。            if (m_bShakeZ)            {\t\t\t\t  //如果摇动在四个顶点的Z值上有随机的加成。                coords.bl.z += ( rand() % (m_nRandrange*2) ) - m_nRandrange;                coords.br.z += ( rand() % (m_nRandrange*2) ) - m_nRandrange;                coords.tl.z += ( rand() % (m_nRandrange*2) ) - m_nRandrange;                coords.tr.z += ( rand() % (m_nRandrange*2) ) - m_nRandrange;            }            //重新设置格子的顶点。            setTile(ccg(i, j), coords);        }    }}对应图： //随机抖动效果的3D网格动画。class CC_DLL CCShatteredTiles3D : public CCTiledGrid3DAction{public:    //初始化函数。    bool initWithRange(int nRange, bool bShatterZ, const ccGridSize& gridSize, float duration);\t//创建一个当前类的实例拷贝。virtual CCObject* copyWithZone(CCZone* pZone);//更新动画。    virtual void update(float time);public:    //静态函数：创建一个当前类的实例 。参一为范围，参数为是否在Z抽上震动，参三为格子大小，参四为动画时长。    CC_DEPRECATED_ATTRIBUTE static CCShatteredTiles3D* actionWithRange(int nRange, bool bShatterZ, const ccGridSize& gridSize,        float duration);    //上面的create实现。    static CCShatteredTiles3D* create(int nRange, bool bShatterZ, const ccGridSize& gridSize,        float duration);protected:\t//随机范围int m_nRandrange;//区分第一次渲染所用。bool m_bOnce;//是否在Z抽上震动。    bool m_bShatterZ;};//静态函数：创建一个当前类的实例 。参一为范围，参数为是否在Z抽上震动，参三为格子大小，参四为动画时长。CCShatteredTiles3D* CCShatteredTiles3D::actionWithRange(int nRange, bool bShatterZ, const ccGridSize& gridSize, float duration){    return CCShatteredTiles3D::create(nRange, bShatterZ, gridSize, duration);    }//上面的create实现。CCShatteredTiles3D* CCShatteredTiles3D::create(int nRange, bool bShatterZ, const ccGridSize& gridSize, float duration){\t//new,初始化，autorelease，失败处理一条龙！    CCShatteredTiles3D *pAction = new CCShatteredTiles3D();    if (pAction)    {        if (pAction->initWithRange(nRange, bShatterZ, gridSize, duration))        {            pAction->autorelease();        }        else        {            CC_SAFE_RELEASE_NULL(pAction);        }    }\t//返在回结果。    return pAction;    }//初始化。bool CCShatteredTiles3D::initWithRange(int nRange, bool bShatterZ, const ccGridSize& gridSize,  float duration){\t//先调用基类的初始化处理。    if (CCTiledGrid3DAction::initWithSize(gridSize, duration)){\t//设置标记提示在更新动理时指明是第一次进行更新。        m_bOnce = false;\t\t//将相应的参数值保存到成员变量中。        m_nRandrange = nRange;        m_bShatterZ = bShatterZ;        return true;    }    return false;}//产生一个当前类的实例。CCObject* CCShatteredTiles3D::copyWithZone(CCZone *pZone){    CCZone* pNewZone = NULL;    CCShatteredTiles3D* pCopy = NULL;    if(pZone && pZone->m_pCopyObject)    {        pCopy = (CCShatteredTiles3D*)(pZone->m_pCopyObject);    }    else    {        pCopy = new CCShatteredTiles3D();        pZone = pNewZone = new CCZone(pCopy);    }    //copy super class's member    CCTiledGrid3DAction::copyWithZone(pZone);    pCopy->initWithRange(m_nRandrange, m_bShatterZ, m_sGridSize, m_fDuration);    CC_SAFE_DELETE(pNewZone);    return pCopy;}//更新动画。void CCShatteredTiles3D::update(float time){    CC_UNUSED_PARAM(time);    int i, j;\t//如果是第一次渲染。    if (m_bOnce == false){\t //双循环遍历格子。        for (i = 0; i < m_sGridSize.x; ++i)        {            for (j = 0; j < m_sGridSize.y; ++j)            {\t\t\t\t  //取得格子的坐标。                ccQuad3 coords = originalTile(ccg(i ,j));                                // 计算格子四个顶点的X坐标。                coords.bl.x += ( rand() % (m_nRandrange*2) ) - m_nRandrange;                coords.br.x += ( rand() % (m_nRandrange*2) ) - m_nRandrange;                coords.tl.x += ( rand() % (m_nRandrange*2) ) - m_nRandrange;                coords.tr.x += ( rand() % (m_nRandrange*2) ) - m_nRandrange;                                // 计算格子四个顶点的Y坐标。                coords.bl.y += ( rand() % (m_nRandrange*2) ) - m_nRandrange;                coords.br.y += ( rand() % (m_nRandrange*2) ) - m_nRandrange;                coords.tl.y += ( rand() % (m_nRandrange*2) ) - m_nRandrange;                coords.tr.y += ( rand() % (m_nRandrange*2) ) - m_nRandrange;                if (m_bShatterZ)                 {                    coords.bl.z += ( rand() % (m_nRandrange*2) ) - m_nRandrange;                    coords.br.z += ( rand() % (m_nRandrange*2) ) - m_nRandrange;                                    coords.tl.z += ( rand() % (m_nRandrange*2) ) - m_nRandrange;                    coords.tr.z += ( rand() % (m_nRandrange*2) ) - m_nRandrange;                }                //重新设置格子的顶点。                setTile(ccg(i, j), coords);            }        }        //设置不是第一次更新。        m_bOnce = true;    }}struct Tile;对应图: //重新排列格子效果的3D网格动画。class CC_DLL CCShuffleTiles : public CCTiledGrid3DAction{public:\t//析构    ~CCShuffleTiles(void);    //初始化函数。bool initWithSeed(int s, const ccGridSize& gridSize, float duration);//重新排列处理void shuffle(int *pArray, unsigned int nLen);//取得ccGridSize getDelta(const ccGridSize& pos);//    void placeTile(const ccGridSize& pos, Tile *t);\t//重载基类的相应函数。    virtual void startWithTarget(CCNode *pTarget);    virtual void update(float time);    virtual CCObject* copyWithZone(CCZone* pZone);public:    //创建一个重新排列格子的动画:参一为，参二为格子大小，参三为动画时长。    CC_DEPRECATED_ATTRIBUTE static CCShuffleTiles* actionWithSeed(int s, const ccGridSize& gridSize, float duration);    //上面的create实现。    static CCShuffleTiles* create(int s, const ccGridSize& gridSize, float duration);protected:\t//    int             m_nSeed;    unsigned int m_nTilesCount;    int             *m_pTilesOrder;    Tile         *m_pTiles;};//创建一个重新排列格子的动画:参一为，参二为格子大小，参三为动画时长。CCShuffleTiles* CCShuffleTiles::actionWithSeed(int s, const ccGridSize& gridSize, float duration){    return CCShuffleTiles::create(s, gridSize, duration);    }//上面的create实现。CCShuffleTiles* CCShuffleTiles::create(int s, const ccGridSize& gridSize, float duration){\t//new ,初始化，autorelease,失败处理一条龙！    CCShuffleTiles *pAction = new CCShuffleTiles();    if (pAction)    {        if (pAction->initWithSeed(s, gridSize, duration))        {            pAction->autorelease();        }        else        {            CC_SAFE_RELEASE_NULL(pAction);        }    }    return pAction;    }//初始化处理。bool CCShuffleTiles::initWithSeed(int s, const ccGridSize& gridSize, float duration){\t//先调用基类的相应函数。    if (CCTiledGrid3DAction::initWithSize(gridSize, duration)){\t//将参数值保存到成员变量中。        m_nSeed = s;        m_pTilesOrder = NULL;        m_pTiles = NULL;        return true;    }    return false;}//产生一个当前类的实例拷贝。CCObject* CCShuffleTiles::copyWithZone(CCZone *pZone){    CCZone* pNewZone = NULL;    CCShuffleTiles* pCopy = NULL;    if(pZone && pZone->m_pCopyObject)    {        pCopy = (CCShuffleTiles*)(pZone->m_pCopyObject);    }    else    {        pCopy = new CCShuffleTiles();        pZone = pNewZone = new CCZone(pCopy);    }    CCTiledGrid3DAction::copyWithZone(pZone);    pCopy->initWithSeed(m_nSeed, m_sGridSize, m_fDuration);    CC_SAFE_DELETE(pNewZone);    return pCopy;}//析构。CCShuffleTiles::~CCShuffleTiles(void){\t//释放申请的内存。    CC_SAFE_DELETE_ARRAY(m_pTilesOrder);    CC_SAFE_DELETE_ARRAY(m_pTiles);}//重新随机排列处理。void CCShuffleTiles::shuffle(int *pArray, unsigned int nLen){\t//定义临时变量，并循环进行随机排列。    int i;    for( i = nLen - 1; i >= 0; i-- )    {        unsigned int j = rand() % (i+1);\t\t //随机交换        int v = pArray[i];        pArray[i] = pArray[j];        pArray[j] = v;    }}//取得ccGridSize CCShuffleTiles::getDelta(const ccGridSize& pos){    CCPoint    pos2;\t//计算格子的位置索引     unsigned int idx = pos.x * m_sGridSize.y + pos.y;\t//取出    pos2.x = (float)(m_pTilesOrder[idx] / (int)m_sGridSize.y);    pos2.y = (float)(m_pTilesOrder[idx] % (int)m_sGridSize.y);\t//    return ccg((int)(pos2.x - pos.x), (int)(pos2.y - pos.y));}//替换指定格子中的数据void CCShuffleTiles::placeTile(const ccGridSize& pos, Tile *t){\t//取得对应格子大小的原始顶点数据    ccQuad3 coords = originalTile(pos);\t//取得演员所用格子数据中格子的间隔。CCPoint step = m_pTarget->getGrid()->getStep();//计算出对应位置。    coords.bl.x += (int)(t->position.x * step.x);    coords.bl.y += (int)(t->position.y * step.y);    coords.br.x += (int)(t->position.x * step.x);    coords.br.y += (int)(t->position.y * step.y);    coords.tl.x += (int)(t->position.x * step.x);    coords.tl.y += (int)(t->position.y * step.y);    coords.tr.x += (int)(t->position.x * step.x);    coords.tr.y += (int)(t->position.y * step.y);\t//设置对应格子的数据。    setTile(pos, coords);}//设置演示当前动画的演员。void CCShuffleTiles::startWithTarget(CCNode *pTarget){\t//调用基类的相应函数。    CCTiledGrid3DAction::startWithTarget(pTarget);\t//如果m_nSeed有效，则做为随机种子。    if (m_nSeed != -1)    {        srand(m_nSeed);    }\t//创建索引数组m_pTilesOrder    m_nTilesCount = m_sGridSize.x * m_sGridSize.y;    m_pTilesOrder = new int[m_nTilesCount];    int i, j;    unsigned int k;    //将顺序索引填充到m_pTilesOrder    for (k = 0; k < m_nTilesCount; ++k)    {        m_pTilesOrder[k] = k;    }\t//对顺序索引数组进行重新随机排序。    shuffle(m_pTilesOrder, m_nTilesCount);\t//创建格子数据。    m_pTiles = (struct Tile *)new Tile[m_nTilesCount];    Tile *tileArray = (Tile*) m_pTiles;\t//双循环遍历，通过结构指针设置相应格子的数据。    for (i = 0; i < m_sGridSize.x; ++i)    {        for (j = 0; j < m_sGridSize.y; ++j)        {            tileArray->position = ccp((float)i, (float)j);            tileArray->startPosition = ccp((float)i, (float)j);            tileArray->delta = getDelta(ccg(i, j));            ++tileArray;        }    }}//更新动画。void CCShuffleTiles::update(float time){    int i, j;\t//取得格子的数据指针。    Tile *tileArray = (Tile*)m_pTiles;\t//双循环遍历。    for (i = 0; i < m_sGridSize.x; ++i)    {        for (j = 0; j < m_sGridSize.y; ++j)        {\t\t\t //重新计算格子位置。            tileArray->position = ccpMult(ccp((float)tileArray->delta.x, (float)tileArray->delta.y), time);\t\t\t  //将指针数据填充到对应格子。            placeTile(ccg(i, j), tileArray);            ++tileArray;        }    }}对应图： //从右上角开始渐隐格子的动画。class CC_DLL CCFadeOutTRTiles : public CCTiledGrid3DAction{public:\t//为了检测是否满足相应条件的函数。virtual float testFunc(const ccGridSize& pos, float time);//开启格子。void turnOnTile(const ccGridSize& pos);//关闭格子。void turnOffTile(const ccGridSize& pos);//跟据距离转换格子。virtual void transformTile(const ccGridSize& pos, float distance);//更新动画。    virtual void update(float time);public:    //静态函数：创建一个从右上角渐隐格子的动画。参一为格子大小，参二为。    CC_DEPRECATED_ATTRIBUTE static CCFadeOutTRTiles* actionWithSize(const ccGridSize& gridSize, float time);    //上面的create实现。    static CCFadeOutTRTiles* create(const ccGridSize& gridSize, float time);};//静态函数：创建一个从右上角渐隐格子的动画。参一为格子大小，参二为。CCFadeOutTRTiles* CCFadeOutTRTiles::actionWithSize(const ccGridSize& gridSize, float time){    return CCFadeOutTRTiles::create( gridSize, time);    }//上面的create实现。CCFadeOutTRTiles* CCFadeOutTRTiles::create(const ccGridSize& gridSize, float time){\t//new,初始化，autorelease，失败处理一条龙！    CCFadeOutTRTiles *pAction = new CCFadeOutTRTiles();    if (pAction)    {        if (pAction->initWithSize(gridSize, time))        {            pAction->autorelease();        }        else        {            CC_SAFE_RELEASE_NULL(pAction);        }    }    return pAction;    }//为了检测是否满足相应条件的函数。float CCFadeOutTRTiles::testFunc(const ccGridSize& pos, float time){\t//计算出格子的位置。CCPoint n = ccpMult(ccp((float)m_sGridSize.x, (float)m_sGridSize.y), time);//为了后面powf中的除法避免除零而做的判断。    if ((n.x + n.y) == 0.0f)    {        return 1.0f;    }\t//计算出一个powf处理后的值。    return powf((pos.x + pos.y) / (n.x + n.y), 6);}//开启格子。void CCFadeOutTRTiles::turnOnTile(const ccGridSize& pos){\t//设置格子位置为原始数据。    setTile(pos, originalTile(pos));}//关闭格子。void CCFadeOutTRTiles::turnOffTile(const ccGridSize& pos){\t//定义一个新的顶点数据，都清零后设置为对应格子的顶点数据。    ccQuad3 coords;    memset(&coords, 0, sizeof(ccQuad3));    setTile(pos, coords);}//跟据距离转换格子。void CCFadeOutTRTiles::transformTile(const ccGridSize& pos, float distance){\t//取得对应格子的顶点数据。ccQuad3 coords = originalTile(pos);//取得每个像素所占的图像大小。    CCPoint step = m_pTarget->getGrid()->getStep();\t//通过距离进行位置的重新计算。    coords.bl.x += (step.x / 2) * (1.0f - distance);    coords.bl.y += (step.y / 2) * (1.0f - distance);    coords.br.x -= (step.x / 2) * (1.0f - distance);    coords.br.y += (step.y / 2) * (1.0f - distance);    coords.tl.x += (step.x / 2) * (1.0f - distance);    coords.tl.y -= (step.y / 2) * (1.0f - distance);    coords.tr.x -= (step.x / 2) * (1.0f - distance);    coords.tr.y -= (step.y / 2) * (1.0f - distance);\t//用新数据设置对应格子的顶点数据。    setTile(pos, coords);}//更新动画。void CCFadeOutTRTiles::update(float time){    int i, j;\t//双循环遍历。    for (i = 0; i < m_sGridSize.x; ++i)    {        for (j = 0; j < m_sGridSize.y; ++j)        {\t\t\t //为了检测是否满足相应条件的函数，返回距离值。            float distance = testFunc(ccg(i, j), time);            if ( distance == 0 )            {\t\t\t\t //如果距离为0，关闭格子。                turnOffTile(ccg(i, j));            } else             if (distance < 1)            {\t\t\t\t  //如果距离在0~1间，进行格子的转换处理。                transformTile(ccg(i, j), distance);            }            else            {\t\t\t\t //如果距离大于等于1，开启格子。                turnOnTile(ccg(i, j));            }        }    }}对应图： //从左下角渐隐格子的动画。class CC_DLL CCFadeOutBLTiles : public CCFadeOutTRTiles{public:\t//检测是否满足相应条件的函数    virtual float testFunc(const ccGridSize& pos, float time);public:    //静态函数：创建一个从左下角渐隐格子的动画。参一为格子大小，参二为。    CC_DEPRECATED_ATTRIBUTE static CCFadeOutBLTiles* actionWithSize(const ccGridSize& gridSize, float time);//上面的create实现。    static CCFadeOutBLTiles* create(const ccGridSize& gridSize, float time);};// //静态函数：创建一个从左下角渐隐格子的动画。参一为格子大小，参二为。CCFadeOutBLTiles* CCFadeOutBLTiles::actionWithSize(const ccGridSize& gridSize, float time){    return CCFadeOutBLTiles::create(gridSize, time);}//上面的create实现。CCFadeOutBLTiles* CCFadeOutBLTiles::create(const ccGridSize& gridSize, float time){\t//new ,初始化,autorelease,失败处理一条龙！    CCFadeOutBLTiles *pAction = new CCFadeOutBLTiles();    if (pAction)    {        if (pAction->initWithSize(gridSize, time))        {            pAction->autorelease();        }        else        {            CC_SAFE_RELEASE_NULL(pAction);        }    }    return pAction;}//检测是否满足相应条件的函数float CCFadeOutBLTiles::testFunc(const ccGridSize& pos, float time){\t//计算出格子的位置。CCPoint n = ccpMult(ccp((float)m_sGridSize.x, (float)m_sGridSize.y), (1.0f - time));//为了后面powf中的除法避免除零而做的判断。    if ((pos.x + pos.y) == 0)    {        return 1.0f;    }\t//计算出一个powf处理后的值。    return powf((n.x + n.y) / (pos.x + pos.y), 6);}//向上部渐隐格子的动画。class CC_DLL CCFadeOutUpTiles : public CCFadeOutTRTiles{public:\t//检测是否满足相应条件的函数virtual float testFunc(const ccGridSize& pos, float time);//跟据距离转换格子。    virtual void transformTile(const ccGridSize& pos, float distance);public://静态函数：创建一个从上部渐隐格子的动画。参一为格子大小，参二为动画时长。    CC_DEPRECATED_ATTRIBUTE static CCFadeOutUpTiles* actionWithSize(const ccGridSize& gridSize, float time);    //上面的create实现。    static CCFadeOutUpTiles* create(const ccGridSize& gridSize, float time);};//静态函数：创建一个从上部渐隐格子的动画。参一为格子大小，参二为动画时长。CCFadeOutUpTiles* CCFadeOutUpTiles::actionWithSize(const ccGridSize& gridSize, float time){    return CCFadeOutUpTiles::create(gridSize, time);}//上面的create实现。CCFadeOutUpTiles* CCFadeOutUpTiles::create(const ccGridSize& gridSize, float time){\t//new ,初始化,autorelease,失败处理一条龙！    CCFadeOutUpTiles *pAction = new CCFadeOutUpTiles();    if (pAction)    {        if (pAction->initWithSize(gridSize, time))        {            pAction->autorelease();        }        else        {            CC_SAFE_RELEASE_NULL(pAction);        }    }    return pAction;}//检测是否满足相应条件的函数float CCFadeOutUpTiles::testFunc(const ccGridSize& pos, float time){\t//计算出格子的位置。CCPoint n = ccpMult(ccp((float)m_sGridSize.x, (float)m_sGridSize.y), time);//为了后面powf中的除法避免除零而做的判断。    if (n.y == 0.0f)    {        return 1.0f;    }\t//计算出一个powf处理后的值。    return powf(pos.y / n.y, 6);}//跟据距离转换格子。void CCFadeOutUpTiles::transformTile(const ccGridSize& pos, float distance){\t//取得对应格子的顶点数据。ccQuad3 coords = originalTile(pos);//取得一个格子所占用的图像大小。    CCPoint step = m_pTarget->getGrid()->getStep();\t//通过距离进行位置的重新计算。\t//让格子的下部的Y值上移，上部的Y值下移，这样格子就像被压扁了一样的效果。    coords.bl.y += (step.y / 2) * (1.0f - distance);    coords.br.y += (step.y / 2) * (1.0f - distance);    coords.tl.y -= (step.y / 2) * (1.0f - distance);    coords.tr.y -= (step.y / 2) * (1.0f - distance);\t//设置格子的新位置。    setTile(pos, coords);}对应图: //从左下角渐隐格子的动画。class CC_DLL CCFadeOutBLTiles : public CCFadeOutTRTiles{public:\t//检测是否满足相应条件的函数    virtual float testFunc(const ccGridSize& pos, float time);public:    //静态函数：创建一个从左下角渐隐格子的动画。参一为格子大小，参二为。    CC_DEPRECATED_ATTRIBUTE static CCFadeOutBLTiles* actionWithSize(const ccGridSize& gridSize, float time);//上面的create实现。    static CCFadeOutBLTiles* create(const ccGridSize& gridSize, float time);};// //静态函数：创建一个从左下角渐隐格子的动画。参一为格子大小，参二为。CCFadeOutBLTiles* CCFadeOutBLTiles::actionWithSize(const ccGridSize& gridSize, float time){    return CCFadeOutBLTiles::create(gridSize, time);}//上面的create实现。CCFadeOutBLTiles* CCFadeOutBLTiles::create(const ccGridSize& gridSize, float time){\t//new ,初始化,autorelease,失败处理一条龙！    CCFadeOutBLTiles *pAction = new CCFadeOutBLTiles();    if (pAction)    {        if (pAction->initWithSize(gridSize, time))        {            pAction->autorelease();        }        else        {            CC_SAFE_RELEASE_NULL(pAction);        }    }    return pAction;}//检测是否满足相应条件的函数float CCFadeOutBLTiles::testFunc(const ccGridSize& pos, float time){\t//计算出格子的位置。CCPoint n = ccpMult(ccp((float)m_sGridSize.x, (float)m_sGridSize.y), (1.0f - time));//为了后面powf中的除法避免除零而做的判断。    if ((pos.x + pos.y) == 0)    {        return 1.0f;    }\t//计算出一个powf处理后的值。    return powf((n.x + n.y) / (pos.x + pos.y), 6);} 对应图： //向上部渐隐格子的动画。class CC_DLL CCFadeOutUpTiles : public CCFadeOutTRTiles{public:\t//检测是否满足相应条件的函数virtual float testFunc(const ccGridSize& pos, float time);//跟据距离转换格子。    virtual void transformTile(const ccGridSize& pos, float distance);public://静态函数：创建一个从上部渐隐格子的动画。参一为格子大小，参二为动画时长。    CC_DEPRECATED_ATTRIBUTE static CCFadeOutUpTiles* actionWithSize(const ccGridSize& gridSize, float time);    //上面的create实现。    static CCFadeOutUpTiles* create(const ccGridSize& gridSize, float time);};//静态函数：创建一个从上部渐隐格子的动画。参一为格子大小，参二为动画时长。CCFadeOutUpTiles* CCFadeOutUpTiles::actionWithSize(const ccGridSize& gridSize, float time){    return CCFadeOutUpTiles::create(gridSize, time);}//上面的create实现。CCFadeOutUpTiles* CCFadeOutUpTiles::create(const ccGridSize& gridSize, float time){\t//new ,初始化,autorelease,失败处理一条龙！    CCFadeOutUpTiles *pAction = new CCFadeOutUpTiles();    if (pAction)    {        if (pAction->initWithSize(gridSize, time))        {            pAction->autorelease();        }        else        {            CC_SAFE_RELEASE_NULL(pAction);        }    }    return pAction;}//检测是否满足相应条件的函数float CCFadeOutUpTiles::testFunc(const ccGridSize& pos, float time){\t//计算出格子的位置。CCPoint n = ccpMult(ccp((float)m_sGridSize.x, (float)m_sGridSize.y), time);//为了后面powf中的除法避免除零而做的判断。    if (n.y == 0.0f)    {        return 1.0f;    }\t//计算出一个powf处理后的值。    return powf(pos.y / n.y, 6);}//跟据距离转换格子。void CCFadeOutUpTiles::transformTile(const ccGridSize& pos, float distance){\t//取得对应格子的顶点数据。ccQuad3 coords = originalTile(pos);//取得一个格子所占用的图像大小。    CCPoint step = m_pTarget->getGrid()->getStep();\t//通过距离进行位置的重新计算。\t//让格子的下部的Y值上移，上部的Y值下移，这样格子就像被压扁了一样的效果。    coords.bl.y += (step.y / 2) * (1.0f - distance);    coords.br.y += (step.y / 2) * (1.0f - distance);    coords.tl.y -= (step.y / 2) * (1.0f - distance);    coords.tr.y -= (step.y / 2) * (1.0f - distance);\t//设置格子的新位置。    setTile(pos, coords);}对应图: //向下部渐隐格子的动画。class CC_DLL CCFadeOutDownTiles : public CCFadeOutUpTiles{public:\t//检测是否满足相应条件的函数    virtual float testFunc(const ccGridSize& pos, float time);public: //静态函数：创建一个从下部渐隐格子的动画。参一为格子大小，参二为动画时长。    CC_DEPRECATED_ATTRIBUTE static CCFadeOutDownTiles* actionWithSize(const ccGridSize& gridSize, float time);    //上面的create实现。    static CCFadeOutDownTiles* create(const ccGridSize& gridSize, float time);};//静态函数：创建一个从下部渐隐格子的动画。参一为格子大小，参二为动画时长。CCFadeOutDownTiles* CCFadeOutDownTiles::actionWithSize(const ccGridSize& gridSize, float time){    return CCFadeOutDownTiles::create(gridSize, time);}//上面的create实现。CCFadeOutDownTiles* CCFadeOutDownTiles::create(const ccGridSize& gridSize, float time){\t//new ,初始化,autorelease,失败处理一条龙！    CCFadeOutDownTiles *pAction = new CCFadeOutDownTiles();    if (pAction)    {        if (pAction->initWithSize(gridSize, time))        {            pAction->autorelease();        }        else        {            CC_SAFE_RELEASE_NULL(pAction);        }    }    return pAction;}//检测是否满足相应条件的函数float CCFadeOutDownTiles::testFunc(const ccGridSize& pos, float time){\t//计算出格子的位置。CCPoint n = ccpMult(ccp((float)m_sGridSize.x, (float)m_sGridSize.y), (1.0f - time));//为了后面powf中的除法避免除零而做的判断。    if (pos.y == 0)    {        return 1.0f;    }\t//计算出一个powf处理后的值。    return powf(n.y / pos.y, 6);}对应图: //格子的消失动画class CC_DLL CCTurnOffTiles : public CCTiledGrid3DAction{public:\t//析构    ~CCTurnOffTiles(void);    //初始化bool initWithSeed(int s, const ccGridSize& gridSize, float duration);//重新排列格子。void shuffle(int *pArray, unsigned int nLen);//开启格子。void turnOnTile(const ccGridSize& pos);//关闭格子。    void turnOffTile(const ccGridSize& pos);\t//重载基类的相应函数。    virtual CCObject* copyWithZone(CCZone* pZone);    virtual void startWithTarget(CCNode *pTarget);    virtual void update(float time);public:    //创建一个    CC_DEPRECATED_ATTRIBUTE static CCTurnOffTiles* actionWithSize(const ccGridSize& size, float d);    //     CC_DEPRECATED_ATTRIBUTE static CCTurnOffTiles* actionWithSeed(int s, const ccGridSize& gridSize, float duration);    //上面的create实现。    static CCTurnOffTiles* create(const ccGridSize& size, float d);    //上面的create实现。    static CCTurnOffTiles* create(int s, const ccGridSize& gridSize, float duration);protected:    int                m_nSeed;    unsigned int    m_nTilesCount;    int                *m_pTilesOrder;};//创建一个CCTurnOffTiles* CCTurnOffTiles::actionWithSize(const ccGridSize& size, float d){    return CCTurnOffTiles::create( size, d);}//上面的create实现。CCTurnOffTiles* CCTurnOffTiles::create(const ccGridSize& size, float d){\t//new ,初始化,autorelease,失败处理一条龙！    CCTurnOffTiles* pAction = new CCTurnOffTiles();    if (pAction->initWithSize(size, d))    {        pAction->autorelease();    }    else    {        CC_SAFE_RELEASE_NULL(pAction);    }    return pAction;}//创建一个CCTurnOffTiles* CCTurnOffTiles::actionWithSeed(int s, const ccGridSize& gridSize, float duration){    return CCTurnOffTiles::create(s, gridSize, duration);}//上面的create实现。CCTurnOffTiles* CCTurnOffTiles::create(int s, const ccGridSize& gridSize, float duration){\t//new ,初始化,autorelease,失败处理一条龙！    CCTurnOffTiles *pAction = new CCTurnOffTiles();    if (pAction)    {        if (pAction->initWithSeed(s, gridSize, duration))        {            pAction->autorelease();        }        else        {            CC_SAFE_RELEASE_NULL(pAction);        }    }    return pAction;}//初始化。bool CCTurnOffTiles::initWithSeed(int s, const ccGridSize& gridSize, float duration){\t//调用基类的相应函数。    if (CCTiledGrid3DAction::initWithSize(gridSize, duration)){\t//保存参数到成员变量。        m_nSeed = s;        m_pTilesOrder = NULL;        return true;    }    return false;}//产生一个当前类的实例拷贝。CCObject* CCTurnOffTiles::copyWithZone(CCZone *pZone){    CCZone* pNewZone = NULL;    CCTurnOffTiles* pCopy = NULL;    if(pZone && pZone->m_pCopyObject)     {        pCopy = (CCTurnOffTiles*)(pZone->m_pCopyObject);    }    else    {        pCopy = new CCTurnOffTiles();        pZone = pNewZone = new CCZone(pCopy);    }    CCTiledGrid3DAction::copyWithZone(pZone);    pCopy->initWithSeed(m_nSeed, m_sGridSize, m_fDuration);    CC_SAFE_DELETE(pNewZone);    return pCopy;}//析构。CCTurnOffTiles::~CCTurnOffTiles(void){    CC_SAFE_DELETE_ARRAY(m_pTilesOrder);}//重新随机排列。void CCTurnOffTiles::shuffle(int *pArray, unsigned int nLen){\t//定义临时变量，并循环进行随机排列。    int i;    for (i = nLen - 1; i >= 0; i--){\t//随机交换。        unsigned int j = rand() % (i+1);        int v = pArray[i];        pArray[i] = pArray[j];        pArray[j] = v;    }}//开启格子void CCTurnOffTiles::turnOnTile(const ccGridSize& pos){\t//设置格子的数据为原始数据。    setTile(pos, originalTile(pos));}//关闭格子。void CCTurnOffTiles::turnOffTile(const ccGridSize& pos){\t//定义一个新的顶点数据，都清零后设置为对应格子的顶点数据。    ccQuad3 coords;    memset(&coords, 0, sizeof(ccQuad3));    setTile(pos, coords);}//设置演示当前动画的演员。void CCTurnOffTiles::startWithTarget(CCNode *pTarget){\t//    unsigned int i;\t//调用基类的相应函数。    CCTiledGrid3DAction::startWithTarget(pTarget);\t//初始化随机种子。    if (m_nSeed != -1)    {        srand(m_nSeed);    }\t//取得格子数量m_nTilesCount = m_sGridSize.x * m_sGridSize.y;//创建相应大小的排序索引数组。    m_pTilesOrder = new int[m_nTilesCount];\t//填充数据。    for (i = 0; i < m_nTilesCount; ++i)    {        m_pTilesOrder[i] = i;    }\t//随机排列格子。    shuffle(m_pTilesOrder, m_nTilesCount);}//更新动画。void CCTurnOffTiles::update(float time){    unsigned int i, l, t;\t//通过进度值计算要消失的格子的数量。    l = (int)(time * (float)m_nTilesCount);\t//遍历每个格子    for( i = 0; i < m_nTilesCount; i++ ){\t//取出顺序索引，并计算出相应的格子位置。        t = m_pTilesOrder[i];        ccGridSize tilePos = ccg( t / m_sGridSize.y, t % m_sGridSize.y );\t\t//如果当前索引i小于要消失的可子的数量值，关闭格子。        if ( i < l )        {            turnOffTile(tilePos);        }        else        {\t//开启格子。            turnOnTile(tilePos);        }    }}对应图: //波浪状的格子动画。class CC_DLL CCWavesTiles3D : public CCTiledGrid3DAction{public:    //取得和设置振幅。    inline float getAmplitude(void) { return m_fAmplitude; }    inline void setAmplitude(float fAmplitude) { m_fAmplitude = fAmplitude; }    //取得和设置频率。    inline float getAmplitudeRate(void) { return m_fAmplitudeRate; }    inline void setAmplitudeRate(float fAmplitudeRate) { m_fAmplitudeRate = fAmplitudeRate; }    //初始化波浪状网格的动画    bool initWithWaves(int wav, float amp, const ccGridSize& gridSize, float duration);\t//创建一个当前类的实例拷贝。virtual CCObject* copyWithZone(CCZone* pZone);//更新动画。    virtual void update(float time);public:    //静态函数：创建一个当前类的实例对象指针，参数一为    CC_DEPRECATED_ATTRIBUTE static CCWavesTiles3D* actionWithWaves(int wav, float amp, const ccGridSize& gridSize, float duration);    //上面的create实现。    static CCWavesTiles3D* create(int wav, float amp, const ccGridSize& gridSize, float duration);protected:int m_nWaves;//振幅。float m_fAmplitude;//频率。    float m_fAmplitudeRate;};//静态函数：创建一个当前类的实例对象指针，参数一为CCWavesTiles3D* CCWavesTiles3D::actionWithWaves(int wav, float amp, const ccGridSize& gridSize, float duration){    return CCWavesTiles3D::create(wav, amp, gridSize, duration);}//上面的create实现。CCWavesTiles3D* CCWavesTiles3D::create(int wav, float amp, const ccGridSize& gridSize, float duration){\t//new ,初始化,autorelease,失败处理一条龙！    CCWavesTiles3D *pAction = new CCWavesTiles3D();    if (pAction)    {        if (pAction->initWithWaves(wav, amp, gridSize, duration))        {            pAction->autorelease();        }        else        {            CC_SAFE_RELEASE_NULL(pAction);        }    }    return pAction;}//初始化。bool CCWavesTiles3D::initWithWaves(int wav, float amp, const ccGridSize& gridSize, float duration){\t//调用基类的初始化函数。    if (CCTiledGrid3DAction::initWithSize(gridSize, duration)){\t//将相应参数保存到成员变量中。        m_nWaves = wav;        m_fAmplitude = amp;        m_fAmplitudeRate = 1.0f;        return true;    }    return false;}//产生一个当前类的实例拷贝。CCObject* CCWavesTiles3D::copyWithZone(CCZone *pZone){    CCZone* pNewZone = NULL;    CCWavesTiles3D* pCopy = NULL;    if(pZone && pZone->m_pCopyObject)    {        pCopy = (CCWavesTiles3D*)(pZone->m_pCopyObject);    }    else    {        pCopy = new CCWavesTiles3D();        pZone = pNewZone = new CCZone(pCopy);    }    CCTiledGrid3DAction::copyWithZone(pZone);    pCopy->initWithWaves(m_nWaves, m_fAmplitude, m_sGridSize, m_fDuration);    CC_SAFE_DELETE(pNewZone);    return pCopy;}//更新动画。void CCWavesTiles3D::update(float time){    int i, j;\t//双循环遍历。    for( i = 0; i < m_sGridSize.x; i++ )    {        for( j = 0; j < m_sGridSize.y; j++ )        {\t\t\t//取得对应格子的顶点数据。            ccQuad3 coords = originalTile(ccg(i, j));\t\t\t //重新设置顶点数据位置。            coords.bl.z = (sinf(time * (float)M_PI  *m_nWaves * 2 +                 (coords.bl.y+coords.bl.x) * .01f) * m_fAmplitude * m_fAmplitudeRate );            coords.br.z    = coords.bl.z;            coords.tl.z = coords.bl.z;            coords.tr.z = coords.bl.z;\t\t\t //将新的位置数据设置给相应格子。            setTile(ccg(i, j), coords);        }    }}对应图: //跳动的格子动画。class CC_DLL CCJumpTiles3D : public CCTiledGrid3DAction{public:    //取得跳动的范围。    inline float getAmplitude(void) { return m_fAmplitude; }    inline void setAmplitude(float fAmplitude) { m_fAmplitude = fAmplitude; }//取和和设置频率。    inline float getAmplitudeRate(void) { return m_fAmplitudeRate; }    inline void setAmplitudeRate(float fAmplitudeRate) { m_fAmplitudeRate = fAmplitudeRate; }    //初始化。bool initWithJumps(int j, float amp, const ccGridSize& gridSize, float duration);//创建一个当前类的实例拷贝。virtual CCObject* copyWithZone(CCZone* pZone);//更新动画。    virtual void update(float time);public:    //静态函数：创建一个当前类的动画实例。    CC_DEPRECATED_ATTRIBUTE static CCJumpTiles3D* actionWithJumps(int j, float amp, const ccGridSize& gridSize, float duration);    //上面的create实现。    static CCJumpTiles3D* create(int j, float amp, const ccGridSize& gridSize, float duration);protected:\t//跳跃的次数。int m_nJumps;//振幅。float m_fAmplitude;//频率。    float m_fAmplitudeRate;};//静态函数：创建一个当前类的动画实例。CCJumpTiles3D* CCJumpTiles3D::actionWithJumps(int j, float amp, const ccGridSize& gridSize, float duration){    return CCJumpTiles3D::create(j, amp, gridSize, duration);}//上面的create实现。CCJumpTiles3D* CCJumpTiles3D::create(int j, float amp, const ccGridSize& gridSize, float duration){\t//new ,初始化,autorelease,失败处理一条龙！    CCJumpTiles3D *pAction = new CCJumpTiles3D();    if (pAction)    {        if (pAction->initWithJumps(j, amp, gridSize, duration))        {            pAction->autorelease();        }        else        {            CC_SAFE_RELEASE_NULL(pAction);        }    }    return pAction;}//初始化。bool CCJumpTiles3D::initWithJumps(int j, float amp, const ccGridSize& gridSize, float duration){\t//调用基类的相应函数。    if (CCTiledGrid3DAction::initWithSize(gridSize, duration)){\t//保存参数到成员变量。        m_nJumps = j;        m_fAmplitude = amp;        m_fAmplitudeRate = 1.0f;        return true;    }    return false;}//产生一个当前类的实例拷贝。CCObject* CCJumpTiles3D::copyWithZone(CCZone *pZone){    CCZone* pNewZone = NULL;    CCJumpTiles3D* pCopy = NULL;    if(pZone && pZone->m_pCopyObject)     {        pCopy = (CCJumpTiles3D*)(pZone->m_pCopyObject);    }    else    {        pCopy = new CCJumpTiles3D();        pZone = pNewZone = new CCZone(pCopy);    }    CCTiledGrid3DAction::copyWithZone(pZone);    pCopy->initWithJumps(m_nJumps, m_fAmplitude, m_sGridSize, m_fDuration);    CC_SAFE_DELETE(pNewZone);    return pCopy;}//更新动画。void CCJumpTiles3D::update(float time){    int i, j;\t//定义两个临时变量，分别设置为不同的sin曲线变化值。    float sinz =  (sinf((float)M_PI * time * m_nJumps * 2) * m_fAmplitude * m_fAmplitudeRate );    float sinz2 = (sinf((float)M_PI * (time * m_nJumps * 2 + 1)) * m_fAmplitude * m_fAmplitudeRate );\t//双循环遍历。    for( i = 0; i < m_sGridSize.x; i++ )    {        for( j = 0; j < m_sGridSize.y; j++ )        {\t\t\t//取得对应格子的顶点数据。            ccQuad3 coords = originalTile(ccg(i, j));\t\t\t//(i+j)的值对2取模，可以实现上，下，左，右相邻的Z值加成不同。            if ( ((i+j) % 2) == 0 )            {                coords.bl.z += sinz;                coords.br.z += sinz;                coords.tl.z += sinz;                coords.tr.z += sinz;            }            else            {                coords.bl.z += sinz2;                coords.br.z += sinz2;                coords.tl.z += sinz2;                coords.tr.z += sinz2;            }\t\t\t //将新的顶点数据设置给相应格子。            setTile(ccg(i, j), coords);        }    }}对应图: //横向分割的格子动画。class CC_DLL CCSplitRows : public CCTiledGrid3DAction{public :    //初始化。    bool initWithRows(int nRows, float duration);\t//重载基类的相应函数。    virtual CCObject* copyWithZone(CCZone* pZone);    virtual void update(float time);    virtual void startWithTarget(CCNode *pTarget);public:    //静态函数：创建一个横向分割的格子动画。参一为横向分的份数，参二为动画时长。内部调用create实现。    CC_DEPRECATED_ATTRIBUTE static CCSplitRows* actionWithRows(int nRows, float duration);    //上面的create实现。    static CCSplitRows* create(int nRows, float duration);protected:\t//切分的行数。int m_nRows;//屏幕大小。    CCSize m_winSize;};//静态函数：创建一个横向分割的格子动画。参一为横向分的份数，参二为动画时长。内部调用create实现。CCSplitRows* CCSplitRows::actionWithRows(int nRows, float duration){    return CCSplitRows::create(nRows, duration);}//上面的create实现。CCSplitRows* CCSplitRows::create(int nRows, float duration){\t//new ,初始化,autorelease,失败处理一条龙！    CCSplitRows *pAction = new CCSplitRows();    if (pAction)    {        if (pAction->initWithRows(nRows, duration))        {            pAction->autorelease();        }        else        {            CC_SAFE_RELEASE_NULL(pAction);        }    }    return pAction;}//初始化。bool CCSplitRows::initWithRows(int nRows, float duration){\t//保存切分的份数。    m_nRows = nRows;//将切分的份数做为参数放在格子大小的Y值中初始化3D格子动画。    return CCTiledGrid3DAction::initWithSize(ccg(1, nRows), duration);}//产生一个当前类的实例拷贝。CCObject* CCSplitRows::copyWithZone(CCZone *pZone){    CCZone* pNewZone = NULL;    CCSplitRows* pCopy = NULL;    if(pZone && pZone->m_pCopyObject)     {        pCopy = (CCSplitRows*)(pZone->m_pCopyObject);    }    else    {        pCopy = new CCSplitRows();        pZone = pNewZone = new CCZone(pCopy);    }    CCTiledGrid3DAction::copyWithZone(pZone);    pCopy->initWithRows(m_nRows, m_fDuration);    CC_SAFE_DELETE(pNewZone);    return pCopy;}//以置演示当前动画的演员。void CCSplitRows::startWithTarget(CCNode *pTarget){    CCTiledGrid3DAction::startWithTarget(pTarget);    m_winSize = CCDirector::sharedDirector()->getWinSizeInPixels();}//更新动画。void CCSplitRows::update(float time){    int j;\t//遍历切分的格子。在初始化时说过格子大小的Y值中保存了切分的份数。    for (j = 0; j < m_sGridSize.y; ++j){\t//通过格子的的索引取得原始的顶点位置。        ccQuad3 coords = originalTile(ccg(0, j));//创建临时变量保存方向。        float    direction = 1;\t\t//对i取2的模，可使相邻的切分块方向不同。        if ( (j % 2 ) == 0 )        {            direction = -1;        }\t\t//根据方向来对顶点X值进行偏移。        coords.bl.x += direction * m_winSize.width * time;        coords.br.x += direction * m_winSize.width * time;        coords.tl.x += direction * m_winSize.width * time;        coords.tr.x += direction * m_winSize.width * time;\t\t//设置格子的顶点数据，这样就可以实现每个切分格子的运动了。        setTile(ccg(0, j), coords);    }}对应图: //纵向切分的格子运动动画。class CC_DLL CCSplitCols : public CCTiledGrid3DAction{public:    //初始化。    bool initWithCols(int nCols, float duration);\t//重载基类的相应函数。    virtual CCObject* copyWithZone(CCZone* pZone);    virtual void update(float time);    virtual void startWithTarget(CCNode *pTarget);public:    //静态函数：创建一个纵向分割的格子动画。参一为纵向切分的份数，参二为动画时长。内部调用create实现。    CC_DEPRECATED_ATTRIBUTE static CCSplitCols* actionWithCols(int nCols, float duration);    //上面的create实现。    static CCSplitCols* create(int nCols, float duration);protected:\t//切分的列数。int m_nCols;//屏幕大小。    CCSize m_winSize;};//静态函数：创建一个纵向分割的格子动画。参一为纵向切分的份数，参二为动画时长。内部调用create实现。CCSplitCols* CCSplitCols::actionWithCols(int nCols, float duration){    return CCSplitCols::create(nCols, duration);}//上面的create实现。CCSplitCols* CCSplitCols::create(int nCols, float duration){\t//new ,初始化,autorelease,失败处理一条龙！    CCSplitCols *pAction = new CCSplitCols();    if (pAction)    {        if (pAction->initWithCols(nCols, duration))        {            pAction->autorelease();        }        else        {            CC_SAFE_RELEASE_NULL(pAction);        }    }    return pAction;}//初始化。bool CCSplitCols::initWithCols(int nCols, float duration){\t//保存切分的份数。m_nCols = nCols;//将切分的份数做为参数放在格子大小的X值中初始化3D格子动画。    return CCTiledGrid3DAction::initWithSize(ccg(nCols, 1), duration);}//产生一个当前类的实例拷贝。CCObject* CCSplitCols::copyWithZone(CCZone *pZone){    CCZone* pNewZone = NULL;    CCSplitCols* pCopy = NULL;    if(pZone && pZone->m_pCopyObject)     {        pCopy = (CCSplitCols*)(pZone->m_pCopyObject);    }    else    {        pCopy = new CCSplitCols();        pZone = pNewZone = new CCZone(pCopy);    }    CCTiledGrid3DAction::copyWithZone(pZone);    pCopy->initWithCols(m_nCols, m_fDuration);    CC_SAFE_DELETE(pNewZone);    return pCopy;}//设置演示当前动画的演员。void CCSplitCols::startWithTarget(CCNode *pTarget){\t//调用基类的相应函数。CCTiledGrid3DAction::startWithTarget(pTarget);//取得屏幕大小    m_winSize = CCDirector::sharedDirector()->getWinSizeInPixels();}//更新动画。void CCSplitCols::update(float time){    int i;\t//遍历切分的格子。在初始化时说过格子大小的X值中保存了切分的份数。    for (i = 0; i < m_sGridSize.x; ++i){\t//通过格子的的索引取得原始的顶点位置。        ccQuad3 coords = originalTile(ccg(i, 0));\t\t//创建临时变量保存方向。        float    direction = 1;\t\t//对i取2的模，可使相邻的切分块方向不同。        if ( (i % 2 ) == 0 )        {            direction = -1;        }\t\t//根据方向来对顶点Y值进行偏移。        coords.bl.y += direction * m_winSize.height * time;        coords.br.y += direction * m_winSize.height * time;        coords.tl.y += direction * m_winSize.height * time;        coords.tr.y += direction * m_winSize.height * time;\t\t//设置格子的顶点数据，这样就可以实现每个切分格子的运动了。        setTile(ccg(i, 0), coords);    }}对应图: 最后我们来看一下EffectsTest的场景演示方面的代码： EffectsTest.h: //由TestScene派生出一个场景。class EffectTestScene : public TestScene{public:    //运行这个场景。    virtual void runThisTest();};//由CCLayerColor派生出一个TextLayer，用于演示各动画效果。class TextLayer : public CCLayerColor{protected:    //UxString    m_strTitle;public:    TextLayer(void);    ~TextLayer(void);    void checkAnim(float dt);    virtual void onEnter();    void restartCallback(CCObject* pSender);    void nextCallback(CCObject* pSender);    void backCallback(CCObject* pSender);    void newScene();    static TextLayer* create();}; 对应CPP: //enum {    kTagTextLayer = 1,    kTagBackground = 1,    kTagLabel = 2,};//动画的索引static int actionIdx=0; //效果标题列表。static std::string effectsList[] ={    \"Shaky3D\",    \"Waves3D\",    \"FlipX3D\",    \"FlipY3D\",    \"Lens3D\",    \"Ripple3D\",    \"Liquid\",    \"Waves\",    \"Twirl\",    \"ShakyTiles3D\",    \"ShatteredTiles3D\",    \"ShuffleTiles\",    \"FadeOutTRTiles\",    \"FadeOutBLTiles\",    \"FadeOutUpTiles\",    \"FadeOutDownTiles\",    \"TurnOffTiles\",    \"WavesTiles3D\",    \"JumpTiles3D\",    \"SplitRows\",    \"SplitCols\",    \"PageTurn3D\",}; //由CCShaky3D派生出一个动画演示。class Shaky3DDemo : public CCShaky3D {public:    //重载其创建函数。    static CCActionInterval* create(float t)    {\t\t //调用基类相应函数创建一个具体的动画演示。        return CCShaky3D::create(5, false, ccg(15,10), t);    }};//由CCWaves3D派生出一个动画演示。class Waves3DDemo : public CCWaves3D {public:    //重载其创建函数。    static CCActionInterval* create(float t)    {        //调用基类相应函数创建一个具体的动画演示。        return CCWaves3D::create(5, 40, ccg(15,10), t);    }};//由CCFlipX3D派生出一个动画演示。class FlipX3DDemo : public CCFlipX3D {public:    //重载其创建函数。    static CCActionInterval* create(float t)    {        CCFlipX3D* flipx  = CCFlipX3D::create(t);        CCActionInterval* flipx_back = flipx->reverse();        CCDelayTime* delay = CCDelayTime::create(2);        //调用基类相应函数创建一个具体的动画演示。        return (CCActionInterval*)(CCSequence::create(flipx, delay, flipx_back, NULL));    }};//由CCFlipY3D派生出一个动画演示。class FlipY3DDemo : public CCFlipY3D {public:    //重载其创建函数。    static CCActionInterval* create(float t)    {        CCFlipY3D* flipy  = CCFlipY3D::create(t);        CCActionInterval* flipy_back = flipy->reverse();        CCDelayTime* delay = CCDelayTime::create(2);        //调用基类相应函数创建一个具体的动画演示。        return (CCActionInterval*)(CCSequence::create(flipy, delay, flipy_back, NULL));    }};//由CCLens3D派生出一个动画演示。class Lens3DDemo : public CCLens3D {public:    //重载其创建函数。    static CCActionInterval* create(float t)    {        CCSize size = CCDirector::sharedDirector()->getWinSize();        //调用基类相应函数创建一个具体的动画演示。        return CCLens3D::create(CCPointMake(size.width/2,size.height/2), 240, ccg(15,10), t);     }};//由CCRipple3D派生出一个动画演示。class Ripple3DDemo : public CCRipple3D {public:    //重载其创建函数。    static CCActionInterval* create(float t)    {        CCSize size = CCDirector::sharedDirector()->getWinSize();        //调用基类相应函数创建一个具体的动画演示。        return CCRipple3D::create(CCPointMake(size.width/2,size.height/2), 240, 4, 160, ccg(32,24), t);    }};//由CCLiquid派生出一个动画演示。class LiquidDemo : public CCLiquid{public:     //重载其创建函数。    static CCActionInterval* create(float t)    {        //调用基类相应函数创建一个具体的动画演示。        return CCLiquid::create(4, 20, ccg(16,12), t);     }};//由CCWaves派生出一个动画演示。class WavesDemo : public CCWaves {public:    //重载其创建函数。    static CCActionInterval* create(float t)    {//调用基类相应函数创建一个具体的动画演示。        return CCWaves::create(4, 20, true, true, ccg(16,12), t);      }};//由CCTwirl派生出一个动画演示。class TwirlDemo : public CCTwirl {public:    //重载其创建函数。    static CCActionInterval* create(float t)    {//调用基类相应函数创建一个具体的动画演示。        CCSize size = CCDirector::sharedDirector()->getWinSize();        return CCTwirl::create(CCPointMake(size.width/2, size.height/2), 1, 2.5f, ccg(12,8), t);     }};//由CCShakyTiles3D派生出一个动画演示。class ShakyTiles3DDemo : public CCShakyTiles3D{public:    //重载其创建函数。    static CCActionInterval* create(float t)    {//调用基类相应函数创建一个具体的动画演示。        return CCShakyTiles3D::create(5, false, ccg(16,12), t) ;    }};//由CCShatteredTiles3D派生出一个动画演示。class ShatteredTiles3DDemo : public CCShatteredTiles3D{public:    //重载其创建函数。    static CCActionInterval* create(float t)    {//调用基类相应函数创建一个具体的动画演示。        return CCShatteredTiles3D::create(5, false, ccg(16,12), t);     }};//由CCShuffleTiles派生出一个动画演示。class ShuffleTilesDemo : public CCShuffleTiles{public:    //重载其创建函数。    static CCActionInterval* create(float t)    {        CCShuffleTiles* shuffle = CCShuffleTiles::create(25, ccg(16,12), t);        CCActionInterval* shuffle_back = shuffle->reverse();        CCDelayTime* delay = CCDelayTime::create(2);//调用基类相应函数创建一个具体的动画演示。        return (CCActionInterval*)(CCSequence::create(shuffle, delay, shuffle_back, NULL));    }};//由CCFadeOutTRTiles派生出一个动画演示。class FadeOutTRTilesDemo : public CCFadeOutTRTiles{public:    //重载其创建函数。    static CCActionInterval* create(float t)    {        CCFadeOutTRTiles* fadeout = CCFadeOutTRTiles::create(ccg(16,12), t);        CCActionInterval* back = fadeout->reverse();        CCDelayTime* delay = CCDelayTime::create(0.5f);        //调用基类相应函数创建一个具体的动画演示。        return (CCActionInterval*)(CCSequence::create(fadeout, delay, back, NULL));    }};//由CCFadeOutBLTiles派生出一个动画演示。class FadeOutBLTilesDemo : public CCFadeOutBLTiles{public:    //重载其创建函数。    static CCActionInterval* create(float t)    {        CCFadeOutBLTiles* fadeout = CCFadeOutBLTiles::create(ccg(16,12), t);        CCActionInterval* back = fadeout->reverse();        CCDelayTime* delay = CCDelayTime::create(0.5f);         //调用基类相应函数创建一个具体的动画演示。        return (CCActionInterval*)(CCSequence::create(fadeout, delay, back, NULL));    }};//由CCFadeOutUpTiles派生出一个动画演示。class FadeOutUpTilesDemo : public CCFadeOutUpTiles{public:    //重载其创建函数。    static CCActionInterval* create(float t)    {        CCFadeOutUpTiles* fadeout = CCFadeOutUpTiles::create(ccg(16,12), t);        CCActionInterval* back = fadeout->reverse();        CCDelayTime* delay = CCDelayTime::create(0.5f);        //调用基类相应函数创建一个具体的动画演示。        return (CCActionInterval*)(CCSequence::create(fadeout, delay, back, NULL));    }};//由CCFadeOutDownTiles派生出一个动画演示。class FadeOutDownTilesDemo : public CCFadeOutDownTiles{public:    //重载其创建函数。    static CCActionInterval* create(float t)    {        CCFadeOutDownTiles* fadeout = CCFadeOutDownTiles::create(ccg(16,12), t);        CCActionInterval* back = fadeout->reverse();        CCDelayTime* delay = CCDelayTime::create(0.5f);        //调用基类相应函数创建一个具体的动画演示。        return (CCActionInterval*)(CCSequence::create(fadeout, delay, back, NULL));    }};//由CCTurnOffTiles派生出一个动画演示。class TurnOffTilesDemo : public CCTurnOffTiles{public:    //重载其创建函数。    static CCActionInterval* create(float t)    {        CCTurnOffTiles* fadeout = CCTurnOffTiles::create(25, ccg(48,32) , t);        CCActionInterval* back = fadeout->reverse();        CCDelayTime* delay = CCDelayTime::create(0.5f);       //调用基类相应函数创建一个具体的动画演示。        return (CCActionInterval*)(CCSequence::create(fadeout, delay, back, NULL));    }};//由CCWavesTiles3D派生出一个动画演示。class WavesTiles3DDemo : public CCWavesTiles3D{public:    //重载其创建函数。    static CCActionInterval* create(float t)    {//调用基类相应函数创建一个具体的动画演示。        return CCWavesTiles3D::create(4, 120, ccg(15,10), t);     }};//由CCJumpTiles3D派生出一个动画演示。class JumpTiles3DDemo : public CCJumpTiles3D{public:    //重载其创建函数。    static CCActionInterval* create(float t)    {        CCSize size = CCDirector::sharedDirector()->getWinSize();        //调用基类相应函数创建一个具体的动画演示。        return CCJumpTiles3D::create(2, 30, ccg(15,10), t);     }};//由CCSplitRows派生出一个动画演示。class SplitRowsDemo : public CCSplitRows{public:    //重载其创建函数。    static CCActionInterval* create(float t)    {        //调用基类相应函数创建一个具体的动画演示。        return CCSplitRows::create(9, t);     }};//由CCSplitCols派生出一个动画演示。class SplitColsDemo : public CCSplitCols{public:    //重载其创建函数。    static CCActionInterval* create(float t)    {        //调用基类相应函数创建一个具体的动画演示。        return CCSplitCols::create(9, t);     }};//由CCPageTurn3D派生出一个动画演示。class PageTurn3DDemo : public CCPageTurn3D{public:    //重载其创建函数。    static CCActionInterval* create(float t)    {        //调用基类相应函数创建一个具体的动画演示。        CCDirector::sharedDirector()->setDepthTest(true);        return CCPageTurn3D::create(ccg(15,10), t);     }};#define MAX_LAYER    22//创建相应的效果。CCActionInterval* createEffect(int nIndex, float t){    //设置    CCDirector::sharedDirector()->setDepthTest(false);    //根据索引来创建相应的动画实例。    switch(nIndex)    {        case 0: return Shaky3DDemo::create(t);        case 1: return Waves3DDemo::create(t);        case 2: return FlipX3DDemo::create(t);        case 3: return FlipY3DDemo::create(t);        case 4: return Lens3DDemo::create(t);        case 5: return Ripple3DDemo::create(t);        case 6: return LiquidDemo::create(t);        case 7: return WavesDemo::create(t);        case 8: return TwirlDemo::create(t);        case 9: return ShakyTiles3DDemo::create(t);        case 10: return ShatteredTiles3DDemo::create(t);        case 11: return ShuffleTilesDemo::create(t);        case 12: return FadeOutTRTilesDemo::create(t);        case 13: return FadeOutBLTilesDemo::create(t);        case 14: return FadeOutUpTilesDemo::create(t);        case 15: return FadeOutDownTilesDemo::create(t);        case 16: return TurnOffTilesDemo::create(t);        case 17: return WavesTiles3DDemo::create(t);        case 18: return JumpTiles3DDemo::create(t);        case 19: return SplitRowsDemo::create(t);        case 20: return SplitColsDemo::create(t);        case 21: return PageTurn3DDemo::create(t);    }    return NULL;}//取得相应的动画。CCActionInterval* getAction(){    CCActionInterval* pEffect = createEffect(actionIdx, 3);    return pEffect;} //运行当前的场景。void EffectTestScene::runThisTest(){    //创建一个当前的动画演示层放入场景，并运行这个场景。    addChild(TextLayer::create());    CCDirector::sharedDirector()->replaceScene(this);}#define SID_RESTART        1//构造函数。TextLayer::TextLayer(void){    //调用基类LayerColor的初始化函数，设置当前层的背景色。    initWithColor( ccc4(32,128,32,255) );    //    float x,y;    //取得屏幕大小。    CCSize s = CCDirector::sharedDirector()->getWinSize();    x = s.width;    y = s.height;    //创建一个节点。    CCNode* node = CCNode::create();    //创建一个动画。    CCActionInterval* effect = getAction();    //将动画绑定到这个节点上。    node->runAction(effect);    //将这个节点再放入到当前层中。    addChild(node, 0, kTagBackground);    //创建第一个精灵做为背景。    CCSprite *bg = CCSprite::create(s_back3);    node->addChild(bg, 0);//  bg->setAnchorPoint( CCPointZero );    bg->setPosition(ccp(s.width/2, s.height/2));    //创建第二个精灵（女一号）。    CCSprite* grossini = CCSprite::create(s_pPathSister2);    node->addChild(grossini, 1);    grossini->setPosition( CCPointMake(x/3,y/2) );    //创建一个缩放动画及对应的反向动画。    CCActionInterval* sc = CCScaleBy::create(2, 5);    CCActionInterval* sc_back = sc->reverse();    //让第二个精灵运行相应的动画序列。 grossini->runAction( CCRepeatForever::create((CCActionInterval*)(CCSequence::create(sc, sc_back, NULL)) ) );    //创建第三个精灵。（女二号）    CCSprite* tamara = CCSprite::create(s_pPathSister1);    node->addChild(tamara, 1);tamara->setPosition( CCPointMake(2*x/3,y/2) );//创建一个缩放动画及对应的反向动画。    CCActionInterval* sc2 = CCScaleBy::create(2, 5);    CCActionInterval* sc2_back = sc2->reverse();    //让第三个精灵运行相应的动画序列。tamara->runAction( CCRepeatForever::create((CCActionInterval*)(CCSequence::create(sc2, sc2_back, NULL))) );    //创建一个文字标签。    CCLabelTTF* label = CCLabelTTF::create((effectsList[actionIdx]).c_str(), \"Marker Felt\", 32);    //设置标签的位置并放入当前层中。    label->setPosition( CCPointMake(x/2,y-80) );    addChild(label);    label->setTag( kTagLabel );    //创建三个菜单按钮分别代表运行上一个，重新运行当前动画，运行下一个动画。    CCMenuItemImage *item1 = CCMenuItemImage::create(s_pPathB1, s_pPathB2, this, menu_selector(TextLayer::backCallback) );    CCMenuItemImage *item2 = CCMenuItemImage::create(s_pPathR1, s_pPathR2, this, menu_selector(TextLayer::restartCallback) );    CCMenuItemImage *item3 = CCMenuItemImage::create(s_pPathF1, s_pPathF2, this, menu_selector(TextLayer::nextCallback) );    //由三个菜单按钮创建菜单。    CCMenu *menu = CCMenu::create(item1, item2, item3, NULL);    //设置相应菜单按钮的位置。    menu->setPosition(CCPointZero);    item1->setPosition(CCPointMake( s.width/2 - item2->getContentSize().width*2, item2->getContentSize().height/2));    item2->setPosition(CCPointMake( s.width/2, item2->getContentSize().height/2));    item3->setPosition(CCPointMake( s.width/2 + item2->getContentSize().width*2, item2->getContentSize().height/2));    //将菜单加入当前层中。    addChild(menu, 1);        //对当前层调用一个函数。    schedule( schedule_selector(TextLayer::checkAnim) );}//检查动画。void TextLayer::checkAnim(float dt){    //取得对应结点。CCNode* s2 = getChildByTag(kTagBackground);//判断如果没有正在运行中的动画，并且其有格子数据，则将其格子数据释放并置空。    if ( s2->numberOfRunningActions() == 0 && s2->getGrid() != NULL)        s2->setGrid(NULL);;}//析构。TextLayer::~TextLayer(void){}//创建一个当前层的函数。TextLayer* TextLayer::create(){    TextLayer* pLayer = new TextLayer();    pLayer->autorelease();        return pLayer;}//当前层被加载时的处理。void TextLayer::onEnter(){    CCLayer::onEnter();}//创建一个新场景。void TextLayer::newScene(){    CCScene* s = new EffectTestScene();    CCNode* child = TextLayer::create();    s->addChild(child);    CCDirector::sharedDirector()->replaceScene(s);    s->release();}//重启当前动画演示。void TextLayer::restartCallback(CCObject* pSender){    newScene();}//前进到下一个动画演示。void TextLayer::nextCallback(CCObject* pSender){    // update the action index    actionIdx++;    actionIdx = actionIdx % MAX_LAYER;    newScene();}//回退到上一个动画演示。void TextLayer::backCallback(CCObject* pSender){    // update the action index    actionIdx--;    int total = MAX_LAYER;    if( actionIdx < 0 )        actionIdx += total;        newScene();}   最后做个总结：        Cocos2d-x提供了屏幕画面上的一些基于网格的动画，首先将要渲染的画面输出到一张纹理上，然后跟据屏幕大小创建相应数量的网格，通过对于网格上的顶点进行改变，形成顶点的运动动画，然后将纹理贴在网格上再绘制出来，就能够出现很多屏幕特效了。        觉得怎么样？是不是恍然大悟呢?如果有这样的感觉，则我的辛苦就没有白费。      最后，祝大家元旦快乐！2013年新的一年有更大的飞跃！","title":"[置顶] Cocos2d-x 2.0 网格动画深入分析"},{"content":"管理你的Activity的生命周期 当用户在系统与你的应用之间切换的过程中，你的应用中的Activity实例也会在自己的不同生命周期中切换。例如，用户第一次打开你的应用，应用展现在用户的手机桌面，获取用户的输入焦点。在这个过程中，Android系统调用了你的Activity中的一系列的生命周期方法，这些方法建立了应用组建和用户之间的联系。如果用户启动了应用中的另外一个Activity，或者直接切换到另外一个应用，系统也调用了Activity生命周期中的一系列方法使应用可以在后台运行。， 在Activity生命周期的回调方法中你可以定义Activity在用户第一次进入和重新进入应用的行为。举例来说，当你做一个流媒体播放器，你可以在用户切换到另外一个应用的时候暂停视频并停止网络连接，当用户切换回来的时候，重新连接网络，并且从用户之前暂停的点继续播放。 理解生命周期中回调方法 在Activity生命周期之中，系统调用了App生命周期中的回调方法集，这些生命周期回调方法就像一个一级一级的金字塔。Activity生命周期的每一个阶段都对应金字塔的一个台阶。当系统创建了一个新的Activity实例，回调方法一级一级的从塔底向塔顶移动，当位于金字塔顶部的时候,这个Activity就位于用户前台，用户此时就可以与Activity互动了。 当用户要离开Activity的时候，系统调用另外一串方法，使Activity的状态从塔顶移动到塔底。在有些情况下，Activity只是完成部分的状态迁移并且等待用户的指令，并重新回到塔顶的状态。 根据Activity复杂度的不同，你或许不用实现所有的生命周期方法。可是，理解每个生命周期回调函数的意义从而确保你的应用按照用户的期望正确的动作则非常重要。正确的实现生命周期的回调方法，从而使应用正确的动作，主要有以下几点需要注意： 确保应用在用户使用你的时候可以接电话或者切换到其他应用而不崩溃。 确保你的应用在用户不使用的时候不消耗系统资源。 确保用户在从其他的应用切换回你的应用的时候能够继续之前的工作 在用户屏幕切换或者其他动作的时候不崩溃或者丢失用户数据 图一所显示的Activity不同状态之间的迁移的几种情形，可是在这些状态当中只有三种是稳定的状态，所谓稳定就是Activity可以在这个状态持续保持一段时间，者三个状态是： Resumed：这个状态下，Activity来到用户前台，并且完成与用户的交互。（有些情况下我们也称这个状态为运行态。） Paused：在这个状态下，Activity被另外一个在前台运行的半透明的Activity或者被另外一个Activity部分盖住，在这个状态下Activity不能接受用户的输入，也不能执行任何代码 。 Stopped：在这个状态下，Activity被全部盖住，对用户完全不可见，可以认为已经在后台了。在停止状态下，Activity的所有实例，以及他的所有状态信息都被保存，可是不能执行任何代码。 另外的状态（Created和Started）是一个过渡状态，系统将迅速通过呼叫生命周期的回调函数来迁移到其生命周期的下一站。系统在呼叫了onCreate()->onStart()->onResume() 指定你的应用的启动Activity 当用户启动你的应用程序的时候系统调用了那个你声明为启动Activity的onCreat()方法。这个Activity作为你的应用主进入点 你可以通过修改AndroidManifest.xml这个位于你的工程根目录的文件来实现这一点。 以下为一个示例： <activity android:name=\".MainActivity\" android:label=\"@string/app_name\">     <intent-filter>         <action android:name=\"android.intent.action.MAIN\" />         <category android:name=\"android.intent.category.LAUNCHER\" />     <\/intent-filter> <\/activity> 注意：当你用Android SDK建立一个工程的时候，工程中的默认会包含一个Activity，而且会被默认为启动Activity 如果MAIN或者LAUNCHER在你的应用中被多次定义，你的应用的图标将不会在用户的应用列表中出现   Start一个Activity Android应用与其他的过程式编程语言从一个Main（）开始运行不同，Android系统通过触发一个特别的Activity生命周期中的一个回调方法来启动一个Activity。Android中有一系列的回调方法启动一个Activity，也有一系列的回调方法来终止一个Activity。   启动一个新的Activity实例 大部分应用都会提供多个不同的Activity来实现不同的用户功能，当用户通过点击应用图标来启动应用，或者另外一个Activity接受用户的指令来来调用你的应用，系统都会通过调用onCreate()创建一个新的Activity实例。 你必须通过实现onCreate()方法来完成基本的应用启动逻辑，而且这个只会在Activity的生命周期中发生一次。你如你可以通过onCreate()应该定义用户接口和一些系统级的变量。 Destroythe Activity销毁一个Activity Activity生命周期的第一个回调方法是onCreate()，而其最后一个回调方法是onDestroy()。系统通过调用这个方法将Activity的实例彻底的从系统内存中移除。 大部分的应用可能不需要实现这个方法，因为很多本地类的实例在onPause()和onStop()方法中已经销毁了。当然如果你的应用有些后台运行的线程，或者一些其他的长期占有的系统资源，你也应该在onDestroy()中销毁他们。 注意：系统一般都会在调用了onPause()和onStop()之后再调用onDestroy()，但是如果你在onCreate()方法中调用了finish()则是一个例外。 Pause、Resume一个Activity 在应用的使用过程中，一个在前台的Activity可能会被部分的遮盖，这回导致Activity进入Pause状态。当一个Activity被完全遮盖时，其进入stop状态。 当你的Activity进入pasued状态，系统调用你的Activity的onPause()方法，从而使你有机会停止你的正在运行的动作，保存你应该保存的信息以保证用户回来的时候不丢失信息 Pause YourActivity 当系统调用你的Activity的onPause方法，从技术角度来说意味着你的Activity还部分可视，可视更多的是用户将要离开此Activity，这个Activity将进入Stopped状态。你应该使用onPause（）方法完成以下功能： 停止一切可能会消耗CPU的动画后者动作 提交未保存的修改，当然是用户期望保存的修改 释放一切可能会消耗电池而你的应用也不需要的资源 一般来说，你不需要用onPause方法将用户修改存储到永久存储器上，唯一的例外就是用户期望自动存储的信息。不管怎么说，你应该避免执行一些消耗CPU的动作，以避免影响Activity之间切换的感觉，你应该在onStop方法中执行那些大运算量的关闭操作。 ResumeYour Activity 系统如果要将你的Activity从Paused状态唤醒，需要调用onResume方法。 记得你Activity任何一次到前台的运行都需要调用onResume方法。所以你所要实现onResume方法来初始化那些被onPause方法释放的组件。 Stop、Restart一个Activity 恰当的停止和重启你的Activity是其生命周期中非常重要的过程，他们保证你的应用对用户来说一致都是可用的，并且不会丢失他们的数据，你需要： 当用户从你的应用切换到其他的应用，你的Activity能够正确的停止；当用户从跟其他的应用切换回你的应用，你的应用可以正确的重启； 当用户在你的Activity中启动了另外一个新的Activity，当前Activity在新的Activity创建之后停止；当用户点击返回按钮，原先的Activity可以正确重启； 当用户在使用你的应用的时候接到一个电话，你的Activity可以正确的停止； Activity类提供了两个生命周期方法onStop() 和 onRestart(),从而可以定义该Activity停止和重启的过程中的动作。与pause状态不同，stop状态保证UI不再可见，而用户的输入焦点在另外一个Activity中。 注意：在Activity处于停止状态时，系统还是将其保存在系统内存当中，所以你可以不实现onStop() 和 onRestart()方法，甚至你可以连onStart()方法也不必实现。因为大部分Activity都比较简单，你可以通过onPause方法来停止正在运行的动作，断开系统资源。 Stop YourActivity 当你的Activity被呼叫了onStop方法，它已经不可见了，应该释放所有用户在不使用情况下不需要的资源。当Activity被停止，系统可能销毁这个Activity实例，甚至在极端情况下杀死应用进程已恢复内存等系统资源。 尽管onPause方法在onStop方法之前调用，但是你需要使用onStop方法来执行那些耗CPU资源的操作，例如同步数据库。 Start/RestartYour Activity 当一个处于停止状态的Activity需要被唤醒到前台运行，它的onRestart方法将被调用，同时onStart方法也会被调用。onRestart方法只有在系统从Stop状态下被激活才会被调用，所以你可以利用其来恢复那些在stop过程中被释放的资源。 通过onRestart方法来恢复Activity状态的做法不是非常普遍，所以我们没有为这个方法列出一个指南。因为onStop方法应该将Activity中的资源释放，所以你需要在onRestart中将这个资源重新实例化，同样在Activity创建的时候也需要将这些资源实例化，因为这个原因我们一般将onStart和onStop做资源申请与释放上的对应。 例如，用户切换出你的应用并且长时间没有返回，onStart方法就是去确认系统资源有没有被正确设置的好地方。 当系统需要系会你的Activity，它需要调用你的Activity的onDestroy()方法。因为你已经在onStop方法中释放了大部分的资源，onDestroy方法应当没有很多工作需要完成。这个方法是你释放资源，避免内存泄露的最后的机会，你需要确保所有附加的线程等被正确的停止 Recreate一个Activity 在一些情况下，Activity因为应用的正常动作被销毁，例如用户按返回按钮，或者应用受到finish（）调用。系统也会在Activity长时间不用或者系统需要资源的情况下销毁Activity。 当你的Activity因为按返回或者自我终结的方式销毁的，系统就会认为Activity不被需要了，会在系统中消失。但是，在因为系统的限制而被销毁的Activity，虽然其实例已经被销毁，但是系统仍然会记住其曾经存在过，当用户切换回来的时候，系统会重新创建一个实例，并且将在销毁时保存在bundle中的实例状态数据传递给这个实例。 注意：Activity在用户旋转屏幕的时候都会销毁并重新创建一个Activity 保存和恢复 Activity 状态 当你的Activity加入stop状态的时候系统调用onSaveInstanceState()，你可以一系列的键值对来存储目前的状态。当Activity需要Resume的时候，系统调用onRestoreInstanceState()将这些键值对恢复出来。  ","title":"深入理解Activity的生命周期"},{"content":"/*    说到AsyncTask这个类，好多人其实不太了解。最近看了下代码，把心得分享给大家。    AsyncTask的execute的执行流程为    先调用ThreadPoolExecutor.execute(mFuture);    然后ThreadPoolExecutor.execute(mFuture) 会调用ThreadPoolExecutor.addWorker(mFuture);    最后ThreadPoolExecutor.addWorker(mFuture)会调用mFuture的run()方法，run方法中就是该线程要执行操作的地方    到此我们来关注一下mFuture，AsyncTask中的mFuture是一个FutureTask，FutureTask实现了Future<V>, Runnable两个接口，    Future 表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果，计算完成后只能使用 get 方法来获取结果。    mFuture以mWorker作为参数    现看mFuture的构造方法：public void run() {    sync.innerRun();}    sync是什么呢？Sync类是一个内部类，我们看看它的初始化public FutureTask(Callable<V> callable) {    if (callable == null)        throw new NullPointerException();    sync = new Sync(callable);}    在看看sync.innerRun()方法：void innerRun() {    if (!compareAndSetState(READY, RUNNING))        return;    runner = Thread.currentThread();    if (getState() == RUNNING) { // recheck after setting thread        V result;        try {            result = callable.call();        } catch (Throwable ex) {            setException(ex);            return;        }        set(result);    } else {        releaseShared(0); // cancel    }}    从代码可以看到，其实最终是调用了callable.call()这个方法。    从AsyncTask中我们可以知道,我们传入的Callable是我们的WorkerRunnable    所以，我们会调用WorkerRunnable的call()方法,在call方法里面    返回postResult(doInBackground(mParams));    通知UI线程更新，这就是调用过程Notes：1:    因为AsyncTask里面的内部handler和Executor都是静态变量，所以，他们控制着所有的子类。2:    我们可以通过AsyncTask.execute()方法来调用系统默认的线程池来处理当前的任务，    系统默认的线程池用的是SerialExecutor.这个线程池控制所有任务按顺序执行。也就是一次只执行一条.    当前执行完了，才执行下一条.2.3平台以前是所有的任务并发执行，这会导致一种情况，就是其中一条任务执行出问题了，会引起其他任务    出现错误.3:    AsyncTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR)你也可以采用这个系统提供的线程池来处理你的任务    默认这个线程池是并发处理任务的，也就是不按顺序来.核心为5条,最大128条4:    你也可以使用自定义的线程池，这样就可以即使的执行你的任务需求，而不是用系统的。因为用系统默认的线程池可以需要等待，它默认    是按顺序执行（THREAD_POOL_EXECUTOR）或者最多执行5个（SerialExecutor）.    自己使用自定义线程池方式如下：    new AsyncTask.executeOnExecutor((ExecutorService)Executors.newCachedThreadPool()).5:  不要随意使用AsyncTask,除非你必须要与UI线程交互.默认情况下使用Thread即可,要注意需要将线程优先级调低.    从google官方文档你也可以看到,AsyncTasks should ideally be used for short operations (a few seconds at the most.)    AsyncTask适合处理短时间的操作,长时间的操作,比如下载一个很大的视频,这就需要你使用自己的线程来下载,不管是断点下载还是其它的.    当然,如果你需要开启自定义的很多线程来处理你的任务,切记你此时可以考虑自定义线程池 */ public abstract class AsyncTask<Params, Progress, Result> {    private static final String LOG_TAG = \"AsyncTask\";    // 核心线程数是要    private static final int CORE_POOL_SIZE = 5;    // 最大线程数支持128    private static final int MAXIMUM_POOL_SIZE = 128;    // 这个参数的的意思是当前线程池里面的thread如果超过了规定的核心线程5,如果有线程的空闲时间超过了这个数值,    // 数值的单位自己指定，就回收该线程的资源，达到动态调整线程池资源的目的.    private static final int KEEP_ALIVE = 1;    // ThreadFactory是用来在线程池中构建新线程的方法.可以看到每次构建一个方法,名字都不同.为\"AsyncTask # 1++\".    private static final ThreadFactory sThreadFactory = new ThreadFactory() {        private final AtomicInteger mCount = new AtomicInteger(1);        public Thread newThread(Runnable r) {            return new Thread(r, \"AsyncTask #\" + mCount.getAndIncrement());        }    };    // 线程池所使用的缓冲队列.FIFO,它用于存放如果当前线程池中核心线程已满，此时来的任务都被放到缓冲队列中等待被处理.    // 初始化容量为10    private static final BlockingQueue<Runnable> sPoolWorkQueue =            new LinkedBlockingQueue<Runnable>(10);    /**     * An {@link Executor} that can be used to execute tasks in parallel.     */    // 线程池的初始化，指定了核心线程5,最大线程128,超时1s，缓冲队列等, 你在使用asyncTask的时候，可以传入这个参数，    // 就可以让多条线程并发的执行了.比如：executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR)    public static final Executor THREAD_POOL_EXECUTOR            = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,                    TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);    /**     * An {@link Executor} that executes tasks one at a time in serial     * order.  This serialization is global to a particular process.     */    // 从这个线程池内部看,已经不是并行执行任务，而是一次只执行一个.    public static final Executor SERIAL_EXECUTOR = new SerialExecutor();    // 消息数值    private static final int MESSAGE_POST_RESULT = 0x1;    private static final int MESSAGE_POST_PROGRESS = 0x2;    // 这个InternalHandler就是用来是UI线程打交道的。可以看到它是个静态的变量。也就是说谁第一次调用它，下一次另一个    // 线程来调用，也不会实例话这个常量.关于这个handler,默认asynctask都是从主线程中调用的,所以,这个Handler默认    // 获得了主线程的Looper,所以就能和主线程来交互. Notes：假如你在一个子线程中构建了自己的Looper并使用Asynctask,    // 应该会出问题,因为此时这个Handler就属于子线程了,就不能去操控UI的操作.这应该算是AsyncTask的Bug.网上有人说    // 在4.0上运行没问题,2.3会有问题,原因是因为4.0中的ActivityThread.main方法里面最先用主线程的Looper来初始化了这个    // AsyncTask。理论上Asynctask应该判断当前的Looper如果不是MainThread的Looper的话，抛出异常，遗憾的是,    // google没有考虑到这里，只是在文档中要求必须在主线程中调用,其实，很不好！    private static final InternalHandler sHandler = new InternalHandler();    private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;    // 自定义的静态内部类    private final WorkerRunnable<Params, Result> mWorker;    // 其实就是也一个Runnable,实现了这个接口    private final FutureTask<Result> mFuture;    // 默认为pending状态。    private volatile Status mStatus = Status.PENDING;    // 原子操作,专门用来处理并发访问,就可以不用synchronized    private final AtomicBoolean mCancelled = new AtomicBoolean();    private final AtomicBoolean mTaskInvoked = new AtomicBoolean();    private static class SerialExecutor implements Executor {        // ArrayDeque是一个双向队列,我们来理解下这个线程池是如何做到一次只        // 执行一条任务的.比如此时有多处先后都调用了AsyncTask.execute()方法,        // 对第一条最先到的任务来说，首先自己被假如到了队列中,因为第一次mActive == null成立,        // 所以执行THREAD_POOL_EXECUTOR.execute(mActive).且mActive 此时不等于Null.        // 所以第二条任务来的时候,只是被加入到了队列中，并不会执行.除非第一条任务执行完了,在它的finnally方法中        // 调用scheduleNext()去再次从对列中取出下一条任务来执行.这样就实现了所有任务按顺序执行的功能.        final ArrayDeque<Runnable> mTasks = new ArrayDeque<Runnable>();        Runnable mActive;        public synchronized void execute(final Runnable r) {            // 把线程offer到队列中            mTasks.offer(new Runnable() {                public void run() {                    try {                        r.run();                    } finally {                        // 一条执行完了，执行下一条任务                        scheduleNext();                    }                }            });            if (mActive == null) {                scheduleNext();            }        }        protected synchronized void scheduleNext() {            if ((mActive = mTasks.poll()) != null) {                THREAD_POOL_EXECUTOR.execute(mActive);            }        }    }    /**     * Indicates the current status of the task. Each status will be set only once     * during the lifetime of a task.     */    public enum Status {        /**         * Indicates that the task has not been executed yet.         */        PENDING,        /**         * Indicates that the task is running.         */        RUNNING,        /**         * Indicates that {@link AsyncTask#onPostExecute} has finished.         */        FINISHED,    }    /** @hide Used to force static handler to be created. */    public static void init() {        sHandler.getLooper();    }    /** @hide */    public static void setDefaultExecutor(Executor exec) {        sDefaultExecutor = exec;    }    /**     * Creates a new asynchronous task. This constructor must be invoked on the UI thread.     */    public AsyncTask() {        //初始化mWorker并复写call方法,后面会介绍什么时候调用        mWorker = new WorkerRunnable<Params, Result>() {            // 这个方法就是当你嗲用excutor.excute()方法后执行的方法。至于是如何执行的,我们后面会分析            public Result call() throws Exception {                mTaskInvoked.set(true);                // 将线程优先级设置为后台线程，默认和主线程优先级一样，如果不这样做，也会降低程序性能.因为会优先                // 抢占cpu资源.所以,如果你在程序中不使用asyncTask而是自己new 一条线程出来，记得把线程的优先级设置为                // 后台线程                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);                //这个地方调用了我们自己实现的doInBackground                return postResult(doInBackground(mParams));            }        };       // 用mWorker创建一个可取消的异步计算任务        mFuture = new FutureTask<Result>(mWorker) {            @Override            // 当任务不管是正常终止、异常或取消而完成的,都回调此方法, 即isDone()为true时,isDone不管成功还是失败都            // 返回true            protected void done() {                try {                    // 如果当前的task没有被invoke,就被finish掉                    postResultIfNotInvoked(get());                } catch (InterruptedException e) {                    android.util.Log.w(LOG_TAG, e);                } catch (ExecutionException e) {                    throw new RuntimeException(\"An error occured while executing doInBackground()\",                            e.getCause());                } catch (CancellationException e) {                    postResultIfNotInvoked(null);                }            }        };    }    private void postResultIfNotInvoked(Result result) {        final boolean wasTaskInvoked = mTaskInvoked.get();        if (!wasTaskInvoked) {            postResult(result);        }    }    // 当doInBackground结束了，调用PostResult发布结果    private Result postResult(Result result) {        @SuppressWarnings(\"unchecked\")        Message message = sHandler.obtainMessage(MESSAGE_POST_RESULT,                new AsyncTaskResult<Result>(this, result));        message.sendToTarget();        return result;    }    /**     * Returns the current status of this task.     *     * @return The current status.     */    // 获得当前的状态    public final Status getStatus() {        return mStatus;    }    /**     * Override this method to perform a computation on a background thread. The     * specified parameters are the parameters passed to {@link #execute}     * by the caller of this task.     *     * This method can call {@link #publishProgress} to publish updates     * on the UI thread.     *     * @param params The parameters of the task.     *     * @return A result, defined by the subclass of this task.     *     * @see #onPreExecute()     * @see #onPostExecute     * @see #publishProgress     */    // 用户自己实现    protected abstract Result doInBackground(Params... params);    /**     * Runs on the UI thread before {@link #doInBackground}.     *     * @see #onPostExecute     * @see #doInBackground     */    // 用户自己实现    protected void onPreExecute() {    }    /**     * <p>Runs on the UI thread after {@link #doInBackground}. The     * specified result is the value returned by {@link #doInBackground}.<\/p>     *     * <p>This method won't be invoked if the task was cancelled.<\/p>     *     * @param result The result of the operation computed by {@link #doInBackground}.     *     * @see #onPreExecute     * @see #doInBackground     * @see #onCancelled(Object)     */    @SuppressWarnings({\"UnusedDeclaration\"})    // 用户自己实现    protected void onPostExecute(Result result) {    }    /**     * Runs on the UI thread after {@link #publishProgress} is invoked.     * The specified values are the values passed to {@link #publishProgress}.     *     * @param values The values indicating progress.     *     * @see #publishProgress     * @see #doInBackground     */    @SuppressWarnings({\"UnusedDeclaration\"})    // 用户自己实现    protected void onProgressUpdate(Progress... values) {    }    /**     * <p>Runs on the UI thread after {@link #cancel(boolean)} is invoked and     * {@link #doInBackground(Object[])} has finished.<\/p>     *     * <p>The default implementation simply invokes {@link #onCancelled()} and     * ignores the result. If you write your own implementation, do not call     * <code>super.onCancelled(result)<\/code>.<\/p>     *     * @param result The result, if any, computed in     *               {@link #doInBackground(Object[])}, can be null     *     * @see #cancel(boolean)     * @see #isCancelled()     */    @SuppressWarnings({\"UnusedParameters\"})    protected void onCancelled(Result result) {        onCancelled();    }    /**     * <p>Applications should preferably override {@link #onCancelled(Object)}.     * This method is invoked by the default implementation of     * {@link #onCancelled(Object)}.<\/p>     *     * <p>Runs on the UI thread after {@link #cancel(boolean)} is invoked and     * {@link #doInBackground(Object[])} has finished.<\/p>     *     * @see #onCancelled(Object)     * @see #cancel(boolean)     * @see #isCancelled()     */    protected void onCancelled() {    }    /**     * Returns <tt>true<\/tt> if this task was cancelled before it completed     * normally. If you are calling {@link #cancel(boolean)} on the task,     * the value returned by this method should be checked periodically from     * {@link #doInBackground(Object[])} to end the task as soon as possible.     *     * @return <tt>true<\/tt> if task was cancelled before it completed     *     * @see #cancel(boolean)     */    public final boolean isCancelled() {        return mCancelled.get();    }    /**     * <p>Attempts to cancel execution of this task.  This attempt will     * fail if the task has already completed, already been cancelled,     * or could not be cancelled for some other reason. If successful,     * and this task has not started when <tt>cancel<\/tt> is called,     * this task should never run. If the task has already started,     * then the <tt>mayInterruptIfRunning<\/tt> parameter determines     * whether the thread executing this task should be interrupted in     * an attempt to stop the task.<\/p>     *     * <p>Calling this method will result in {@link #onCancelled(Object)} being     * invoked on the UI thread after {@link #doInBackground(Object[])}     * returns. Calling this method guarantees that {@link #onPostExecute(Object)}     * is never invoked. After invoking this method, you should check the     * value returned by {@link #isCancelled()} periodically from     * {@link #doInBackground(Object[])} to finish the task as early as     * possible.<\/p>     *     * @param mayInterruptIfRunning <tt>true<\/tt> if the thread executing this     *        task should be interrupted; otherwise, in-progress tasks are allowed     *        to complete.     *     * @return <tt>false<\/tt> if the task could not be cancelled,     *         typically because it has already completed normally;     *         <tt>true<\/tt> otherwise     *     * @see #isCancelled()     * @see #onCancelled(Object)     */    public final boolean cancel(boolean mayInterruptIfRunning) {        mCancelled.set(true);        return mFuture.cancel(mayInterruptIfRunning);    }    /**     * Waits if necessary for the computation to complete, and then     * retrieves its result.     *     * @return The computed result.     *     * @throws CancellationException If the computation was cancelled.     * @throws ExecutionException If the computation threw an exception.     * @throws InterruptedException If the current thread was interrupted     *         while waiting.     */    public final Result get() throws InterruptedException, ExecutionException {        return mFuture.get();    }    /**     * Waits if necessary for at most the given time for the computation     * to complete, and then retrieves its result.     *     * @param timeout Time to wait before cancelling the operation.     * @param unit The time unit for the timeout.     *     * @return The computed result.     *     * @throws CancellationException If the computation was cancelled.     * @throws ExecutionException If the computation threw an exception.     * @throws InterruptedException If the current thread was interrupted     *         while waiting.     * @throws TimeoutException If the wait timed out.     */    public final Result get(long timeout, TimeUnit unit) throws InterruptedException,            ExecutionException, TimeoutException {        return mFuture.get(timeout, unit);    }    /**     * Executes the task with the specified parameters. The task returns     * itself (this) so that the caller can keep a reference to it.     *     * <p>Note: this function schedules the task on a queue for a single background     * thread or pool of threads depending on the platform version.  When first     * introduced, AsyncTasks were executed serially on a single background thread.     * Starting with {@link android.os.Build.VERSION_CODES#DONUT}, this was changed     * to a pool of threads allowing multiple tasks to operate in parallel. Starting     * {@link android.os.Build.VERSION_CODES#HONEYCOMB}, tasks are back to being     * executed on a single thread to avoid common application errors caused     * by parallel execution.  If you truly want parallel execution, you can use     * the {@link #executeOnExecutor} version of this method     * with {@link #THREAD_POOL_EXECUTOR}; however, see commentary there for warnings     * on its use.     *     * <p>This method must be invoked on the UI thread.     *     * @param params The parameters of the task.     *     * @return This instance of AsyncTask.     *     * @throws IllegalStateException If {@link #getStatus()} returns either     *         {@link AsyncTask.Status#RUNNING} or {@link AsyncTask.Status#FINISHED}.     *     * @see #executeOnExecutor(java.util.concurrent.Executor, Object[])     * @see #execute(Runnable)     */    // 这个方法就是用户调用的excute方法，默认采用asynctask自带的线程池串行执行任务    public final AsyncTask<Params, Progress, Result> execute(Params... params) {        return executeOnExecutor(sDefaultExecutor, params);    }    /**     * Executes the task with the specified parameters. The task returns     * itself (this) so that the caller can keep a reference to it.     *     * <p>This method is typically used with {@link #THREAD_POOL_EXECUTOR} to     * allow multiple tasks to run in parallel on a pool of threads managed by     * AsyncTask, however you can also use your own {@link Executor} for custom     * behavior.     *     * <p><em>Warning:<\/em> Allowing multiple tasks to run in parallel from     * a thread pool is generally <em>not<\/em> what one wants, because the order     * of their operation is not defined.  For example, if these tasks are used     * to modify any state in common (such as writing a file due to a button click),     * there are no guarantees on the order of the modifications.     * Without careful work it is possible in rare cases for the newer version     * of the data to be over-written by an older one, leading to obscure data     * loss and stability issues.  Such changes are best     * executed in serial; to guarantee such work is serialized regardless of     * platform version you can use this function with {@link #SERIAL_EXECUTOR}.     *     * <p>This method must be invoked on the UI thread.     *     * @param exec The executor to use.  {@link #THREAD_POOL_EXECUTOR} is available as a     *              convenient process-wide thread pool for tasks that are loosely coupled.     * @param params The parameters of the task.     *     * @return This instance of AsyncTask.     *     * @throws IllegalStateException If {@link #getStatus()} returns either     *         {@link AsyncTask.Status#RUNNING} or {@link AsyncTask.Status#FINISHED}.     *     * @see #execute(Object[])     */    public final AsyncTask<Params, Progress, Result> executeOnExecutor(Executor exec,            Params... params) {        // 可以看出同一个任务只能执行一次        if (mStatus != Status.PENDING) {            switch (mStatus) {                case RUNNING:                    throw new IllegalStateException(\"Cannot execute task:\"                            + \" the task is already running.\");                case FINISHED:                    throw new IllegalStateException(\"Cannot execute task:\"                            + \" the task has already been executed \"                            + \"(a task can be executed only once)\");            }        }        mStatus = Status.RUNNING;        // 调用用户--UI线程---自己实现的方法        onPreExecute();        mWorker.mParams = params;        // 这个方法就会调用前面的mWorker的call方法        exec.execute(mFuture);        return this;    }    /**     * Convenience version of {@link #execute(Object...)} for use with     * a simple Runnable object. See {@link #execute(Object[])} for more     * information on the order of execution.     *     * @see #execute(Object[])     * @see #executeOnExecutor(java.util.concurrent.Executor, Object[])     */    public static void execute(Runnable runnable) {        sDefaultExecutor.execute(runnable);    }    /**     * This method can be invoked from {@link #doInBackground} to     * publish updates on the UI thread while the background computation is     * still running. Each call to this method will trigger the execution of     * {@link #onProgressUpdate} on the UI thread.     *     * {@link #onProgressUpdate} will note be called if the task has been     * canceled.     *     * @param values The progress values to update the UI with.     *     * @see #onProgressUpdate     * @see #doInBackground     */    protected final void publishProgress(Progress... values) {        if (!isCancelled()) {            sHandler.obtainMessage(MESSAGE_POST_PROGRESS,                    new AsyncTaskResult<Progress>(this, values)).sendToTarget();        }    }    private void finish(Result result) {        if (isCancelled()) {            onCancelled(result);        } else {            onPostExecute(result);        }        mStatus = Status.FINISHED;    }    //  与UI交互    private static class InternalHandler extends Handler {        @SuppressWarnings({\"unchecked\", \"RawUseOfParameterizedType\"})        @Override        public void handleMessage(Message msg) {            AsyncTaskResult result = (AsyncTaskResult) msg.obj;            switch (msg.what) {                case MESSAGE_POST_RESULT:                    // There is only one result                    result.mTask.finish(result.mData[0]);                    break;                case MESSAGE_POST_PROGRESS:                    result.mTask.onProgressUpdate(result.mData);                    break;            }        }    }    private static abstract class WorkerRunnable<Params, Result> implements Callable<Result> {        Params[] mParams;    }    @SuppressWarnings({\"RawUseOfParameterizedType\"})    // 存储异步执行结果的类    private static class AsyncTaskResult<Data> {        final AsyncTask mTask;        final Data[] mData;        AsyncTaskResult(AsyncTask task, Data... data) {            mTask = task;            mData = data;        }    }}","title":"[置顶] Asynctask解析以及注意事项"},{"content":"今天跟大家一起分享下android开发中比较难的一个环节,可能很多人看到这个标题就会感觉头很大,的确如果没有良好的编码能力和逻辑思维,这块是很难搞明白的,前面2次总结中已经为大家分享过有关技术的一些基本要领,我们先一起简单回顾下它的基本原理。 http://blog.csdn.net/shimiso/article/details/6763664  android 多线程断点续传下载 一 http://blog.csdn.net/shimiso/article/details/6763986  android 多线程断点续传下载 二 什么是多线程下载？ 多线程下载其实就是迅雷,BT一些下载原理,通过多个线程同时和服务器连接,那么你就可以榨取到较高的带宽了,大致做法是将文件切割成N块,每块交给单独一个线程去下载,各自下载完成后将文件块组合成一个文件,程序上要完成做切割和组装的小算法 什么是断点续传? 断点续传,就是当我们下载未结束时候,退出保存下载进度,当下次打开继续下载的时接着上次的进度继续下载,不用每次下载都重新开始,那么有关断点续传的原理和实现手段,可参考我以前的一篇总结http://blog.csdn.net/shimiso/article/details/5956314 里面详细讲解http协议断点续传的原理,务必要看懂,否则你无法真正理解本节代码 怎么完成多线程断点续传? 将两者合二为一需要程序记住每个文件块的下载进度,并保存入库,当下载程序启动时候你需要判断程序是否已经下载过该文件,并取出各个文件块的保存记录,换算出下载进度继续下载,在这里你需要掌握java多线程的基本知识,handler的使用,以及集合,算法,文件操作等基本技能,同时还要解决sqlite数据库的同步问题,因为它是不太怎么支持多线程操作的,控制不好经常会出现库被锁定的异常,同时在android2.3以后就不能activity中直接操作http,否则你将收到系统送上的NetworkOnMainThreadException异常,在UI体验上一定记住要使用异步完成,既然大致思路已经清楚,下面我们开始分析程序: package cn.demo.DBHelper;  import android.content.Context;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteOpenHelper;      /**      * 建立一个数据库帮助类      */ public class DBHelper extends SQLiteOpenHelper {     //download.db-->数据库名     public DBHelper(Context context) {         super(context, \"download.db\", null, 1);     }          /**      * 在download.db数据库下创建一个download_info表存储下载信息      */     @Override     public void onCreate(SQLiteDatabase db) {         db.execSQL(\"create table download_info(_id integer PRIMARY KEY AUTOINCREMENT, thread_id integer, \"                 + \"start_pos integer, end_pos integer, compelete_size integer,url char)\");     }     @Override     public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {      }  }    数据库操作要借助单例和同步,来保证线程的执行顺序,以免多个线程争相抢用sqlite资源导致异常出现 package cn.demo.Dao;import java.util.ArrayList;import java.util.List;import android.content.Context;import android.database.Cursor;import android.database.sqlite.SQLiteDatabase;import cn.demo.DBHelper.DBHelper;import cn.demo.entity.DownloadInfo;/** *  * 一个业务类 */public class Dao {  \tprivate static Dao dao=null;\tprivate Context context; \tprivate  Dao(Context context) { \t\tthis.context=context;\t}\tpublic static  Dao getInstance(Context context){\t\tif(dao==null){\t\t\tdao=new Dao(context); \t\t}\t\treturn dao;\t}\tpublic  SQLiteDatabase getConnection() {\t\tSQLiteDatabase sqliteDatabase = null;\t\ttry { \t\t\tsqliteDatabase= new DBHelper(context).getReadableDatabase();\t\t} catch (Exception e) {  \t\t}\t\treturn sqliteDatabase;\t}\t/**\t * 查看数据库中是否有数据\t */\tpublic synchronized boolean isHasInfors(String urlstr) {\t\tSQLiteDatabase database = getConnection();\t\tint count = -1;\t\tCursor cursor = null;\t\ttry {\t\t\tString sql = \"select count(*)  from download_info where url=?\";\t\t\tcursor = database.rawQuery(sql, new String[] { urlstr });\t\t\tif (cursor.moveToFirst()) {\t\t\t\tcount = cursor.getInt(0);\t\t\t} \t\t} catch (Exception e) {\t\t\te.printStackTrace();\t\t} finally {\t\t\tif (null != database) {\t\t\t\tdatabase.close();\t\t\t}\t\t\tif (null != cursor) {\t\t\t\tcursor.close();\t\t\t}\t\t}\t\treturn count == 0;\t}\t/**\t * 保存 下载的具体信息\t */\tpublic synchronized void saveInfos(List<DownloadInfo> infos) {\t\tSQLiteDatabase database = getConnection();\t\ttry {\t\t\tfor (DownloadInfo info : infos) {\t\t\t\tString sql = \"insert into download_info(thread_id,start_pos, end_pos,compelete_size,url) values (?,?,?,?,?)\";\t\t\t\tObject[] bindArgs = { info.getThreadId(), info.getStartPos(),\t\t\t\t\t\tinfo.getEndPos(), info.getCompeleteSize(),\t\t\t\t\t\tinfo.getUrl() };\t\t\t\tdatabase.execSQL(sql, bindArgs);\t\t\t}\t\t} catch (Exception e) {\t\t\te.printStackTrace();\t\t} finally {\t\t\tif (null != database) {\t\t\t\tdatabase.close();\t\t\t}\t\t}\t}\t/**\t * 得到下载具体信息\t */\tpublic synchronized List<DownloadInfo> getInfos(String urlstr) {\t\tList<DownloadInfo> list = new ArrayList<DownloadInfo>();\t\tSQLiteDatabase database = getConnection();\t\tCursor cursor = null;\t\ttry {\t\t\tString sql = \"select thread_id, start_pos, end_pos,compelete_size,url from download_info where url=?\";\t\t\tcursor = database.rawQuery(sql, new String[] { urlstr });\t\t\twhile (cursor.moveToNext()) {\t\t\t\tDownloadInfo info = new DownloadInfo(cursor.getInt(0),\t\t\t\t\t\tcursor.getInt(1), cursor.getInt(2), cursor.getInt(3),\t\t\t\t\t\tcursor.getString(4));\t\t\t\tlist.add(info);\t\t\t}\t\t} catch (Exception e) {\t\t\te.printStackTrace();\t\t} finally {\t\t\tif (null != database) {\t\t\t\tdatabase.close();\t\t\t}\t\t\tif (null != cursor) {\t\t\t\tcursor.close();\t\t\t}\t\t}\t\treturn list;\t}\t/**\t * 更新数据库中的下载信息\t */\tpublic synchronized void updataInfos(int threadId, int compeleteSize, String urlstr) {\t\tSQLiteDatabase database = getConnection();\t\ttry {\t\t\tString sql = \"update download_info set compelete_size=? where thread_id=? and url=?\";\t\t\tObject[] bindArgs = { compeleteSize, threadId, urlstr };\t\t\tdatabase.execSQL(sql, bindArgs);\t\t} catch (Exception e) {\t\t\te.printStackTrace();\t\t} finally {\t\t\tif (null != database) {\t\t\t\tdatabase.close();\t\t\t}\t\t}\t}\t/**\t * 下载完成后删除数据库中的数据\t */\tpublic synchronized void delete(String url) {\t\tSQLiteDatabase database = getConnection();\t\ttry {\t\t\tdatabase.delete(\"download_info\", \"url=?\", new String[] { url });\t\t} catch (Exception e) {\t\t\te.printStackTrace();\t\t} finally {\t\t\tif (null != database) {\t\t\t\tdatabase.close();\t\t\t}\t\t}\t}}   package cn.demo.download;import java.util.List;import java.util.Map;import android.content.Context;import android.view.LayoutInflater;import android.view.View;import android.view.View.OnClickListener;import android.view.ViewGroup;import android.widget.BaseAdapter;import android.widget.Button;import android.widget.TextView;public class DownLoadAdapter extends BaseAdapter{\t \tprivate LayoutInflater mInflater;\tprivate List<Map<String, String>> data;\tprivate Context context;\tprivate OnClickListener click;\t\tpublic DownLoadAdapter(Context context,List<Map<String, String>> data) {\t\tthis.context=context;\t\tmInflater = LayoutInflater.from(context);\t\tthis.data=data;\t}\tpublic void refresh(List<Map<String, String>> data) {\t\tthis.data=data;\t\tthis.notifyDataSetChanged();\t}\tpublic void setOnclick(OnClickListener click) {\t\t this.click=click;\t}\t\t\t@Override\tpublic int getCount() {\t\treturn data.size();\t}\t@Override\tpublic Object getItem(int position) {\t\treturn data.get(position);\t}\t@Override\tpublic long getItemId(int position) {\t\treturn position;\t}\t@Override\tpublic View getView(final int position, View convertView, ViewGroup parent) {\t\tfinal Map<String, String> bean=data.get(position);\t\tViewHolder holder = null;\t\tif (convertView == null) {\t\t\tconvertView = mInflater.inflate(R.layout.list_item, null);\t\t\tholder = new ViewHolder(); \t\t\tholder.resouceName=(TextView) convertView.findViewById(R.id.tv_resouce_name);\t\t\tholder.startDownload=(Button) convertView.findViewById(R.id.btn_start);\t\t\tholder.pauseDownload=(Button) convertView.findViewById(R.id.btn_pause);\t\t\tconvertView.setTag(holder);\t\t} else {\t\t\tholder = (ViewHolder) convertView.getTag();\t\t} \t \tholder.resouceName.setText(bean.get(\"name\")); \t\treturn convertView;\t}\tpublic OnClickListener getClick() {\t\treturn click;\t}\tpublic void setClick(OnClickListener click) {\t\tthis.click = click;\t}\tprivate class ViewHolder {         public TextView resouceName;        public Button startDownload;        public Button pauseDownload;                       }\t} 注意子线程不要影响主UI线程,灵活运用task和handler,各取所长,保证用户体验,handler通常在主线程中有利于专门负责处理UI的一些工作 package cn.demo.download;  import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import android.app.ListActivity;import android.os.AsyncTask;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.view.View;import android.widget.Button;import android.widget.LinearLayout;import android.widget.LinearLayout.LayoutParams;import android.widget.ProgressBar; import android.widget.TextView;import android.widget.Toast;import cn.demo.entity.LoadInfo;import cn.demo.service.Downloader; public class MainActivity extends ListActivity {      // 固定下载的资源路径，这里可以设置网络上的地址     private static final String URL = \"http://download.haozip.com/\";     // 固定存放下载的音乐的路径：SD卡目录下     private static final String SD_PATH = \"/mnt/sdcard/\";     // 存放各个下载器     private Map<String, Downloader> downloaders = new HashMap<String, Downloader>();     // 存放与下载器对应的进度条     private Map<String, ProgressBar> ProgressBars = new HashMap<String, ProgressBar>();     /**      * 利用消息处理机制适时更新进度条      */     private Handler mHandler = new Handler() {         public void handleMessage(Message msg) {             if (msg.what == 1) {                 String url = (String) msg.obj;                 int length = msg.arg1;                 ProgressBar bar = ProgressBars.get(url);                 if (bar != null) {                     // 设置进度条按读取的length长度更新                     bar.incrementProgressBy(length);                     if (bar.getProgress() == bar.getMax()) {                    \t LinearLayout layout = (LinearLayout) bar.getParent();                    \t TextView resouceName=(TextView)layout.findViewById(R.id.tv_resouce_name);                         Toast.makeText(MainActivity.this, \"[\"+resouceName.getText()+\"]下载完成！\", Toast.LENGTH_SHORT).show();                         // 下载完成后清除进度条并将map中的数据清空                         layout.removeView(bar);                         ProgressBars.remove(url);                         downloaders.get(url).delete(url);                         downloaders.get(url).reset();                         downloaders.remove(url);                                                  Button btn_start=(Button)layout.findViewById(R.id.btn_start);                         Button btn_pause=(Button)layout.findViewById(R.id.btn_pause);                         btn_pause.setVisibility(View.GONE);                         btn_start.setVisibility(View.GONE);                     }                 }             }         }     };     @Override     public void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.main);          showListView();     }     // 显示listView，这里可以随便添加     private void showListView() {         List<Map<String, String>> data = new ArrayList<Map<String, String>>();         Map<String, String> map = new HashMap<String, String>();         map.put(\"name\", \"haozip_v3.1.exe\");         data.add(map);         map = new HashMap<String, String>();         map.put(\"name\", \"haozip_v3.1_hj.exe\");         data.add(map);         map = new HashMap<String, String>();         map.put(\"name\", \"haozip_v2.8_x64_tiny.exe\");         data.add(map);         map = new HashMap<String, String>();         map.put(\"name\", \"haozip_v2.8_tiny.exe\");         data.add(map);         DownLoadAdapter adapter=new DownLoadAdapter(this,data);           setListAdapter(adapter);              }     /**      * 响应开始下载按钮的点击事件      */     public void startDownload(View v) {         // 得到textView的内容          LinearLayout layout = (LinearLayout) v.getParent();         String resouceName = ((TextView) layout.findViewById(R.id.tv_resouce_name)).getText().toString();         String urlstr = URL + resouceName;         String localfile = SD_PATH + resouceName;         //设置下载线程数为4，这里是我为了方便随便固定的         String threadcount = \"4\";         DownloadTask downloadTask=new DownloadTask(v);         downloadTask.execute(urlstr,localfile,threadcount);            };    class DownloadTask extends AsyncTask<String, Integer, LoadInfo>{    \tDownloader downloader=null;     \tView v=null;    \tString urlstr=null;    \tpublic DownloadTask(final View v){    \t\tthis.v=v;    \t}      \t@Override    \tprotected void onPreExecute() {     \t\tButton btn_start=(Button)((View)v.getParent()).findViewById(R.id.btn_start);    \t\tButton btn_pause=(Button)((View)v.getParent()).findViewById(R.id.btn_pause);    \t\tbtn_start.setVisibility(View.GONE);    \t\tbtn_pause.setVisibility(View.VISIBLE);    \t}\t\t@Override\t\tprotected LoadInfo doInBackground(String... params) {\t\t\turlstr=params[0];\t\t\tString localfile=params[1];\t\t\tint threadcount=Integer.parseInt(params[2]);\t\t\t // 初始化一个downloader下载器\t         downloader = downloaders.get(urlstr);\t         if (downloader == null) {\t             downloader = new Downloader(urlstr, localfile, threadcount, MainActivity.this, mHandler);\t             downloaders.put(urlstr, downloader);\t         }\t         if (downloader.isdownloading())\t        \t return null;\t         // 得到下载信息类的个数组成集合\t         return downloader.getDownloaderInfors(); \t\t}\t\t@Override\t\tprotected void onPostExecute(LoadInfo loadInfo) {\t\t\tif(loadInfo!=null){\t\t\t\t // 显示进度条\t\t         showProgress(loadInfo, urlstr, v);\t\t         // 调用方法开始下载\t\t         downloader.download();\t\t\t} \t\t}\t\t \t };     /**      * 显示进度条      */     private void showProgress(LoadInfo loadInfo, String url, View v) {         ProgressBar bar = ProgressBars.get(url);         if (bar == null) {             bar = new ProgressBar(this, null, android.R.attr.progressBarStyleHorizontal);             bar.setMax(loadInfo.getFileSize());             bar.setProgress(loadInfo.getComplete());             ProgressBars.put(url, bar);             LinearLayout.LayoutParams params = new LayoutParams(LayoutParams.FILL_PARENT, 5);             ((LinearLayout) ((LinearLayout) v.getParent()).getParent()).addView(bar, params);         }     }     /**      * 响应暂停下载按钮的点击事件      */     public void pauseDownload(View v) {         LinearLayout layout = (LinearLayout) v.getParent();         String resouceName = ((TextView) layout.findViewById(R.id.tv_resouce_name)).getText().toString();         String urlstr = URL + resouceName;         downloaders.get(urlstr).pause();         Button btn_start=(Button)((View)v.getParent()).findViewById(R.id.btn_start); \t\t Button btn_pause=(Button)((View)v.getParent()).findViewById(R.id.btn_pause);         btn_pause.setVisibility(View.GONE);         btn_start.setVisibility(View.VISIBLE);     } }    这是一个信息的实体,记录了一些字典信息,可以认为是一个简单bean对象 package cn.demo.entity; /**  *创建一个下载信息的实体类  */ public class DownloadInfo {     private int threadId;//下载器id     private int startPos;//开始点     private int endPos;//结束点     private int compeleteSize;//完成度     private String url;//下载器网络标识     public DownloadInfo(int threadId, int startPos, int endPos,             int compeleteSize,String url) {         this.threadId = threadId;         this.startPos = startPos;         this.endPos = endPos;         this.compeleteSize = compeleteSize;         this.url=url;     }     public DownloadInfo() {     }     public String getUrl() {         return url;     }     public void setUrl(String url) {         this.url = url;     }     public int getThreadId() {         return threadId;     }     public void setThreadId(int threadId) {         this.threadId = threadId;     }     public int getStartPos() {         return startPos;     }     public void setStartPos(int startPos) {         this.startPos = startPos;     }     public int getEndPos() {         return endPos;     }     public void setEndPos(int endPos) {         this.endPos = endPos;     }     public int getCompeleteSize() {         return compeleteSize;     }     public void setCompeleteSize(int compeleteSize) {         this.compeleteSize = compeleteSize;     }      @Override     public String toString() {         return \"DownloadInfo [threadId=\" + threadId                 + \", startPos=\" + startPos + \", endPos=\" + endPos                 + \", compeleteSize=\" + compeleteSize +\"]\";     } } package cn.demo.entity; /**  *自定义的一个记载下载器详细信息的类   */ public class LoadInfo {     public int fileSize;//文件大小     private int complete;//完成度     private String urlstring;//下载器标识     public LoadInfo(int fileSize, int complete, String urlstring) {         this.fileSize = fileSize;         this.complete = complete;         this.urlstring = urlstring;     }     public LoadInfo() {     }     public int getFileSize() {         return fileSize;     }     public void setFileSize(int fileSize) {         this.fileSize = fileSize;     }     public int getComplete() {         return complete;     }     public void setComplete(int complete) {         this.complete = complete;     }     public String getUrlstring() {         return urlstring;     }     public void setUrlstring(String urlstring) {         this.urlstring = urlstring;     }     @Override     public String toString() {         return \"LoadInfo [fileSize=\" + fileSize + \", complete=\" + complete                 + \", urlstring=\" + urlstring + \"]\";     } }   这是一个核心类,专门用来处理下载的 package cn.demo.service;  import java.io.File;import java.io.InputStream;import java.io.RandomAccessFile;import java.net.HttpURLConnection;import java.net.URL;import java.util.ArrayList;import java.util.List;import android.content.Context;import android.os.AsyncTask;import android.os.Handler;import android.os.Message;import android.util.Log;import cn.demo.Dao.Dao;import cn.demo.entity.DownloadInfo;import cn.demo.entity.LoadInfo;  public class Downloader {     private String urlstr;// 下载的地址     private String localfile;// 保存路径     private int threadcount;// 线程数     private Handler mHandler;// 消息处理器      private int fileSize;// 所要下载的文件的大小     private Context context;      private List<DownloadInfo> infos;// 存放下载信息类的集合     private static final int INIT = 1;//定义三种下载的状态：初始化状态，正在下载状态，暂停状态     private static final int DOWNLOADING = 2;     private static final int PAUSE = 3;     private int state = INIT;      public Downloader(String urlstr, String localfile, int threadcount,             Context context, Handler mHandler) {         this.urlstr = urlstr;         this.localfile = localfile;         this.threadcount = threadcount;         this.mHandler = mHandler;         this.context = context;     }     /**      *判断是否正在下载       */     public boolean isdownloading() {         return state == DOWNLOADING;     }     /**      * 得到downloader里的信息      * 首先进行判断是否是第一次下载，如果是第一次就要进行初始化，并将下载器的信息保存到数据库中      * 如果不是第一次下载，那就要从数据库中读出之前下载的信息（起始位置，结束为止，文件大小等），并将下载信息返回给下载器      */     public LoadInfo getDownloaderInfors() {         if (isFirst(urlstr)) {             Log.v(\"TAG\", \"isFirst\");             init();             int range = fileSize / threadcount;             infos = new ArrayList<DownloadInfo>();             for (int i = 0; i < threadcount - 1; i++) {                 DownloadInfo info = new DownloadInfo(i, i * range, (i + 1)* range - 1, 0, urlstr);                 infos.add(info);             }             DownloadInfo info = new DownloadInfo(threadcount - 1,(threadcount - 1) * range, fileSize - 1, 0, urlstr);             infos.add(info);             //保存infos中的数据到数据库             Dao.getInstance(context).saveInfos(infos);             //创建一个LoadInfo对象记载下载器的具体信息             LoadInfo loadInfo = new LoadInfo(fileSize, 0, urlstr);             return loadInfo;         } else {             //得到数据库中已有的urlstr的下载器的具体信息             infos = Dao.getInstance(context).getInfos(urlstr);             Log.v(\"TAG\", \"not isFirst size=\" + infos.size());             int size = 0;             int compeleteSize = 0;             for (DownloadInfo info : infos) {                 compeleteSize += info.getCompeleteSize();                 size += info.getEndPos() - info.getStartPos() + 1;             }             return new LoadInfo(size, compeleteSize, urlstr);         }     }      /**      * 初始化      */     private void init() {         try {             URL url = new URL(urlstr);             HttpURLConnection connection = (HttpURLConnection) url.openConnection();             connection.setConnectTimeout(5000);             connection.setRequestMethod(\"GET\");             fileSize = connection.getContentLength();              File file = new File(localfile);             if (!file.exists()) {                 file.createNewFile();             }             // 本地访问文件             RandomAccessFile accessFile = new RandomAccessFile(file, \"rwd\");             accessFile.setLength(fileSize);             accessFile.close();             connection.disconnect();         } catch (Exception e) {             e.printStackTrace();         }     }       /**      * 判断是否是第一次 下载      */     private boolean isFirst(String urlstr) {         return Dao.getInstance(context).isHasInfors(urlstr);     }      /**      * 利用线程开始下载数据      */     public void download() {         if (infos != null) {             if (state == DOWNLOADING)                 return;             state = DOWNLOADING;             for (DownloadInfo info : infos) {                 new MyThread(info.getThreadId(), info.getStartPos(),                         info.getEndPos(), info.getCompeleteSize(),                         info.getUrl()).start();             }         }     }      public class MyThread extends Thread {         private int threadId;         private int startPos;         private int endPos;         private int compeleteSize;         private String urlstr;          public MyThread(int threadId, int startPos, int endPos,                 int compeleteSize, String urlstr) {             this.threadId = threadId;             this.startPos = startPos;             this.endPos = endPos;             this.compeleteSize = compeleteSize;             this.urlstr = urlstr;         }         @Override         public void run() {             HttpURLConnection connection = null;             RandomAccessFile randomAccessFile = null;             InputStream is = null;             try {                 URL url = new URL(urlstr);                 connection = (HttpURLConnection) url.openConnection();                 connection.setConnectTimeout(5000);                 connection.setRequestMethod(\"GET\");                 // 设置范围，格式为Range：bytes x-y;                 connection.setRequestProperty(\"Range\", \"bytes=\"+(startPos + compeleteSize) + \"-\" + endPos);                  randomAccessFile = new RandomAccessFile(localfile, \"rwd\");                 randomAccessFile.seek(startPos + compeleteSize);                 // 将要下载的文件写到保存在保存路径下的文件中                 is = connection.getInputStream();                 byte[] buffer = new byte[4096];                 int length = -1;                 while ((length = is.read(buffer)) != -1) {                     randomAccessFile.write(buffer, 0, length);                     compeleteSize += length;                     // 更新数据库中的下载信息                     Dao.getInstance(context).updataInfos(threadId, compeleteSize, urlstr);                     // 用消息将下载信息传给进度条，对进度条进行更新                     Message message = Message.obtain();                     message.what = 1;                     message.obj = urlstr;                     message.arg1 = length;                     mHandler.sendMessage(message);                     if (state == PAUSE) {                         return;                     }                 }             } catch (Exception e) {                 e.printStackTrace();             }           }     }     //删除数据库中urlstr对应的下载器信息     public void delete(String urlstr) {    \t Dao.getInstance(context).delete(urlstr);     }     //设置暂停     public void pause() {         state = PAUSE;     }     //重置下载状态     public void reset() {         state = INIT;     } } 以下是些xml文件 <?xml version=\"1.0\" encoding=\"utf-8\"?> <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"            android:orientation=\"vertical\"            android:layout_width=\"fill_parent\"            android:layout_height=\"wrap_content\">     <LinearLayout            android:orientation=\"horizontal\"            android:layout_width=\"fill_parent\"            android:layout_height=\"wrap_content\"            android:layout_marginBottom=\"5dip\">         <TextView              android:layout_width=\"fill_parent\"             android:layout_height=\"wrap_content\"             android:layout_weight=\"1\"             android:id=\"@+id/tv_resouce_name\"/>         <Button             android:layout_width=\"fill_parent\"             android:layout_height=\"wrap_content\"             android:layout_weight=\"1\"             android:text=\"下载\"             android:id=\"@+id/btn_start\"             android:onClick=\"startDownload\"/>         <Button             android:layout_width=\"fill_parent\"             android:layout_height=\"wrap_content\"             android:layout_weight=\"1\"             android:text=\"暂停\"             android:visibility=\"gone\"             android:id=\"@+id/btn_pause\"             android:onClick=\"pauseDownload\"/>       <\/LinearLayout> <\/LinearLayout>   <?xml version=\"1.0\" encoding=\"utf-8\"?> <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"     android:orientation=\"vertical\"     android:layout_width=\"fill_parent\"     android:layout_height=\"fill_parent\"     android:id=\"@+id/llRoot\">     <ListView android:id=\"@android:id/list\"         android:layout_width=\"fill_parent\"         android:layout_height=\"fill_parent\">     <\/ListView> <\/LinearLayout>   <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"    package=\"cn.demo.download\"    android:versionCode=\"1\"    android:versionName=\"1.0\">    <uses-sdk android:minSdkVersion=\"8\" android:targetSdkVersion=\"8\" />\t<uses-permission android:name=\"android.permission.INTERNET\"/>　\t<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>    <application android:label=\"@string/app_name\"        android:icon=\"@drawable/ic_launcher\"        android:theme=\"@style/AppTheme\">\t\t<activity\t            android:name=\".MainActivity\" \t            android:label=\"@string/app_name\" >\t            <intent-filter>\t                <action android:name=\"android.intent.action.MAIN\" /> \t                <category android:name=\"android.intent.category.LAUNCHER\" />\t            <\/intent-filter>\t        <\/activity>    <\/application><\/manifest> 运行效果如下     源码下载地址     转载请标明出处 http://blog.csdn.net/shimiso    技术交流群:173711587","title":"android 多线程断点续传下载 三"},{"content":"#2013微软MVP社区巡讲#欢迎热爱微软技术的开发人员和IT专业人士参与“新年新期待”2013 微软MVP新年社区巡讲。微软最有价值专家MVP将在2013年伊始到访美丽上青岛，帝都北京，泉城济南。微软专家，明星讲师为您倾情奉献Windows 8， Windows Phone， New Office技术课程，参与活动您将会与专家们进行面对面的交流。一个下午的时间轻松掌握技术握住新年礼物。报名参与活动http://aka.ms/chinamvp","title":"2013微软 MVP 社区巡讲"},{"content":"本人博客原文 第一部分 Android线程 Android线程模型 Android的每个进程有一个称为“main”主线程（也称UI线程）的线程。它除了负责所有事件的分发和处理，还负责4大组件的生命周期函数的调用。 更多内容请参考《Android线程模型》和《Looper和Handler》 如何确定当前线程 我们可以通过打印代码的调用层次来确定当前线程。 更多内容请参考《 Android中打印代码的调用层次》 Handler技术 Handler用于异步消息的处理。默认情况下Handler与其创建者处于同一线程， 如果Handler里面做耗时的动作，其对应线程自然会阻塞。 更多内容请参考《 关于Handler技术》和《Looper和Handler》 AsyncTask技术  引入AsyncTask的目的是任务在主线程之外运行，而回调方法是在主线程中执行，以避免了使用Handler带来代码看上去非常臃肿的麻烦. 关于此的详细内容请阅读《 AsyncTask简介》 ThreadLocal简介 ThreadLocal的目的就是为每一个使用ThreadLocal的线程都提供一个值，让该值和使用它的线程绑定，当然每一个线程都可以独立地改变它绑定的值。 更多请参考《 ThreadLocal简介》 第二部分 什么是ANR 在Android中，系统会监视那些反应不够迅速的应用。如果系统发现某个应用程序反应太慢，它会显示一个叫做Application Not Responding (ANR)的对话框给用户。用户可以选择等待该应用程序让它继续，也可以选择强行结束该应用程序。虽然用户可以选择等待该应用程序让它继续，但是用户其实是非常不喜欢出现该对话框（ANR提示框） 更多的内容请参考《关于ANR的官方建议》 第三部分 对付ANR的N种武器 关于此请参考《Android中对付ANR的N种武器》 结束","title":"Android线程与ANR"},{"content":"相关几个重要的类的继承关系如下   1.所有文本框必须实现CCLabelProtocol接口   2.CCLableTTF比另外两个文本框渲染慢 TTF（TrueTypeFont）是一种字库名称，是Apple公司和Microsoft公司共同推出的字体文件格式,随着windows的流行，已经变成最常用的一种字体文件表示方式。            CCLabelTTF 每次调用 setString （即改变文字）的时候，一个新的OpenGL纹理将会被创建.。这意味着setString 和创建一个新的标签一样慢。            所以，当你需要频繁的更新它们的时候，尽可能的不用去使用标签对象。  而应该使用CCLabelAtlas或者是CCLabelBMFont  OK， 看下它的使用方法  CCLabelTTF *label = CCLabelTTF::labelWithString(\"the string\", \"Marker Felt\", 21); this->addChild(label);  label->setPosition(ccp(100, 100));  label->setString(\"change string\");//修改文字的方法  这个类使用的是系统中的字体，不需要额外往项目文件中添加字体文件。但如果你有自定义的字体也可以加到项目中，如果无法使用，可以查看一下ccConfig.h中的CC_FONT_LABEL_SUPPORT是否enable了。       3.CCLabelBMFont中每个文字相当于一个CCSprite，可以旋转，移动，改变尺寸等 CCLabelBMFont  相当于每次改变只改变了图片坐标，而CCLabelTTF要重新渲染.这个类使用之前，需要添加好字体文件，包括一个图片文件 (**.png) 和一个 字体坐标文件 （**.fnt）。 在 cocos2d-x的示例项目中有现成的，可以先拿过来练习一下，找的时候注意两个文件的名称是相同的，只是扩展名不同。 CCLabelIBMFont *label = CCLabelIBMFont::labelWithString(\"the string\", \"font-hd.png\"); this->addChild(label); label->setPosition(ccp(100, 100)); label->setString(\"change string\");   下面是 font-hd.png文件的截图  font-hd.fnt文件定义了 图像文件的名称，以及每个字符对应的位置信息。  这个没办法指定字体的字号，但可以用scale属性进行缩放来调整大小。就当它是sprite,可以简单的实现很炫的文字的动画效果。   4.CCLabelAtlas         如果你用cocos2d-x项目模板创建过项目，那么你已经看过它的效果了，就是左下角显示帧率的数字。 因为帧率一直在变，使用CCLabelTTF的话效率太低，因为只是数字所以也犯不上使用 CCLabelBMFont 加载那么大的文字图像，所以使用这个比较合适。 CCLabelAtlas *label = CCLabelAtlas::labelWithString(\"12\", \"fps_images.png\", 12, 18, \".\"); this->addChild(label); label->setPosition(ccp(100, 100)); label->setString(\"34\");  在项目文件中，在resourse group里你可以找一下一个叫 fps_images.png的这个图像文件，文件如下：                所以，这个只能显示上面这个12个字符，abcd什么的就不行了。        解释一下参数，        12 就是字符，        fps_images.png就是字符的图像文件（这个只要图像文件就可以了），        12 是每个字符的宽度，        18 是每个字符的高度，这个不能设错，否则显示的时候可能就不对了。        最后一个是起始字符，它是使用这个其实字符来对应字符和图像关系的 5.下面具体分析一下画字的原理（参考一篇博客） 图字，顾名思义，利用图片做为纹理来显示的文字。当下流行的跨平台2D引擎Cocos2d-x和LibGdx也都有对于图字的应用支持，今天我就来为大家讲一讲图字。   首先要介绍一下，图字是怎么来的？其实这个很早很早了，记得80后在95年开始玩DOS下的仙剑奇侠传的时候，那些令人难忘的中文对话吧！DOS下做游戏，使用的是C语言，不要说写字了，很多复杂的操作甚至涉及驱动。那时候绘图就是利用将图片中的像素取出来后绘制在屏幕上，所以处理游戏中的中文，就只有把这些文字的像素预先写到BMP或二进制文件中，然后读取出来再设置屏幕像素以实现。后来进入DDRAW的时代，可以使用WINDOWS系统中的字库来写字了。把DDRAW的后台表面进行LOCK，取出其DC，然后用GDI将文字写到其DC上，这种做法后面也延续了很久，但GDI进行TextOut的效率非常慢，你要是想像梦幻西游一样满屏写了，那得卡死，解决方案是什么？还是图字。专业的游戏开发者会将所用到的字都预处理生成到一张图片中，通过一个编码与纹理UV对应文件来进行纹理UV的获取后做为顶点的UV值然后进行绘制，有也的在每一帧中实时的将需要的字使用DDRAW写字的方法绘制到相应的纹理上然后使用文字编码与纹理UV对应信息来进行绘制，这样效率就提高很多了。目前比较流行的做法是使用一张png图片来存储用到的文字。一个.fnt文件来存储文字图片说明信息。Cocos2d-x和LibGdx中都集成了相关的图字处理类。在世界范围内，也有很多游戏使用了这个方案。在游戏汉化界，了解和掌握图字的原理和修改方法也是很重要的一项工作 我们以Cocos2d-x的tests工程中的LabelTest中的最后一个Label显示“中国”为例来分析一下。 打开Cocos2d-x所在目录下的tests\\Resources\\fonts目录，找到bitmapFontChinese.png(文字贴图文件)和bitmapFontChinese.fnt(文字图片说明信息文件) 先打开png，我们可以看到它是512×512大小，上面由12行，14列个文字组成。包括有一些汉字，常用字符，数字和字母。它的每个字都是由青色到蓝色的向下渐变。 再用UEdit或记事本打开bitmapFontChinese.fnt,可以看到它的构成,我在这里讲一下。 第一行是对字体的介绍。   1 info face=\"华康海报体W12(P)\" size=32 bold=0italic=0 charset=\"\" unicode=0stretchH=100smooth=1 aa=1 padding=0,0,0,0 spacing=1,1   解释： face=”华康海报体W12(P)”:字体为”华康海报体W12(P)”, size=32:大小为32像素 bold=0 :不加粗 italic=0:不使用斜体 charset=”\": charset是编码字符集，这里没有填写值即使用默认， unicode=0:不使用Unicode stretchH=100:纵向缩放百分比 smooth=1 :开启平滑 aa=1:开启抗锯齿 padding=0,0,0,0:内边距，文字与边框的空隙。 spacing=1,1 :外边距，就是相临边缘的距离。 第二行是对应所有字贴图的公共信息   1 common lineHeight=37 base=28 scaleW=512 scaleH=512pages=1 packed=0   解释： lineHeight=37：行高，如果遇到换行符时，绘制字的位置坐标的Y值在换行后增加的像素值。 base=28 :字的基本大小 scaleW=512 :图片大小 scaleH=512:图片大小 pages=1 :此种字体共用到几张图。 packed=0:图片不压缩 第三行是对应当前字贴图的信息 //第一页，文件名称是”bitmapFontChinese.png” page id=0 file=”bitmapFontChinese.png” 第四行是当前贴图中所容纳的文字数量 chars count=204 第五行起把当前贴图中所用到的所有文字的编码以及对应在图片上的矩形位置，偏移等列出来 第一个字符编码为32,也就是空格，位置为0,0,宽高为0,0, 绘制到屏幕的相应位置时，像素偏移（0，28），绘制完后相应位置的x往后移15像素再画下一个字符，字的图块在第1页上 char id=32 x=0 y=0 width=0 height=0 xoffset=0 yoffset=28 xadvance=15 page=0 chnl=0 第一个字符编码为汉字”象”,也就是空格，位置为0,0,宽为33,高为36, 绘制到屏幕的相应位置时，像素偏移（0，-1），绘制完后相应位置的x往后移36像素再画下一个字，字的图块在第1页上 char id=35937 x=0 y=0 width=33 height=36 xoffset=0 yoffset=-1 xadvance=36 page=0 chnl=0 char id=26696 x=33 y=0 width=35 height=36 xoffset=-1 yoffset=-1 xadvance=36 page=0 chnl=0 char id=26071 x=68 y=0 width=35 height=36 xoffset=-1 yoffset=-1 xadvance=36 page=0 chnl=0 … 再后面是描述两个字在进行组合绘制时字距调整的相关信息，这里没有要进行间距调整的字组合所以为设-1。对于字组合间距调整可以看此示例图： kernings count=-1 这个数字代表参与字组合间距调整的字的数量。 如果kernings count大于零，后面会有类似这样的描述： kerning first=102 second=41 amount=2 也就是’f’与’)’进行组合显示’f)’时，’)’向右移2像素防止粘在一起。 通过上面这些信息，引擎可以通过编码找到相应的文字并取出对应的纹理块。 //Cocos2d-x中LabelBMFontChinese 下面我们来分析一下Cocos2d-x的tests工程中的LabelTest中的最后一个Label，它的类名为CCLabelBMFont.转到其类定义文件CCLabelBMFont.h   1 class CC_DLL CCLabelBMFont : public CCSpriteBatchNode, public CCLabelProtocol, public CCRGBAProtocol   可以看到其直接派生于三个类，分别是 CCSpriteBatchNode :精灵批次管理类，用于将使用一张图的多个精灵在设置一次纹理的批次里进行绘制，提高渲染的效率。 CCLabelProtocol :文字字串类 CCRGBAProtocol:颜色调节接口类 由简入深，我们先来看一下CCRGBAProtocol，打开CCProtocols.h   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class CC_DLL CCRGBAProtocol { public:     //设置颜色     virtual void setColor(const ccColor3B& color) = 0;     //取得颜色     virtual const ccColor3B& getColor(void) = 0;     //返回透明度     virtual GLubyte getOpacity(void) = 0;     //设置透明度     virtual void setOpacity(GLubyte opacity) = 0;     //设置是否使用Alpha值设置RGB，如果     virtual void setIsOpacityModifyRGB(bool bValue) = 0;     //取得是否使用Alpha值设置RGB     virtual bool getIsOpacityModifyRGB(void) = 0; };   可以看到CCRGBAProtocol类是个纯虚类，只是定义了一些设置获取颜色信息的接口函数。 继续看CCLabelProtocal，明显的，它也是纯虚类，做为存储字符串的接口使用:   1 2 3 4 5 6 7 8 9 class CC_DLL CCLabelProtocol { public:     // 设置文字标签显示的字符串     virtual void setString(const char *label) = 0;     // 返回文字标签显示的字符串     virtual const char* getString(void) = 0; };   最后来分析CCSpriteBatchNode类。它由CCNodet 和 CCTextureProtocal两个类派生而来，CCNode是基础结点类，用于将引擎中所有具有逻辑顺序和父子关系的类组织起来，基于CCNode派生的类均可以互相挂接。CCNode不是本章要详细介绍的内容，就不再详细分析了，看一下CCTextureProtocol，这是一个纹理使用接口类:   1 2 3 4 5 6 7 8 9 class CC_DLL CCTextureProtocol : public CCBlendProtocol { public:     // 返回所使用的2D纹理     virtual CCTexture2D* getTexture(void) = 0;     // 设置使用的2D纹理，并为纹理的使用计数器加1操作     virtual void setTexture(CCTexture2D *texture) = 0; };   很简单，只有两个函数对纹理进行设置和获取，它派生于CCBlendProtocal,这是一个Alpha混合系数设置接口类，用于在开启Alpha混合状态后对Alpha混合的系数进行设置。再来看一下CCBlendProtocal,这是一个混合状态设置接口类:   1 2 3 4 5 6 7 8 9 class CC_DLL CCBlendProtocol { public:     // 为纹理设置使用的混合状态     virtual void setBlendFunc(ccBlendFunc blendFunc) = 0;     // 返回为纹理设置的混合状态     virtual ccBlendFunc getBlendFunc(void) = 0; };   返回到类CCSpriteBatchNode的定义。我们再来分析CCSpriteBatchNode。之前说了CCSpriteBatchNode是精灵批次管理类，用于将使用一张图的多个精灵在设置一次纹理的批次里进行绘制，提高渲染的效率。既然多个精灵使用一张图，则需要将多个小图块合并在一张图上，这样只要设置使用大图做为纹理，将使用各小图块做为纹理贴图的精灵设置好顶点与UV等数据，就可以绘制出这些精灵了。Cocos2d-x提供了一个类CCTextureAtlas对使用图块的这些精灵所使用的顶点缓冲区进行管理。为了更好的理解CCSpriteBatchNode,我们看一下它的定义和实现：   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 #ifndef __CCTEXTURE_ATLAS_H__ #define __CCTEXTURE_ATLAS_H__ //用到的头文件 #include <string> #include \"ccTypes.h\" #include \"CCObject.h\" #include \"ccConfig.h\" //使用Cocos2d命名空间 namespace   cocos2d { class CCTexture2D; //CCTextureAtlas由CCObject派生而来 class CC_DLL CCTextureAtlas : public CCObject { protected:     //使用此大图中的图块的精灵对应的三角形索引数组的指针     GLushort            *m_pIndices; #if CC_USES_VBO     //如果使用Vertex Buffer Object(VBO:使用显存而非内存存储顶点缓冲数据，大大提高效率)，建立VBO句柄数组，第一个元素存顶点数组的句柄，第二个元素存索引数组句柄     GLuint              m_pBuffersVBO[2];     //标记是否更新需要更新的图块信息。当你新加入了图块或者修改了图块，需要设置为true。     bool                m_bDirty; #endif // CC_USES_VBO // CC_PROPERTY_READONLY宏为类定义变量及增加相应的get函数。     //当前使用图块的数量     CC_PROPERTY_READONLY(unsigned int, m_uTotalQuads, TotalQuads)     //存储图块信息的数组容量     CC_PROPERTY_READONLY(unsigned int, m_uCapacity, Capacity)     //设置所使用的大图纹理     CC_PROPERTY(CCTexture2D *, m_pTexture, Texture)     //使用此大图的图块的所有精灵的顶点缓冲信息数组     CC_PROPERTY(ccV3F_C4B_T2F_Quad *, m_pQuads, Quads) public:     //构造     CCTextureAtlas();     //析构     virtual ~CCTextureAtlas();     //描述     char * description();     //静态函数：从文件中创建纹理，并初始化图块容量     static CCTextureAtlas * textureAtlasWithFile(const char* file , unsigned int capacity);     //同上，只是非静态函数。作者提示不能重复调用，否则会造成内存泄漏。     bool initWithFile(const char* file, unsigned int capacity);     //静态函数：从贴图中创建纹理，并初始化图块容量     static CCTextureAtlas * textureAtlasWithTexture(CCTexture2D *texture, unsigned int capacity);     //同上，只是非静态函数。作者提示不能重复调用，否则会造成内存泄漏。     bool initWithTexture(CCTexture2D *texture, unsigned int capacity);     //通过索引值找到对应的图块顶点缓冲数据并用新数据修改它，由CCSprite实例对象在变换顶点信息时调用。     void updateQuad(ccV3F_C4B_T2F_Quad* quad, unsigned int index);     //通过索引值找到对应的图块顶点缓冲数据，并在其之前插入一个新的图块。     void insertQuad(ccV3F_C4B_T2F_Quad* quad, unsigned int index);     //通过索引值找到对应的图块顶点缓冲数据，并把它插入另一个图块之前。     void insertQuadFromIndex(unsigned int fromIndex, unsigned int newIndex);     //移除指定位置的图块顶点缓冲数据.     void removeQuadAtIndex(unsigned int index);     //清空所有的图块顶点缓冲数据。     void removeAllQuads();     //重新设置图块顶点缓冲数组的容量     bool resizeCapacity(unsigned int n);     //绘制指定的图块顶点缓冲     void drawNumberOfQuads(unsigned int n);     //绘制从指定的图块起后面的N个图块     void drawNumberOfQuads(unsigned int n, unsigned int start);     //绘制所有的图块顶点缓冲     void drawQuads(); private:     //初始化索引缓冲数据     void initIndices(); }; }//namespace   cocos2d #endif //__CCTEXTURE_ATLAS_H__   再看CPP:   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 #include \"CCTextureAtlas.h\" #include \"CCTextureCache.h\" #include \"ccMacros.h\" // 纹理头文件 #include \"CCTexture2D.h\" #include <stdlib.h> //使用Cocos2d命名空间 namespace   cocos2d { //构造,初始化成员变量 CCTextureAtlas::CCTextureAtlas()     :m_pIndices(NULL) #if CC_USES_VBO     , m_bDirty(false) #endif     ,m_pTexture(NULL)     ,m_pQuads(NULL) {} //析构，释放所用的内存 CCTextureAtlas::~CCTextureAtlas() { //  CCLOGINFO(\"cocos2d: deallocing CCTextureAtlas.\");     CC_SAFE_FREE(m_pQuads)     CC_SAFE_FREE(m_pIndices) #if CC_USES_VBO     //释放缓冲区对象     glDeleteBuffers(2, m_pBuffersVBO); #endif // CC_USES_VBO     CC_SAFE_RELEASE(m_pTexture); } //实现通过宏CC_PROPERTY_READONLY声明的函数 //取得当前使用的图块的数量 unsigned int CCTextureAtlas::getTotalQuads() {     return m_uTotalQuads; } //取得图块集的容量 unsigned int CCTextureAtlas::getCapacity() {     return m_uCapacity; } //取得大纹理 CCTexture2D* CCTextureAtlas::getTexture() {     return m_pTexture; } //设置大纹理 void CCTextureAtlas::setTexture(CCTexture2D * var) {     CC_SAFE_RETAIN(var);     CC_SAFE_RELEASE(m_pTexture);     m_pTexture = var; } //取得使用此大图的图块的所有精灵的顶点缓冲信息数组 ccV3F_C4B_T2F_Quad* CCTextureAtlas::getQuads() {     return m_pQuads; } //设置使用此大图的图块的所有精灵的顶点缓冲信息数组 void CCTextureAtlas::setQuads(ccV3F_C4B_T2F_Quad *var) {     m_pQuads = var; } //静态函数：从文件中创建纹理，并初始化图块容量 CCTextureAtlas * CCTextureAtlas::textureAtlasWithFile(const char* file, unsigned int capacity) {     //使用new来实例化一个CCTextureAtlas对象     CCTextureAtlas * pTextureAtlas = new CCTextureAtlas();     //调用成员函数进行初始化     if(pTextureAtlas && pTextureAtlas->initWithFile(file, capacity))     {         pTextureAtlas->autorelease();         return pTextureAtlas;     }     //如果失败，释放后返回NULL     CC_SAFE_DELETE(pTextureAtlas);     return NULL; } //静态函数：从贴图中创建纹理，并初始化图块容量 CCTextureAtlas * CCTextureAtlas::textureAtlasWithTexture(CCTexture2D *texture, unsigned int capacity) {     //使用new来实例化一个CCTextureAtlas对象     CCTextureAtlas * pTextureAtlas = new CCTextureAtlas();     //调用成员函数进行初始化     if (pTextureAtlas && pTextureAtlas->initWithTexture(texture, capacity))     {         pTextureAtlas->autorelease();         return pTextureAtlas;     }     //如果失败，释放后返回NULL     CC_SAFE_DELETE(pTextureAtlas);     return NULL; } //非静态函数，从文件中创建纹理，并初始化图块容量 bool CCTextureAtlas::initWithFile(const char * file, unsigned int capacity) {     // 由纹理管理器加载一个图片文件，返回生成的纹理     CCTexture2D *texture = CCTextureCache::sharedTextureCache()->addImage(file);     //判断生成纹理是否有效     if (texture)     {           //如果成功，使用纹理进行初始化         return initWithTexture(texture, capacity);     }     else     {         //不成功打印错误日志并返回NULL         CCLOG(\"cocos2d: Could not open file: %s\", file);         delete this;         return NULL;     } } //非静态函数，设置纹理，并初始化图块容量 bool CCTextureAtlas::initWithTexture(CCTexture2D *texture, unsigned int capacity) {     //纹理有效性判断，防止重复调用     CCAssert(texture != NULL, \"texture should not be null\");     //设置图块容量     m_uCapacity = capacity;     m_uTotalQuads = 0;     // 设置纹理     this->m_pTexture = texture;     CC_SAFE_RETAIN(m_pTexture);     // 判断是否重复调用     CCAssert(m_pQuads == NULL && m_pIndices == NULL, \"\");     //申请容量大小的的顶点缓冲信息数组     m_pQuads = (ccV3F_C4B_T2F_Quad*)calloc( sizeof(ccV3F_C4B_T2F_Quad) * m_uCapacity, 1 );      //申请容量大小的索引缓冲数组     m_pIndices = (GLushort *)calloc( sizeof(GLushort) * m_uCapacity * 6, 1 );     //如果失败，做相应处理     if( ! ( m_pQuads && m_pIndices) && m_uCapacity > 0) {         //CCLOG(\"cocos2d: CCTextureAtlas: not enough memory\");         CC_SAFE_FREE(m_pQuads)         CC_SAFE_FREE(m_pIndices)         CC_SAFE_RELEASE_NULL(m_pTexture);         return false;     } //初始化缓冲区对象 #if CC_USES_VBO     glGenBuffers(2, &m_pBuffersVBO[0]);     m_bDirty = true; #endif // CC_USES_VBO //初始化索引缓冲     this->initIndices();     return true; } //取得描述 char * CCTextureAtlas::description() {     char *ret = new char[100];     sprintf(ret, \"<CCTextureAtlas | totalQuads = %u>\", m_uTotalQuads);     return ret; } //初始化索引缓冲 void CCTextureAtlas::initIndices() {     //如果容量为0直接返回     if (m_uCapacity == 0)         return;     //按照顶点的顺序和使用的三角形渲染排列方式为索引缓冲填充数据。     for( unsigned int i=0; i < m_uCapacity; i++)     { #if CC_TEXTURE_ATLAS_USE_TRIANGLE_STRIP         m_pIndices[i*6+0] = i*4+0;         m_pIndices[i*6+1] = i*4+0;         m_pIndices[i*6+2] = i*4+2;              m_pIndices[i*6+3] = i*4+1;         m_pIndices[i*6+4] = i*4+3;         m_pIndices[i*6+5] = i*4+3; #else         m_pIndices[i*6+0] = (GLushort)(i*4+0);         m_pIndices[i*6+1] = (GLushort)(i*4+1);         m_pIndices[i*6+2] = (GLushort)(i*4+2);         // inverted index. issue #179         m_pIndices[i*6+3] = (GLushort)(i*4+3);         m_pIndices[i*6+4] = (GLushort)(i*4+2);         m_pIndices[i*6+5] = (GLushort)(i*4+1);              //      m_pIndices[i*6+3] = i*4+2;         //      m_pIndices[i*6+4] = i*4+3;         //      m_pIndices[i*6+5] = i*4+1;  #endif      } #if CC_USES_VBO     //指定m_pBuffersVBO[0]为顶点缓冲区，并激活缓冲区     glBindBuffer(GL_ARRAY_BUFFER, m_pBuffersVBO[0]);     //绑定完成后为其分配内存     glBufferData(GL_ARRAY_BUFFER, sizeof(m_pQuads[0]) * m_uCapacity, m_pQuads, GL_DYNAMIC_DRAW);     //指定m_pBuffersVBO[1]为索引缓冲区，并激活缓冲区     glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_pBuffersVBO[1]);     //绑定完成后为其分配内存      glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(m_pIndices[0]) * m_uCapacity * 6, m_pIndices, GL_STATIC_DRAW);     //取消绑定     glBindBuffer(GL_ARRAY_BUFFER, 0);     glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0); #endif // CC_USES_VBO } //通过索引值找到对应图块的顶点缓冲并用新数据修改它 void CCTextureAtlas::updateQuad(ccV3F_C4B_T2F_Quad *quad, unsigned int index) {     //有效性判断     CCAssert( index >= 0 && index < m_uCapacity, \"updateQuadWithTexture: Invalid index\");     //如果index大于现有的数量则更新数量     m_uTotalQuads = max( index+1, m_uTotalQuads);     //修改对应的数据值     m_pQuads[index] = *quad;        //需要更新 #if CC_USES_VBO     m_bDirty = true; #endif } //通过索引值找到对应图块的顶点缓冲，并在其位置之前插入一个新的图块。 void CCTextureAtlas::insertQuad(ccV3F_C4B_T2F_Quad *quad, unsigned int index) {     //有效性判断     CCAssert( index < m_uCapacity, \"insertQuadWithTexture: Invalid index\");     //数量增加     m_uTotalQuads++;     CCAssert( m_uTotalQuads <= m_uCapacity, \"invalid totalQuads\");     //先将索引位置之后的数据整体后移一个位置，再用新数据填充索引位置的数据。实现插入操作。     unsigned int remaining = (m_uTotalQuads-1) - index;         if( remaining > 0) {         // texture coordinates         memmove( &m_pQuads[index+1],&m_pQuads[index], sizeof(m_pQuads[0]) * remaining );            }     m_pQuads[index] = *quad;     //设置需要更新m_pBuffersVBO中的VBO数组数据。 #if CC_USES_VBO     m_bDirty = true; #endif } //通过索引值找到对应图块的顶点缓冲，并把它插入另一个图块之前。 void CCTextureAtlas::insertQuadFromIndex(unsigned int oldIndex, unsigned int newIndex) {     //有效性判断     CCAssert( newIndex >= 0 && newIndex < m_uTotalQuads, \"insertQuadFromIndex:atIndex: Invalid index\");     CCAssert( oldIndex >= 0 && oldIndex < m_uTotalQuads, \"insertQuadFromIndex:atIndex: Invalid index\");     //两个索引相同直接返回即可     if( oldIndex == newIndex )         return;     //计算要移动的图块数量     unsigned int howMany = (oldIndex - newIndex) > 0 ? (oldIndex - newIndex) :  (newIndex - oldIndex);     unsigned int dst = oldIndex;     unsigned int src = oldIndex + 1;     if( oldIndex > newIndex) {         dst = newIndex+1;         src = newIndex;     }     // 开始进行移动     ccV3F_C4B_T2F_Quad quadsBackup = m_pQuads[oldIndex];     memmove( &m_pQuads[dst],&m_pQuads[src], sizeof(m_pQuads[0]) * howMany );     //更新新索引位置的数据     m_pQuads[newIndex] = quadsBackup;     //设置需要更新m_pBuffersVBO中的VBO数组数据。 #if CC_USES_VBO     m_bDirty = true; #endif } //移除指定位置的图块顶点缓冲 void CCTextureAtlas::removeQuadAtIndex(unsigned int index) {     //有效性判断     CCAssert( index < m_uTotalQuads, \"removeQuadAtIndex: Invalid index\");     unsigned int remaining = (m_uTotalQuads-1) - index;     //将索引图块后的所有图块向前移1个位置即可     // last object doesn't need to be moved     if( remaining ) {         // texture coordinates         memmove( &m_pQuads[index],&m_pQuads[index+1], sizeof(m_pQuads[0]) * remaining );     }     //数量减1     m_uTotalQuads--;     //设置需要更新m_pBuffersVBO中的VBO数组数据。 #if CC_USES_VBO     m_bDirty = true; #endif } //移除所有的顶点缓冲数据 void CCTextureAtlas::removeAllQuads() {     //数量直接置0，这是最快的方式     m_uTotalQuads = 0; } // 重新设置图块顶点缓冲数组的容量 bool CCTextureAtlas::resizeCapacity(unsigned int newCapacity) {     //如果等于原来的容量直接返回     if( newCapacity == m_uCapacity )         return true;     //确保当前绘制的精灵数量最大不能超过容量     m_uTotalQuads = min(m_uTotalQuads, newCapacity);     //更新容量     m_uCapacity = newCapacity;         //定义指针存放要申请的图块信息与索引数组的内存地址     void * tmpQuads = NULL;     void * tmpIndices = NULL;         //为图块的顶点缓冲数组申请内存,注意：如果已占有内存则直接在原内存地址上进行内存长度调整     if (m_pQuads == NULL)         tmpQuads = calloc(sizeof(m_pQuads[0]) * m_uCapacity, 1);     else         tmpQuads = realloc( m_pQuads, sizeof(m_pQuads[0]) * m_uCapacity );     //为图块的索引缓冲数组申请内存, 如果已占有内存则直接在原内存地址上进行内存长度调整     if (m_pIndices == NULL)         tmpIndices = calloc(sizeof(m_pIndices[0]) * m_uCapacity * 6, 1);     else         tmpIndices = realloc( m_pIndices, sizeof(m_pIndices[0]) * m_uCapacity * 6 );         //如果内存申请失败的处理     if( ! ( tmpQuads && tmpIndices) ) {         //CCLOG(\"cocos2d: CCTextureAtlas: not enough memory\");         if( tmpQuads )             free(tmpQuads);         else             free(m_pQuads);         if( tmpIndices )             free(tmpIndices);         else             free(m_pIndices);         m_pQuads = NULL;         m_pIndices = NULL;         m_uCapacity = m_uTotalQuads = 0;         return false;     }     //如果成功，则将内存地址赋给相应成员指针变量     m_pQuads = (ccV3F_C4B_T2F_Quad *)tmpQuads;     m_pIndices = (GLushort *)tmpIndices;         //释放顶点缓冲对象并重新创建和进行绑定 #if CC_USES_VBO     glDeleteBuffers(2, m_pBuffersVBO);     // initial binding     glGenBuffers(2, &m_pBuffersVBO[0]);     m_bDirty = true; #endif // CC_USES_VBO     //初始化索引缓冲     this->initIndices();     //设置需要更新m_pBuffersVBO中的VBO数组数据。上面已经设了，这里重复可以不要。 #if CC_USES_VBO     m_bDirty = true; #endif     return true; } //绘制所有的图块顶点缓冲数据 void CCTextureAtlas::drawQuads() {     this->drawNumberOfQuads(m_uTotalQuads, 0); } //绘制指定的图块顶点缓冲数据 void CCTextureAtlas::drawNumberOfQuads(unsigned int n) {     this->drawNumberOfQuads(n, 0); } //绘制从指定的图块顶点缓冲数据起后面的N个图块顶点缓冲数据 void CCTextureAtlas::drawNumberOfQuads(unsigned int n, unsigned int start) {       // Default GL states: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY     // Needed states: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY     // Unneeded states: -     // 如果数量为零直接返回。     if (0 == n)         return;     //设置使用纹理     glBindTexture(GL_TEXTURE_2D, m_pTexture->getName()); #define kQuadSize sizeof(m_pQuads[0].bl)     //如果使用VBO所进行的渲染设置 #if CC_USES_VBO     //指定m_pBuffersVBO[0]为顶点缓冲区，并激活缓冲区     glBindBuffer(GL_ARRAY_BUFFER, m_pBuffersVBO[0]);     //绑定完成后为其分配内存 #if CC_ENABLE_CACHE_TEXTTURE_DATA     glBufferData(GL_ARRAY_BUFFER, sizeof(m_pQuads[0]) * m_uCapacity, m_pQuads, GL_DYNAMIC_DRAW); #endif     //在绘制时如果遇到需要更新标记，则重新将顶点缓冲数据更新到绑定的对象上。     if (m_bDirty)     {         glBufferSubData(GL_ARRAY_BUFFER, sizeof(m_pQuads[0]) * start, sizeof(m_pQuads[0]) * n, &m_pQuads[start]);         m_bDirty = false;     }         // 对顶点缓冲中的顶点格式进行解释，让显卡知道顶点格式的构成。     // 顶点缓冲中哪个是位置数据     glVertexPointer(3, GL_FLOAT, kQuadSize, (GLvoid*) offsetof( ccV3F_C4B_T2F, vertices));     //顶点缓冲中哪个是颜色数据     glColorPointer(4, GL_UNSIGNED_BYTE, kQuadSize, (GLvoid*) offsetof( ccV3F_C4B_T2F, colors));     //顶点缓冲中哪个是纹理坐标数据     glTexCoordPointer(2, GL_FLOAT, kQuadSize, (GLvoid*) offsetof( ccV3F_C4B_T2F, texCoords));         //指定m_pBuffersVBO[1]为索引缓冲区，并激活缓冲区 glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_pBuffersVBO[1]);     //绑定完成后为其分配内存 #if CC_ENABLE_CACHE_TEXTTURE_DATA     glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(m_pIndices[0]) * m_uCapacity * 6, m_pIndices, GL_STATIC_DRAW); #endif //按照相应的三角形排列进行渲染 #if CC_TEXTURE_ATLAS_USE_TRIANGLE_STRIP     glDrawElements(GL_TRIANGLE_STRIP, (GLsizei)n*6, GL_UNSIGNED_SHORT, (GLvoid*)(start * 6 * sizeof(m_pIndices[0])));     #else     glDrawElements(GL_TRIANGLES, (GLsizei)n*6, GL_UNSIGNED_SHORT, (GLvoid*)(start * 6 * sizeof(m_pIndices[0]))); #endif // CC_USES_VBO     //从显存上卸载绑定的数据     //停止使用缓冲区     glBindBuffer(GL_ARRAY_BUFFER, 0);     glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0); #else // ! CC_USES_VBO     //如果不使用VBO所进行的渲染设置     unsigned int offset = (unsigned int)m_pQuads;     //设置OpenGL渲染使用的顶点数据     unsigned int diff = offsetof( ccV3F_C4B_T2F, vertices);     glVertexPointer(3, GL_FLOAT, kQuadSize, (GLvoid*) (offset + diff) );     //设置OpenGL渲染使用的颜色数据     diff = offsetof( ccV3F_C4B_T2F, colors);     glColorPointer(4, GL_UNSIGNED_BYTE, kQuadSize, (GLvoid*)(offset + diff));     //设置OpenGL渲染使用的纹理坐标数据     diff = offsetof( ccV3F_C4B_T2F, texCoords);     glTexCoordPointer(2, GL_FLOAT, kQuadSize, (GLvoid*)(offset + diff)); //按照相应的三角形排列进行渲染 #if CC_TEXTURE_ATLAS_USE_TRIANGLE_STRIP     glDrawElements(GL_TRIANGLE_STRIP, n*6, GL_UNSIGNED_SHORT, m_pIndices + start * 6);  #else     glDrawElements(GL_TRIANGLES, n*6, GL_UNSIGNED_SHORT, m_pIndices + start * 6);   #endif #endif // CC_USES_VBO } }//namespace   cocos2d   清楚了CCTextureAtlas，现在回过头再来看CCSpriteBatchNode。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 class CC_DLL CCSpriteBatchNode : public CCNode, public CCTextureProtocol     {     public:         //析构         ~CCSpriteBatchNode();           // 取得纹理图块顶点缓冲管理器。         inline CCTextureAtlas* getTextureAtlas(void) { return m_pobTextureAtlas; }         //设置纹理图块顶点缓冲管理器         inline void setTextureAtlas(CCTextureAtlas* textureAtlas)         {             //如果当前使用的纹理图块顶点缓冲管理器与要设置的纹理图块顶点缓冲管理器不同，先释放原顶点缓冲管理器，再将当前使用的顶点缓冲管理器指针指向要设置顶点缓冲管理器。             if (textureAtlas != m_pobTextureAtlas)             {                 CC_SAFE_RETAIN(textureAtlas);                 CC_SAFE_RELEASE(m_pobTextureAtlas);                 m_pobTextureAtlas = textureAtlas;             }         }         //取得存放所有使用此图块集的CCSprite指针数组         inline CCArray* getDescendants(void) { return m_pobDescendants; }         //静态函数：通过纹理指针按照默认的图块数量29创建一个CCSpriteBatch实例对象。注意：如果游戏运行中图块数量超过这个数值，则数量递增33%以满足需要         static CCSpriteBatchNode* batchNodeWithTexture(CCTexture2D *tex);         //静态函数：通过纹理指针按照设定的图块数量创建一个CCSpriteBatch实例对象。          static CCSpriteBatchNode* batchNodeWithTexture(CCTexture2D* tex, unsigned int capacity);         //静态函数：通过图片名称按照默认的图块数量29创建一个CCSpriteBatch实例对象。         static CCSpriteBatchNode* batchNodeWithFile(const char* fileImage);         //静态函数：通过图片名称按照设定的图块数量创建一个CCSpriteBatch实例对象。          static CCSpriteBatchNode* batchNodeWithFile(const char* fileImage, unsigned int capacity);         //通过纹理指针和图块数量进行初始化。         bool initWithTexture(CCTexture2D *tex, unsigned int capacity);         //通过图片名称和图块数量进行初始化。         bool initWithFile(const char* fileImage, unsigned int capacity);                 //扩容，递增1/3的图块数量         void increaseAtlasCapacity();         //通过索引移除一个子结点，参数doCleanUp决定移除的同时是否对其进行释放。         void removeChildAtIndex(unsigned int index, bool doCleanup);         //将一个指定的CCSprite指针插入到子节点指针数组的指定位置         void insertChild(CCSprite *child, unsigned int index);         //移除一个指定的CCSprite指针         void removeSpriteFromAtlas(CCSprite *sprite);         //重新构建指定的CCSprite指针下的所有子结点的索引         unsigned int rebuildIndexInOrder(CCSprite *parent, unsigned int index);         //取得指定CCSprite的所有节点的最大图块索引         unsigned int highestAtlasIndexInChild(CCSprite *sprite);         //取得指定CCSprite的所有节点的最小图块索引         unsigned int lowestAtlasIndexInChild(CCSprite *sprite);         //取得指定CCSprite的Z顺序之上或之下的最近的图块索引         unsigned int atlasIndexForChild(CCSprite *sprite, int z);                 // 实现CCTextureProtocol的接口函数         // 取得纹理         virtual CCTexture2D* getTexture(void);         // 设置纹理         virtual void setTexture(CCTexture2D *texture);         //为纹理设置使用的混合状态         virtual void setBlendFunc(ccBlendFunc blendFunc);         //取得混合状态         virtual ccBlendFunc getBlendFunc(void);         //重载CCNode的相关函数         //每一帧要被调用的函数         virtual void visit(void);         //将一个CCNode指针做为自已的子结点         virtual void addChild(CCNode * child);         //将一个CCNode指针以指定的Z顺序做为自已的子结点         virtual void addChild(CCNode * child, int zOrder);         //将一个CCNode指针以指定的Z顺序并附带一个参数值做为自已的子结点         virtual void addChild(CCNode * child, int zOrder, int tag);         //将一个子结点重新设置Z顺序         virtual void reorderChild(CCNode * child, int zOrder);         //将一个子结点删除，并根所参数决定是否释放元素         virtual void removeChild(CCNode* child, bool cleanup);         //将所有的子结点移除，并根所参数决定是否释放元素         virtual void removeAllChildrenWithCleanup(bool cleanup);         //绘制函数         virtual void draw(void);     protected:                 //从精灵数据中在图块管理器中插入一个新的图块，注意：并不将精灵放入子结点。      void addQuadFromSprite(CCSprite *sprite, unsigned int index);         //在子结点数组指定位置插入一个新的精灵。注意：并不新建图块。         CCSpriteBatchNode * addSpriteWithoutQuad(CCSprite*child, unsigned int z, int aTag);     private:         //更新混合状态         void updateBlendFunc();     protected:         //使用的纹理图块顶点缓冲管理器         CCTextureAtlas *m_pobTextureAtlas;         //混合状态         ccBlendFunc m_blendFunc;         //指向存放所有使用此纹理中的图块的CCSprite指针数组的指针         CCArray* m_pobDescendants;     };   再看CPP：   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 //加入用到的头文件 #include \"CCSpriteBatchNode.h\" #include \"ccConfig.h\" #include \"CCSprite.h\" #include \"effects/CCGrid.h\" #include \"CCDrawingPrimitives.h\" #include \"CCTextureCache.h\" #include \"CCPointExtension.h\" //使用cocos2d命名空间 namespace cocos2d {     //定义整型常量defaultCapacity做为默认创建的图块数量     const int defaultCapacity = 29;     //静态函数：通过纹理指针按照默认的图块数量29创建一个CCSpriteBatch实例对象。 CCSpriteBatchNode::batchNodeWithTexture(CCTexture2D *tex)     {         //使用new创建一个CCSpriteBatchNode实例对象。         CCSpriteBatchNode *batchNode = new CCSpriteBatchNode();         //使用纹理指针和默认图块数量对CCSpriteBatchNode实例对象进行初始化。         batchNode->initWithTexture(tex, defaultCapacity);         //设置其由内存管理器进行内存释放。         batchNode->autorelease();         //返回新创建的CCSpriteBatchNode实例对象         return batchNode;     }     //静态函数：通过纹理指针按照设定的图块数量创建一个CCSpriteBatch实例对象。      CCSpriteBatchNode* CCSpriteBatchNode::batchNodeWithTexture(CCTexture2D* tex, unsigned int capacity)     {         //同上一函数         CCSpriteBatchNode *batchNode = new CCSpriteBatchNode();         batchNode->initWithTexture(tex, capacity);         batchNode->autorelease();         return batchNode;     }     //静态函数：通过图片名称按照设定的图块数量创建一个CCSpriteBatch实例对象。      CCSpriteBatchNode* CCSpriteBatchNode::batchNodeWithFile(const char *fileImage, unsigned int capacity)     {         //同上一函数         CCSpriteBatchNode *batchNode = new CCSpriteBatchNode();         //这里参数1改为图片名称         batchNode->initWithFile(fileImage, capacity);         batchNode->autorelease();         return batchNode;     }     //静态函数：通过图片名称按照默认的图块数量29创建一个CCSpriteBatch实例对象 CCSpriteBatchNode* CCSpriteBatchNode::batchNodeWithFile(const char *fileImage)     {         //同上         CCSpriteBatchNode *batchNode = new CCSpriteBatchNode();         batchNode->initWithFile(fileImage, defaultCapacity);         batchNode->autorelease();         return batchNode;     }     //通过纹理指针和图块数量进行初始化。注意：这个函数才是真正进行初始化的实现过程。     bool CCSpriteBatchNode::initWithTexture(CCTexture2D *tex, unsigned int capacity)     {         //设置混合系数，源混合系数为CC_BLEND_SRC，目标混合系数为CC_BLEND_DST，则图像绘制时按照纹理或色彩的Alpha值与背景进行混合。         m_blendFunc.src = CC_BLEND_SRC;         m_blendFunc.dst = CC_BLEND_DST;         //创建一个图片集管理器         m_pobTextureAtlas = new CCTextureAtlas();         //将纹理和图块数量做为参数初始化图片集,这里可知图块集还是依靠CCTextureAtlas类。         m_pobTextureAtlas->initWithTexture(tex, capacity);         //更新混合状态         updateBlendFunc();         // 新建一个CCArray实例，将m_pChildren指向它         m_pChildren = CCArray::array();         //新建一个存放所有使用此图块集的CCSprite指针数组，将m_pobDescendants指向它         m_pobDescendants = CCArray::array();         //分别进行引用计数加1操作。         m_pChildren->retain();         m_pobDescendants->retain();         return true;     }     //通过纹理文件名和图块数量进行初始化。     bool CCSpriteBatchNode::initWithFile(const char* fileImage, unsigned int capacity)     {         //使用纹理管理器加载一个图片，生成的纹理返回给变量pTexture2D CCTexture2D *pTexture2D = CCTextureCache::sharedTextureCache()->addImage(fileImage);         //以变量pTexture2D为参数调用上一个函数进行初始化         return initWithTexture(pTexture2D, capacity);     }     //析构     CCSpriteBatchNode::~CCSpriteBatchNode()     {         //释放图块集         CC_SAFE_RELEASE(m_pobTextureAtlas);         CC_SAFE_RELEASE(m_pobDescendants);     }     // 是基类CCNode虚函数，是每帧会被调用到的函数。     void CCSpriteBatchNode::visit(void)     {         //如果不显示，则直接返回。         if (! m_bIsVisible)         {             return;         }         //矩阵压栈，保存渲染此结点前的所有OpenGL所需矩阵的值         glPushMatrix();         //如果         if (m_pGrid && m_pGrid->isActive())         {             m_pGrid->beforeDraw();             transformAncestors();         }         //矩阵变量         transform();         //基类CCNode虚函数，用于实现当前CCNode的绘制。         draw();         //         if (m_pGrid && m_pGrid->isActive())         {             m_pGrid->afterDraw(this);         }         //矩阵出栈。恢复渲染此结点前的所有OpenGL所需矩阵的值         glPopMatrix();     }     //将一个CCSprite指针以指定的Z顺序并附带一个参数值做为子结点     void CCSpriteBatchNode::addChild(CCNode *child, int zOrder, int tag)     {         //有效性判断         CCAssert(child != NULL, \"child should not be null\");         //将结点转为CCSprite         CCSprite *pSprite = (CCSprite*)(child);         // check CCSprite is using the same texture id         //确保pSprite的纹理与图片集的纹理相同才可以放为子结点         CCAssert(pSprite->getTexture()->getName() == m_pobTextureAtlas->getTexture()->getName(), \"\");         CCNode::addChild(child, zOrder, tag);         //根据填入的Z顺序值取得pSprite所在的子结点索引放在变量uIndex中         unsigned int uIndex = atlasIndexForChild(pSprite, zOrder);         //将pSprite插入到第uIndex个位置         insertChild(pSprite, uIndex);     }     //将一个CCNode指针做为子结点     void CCSpriteBatchNode::addChild(CCNode *child)     {         //调用基类的addChild         CCNode::addChild(child);     }     //将一个CCNode指针以指定的Z顺序做为子结点     void CCSpriteBatchNode::addChild(CCNode *child, int zOrder)     {         //调用基类的addChild         CCNode::addChild(child, zOrder);     }     //将子结点重新设置Z顺序。     void CCSpriteBatchNode::reorderChild(CCNode *child, int zOrder)     {         //结点参数有效性判断         CCAssert(child != NULL, \"the child should not be null\");         //确保此结点是挂在子结点树上。         CCAssert(m_pChildren->containsObject(child), \"sprite batch node should contain the child\");         //如果顺序已经与结点的Z顺序相等则直接返回         if (zOrder == child->getZOrder())         {             return;         }         //子结点引用计数加1         child->retain();         //将子结点从子结点树上移除         removeChild((CCSprite*)child, false);         //按照新的Z顺序插入结点树         addChild(child, zOrder);         //引用计数减1         child->release();     }     //将一个CCNode指针从子结点数组中删除，并根所参数决定是否释放元素     void CCSpriteBatchNode::removeChild(CCNode *child, bool cleanup)     {         //将结点转为CCSprite         CCSprite *pSprite = (CCSprite*)(child);         // explicit null handling         if (pSprite == NULL)         {             return;         }         //确保子结点树中有pSprite         CCAssert(m_pChildren->containsObject(pSprite), \"sprite batch node should contain the child\");         //移除一个指定的CCSprite指针         removeSpriteFromAtlas(pSprite);         //调用基类的移除子结点函数         CCNode::removeChild(pSprite, cleanup);     }     //通过索引移除一个子结点，参数doCleanUp决定移除的同时是否对其进行释放。     void CCSpriteBatchNode::removeChildAtIndex(unsigned int uIndex, bool bDoCleanup)     {         removeChild((CCSprite*)(m_pChildren->objectAtIndex(uIndex)), bDoCleanup);     }     //将所有的子结点数组元素移除，并根所参数决定是否释放元素     void CCSpriteBatchNode::removeAllChildrenWithCleanup(bool bCleanup)     {         // 如果有子结点         if (m_pChildren && m_pChildren->count() > 0)         {             //遍历子结点调用移除子结点函数             CCObject* pObject = NULL;             CCARRAY_FOREACH(m_pChildren, pObject)             {                 CCSprite* pChild = (CCSprite*) pObject;                 if (pChild)                 {                     removeSpriteFromAtlas(pChild);                 }             }         }         //调用基类的移除子结点函数         CCNode::removeAllChildrenWithCleanup(bCleanup);         //清空使用此图块集的CCSprite指针数组         m_pobDescendants->removeAllObjects();         //清空图块集管理器中的图块信息         m_pobTextureAtlas->removeAllQuads();     }     //绘制当前CCNode     void CCSpriteBatchNode::draw(void)     {         //调用基类CCNode的draw函数         CCNode::draw();         // 如果图块集为空直接返回         if (m_pobTextureAtlas->getTotalQuads() == 0)         {             return;         }         // 如果图块集不为空         if (m_pobDescendants && m_pobDescendants->count() > 0)         {             //遍历所有使用此图块集的CCSprite             CCObject* pObject = NULL;             CCARRAY_FOREACH(m_pobDescendants, pObject)             {                 CCSprite* pChild = (CCSprite*) pObject;                 if (pChild)                 {                     // 更新CCSprite的矩阵，注意:此句内部实现将子结点pChild所指的精灵的位置更新到对应的图块集顶点缓冲中。                     pChild->updateTransform(); #if CC_SPRITEBATCHNODE_DEBUG_DRAW                     // 如果开启调试，则绘制CCSprite的包围矩形                     CCRect rect = pChild->boundingBox();                     CCPoint vertices[4]={                         ccp(rect.origin.x,rect.origin.y),                         ccp(rect.origin.x+rect.size.width,rect.origin.y),                         ccp(rect.origin.x+rect.size.width,rect.origin.y+rect.size.height),                         ccp(rect.origin.x,rect.origin.y+rect.size.height),                     };                     ccDrawPoly(vertices, 4, true); #endif // CC_SPRITEBATCHNODE_DEBUG_DRAW                 }             }         }         // 设置ALPHA混合状态         bool newBlend = m_blendFunc.src != CC_BLEND_SRC || m_blendFunc.dst != CC_BLEND_DST;         if (newBlend)         {             glBlendFunc(m_blendFunc.src, m_blendFunc.dst);         }         //绘制图块集         m_pobTextureAtlas->drawQuads();         //恢复原ALPHA混合状态         if (newBlend)         {             glBlendFunc(CC_BLEND_SRC, CC_BLEND_DST);         }     }     //扩容，递增1/3的图块数量     void CCSpriteBatchNode::increaseAtlasCapacity(void)     {         // this is likely computationally expensive         // 如果当前需要的图块数量比实际图块数量大，则将图块的数量增加1/3。         unsigned int quantity = (m_pobTextureAtlas->getCapacity() + 1) * 4 / 3;         // 打印图块数量的变化信息         CCLOG(\"cocos2d: CCSpriteBatchNode: resizing TextureAtlas capacity from [%lu] to [%lu].\",             (long)m_pobTextureAtlas->getCapacity(),             (long)quantity);         //图块集重新设置数量，resizeCapacity按新的图块集数量重新计算每个图块的纹理UV         if (! m_pobTextureAtlas->resizeCapacity(quantity))         {             // 如果失败，返回出错信息。             CCLOG(\"cocos2d: WARNING: Not enough memory to resize the atlas\");             CCAssert(false, \"Not enough memory to resize the atla\");         }     }     //重新构建指定的CCSprite指针下的所有子结点的索引     unsigned int CCSpriteBatchNode::rebuildIndexInOrder(CCSprite *pobParent, unsigned int uIndex)     {         //取得参数pobParent的所有子结点数组         CCArray *pChildren = pobParent->getChildren();         //如果子结点数组不为空         if (pChildren && pChildren->count() > 0)         {             //遍历子结点数组并             CCObject* pObject = NULL;             CCARRAY_FOREACH(pChildren, pObject)             {                 CCSprite* pChild = (CCSprite*) pObject;                 if (pChild && (pChild->getZOrder() < 0))                 {                     uIndex = rebuildIndexInOrder(pChild, uIndex);                 }             }         }           // 如果pobParent         if (! pobParent->isEqual(this))         {             pobParent->setAtlasIndex(uIndex);             uIndex++;         }         //如果子结点数组不为空         if (pChildren && pChildren->count() > 0)         {             //遍历子结点数组并             CCObject* pObject = NULL;             CCARRAY_FOREACH(pChildren, pObject)             {                 CCSprite* pChild = (CCSprite*) pObject;                 if (pChild && (pChild->getZOrder() >= 0))                 {                     uIndex = rebuildIndexInOrder(pChild, uIndex);                 }             }         }         return uIndex;     }     //取得指定CCSprite的所有节点的最大图块索引     unsigned int CCSpriteBatchNode::highestAtlasIndexInChild(CCSprite *pSprite)     {         //取得指定CCSprite的子结点数组         CCArray *pChildren = pSprite->getChildren();          //如果没有子结点，直接返回指定CCSprite的图块索引         if (! pChildren || pChildren->count() == 0)         {             return pSprite->getAtlasIndex();         }         else         {             return highestAtlasIndexInChild((CCSprite*)(pChildren->lastObject()));         }     }     //取得指定CCSprite的所有节点的最小图块索引     unsigned int CCSpriteBatchNode::lowestAtlasIndexInChild(CCSprite *pSprite)     {                 CCArray *pChildren = pSprite->getChildren();         //取得指定CCSprite的子结点数           if (! pChildren || pChildren->count() == 0)         { //取得指定CCSprite的子结点数组             return pSprite->getAtlasIndex();         }         else         {             return lowestAtlasIndexInChild((CCSprite*)(pChildren->objectAtIndex(0)));         }     }     //取得对应的子结点的Z顺序之上或之下的最近图块索引     unsigned int CCSpriteBatchNode::atlasIndexForChild(CCSprite *pobSprite, int nZ)     {         //取得pobSprite的父节点的所有子结点数组。         CCArray *pBrothers = pobSprite->getParent()->getChildren();         //查询pobSprite在所有子结点数组中的索引 unsigned int uChildIndex = pBrothers->indexOfObject(pobSprite);          // 判断当前节点是否是pobSprite的父结点，将结果存入bIgnoreParent。         bool bIgnoreParent = (CCSpriteBatchNode*)(pobSprite->getParent()) == this;         // 新建指针变量pPrevious，用于存储pobSprite的前一个结点。         CCSprite *pPrevious = NULL;         if (uChildIndex > 0 &&             uChildIndex < UINT_MAX)         {   //取得pobSprite在所有子结点中的位置前一个节点。             pPrevious = (CCSprite*)(pBrothers->objectAtIndex(uChildIndex - 1));         }         // 如果当前节点是pobSprite的父结点。         if (bIgnoreParent)         {             //如果pobSprite就是第一个子结点。则返回0。             if (uChildIndex == 0)             {                 return 0;             }             //如果pobSprite不是第一个子结点，则返回pobSprite的前一个结点的最大图块索引，加1返回。             return highestAtlasIndexInChild(pPrevious) + 1;         }         // 当前节点不是pobSprite的父结点。         // 如果pobSprite是其父节点的第一子结点         if (uChildIndex == 0)         {             //新建指针变量p，指向pobSprite的父结点。             CCSprite *p = (CCSprite*)(pobSprite->getParent());             // less than parent and brothers             // 如果nZ小于零,即在其之下的最近索引             if (nZ < 0)             {                 //返回pobSprite的父结点的图块索引。                 return p->getAtlasIndex();             }             else             {   //如果nZ大于零，即在其之上的最近索引                 //返回pobSprite的父结点的图块索引值加1。                 return p->getAtlasIndex() + 1;             }         }         else         {             //如果pobSprite不是其父节点的第一子结点             if ((pPrevious->getZOrder() < 0 && nZ < 0) || (pPrevious->getZOrder() >= 0 && nZ >= 0))             {                 //返回pobSprite前一个节点的的最大图块索引加1                 return highestAtlasIndexInChild(pPrevious) + 1;             }             // 否则返回其父节点的图块索引值加1             // else (previous < 0 and sprite >= 0 )             CCSprite *p = (CCSprite*)(pobSprite->getParent());             return p->getAtlasIndex() + 1;         }         // 如果进行到这一步，已经出错了。打印出错信息。         CCAssert(0, \"should not run here\");         return 0;     }     //将一个CCSprite插入到子节点指针数组的指定位置     void CCSpriteBatchNode::insertChild(CCSprite *pobSprite, unsigned int uIndex)     {         //pobSprite应用此图片集         pobSprite->useBatchNode(this);         //设置图块集索引值         pobSprite->setAtlasIndex(uIndex);         //设置pobSprite在绘制时需要进行绑定图块的更新         pobSprite->setDirty(true);         //如果图块集已经达到最大容量则进行扩容         if (m_pobTextureAtlas->getTotalQuads() == m_pobTextureAtlas->getCapacity())         {             increaseAtlasCapacity();         }         //在图块集管理器中新增加一个图块，并指定其索引         ccV3F_C4B_T2F_Quad quad = pobSprite->getQuad();         m_pobTextureAtlas->insertQuad(&quad, uIndex);         //将pobSprite放入到使用此图集子结点数组的对应位置         m_pobDescendants->insertObject(pobSprite, uIndex);         // 更新索引         unsigned int i = 0;         //如果使用此图集的子结点数组不为空，遍历并重设一下大于此索引的所有子结点。         if (m_pobDescendants && m_pobDescendants->count() > 0)         {             CCObject* pObject = NULL;             CCARRAY_FOREACH(m_pobDescendants, pObject)             {                 CCSprite* pChild = (CCSprite*) pObject;                 if (pChild)                 {                     if (i > uIndex)                     {                         pChild->setAtlasIndex(pChild->getAtlasIndex() + 1);                     }                     ++i;                 }             }         }           // 取得pobSprite的子结点数组         CCArray *pChildren = pobSprite->getChildren();         // 如果不为空，遍历并将子结点也按照Z顺序放入到当前CCSpriteBatchNode的子结点数组中。         if (pChildren && pChildren->count() > 0)         {             CCObject* pObject = NULL;             CCARRAY_FOREACH(pChildren, pObject)             {                 CCSprite* pChild = (CCSprite*) pObject;                 if (pChild)                 {                     unsigned int uIndex = atlasIndexForChild(pChild, pChild->getZOrder());                     insertChild(pChild, uIndex);                 }             }         }     }     //移除一个CCSprite     void CCSpriteBatchNode::removeSpriteFromAtlas(CCSprite *pobSprite)     {         // 从图块管理器中移除目标精灵pobSprite所用的图块信息         m_pobTextureAtlas->removeQuadAtIndex(pobSprite->getAtlasIndex());         //重置目标精灵pobSprite所使用的图块信息         pobSprite->useSelfRender();         //取得目标精灵pobSprite在CCSpriteBatchNode的子结点中数组中的位置         unsigned int uIndex = m_pobDescendants->indexOfObject(pobSprite);         //如果找到后，从子结点数组中移除它         if (uIndex != UINT_MAX)         {             m_pobDescendants->removeObjectAtIndex(uIndex);             // 取得子结点的数组元素数量，遍历大于当前索引的子结点，向前移一个位置。注意：这个for循环从uIndex开始计数。             unsigned int count = m_pobDescendants->count();             for(; uIndex < count; ++uIndex)             {                 CCSprite* s = (CCSprite*)(m_pobDescendants->objectAtIndex(uIndex));                 s->setAtlasIndex( s->getAtlasIndex() - 1 );             }         }         // 取得目标精灵的子结点数组，遍历并从当前CCSpriteBatchNode的子结点数组中移除。         CCArray *pChildren = pobSprite->getChildren();         if (pChildren && pChildren->count() > 0)         {             CCObject* pObject = NULL;             CCARRAY_FOREACH(pChildren, pObject)             {                 CCSprite* pChild = (CCSprite*) pObject;                 if (pChild)                 {                     removeSpriteFromAtlas(pChild);                 }             }         }     }     //更新Alpha混合状态     void CCSpriteBatchNode::updateBlendFunc(void)     {         //如果当前图块集对应的纹理有Alpha通道         if (! m_pobTextureAtlas->getTexture()->getHasPremultipliedAlpha())         {             //设置GL_SRC_ALPHA表示使用源颜色的alpha值来作源混合因子。             m_blendFunc.src = GL_SRC_ALPHA;             // GL_ONE_MINUS_SRC_ALPHA表示用1.0减去源颜色的alpha值来作为目标混合因子。             m_blendFunc.dst = GL_ONE_MINUS_SRC_ALPHA;         }     }     // 设置Alpha混合状态     void CCSpriteBatchNode::setBlendFunc(ccBlendFunc blendFunc)     {         m_blendFunc = blendFunc;     }     // 取得Alpha混合状态     ccBlendFunc CCSpriteBatchNode::getBlendFunc(void)     {         return m_blendFunc;     }     //取得图块集所应用的纹理贴图。     CCTexture2D* CCSpriteBatchNode::getTexture(void)     {         return m_pobTextureAtlas->getTexture();     }     //设置图块集所应用的纹理贴图     void CCSpriteBatchNode::setTexture(CCTexture2D *texture)     {         m_pobTextureAtlas->setTexture(texture);         //设置完后跟据纹理贴图是否有Alpha通道更新一下混合状态。         updateBlendFunc();     }     //从精灵数据中在图块管理器中插入一个新的图块，注意：并不将精灵放入子结点。     void CCSpriteBatchNode::addQuadFromSprite(CCSprite *sprite, unsigned int index) {      //判断sprite是否有效。         CCAssert( sprite != NULL, \"Argument must be non-nil\");          //如果指定的索引大于图块集的数量或者图块集的数量已经达到最大值，则需要对图块集进行扩容。         while(index >= m_pobTextureAtlas->getCapacity() || m_pobTextureAtlas->getCapacity() == m_pobTextureAtlas->getTotalQuads())         {             this->increaseAtlasCapacity();         }         //让sprite使用此图集管理器         sprite->useBatchNode(this);         //设置sprite的图块索引         sprite->setAtlasIndex(index);                 //新建一个图块顶点信息放入图块信息管理器中。         ccV3F_C4B_T2F_Quad quad = sprite->getQuad();         m_pobTextureAtlas->insertQuad(&quad, index);         //设置在缓制sprite时更新一下图块信息         sprite->setDirty(true);         //将sprite的顶点位置信息填充入图块顶点缓冲管理器中的顶点数据中。         sprite->updateTransform(); }     //在子结点数组指定位置插入一个新的精灵。注意：并不新建图块。     CCSpriteBatchNode * CCSpriteBatchNode::addSpriteWithoutQuad(CCSprite*child, unsigned int z, int aTag) {      //判断sprite是否有效。         CCAssert( child != NULL, \"Argument must be non-nil\");         //设置sprite的图块索引         child->setAtlasIndex(z);        //遍历子结点数组查看当前Z值应该排在哪个位置。         int i=0;         if (m_pobDescendants && m_pobDescendants->count() > 0)         {             CCObject* pObject = NULL;             CCARRAY_FOREACH(m_pobDescendants, pObject)             {                 CCSprite* pChild = (CCSprite*) pObject;                 if (pChild && (pChild->getAtlasIndex() >= z))                 {                     ++i;                 }             }         }         //取得位置i，插入child到数组中。         m_pobDescendants->insertObject(child, i);         //基类同名函数         CCNode::addChild(child, z, aTag);         return this;     } }   分析这个类的确是费功夫啊，呵呵。继续之前。喝口水先。话说今天听新闻，北京PM2.5浓度又升高了，我可怜的嗓子，担忧中… 走到这里，我们已经了解了CCSpriteBatchNode的作用。其实红孩儿在开发引擎的经历中也有过类似的设计，为了渲染大量相同类型的模型，按照纹理将子模型归类，并将这些纹理进行合并生成大纹理，渲染时设置大纹理就可以渲染出多个不同类型的子模型，如果开启克隆实例，则可以在一个批次内渲出上百个模型。原理相通，目的只有一个，提高渲染效率。 CCLabelBMFont类中关于图字纹理和图块的相关知识我们了解完了，但是我们仍然没有发现Fnt用在哪里，所以我们只理解了一半，现在我们来理解另一半。CCLabelBMFont中使用到一个类CCBMFontConfiguration，它就是用来读取Fnt文件中的文字图片说明信息的。在CCLabelBMFont.h中我们找到它   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class CC_DLL CCBMFontConfiguration : public CCObject     {         public:         //通过map容器对字的编码值和对应的信息做映射         std::map<unsigned int, ccBMFontDef>* m_pBitmapFontArray;         //FNT文件中的字图块公共项:Height         unsigned int m_uCommonHeight;         //FNT文件中的信息:边距，文字与边框的空隙         ccBMFontPadding m_tPadding;         //FNT文件中的信息:用到的png图         std::string m_sAtlasName;         //FNT文件中的信息:两个字在先后绘制时的间距调整的信息结构的哈希字典(其实就是个数组，以哈希算法进行存储）。         struct _KerningHashElement  *m_pKerningDictionary;     public:         //构造         CCBMFontConfiguration();         //析构         virtual ~CCBMFontConfiguration();         //取得描述         char * description();         //静态函数：将FNT文件加载进来返回一个CCBMFontConfiguration实例对象。         static CCBMFontConfiguration * configurationWithFNTFile(const char *FNTfile);         //使用FNT文件初始化         bool initWithFNTfile(const char *FNTfile);     private:         //解析FNT文件         void parseConfigFile(const char *controlFile);         //从文件中取得字符的编码及UV对应信息         void parseCharacterDefinition(std::string line, ccBMFontDef *characterDefinition);         //从文件取得字体说明         void parseInfoArguments(std::string line);         //从文件取得字符图块公共信息         void parseCommonArguments(std::string line);         //从文件取得图片文件名称         void parseImageFileName(std::string line, const char *fntFile);         //从文件取得要调整间距的字组合信息容量         void parseKerningCapacity(std::string line);         //从文件取得要调整间距的字组合信息         void parseKerningEntry(std::string line);         //从文件取得调整间距的字组合信息字典         void purgeKerningDictionary();     };   太棒了，它对Fnt文件做了全面的解析。马上看CPP他是怎么现实的。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332     初始化全局容器指针为空     CCMutableDictionary<std::string, CCBMFontConfiguration*> *configurations = NULL;     //全局函数：从Fnt文件中取得一个CCBMFontConfiguration实例对象     CCBMFontConfiguration* FNTConfigLoadFile( const char *fntFile)     {         //创建CCBMFontConfiguration指针变量pRet并置空         CCBMFontConfiguration *pRet = NULL;         //如果容器为空则新建容器         if( configurations == NULL )         {             configurations = new CCMutableDictionary<std::string, CCBMFontConfiguration*>();         }         //在容器中取得该文件对应的CCBMFontConfiguration         std::string key(fntFile);         pRet = configurations->objectForKey(key);         if( pRet == NULL )         {             //如果为空则调用CCBMFontConfiguration静态函数新建一个CCBMFontConfiguration读取文件返回信息结构给pRet             pRet = CCBMFontConfiguration::configurationWithFNTFile(fntFile);             //并将其加入容器中             configurations->setObject(pRet, key);         }         return pRet;     }     //释放容器中的数据并释放容器占用内存     void FNTConfigRemoveCache( void )     {         if (configurations)         {             configurations->removeAllObjects();             CC_SAFE_RELEASE_NULL(configurations);         }     }     //用于进行获取间距调整信息的哈希参数结构     typedef struct _KerningHashElement     {           int             key;        // key for the hash. 16-bit for 1st element, 16-bit for 2nd element         int             amount;         UT_hash_handle  hh;     } tKerningHashElement;             //静态函数，从Fnt文件中取得一个CCBMFontConfiguration实例对象         CCBMFontConfiguration * CCBMFontConfiguration::configurationWithFNTFile(const char *FNTfile)     {         //新建一个CCBMFontConfiguration实例对象         CCBMFontConfiguration * pRet = new CCBMFontConfiguration();         //使用FNT文件信息初始化         if (pRet->initWithFNTfile(FNTfile))         {             pRet->autorelease();             return pRet;         }         CC_SAFE_DELETE(pRet);         return NULL;     }     //由FNT文件对CCBMFontConfiguration实例对象进行初始化     bool CCBMFontConfiguration::initWithFNTfile(const char *FNTfile)     {         //有效性判断         CCAssert(FNTfile != NULL && strlen(FNTfile)!=0, \"\");         //解析FNT文件         m_pKerningDictionary = NULL;         this->parseConfigFile(FNTfile);         return true;     }     //构造函数     CCBMFontConfiguration::CCBMFontConfiguration()         : m_pBitmapFontArray(new std::map<unsigned int, ccBMFontDef>)         , m_uCommonHeight(0)         , m_pKerningDictionary(NULL)     {       }     //析构     CCBMFontConfiguration::~CCBMFontConfiguration()     {         //打印日志         CCLOGINFO( \"cocos2d: deallocing CCBMFontConfiguration\" );         //释放占用内存         CC_SAFE_DELETE(m_pBitmapFontArray);         this->purgeKerningDictionary();         m_sAtlasName.clear();     }     //取得描述     char * CCBMFontConfiguration::description(void)     {         char *ret = new char[100];         sprintf(ret, \"<CCBMFontConfiguration | Kernings:%d | Image = %s>\", HASH_COUNT(m_pKerningDictionary), m_sAtlasName.c_str());         return ret;     }     //释放间距信息字典     void CCBMFontConfiguration::purgeKerningDictionary()     {         tKerningHashElement *current;         while(m_pKerningDictionary)         {             current = m_pKerningDictionary;             HASH_DEL(m_pKerningDictionary,current);             free(current);         }     }         //解析FNT文件     void CCBMFontConfiguration::parseConfigFile(const char *controlFile)     {           //通过文件名找出对应的文件路径         std::string fullpath = CCFileUtils::fullPathFromRelativePath(controlFile);         //打开文件进行读操作，执行后会将文件读取到CCFileData创建的内存志中。         CCFileData data(fullpath.c_str(), \"rb\");         //取得文件大小         unsigned long nBufSize = data.getSize();         //取得CCFileData存储读取信息的内存块。         char* pBuffer = (char*) data.getBuffer();         //有效检查         CCAssert(pBuffer, \"CCBMFontConfiguration::parseConfigFile | Open file error.\");         if (!pBuffer)         {             return;         }         std::string line;         //将文件信息放入到字符串strLeft中         std::string strLeft(pBuffer, nBufSize);         //遍历字符串中每个字符进行解析         while (strLeft.length() > 0)         {              //根据换行符取出每一行             int pos = strLeft.find('\\n');              //如果不是结尾             if (pos != (int)std::string::npos)             {                 //取出此行                 line = strLeft.substr(0, pos);                   //更新当前字符串为新一行位置后面的字符串                 strLeft = strLeft.substr(pos + 1);             }             else             {                 //取后一行                 line = strLeft;                 strLeft.erase();             }              //如果是字体介绍信息             if(line.substr(0,strlen(\"info face\")) == \"info face\")             {                 //解析信息行                 this->parseInfoArguments(line);             }             //如果是图块公共信息             else if(line.substr(0,strlen(\"common lineHeight\")) == \"common lineHeight\")             {                   //解析图块公共信息                 this->parseCommonArguments(line);             }               //如果是指定索引的图片说明信息             else if(line.substr(0,strlen(\"page id\")) == \"page id\")             {                   //解析指定索引的图片的说明信息                 this->parseImageFileName(line, controlFile);             }               //如果是本图片中的字符数量             else if(line.substr(0,strlen(\"chars c\")) == \"chars c\")             {                 //本句忽略了，无意义，后面读取字符时可以统计             }               //如果是字符信息             else if(line.substr(0,strlen(\"char\")) == \"char\")             {                 //一个字符的编码对应信息                 ccBMFontDef characterDefinition;                   //将本行字符串解析到字符的编码对应信息中                 this->parseCharacterDefinition(line, &characterDefinition);                 通过信息索引存入哈希字典                 (*m_pBitmapFontArray)[ characterDefinition.charID ] = characterDefinition;             }               //如果有间距调整信息             else if(line.substr(0,strlen(\"kernings count\")) == \"kernings count\")             {                //那也得解析啊~                  this->parseKerningCapacity(line);             }              //解析后面的间距调整             else if(line.substr(0,strlen(\"kerning first\")) == \"kerning first\")             {                   //解析间距调整信息                 this->parseKerningEntry(line);             }         }     }     //解析指定索引的图片的说明信息     void CCBMFontConfiguration::parseImageFileName(std::string line, const char *fntFile)     {         //先取得id         int index = line.find('=')+1;         int index2 = line.find(' ', index);         std::string value = line.substr(index, index2-index);                 //这里只使用了第一张图。所以要求索引为0         CCAssert(atoi(value.c_str()) == 0, \"LabelBMFont file could not be found\");         // 取得文件名称         index = line.find('\"')+1;         index2 = line.find('\"', index);         value = line.substr(index, index2-index);         //将文件名对应的全路径存入到字符串m_sAtlasName中         m_sAtlasName = CCFileUtils::fullPathFromRelativeFile(value.c_str(), fntFile);     }     //解析字体介绍信息     void CCBMFontConfiguration::parseInfoArguments(std::string line)     {                 //实际使用中，其实只用到了内边距padding，因为最终显示结果还是需要从图块中获取，既然已经有了图块，那至于字体的字体，大小，是否平滑等信息其实不会影响什么，只是用来做一个说明罢了。         // 内边距padding         int index = line.find(\"padding=\");         int index2 = line.find(' ', index);         std::string value = line.substr(index, index2-index);         sscanf(value.c_str(), \"padding=%d,%d,%d,%d\", &m_tPadding.top, &m_tPadding.right, &m_tPadding.bottom, &m_tPadding.left);         CCLOG(\"cocos2d: padding: %d,%d,%d,%d\", m_tPadding.left, m_tPadding.top, m_tPadding.right, m_tPadding.bottom);     }     //解析字块公共信息     void CCBMFontConfiguration::parseCommonArguments(std::string line)     {         // LineHeight：行高         int index = line.find(\"lineHeight=\");         int index2 = line.find(' ', index);         std::string value = line.substr(index, index2-index);         sscanf(value.c_str(), \"lineHeight=%u\", &m_uCommonHeight);         // scaleW：图片宽         index = line.find(\"scaleW=\") + strlen(\"scaleW=\");         index2 = line.find(' ', index);         value = line.substr(index, index2-index);         CCAssert(atoi(value.c_str()) <= CCConfiguration::sharedConfiguration()->getMaxTextureSize(), \"CCLabelBMFont: page can't be larger than supported\");         // scaleH：图片高         index = line.find(\"scaleH=\") + strlen(\"scaleH=\");         index2 = line.find(' ', index);         value = line.substr(index, index2-index);         CCAssert(atoi(value.c_str()) <= CCConfiguration::sharedConfiguration()->getMaxTextureSize(), \"CCLabelBMFont: page can't be larger than supported\");         // pages:共有几张文字图片供使用         index = line.find(\"pages=\") + strlen(\"pages=\");         index2 = line.find(' ', index);         value = line.substr(index, index2-index);         CCAssert(atoi(value.c_str()) == 1, \"CCBitfontAtlas: only supports 1 page\");         //packed忽略     }     //解析字符编码与UV对应信息块     void CCBMFontConfiguration::parseCharacterDefinition(std::string line, ccBMFontDef *characterDefinition)     {                   //读取编码值         int index = line.find(\"id=\");         int index2 = line.find(' ', index);         std::string value = line.substr(index, index2-index);         sscanf(value.c_str(), \"id=%u\", &characterDefinition->charID);         // 在图块中的像素横向位置         index = line.find(\"x=\");         index2 = line.find(' ', index);         value = line.substr(index, index2-index);         sscanf(value.c_str(), \"x=%f\", &characterDefinition->rect.origin.x);         // 在图块中的像素纵向位置         index = line.find(\"y=\");         index2 = line.find(' ', index);         value = line.substr(index, index2-index);         sscanf(value.c_str(), \"y=%f\", &characterDefinition->rect.origin.y);         // 对应图块的宽         index = line.find(\"width=\");         index2 = line.find(' ', index);         value = line.substr(index, index2-index);         sscanf(value.c_str(), \"width=%f\", &characterDefinition->rect.size.width);         // 对应图块的高         index = line.find(\"height=\");         index2 = line.find(' ', index);         value = line.substr(index, index2-index);         sscanf(value.c_str(), \"height=%f\", &characterDefinition->rect.size.height);         // 当前字在绘制时的像素偏移横向位置         index = line.find(\"xoffset=\");         index2 = line.find(' ', index);         value = line.substr(index, index2-index);         sscanf(value.c_str(), \"xoffset=%d\", &characterDefinition->xOffset);         // 当前字在绘制时的像素偏移纵向位置         index = line.find(\"yoffset=\");         index2 = line.find(' ', index);         value = line.substr(index, index2-index);         sscanf(value.c_str(), \"yoffset=%d\", &characterDefinition->yOffset);         // 绘制完当前字后，光标向后移多少像素以绘制下一个字         index = line.find(\"xadvance=\");         index2 = line.find(' ', index);         value = line.substr(index, index2-index);         sscanf(value.c_str(), \"xadvance=%d\", &characterDefinition->xAdvance);     }     //解析某两个字在一起时字距调整信息并存入哈希字典     void CCBMFontConfiguration::parseKerningCapacity(std::string line)     {         //同样没有什么意义，字数量可以统过后面的解析统计出来     }     //解析字距调整信息     void CCBMFontConfiguration::parseKerningEntry(std::string line)     {               // first解析第一个字         int first;         int index = line.find(\"first=\");         int index2 = line.find(' ', index);         std::string value = line.substr(index, index2-index);         sscanf(value.c_str(), \"first=%d\", &first);         // second:解析第二个字         int second;         index = line.find(\"second=\");         index2 = line.find(' ', index);         value = line.substr(index, index2-index);         sscanf(value.c_str(), \"second=%d\", &second);         // amount:解析要调整的像素个数，负值向左，正值向右         int amount;         index = line.find(\"amount=\");         index2 = line.find(' ', index);         value = line.substr(index, index2-index);         sscanf(value.c_str(), \"amount=%d\", &amount);                 //将对应关系存入哈希字典         tKerningHashElement *element = (tKerningHashElement *)calloc( sizeof( *element ), 1 );         element->amount = amount;         element->key = (first<<16) | (second&0xffff);         HASH_ADD_INT(m_pKerningDictionary,key, element);     }   CCBMFontConfiguration类分析完了，CCLabelBMFont就很容易理解了。快马加鞭向前冲哟~   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class CC_DLL CCLabelBMFont : public CCSpriteBatchNode, public CCLabelProtocol, public CCRGBAProtocol     {         //容量         CC_PROPERTY(GLubyte, m_cOpacity, Opacity)         //颜色         CC_PROPERTY_PASS_BY_REF(ccColor3B, m_tColor, Color)         //是否使用透明度来设置RGB值         CC_PROPERTY(bool, m_bIsOpacityModifyRGB, IsOpacityModifyRGB)     protected:         // 要渲染的字符串         std::string m_sString;         //使用的设置         CCBMFontConfiguration *m_pConfiguration;     public:         //构造函数。         CCLabelBMFont()             : m_cOpacity(0)                       , m_bIsOpacityModifyRGB(false)             , m_sString(\"\")              , m_pConfiguration(NULL)         {}         //析构         virtual ~CCLabelBMFont();         //释放占用的内存         static void purgeCachedData();         //由一个字符串和字体fnt文件创建图字         bool initWithString(const char *str, const char *fntFile);         //重点函数：根据字符串和字体信息进行纹理图对应         void createFontChars();         //设置要渲染的字符串         virtual void setString(const char *label);         //取得要渲染的字符串         virtual const char* getString(void);         //设置要渲染的字符串，setString的别名函数         virtual void setCString(const char *label);         //设置锚点         virtual void setAnchorPoint(const CCPoint& var);         //绘制函数 #if CC_LABELBMFONT_DEBUG_DRAW         virtual void draw(); #endif // CC_LABELBMFONT_DEBUG_DRAW     private:         char * atlasNameFromFntFile(const char *fntFile);         int kerningAmountForFirst(unsigned short first, unsigned short second);     };   CPP文件:   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499     //释放占用的内存     void CCLabelBMFont::purgeCachedData()     {         //释放文字FNT信息指针         FNTConfigRemoveCache();     }     //静态函数：由一个字符串和字体fnt文件创建图字     CCLabelBMFont *CCLabelBMFont::labelWithString(const char *str, const char *fntFile)     {         //new 出一个新的CCLabelBMFont         CCLabelBMFont *pRet = new CCLabelBMFont();         //调用其成员函数initWithString创建图字         if(pRet && pRet->initWithString(str, fntFile))         {             //交由内存管理器进行内存管理。             pRet->autorelease();             return pRet;         }         CC_SAFE_DELETE(pRet)         return NULL;     }     //由一个字符串和字体fnt文件创建图字     bool CCLabelBMFont::initWithString(const char *theString, const char *fntFile)     {           //有效性判断         CCAssert(theString != NULL, \"\");         CC_SAFE_RELEASE(m_pConfiguration);// allow re-init         //调用FNTConfigLoadFile读取Fnt文件并返回出信息的内存地址给指针变量m_pConfiguration         m_pConfiguration = FNTConfigLoadFile(fntFile);         //用到它就给它的引用计数器加1         m_pConfiguration->retain();         //有效性判断         CCAssert( m_pConfiguration, \"Error creating config for LabelBMFont\");         //由信息指针取得字体图和字符串长度来初始化图块集管理器。         if (CCSpriteBatchNode::initWithFile(m_pConfiguration->m_sAtlasName.c_str(), strlen(theString)))         {             //如果成功，容量设为255             m_cOpacity = 255;             //使用白色             m_tColor = ccWHITE;             //m_tContentSize是CCNode中变量，为结点原始大小，不受矩阵变换影响，这里初始化为零大小             m_tContentSize = CCSizeZero;             //如果纹理有Alpha通道，则使用透明度设置RGB值。             m_bIsOpacityModifyRGB = m_pobTextureAtlas->getTexture()->getHasPremultipliedAlpha();             //设置锚点在正中心             setAnchorPoint(ccp(0.5f, 0.5f));             //设置字符串             this->setString(theString);             return true;         }         return false;     }     //析构函数     CCLabelBMFont::~CCLabelBMFont()     {         //释放字符串容器，释放         m_sString.clear();         CC_SAFE_RELEASE(m_pConfiguration);     }     // 由参1和参2组成key从哈希表中找到元素的数量。     int CCLabelBMFont::kerningAmountForFirst(unsigned short first, unsigned short second)     {         int ret = 0;         //将两个字合并为双字做为key来进行哈希表查找         unsigned int key = (first<<16) | (second & 0xffff);         //如果Fnt信息中有字距调整信息         if( m_pConfiguration->m_pKerningDictionary ) {             //使用哈希算法找到对应的字距信息值             tKerningHashElement *element = NULL;             HASH_FIND_INT(m_pConfiguration->m_pKerningDictionary, &key, element);                   //如果找到返回             if(element)                 ret = element->amount;         }         return ret;     }     //计算Char对应的UTF8码的掩码和长度     #define UTF8_COMPUTE(Char, Mask, Len)       \\       if (Char < 128)               \\         {                       \\           Len = 1;                  \\           Mask = 0x7f;              \\         }                       \\       else if ((Char & 0xe0) == 0xc0)       \\         {                       \\           Len = 2;                  \\           Mask = 0x1f;              \\         }                       \\       else if ((Char & 0xf0) == 0xe0)       \\         {                       \\           Len = 3;                  \\           Mask = 0x0f;              \\         }                       \\       else if ((Char & 0xf8) == 0xf0)       \\         {                       \\           Len = 4;                  \\           Mask = 0x07;              \\         }                       \\       else if ((Char & 0xfc) == 0xf8)       \\         {                       \\           Len = 5;                  \\           Mask = 0x03;              \\         }                       \\       else if ((Char & 0xfe) == 0xfc)       \\         {                       \\           Len = 6;                  \\           Mask = 0x01;              \\         }                       \\       else                      \\         Len = -1;     //计算Char对应的UTF8码的长度     #define UTF8_LENGTH(Char)           \\       ((Char) < 0x80 ? 1 :              \\        ((Char) < 0x800 ? 2 :            \\         ((Char) < 0x10000 ? 3 :         \\          ((Char) < 0x200000 ? 4 :           \\           ((Char) < 0x4000000 ? 5 : 6)))))     //取得Char对应的UTF8码     #define UTF8_GET(Result, Chars, Count, Mask, Len)   \\       (Result) = (Chars)[0] & (Mask);           \\       for ((Count) = 1; (Count) < (Len); ++(Count))     \\         {                           \\           if (((Chars)[(Count)] & 0xc0) != 0x80)        \\         {                       \\           (Result) = -1;                \\           break;                    \\         }                       \\           (Result) <<= 6;                   \\           (Result) |= ((Chars)[(Count)] & 0x3f);        \\         }     //判断Char是否是有效的Unicode码     #define UNICODE_VALID(Char)         \\       ((Char) < 0x110000 &&             \\        (((Char) & 0xFFFFF800) != 0xD800) &&     \\        ((Char) < 0xFDD0 || (Char) > 0xFDEF) &&  \\        ((Char) & 0xFFFE) != 0xFFFE)     //用于获取UTF8下个字符的编码偏移。     static const char utf8_skip_data[256] = {       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,       1, 1, 1, 1, 1, 1, 1,       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,       1, 1, 1, 1, 1, 1, 1,       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,       1, 1, 1, 1, 1, 1, 1,       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,       1, 1, 1, 1, 1, 1, 1,       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,       1, 1, 1, 1, 1, 1, 1,       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,       1, 1, 1, 1, 1, 1, 1,       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,       2, 2, 2, 2, 2, 2, 2,       3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5,       5, 5, 5, 6, 6, 1, 1     };     static const char *const g_utf8_skip = utf8_skip_data;     //取得UTP8编码字符的下一个字符。     #define cc_utf8_next_char(p) (char *)((p) + g_utf8_skip[*(unsigned char *)(p)])    //返回取得字符串转换为UTF8后的字符长度     static long     cc_utf8_strlen (const char * p, int max)     {       long len = 0;       const char *start = p;       if (!(p != NULL || max == 0))       {           return 0;       }       if (max < 0)         {           while (*p)         {           p = cc_utf8_next_char (p);           ++len;         }         }       else         {           if (max == 0 || !*p)         return 0;           p = cc_utf8_next_char (p);           while (p - start < max && *p)         {           ++len;           p = cc_utf8_next_char (p);         }           /* only do the last len increment if we got a complete            * char (don't count partial chars)            */           if (p - start == max)         ++len;         }       return len;     }     //将Unicode编码字符串p转换为UTF8编码     static unsigned int     cc_utf8_get_char (const char * p)     {       int i, mask = 0, len;       unsigned int result;       unsigned char c = (unsigned char) *p;       UTF8_COMPUTE (c, mask, len);       if (len == -1)         return (unsigned int) - 1;       UTF8_GET (result, p, i, mask, len);       return result;     }     //重点函数：由字符串和字编码纹理块对应信息设置到     void CCLabelBMFont::createFontChars()     {         int nextFontPositionX = 0;  //下一个字的横向绘制位置        int nextFontPositionY = 0;   //下一个字的纵向绘制位置         unsigned short prev = -1;   //上一个字编码         int kerningAmount = 0;      //字间距调整的像素数量         CCSize tmpSize = CCSizeZero;//         int longestLine = 0;        // 最长的一行的宽度         unsigned int totalHeight = 0;//字符串的总高度         unsigned int quantityOfLines = 1;          //如果字符串长度为零直接返回         if (0 == m_sString.length())         {             return;         }          //取得字符串转换为UTF8后的字符长度         int utf8len = cc_utf8_strlen(m_sString.c_str(), -1);         if (utf8len == 0)         {             return;         }         //将字符串转换为UTF8的字符串         unsigned short* pUniStr = new unsigned short[utf8len+1];         pUniStr[utf8len] = 0;         const char* p = m_sString.c_str();         for (int i = 0; i < utf8len; ++i)         {             pUniStr[i] = cc_utf8_get_char(p);             p = cc_utf8_next_char (p);         }         unsigned int stringLen = cc_wcslen(pUniStr);         //统计行数         for (unsigned int i = 0; i < stringLen - 1; ++i)         {             unsigned short c = pUniStr[i];             if (c == '\\n')             {                 quantityOfLines++;             }         }         //由行高乘行数最得要显示的字符串占用的总高度         totalHeight = m_pConfiguration->m_uCommonHeight * quantityOfLines;         //统计字符串的起始位置高度         nextFontPositionY = -(m_pConfiguration->m_uCommonHeight - m_pConfiguration->m_uCommonHeight * quantityOfLines);         //遍历所有的字         for (unsigned int i= 0; i < stringLen; i++)         {             unsigned short c = pUniStr[i];             if (c == '\\n')             {                   //如果遇到换行符则进行换行处理                 nextFontPositionX = 0;                 nextFontPositionY -= m_pConfiguration->m_uCommonHeight;                 continue;             }             //查找是当前字的纹理映射信息结点             std::map<unsigned int, ccBMFontDef>::iterator it = m_pConfiguration->m_pBitmapFontArray->find(c);             CCAssert(it != m_pConfiguration->m_pBitmapFontArray->end(), \"LabelBMFont: character is not supported\");             //根据上一个字与当前字进行间距调整信息哈希表的查找，返回调整的像素偏移量。             kerningAmount = this->kerningAmountForFirst(prev, c);             //取得当前字的纹理映射信息结点             const ccBMFontDef& fontDef = (*(m_pConfiguration->m_pBitmapFontArray))[c];             //取得当前字在贴图上的像素矩形             CCRect rect = fontDef.rect;             //取得对应当前字的精灵             CCSprite *fontChar;             fontChar = (CCSprite*)(this->getChildByTag(i));                         if( ! fontChar )             {                 //如果找不到，则新建精灵，并将纹理上对应像素块信息传给精灵进行初始化。                 fontChar = new CCSprite();                 fontChar->initWithBatchNodeRectInPixels(this, rect);                 //将精灵加入到子结点，设置i为附带查找唯一ID                 this->addChild(fontChar, 0, i);                 fontChar->release();             }             else             {                 // 将纹理上对应像素块信息传给精灵。                                 fontChar->setTextureRectInPixels(rect, false, rect.size);                 //设置其显示，完全不透明。                 fontChar->setIsVisible(true);                 fontChar->setOpacity(255);             }             //设置字的纵向偏移            float yOffset = (float)(m_pConfiguration->m_uCommonHeight) - fontDef.yOffset;             //计算字的位置,注意：因为锚点设的精灵正中心，所以位置应该是左下角位置加上大小的一半再进行相关偏移和间距调整计算。             fontChar->setPositionInPixels( ccp( nextFontPositionX + fontDef.xOffset + fontDef.rect.size.width / 2.0f + kerningAmount,                                                 (float) nextFontPositionY + yOffset - rect.size.height/2.0f ) );                    //      NSLog(@\"position.y: %f\", fontChar.position.y);             // 更新绘制下一个字的横向位置             nextFontPositionX += (*(m_pConfiguration->m_pBitmapFontArray))[c].xAdvance + kerningAmount;             //更新上一个字符供循环再次使用             prev = c;             // 设置是否用透明度设置色彩                                             fontChar->setIsOpacityModifyRGB(m_bIsOpacityModifyRGB);             //设置色彩，             fontChar->setColor(m_tColor);             //如果透明度小于255，设置透明度             if( m_cOpacity != 255 )             {                 fontChar->setOpacity(m_cOpacity);             }             //取得最长的一行的宽度             if (longestLine < nextFontPositionX)             {                 longestLine = nextFontPositionX;             }         }         //设置当前字符串在屏幕上占用的矩形位置          tmpSize.width  = (float) longestLine;         tmpSize.height = (float) totalHeight;         //调用基类CCNode的函数设置为原始大小         this->setContentSizeInPixels(tmpSize);         //释放字符串         CC_SAFE_DELETE_ARRAY(pUniStr);     }     //LabelBMFont重载基类 CCLabelProtocol的接口函数     //设置字符串     void CCLabelBMFont::setString(const char *newString)     {           //将newString保存入字符串成员变量m_sString         m_sString.clear();         m_sString = newString;         //因CCLabelBMFont派生于CCSpriteBatchNode，m_pChildren为其子节点数组，这里进行遍历将其所有显示中的字精灵都设为不显示         if (m_pChildren && m_pChildren->count() != 0)         {             CCObject* child;             CCARRAY_FOREACH(m_pChildren, child)             {                 CCNode* pNode = (CCNode*) child;                 if (pNode)                 {                     pNode->setIsVisible(false);                 }             }         }         //重新由字符串和字体信息创建要显示的字精灵         this->createFontChars();     }     //取得字符串     const char* CCLabelBMFont::getString(void)     {         return m_sString.c_str();     }     // setString别名函数     void CCLabelBMFont::setCString(const char *label)     {         setString(label);     }     //LabelBMFont 重载基类 CCRGBAProtocol 的接口函数     //设置颜色     void CCLabelBMFont::setColor(const ccColor3B& var)     {         m_tColor = var;         //因CCLabelBMFont派生于CCSpriteBatchNode，m_pChildren为其子节点数组，这里进行遍历设置         if (m_pChildren && m_pChildren->count() != 0)         {             CCObject* child;             CCARRAY_FOREACH(m_pChildren, child)             {                 CCSprite* pNode = (CCSprite*) child;                 if (pNode)                 {                     pNode->setColor(m_tColor);                 }             }         }     }     //取得颜色     const ccColor3B& CCLabelBMFont::getColor()     {         return m_tColor;     }     //设置透明度     void CCLabelBMFont::setOpacity(GLubyte var)     {         m_cOpacity = var;         if (m_pChildren && m_pChildren->count() != 0)         {             CCObject* child;             CCARRAY_FOREACH(m_pChildren, child)             {                 CCNode* pNode = (CCNode*) child;                 if (pNode)                 {                     CCRGBAProtocol *pRGBAProtocol = dynamic_cast<CCRGBAProtocol*>(pNode);                     if (pRGBAProtocol)                     {                         pRGBAProtocol->setOpacity(m_cOpacity);                     }                 }             }         }     }     //取得透明度     GLubyte CCLabelBMFont::getOpacity()     {         return m_cOpacity;     }     //设置是否使用透明度设置RGB值     void CCLabelBMFont::setIsOpacityModifyRGB(bool var)     {         m_bIsOpacityModifyRGB = var;         if (m_pChildren && m_pChildren->count() != 0)         {             CCObject* child;             CCARRAY_FOREACH(m_pChildren, child)             {                 CCNode* pNode = (CCNode*) child;                 if (pNode)                 {                       //因子结点即是精灵CCSprite，CCSprite又派生于CCRGBAProtocol，故进行转换                     CCRGBAProtocol *pRGBAProtocol = dynamic_cast<CCRGBAProtocol*>(pNode);                     if (pRGBAProtocol)                     {                      //调用setIsOpacityModifyRGB进行设置 pRGBAProtocol->setIsOpacityModifyRGB(m_bIsOpacityModifyRGB);                     }                 }             }         }     }     //取得是否使用透明度设置RGB值     bool CCLabelBMFont::getIsOpacityModifyRGB()     {         return m_bIsOpacityModifyRGB;     }     // 设置锚点     void CCLabelBMFont::setAnchorPoint(const CCPoint& point)     {         if( ! CCPoint::CCPointEqualToPoint(point, m_tAnchorPoint) )         {             CCSpriteBatchNode::setAnchorPoint(point);             this->createFontChars();         }     }     //绘制图字标签,Debug模式下手动调用绘制 #if CC_LABELBMFONT_DEBUG_DRAW     void CCLabelBMFont::draw()     {         //绘制图块集         CCSpriteBatchNode::draw();         //绘制边框         const CCSize& s = this->getContentSize();         CCPoint vertices[4]={             ccp(0,0),ccp(s.width,0),             ccp(s.width,s.height),ccp(0,s.height),         };         ccDrawPoly(vertices, 4, true);     } #endif // CC_LABELBMFONT_DEBUG_DRAW }   照例做个总结： 1． 图字的原理：将所要绘制的字绘制到图片上，通过编码取得对应的矩形块UV进行顶点缓冲的设置之后进行绘制。Cocos2d-x提供的两个类非常重要：(1) CCTextureAtlas(2) CCSpriteBatchNode。 2． 图字的组成：一张纹理，一个纹理描述信息文件。缺一不可。要做好图字，必须深入理解图字纹理描述信息文件的格式,可能看Cocos2d-x提供的类: CCBMFontConfiguration，并掌握图字工具的使用。 呃，网上提供了一些图字工具，比较常用的有 Hiero:       1.所有文本框必须实现CCLabelProtocol接口   2.CCLableTTF比另外两个文本框渲染慢 TTF（TrueTypeFont）是一种字库名称，是Apple公司和Microsoft公司共同推出的字体文件格式,随着windows的流行，已经变成最常用的一种字体文件表示方式。            CCLabelTTF 每次调用 setString （即改变文字）的时候，一个新的OpenGL纹理将会被创建.。这意味着setString 和创建一个新的标签一样慢。            所以，当你需要频繁的更新它们的时候，尽可能的不用去使用标签对象。  而应该使用CCLabelAtlas或者是CCLabelBMFont  OK， 看下它的使用方法  CCLabelTTF *label = CCLabelTTF::labelWithString(\"the string\", \"Marker Felt\", 21); this->addChild(label);  label->setPosition(ccp(100, 100));  label->setString(\"change string\");//修改文字的方法  这个类使用的是系统中的字体，不需要额外往项目文件中添加字体文件。但如果你有自定义的字体也可以加到项目中，如果无法使用，可以查看一下ccConfig.h中的CC_FONT_LABEL_SUPPORT是否enable了。       3.CCLabelBMFont中每个文字相当于一个CCSprite，可以旋转，移动，改变尺寸等 CCLabelBMFont  相当于每次改变只改变了图片坐标，而CCLabelTTF要重新渲染.这个类使用之前，需要添加好字体文件，包括一个图片文件 (**.png) 和一个 字体坐标文件 （**.fnt）。 在 cocos2d-x的示例项目中有现成的，可以先拿过来练习一下，找的时候注意两个文件的名称是相同的，只是扩展名不同。 CCLabelIBMFont *label = CCLabelIBMFont::labelWithString(\"the string\", \"font-hd.png\"); this->addChild(label); label->setPosition(ccp(100, 100)); label->setString(\"change string\");   下面是 font-hd.png文件的截图  font-hd.fnt文件定义了 图像文件的名称，以及每个字符对应的位置信息。  这个没办法指定字体的字号，但可以用scale属性进行缩放来调整大小。就当它是sprite,可以简单的实现很炫的文字的动画效果。   4.CCLabelAtlas         如果你用cocos2d-x项目模板创建过项目，那么你已经看过它的效果了，就是左下角显示帧率的数字。 因为帧率一直在变，使用CCLabelTTF的话效率太低，因为只是数字所以也犯不上使用 CCLabelBMFont 加载那么大的文字图像，所以使用这个比较合适。 CCLabelAtlas *label = CCLabelAtlas::labelWithString(\"12\", \"fps_images.png\", 12, 18, \".\"); this->addChild(label); label->setPosition(ccp(100, 100)); label->setString(\"34\");  在项目文件中，在resourse group里你可以找一下一个叫 fps_images.png的这个图像文件，文件如下：                所以，这个只能显示上面这个12个字符，abcd什么的就不行了。        解释一下参数，        12 就是字符，        fps_images.png就是字符的图像文件（这个只要图像文件就可以了），        12 是每个字符的宽度，        18 是每个字符的高度，这个不能设错，否则显示的时候可能就不对了。        最后一个是起始字符，它是使用这个其实字符来对应字符和图像关系的 5.下面具体分析一下画字的原理（参考一篇博客） 图字，顾名思义，利用图片做为纹理来显示的文字。当下流行的跨平台2D引擎Cocos2d-x和LibGdx也都有对于图字的应用支持，今天我就来为大家讲一讲图字。   首先要介绍一下，图字是怎么来的？其实这个很早很早了，记得80后在95年开始玩DOS下的仙剑奇侠传的时候，那些令人难忘的中文对话吧！DOS下做游戏，使用的是C语言，不要说写字了，很多复杂的操作甚至涉及驱动。那时候绘图就是利用将图片中的像素取出来后绘制在屏幕上，所以处理游戏中的中文，就只有把这些文字的像素预先写到BMP或二进制文件中，然后读取出来再设置屏幕像素以实现。后来进入DDRAW的时代，可以使用WINDOWS系统中的字库来写字了。把DDRAW的后台表面进行LOCK，取出其DC，然后用GDI将文字写到其DC上，这种做法后面也延续了很久，但GDI进行TextOut的效率非常慢，你要是想像梦幻西游一样满屏写了，那得卡死，解决方案是什么？还是图字。专业的游戏开发者会将所用到的字都预处理生成到一张图片中，通过一个编码与纹理UV对应文件来进行纹理UV的获取后做为顶点的UV值然后进行绘制，有也的在每一帧中实时的将需要的字使用DDRAW写字的方法绘制到相应的纹理上然后使用文字编码与纹理UV对应信息来进行绘制，这样效率就提高很多了。目前比较流行的做法是使用一张png图片来存储用到的文字。一个.fnt文件来存储文字图片说明信息。Cocos2d-x和LibGdx中都集成了相关的图字处理类。在世界范围内，也有很多游戏使用了这个方案。在游戏汉化界，了解和掌握图字的原理和修改方法也是很重要的一项工作 我们以Cocos2d-x的tests工程中的LabelTest中的最后一个Label显示“中国”为例来分析一下。 打开Cocos2d-x所在目录下的tests\\Resources\\fonts目录，找到bitmapFontChinese.png(文字贴图文件)和bitmapFontChinese.fnt(文字图片说明信息文件) 先打开png，我们可以看到它是512×512大小，上面由12行，14列个文字组成。包括有一些汉字，常用字符，数字和字母。它的每个字都是由青色到蓝色的向下渐变。 再用UEdit或记事本打开bitmapFontChinese.fnt,可以看到它的构成,我在这里讲一下。 第一行是对字体的介绍。   1 info face=\"华康海报体W12(P)\" size=32 bold=0italic=0 charset=\"\" unicode=0stretchH=100smooth=1 aa=1 padding=0,0,0,0 spacing=1,1   解释： face=”华康海报体W12(P)”:字体为”华康海报体W12(P)”, size=32:大小为32像素 bold=0 :不加粗 italic=0:不使用斜体 charset=”\": charset是编码字符集，这里没有填写值即使用默认， unicode=0:不使用Unicode stretchH=100:纵向缩放百分比 smooth=1 :开启平滑 aa=1:开启抗锯齿 padding=0,0,0,0:内边距，文字与边框的空隙。 spacing=1,1 :外边距，就是相临边缘的距离。 第二行是对应所有字贴图的公共信息   1 common lineHeight=37 base=28 scaleW=512 scaleH=512pages=1 packed=0   解释： lineHeight=37：行高，如果遇到换行符时，绘制字的位置坐标的Y值在换行后增加的像素值。 base=28 :字的基本大小 scaleW=512 :图片大小 scaleH=512:图片大小 pages=1 :此种字体共用到几张图。 packed=0:图片不压缩 第三行是对应当前字贴图的信息 //第一页，文件名称是”bitmapFontChinese.png” page id=0 file=”bitmapFontChinese.png” 第四行是当前贴图中所容纳的文字数量 chars count=204 第五行起把当前贴图中所用到的所有文字的编码以及对应在图片上的矩形位置，偏移等列出来 第一个字符编码为32,也就是空格，位置为0,0,宽高为0,0, 绘制到屏幕的相应位置时，像素偏移（0，28），绘制完后相应位置的x往后移15像素再画下一个字符，字的图块在第1页上 char id=32 x=0 y=0 width=0 height=0 xoffset=0 yoffset=28 xadvance=15 page=0 chnl=0 第一个字符编码为汉字”象”,也就是空格，位置为0,0,宽为33,高为36, 绘制到屏幕的相应位置时，像素偏移（0，-1），绘制完后相应位置的x往后移36像素再画下一个字，字的图块在第1页上 char id=35937 x=0 y=0 width=33 height=36 xoffset=0 yoffset=-1 xadvance=36 page=0 chnl=0 char id=26696 x=33 y=0 width=35 height=36 xoffset=-1 yoffset=-1 xadvance=36 page=0 chnl=0 char id=26071 x=68 y=0 width=35 height=36 xoffset=-1 yoffset=-1 xadvance=36 page=0 chnl=0 … 再后面是描述两个字在进行组合绘制时字距调整的相关信息，这里没有要进行间距调整的字组合所以为设-1。对于字组合间距调整可以看此示例图： kernings count=-1 这个数字代表参与字组合间距调整的字的数量。 如果kernings count大于零，后面会有类似这样的描述： kerning first=102 second=41 amount=2 也就是’f’与’)’进行组合显示’f)’时，’)’向右移2像素防止粘在一起。 通过上面这些信息，引擎可以通过编码找到相应的文字并取出对应的纹理块。 //Cocos2d-x中LabelBMFontChinese 下面我们来分析一下Cocos2d-x的tests工程中的LabelTest中的最后一个Label，它的类名为CCLabelBMFont.转到其类定义文件CCLabelBMFont.h   1 class CC_DLL CCLabelBMFont : public CCSpriteBatchNode, public CCLabelProtocol, public CCRGBAProtocol   可以看到其直接派生于三个类，分别是 CCSpriteBatchNode :精灵批次管理类，用于将使用一张图的多个精灵在设置一次纹理的批次里进行绘制，提高渲染的效率。 CCLabelProtocol :文字字串类 CCRGBAProtocol:颜色调节接口类 由简入深，我们先来看一下CCRGBAProtocol，打开CCProtocols.h   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class CC_DLL CCRGBAProtocol { public:     //设置颜色     virtual void setColor(const ccColor3B& color) = 0;     //取得颜色     virtual const ccColor3B& getColor(void) = 0;     //返回透明度     virtual GLubyte getOpacity(void) = 0;     //设置透明度     virtual void setOpacity(GLubyte opacity) = 0;     //设置是否使用Alpha值设置RGB，如果     virtual void setIsOpacityModifyRGB(bool bValue) = 0;     //取得是否使用Alpha值设置RGB     virtual bool getIsOpacityModifyRGB(void) = 0; };   可以看到CCRGBAProtocol类是个纯虚类，只是定义了一些设置获取颜色信息的接口函数。 继续看CCLabelProtocal，明显的，它也是纯虚类，做为存储字符串的接口使用:   1 2 3 4 5 6 7 8 9 class CC_DLL CCLabelProtocol { public:     // 设置文字标签显示的字符串     virtual void setString(const char *label) = 0;     // 返回文字标签显示的字符串     virtual const char* getString(void) = 0; };   最后来分析CCSpriteBatchNode类。它由CCNodet 和 CCTextureProtocal两个类派生而来，CCNode是基础结点类，用于将引擎中所有具有逻辑顺序和父子关系的类组织起来，基于CCNode派生的类均可以互相挂接。CCNode不是本章要详细介绍的内容，就不再详细分析了，看一下CCTextureProtocol，这是一个纹理使用接口类:   1 2 3 4 5 6 7 8 9 class CC_DLL CCTextureProtocol : public CCBlendProtocol { public:     // 返回所使用的2D纹理     virtual CCTexture2D* getTexture(void) = 0;     // 设置使用的2D纹理，并为纹理的使用计数器加1操作     virtual void setTexture(CCTexture2D *texture) = 0; };   很简单，只有两个函数对纹理进行设置和获取，它派生于CCBlendProtocal,这是一个Alpha混合系数设置接口类，用于在开启Alpha混合状态后对Alpha混合的系数进行设置。再来看一下CCBlendProtocal,这是一个混合状态设置接口类:   1 2 3 4 5 6 7 8 9 class CC_DLL CCBlendProtocol { public:     // 为纹理设置使用的混合状态     virtual void setBlendFunc(ccBlendFunc blendFunc) = 0;     // 返回为纹理设置的混合状态     virtual ccBlendFunc getBlendFunc(void) = 0; };   返回到类CCSpriteBatchNode的定义。我们再来分析CCSpriteBatchNode。之前说了CCSpriteBatchNode是精灵批次管理类，用于将使用一张图的多个精灵在设置一次纹理的批次里进行绘制，提高渲染的效率。既然多个精灵使用一张图，则需要将多个小图块合并在一张图上，这样只要设置使用大图做为纹理，将使用各小图块做为纹理贴图的精灵设置好顶点与UV等数据，就可以绘制出这些精灵了。Cocos2d-x提供了一个类CCTextureAtlas对使用图块的这些精灵所使用的顶点缓冲区进行管理。为了更好的理解CCSpriteBatchNode,我们看一下它的定义和实现：   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 #ifndef __CCTEXTURE_ATLAS_H__ #define __CCTEXTURE_ATLAS_H__ //用到的头文件 #include <string> #include \"ccTypes.h\" #include \"CCObject.h\" #include \"ccConfig.h\" //使用Cocos2d命名空间 namespace   cocos2d { class CCTexture2D; //CCTextureAtlas由CCObject派生而来 class CC_DLL CCTextureAtlas : public CCObject { protected:     //使用此大图中的图块的精灵对应的三角形索引数组的指针     GLushort            *m_pIndices; #if CC_USES_VBO     //如果使用Vertex Buffer Object(VBO:使用显存而非内存存储顶点缓冲数据，大大提高效率)，建立VBO句柄数组，第一个元素存顶点数组的句柄，第二个元素存索引数组句柄     GLuint              m_pBuffersVBO[2];     //标记是否更新需要更新的图块信息。当你新加入了图块或者修改了图块，需要设置为true。     bool                m_bDirty; #endif // CC_USES_VBO // CC_PROPERTY_READONLY宏为类定义变量及增加相应的get函数。     //当前使用图块的数量     CC_PROPERTY_READONLY(unsigned int, m_uTotalQuads, TotalQuads)     //存储图块信息的数组容量     CC_PROPERTY_READONLY(unsigned int, m_uCapacity, Capacity)     //设置所使用的大图纹理     CC_PROPERTY(CCTexture2D *, m_pTexture, Texture)     //使用此大图的图块的所有精灵的顶点缓冲信息数组     CC_PROPERTY(ccV3F_C4B_T2F_Quad *, m_pQuads, Quads) public:     //构造     CCTextureAtlas();     //析构     virtual ~CCTextureAtlas();     //描述     char * description();     //静态函数：从文件中创建纹理，并初始化图块容量     static CCTextureAtlas * textureAtlasWithFile(const char* file , unsigned int capacity);     //同上，只是非静态函数。作者提示不能重复调用，否则会造成内存泄漏。     bool initWithFile(const char* file, unsigned int capacity);     //静态函数：从贴图中创建纹理，并初始化图块容量     static CCTextureAtlas * textureAtlasWithTexture(CCTexture2D *texture, unsigned int capacity);     //同上，只是非静态函数。作者提示不能重复调用，否则会造成内存泄漏。     bool initWithTexture(CCTexture2D *texture, unsigned int capacity);     //通过索引值找到对应的图块顶点缓冲数据并用新数据修改它，由CCSprite实例对象在变换顶点信息时调用。     void updateQuad(ccV3F_C4B_T2F_Quad* quad, unsigned int index);     //通过索引值找到对应的图块顶点缓冲数据，并在其之前插入一个新的图块。     void insertQuad(ccV3F_C4B_T2F_Quad* quad, unsigned int index);     //通过索引值找到对应的图块顶点缓冲数据，并把它插入另一个图块之前。     void insertQuadFromIndex(unsigned int fromIndex, unsigned int newIndex);     //移除指定位置的图块顶点缓冲数据.     void removeQuadAtIndex(unsigned int index);     //清空所有的图块顶点缓冲数据。     void removeAllQuads();     //重新设置图块顶点缓冲数组的容量     bool resizeCapacity(unsigned int n);     //绘制指定的图块顶点缓冲     void drawNumberOfQuads(unsigned int n);     //绘制从指定的图块起后面的N个图块     void drawNumberOfQuads(unsigned int n, unsigned int start);     //绘制所有的图块顶点缓冲     void drawQuads(); private:     //初始化索引缓冲数据     void initIndices(); }; }//namespace   cocos2d #endif //__CCTEXTURE_ATLAS_H__   再看CPP:   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 #include \"CCTextureAtlas.h\" #include \"CCTextureCache.h\" #include \"ccMacros.h\" // 纹理头文件 #include \"CCTexture2D.h\" #include <stdlib.h> //使用Cocos2d命名空间 namespace   cocos2d { //构造,初始化成员变量 CCTextureAtlas::CCTextureAtlas()     :m_pIndices(NULL) #if CC_USES_VBO     , m_bDirty(false) #endif     ,m_pTexture(NULL)     ,m_pQuads(NULL) {} //析构，释放所用的内存 CCTextureAtlas::~CCTextureAtlas() { //  CCLOGINFO(\"cocos2d: deallocing CCTextureAtlas.\");     CC_SAFE_FREE(m_pQuads)     CC_SAFE_FREE(m_pIndices) #if CC_USES_VBO     //释放缓冲区对象     glDeleteBuffers(2, m_pBuffersVBO); #endif // CC_USES_VBO     CC_SAFE_RELEASE(m_pTexture); } //实现通过宏CC_PROPERTY_READONLY声明的函数 //取得当前使用的图块的数量 unsigned int CCTextureAtlas::getTotalQuads() {     return m_uTotalQuads; } //取得图块集的容量 unsigned int CCTextureAtlas::getCapacity() {     return m_uCapacity; } //取得大纹理 CCTexture2D* CCTextureAtlas::getTexture() {     return m_pTexture; } //设置大纹理 void CCTextureAtlas::setTexture(CCTexture2D * var) {     CC_SAFE_RETAIN(var);     CC_SAFE_RELEASE(m_pTexture);     m_pTexture = var; } //取得使用此大图的图块的所有精灵的顶点缓冲信息数组 ccV3F_C4B_T2F_Quad* CCTextureAtlas::getQuads() {     return m_pQuads; } //设置使用此大图的图块的所有精灵的顶点缓冲信息数组 void CCTextureAtlas::setQuads(ccV3F_C4B_T2F_Quad *var) {     m_pQuads = var; } //静态函数：从文件中创建纹理，并初始化图块容量 CCTextureAtlas * CCTextureAtlas::textureAtlasWithFile(const char* file, unsigned int capacity) {     //使用new来实例化一个CCTextureAtlas对象     CCTextureAtlas * pTextureAtlas = new CCTextureAtlas();     //调用成员函数进行初始化     if(pTextureAtlas && pTextureAtlas->initWithFile(file, capacity))     {         pTextureAtlas->autorelease();         return pTextureAtlas;     }     //如果失败，释放后返回NULL     CC_SAFE_DELETE(pTextureAtlas);     return NULL; } //静态函数：从贴图中创建纹理，并初始化图块容量 CCTextureAtlas * CCTextureAtlas::textureAtlasWithTexture(CCTexture2D *texture, unsigned int capacity) {     //使用new来实例化一个CCTextureAtlas对象     CCTextureAtlas * pTextureAtlas = new CCTextureAtlas();     //调用成员函数进行初始化     if (pTextureAtlas && pTextureAtlas->initWithTexture(texture, capacity))     {         pTextureAtlas->autorelease();         return pTextureAtlas;     }     //如果失败，释放后返回NULL     CC_SAFE_DELETE(pTextureAtlas);     return NULL; } //非静态函数，从文件中创建纹理，并初始化图块容量 bool CCTextureAtlas::initWithFile(const char * file, unsigned int capacity) {     // 由纹理管理器加载一个图片文件，返回生成的纹理     CCTexture2D *texture = CCTextureCache::sharedTextureCache()->addImage(file);     //判断生成纹理是否有效     if (texture)     {           //如果成功，使用纹理进行初始化         return initWithTexture(texture, capacity);     }     else     {         //不成功打印错误日志并返回NULL         CCLOG(\"cocos2d: Could not open file: %s\", file);         delete this;         return NULL;     } } //非静态函数，设置纹理，并初始化图块容量 bool CCTextureAtlas::initWithTexture(CCTexture2D *texture, unsigned int capacity) {     //纹理有效性判断，防止重复调用     CCAssert(texture != NULL, \"texture should not be null\");     //设置图块容量     m_uCapacity = capacity;     m_uTotalQuads = 0;     // 设置纹理     this->m_pTexture = texture;     CC_SAFE_RETAIN(m_pTexture);     // 判断是否重复调用     CCAssert(m_pQuads == NULL && m_pIndices == NULL, \"\");     //申请容量大小的的顶点缓冲信息数组     m_pQuads = (ccV3F_C4B_T2F_Quad*)calloc( sizeof(ccV3F_C4B_T2F_Quad) * m_uCapacity, 1 );      //申请容量大小的索引缓冲数组     m_pIndices = (GLushort *)calloc( sizeof(GLushort) * m_uCapacity * 6, 1 );     //如果失败，做相应处理     if( ! ( m_pQuads && m_pIndices) && m_uCapacity > 0) {         //CCLOG(\"cocos2d: CCTextureAtlas: not enough memory\");         CC_SAFE_FREE(m_pQuads)         CC_SAFE_FREE(m_pIndices)         CC_SAFE_RELEASE_NULL(m_pTexture);         return false;     } //初始化缓冲区对象 #if CC_USES_VBO     glGenBuffers(2, &m_pBuffersVBO[0]);     m_bDirty = true; #endif // CC_USES_VBO //初始化索引缓冲     this->initIndices();     return true; } //取得描述 char * CCTextureAtlas::description() {     char *ret = new char[100];     sprintf(ret, \"<CCTextureAtlas | totalQuads = %u>\", m_uTotalQuads);     return ret; } //初始化索引缓冲 void CCTextureAtlas::initIndices() {     //如果容量为0直接返回     if (m_uCapacity == 0)         return;     //按照顶点的顺序和使用的三角形渲染排列方式为索引缓冲填充数据。     for( unsigned int i=0; i < m_uCapacity; i++)     { #if CC_TEXTURE_ATLAS_USE_TRIANGLE_STRIP         m_pIndices[i*6+0] = i*4+0;         m_pIndices[i*6+1] = i*4+0;         m_pIndices[i*6+2] = i*4+2;              m_pIndices[i*6+3] = i*4+1;         m_pIndices[i*6+4] = i*4+3;         m_pIndices[i*6+5] = i*4+3; #else         m_pIndices[i*6+0] = (GLushort)(i*4+0);         m_pIndices[i*6+1] = (GLushort)(i*4+1);         m_pIndices[i*6+2] = (GLushort)(i*4+2);         // inverted index. issue #179         m_pIndices[i*6+3] = (GLushort)(i*4+3);         m_pIndices[i*6+4] = (GLushort)(i*4+2);         m_pIndices[i*6+5] = (GLushort)(i*4+1);              //      m_pIndices[i*6+3] = i*4+2;         //      m_pIndices[i*6+4] = i*4+3;         //      m_pIndices[i*6+5] = i*4+1;  #endif      } #if CC_USES_VBO     //指定m_pBuffersVBO[0]为顶点缓冲区，并激活缓冲区     glBindBuffer(GL_ARRAY_BUFFER, m_pBuffersVBO[0]);     //绑定完成后为其分配内存     glBufferData(GL_ARRAY_BUFFER, sizeof(m_pQuads[0]) * m_uCapacity, m_pQuads, GL_DYNAMIC_DRAW);     //指定m_pBuffersVBO[1]为索引缓冲区，并激活缓冲区     glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_pBuffersVBO[1]);     //绑定完成后为其分配内存      glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(m_pIndices[0]) * m_uCapacity * 6, m_pIndices, GL_STATIC_DRAW);     //取消绑定     glBindBuffer(GL_ARRAY_BUFFER, 0);     glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0); #endif // CC_USES_VBO } //通过索引值找到对应图块的顶点缓冲并用新数据修改它 void CCTextureAtlas::updateQuad(ccV3F_C4B_T2F_Quad *quad, unsigned int index) {     //有效性判断     CCAssert( index >= 0 && index < m_uCapacity, \"updateQuadWithTexture: Invalid index\");     //如果index大于现有的数量则更新数量     m_uTotalQuads = max( index+1, m_uTotalQuads);     //修改对应的数据值     m_pQuads[index] = *quad;        //需要更新 #if CC_USES_VBO     m_bDirty = true; #endif } //通过索引值找到对应图块的顶点缓冲，并在其位置之前插入一个新的图块。 void CCTextureAtlas::insertQuad(ccV3F_C4B_T2F_Quad *quad, unsigned int index) {     //有效性判断     CCAssert( index < m_uCapacity, \"insertQuadWithTexture: Invalid index\");     //数量增加     m_uTotalQuads++;     CCAssert( m_uTotalQuads <= m_uCapacity, \"invalid totalQuads\");     //先将索引位置之后的数据整体后移一个位置，再用新数据填充索引位置的数据。实现插入操作。     unsigned int remaining = (m_uTotalQuads-1) - index;         if( remaining > 0) {         // texture coordinates         memmove( &m_pQuads[index+1],&m_pQuads[index], sizeof(m_pQuads[0]) * remaining );            }     m_pQuads[index] = *quad;     //设置需要更新m_pBuffersVBO中的VBO数组数据。 #if CC_USES_VBO     m_bDirty = true; #endif } //通过索引值找到对应图块的顶点缓冲，并把它插入另一个图块之前。 void CCTextureAtlas::insertQuadFromIndex(unsigned int oldIndex, unsigned int newIndex) {     //有效性判断     CCAssert( newIndex >= 0 && newIndex < m_uTotalQuads, \"insertQuadFromIndex:atIndex: Invalid index\");     CCAssert( oldIndex >= 0 && oldIndex < m_uTotalQuads, \"insertQuadFromIndex:atIndex: Invalid index\");     //两个索引相同直接返回即可     if( oldIndex == newIndex )         return;     //计算要移动的图块数量     unsigned int howMany = (oldIndex - newIndex) > 0 ? (oldIndex - newIndex) :  (newIndex - oldIndex);     unsigned int dst = oldIndex;     unsigned int src = oldIndex + 1;     if( oldIndex > newIndex) {         dst = newIndex+1;         src = newIndex;     }     // 开始进行移动     ccV3F_C4B_T2F_Quad quadsBackup = m_pQuads[oldIndex];     memmove( &m_pQuads[dst],&m_pQuads[src], sizeof(m_pQuads[0]) * howMany );     //更新新索引位置的数据     m_pQuads[newIndex] = quadsBackup;     //设置需要更新m_pBuffersVBO中的VBO数组数据。 #if CC_USES_VBO     m_bDirty = true; #endif } //移除指定位置的图块顶点缓冲 void CCTextureAtlas::removeQuadAtIndex(unsigned int index) {     //有效性判断     CCAssert( index < m_uTotalQuads, \"removeQuadAtIndex: Invalid index\");     unsigned int remaining = (m_uTotalQuads-1) - index;     //将索引图块后的所有图块向前移1个位置即可     // last object doesn't need to be moved     if( remaining ) {         // texture coordinates         memmove( &m_pQuads[index],&m_pQuads[index+1], sizeof(m_pQuads[0]) * remaining );     }     //数量减1     m_uTotalQuads--;     //设置需要更新m_pBuffersVBO中的VBO数组数据。 #if CC_USES_VBO     m_bDirty = true; #endif } //移除所有的顶点缓冲数据 void CCTextureAtlas::removeAllQuads() {     //数量直接置0，这是最快的方式     m_uTotalQuads = 0; } // 重新设置图块顶点缓冲数组的容量 bool CCTextureAtlas::resizeCapacity(unsigned int newCapacity) {     //如果等于原来的容量直接返回     if( newCapacity == m_uCapacity )         return true;     //确保当前绘制的精灵数量最大不能超过容量     m_uTotalQuads = min(m_uTotalQuads, newCapacity);     //更新容量     m_uCapacity = newCapacity;         //定义指针存放要申请的图块信息与索引数组的内存地址     void * tmpQuads = NULL;     void * tmpIndices = NULL;         //为图块的顶点缓冲数组申请内存,注意：如果已占有内存则直接在原内存地址上进行内存长度调整     if (m_pQuads == NULL)         tmpQuads = calloc(sizeof(m_pQuads[0]) * m_uCapacity, 1);     else         tmpQuads = realloc( m_pQuads, sizeof(m_pQuads[0]) * m_uCapacity );     //为图块的索引缓冲数组申请内存, 如果已占有内存则直接在原内存地址上进行内存长度调整     if (m_pIndices == NULL)         tmpIndices = calloc(sizeof(m_pIndices[0]) * m_uCapacity * 6, 1);     else         tmpIndices = realloc( m_pIndices, sizeof(m_pIndices[0]) * m_uCapacity * 6 );         //如果内存申请失败的处理     if( ! ( tmpQuads && tmpIndices) ) {         //CCLOG(\"cocos2d: CCTextureAtlas: not enough memory\");         if( tmpQuads )             free(tmpQuads);         else             free(m_pQuads);         if( tmpIndices )             free(tmpIndices);         else             free(m_pIndices);         m_pQuads = NULL;         m_pIndices = NULL;         m_uCapacity = m_uTotalQuads = 0;         return false;     }     //如果成功，则将内存地址赋给相应成员指针变量     m_pQuads = (ccV3F_C4B_T2F_Quad *)tmpQuads;     m_pIndices = (GLushort *)tmpIndices;         //释放顶点缓冲对象并重新创建和进行绑定 #if CC_USES_VBO     glDeleteBuffers(2, m_pBuffersVBO);     // initial binding     glGenBuffers(2, &m_pBuffersVBO[0]);     m_bDirty = true; #endif // CC_USES_VBO     //初始化索引缓冲     this->initIndices();     //设置需要更新m_pBuffersVBO中的VBO数组数据。上面已经设了，这里重复可以不要。 #if CC_USES_VBO     m_bDirty = true; #endif     return true; } //绘制所有的图块顶点缓冲数据 void CCTextureAtlas::drawQuads() {     this->drawNumberOfQuads(m_uTotalQuads, 0); } //绘制指定的图块顶点缓冲数据 void CCTextureAtlas::drawNumberOfQuads(unsigned int n) {     this->drawNumberOfQuads(n, 0); } //绘制从指定的图块顶点缓冲数据起后面的N个图块顶点缓冲数据 void CCTextureAtlas::drawNumberOfQuads(unsigned int n, unsigned int start) {       // Default GL states: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY     // Needed states: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY     // Unneeded states: -     // 如果数量为零直接返回。     if (0 == n)         return;     //设置使用纹理     glBindTexture(GL_TEXTURE_2D, m_pTexture->getName()); #define kQuadSize sizeof(m_pQuads[0].bl)     //如果使用VBO所进行的渲染设置 #if CC_USES_VBO     //指定m_pBuffersVBO[0]为顶点缓冲区，并激活缓冲区     glBindBuffer(GL_ARRAY_BUFFER, m_pBuffersVBO[0]);     //绑定完成后为其分配内存 #if CC_ENABLE_CACHE_TEXTTURE_DATA     glBufferData(GL_ARRAY_BUFFER, sizeof(m_pQuads[0]) * m_uCapacity, m_pQuads, GL_DYNAMIC_DRAW); #endif     //在绘制时如果遇到需要更新标记，则重新将顶点缓冲数据更新到绑定的对象上。     if (m_bDirty)     {         glBufferSubData(GL_ARRAY_BUFFER, sizeof(m_pQuads[0]) * start, sizeof(m_pQuads[0]) * n, &m_pQuads[start]);         m_bDirty = false;     }         // 对顶点缓冲中的顶点格式进行解释，让显卡知道顶点格式的构成。     // 顶点缓冲中哪个是位置数据     glVertexPointer(3, GL_FLOAT, kQuadSize, (GLvoid*) offsetof( ccV3F_C4B_T2F, vertices));     //顶点缓冲中哪个是颜色数据     glColorPointer(4, GL_UNSIGNED_BYTE, kQuadSize, (GLvoid*) offsetof( ccV3F_C4B_T2F, colors));     //顶点缓冲中哪个是纹理坐标数据     glTexCoordPointer(2, GL_FLOAT, kQuadSize, (GLvoid*) offsetof( ccV3F_C4B_T2F, texCoords));         //指定m_pBuffersVBO[1]为索引缓冲区，并激活缓冲区 glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_pBuffersVBO[1]);     //绑定完成后为其分配内存 #if CC_ENABLE_CACHE_TEXTTURE_DATA     glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(m_pIndices[0]) * m_uCapacity * 6, m_pIndices, GL_STATIC_DRAW); #endif //按照相应的三角形排列进行渲染 #if CC_TEXTURE_ATLAS_USE_TRIANGLE_STRIP     glDrawElements(GL_TRIANGLE_STRIP, (GLsizei)n*6, GL_UNSIGNED_SHORT, (GLvoid*)(start * 6 * sizeof(m_pIndices[0])));     #else     glDrawElements(GL_TRIANGLES, (GLsizei)n*6, GL_UNSIGNED_SHORT, (GLvoid*)(start * 6 * sizeof(m_pIndices[0]))); #endif // CC_USES_VBO     //从显存上卸载绑定的数据     //停止使用缓冲区     glBindBuffer(GL_ARRAY_BUFFER, 0);     glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0); #else // ! CC_USES_VBO     //如果不使用VBO所进行的渲染设置     unsigned int offset = (unsigned int)m_pQuads;     //设置OpenGL渲染使用的顶点数据     unsigned int diff = offsetof( ccV3F_C4B_T2F, vertices);     glVertexPointer(3, GL_FLOAT, kQuadSize, (GLvoid*) (offset + diff) );     //设置OpenGL渲染使用的颜色数据     diff = offsetof( ccV3F_C4B_T2F, colors);     glColorPointer(4, GL_UNSIGNED_BYTE, kQuadSize, (GLvoid*)(offset + diff));     //设置OpenGL渲染使用的纹理坐标数据     diff = offsetof( ccV3F_C4B_T2F, texCoords);     glTexCoordPointer(2, GL_FLOAT, kQuadSize, (GLvoid*)(offset + diff)); //按照相应的三角形排列进行渲染 #if CC_TEXTURE_ATLAS_USE_TRIANGLE_STRIP     glDrawElements(GL_TRIANGLE_STRIP, n*6, GL_UNSIGNED_SHORT, m_pIndices + start * 6);  #else     glDrawElements(GL_TRIANGLES, n*6, GL_UNSIGNED_SHORT, m_pIndices + start * 6);   #endif #endif // CC_USES_VBO } }//namespace   cocos2d   清楚了CCTextureAtlas，现在回过头再来看CCSpriteBatchNode。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 class CC_DLL CCSpriteBatchNode : public CCNode, public CCTextureProtocol     {     public:         //析构         ~CCSpriteBatchNode();           // 取得纹理图块顶点缓冲管理器。         inline CCTextureAtlas* getTextureAtlas(void) { return m_pobTextureAtlas; }         //设置纹理图块顶点缓冲管理器         inline void setTextureAtlas(CCTextureAtlas* textureAtlas)         {             //如果当前使用的纹理图块顶点缓冲管理器与要设置的纹理图块顶点缓冲管理器不同，先释放原顶点缓冲管理器，再将当前使用的顶点缓冲管理器指针指向要设置顶点缓冲管理器。             if (textureAtlas != m_pobTextureAtlas)             {                 CC_SAFE_RETAIN(textureAtlas);                 CC_SAFE_RELEASE(m_pobTextureAtlas);                 m_pobTextureAtlas = textureAtlas;             }         }         //取得存放所有使用此图块集的CCSprite指针数组         inline CCArray* getDescendants(void) { return m_pobDescendants; }         //静态函数：通过纹理指针按照默认的图块数量29创建一个CCSpriteBatch实例对象。注意：如果游戏运行中图块数量超过这个数值，则数量递增33%以满足需要         static CCSpriteBatchNode* batchNodeWithTexture(CCTexture2D *tex);         //静态函数：通过纹理指针按照设定的图块数量创建一个CCSpriteBatch实例对象。          static CCSpriteBatchNode* batchNodeWithTexture(CCTexture2D* tex, unsigned int capacity);         //静态函数：通过图片名称按照默认的图块数量29创建一个CCSpriteBatch实例对象。         static CCSpriteBatchNode* batchNodeWithFile(const char* fileImage);         //静态函数：通过图片名称按照设定的图块数量创建一个CCSpriteBatch实例对象。          static CCSpriteBatchNode* batchNodeWithFile(const char* fileImage, unsigned int capacity);         //通过纹理指针和图块数量进行初始化。         bool initWithTexture(CCTexture2D *tex, unsigned int capacity);         //通过图片名称和图块数量进行初始化。         bool initWithFile(const char* fileImage, unsigned int capacity);                 //扩容，递增1/3的图块数量         void increaseAtlasCapacity();         //通过索引移除一个子结点，参数doCleanUp决定移除的同时是否对其进行释放。         void removeChildAtIndex(unsigned int index, bool doCleanup);         //将一个指定的CCSprite指针插入到子节点指针数组的指定位置         void insertChild(CCSprite *child, unsigned int index);         //移除一个指定的CCSprite指针         void removeSpriteFromAtlas(CCSprite *sprite);         //重新构建指定的CCSprite指针下的所有子结点的索引         unsigned int rebuildIndexInOrder(CCSprite *parent, unsigned int index);         //取得指定CCSprite的所有节点的最大图块索引         unsigned int highestAtlasIndexInChild(CCSprite *sprite);         //取得指定CCSprite的所有节点的最小图块索引         unsigned int lowestAtlasIndexInChild(CCSprite *sprite);         //取得指定CCSprite的Z顺序之上或之下的最近的图块索引         unsigned int atlasIndexForChild(CCSprite *sprite, int z);                 // 实现CCTextureProtocol的接口函数         // 取得纹理         virtual CCTexture2D* getTexture(void);         // 设置纹理         virtual void setTexture(CCTexture2D *texture);         //为纹理设置使用的混合状态         virtual void setBlendFunc(ccBlendFunc blendFunc);         //取得混合状态         virtual ccBlendFunc getBlendFunc(void);         //重载CCNode的相关函数         //每一帧要被调用的函数         virtual void visit(void);         //将一个CCNode指针做为自已的子结点         virtual void addChild(CCNode * child);         //将一个CCNode指针以指定的Z顺序做为自已的子结点         virtual void addChild(CCNode * child, int zOrder);         //将一个CCNode指针以指定的Z顺序并附带一个参数值做为自已的子结点         virtual void addChild(CCNode * child, int zOrder, int tag);         //将一个子结点重新设置Z顺序         virtual void reorderChild(CCNode * child, int zOrder);         //将一个子结点删除，并根所参数决定是否释放元素         virtual void removeChild(CCNode* child, bool cleanup);         //将所有的子结点移除，并根所参数决定是否释放元素         virtual void removeAllChildrenWithCleanup(bool cleanup);         //绘制函数         virtual void draw(void);     protected:                 //从精灵数据中在图块管理器中插入一个新的图块，注意：并不将精灵放入子结点。      void addQuadFromSprite(CCSprite *sprite, unsigned int index);         //在子结点数组指定位置插入一个新的精灵。注意：并不新建图块。         CCSpriteBatchNode * addSpriteWithoutQuad(CCSprite*child, unsigned int z, int aTag);     private:         //更新混合状态         void updateBlendFunc();     protected:         //使用的纹理图块顶点缓冲管理器         CCTextureAtlas *m_pobTextureAtlas;         //混合状态         ccBlendFunc m_blendFunc;         //指向存放所有使用此纹理中的图块的CCSprite指针数组的指针         CCArray* m_pobDescendants;     };   再看CPP：   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 //加入用到的头文件 #include \"CCSpriteBatchNode.h\" #include \"ccConfig.h\" #include \"CCSprite.h\" #include \"effects/CCGrid.h\" #include \"CCDrawingPrimitives.h\" #include \"CCTextureCache.h\" #include \"CCPointExtension.h\" //使用cocos2d命名空间 namespace cocos2d {     //定义整型常量defaultCapacity做为默认创建的图块数量     const int defaultCapacity = 29;     //静态函数：通过纹理指针按照默认的图块数量29创建一个CCSpriteBatch实例对象。 CCSpriteBatchNode::batchNodeWithTexture(CCTexture2D *tex)     {         //使用new创建一个CCSpriteBatchNode实例对象。         CCSpriteBatchNode *batchNode = new CCSpriteBatchNode();         //使用纹理指针和默认图块数量对CCSpriteBatchNode实例对象进行初始化。         batchNode->initWithTexture(tex, defaultCapacity);         //设置其由内存管理器进行内存释放。         batchNode->autorelease();         //返回新创建的CCSpriteBatchNode实例对象         return batchNode;     }     //静态函数：通过纹理指针按照设定的图块数量创建一个CCSpriteBatch实例对象。      CCSpriteBatchNode* CCSpriteBatchNode::batchNodeWithTexture(CCTexture2D* tex, unsigned int capacity)     {         //同上一函数         CCSpriteBatchNode *batchNode = new CCSpriteBatchNode();         batchNode->initWithTexture(tex, capacity);         batchNode->autorelease();         return batchNode;     }     //静态函数：通过图片名称按照设定的图块数量创建一个CCSpriteBatch实例对象。      CCSpriteBatchNode* CCSpriteBatchNode::batchNodeWithFile(const char *fileImage, unsigned int capacity)     {         //同上一函数         CCSpriteBatchNode *batchNode = new CCSpriteBatchNode();         //这里参数1改为图片名称         batchNode->initWithFile(fileImage, capacity);         batchNode->autorelease();         return batchNode;     }     //静态函数：通过图片名称按照默认的图块数量29创建一个CCSpriteBatch实例对象 CCSpriteBatchNode* CCSpriteBatchNode::batchNodeWithFile(const char *fileImage)     {         //同上         CCSpriteBatchNode *batchNode = new CCSpriteBatchNode();         batchNode->initWithFile(fileImage, defaultCapacity);         batchNode->autorelease();         return batchNode;     }     //通过纹理指针和图块数量进行初始化。注意：这个函数才是真正进行初始化的实现过程。     bool CCSpriteBatchNode::initWithTexture(CCTexture2D *tex, unsigned int capacity)     {         //设置混合系数，源混合系数为CC_BLEND_SRC，目标混合系数为CC_BLEND_DST，则图像绘制时按照纹理或色彩的Alpha值与背景进行混合。         m_blendFunc.src = CC_BLEND_SRC;         m_blendFunc.dst = CC_BLEND_DST;         //创建一个图片集管理器         m_pobTextureAtlas = new CCTextureAtlas();         //将纹理和图块数量做为参数初始化图片集,这里可知图块集还是依靠CCTextureAtlas类。         m_pobTextureAtlas->initWithTexture(tex, capacity);         //更新混合状态         updateBlendFunc();         // 新建一个CCArray实例，将m_pChildren指向它         m_pChildren = CCArray::array();         //新建一个存放所有使用此图块集的CCSprite指针数组，将m_pobDescendants指向它         m_pobDescendants = CCArray::array();         //分别进行引用计数加1操作。         m_pChildren->retain();         m_pobDescendants->retain();         return true;     }     //通过纹理文件名和图块数量进行初始化。     bool CCSpriteBatchNode::initWithFile(const char* fileImage, unsigned int capacity)     {         //使用纹理管理器加载一个图片，生成的纹理返回给变量pTexture2D CCTexture2D *pTexture2D = CCTextureCache::sharedTextureCache()->addImage(fileImage);         //以变量pTexture2D为参数调用上一个函数进行初始化         return initWithTexture(pTexture2D, capacity);     }     //析构     CCSpriteBatchNode::~CCSpriteBatchNode()     {         //释放图块集         CC_SAFE_RELEASE(m_pobTextureAtlas);         CC_SAFE_RELEASE(m_pobDescendants);     }     // 是基类CCNode虚函数，是每帧会被调用到的函数。     void CCSpriteBatchNode::visit(void)     {         //如果不显示，则直接返回。         if (! m_bIsVisible)         {             return;         }         //矩阵压栈，保存渲染此结点前的所有OpenGL所需矩阵的值         glPushMatrix();         //如果         if (m_pGrid && m_pGrid->isActive())         {             m_pGrid->beforeDraw();             transformAncestors();         }         //矩阵变量         transform();         //基类CCNode虚函数，用于实现当前CCNode的绘制。         draw();         //         if (m_pGrid && m_pGrid->isActive())         {             m_pGrid->afterDraw(this);         }         //矩阵出栈。恢复渲染此结点前的所有OpenGL所需矩阵的值         glPopMatrix();     }     //将一个CCSprite指针以指定的Z顺序并附带一个参数值做为子结点     void CCSpriteBatchNode::addChild(CCNode *child, int zOrder, int tag)     {         //有效性判断         CCAssert(child != NULL, \"child should not be null\");         //将结点转为CCSprite         CCSprite *pSprite = (CCSprite*)(child);         // check CCSprite is using the same texture id         //确保pSprite的纹理与图片集的纹理相同才可以放为子结点         CCAssert(pSprite->getTexture()->getName() == m_pobTextureAtlas->getTexture()->getName(), \"\");         CCNode::addChild(child, zOrder, tag);         //根据填入的Z顺序值取得pSprite所在的子结点索引放在变量uIndex中         unsigned int uIndex = atlasIndexForChild(pSprite, zOrder);         //将pSprite插入到第uIndex个位置         insertChild(pSprite, uIndex);     }     //将一个CCNode指针做为子结点     void CCSpriteBatchNode::addChild(CCNode *child)     {         //调用基类的addChild         CCNode::addChild(child);     }     //将一个CCNode指针以指定的Z顺序做为子结点     void CCSpriteBatchNode::addChild(CCNode *child, int zOrder)     {         //调用基类的addChild         CCNode::addChild(child, zOrder);     }     //将子结点重新设置Z顺序。     void CCSpriteBatchNode::reorderChild(CCNode *child, int zOrder)     {         //结点参数有效性判断         CCAssert(child != NULL, \"the child should not be null\");         //确保此结点是挂在子结点树上。         CCAssert(m_pChildren->containsObject(child), \"sprite batch node should contain the child\");         //如果顺序已经与结点的Z顺序相等则直接返回         if (zOrder == child->getZOrder())         {             return;         }         //子结点引用计数加1         child->retain();         //将子结点从子结点树上移除         removeChild((CCSprite*)child, false);         //按照新的Z顺序插入结点树         addChild(child, zOrder);         //引用计数减1         child->release();     }     //将一个CCNode指针从子结点数组中删除，并根所参数决定是否释放元素     void CCSpriteBatchNode::removeChild(CCNode *child, bool cleanup)     {         //将结点转为CCSprite         CCSprite *pSprite = (CCSprite*)(child);         // explicit null handling         if (pSprite == NULL)         {             return;         }         //确保子结点树中有pSprite         CCAssert(m_pChildren->containsObject(pSprite), \"sprite batch node should contain the child\");         //移除一个指定的CCSprite指针         removeSpriteFromAtlas(pSprite);         //调用基类的移除子结点函数         CCNode::removeChild(pSprite, cleanup);     }     //通过索引移除一个子结点，参数doCleanUp决定移除的同时是否对其进行释放。     void CCSpriteBatchNode::removeChildAtIndex(unsigned int uIndex, bool bDoCleanup)     {         removeChild((CCSprite*)(m_pChildren->objectAtIndex(uIndex)), bDoCleanup);     }     //将所有的子结点数组元素移除，并根所参数决定是否释放元素     void CCSpriteBatchNode::removeAllChildrenWithCleanup(bool bCleanup)     {         // 如果有子结点         if (m_pChildren && m_pChildren->count() > 0)         {             //遍历子结点调用移除子结点函数             CCObject* pObject = NULL;             CCARRAY_FOREACH(m_pChildren, pObject)             {                 CCSprite* pChild = (CCSprite*) pObject;                 if (pChild)                 {                     removeSpriteFromAtlas(pChild);                 }             }         }         //调用基类的移除子结点函数         CCNode::removeAllChildrenWithCleanup(bCleanup);         //清空使用此图块集的CCSprite指针数组         m_pobDescendants->removeAllObjects();         //清空图块集管理器中的图块信息         m_pobTextureAtlas->removeAllQuads();     }     //绘制当前CCNode     void CCSpriteBatchNode::draw(void)     {         //调用基类CCNode的draw函数         CCNode::draw();         // 如果图块集为空直接返回         if (m_pobTextureAtlas->getTotalQuads() == 0)         {             return;         }         // 如果图块集不为空         if (m_pobDescendants && m_pobDescendants->count() > 0)         {             //遍历所有使用此图块集的CCSprite             CCObject* pObject = NULL;             CCARRAY_FOREACH(m_pobDescendants, pObject)             {                 CCSprite* pChild = (CCSprite*) pObject;                 if (pChild)                 {                     // 更新CCSprite的矩阵，注意:此句内部实现将子结点pChild所指的精灵的位置更新到对应的图块集顶点缓冲中。                     pChild->updateTransform(); #if CC_SPRITEBATCHNODE_DEBUG_DRAW                     // 如果开启调试，则绘制CCSprite的包围矩形                     CCRect rect = pChild->boundingBox();                     CCPoint vertices[4]={                         ccp(rect.origin.x,rect.origin.y),                         ccp(rect.origin.x+rect.size.width,rect.origin.y),                         ccp(rect.origin.x+rect.size.width,rect.origin.y+rect.size.height),                         ccp(rect.origin.x,rect.origin.y+rect.size.height),                     };                     ccDrawPoly(vertices, 4, true); #endif // CC_SPRITEBATCHNODE_DEBUG_DRAW                 }             }         }         // 设置ALPHA混合状态         bool newBlend = m_blendFunc.src != CC_BLEND_SRC || m_blendFunc.dst != CC_BLEND_DST;         if (newBlend)         {             glBlendFunc(m_blendFunc.src, m_blendFunc.dst);         }         //绘制图块集         m_pobTextureAtlas->drawQuads();         //恢复原ALPHA混合状态         if (newBlend)         {             glBlendFunc(CC_BLEND_SRC, CC_BLEND_DST);         }     }     //扩容，递增1/3的图块数量     void CCSpriteBatchNode::increaseAtlasCapacity(void)     {         // this is likely computationally expensive         // 如果当前需要的图块数量比实际图块数量大，则将图块的数量增加1/3。         unsigned int quantity = (m_pobTextureAtlas->getCapacity() + 1) * 4 / 3;         // 打印图块数量的变化信息         CCLOG(\"cocos2d: CCSpriteBatchNode: resizing TextureAtlas capacity from [%lu] to [%lu].\",             (long)m_pobTextureAtlas->getCapacity(),             (long)quantity);         //图块集重新设置数量，resizeCapacity按新的图块集数量重新计算每个图块的纹理UV         if (! m_pobTextureAtlas->resizeCapacity(quantity))         {             // 如果失败，返回出错信息。             CCLOG(\"cocos2d: WARNING: Not enough memory to resize the atlas\");             CCAssert(false, \"Not enough memory to resize the atla\");         }     }     //重新构建指定的CCSprite指针下的所有子结点的索引     unsigned int CCSpriteBatchNode::rebuildIndexInOrder(CCSprite *pobParent, unsigned int uIndex)     {         //取得参数pobParent的所有子结点数组         CCArray *pChildren = pobParent->getChildren();         //如果子结点数组不为空         if (pChildren && pChildren->count() > 0)         {             //遍历子结点数组并             CCObject* pObject = NULL;             CCARRAY_FOREACH(pChildren, pObject)             {                 CCSprite* pChild = (CCSprite*) pObject;                 if (pChild && (pChild->getZOrder() < 0))                 {                     uIndex = rebuildIndexInOrder(pChild, uIndex);                 }             }         }           // 如果pobParent         if (! pobParent->isEqual(this))         {             pobParent->setAtlasIndex(uIndex);             uIndex++;         }         //如果子结点数组不为空         if (pChildren && pChildren->count() > 0)         {             //遍历子结点数组并             CCObject* pObject = NULL;             CCARRAY_FOREACH(pChildren, pObject)             {                 CCSprite* pChild = (CCSprite*) pObject;                 if (pChild && (pChild->getZOrder() >= 0))                 {                     uIndex = rebuildIndexInOrder(pChild, uIndex);                 }             }         }         return uIndex;     }     //取得指定CCSprite的所有节点的最大图块索引     unsigned int CCSpriteBatchNode::highestAtlasIndexInChild(CCSprite *pSprite)     {         //取得指定CCSprite的子结点数组         CCArray *pChildren = pSprite->getChildren();          //如果没有子结点，直接返回指定CCSprite的图块索引         if (! pChildren || pChildren->count() == 0)         {             return pSprite->getAtlasIndex();         }         else         {             return highestAtlasIndexInChild((CCSprite*)(pChildren->lastObject()));         }     }     //取得指定CCSprite的所有节点的最小图块索引     unsigned int CCSpriteBatchNode::lowestAtlasIndexInChild(CCSprite *pSprite)     {                 CCArray *pChildren = pSprite->getChildren();         //取得指定CCSprite的子结点数           if (! pChildren || pChildren->count() == 0)         { //取得指定CCSprite的子结点数组             return pSprite->getAtlasIndex();         }         else         {             return lowestAtlasIndexInChild((CCSprite*)(pChildren->objectAtIndex(0)));         }     }     //取得对应的子结点的Z顺序之上或之下的最近图块索引     unsigned int CCSpriteBatchNode::atlasIndexForChild(CCSprite *pobSprite, int nZ)     {         //取得pobSprite的父节点的所有子结点数组。         CCArray *pBrothers = pobSprite->getParent()->getChildren();         //查询pobSprite在所有子结点数组中的索引 unsigned int uChildIndex = pBrothers->indexOfObject(pobSprite);          // 判断当前节点是否是pobSprite的父结点，将结果存入bIgnoreParent。         bool bIgnoreParent = (CCSpriteBatchNode*)(pobSprite->getParent()) == this;         // 新建指针变量pPrevious，用于存储pobSprite的前一个结点。         CCSprite *pPrevious = NULL;         if (uChildIndex > 0 &&             uChildIndex < UINT_MAX)         {   //取得pobSprite在所有子结点中的位置前一个节点。             pPrevious = (CCSprite*)(pBrothers->objectAtIndex(uChildIndex - 1));         }         // 如果当前节点是pobSprite的父结点。         if (bIgnoreParent)         {             //如果pobSprite就是第一个子结点。则返回0。             if (uChildIndex == 0)             {                 return 0;             }             //如果pobSprite不是第一个子结点，则返回pobSprite的前一个结点的最大图块索引，加1返回。             return highestAtlasIndexInChild(pPrevious) + 1;         }         // 当前节点不是pobSprite的父结点。         // 如果pobSprite是其父节点的第一子结点         if (uChildIndex == 0)         {             //新建指针变量p，指向pobSprite的父结点。             CCSprite *p = (CCSprite*)(pobSprite->getParent());             // less than parent and brothers             // 如果nZ小于零,即在其之下的最近索引             if (nZ < 0)             {                 //返回pobSprite的父结点的图块索引。                 return p->getAtlasIndex();             }             else             {   //如果nZ大于零，即在其之上的最近索引                 //返回pobSprite的父结点的图块索引值加1。                 return p->getAtlasIndex() + 1;             }         }         else         {             //如果pobSprite不是其父节点的第一子结点             if ((pPrevious->getZOrder() < 0 && nZ < 0) || (pPrevious->getZOrder() >= 0 && nZ >= 0))             {                 //返回pobSprite前一个节点的的最大图块索引加1                 return highestAtlasIndexInChild(pPrevious) + 1;             }             // 否则返回其父节点的图块索引值加1             // else (previous < 0 and sprite >= 0 )             CCSprite *p = (CCSprite*)(pobSprite->getParent());             return p->getAtlasIndex() + 1;         }         // 如果进行到这一步，已经出错了。打印出错信息。         CCAssert(0, \"should not run here\");         return 0;     }     //将一个CCSprite插入到子节点指针数组的指定位置     void CCSpriteBatchNode::insertChild(CCSprite *pobSprite, unsigned int uIndex)     {         //pobSprite应用此图片集         pobSprite->useBatchNode(this);         //设置图块集索引值         pobSprite->setAtlasIndex(uIndex);         //设置pobSprite在绘制时需要进行绑定图块的更新         pobSprite->setDirty(true);         //如果图块集已经达到最大容量则进行扩容         if (m_pobTextureAtlas->getTotalQuads() == m_pobTextureAtlas->getCapacity())         {             increaseAtlasCapacity();         }         //在图块集管理器中新增加一个图块，并指定其索引         ccV3F_C4B_T2F_Quad quad = pobSprite->getQuad();         m_pobTextureAtlas->insertQuad(&quad, uIndex);         //将pobSprite放入到使用此图集子结点数组的对应位置         m_pobDescendants->insertObject(pobSprite, uIndex);         // 更新索引         unsigned int i = 0;         //如果使用此图集的子结点数组不为空，遍历并重设一下大于此索引的所有子结点。         if (m_pobDescendants && m_pobDescendants->count() > 0)         {             CCObject* pObject = NULL;             CCARRAY_FOREACH(m_pobDescendants, pObject)             {                 CCSprite* pChild = (CCSprite*) pObject;                 if (pChild)                 {                     if (i > uIndex)                     {                         pChild->setAtlasIndex(pChild->getAtlasIndex() + 1);                     }                     ++i;                 }             }         }           // 取得pobSprite的子结点数组         CCArray *pChildren = pobSprite->getChildren();         // 如果不为空，遍历并将子结点也按照Z顺序放入到当前CCSpriteBatchNode的子结点数组中。         if (pChildren && pChildren->count() > 0)         {             CCObject* pObject = NULL;             CCARRAY_FOREACH(pChildren, pObject)             {                 CCSprite* pChild = (CCSprite*) pObject;                 if (pChild)                 {                     unsigned int uIndex = atlasIndexForChild(pChild, pChild->getZOrder());                     insertChild(pChild, uIndex);                 }             }         }     }     //移除一个CCSprite     void CCSpriteBatchNode::removeSpriteFromAtlas(CCSprite *pobSprite)     {         // 从图块管理器中移除目标精灵pobSprite所用的图块信息         m_pobTextureAtlas->removeQuadAtIndex(pobSprite->getAtlasIndex());         //重置目标精灵pobSprite所使用的图块信息         pobSprite->useSelfRender();         //取得目标精灵pobSprite在CCSpriteBatchNode的子结点中数组中的位置         unsigned int uIndex = m_pobDescendants->indexOfObject(pobSprite);         //如果找到后，从子结点数组中移除它         if (uIndex != UINT_MAX)         {             m_pobDescendants->removeObjectAtIndex(uIndex);             // 取得子结点的数组元素数量，遍历大于当前索引的子结点，向前移一个位置。注意：这个for循环从uIndex开始计数。             unsigned int count = m_pobDescendants->count();             for(; uIndex < count; ++uIndex)             {                 CCSprite* s = (CCSprite*)(m_pobDescendants->objectAtIndex(uIndex));                 s->setAtlasIndex( s->getAtlasIndex() - 1 );             }         }         // 取得目标精灵的子结点数组，遍历并从当前CCSpriteBatchNode的子结点数组中移除。         CCArray *pChildren = pobSprite->getChildren();         if (pChildren && pChildren->count() > 0)         {             CCObject* pObject = NULL;             CCARRAY_FOREACH(pChildren, pObject)             {                 CCSprite* pChild = (CCSprite*) pObject;                 if (pChild)                 {                     removeSpriteFromAtlas(pChild);                 }             }         }     }     //更新Alpha混合状态     void CCSpriteBatchNode::updateBlendFunc(void)     {         //如果当前图块集对应的纹理有Alpha通道         if (! m_pobTextureAtlas->getTexture()->getHasPremultipliedAlpha())         {             //设置GL_SRC_ALPHA表示使用源颜色的alpha值来作源混合因子。             m_blendFunc.src = GL_SRC_ALPHA;             // GL_ONE_MINUS_SRC_ALPHA表示用1.0减去源颜色的alpha值来作为目标混合因子。             m_blendFunc.dst = GL_ONE_MINUS_SRC_ALPHA;         }     }     // 设置Alpha混合状态     void CCSpriteBatchNode::setBlendFunc(ccBlendFunc blendFunc)     {         m_blendFunc = blendFunc;     }     // 取得Alpha混合状态     ccBlendFunc CCSpriteBatchNode::getBlendFunc(void)     {         return m_blendFunc;     }     //取得图块集所应用的纹理贴图。     CCTexture2D* CCSpriteBatchNode::getTexture(void)     {         return m_pobTextureAtlas->getTexture();     }     //设置图块集所应用的纹理贴图     void CCSpriteBatchNode::setTexture(CCTexture2D *texture)     {         m_pobTextureAtlas->setTexture(texture);         //设置完后跟据纹理贴图是否有Alpha通道更新一下混合状态。         updateBlendFunc();     }     //从精灵数据中在图块管理器中插入一个新的图块，注意：并不将精灵放入子结点。     void CCSpriteBatchNode::addQuadFromSprite(CCSprite *sprite, unsigned int index) {      //判断sprite是否有效。         CCAssert( sprite != NULL, \"Argument must be non-nil\");          //如果指定的索引大于图块集的数量或者图块集的数量已经达到最大值，则需要对图块集进行扩容。         while(index >= m_pobTextureAtlas->getCapacity() || m_pobTextureAtlas->getCapacity() == m_pobTextureAtlas->getTotalQuads())         {             this->increaseAtlasCapacity();         }         //让sprite使用此图集管理器         sprite->useBatchNode(this);         //设置sprite的图块索引         sprite->setAtlasIndex(index);                 //新建一个图块顶点信息放入图块信息管理器中。         ccV3F_C4B_T2F_Quad quad = sprite->getQuad();         m_pobTextureAtlas->insertQuad(&quad, index);         //设置在缓制sprite时更新一下图块信息         sprite->setDirty(true);         //将sprite的顶点位置信息填充入图块顶点缓冲管理器中的顶点数据中。         sprite->updateTransform(); }     //在子结点数组指定位置插入一个新的精灵。注意：并不新建图块。     CCSpriteBatchNode * CCSpriteBatchNode::addSpriteWithoutQuad(CCSprite*child, unsigned int z, int aTag) {      //判断sprite是否有效。         CCAssert( child != NULL, \"Argument must be non-nil\");         //设置sprite的图块索引         child->setAtlasIndex(z);        //遍历子结点数组查看当前Z值应该排在哪个位置。         int i=0;         if (m_pobDescendants && m_pobDescendants->count() > 0)         {             CCObject* pObject = NULL;             CCARRAY_FOREACH(m_pobDescendants, pObject)             {                 CCSprite* pChild = (CCSprite*) pObject;                 if (pChild && (pChild->getAtlasIndex() >= z))                 {                     ++i;                 }             }         }         //取得位置i，插入child到数组中。         m_pobDescendants->insertObject(child, i);         //基类同名函数         CCNode::addChild(child, z, aTag);         return this;     } }   分析这个类的确是费功夫啊，呵呵。继续之前。喝口水先。话说今天听新闻，北京PM2.5浓度又升高了，我可怜的嗓子，担忧中… 走到这里，我们已经了解了CCSpriteBatchNode的作用。其实红孩儿在开发引擎的经历中也有过类似的设计，为了渲染大量相同类型的模型，按照纹理将子模型归类，并将这些纹理进行合并生成大纹理，渲染时设置大纹理就可以渲染出多个不同类型的子模型，如果开启克隆实例，则可以在一个批次内渲出上百个模型。原理相通，目的只有一个，提高渲染效率。 CCLabelBMFont类中关于图字纹理和图块的相关知识我们了解完了，但是我们仍然没有发现Fnt用在哪里，所以我们只理解了一半，现在我们来理解另一半。CCLabelBMFont中使用到一个类CCBMFontConfiguration，它就是用来读取Fnt文件中的文字图片说明信息的。在CCLabelBMFont.h中我们找到它   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class CC_DLL CCBMFontConfiguration : public CCObject     {         public:         //通过map容器对字的编码值和对应的信息做映射         std::map<unsigned int, ccBMFontDef>* m_pBitmapFontArray;         //FNT文件中的字图块公共项:Height         unsigned int m_uCommonHeight;         //FNT文件中的信息:边距，文字与边框的空隙         ccBMFontPadding m_tPadding;         //FNT文件中的信息:用到的png图         std::string m_sAtlasName;         //FNT文件中的信息:两个字在先后绘制时的间距调整的信息结构的哈希字典(其实就是个数组，以哈希算法进行存储）。         struct _KerningHashElement  *m_pKerningDictionary;     public:         //构造         CCBMFontConfiguration();         //析构         virtual ~CCBMFontConfiguration();         //取得描述         char * description();         //静态函数：将FNT文件加载进来返回一个CCBMFontConfiguration实例对象。         static CCBMFontConfiguration * configurationWithFNTFile(const char *FNTfile);         //使用FNT文件初始化         bool initWithFNTfile(const char *FNTfile);     private:         //解析FNT文件         void parseConfigFile(const char *controlFile);         //从文件中取得字符的编码及UV对应信息         void parseCharacterDefinition(std::string line, ccBMFontDef *characterDefinition);         //从文件取得字体说明         void parseInfoArguments(std::string line);         //从文件取得字符图块公共信息         void parseCommonArguments(std::string line);         //从文件取得图片文件名称         void parseImageFileName(std::string line, const char *fntFile);         //从文件取得要调整间距的字组合信息容量         void parseKerningCapacity(std::string line);         //从文件取得要调整间距的字组合信息         void parseKerningEntry(std::string line);         //从文件取得调整间距的字组合信息字典         void purgeKerningDictionary();     };   太棒了，它对Fnt文件做了全面的解析。马上看CPP他是怎么现实的。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332     初始化全局容器指针为空     CCMutableDictionary<std::string, CCBMFontConfiguration*> *configurations = NULL;     //全局函数：从Fnt文件中取得一个CCBMFontConfiguration实例对象     CCBMFontConfiguration* FNTConfigLoadFile( const char *fntFile)     {         //创建CCBMFontConfiguration指针变量pRet并置空         CCBMFontConfiguration *pRet = NULL;         //如果容器为空则新建容器         if( configurations == NULL )         {             configurations = new CCMutableDictionary<std::string, CCBMFontConfiguration*>();         }         //在容器中取得该文件对应的CCBMFontConfiguration         std::string key(fntFile);         pRet = configurations->objectForKey(key);         if( pRet == NULL )         {             //如果为空则调用CCBMFontConfiguration静态函数新建一个CCBMFontConfiguration读取文件返回信息结构给pRet             pRet = CCBMFontConfiguration::configurationWithFNTFile(fntFile);             //并将其加入容器中             configurations->setObject(pRet, key);         }         return pRet;     }     //释放容器中的数据并释放容器占用内存     void FNTConfigRemoveCache( void )     {         if (configurations)         {             configurations->removeAllObjects();             CC_SAFE_RELEASE_NULL(configurations);         }     }     //用于进行获取间距调整信息的哈希参数结构     typedef struct _KerningHashElement     {           int             key;        // key for the hash. 16-bit for 1st element, 16-bit for 2nd element         int             amount;         UT_hash_handle  hh;     } tKerningHashElement;             //静态函数，从Fnt文件中取得一个CCBMFontConfiguration实例对象         CCBMFontConfiguration * CCBMFontConfiguration::configurationWithFNTFile(const char *FNTfile)     {         //新建一个CCBMFontConfiguration实例对象         CCBMFontConfiguration * pRet = new CCBMFontConfiguration();         //使用FNT文件信息初始化         if (pRet->initWithFNTfile(FNTfile))         {             pRet->autorelease();             return pRet;         }         CC_SAFE_DELETE(pRet);         return NULL;     }     //由FNT文件对CCBMFontConfiguration实例对象进行初始化     bool CCBMFontConfiguration::initWithFNTfile(const char *FNTfile)     {         //有效性判断         CCAssert(FNTfile != NULL && strlen(FNTfile)!=0, \"\");         //解析FNT文件         m_pKerningDictionary = NULL;         this->parseConfigFile(FNTfile);         return true;     }     //构造函数     CCBMFontConfiguration::CCBMFontConfiguration()         : m_pBitmapFontArray(new std::map<unsigned int, ccBMFontDef>)         , m_uCommonHeight(0)         , m_pKerningDictionary(NULL)     {       }     //析构     CCBMFontConfiguration::~CCBMFontConfiguration()     {         //打印日志         CCLOGINFO( \"cocos2d: deallocing CCBMFontConfiguration\" );         //释放占用内存         CC_SAFE_DELETE(m_pBitmapFontArray);         this->purgeKerningDictionary();         m_sAtlasName.clear();     }     //取得描述     char * CCBMFontConfiguration::description(void)     {         char *ret = new char[100];         sprintf(ret, \"<CCBMFontConfiguration | Kernings:%d | Image = %s>\", HASH_COUNT(m_pKerningDictionary), m_sAtlasName.c_str());         return ret;     }     //释放间距信息字典     void CCBMFontConfiguration::purgeKerningDictionary()     {         tKerningHashElement *current;         while(m_pKerningDictionary)         {             current = m_pKerningDictionary;             HASH_DEL(m_pKerningDictionary,current);             free(current);         }     }         //解析FNT文件     void CCBMFontConfiguration::parseConfigFile(const char *controlFile)     {           //通过文件名找出对应的文件路径         std::string fullpath = CCFileUtils::fullPathFromRelativePath(controlFile);         //打开文件进行读操作，执行后会将文件读取到CCFileData创建的内存志中。         CCFileData data(fullpath.c_str(), \"rb\");         //取得文件大小         unsigned long nBufSize = data.getSize();         //取得CCFileData存储读取信息的内存块。         char* pBuffer = (char*) data.getBuffer();         //有效检查         CCAssert(pBuffer, \"CCBMFontConfiguration::parseConfigFile | Open file error.\");         if (!pBuffer)         {             return;         }         std::string line;         //将文件信息放入到字符串strLeft中         std::string strLeft(pBuffer, nBufSize);         //遍历字符串中每个字符进行解析         while (strLeft.length() > 0)         {              //根据换行符取出每一行             int pos = strLeft.find('\\n');              //如果不是结尾             if (pos != (int)std::string::npos)             {                 //取出此行                 line = strLeft.substr(0, pos);                   //更新当前字符串为新一行位置后面的字符串                 strLeft = strLeft.substr(pos + 1);             }             else             {                 //取后一行                 line = strLeft;                 strLeft.erase();             }              //如果是字体介绍信息             if(line.substr(0,strlen(\"info face\")) == \"info face\")             {                 //解析信息行                 this->parseInfoArguments(line);             }             //如果是图块公共信息             else if(line.substr(0,strlen(\"common lineHeight\")) == \"common lineHeight\")             {                   //解析图块公共信息                 this->parseCommonArguments(line);             }               //如果是指定索引的图片说明信息             else if(line.substr(0,strlen(\"page id\")) == \"page id\")             {                   //解析指定索引的图片的说明信息                 this->parseImageFileName(line, controlFile);             }               //如果是本图片中的字符数量             else if(line.substr(0,strlen(\"chars c\")) == \"chars c\")             {                 //本句忽略了，无意义，后面读取字符时可以统计             }               //如果是字符信息             else if(line.substr(0,strlen(\"char\")) == \"char\")             {                 //一个字符的编码对应信息                 ccBMFontDef characterDefinition;                   //将本行字符串解析到字符的编码对应信息中                 this->parseCharacterDefinition(line, &characterDefinition);                 通过信息索引存入哈希字典                 (*m_pBitmapFontArray)[ characterDefinition.charID ] = characterDefinition;             }               //如果有间距调整信息             else if(line.substr(0,strlen(\"kernings count\")) == \"kernings count\")             {                //那也得解析啊~                  this->parseKerningCapacity(line);             }              //解析后面的间距调整             else if(line.substr(0,strlen(\"kerning first\")) == \"kerning first\")             {                   //解析间距调整信息                 this->parseKerningEntry(line);             }         }     }     //解析指定索引的图片的说明信息     void CCBMFontConfiguration::parseImageFileName(std::string line, const char *fntFile)     {         //先取得id         int index = line.find('=')+1;         int index2 = line.find(' ', index);         std::string value = line.substr(index, index2-index);                 //这里只使用了第一张图。所以要求索引为0         CCAssert(atoi(value.c_str()) == 0, \"LabelBMFont file could not be found\");         // 取得文件名称         index = line.find('\"')+1;         index2 = line.find('\"', index);         value = line.substr(index, index2-index);         //将文件名对应的全路径存入到字符串m_sAtlasName中         m_sAtlasName = CCFileUtils::fullPathFromRelativeFile(value.c_str(), fntFile);     }     //解析字体介绍信息     void CCBMFontConfiguration::parseInfoArguments(std::string line)     {                 //实际使用中，其实只用到了内边距padding，因为最终显示结果还是需要从图块中获取，既然已经有了图块，那至于字体的字体，大小，是否平滑等信息其实不会影响什么，只是用来做一个说明罢了。         // 内边距padding         int index = line.find(\"padding=\");         int index2 = line.find(' ', index);         std::string value = line.substr(index, index2-index);         sscanf(value.c_str(), \"padding=%d,%d,%d,%d\", &m_tPadding.top, &m_tPadding.right, &m_tPadding.bottom, &m_tPadding.left);         CCLOG(\"cocos2d: padding: %d,%d,%d,%d\", m_tPadding.left, m_tPadding.top, m_tPadding.right, m_tPadding.bottom);     }     //解析字块公共信息     void CCBMFontConfiguration::parseCommonArguments(std::string line)     {         // LineHeight：行高         int index = line.find(\"lineHeight=\");         int index2 = line.find(' ', index);         std::string value = line.substr(index, index2-index);         sscanf(value.c_str(), \"lineHeight=%u\", &m_uCommonHeight);         // scaleW：图片宽         index = line.find(\"scaleW=\") + strlen(\"scaleW=\");         index2 = line.find(' ', index);         value = line.substr(index, index2-index);         CCAssert(atoi(value.c_str()) <= CCConfiguration::sharedConfiguration()->getMaxTextureSize(), \"CCLabelBMFont: page can't be larger than supported\");         // scaleH：图片高         index = line.find(\"scaleH=\") + strlen(\"scaleH=\");         index2 = line.find(' ', index);         value = line.substr(index, index2-index);         CCAssert(atoi(value.c_str()) <= CCConfiguration::sharedConfiguration()->getMaxTextureSize(), \"CCLabelBMFont: page can't be larger than supported\");         // pages:共有几张文字图片供使用         index = line.find(\"pages=\") + strlen(\"pages=\");         index2 = line.find(' ', index);         value = line.substr(index, index2-index);         CCAssert(atoi(value.c_str()) == 1, \"CCBitfontAtlas: only supports 1 page\");         //packed忽略     }     //解析字符编码与UV对应信息块     void CCBMFontConfiguration::parseCharacterDefinition(std::string line, ccBMFontDef *characterDefinition)     {                   //读取编码值         int index = line.find(\"id=\");         int index2 = line.find(' ', index);         std::string value = line.substr(index, index2-index);         sscanf(value.c_str(), \"id=%u\", &characterDefinition->charID);         // 在图块中的像素横向位置         index = line.find(\"x=\");         index2 = line.find(' ', index);         value = line.substr(index, index2-index);         sscanf(value.c_str(), \"x=%f\", &characterDefinition->rect.origin.x);         // 在图块中的像素纵向位置         index = line.find(\"y=\");         index2 = line.find(' ', index);         value = line.substr(index, index2-index);         sscanf(value.c_str(), \"y=%f\", &characterDefinition->rect.origin.y);         // 对应图块的宽         index = line.find(\"width=\");         index2 = line.find(' ', index);         value = line.substr(index, index2-index);         sscanf(value.c_str(), \"width=%f\", &characterDefinition->rect.size.width);         // 对应图块的高         index = line.find(\"height=\");         index2 = line.find(' ', index);         value = line.substr(index, index2-index);         sscanf(value.c_str(), \"height=%f\", &characterDefinition->rect.size.height);         // 当前字在绘制时的像素偏移横向位置         index = line.find(\"xoffset=\");         index2 = line.find(' ', index);         value = line.substr(index, index2-index);         sscanf(value.c_str(), \"xoffset=%d\", &characterDefinition->xOffset);         // 当前字在绘制时的像素偏移纵向位置         index = line.find(\"yoffset=\");         index2 = line.find(' ', index);         value = line.substr(index, index2-index);         sscanf(value.c_str(), \"yoffset=%d\", &characterDefinition->yOffset);         // 绘制完当前字后，光标向后移多少像素以绘制下一个字         index = line.find(\"xadvance=\");         index2 = line.find(' ', index);         value = line.substr(index, index2-index);         sscanf(value.c_str(), \"xadvance=%d\", &characterDefinition->xAdvance);     }     //解析某两个字在一起时字距调整信息并存入哈希字典     void CCBMFontConfiguration::parseKerningCapacity(std::string line)     {         //同样没有什么意义，字数量可以统过后面的解析统计出来     }     //解析字距调整信息     void CCBMFontConfiguration::parseKerningEntry(std::string line)     {               // first解析第一个字         int first;         int index = line.find(\"first=\");         int index2 = line.find(' ', index);         std::string value = line.substr(index, index2-index);         sscanf(value.c_str(), \"first=%d\", &first);         // second:解析第二个字         int second;         index = line.find(\"second=\");         index2 = line.find(' ', index);         value = line.substr(index, index2-index);         sscanf(value.c_str(), \"second=%d\", &second);         // amount:解析要调整的像素个数，负值向左，正值向右         int amount;         index = line.find(\"amount=\");         index2 = line.find(' ', index);         value = line.substr(index, index2-index);         sscanf(value.c_str(), \"amount=%d\", &amount);                 //将对应关系存入哈希字典         tKerningHashElement *element = (tKerningHashElement *)calloc( sizeof( *element ), 1 );         element->amount = amount;         element->key = (first<<16) | (second&0xffff);         HASH_ADD_INT(m_pKerningDictionary,key, element);     }   CCBMFontConfiguration类分析完了，CCLabelBMFont就很容易理解了。快马加鞭向前冲哟~   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class CC_DLL CCLabelBMFont : public CCSpriteBatchNode, public CCLabelProtocol, public CCRGBAProtocol     {         //容量         CC_PROPERTY(GLubyte, m_cOpacity, Opacity)         //颜色         CC_PROPERTY_PASS_BY_REF(ccColor3B, m_tColor, Color)         //是否使用透明度来设置RGB值         CC_PROPERTY(bool, m_bIsOpacityModifyRGB, IsOpacityModifyRGB)     protected:         // 要渲染的字符串         std::string m_sString;         //使用的设置         CCBMFontConfiguration *m_pConfiguration;     public:         //构造函数。         CCLabelBMFont()             : m_cOpacity(0)                       , m_bIsOpacityModifyRGB(false)             , m_sString(\"\")              , m_pConfiguration(NULL)         {}         //析构         virtual ~CCLabelBMFont();         //释放占用的内存         static void purgeCachedData();         //由一个字符串和字体fnt文件创建图字         bool initWithString(const char *str, const char *fntFile);         //重点函数：根据字符串和字体信息进行纹理图对应         void createFontChars();         //设置要渲染的字符串         virtual void setString(const char *label);         //取得要渲染的字符串         virtual const char* getString(void);         //设置要渲染的字符串，setString的别名函数         virtual void setCString(const char *label);         //设置锚点         virtual void setAnchorPoint(const CCPoint& var);         //绘制函数 #if CC_LABELBMFONT_DEBUG_DRAW         virtual void draw(); #endif // CC_LABELBMFONT_DEBUG_DRAW     private:         char * atlasNameFromFntFile(const char *fntFile);         int kerningAmountForFirst(unsigned short first, unsigned short second);     };   CPP文件:   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499     //释放占用的内存     void CCLabelBMFont::purgeCachedData()     {         //释放文字FNT信息指针         FNTConfigRemoveCache();     }     //静态函数：由一个字符串和字体fnt文件创建图字     CCLabelBMFont *CCLabelBMFont::labelWithString(const char *str, const char *fntFile)     {         //new 出一个新的CCLabelBMFont         CCLabelBMFont *pRet = new CCLabelBMFont();         //调用其成员函数initWithString创建图字         if(pRet && pRet->initWithString(str, fntFile))         {             //交由内存管理器进行内存管理。             pRet->autorelease();             return pRet;         }         CC_SAFE_DELETE(pRet)         return NULL;     }     //由一个字符串和字体fnt文件创建图字     bool CCLabelBMFont::initWithString(const char *theString, const char *fntFile)     {           //有效性判断         CCAssert(theString != NULL, \"\");         CC_SAFE_RELEASE(m_pConfiguration);// allow re-init         //调用FNTConfigLoadFile读取Fnt文件并返回出信息的内存地址给指针变量m_pConfiguration         m_pConfiguration = FNTConfigLoadFile(fntFile);         //用到它就给它的引用计数器加1         m_pConfiguration->retain();         //有效性判断         CCAssert( m_pConfiguration, \"Error creating config for LabelBMFont\");         //由信息指针取得字体图和字符串长度来初始化图块集管理器。         if (CCSpriteBatchNode::initWithFile(m_pConfiguration->m_sAtlasName.c_str(), strlen(theString)))         {             //如果成功，容量设为255             m_cOpacity = 255;             //使用白色             m_tColor = ccWHITE;             //m_tContentSize是CCNode中变量，为结点原始大小，不受矩阵变换影响，这里初始化为零大小             m_tContentSize = CCSizeZero;             //如果纹理有Alpha通道，则使用透明度设置RGB值。             m_bIsOpacityModifyRGB = m_pobTextureAtlas->getTexture()->getHasPremultipliedAlpha();             //设置锚点在正中心             setAnchorPoint(ccp(0.5f, 0.5f));             //设置字符串             this->setString(theString);             return true;         }         return false;     }     //析构函数     CCLabelBMFont::~CCLabelBMFont()     {         //释放字符串容器，释放         m_sString.clear();         CC_SAFE_RELEASE(m_pConfiguration);     }     // 由参1和参2组成key从哈希表中找到元素的数量。     int CCLabelBMFont::kerningAmountForFirst(unsigned short first, unsigned short second)     {         int ret = 0;         //将两个字合并为双字做为key来进行哈希表查找         unsigned int key = (first<<16) | (second & 0xffff);         //如果Fnt信息中有字距调整信息         if( m_pConfiguration->m_pKerningDictionary ) {             //使用哈希算法找到对应的字距信息值             tKerningHashElement *element = NULL;             HASH_FIND_INT(m_pConfiguration->m_pKerningDictionary, &key, element);                   //如果找到返回             if(element)                 ret = element->amount;         }         return ret;     }     //计算Char对应的UTF8码的掩码和长度     #define UTF8_COMPUTE(Char, Mask, Len)       \\       if (Char < 128)               \\         {                       \\           Len = 1;                  \\           Mask = 0x7f;              \\         }                       \\       else if ((Char & 0xe0) == 0xc0)       \\         {                       \\           Len = 2;                  \\           Mask = 0x1f;              \\         }                       \\       else if ((Char & 0xf0) == 0xe0)       \\         {                       \\           Len = 3;                  \\           Mask = 0x0f;              \\         }                       \\       else if ((Char & 0xf8) == 0xf0)       \\         {                       \\           Len = 4;                  \\           Mask = 0x07;              \\         }                       \\       else if ((Char & 0xfc) == 0xf8)       \\         {                       \\           Len = 5;                  \\           Mask = 0x03;              \\         }                       \\       else if ((Char & 0xfe) == 0xfc)       \\         {                       \\           Len = 6;                  \\           Mask = 0x01;              \\         }                       \\       else                      \\         Len = -1;     //计算Char对应的UTF8码的长度     #define UTF8_LENGTH(Char)           \\       ((Char) < 0x80 ? 1 :              \\        ((Char) < 0x800 ? 2 :            \\         ((Char) < 0x10000 ? 3 :         \\          ((Char) < 0x200000 ? 4 :           \\           ((Char) < 0x4000000 ? 5 : 6)))))     //取得Char对应的UTF8码     #define UTF8_GET(Result, Chars, Count, Mask, Len)   \\       (Result) = (Chars)[0] & (Mask);           \\       for ((Count) = 1; (Count) < (Len); ++(Count))     \\         {                           \\           if (((Chars)[(Count)] & 0xc0) != 0x80)        \\         {                       \\           (Result) = -1;                \\           break;                    \\         }                       \\           (Result) <<= 6;                   \\           (Result) |= ((Chars)[(Count)] & 0x3f);        \\         }     //判断Char是否是有效的Unicode码     #define UNICODE_VALID(Char)         \\       ((Char) < 0x110000 &&             \\        (((Char) & 0xFFFFF800) != 0xD800) &&     \\        ((Char) < 0xFDD0 || (Char) > 0xFDEF) &&  \\        ((Char) & 0xFFFE) != 0xFFFE)     //用于获取UTF8下个字符的编码偏移。     static const char utf8_skip_data[256] = {       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,       1, 1, 1, 1, 1, 1, 1,       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,       1, 1, 1, 1, 1, 1, 1,       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,       1, 1, 1, 1, 1, 1, 1,       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,       1, 1, 1, 1, 1, 1, 1,       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,       1, 1, 1, 1, 1, 1, 1,       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,       1, 1, 1, 1, 1, 1, 1,       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,       2, 2, 2, 2, 2, 2, 2,       3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5,       5, 5, 5, 6, 6, 1, 1     };     static const char *const g_utf8_skip = utf8_skip_data;     //取得UTP8编码字符的下一个字符。     #define cc_utf8_next_char(p) (char *)((p) + g_utf8_skip[*(unsigned char *)(p)])    //返回取得字符串转换为UTF8后的字符长度     static long     cc_utf8_strlen (const char * p, int max)     {       long len = 0;       const char *start = p;       if (!(p != NULL || max == 0))       {           return 0;       }       if (max < 0)         {           while (*p)         {           p = cc_utf8_next_char (p);           ++len;         }         }       else         {           if (max == 0 || !*p)         return 0;           p = cc_utf8_next_char (p);           while (p - start < max && *p)         {           ++len;           p = cc_utf8_next_char (p);         }           /* only do the last len increment if we got a complete            * char (don't count partial chars)            */           if (p - start == max)         ++len;         }       return len;     }     //将Unicode编码字符串p转换为UTF8编码     static unsigned int     cc_utf8_get_char (const char * p)     {       int i, mask = 0, len;       unsigned int result;       unsigned char c = (unsigned char) *p;       UTF8_COMPUTE (c, mask, len);       if (len == -1)         return (unsigned int) - 1;       UTF8_GET (result, p, i, mask, len);       return result;     }     //重点函数：由字符串和字编码纹理块对应信息设置到     void CCLabelBMFont::createFontChars()     {         int nextFontPositionX = 0;  //下一个字的横向绘制位置        int nextFontPositionY = 0;   //下一个字的纵向绘制位置         unsigned short prev = -1;   //上一个字编码         int kerningAmount = 0;      //字间距调整的像素数量         CCSize tmpSize = CCSizeZero;//         int longestLine = 0;        // 最长的一行的宽度         unsigned int totalHeight = 0;//字符串的总高度         unsigned int quantityOfLines = 1;          //如果字符串长度为零直接返回         if (0 == m_sString.length())         {             return;         }          //取得字符串转换为UTF8后的字符长度         int utf8len = cc_utf8_strlen(m_sString.c_str(), -1);         if (utf8len == 0)         {             return;         }         //将字符串转换为UTF8的字符串         unsigned short* pUniStr = new unsigned short[utf8len+1];         pUniStr[utf8len] = 0;         const char* p = m_sString.c_str();         for (int i = 0; i < utf8len; ++i)         {             pUniStr[i] = cc_utf8_get_char(p);             p = cc_utf8_next_char (p);         }         unsigned int stringLen = cc_wcslen(pUniStr);         //统计行数         for (unsigned int i = 0; i < stringLen - 1; ++i)         {             unsigned short c = pUniStr[i];             if (c == '\\n')             {                 quantityOfLines++;             }         }         //由行高乘行数最得要显示的字符串占用的总高度         totalHeight = m_pConfiguration->m_uCommonHeight * quantityOfLines;         //统计字符串的起始位置高度         nextFontPositionY = -(m_pConfiguration->m_uCommonHeight - m_pConfiguration->m_uCommonHeight * quantityOfLines);         //遍历所有的字         for (unsigned int i= 0; i < stringLen; i++)         {             unsigned short c = pUniStr[i];             if (c == '\\n')             {                   //如果遇到换行符则进行换行处理                 nextFontPositionX = 0;                 nextFontPositionY -= m_pConfiguration->m_uCommonHeight;                 continue;             }             //查找是当前字的纹理映射信息结点             std::map<unsigned int, ccBMFontDef>::iterator it = m_pConfiguration->m_pBitmapFontArray->find(c);             CCAssert(it != m_pConfiguration->m_pBitmapFontArray->end(), \"LabelBMFont: character is not supported\");             //根据上一个字与当前字进行间距调整信息哈希表的查找，返回调整的像素偏移量。             kerningAmount = this->kerningAmountForFirst(prev, c);             //取得当前字的纹理映射信息结点             const ccBMFontDef& fontDef = (*(m_pConfiguration->m_pBitmapFontArray))[c];             //取得当前字在贴图上的像素矩形             CCRect rect = fontDef.rect;             //取得对应当前字的精灵             CCSprite *fontChar;             fontChar = (CCSprite*)(this->getChildByTag(i));                         if( ! fontChar )             {                 //如果找不到，则新建精灵，并将纹理上对应像素块信息传给精灵进行初始化。                 fontChar = new CCSprite();                 fontChar->initWithBatchNodeRectInPixels(this, rect);                 //将精灵加入到子结点，设置i为附带查找唯一ID                 this->addChild(fontChar, 0, i);                 fontChar->release();             }             else             {                 // 将纹理上对应像素块信息传给精灵。                                 fontChar->setTextureRectInPixels(rect, false, rect.size);                 //设置其显示，完全不透明。                 fontChar->setIsVisible(true);                 fontChar->setOpacity(255);             }             //设置字的纵向偏移            float yOffset = (float)(m_pConfiguration->m_uCommonHeight) - fontDef.yOffset;             //计算字的位置,注意：因为锚点设的精灵正中心，所以位置应该是左下角位置加上大小的一半再进行相关偏移和间距调整计算。             fontChar->setPositionInPixels( ccp( nextFontPositionX + fontDef.xOffset + fontDef.rect.size.width / 2.0f + kerningAmount,                                                 (float) nextFontPositionY + yOffset - rect.size.height/2.0f ) );                    //      NSLog(@\"position.y: %f\", fontChar.position.y);             // 更新绘制下一个字的横向位置             nextFontPositionX += (*(m_pConfiguration->m_pBitmapFontArray))[c].xAdvance + kerningAmount;             //更新上一个字符供循环再次使用             prev = c;             // 设置是否用透明度设置色彩                                             fontChar->setIsOpacityModifyRGB(m_bIsOpacityModifyRGB);             //设置色彩，             fontChar->setColor(m_tColor);             //如果透明度小于255，设置透明度             if( m_cOpacity != 255 )             {                 fontChar->setOpacity(m_cOpacity);             }             //取得最长的一行的宽度             if (longestLine < nextFontPositionX)             {                 longestLine = nextFontPositionX;             }         }         //设置当前字符串在屏幕上占用的矩形位置          tmpSize.width  = (float) longestLine;         tmpSize.height = (float) totalHeight;         //调用基类CCNode的函数设置为原始大小         this->setContentSizeInPixels(tmpSize);         //释放字符串         CC_SAFE_DELETE_ARRAY(pUniStr);     }     //LabelBMFont重载基类 CCLabelProtocol的接口函数     //设置字符串     void CCLabelBMFont::setString(const char *newString)     {           //将newString保存入字符串成员变量m_sString         m_sString.clear();         m_sString = newString;         //因CCLabelBMFont派生于CCSpriteBatchNode，m_pChildren为其子节点数组，这里进行遍历将其所有显示中的字精灵都设为不显示         if (m_pChildren && m_pChildren->count() != 0)         {             CCObject* child;             CCARRAY_FOREACH(m_pChildren, child)             {                 CCNode* pNode = (CCNode*) child;                 if (pNode)                 {                     pNode->setIsVisible(false);                 }             }         }         //重新由字符串和字体信息创建要显示的字精灵         this->createFontChars();     }     //取得字符串     const char* CCLabelBMFont::getString(void)     {         return m_sString.c_str();     }     // setString别名函数     void CCLabelBMFont::setCString(const char *label)     {         setString(label);     }     //LabelBMFont 重载基类 CCRGBAProtocol 的接口函数     //设置颜色     void CCLabelBMFont::setColor(const ccColor3B& var)     {         m_tColor = var;         //因CCLabelBMFont派生于CCSpriteBatchNode，m_pChildren为其子节点数组，这里进行遍历设置         if (m_pChildren && m_pChildren->count() != 0)         {             CCObject* child;             CCARRAY_FOREACH(m_pChildren, child)             {                 CCSprite* pNode = (CCSprite*) child;                 if (pNode)                 {                     pNode->setColor(m_tColor);                 }             }         }     }     //取得颜色     const ccColor3B& CCLabelBMFont::getColor()     {         return m_tColor;     }     //设置透明度     void CCLabelBMFont::setOpacity(GLubyte var)     {         m_cOpacity = var;         if (m_pChildren && m_pChildren->count() != 0)         {             CCObject* child;             CCARRAY_FOREACH(m_pChildren, child)             {                 CCNode* pNode = (CCNode*) child;                 if (pNode)                 {                     CCRGBAProtocol *pRGBAProtocol = dynamic_cast<CCRGBAProtocol*>(pNode);                     if (pRGBAProtocol)                     {                         pRGBAProtocol->setOpacity(m_cOpacity);                     }                 }             }         }     }     //取得透明度     GLubyte CCLabelBMFont::getOpacity()     {         return m_cOpacity;     }     //设置是否使用透明度设置RGB值     void CCLabelBMFont::setIsOpacityModifyRGB(bool var)     {         m_bIsOpacityModifyRGB = var;         if (m_pChildren && m_pChildren->count() != 0)         {             CCObject* child;             CCARRAY_FOREACH(m_pChildren, child)             {                 CCNode* pNode = (CCNode*) child;                 if (pNode)                 {                       //因子结点即是精灵CCSprite，CCSprite又派生于CCRGBAProtocol，故进行转换                     CCRGBAProtocol *pRGBAProtocol = dynamic_cast<CCRGBAProtocol*>(pNode);                     if (pRGBAProtocol)                     {                      //调用setIsOpacityModifyRGB进行设置 pRGBAProtocol->setIsOpacityModifyRGB(m_bIsOpacityModifyRGB);                     }                 }             }         }     }     //取得是否使用透明度设置RGB值     bool CCLabelBMFont::getIsOpacityModifyRGB()     {         return m_bIsOpacityModifyRGB;     }     // 设置锚点     void CCLabelBMFont::setAnchorPoint(const CCPoint& point)     {         if( ! CCPoint::CCPointEqualToPoint(point, m_tAnchorPoint) )         {             CCSpriteBatchNode::setAnchorPoint(point);             this->createFontChars();         }     }     //绘制图字标签,Debug模式下手动调用绘制 #if CC_LABELBMFONT_DEBUG_DRAW     void CCLabelBMFont::draw()     {         //绘制图块集         CCSpriteBatchNode::draw();         //绘制边框         const CCSize& s = this->getContentSize();         CCPoint vertices[4]={             ccp(0,0),ccp(s.width,0),             ccp(s.width,s.height),ccp(0,s.height),         };         ccDrawPoly(vertices, 4, true);     } #endif // CC_LABELBMFONT_DEBUG_DRAW }   照例做个总结： 1． 图字的原理：将所要绘制的字绘制到图片上，通过编码取得对应的矩形块UV进行顶点缓冲的设置之后进行绘制。Cocos2d-x提供的两个类非常重要：(1) CCTextureAtlas(2) CCSpriteBatchNode。 2． 图字的组成：一张纹理，一个纹理描述信息文件。缺一不可。要做好图字，必须深入理解图字纹理描述信息文件的格式,可能看Cocos2d-x提供的类: CCBMFontConfiguration，并掌握图字工具的使用。 呃，网上提供了一些图字工具，比较常用的有 Hiero:      ","title":"cocos2d-x 文本框"},{"content":"TextView实现文字滚动需要以下几个要点： 1、文字长度长于可显示范围：android:singleLine=\"true\"； 2、设置可滚到，或显示样式：android:ellipsize=\"marquee\"； 3、TextView只有在获取焦点后才会滚动显示隐藏文字，所以可以重写TextView类。(但是一直给予焦点可能会导致其不能被点击，如放在listView中的时候) public class AlwaysMarqueeTextView extends TextView { public AlwaysMarqueeTextView(Context context) { super(context); } public AlwaysMarqueeTextView(Context context, AttributeSet attrs) { super(context, attrs); } public AlwaysMarqueeTextView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); } //始终返回true，即一直获得焦点 @Override public boolean isFocused() { return true; } 布局文件中的TextView添加： android:singleLine =“true” android:focusable=“true” android:marqueeRepeatLimit=“marquee_forever” //滚动次数，此时为无数次 android:ellipsize =“marquee” ellipsize属性 设置当文字过长时,该控件该如何显示。有如下值设置：”start”—–省略号显示在开头；”end”——省略号显示在结尾；”middle”—-省略号显示在中间；”marquee” ——以跑马灯的方式显示(动画横向移动)","title":"TextView文字横向滚动（跑马灯效果）"},{"content":"  菜单栏 Help-- (MyEclipse)Find and Install-- 按new Remote Site,  菜单栏 Help-- (Eclipse)Install New Software -- 按add, Name填 svn , URL填http://subclipse.tigris.org/update ,一直next到finished为止  菜单栏 Window-- Show View-- other-- 选择打开SVN目录下的SVN资源库  新建-- 资源库位置, URL填http://svn.javascud.org/svn/springside/trunk  完成后点finished开始下载svn插件  下载后安装然后重启eclipse","title":"Eclipse在线安装svn插件"},{"content":"     之前为了让自己对移动开发有更深入的了解，在自己的MacBook Pro下通过bootCamp安装了一个100G的win7系统，用来学习android。      今天正值元旦假期前的最后一天，文艺的公司放5天假，但为了显示低调，我们采取普通的做法，给自己放三天假。邻桌的桂芳很不厚道的用自个的烂鼠标换走了我刚买不久的ThinkPad激光鼠标，实在没法把玩他的鼠标，万般无奈只好把玩把玩老阳的正品apple鼠标。       弄了很久，查了很多资料，发现还是不行，最后终于找到了方案。      1.在之前装bootCamp的时候，附带了win7下apple magic mouse的驱动，你可以在任务栏上找到蓝牙设备的图标，右键选择菜单里的“显示BlueTooth设备”，能看到apple magic mouse设备就说明已经连接好。     2.如果此时鼠标移动还没反应，按apple magic mouse左键5秒，就可以正常使用了","title":"MacBook Pro win7系统下使用 苹果鼠标 apple mouse"},{"content":"在AndroidManifest.xml文件中要添加 <uses-permission android:name=\"android.permission.READ_PHONE_STATE\" />  才有权限 TelephonyManager tm = (TelephonyManager) this.getSystemService(TELEPHONY_SERVICE);                 /*       * 电话状态：       * 1.tm.CALL_STATE_IDLE=0          无活动       * 2.tm.CALL_STATE_RINGING=1  响铃       * 3.tm.CALL_STATE_OFFHOOK=2  摘机       */       tm.getCallState();//int                 /*       * 电话方位：       *        */       tm.getCellLocation();//CellLocation                 /*       * 唯一的设备ID：       * GSM手机的 IMEI 和 CDMA手机的 MEID.        * Return null if device ID is not available.       */       tm.getDeviceId();//String                 /*       * 设备的软件版本号：       * 例如：the IMEI/SV(software version) for GSM phones.       * Return null if the software version is not available.        */       tm.getDeviceSoftwareVersion();//String                 /*       * 手机号：       * GSM手机的 MSISDN.       * Return null if it is unavailable.        */       tm.getLine1Number();//String                 /*       * 附近的电话的信息:       * 类型：List<NeighboringCellInfo>        * 需要权限：android.Manifest.permission#ACCESS_COARSE_UPDATES       */       tm.getNeighboringCellInfo();//List<NeighboringCellInfo>                 /*       * 获取ISO标准的国家码，即国际长途区号。       * 注意：仅当用户已在网络注册后有效。       *       在CDMA网络中结果也许不可靠。       */       tm.getNetworkCountryIso();//String                 /*       * MCC+MNC(mobile country code + mobile network code)       * 注意：仅当用户已在网络注册时有效。       *    在CDMA网络中结果也许不可靠。       */       tm.getNetworkOperator();//String                 /*       * 按照字母次序的current registered operator(当前已注册的用户)的名字       * 注意：仅当用户已在网络注册时有效。       *    在CDMA网络中结果也许不可靠。       */       tm.getNetworkOperatorName();//String                 /*       * 当前使用的网络类型：       * 例如： NETWORK_TYPE_UNKNOWN  网络类型未知  0         NETWORK_TYPE_GPRS     GPRS网络  1         NETWORK_TYPE_EDGE     EDGE网络  2         NETWORK_TYPE_UMTS     UMTS网络  3         NETWORK_TYPE_HSDPA    HSDPA网络  8          NETWORK_TYPE_HSUPA    HSUPA网络  9         NETWORK_TYPE_HSPA     HSPA网络  10         NETWORK_TYPE_CDMA     CDMA网络,IS95A 或 IS95B.  4         NETWORK_TYPE_EVDO_0   EVDO网络, revision 0.  5         NETWORK_TYPE_EVDO_A   EVDO网络, revision A.  6         NETWORK_TYPE_1xRTT    1xRTT网络  7       */       tm.getNetworkType();//int                 /*       * 手机类型：       * 例如： PHONE_TYPE_NONE  无信号         PHONE_TYPE_GSM   GSM信号         PHONE_TYPE_CDMA  CDMA信号       */       tm.getPhoneType();//int                 /*       * Returns the ISO country code equivalent for the SIM provider's country code.       * 获取ISO国家码，相当于提供SIM卡的国家码。       *        */       tm.getSimCountryIso();//String                 /*       * Returns the MCC+MNC (mobile country code + mobile network code) of the provider of the SIM. 5 or 6 decimal digits.       * 获取SIM卡提供的移动国家码和移动网络码.5或6位的十进制数字.       * SIM卡的状态必须是 SIM_STATE_READY(使用getSimState()判断).       */       tm.getSimOperator();//String                 /*       * 服务商名称：       * 例如：中国移动、联通       * SIM卡的状态必须是 SIM_STATE_READY(使用getSimState()判断).       */       tm.getSimOperatorName();//String                 /*       * SIM卡的序列号：       * 需要权限：READ_PHONE_STATE       */       tm.getSimSerialNumber();//String                 /*       * SIM的状态信息：       *  SIM_STATE_UNKNOWN          未知状态 0       SIM_STATE_ABSENT           没插卡 1       SIM_STATE_PIN_REQUIRED     锁定状态，需要用户的PIN码解锁 2       SIM_STATE_PUK_REQUIRED     锁定状态，需要用户的PUK码解锁 3       SIM_STATE_NETWORK_LOCKED   锁定状态，需要网络的PIN码解锁 4       SIM_STATE_READY            就绪状态 5       */       tm.getSimState();//int                 /*       * 唯一的用户ID：       * 例如：IMSI(国际移动用户识别码) for a GSM phone.       * 需要权限：READ_PHONE_STATE       */       tm.getSubscriberId();//String                 /*       * 取得和语音邮件相关的标签，即为识别符       * 需要权限：READ_PHONE_STATE       */       tm.getVoiceMailAlphaTag();//String                 /*       * 获取语音邮件号码：       * 需要权限：READ_PHONE_STATE       */       tm.getVoiceMailNumber();//String                 /*       * ICC卡是否存在       */       tm.hasIccCard();//boolean                 /*       * 是否漫游:       * (在GSM用途下)       */      tm.isNetworkRoaming();//boolean     ","title":"Android 获取imei号码，获取手机型号和系统版本号等信息"},{"content":"在BB10 Cascades开发中，界面元素一般都是通过QML建构，虽然在QML中可以使用JavaScript完成一些计算，不过这不足以支持一个复杂的应用。在很多情况下，我们需要在QML中访问C++中的数据和方法。特别是当我们使用MVC模式的时候，使用C++建构Model和Controller，而使用QML建构View时，就更需要从QML中访问C++中的数据和方法。   首先我们来看看如何在QML中访问直接访问C++中的数据，有关QML中访问C++对象的方法和数据的方法我们在以后的文章中讨论。 如果需要在QML中访问C++中的数据，首先我们需要将数据暴露给QML。把C++数据暴露给QML的一个简单方法是使用QDeclarativePropertyMap类。 QDeclarativePropertyMap类是一个Map容器类，在C++中可以通过insert方法将数据插入到该容器中，插入的形式是一个常见的“关键字-值”的形式。 有关QDeclarativePropertyMap对象的定义和数据的插入请参考下面的C++代码： QDeclarativePropertyMap* propertyMap = new QDeclarativePropertyMap;propertyMap->insert(\"mykey1\", QVariant(QString(\"value1\"))); propertyMap->insert(\"mykey2\", QVariant(QString(\"value2\")));      以上代码创建了一个QDeclarativePropertyMap对象，赋予propertyMap变量。 然后通过调用propertyMap的insert方法插入了两个数据，值分别是“value1”和\"value2\"，它们的关键字分别是“mykey1”和“mykey2”。   创建了QDeclarativePropertyMap对象后，就可以通过QmlDocument对象的setContentProperty方法将QDeclarativePropertyMap对象暴露给指定的QML文档对象，如以下代码： QmlDocument *qml = QmlDocument::create(\"asset:///main.qml\");     qml->setContextProperty(\"myProperty\", propertyMap);   以上代码创建了一个QmlDocument对象，对应的QML文档是mail.qml。 然后通过setContentProperty方法将上面创建的propertyMap对象暴露给mail.qml。   这样在mail.qml中就可以访问propertyMap对象中的数据了，如以下代码： Label {    text: \"value of mykey1: \" + myProperty.mykey1 } Label {  text: \"value of mykey2: \" + myProperty.mykey2 }  以上代码运行时，mail.qml加载后会在两个标签字段显示C++中设置的“mykey1”和“mykey2”对应的两个数据，分别是\"value1\"和“value2”。 大家可以通过简单修改Hello World样例来测试以上代码。      ","title":"BB10 Cascades: 如何在QML中访问C++中的数据。"},{"content":"原理：在程序切入到后台后，每十分钟就去执行一个动作来唤醒程序，由此来保证它一直在后台运行。 1、在Info.plist中添加UIBackgroundModes 键值 让系统知道你的应用程序应该在适当的时候被唤醒 2、在 - (void)applicationDidEnterBackground:(UIApplication *)application  切入后台执行的方法中执行下面代码 [[UIApplication sharedApplication]setKeepAliveTimeout:600    handler:^{        //执行的代码    }]; handler 里面可以去实现执行一个本地的推送，也可以去执行某个动作，总之是起到唤醒程序的目的即可","title":"IOS成长之路-程序在后台运行（voip）"},{"content":"当你的应用需要支持很多种屏幕尺寸，你可以在不同的布局配置中重用你的Fragment组件在可用的屏幕尺寸上优化用户体验。 例如，在手持设备中一次只显示一个Fragment可能是一个合适的选择，当然在Pad设备中将两个Fragment拼在一起来填满更大尺寸的屏幕，同时为用户显示更多的信息。 在上图中，两个Fragment，配合不同的配置显示在不同尺寸的屏幕上的效果。 FragmentManager类提供了运行时在Activity上添加，移除或者替换Fragment的方法，从而可以制造出动态的体验。 在运行的Activity中添加一个Fragment 你可以在运行中的Activity中添加Fragment，如果你想在Activity的生命周期中改变Fragment。 FragmentManager类提供了运行时在Activity上添加，移除或者替换Fragment的方法，从而可以制造出动态的体验。 如果你的Activity允许Fragment被移除和替换，你需要在Activity的onCreate方法中添加初始化的Fragment(s)。 一个处理Fragment的重要原则，Fragment必须有一个在布局中有一个让其寄存的View容器，特别是对那些运行时的Fragment。 以下是一个布局文件，每次显示一个Fragment。为了用一个Fragment替换另外一个，Activity的布局文件包含一个空的FrameLayout，作为Fragment容器使用。 res/layout/news_articles.xml: <FrameLayoutxmlns:android=\"http://schemas.android.com/apk/res/android\"    android:id=\"@+id/fragment_container\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\" /> . 在Activity当中，利用getSupportFragmentManager()获取一个FragmentManager，以下是代码示例： import android.os.Bundle; import android.support.v4.app.FragmentActivity;   public class MainActivity extends FragmentActivity {     @Override     public voidonCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);         setContentView(R.layout.news_articles);           // Checkthat the activity is using the layout version with         // thefragment_container FrameLayout         if(findViewById(R.id.fragment_container) != null) {               //However, if we're being restored from a previous state,             // thenwe don't need to do anything and should return or else             // wecould end up with overlapping fragments.             if(savedInstanceState != null) {                return;             }               // Create an instance of ExampleFragment            HeadlinesFragment firstFragment = new HeadlinesFragment();                         // Incase this activity was started with special instructions from an Intent,             // passthe Intent's extras to the fragment as arguments            firstFragment.setArguments(getIntent().getExtras());                         // Addthe fragment to the 'fragment_container' FrameLayout            getSupportFragmentManager().beginTransaction()                     .add(R.id.fragment_container,firstFragment).commit();         }     } } Fragment替换 替换Fragment的流程和添加的流程类似，只不过需要利用replace方法替换add方法。 需要记住的是，当你是Fragment切换的时候，例如替换或者一处，最好让用户拥有返回或者撤销的机会 当你允许用户返回或者撤销Fragment操作的时候，你必须在调用FragmentTransaction之前调用addToBackStack。 以下是一个示例： // Create fragment and give it an argument specifying thearticle it should show ArticleFragment newFragment = new ArticleFragment(); Bundle args = new Bundle(); args.putInt(ArticleFragment.ARG_POSITION, position); newFragment.setArguments(args);   FragmentTransaction transaction =getSupportFragmentManager().beginTransaction();   // Replace whatever is in the fragment_container viewwith this fragment, // and add the transaction to the back stack so the usercan navigate back transaction.replace(R.id.fragment_container,newFragment); transaction.addToBackStack(null);   // Commit the transaction transaction.commit();","title":"Fragment的概念与使用(二）--构建灵活的Android应用UI"},{"content":"1、打开本地推送并设置属性 NSString *str = @\"本地推送的信息\";    UIApplication *app = [UIApplication sharedApplication];    UILocalNotification *notification = [[UILocalNotification alloc]init];//初始化本地推送    notification.soundName = UILocalNotificationDefaultSoundName;//设置声音    notification.alertBody = str;//设置推送的消息    [app scheduleLocalNotification:notification];//实现本地推送的关键步骤，    [notification release];    [str release];通过上面的方法可以实现推送的效果 2、本地推送的接受方法  - (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification","title":"IOS成长之路-推送（本地推送）"},{"content":"过去一年，全球智能手机芯片市场迎来了爆发性增长。美国市场研究公司Strategy Analytics的报告显示，仅2012年上半年全球智能手机芯片市场规模就达到55亿美元，同比增长61%。 　　回顾2012年智能手机芯片市场发展，毫无疑问，ARM阵营仍然是胜利者。截止目前，基于ARM架构的芯片在全球智能手机市场上的份额已经超过95%，其中高通、三星、联发科等厂商都业绩不俗。 　　长期而言，智能手机芯片市场具有成长潜力。不过，随着英特尔这样具备资金、品牌等优势的厂商参战，这个市场也开始由蓝海转向红海。 　　2012年，德州仪器宣布把投资重点从移动芯片转向更广泛的工业市场，这一举动被业界视为智能手机芯片市场洗牌的开始。2013年，智能手机芯片竞争势必会更加激烈。 　　ARM：稳固扩充地盘 　　2012年，笑得最开心的应该是芯片设计厂商ARM。这家总部在英国的公司设计高性能、廉价、耗能低的处理器方案，并将其授权给第三方合作伙伴，第三方合作生产基于ARM架构芯片，ARM则按芯片价格与出货量获得一次性授权费与版税提成。 　　目前，基于ARM的芯片在全球智能手机市场上的份额已经超过95%，而ARM靠着向合作伙伴授权不断升级的芯片设计方案，业绩持续保持快速增长，股价也连创新高。 　　2012年，ARM股价上涨近40%，并且还侵入了服务器和PC市场，持续给英特尔施加压力。 　　高通：风光无限 　　过去一年，高通无疑是最为风光的芯片厂商。高通不但拿下全球智能手机芯片市场近半市场份额，凭借在3G领域积累的专利，还赚取了大量利润，并在资本市场上力压英特尔成为全球市值最大的芯片厂商。 　　市场研究公司IHS iSuppli预计，高通今年的营收将获得27.2%的增长，达到129亿美元，首次成为全球营收第三大芯片厂商，仅次于前两位的英特尔和三星。 　　2012年，在前10大半导体厂商中，有7家营收都将出现下降。两年前，高通仅仅只是全球第九大半导体厂商。高通在芯片市场地位的提升表明了移动设备的重要性。 　　2013年，随着智能手机的进一步普及和价格下降，高通将面临更多中低端芯片厂商的挑战，如何保持较高的毛利率是个问题。 　　联发科：重回快车道 　　2012年，联发科的发展重新回到快车道。通过向中小手机厂商提供高度整合性的“交钥匙(Turn-Key)”方案，联发科抓住了中国千元智能机的机遇，预计2012年，芯片出货量将会超过1亿颗。 　　市场调研公司Strategy Analytics的报告显示，2012年第一季度手机应用处理器市场中，MTK挤进前五，但在第三季度已经挤进市场前三。 　　不过，随着高通、展讯等厂商在中低端市场推出同样的“交钥匙(Turn-Key)”方案，联发科也势必将面临更为激烈的竞争。2013年，中低端智能手机芯片市场预计将会刺刀见红。 　　德州仪器：黯然退出 　　有人风光，也有人落寞。因为市场竞争激烈，毛利率下降，德州仪器在2012年成为第一家退出智能手机芯片市场的厂商。德州仪器并未亲口承认，但是将更多投资转向汽车生产商等工业客户的策略，显示这家厂商事实上已经退出。 　　由于缺乏完整的解决方案(德州仪器的应用处理器很出色，但缺少基带芯片业务)，德州仪器在智能手机芯片市场的份额不断下降，运营亏损也持续扩大。虽然寻求过出售，但最终还是无人接盘。 　　德州仪器的退出实际上颇为无奈。往高端智能手机芯片市场发展，德州仪器很难与高通、三星等展开竞争；而如果往低端市场发展，又竞争不过联发科、展讯等厂商。与其持续亏损，还不如早点退出。 　　英特尔：迈出第一步 　　智能手机芯片市场像一座“围城”，城中的企业想出去，城外的企业却想着冲进来，英特尔就是后者。这家在PC市场遥遥领先的芯片厂商在这一年再次吹响了进军移动领域的号角。 　　在被英特尔称作是“证明”的一年里，英特尔拿出了满意的成绩：7款搭载英特尔芯片的智能手机和多款Windows 8 平板电脑。在产品和性能上，英特尔已经证明了自己，但赢得更多合作伙伴的支持将是一场“持久战”。 　　没有人怀疑英特尔在移动领域的决心，但是在解决能耗等问题上，英特尔需要再快一些。 　　2013年，智能手机芯片产业预计还会继续快速增长，但市场竞争激烈程度肯定将会升级。随着4G通信技术的普及，专利、资金等都将成为重要的竞争要素，而这无疑决定，只有少数企业才是最终的玩家。   Android开发环境搭建所需资源、安装步骤图解        Android海量源码、教程与资料   数字电视接口规范大全（行业标准）                      程序员必备：英语口语学习教程大全  20本Linux电子书学习教程                    2013年25家IT高科技公司薪酬排行榜   2013年Android平台8大预测                   优秀Android开发人员必须注意的10个误区  Android开发应该掌握的28大内容和10大建议      成为“Android高手”的6个境界  90后就业“钱景”分析:IT行业仍是最佳选择       90后就业“钱景”:IT仍是最佳选择 -------------------------------------------------------------------------------------------------------------- 终生受益的43个健康常识--值得珍藏                           面试如何着装：不同职位穿着大不同      2013年国内就业率最高的50个本科专业排名              女生面试如何着装及禁忌    50个“最有钱景专业”的毕业生年薪一览表               毕业后头5年决定你的一生  千万别熬夜:身体器官晚上工作时间表一览                  90后就业“钱景”:IT仍是最佳选择     --------------------------------------------------------------------------------------------------------------  211工程大学最新名单(共112所)                              985工程大学最新名单(共39所)  中国“国家实验室”最新名单（共20所）                 “特色985”大学最新名单（共29所）  2013年国内工科大学排名100强名单                          2013年中国大学580强排行榜  女孩教你追女孩的终极技巧                                       2013年世界各国人均GDP排名  中国各省市面积和人口最新排名                                世界各国国土面积和人口排名  经典英语口语学习教程和资料集合大全                     2013年25家IT高科技公司薪酬排行榜  --------------------------------------------------------------------------------------------------------------      ","title":"2012智能手机芯片产业大盘点：市场爆发重新洗牌"},{"content":"           昨天收到一个bug，描述如下： 1 Enter Settings-->Language&input 2 Choose personal dictionary 3.Choose add in menu 4.Input some word and choose personal dictionary [Expected result] The word can be added to dictionary and no any error [Error] The input panel can't hide 进入添加用户字典后编辑并退出，但是input panel不能自动隐藏。这个问题涉及到fragment的概念，关于理解fragment的概念，可以参考http://www.cnblogs.com/mybkn/articles/2455134.html。         添加用户字典是在UserDictionaryAddWordFragment中进行的，UserDictionaryAddWordFragment继承于Fragment。 \\packages\\apps\\Settings\\src\\com\\android\\settings\\inputmethod\\UserDictionaryAddWordFragment.java 在它的onPause()方法中添加如下code：   boolean autoHide = getResources().getBoolean(R.bool.auto_hide_keyboard_when_onpause);         if (autoHide){             ContexttContext = getActivity();            InputMethodManager imm =(InputMethodManager)getActivity().getSystemService(tContext.INPUT_METHOD_SERVICE);            imm.hideSoftInputFromWindow(getActivity().getCurrentFocus().getWindowToken(),0);         } 其中的R.bool.auto_hide_keyboard_when_onpause这个值在\\packages\\apps\\Settings\\res\\value下的bool.xml中定义。smart-phone的这个值是false，value-sw600dp目录下的bool.xml中的值为true。 Fragment的onPause方法是在看不见这个Fragment的时候被调用的，所以把这段code加在onPause方法中即可实现退出这个Fragment时自动隐藏输入法界面。","title":"Android Fragment：开发大屏幕平板时UserDictionaryAddWordFragment编辑后软键盘不能自动隐藏的问题"},{"content":"2012马上就要结束了，在即将到来的2013年，ArcGIS Runtime SDK for Android将推出一系列激动人心的新特性，本文就为你介绍其中的一些亮点。 新功能： 将会新增Network Analyst Task，用于支持以下操作（在保持连接的场景下）： 路径分析 服务区域分析 最近设施分析 新增Find Task，用于在地图上多个图层和字段中进行搜索。 支持对地图进行连续平移操作，支持跨越国际日期变更线（即wrap around）。 时态感知图层—新增对时态感知图层的支持，图层中存储了随时间变化的信息。 高亮显示要素—选中的要素具有高亮显示的符号化表达。高亮显示一直都有，但过去只是简单符号。 支持以PKI（公钥基础设施）安全方式访问ArcGIS Online中的安全服务。 GraphicsLayer中的Graphic对象新增Z顺序属性，支持开发人员控制和管理Graphic对象的绘制顺序。 We’ve implemented a new Geocode service, which now handles single-line input fields.实现了新的Geocode服务，现在能够处理单线（single-line）输入字段。 新的图层类型： WMS KML (仅限于Internet上的KML) CSV- 逗号分隔的表格化数据 Open Street Map SDK增强： 新的示例向导（Samples Wizard）包括ArcGIS Online上的远程示例—示例向导经过重新设计，支持在Eclipse开发环境中加载本地或远程的示例。 Javadoc外观更新 Javadoc API搜索更容易—你可以直接在API引用中搜索。 将UML模型集成到Javadoc中—这样可以在API中更清晰地看到对象模型直接的关联 API变化： 高级符号API（Advanced Symbology API）支持更新的2525C符号字典（Symbol Dictionary） 支持10.1 中增强的查询功能。","title":"【先睹为快】ArcGIS Android SDK下一版本新特性"},{"content":"//利用BitmapFactory生成Bitmap //注意该方法只是生成了Bitmap,所以返回值都是一个Bitmap //并没有涉及到对于Bitmap对象的操作,比如将其旋转,压缩 //以下为常用的四种方式: //1 依据文件路径生成Bitmap //该方法也是获取缩略图的方法之一 //获取缩略图的另外一种方法是直接调用类方法 //重点是传入参数opts //ThumbnailUtils.extractThumbnail(); //可以这么理解:既然是得到缩率图,其实也就是生成一个 //新的Bitmap,所以当然该调用BitmapFactory.decodeFile()方法. Bitmap bitmap1=BitmapFactory.decodeFile(pathName, opts); //2 从本地资源中生成Bitmap Bitmap bitmap2=BitmapFactory.decodeResource(res, id); //3 从输入流中生成Bitmap Bitmap bitmap3=BitmapFactory.decodeStream(inputStream); //4 从字节数组中生成Bitmap Bitmap bitmap4=BitmapFactory.decodeByteArray(data, offset, length); //生成Bitmap后对于该Bitmap的操作小结如下: //1 压缩Bitmap的宽和高,将Bitmap旋转和倾斜 //  等操作调用的都是类方法Bitmap.createBitmap()方法.其中matrix参数很重要 Bitmap bitmap5=Bitmap.createBitmap(rawBitmap, x, y, width, height, matrix, filter); //2 保存Bitmap到文件.调用的是Bitmap的对象方法 bitmap5.compress(format, quality, os);","title":"Android中Bitmap常见操作(一.理论)"},{"content":"从年初第一款四核手机上市到年末电信联通争夺iPhone5首发，2012年的国内手机业始终处于高度“亢奋”的状态。近日，南都记者获得一份市场调研机构赛诺的手机市场统计数据。内容显示，截至11月，我国国产手机份额总和已达到了71.7%. 据赛诺统计，11月内整个国内手机市场（包括2G、3G、智能机、功能机）总体容量为2459万部，环比10月下降了2 .3%，但同比去年增长了18.3%.分制式看，2G市场加速萎缩，环比下降8 .4 %；3 G市场环比微增0.7%.其中TD-SCDMA市场环比增长12.0%，EVDO市场环比下降4 .4%，WC D MA则下滑了5 .1%. 在占据市场主体的国产手机部分，酷派是销量增长最快的品牌，环比增长1.6%，除此之外，还有少量品牌份额增长在0 .5个百分点之内，但更多的品牌份额呈微跌状态。此前酷派副总裁苏峰接受南都记者采访时曾表示，酷派将继续保持紧跟运营商的策略。这也是月内酷派获得较高增长的主因———按赛诺计，运营商市场在11月份额环比增长了1 .8 %，达116 5万台。相反社会渠道销量环比下降了5 .8%，为1294万台，两种市场的比例进一步接近。 在截至11月的2012年手机品牌整体排名上，前十位分别为三星、联想、诺基亚、华为、中兴、酷派、金立、苹果、HTC和摩托罗拉。   Android开发环境搭建所需资源、安装步骤图解        Android海量源码、教程与资料   数字电视接口规范大全（行业标准）                      程序员必备：英语口语学习教程大全  20本Linux电子书学习教程                    2013年25家IT高科技公司薪酬排行榜   2013年Android平台8大预测                   优秀Android开发人员必须注意的10个误区  Android开发应该掌握的28大内容和10大建议      成为“Android高手”的6个境界  90后就业“钱景”分析:IT行业仍是最佳选择       90后就业“钱景”:IT仍是最佳选择 -------------------------------------------------------------------------------------------------------------- 终生受益的43个健康常识--值得珍藏                           面试如何着装：不同职位穿着大不同      2013年国内就业率最高的50个本科专业排名              女生面试如何着装及禁忌    50个“最有钱景专业”的毕业生年薪一览表               毕业后头5年决定你的一生  千万别熬夜:身体器官晚上工作时间表一览                  90后就业“钱景”:IT仍是最佳选择     --------------------------------------------------------------------------------------------------------------  211工程大学最新名单(共112所)                              985工程大学最新名单(共39所)  中国“国家实验室”最新名单（共20所）                 “特色985”大学最新名单（共29所）  2013年国内工科大学排名100强名单                          2013年中国大学580强排行榜  女孩教你追女孩的终极技巧                                       2013年世界各国人均GDP排名  中国各省市面积和人口最新排名                                世界各国国土面积和人口排名  经典英语口语学习教程和资料集合大全                     2013年25家IT高科技公司薪酬排行榜  --------------------------------------------------------------------------------------------------------------      ","title":"洋手机市场再遭挤压，国产品牌份额飙升超70%"},{"content":"String 字符串常量 StringBuffer 字符串变量（线程安全） StringBuilder 字符串变量（非线程安全）  简要的说， String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。  而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：  String S1 = “This is only a” + “ simple” + “ test”;  StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”);  你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个  String S1 = “This is only a” + “ simple” + “test”; 其实就是：  String S1 = “This is only a simple test”; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如： String S2 = “This is only a”; String S3 = “ simple”; String S4 = “ test”; String S1 = S2 +S3 + S4; 这时候 JVM 会规规矩矩的按照原来的方式去做 在大部分情况下 StringBuffer > String StringBuffer Java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。 可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。 StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。 例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(\"le\") 会使字符串缓冲区包含“startle”，而 z.insert(4, \"le\") 将更改字符串缓冲区，使之包含“starlet”。 在大部分情况下 StringBuilder > StringBuffer java.lang.StringBuilde java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。     如果你读过《Think in Java》，而且对里面描述HashTable和HashMap区别的那部分章节比较熟悉的话，你一定也明白了原因所在。对，就是支持线程同步保证线程安全而导致性能下降的问题。HashTable是线程安全的，很多方法都是synchronized方法，而HashMap不是线程安全的，但其在单线程程序中的性能比HashTable要高。StringBuffer和StringBuilder类的区别也在于此，新引入的StringBuilder类不是线程安全的，但其在单线程中的性能比StringBuffer高。如果你对此不太相信，可以试试下面的例子： package com.hct.test; import java.util.ArrayList; import java.util.Iterator; import java.util.List; /**  * @author: chengtai.he  * @created:2009-12-9 上午09:59:57  */ public class StringBuilderTester {  private static final String base = \" base string. \";  private static final int count = 2000000;  public static void stringTest() {   long begin, end;   begin = System.currentTimeMillis();   String test = new String(base);   for (int i = 0; i < count/100; i++) {    test = test + \" add \";   }   end = System.currentTimeMillis();   System.out.println((end - begin)     + \" millis has elapsed when used String. \");  }  public static void stringBufferTest() {   long begin, end;   begin = System.currentTimeMillis();   StringBuffer test = new StringBuffer(base);   for (int i = 0; i < count; i++) {    test = test.append(\" add \");   }   end = System.currentTimeMillis();   System.out.println((end - begin)     + \" millis has elapsed when used StringBuffer. \");  }  public static void stringBuilderTest() {   long begin, end;   begin = System.currentTimeMillis();   StringBuilder test = new StringBuilder(base);   for (int i = 0; i < count; i++) {    test = test.append(\" add \");   }   end = System.currentTimeMillis();   System.out.println((end - begin)     + \" millis has elapsed when used StringBuilder. \");  }  public static String appendItemsToStringBuiler(List list) {   StringBuilder b = new StringBuilder();   for (Iterator i = list.iterator(); i.hasNext();) {    b.append(i.next()).append(\" \");   }   return b.toString();  }  public static void addToStringBuilder() {   List list = new ArrayList();   list.add(\" I \");   list.add(\" play \");   list.add(\" Bourgeois \");   list.add(\" guitars \");   list.add(\" and \");   list.add(\" Huber \");   list.add(\" banjos \");   System.out.println(StringBuilderTester.appendItemsToStirngBuffer(list));  }  public static String appendItemsToStirngBuffer(List list) {   StringBuffer b = new StringBuffer();   for (Iterator i = list.iterator(); i.hasNext();) {    b.append(i.next()).append(\" \");   }   return b.toString();  }  public static void addToStringBuffer() {   List list = new ArrayList();   list.add(\" I \");   list.add(\" play \");   list.add(\" Bourgeois \");   list.add(\" guitars \");   list.add(\" and \");   list.add(\" Huber \");   list.add(\" banjos \");   System.out.println(StringBuilderTester.appendItemsToStirngBuffer(list));  }  public static void main(String[] args) {   stringTest();   stringBufferTest();   stringBuilderTest();   addToStringBuffer();   addToStringBuilder();  } } 上面的程序结果如下： 5266 millis has elapsed when used String. 375 millis has elapsed when used StringBuffer. 281 millis has elapsed when used StringBuilder.  I   play   Bourgeois   guitars   and   Huber   banjos   I   play   Bourgeois   guitars   and   Huber   banjos 从上面的结果来看，这三个类在单线程程序中的性能差别一目了然，采用String对象时，即使运行次数仅是采用其他对象的1/100，其执行时间仍然比其他对象高出25倍以上；而采用StringBuffer对象和采用StringBuilder对象的差别也比较明显，前者是后者的1.5倍左右。由此可见，如果我们的程序是在单线程下运行，或者是不必考虑到线程同步问题，我们应该优先使用StringBuilder类；当然，如果要保证线程安全，自然非StringBuffer莫属了。 除了对多线程的支持不一样外，这两个类的使用几乎没有任何差别，上面的例子就是个很好的说明。appendItemsToStringBuiler和appendItemsToStirngBuffer两个方法除了采用的对象分别为StringBuilder和StringBuffer外，其他完全相同，而效果也完全相同。","title":"String、StringBuffer 、StringBuilder 的区别"},{"content":"     PS： 一直很困扰与Ubuntu下解压zip乱码问题，虽然解压后不影响文件的正常使用，但看着各种字符的文件名心里就各种不爽。     所以决定解决这个问题，现在将我认为比较好的方法分享给大家，希望对大家有所帮助。 一、乱码原因 其实，并不是所有zip文件解压后都是乱码的，只有windows下压缩的zip在ubuntu中会出现这种情况。 其实就是windows和ubuntu下压缩的编码格式不同。windows下的编码格式为GBK，Ubuntu下的为UTF-8。 二、解决办法 原因分析过了，下面说一下解决办法(这些方法据说是高手们最常用的方法) 1. 安装7-zip 和 convmv :  命令： sudo apt-get install convmv p7zip-full 2. 解压zip文件:  命令：LANG=C 7z e yourZIPfilename 3. 开始转换编码 命令： convmv -f gbk -t utf8 -r --notest * OK,大功告成了，呵呵。。。","title":"Ubuntu 解压缩zip文件乱码问题解决方案"},{"content":"做应用程序，难免会用到本地文件的处理，对WP平台来说，可以采用IsolatedStorage库来实现，关于这个类库的具体操作，网上有很多的详细描述，这里就不多做描述了。当有了相应的类库后，总是使用cmd命令进行文件操作，会让人觉得非常繁琐，如果有一款GUI的工具出现，会让我们的工作变得更为简单。 我想最先遇到的工具肯定是windows phone 7 isolatedstorage explorer tool，这是一款比较老的工具，自从2011年4月份起就没有再更新过，而且界面的子目录无法进行操作，最要命的是这个工具有严重的bug。如果想让你的应用可以与PC上的GUI工具相连接，你需要在你的应用的App.xaml.cs文件内加上以下两句代码： private void Application_Launching(object sender, LaunchingEventArgs e) {   IsolatedStorageExplorer.Explorer.Start(\"localhost\");//参数为PC端的IP地址 }         private void Application_Activated(object sender, ActivatedEventArgs e) {     IsolatedStorageExplorer.Explorer.RestoreFromTombstone(); } 如果网络出现状况，客户端无法与PC端进行连接，那么每隔几十秒，你的程序将出现崩溃。我仔细查阅过原作者在CodePlex上的主页(http://wp7explorer.codeplex.com/)，在ISSUE TRACKER里，作者解释了这种频繁重启的原因，但没有提出相应的解决方案。但是网站有源码可以下载，有兴趣的朋友可以下载下源码后，将这个异常解决掉。 对于我的应用来说，由于时间较紧，并需要为用户提供一个可以通过PC机与手机应用进行数据交互的工具，那么我只能再寻找其它途径了。 幸好我找到了另外一款工具，比这个要强大很多，就是Windows Phone Power Tools(CodePlex上的主页面http://wptools.codeplex.com/)，我的WP应用在win7平台下开发，此工具的最新版本需要在win8上才能运行，如果在win7上开发的话，需要下载standlone版本的安装文件。","title":"isolated storage GUI工具的选择"},{"content":"该实例主要用到了一个jar包，通过这个jar包可以将String Char类型直接从繁体转到简体或者从简体转到繁体，十分方便   jar包下载地址：http://download.csdn.net/detail/stilo2012/4937401 顺便推荐下我的阅读器 下个版本实现繁简转换 :)   http://www.eoemarket.com/show/index/?appId=97578   下面看代码实现： \tpublic static void main(String[] args) {\t\ttry {\t\t\tJChineseConvertor jChineseConvertor = JChineseConvertor\t\t\t\t\t.getInstance();\t\t\tString s = \"简体繁体转换\";\t\t\tSystem.out.println(jChineseConvertor.s2t(s));\t\t} catch (IOException e) {\t\t\te.printStackTrace();\t\t}\t} 输出结果：簡體繁體轉換 如果觉得好用 顶一下 谢谢咯~收一点资源分~~    ","title":"Android中文简体繁体互相转换的实现(繁简互转)"},{"content":"Fragment的概念        Fragment是Android honeycomb 3.0新增的概念，你可以将Fragment类比为Activity的一部分，它拥有自己的生命周期，接收自己的输入，你可以在Activity运行的时加入或者移除Fragment.(或者我们也可以将Fragment类比为一个可以在不同的Activity中重用的子Activity。     Fragment总是嵌入在Activity中，同时Fragment的生命周期受Activity影响，当Activity 暂停，所有在这个Activity中的Fragments将被释放。然而当一个Activity在运行比如resume时，你可以单独的操控每个Fragment。 如何创建一个Fragment      创建Fragment时需要继承Fragment基类，并且重载关键的生命周期方法来加入你的应用逻辑，类似你创建Activity的方法      Fragment与Activity不同的地方在于其必须通过onCreateView()来定义布局。事实上你只要定义这个回调方法就可以让Fragment运行起来。以下是一个示例： import android.os.Bundle; import android.support.v4.app.Fragment; import android.view.LayoutInflater; import android.view.ViewGroup; public class ArticleFragment extends Fragment {     @Override     public ViewonCreateView(LayoutInflater inflater, ViewGroup container,         BundlesavedInstanceState) {         // Inflatethe layout for this Fragment         returninflater.inflate(R.layout.article_view, container, false);     } }        就像其他的Activity一样，Fragment应该事先其他的生命周期回调函数以便于控制其在Activity中的添加与移除，以及控制其本身在各个生命周期状态之间的迁移。当Fragment所在的Activity的onPause方法被调用，Fragment的onPause方法也应该被调用。 利用XML在Activity中添加一个Fragment 因为Fragment是可重用的，模块化的UI组件，任何一个Fragment的实例必须有继承自FragmentActivty父类。你可以通过将Fragment定义在Activity的布局XML文件中实现这一点。 注意：FragmentActivity是一个为支持API11以前的版本所提供特别的Activity。如果你支持的设备的版本高于API11，你可以直接使用Activity 以下是一个布局文件，实现了将两个Fragment添加到一个Activity中： res/layout-large/news_articles.xml: <LinearLayoutxmlns:android=\"http://schemas.android.com/apk/res/android\"     android:orientation=\"horizontal\"    android:layout_width=\"fill_parent\"    android:layout_height=\"fill_parent\">     <Fragmentandroid:name=\"com.example.android.Fragments.HeadlinesFragment\"              android:id=\"@+id/headlines_Fragment\"              android:layout_weight=\"1\"              android:layout_width=\"0dp\"              android:layout_height=\"match_parent\" />     <Fragmentandroid:name=\"com.example.android.Fragments.ArticleFragment\"              android:id=\"@+id/article_Fragment\"               android:layout_weight=\"2\"              android:layout_width=\"0dp\"              android:layout_height=\"match_parent\" /> <\/LinearLayout> 以下是实现这个布局文件的Activity的实现： import android.os.Bundle; import android.support.v4.app.FragmentActivity; public class MainActivity extends FragmentActivity {     @Override     public voidonCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.news_articles);     } } 注意：当你将一个Fragment通过布局文件添加到Activity中的的时候，你不能再运行时将Fragment移除。如果你需要通过用户的互动自由切入切出，你必须在Activity启动的时候添加Activity。","title":"Fragment的概念与使用(一)--基本概念"},{"content":"前几章参考： 1-引言 2-Objective-C 编程 3-类、对象和方法 4-数据类型和表达式 5-循环结构 6-选择结构 7-类 一切从根类开始： 没有父类的类，位于类层次结构的最顶层，称为根（Root）类。NSObject是层次结构的最顶端（也就是它上面没有任何类），因此称为根类。 如果使用术语，可以将类称为子类和父类。同样，也可以将类称为子类和超类。 需要注意的是，要在子类中直接使用实例变量，必须先在接口部分声明。在实现部分声明和合成（synthesize）的实例变量是私有的，子类中并不能够直接访问，需要明确定义或合成取值方法，才能访问实例变量的值。 继承的概念作用于整个继承链。 一定要理解以下事实：类的每个实例都拥有自己的实例变量，即使这些实例变量是继承来的。 找出正确的方法： 首先，检查该对象所属的类，以查看在该类中是否明确定义了一个具有指定名称的方法。如果有，就使用这个方法。如果没有定义，就检查它的父类。如果父类中有定义，就使用这个方法，否者，继续找寻。知道找到根类也没有发现任何方法。 通过继承来扩展：添加新方法 继承通常用于扩展一个类。 @class指令： @class XYPoint; 或 #import \"XYPoint.h\" 使用@class指令提高了效率，因为编译器不需要引入和处理整个XYPoint.h文件（虽然它很小），只需要知道XYPoint是一个类名。如果需要引用XYPoint类的方法（在实现部分中），@class指令是不够的，因为编译器需要更多的消息。 说的通俗点：只引用了类就用@class不然就用#import。 在默认情况下，合成的设值方法只是简单地复制对象指针，而不是对象本身。你可以合成另一种设值方法，而不是制作对象的副本。 覆写方法： 不能通过继承删除或减少方法。但可以利用覆写来更改继承方法的定义。 新方法必须具有相同的返回类型，并且参数的数目与覆写的方法相同。 如果在不同的类中有名称相同的方法，则根据作为消息的接收者的类选择正确的方法。 为什么要创建子类？有如下3个理由： 1）希望继承一个类的方法，也许加入一些新的方法和或实例变量。 2）希望创建一个类的特别的版本。 3）希望通过覆写一个或多个方法来改变类的默认行为。 抽象类： 有时，创建类只是为了更容易创建子类。因此，这些类名为抽象（abstract）类，或等价地称为抽象超类（abstract superclasses）。在该类中定义方法和实例变量，但不期望任何人从该类创建实例。","title":"8-继承"},{"content":"最近在研究手机热点的建立。HTC手机比较坑爹，首先一个，是不能按常规的办法修改 SSID, BSSID, 在网上搜了下，有篇博客把这个问题解决了，请参考：http://blog.sina.com.cn/s/blog_adc221ac01011mrs.html 然后就发现HTC手机热点是建好了，但是其他手机去连它，怎么也连不上，后来发现，使用静态IP能解决这个问题，但太麻烦了。 研究了下通过手动配置HTC的WiFi热点程序 com.htc.WiFiRouter 里面有一个Local DHCP的配置,把它勾上就能自动获取IP。 但要怎么样用代码实现呢这下坑爹了。 研究了半天，还是只有把HTC独有的类给它全部dump出来，代码如下 public void dumpHTCWifiFunction2(){    \t Log.e(TAG, \"dumpHTCWifiFunction2++\");//    \tMethod[] classMethods = null;    \tField localField1;    \t    \tField[] fieldlist;    \tWifiConfiguration apConfig = new WifiConfiguration();    \ttry {\t\t\tlocalField1 = WifiConfiguration.class.getDeclaredField(\"mWifiApProfile\");\t\t\t  localField1.setAccessible(true);\t\t        Object localObject2 = localField1.get(apConfig);\t\t        localField1.setAccessible(false);\t\t        \t\t        if(localObject2!=null){\t\t        \tfieldlist = localObject2.getClass().getDeclaredFields();\t\t        \t\t\t        \tfor (int i = 0;i < fieldlist.length; i++)\t\t            {\t\t                Log.e(TAG, \"found api: \"+ fieldlist[i].getName());\t\t            }\t\t        }\t\t        \t\t        \t\t} catch (NoSuchFieldException e) {\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t} catch (IllegalArgumentException e) {\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t} catch (IllegalAccessException e) {\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t}    \tLog.e(TAG, \"dumpHTCWifiFunction2--\");    } 12-28 11:06:29.956: E/MainActivity(3253): dumpHTCWifiFunction2++ 12-28 11:06:29.966: E/MainActivity(3253): found api: DEFAULT_DHCP_MAX_AP_CONNECTION 12-28 11:06:29.966: E/MainActivity(3253): found api: DEFAULT_MAX_AP_CONNECTION 12-28 11:06:29.976: E/MainActivity(3253): found api: DHCP_MAX_AP_CONNECTION 12-28 11:06:29.976: E/MainActivity(3253): found api: MAX_AP_CONNECTION 12-28 11:06:29.976: E/MainActivity(3253): found api: OPEN 12-28 11:06:29.976: E/MainActivity(3253): found api: WEP 12-28 11:06:29.986: E/MainActivity(3253): found api: WPA 12-28 11:06:29.986: E/MainActivity(3253): found api: WPA2 12-28 11:06:29.986: E/MainActivity(3253): found api: BSSID 12-28 11:06:29.996: E/MainActivity(3253): found api: SSID 12-28 11:06:29.996: E/MainActivity(3253): found api: blocklist 12-28 11:06:29.996: E/MainActivity(3253): found api: whitelist 12-28 11:06:29.996: E/MainActivity(3253): found api: this$0 12-28 11:06:30.006: E/MainActivity(3253): found api: startingIP 12-28 11:06:30.006: E/MainActivity(3253): found api: dhcpSubnetMask 12-28 11:06:30.016: E/MainActivity(3253): found api: dnsIPAddr1 12-28 11:06:30.016: E/MainActivity(3253): found api: dnsIPAddr2 12-28 11:06:30.016: E/MainActivity(3253): found api: secureType 12-28 11:06:30.016: E/MainActivity(3253): found api: key 12-28 11:06:30.016: E/MainActivity(3253): found api: ipAddress 12-28 11:06:30.016: E/MainActivity(3253): found api: hiddenSSID 12-28 11:06:30.016: E/MainActivity(3253): found api: maxConns 12-28 11:06:30.016: E/MainActivity(3253): found api: maxDhcpClients 12-28 11:06:30.026: E/MainActivity(3253): found api: enableMacFilter 12-28 11:06:30.026: E/MainActivity(3253): found api: sleepPolicy 12-28 11:06:30.026: E/MainActivity(3253): found api: dhcpEnable 12-28 11:06:30.026: E/MainActivity(3253): found api: connectionArray 12-28 11:06:30.026: E/MainActivity(3253): found api: channel 12-28 11:06:30.026: E/MainActivity(3253): dumpHTCWifiFunction2-- 发现了 dhcpEnable 这个成员变量，刚开始猜它是boolean变量，但错了，在设置的时候会发生错误。 干脆把它的类型也打印出来吧，打印语句改为： Log.e(TAG, \"found api: \"+ fieldlist[i].getName()+\" type:\"+fieldlist[i].toString()); found api: dhcpEnable type:public int android.net.wifi.WifiConfiguration$HotspotProfile.dhcpEnable 原来它是int型变量,估且猜它是1为enable. 设置之后，果然可以。 完整代码如下： private boolean setWifiSSIDForHTC(WifiConfiguration apConfig) {\t    boolean successed = true;\t    //\t    WifiConfiguration mnetConfig = new WifiConfiguration();\t    Field localField1;\t                    try {\t                        localField1 = WifiConfiguration.class.getDeclaredField(\"mWifiApProfile\");\t                        localField1.setAccessible(true);\t                        Object localObject2 = localField1.get(apConfig);\t                        localField1.setAccessible(false);\t                        if(localObject2!=null){\t                            Field localField5 = localObject2.getClass().getDeclaredField(\"SSID\");\t                            localField5.setAccessible(true);\t                            localField5.set(localObject2, apConfig.SSID);// netConfig.SSID);\t                            localField5.setAccessible(false);\t                            Field localField4 = localObject2.getClass().getDeclaredField(\"BSSID\");\t                            localField4.setAccessible(true);\t                            localField4.set(localObject2, apConfig.BSSID);//netConfig.BSSID);\t                            localField4.setAccessible(false);\t                            \t                            Field localField6 = localObject2.getClass().getDeclaredField(\"dhcpEnable\");                                localField6.setAccessible(true);//                                localField6.set(localObject2, \"true\");//netConfig.BSSID);                                localField6.setInt(localObject2, 1);                                localField6.setAccessible(false);\t                        }\t                    } catch(Exception e) {\t                        e.printStackTrace();\t                    }\t    return successed;\t}","title":"HTC Android Hotspot 热点配置 之DHCP"},{"content":"对于CMSIS函数的调用，ARM官方都是给的stm32的例子，而且stm32调用CMSIS好像也没出过问题。 问题来源：看到iar的技术文章Using CoreSight Trace Techniques on Cortex-M3/M4，感觉不错，在kinetis上一一实践，发现Example 5: Printf via SWO这篇文章中描述的功能不能实现，但是在没有串口的情况下，这又是一个很好的输出方式。 问题分析：主要是函数ITM_SendChar()没有办法调用；而该函数定义在core_CM4.h头文件中，在ARM官方的CMSIS描述中该头文件应该在Device Header File <device.h>中被包含，但是飞思卡尔的头文件MK60DZ10.h又未包含该头文件，不知道飞思卡尔为什么不支持cmsis。 解决办法：根据CMSIS的描述增加如下代码： //cmsis#define __CM4_REV                 0x0001    /* Core revision r0p1                                 */#define __MPU_PRESENT             0         /* MPU present or not                                 */#define __NVIC_PRIO_BITS          3         /* Number of Bits used for Priority Levels            */#define __Vendor_SysTickConfig    0         /* Set to 1 if different SysTick Config is used       */#define __FPU_PRESENT             0         /* FPU present or not                                 */typedef enum IRQn{/******  Cortex-M4 Processor Exceptions Numbers ***************************************************//* ToDo: use this Cortex interrupt numbers if your device is a CORTEX-M3 / Cortex-M4 device       */  NonMaskableInt_IRQn           = -14,      /*!<  2 Non Maskable Interrupt                        */  MemoryManagement_IRQn         = -12,      /*!<  4 Memory Management Interrupt                   */  BusFault_IRQn                 = -11,      /*!<  5 Bus Fault Interrupt                           */  UsageFault_IRQn               = -10,      /*!<  6 Usage Fault Interrupt                         */  SVCall_IRQn                   = -5,       /*!< 11 SV Call Interrupt                             */  DebugMonitor_IRQn             = -4,       /*!< 12 Debug Monitor Interrupt                       */  PendSV_IRQn                   = -2,       /*!< 14 Pend SV Interrupt                             */  SysTick_IRQn                  = -1,       /*!< 15 System Tick Interrupt                         *//******  Device Specific Interrupt Numbers ********************************************************//* ToDo: add here your device specific external interrupt numbers         according the interrupt handlers defined in startup_Device.s         eg.: Interrupt for Timer#1       TIM1_IRQHandler   ->   TIM1_IRQn                        */ } IRQn_Type;/* ToDo: include the correct core_cm#.h file         core_cm0.h if your device is a CORTEX-M0 device         core_cm3.h if your device is a CORTEX-M3 device         core_cm4.h if your device is a CORTEX-M4 device                                          */#include <core_cm4.h>                       /* Cortex-M# processor and core peripherals           *//* ToDo: include your system_<Device>.h file         replace '<Device>' with your device name                                                 *///cmsis 运行效果：","title":"Kinetis调用CMSIS功能函数"},{"content":"随着移动设备的日益增多，以前互联网的一些常用功能逐渐在移动互联网上逐渐迁移 今天我们看一下我们经常用到的报表是怎样实现在android客户端的 接触过android图标的人应该都知道Achartengine  一个android应用的图表库 利用android本地的API来进行图标的绘制 适用于数据分析，报表显示，也涵盖了一些常用的图标，是个易学易用的图表库，但是他的实现的效果有局限性，交互性不强 可以看下实现的效果 ： 移动设备目前已经完美支持HTML5 今天介绍一下利用html5开发本地化的报表 使用的开源报表类库iCharjs ，国内开源小组开发 有详细的中英文API文档以及实例代码 这里不作太多介绍 可以去官方网站详细了解 http://www.ichartjs.com/ 下面介绍使用ichartjs开发本地化报表 首先在官网下载ichartjs类库包 ichart-1.0.js 新建android项目ichartjstest   在assets目录下放置报表文件 报表基于HTML 所以要创建html文件 如下图 目录结构根据项目要求可以自己定义 html中创建图表代码如下： <html>\t<head>\t\t<meta charset=\"UTF-8\" />\t\t<script type=\"text/javascript\" src=\"ichart-1.0.min.js\"><\/script>\t\t<script type=\"text/javascript\">\t\t\t$(function(){\t\t\t\tvar data = [\t\t\t\t        \t{\t\t\t\t        \t\tname : '北京',\t\t\t\t        \t\tvalue:[2,12,14,20,28,32,34,36,33,24,14,4],\t\t\t\t        \t\tcolor:'#1f7e92'\t\t\t\t        \t}\t\t\t\t       ];\t\t\t       \t\t\t\tvar chart = new iChart.Area2D({\t\t\t\t\t\trender : 'canvasDiv',\t\t\t\t\t\tdata: data,\t\t\t\t\t\tturn_off_touchmove:true,\t\t\t\t\t\ttitle : '北京2012年平均温度情况',\t\t\t\t\t\twidth : 800,\t\t\t\t\t\theight : 400,\t\t\t\t\t\tlabels:[\"一月\",\"二月\",\"三月\",\"四月\",\"五月\",\"六月\",\"七月\",\"八月\",\"九月\",\"十月\",\"十一月\",\"十二月\"]\t\t\t\t\t});\t\t\t\t\t\t\t\tchart.draw();\t\t\t});\t\t<\/script>\t\t<\/head>\t\t<body>\t\t\t<div id='canvasDiv'><\/div><\/body><\/html> html文件创建过程这里参考ichartjs教程  创建后就要在activity中显示该图表了 android中可以通过WebView来显示 layout文件很简单 只需要添加WebView标签就可以 <WebView\t\tandroid:id=\"@+id/wv\"\t    android:layout_width=\"fill_parent\"\t    android:layout_height=\"fill_parent\"    /> 当然WebView还要做很多配置  具体设置看下面代码 \t\twv = (WebView) findViewById(R.id.wv);\t\twv.getSettings().setJavaScriptEnabled(true);  //设置WebView支持javascript\t\twv.getSettings().setUseWideViewPort(true);\t//设置是当前html界面自适应屏幕\t\twv.getSettings().setSupportZoom(true); //设置支持缩放\t\twv.getSettings().setBuiltInZoomControls(true);//显示缩放控件\t\twv.getSettings().setLoadWithOverviewMode(true);\t\twv.requestFocus();\t\twv.loadUrl(\"file:///android_asset/mianji_chart.html\"); //加载assert目录下的文件 这样可以显示报表了  效果像上图一样 可以进行缩放、拖动等操作，ichartjs支持点击、触摸等交互 所以会消化掉android屏幕的touchmove事件 导致图表不能够拖动  这里需要增加属性 turn_off_touchmove:true 来去掉事件 就可以正常拖动了  OK 大功告成 是不是很简单，当然这里只是实现了本地化的数据加载 如果需要根据查询数据进行图标展示 ，这里就要进行服务器数据查询，然后根据数据来展示图表，这个也是可以实现的，需要通过js调用，下次再进行详细介绍吧 代码例子下载地址  ichartjstest ichartjs用户使用手册下载  使用手册下载","title":"Android报表解决方案 使用开源组件iChartjs（一）"},{"content":"    做产品适配工作时，能遇到各种奇怪的问题。今天就遇到了RatingBar显示不全的问题，查了一些资料，有说是android 的bug，有说将控件的padding属性值设置为0，都没有成功解决问题。      而且小星星可以显示，大星星显示不正常，如下：      在RatingBar控件使用自定义样式时，在联想机顶盒s系列上不能正常显示星星图片。经过很多方式解决无明显效果。小星星24px能显示，大星星33px显示不全，只显示第一个星星，其余星星呈现一条线）。      附图：      小星星图：      大星星图：      最后联系厂商那边的工程师，说是将AndroidManifest文件中的use sdk去掉。但是去掉后，我们的应用不能正常运行。     突然灵机一动，会不会是编译版本的问题。将 uses-sdk 中的targetSdkVersion去掉     将 <uses-sdk     android:minSdkVersion=\"7\"      android:targetSdkVersion=\"16\" /> 改为： <uses-sdk     android:minSdkVersion=\"7\"   />     再次编译后，大星星终于显示正常了。     希望能对各位有用……    原文链接：http://www.67tgb.com/?p=529   转载请注明出处：望月听涛","title":"RatingBar显示不全"},{"content":" 在编写手机程序的时候，往往一个页面是不够用的，一般应用都需要包括多个页面。在BB10 Cascades中多个页面的浏览处理方式有许多，包括NavigationPane，TabbedPane等。NavigationPane中可以包含几个页面，用户通过打开页面，返回上级页面来实现页面之间的切换，页面堆栈由NavigationPane管理。而TabbedPane是通过屏幕下方的标签按钮完成页面之间的切换，一个TabbedPane可以包含几个标签页，用户通过点击不同的标签来实现不同页面的切换。 NavigationPane和TabbedPane都相对复杂一点点，我们在后面的博文中再详细介绍，本文介绍的Sheet页面是一个更简单的多页面处理方式。   使用Sheet页面建构的应用基本上还是属于单页面应用，用户在主页面上完成主要工作，当用户需要完成额外的工作式，比如修改配置项，或者是填写用户名密码等，我们为用户弹出一个全屏的页面显示相应界面，处理完成后关闭该全屏页面继续在主页面上工作。 所以，基本上来讲，可以把Sheet页面当做是一个全屏对话框。 当然，Sheet页面也可以结合其它页面浏览方式一起使用，比如在NavigationPane中显示了某一个页面，在该页面需要完成额外工作时弹出一个Sheet页面让用户操作。 总之，不管使用什么方式切换页面，首先要保证的是用户在使用过程中可以清晰地了解页面之间的关系，不会被不断弹出的页面搞蒙。   因为Sheet页面的作用是比较简单的，所以它的使用也一样很简单。 首先是要在页面中嵌入一个Sheet对象，像下面的代码这样： import bb.cascades 1.0Page {    Container {//你的主页面内容            }         attachedObjects: [            Sheet {                id: mySheet                content: Page {                    //sheet页面的内容                }            }//sheet页面结束        ]//嵌入对象结束}//主页面结束 注意这里的Sheet页面给了一个id，id为mySheet，你可以根据现实情况使用喜欢的id名。为Sheet页面指定id的目的是在主页面上可以通过这个id操作sheet页面。当然，sheet页面的主要操作就是打开和关闭了，对应方法如下： //打开sheet页面mySheet.open();//关闭sheet页面mySheet.close(); 为了在主页面中打开sheet页面，我们在主页面中加入一个按钮，点击该按钮就调用mySheet的open方法，代码如下：           Button {            text: \"Open Sheet\"            onClicked: {                mySheet.open();            }            horizontalAlignment: HorizontalAlignment.Center        } 然后我们需要添加一个关闭sheet的动作，需要注意的是Sheet页面弹出时会覆盖主页面，所以将关闭Sheet的按钮放在主页面显然是有问题的，在Sheet页面弹出时用户根本无法点中主页面中的按钮。 所以我们需要把关闭Sheet的动作添加到Sheet页面中，为了样例生动一点，我们把关闭Sheet的动作添加到Sheet页面的菜单项中。添加了关闭动作的Sheet页面代码如下： attachedObjects: [            Sheet {                id: mySheet                content: Page {                    Label {                        text: \"This is a sheet.\"                    }                    actions: [                        ActionItem {                            title: \"Close Sheet\"                            ActionBar.placement: ActionBarPlacement.OnBar                            onTriggered: {                                mySheet.close();                            }                        }                    ]                }            }        ]     下面是完整的代码：   // Default empty project templateimport bb.cascades 1.0// creates one page with a labelPage {    Container {        layout: StackLayout {        }        Label {            text: qsTr(\"Sheet Test\")            textStyle.base: SystemDefaults.TextStyles.BigText            verticalAlignment: VerticalAlignment.Center            horizontalAlignment: HorizontalAlignment.Center        }        Button {            text: \"Open Sheet\"            onClicked: {                mySheet.open();            }            horizontalAlignment: HorizontalAlignment.Center        }    }         attachedObjects: [            Sheet {                id: mySheet                content: Page {                    Label {                        text: \"This is a sheet.\"                    }                    actions: [                        ActionItem {                            title: \"Close Sheet\"                            ActionBar.placement: ActionBarPlacement.OnBar                            onTriggered: {                                mySheet.close();                            }                        }                    ]                }            }        ]} 以上代码执行的效果如下，点击其中的“Open Sheet”按钮会弹出一个Sheet页面：      弹出的Sheet页面如下，点击其中的“Close Sheet”菜单项会关闭Sheet.              ","title":"BB10 Cascades: QML中Sheet页面的使用"},{"content":"一般获取媒体文件的metadata元数据的方法大概为 1.MediaMetadataRetriever mr = new MediaMetadataRetriever(); 2.mr.setDataSource(file.getAbsolutePath()); 3.mr.extractMetadata(KEY...); 4.mr.release(); 主要分析1,2 . 这是因为为该媒体文件找到了对应的解码器, 然后对应调用获取的接口, 如果想继续研究如何解码的话就只有再深入研究了, 每种媒体类型的编码都不一样,这里就不深究了,只通过它们的抽象接口来分析. 还是通过时序图来分析, 右键新标签打开图片来看吧. 懒得打字,所以在画图的时候加上关键点的注释, 哈哈!! 由于图片会被缩小, 我还是传多一份资源附件吧  http://download.csdn.net/download/lylianlll/4938539","title":"Android媒体文件metadata是如何实现跟解码器结合获取的"},{"content":"                                                                                                    MTK 平台LCD 驱动的整个过程的讲解 MTK_LCD_Driver 代码的路是在/mediatek/source/kernel/driver/vedio/mtkfb.c module_init(mtkfb_init);模块初始化函数 int__init mtkfb_init(void) { int r = 0; MSG_FUNC_ENTER(); /* Register the driver withLDM */ if(platform_driver_register(&mtkfb_driver)) {／／以platform方式进行注册mtkfb driver PRNERR(\"failed toregister mtkfb driver\\n\"); r = -ENODEV; goto exit; } #ifdefCONFIG_HAS_EARLYSUSPEND register_early_suspend(&mtkfb_early_suspend_handler);／／LCD是以erly_suspend的方式注册的，这个涉及到power_management的内容 #endif DBG_Init(); exit: MSG_FUNC_LEAVE(); return r; ｝ 知道设备模型的人应该知道platformbus总线的match函数的规则是device和driver的名字必须相同，当name匹配一样的时候，我们就会调用driver里面的probe函数，这个函数是LCDdriver的核心入口函数。 进入LCDprobe世界。 staticint mtkfb_probe(struct device *dev) { struct platform_device *pdev; struct mtkfb_device *fbdev= NULL; struct fb_info *fbi; int init_state; int r = 0; char*p = NULL; MSG_FUNC_ENTER(); printk(\"%s,%s\\n\", __func__, saved_command_line); p= strstr(saved_command_line, \"fps=\"); if(p== NULL){ lcd_fps= 6000; printk(\"[FBdriver]can not get fps from uboot\\n\"); } else{ p+= 4; lcd_fps= simple_strtol(p, NULL, 10); } …........................ …........................ r = register_framebuffer(fbi); if (r != 0) { PRNERR(\"register_framebufferfailed\\n\"); goto cleanup; } fbdev->state =MTKFB_ACTIVE; MSG(INFO, \"MTKframebuffer initialized vram=%lu\\n\", fbdev->fb_size_in_byte); MSG_FUNC_LEAVE(); return 0; cleanup: mtkfb_free_resources(fbdev,init_state); MSG_FUNC_LEAVE(); return r; } 这个函数比较长，下面我们一一对这个Probe函数进行讲解。 1、开始driver接受从uboot中传递过来的参数，saved_command_line变量，进行参数的取值。 2、DISP_IsContextInited这个函数判断lcm_params、disp_drv、lcm_drv是不是都进行初始化了，如果都初始化了，那么就返回TRUE如果有一个没有进行初始化的话，那么就返回FALSE。其实这里在uboot中已经进行了初始化了，我们这里假设这里还没有初始化，如果是FALSE的话，那么就会调用mtkfb_find_lcm_driver这个function函数。 mtkfb_find_lcm_driver： BOOLmtkfb_find_lcm_driver(void) { BOOLret = FALSE; char*p, *q; p= strstr(saved_command_line,\"lcm=\");//这里我们会找出”lcm=”这个字符串在saved_command_line中第一次出现的位置，取出这个指针。 if(p== NULL) { //we can't find lcm string in the command line, the uboot should be oldversion returnDISP_SelectDevice(NULL); } p+= 4; if((p- saved_command_line) > strlen(saved_command_line+1)) { ret= FALSE; gotodone; } printk(\"%s,%s\\n\", __func__, p); q= p; while(*q!= ' ' && *q != '\\0') q++; memset((void*)mtkfb_lcm_name,0, sizeof(mtkfb_lcm_name)); strncpy((char*)mtkfb_lcm_name,(const char*)p, (int)(q-p));//这里会找出lcm的名字，接下来会将这个Name股指给mtkfb_lcm_name这个变量，下面会将这个变量传递给mtkfb_lcm_name这个函数。 printk(\"%s,%s\\n\", __func__, mtkfb_lcm_name); if(DISP_SelectDevice(mtkfb_lcm_name)) ret= TRUE; done: returnret; } continuetrace code:DISP_SelectDevice(mtkfb_lcm_name) DISP_SelectDevice(mtkfb_lcm_name): BOOLDISP_SelectDevice(const char* lcm_name) { LCD_STATUSret; ret= LCD_Init(); printk(\"retof LCD_Init() = %d\\n\", ret); lcm_drv= disp_drv_get_lcm_driver(lcm_name); if(NULL == lcm_drv) { printk(\"%s,disp_drv_get_lcm_driver() returns NULL\\n\", __func__); returnFALSE; } disp_dump_lcm_parameters(lcm_params); returndisp_drv_init_context(); } 上面的函数还是比较复杂的，我们下面会进行一一的讲解： 2.1：LCD_Init LCD_STATUSLCD_Init(void) { LCD_STATUS ret =LCD_STATUS_OK; memset(&_lcdContext, 0,sizeof(_lcdContext));／／我们可以发现-lcdContext这个变量是一个数组，而且是static类型的，C语言中我们定义了这种类型的变量的话，那么就会为这个变量分配一个地址 // LCD controller would NOTreset register as default values // Do it by SW here // ResetBackupedLCDRegisterValues();这里我们会为上面的_lcdContext.regBackup里面的值进行赋值，我们所用的是LCD_OUTREG32，函数进行赋值的，开始我一直以为这个变量根本就没有赋值啊，我往哪里的地址写呢，换位思考下，我们定义了一个变量后就肯定有地址，向地址写值就是将这个变量所指向的指针写值，也就是赋值。regs->SERIAL_CFG；regs->PARALLEL_CFG[0]；regs->PARALLEL_CFG[1]；regs->PARALLEL_CFG[2] ret =LCD_PowerOn();//通过配置regiter的值将LCD打开，这里就不具体纠结这个细节了，要深入的话，可以自己去看下。 LCD_OUTREG32(&LCD_REG->SYNC_LCM_SIZE,0x00010001); LCD_OUTREG32(&LCD_REG->SYNC_CNT,0x1); ASSERT(ret == LCD_STATUS_OK); #ifENABLE_LCD_INTERRUPT if(request_irq(MT6577_LCD_IRQ_ID, _LCD_InterruptHandler,IRQF_TRIGGER_LOW, \"mtklcd\", NULL) < 0)//申请LCD的中断处理函数，当有新的数据需要刷新到屏上面的时候，我们就会调用这个中断处理函数，关于这个中断处理函数我们下面会讲解。这里我一直很奇怪的是这个interrupt到底做了什么事情，接下来我会联系lcm_update函数进行统一讲解，这样我就能够将所有的流程串起来了。 { DBI_LOG(\"[LCD][ERROR]fail to request LCD irq\\n\"); return LCD_STATUS_ERROR; } // mt65xx_irq_unmask(MT6577_LCD_IRQ_ID);//下面是设置一些寄存器的值 // enable_irq(MT6577_LCD_IRQ_ID); init_waitqueue_head(&_lcd_wait_queue); LCD_REG->INT_ENABLE.COMPLETED= 1; // LCD_REG->INT_ENABLE.REG_COMPLETED= 1; LCD_REG->INT_ENABLE.CMDQ_COMPLETED= 1; LCD_REG->INT_ENABLE.HTT= 1; LCD_REG->INT_ENABLE.SYNC =1; #endif return LCD_STATUS_OK; } 2.2：disp_drv_get_lcm_driver(lcm_name) disp_drv_get_lcm_driver(lcm_name)：这会将我们在uboot中得到的Lcm的名字传递过来。 constLCM_DRIVER *disp_drv_get_lcm_driver(const char *lcm_name) { LCM_DRIVER*lcm = NULL; printk(\"[LCMAuto Detect], we have %d lcm drivers built in\\n\", lcm_count); printk(\"[LCMAuto Detect], try to find driver for [%s]\\n\", (lcm_name==NULL)?\"unknown\":lcm_name); if(lcm_count==1)//进行判断Lcm_count的值，这个值是通过计算lcm_driver_list里面大小进行判断的，如果我们需要新添加一个新的lcm进去的话，那么就需要在这个数组里面添加新的IC厂商的lcm,添加代码的路径是在/meidatek/custom/common/kernel/lcm/mt65xx_lcm_list.c里面进行添加 { //we need to verify whether the lcm is connected //even there is only one lcm type defined lcm= lcm_driver_list[0];//如果这个lcm_driver_list中只有一个Lcm的话，那么就默认的就只取地一个就可以了 lcm->set_util_funcs(&lcm_utils);//没一个lcm结构里面都自己对应的定义成员，这里会调用lcm->set_util_funcs函数，传递进去的参数是在disp_drv.c里面定义好的结构，这个结构是mediatek的自己实现的display_driver：/mediatek/source/kernel/driver/video/disp_drv.c，我们调用lcm.set_util_funcs函数就是完成将display_driver里面的结构赋值给lcm_util这个static结构。 lcm->get_params(&s_lcm_params);//调用Lcm.get_params函数将s_lcm_params这个变量进行初始化，所赋的值，我们都都在每一个lcm进行参数的初始化。 lcm_params= &s_lcm_params; lcm_drv= lcm; { isLCMFound= TRUE; } printk(\"[LCMSpecified]\\t[%s]\\n\", (lcm->name==NULL)?\"unknown\":lcm->name); gotodone; } else { inti; for(i= 0;i < lcm_count;i++) { lcm_params= &s_lcm_params; lcm= lcm_driver_list[i]; printk(\"[LCMAuto Detect] [%d] - [%s]\\t\", i,(lcm->name==NULL)?\"unknown\":lcm->name); lcm->set_util_funcs(&lcm_utils); memset((void*)lcm_params,0, sizeof(LCM_PARAMS)); lcm->get_params(lcm_params);//上面的函数和count等于1的status是一样的，参考上面就可以了。 disp_drv_init_ctrl_if();//初始化dispaly的controlinterface有串口和并口等 disp_drv_set_driving_current(lcm_params);//从函数的命名定义上面，我们是在设置lcd的电流，但是我根据地址查询mediatek的socdatasheet并没有找到相关的定义。 disp_drv_init_io_pad(lcm_params);//查看datasheet是说在设置这个register就可以设置pin脚的值 if(lcm_name!= NULL) { if(!strcmp(lcm_name,lcm->name))//将我们从uboot中得到的lcm_name和我们没一个的lcm里面的name进行对比，如果一样的话，那么就代表我们已经找到了我们使用的Lcm { printk(\"\\t\\t[success]\\n\"); isLCMFound= TRUE; lcm_drv= lcm; gotodone; } else { printk(\"\\t\\t[fail]\\n\"); } } else { if(LCM_TYPE_DSI== lcm_params->type){ init_dsi(FALSE);//初始化dsi这种模式 } if(lcm->compare_id!= NULL &&lcm->compare_id())如果发现我们的传递的lcm_name是NULL；并且Lcm_list又不止一个的话，那么就会调用没一个lcm的compare_id函数，这个函数是我们lcm里面实现好的，我这里用的是r61408这个IC屏，我们就看看这个lcm的compare_id函数是如何实现的。我们R61408这个IC里面直接是读取IC里面的devicecode register进行和这个LCM默认的值进行对比而得到的，当然不同deIC可能compare_id函数实现也不一样，只要满足一个判断的标准就可以了。 { printk(\"\\t\\t[success]\\n\"); isLCMFound= TRUE; lcm_drv= lcm; gotodone; } else { if(LCM_TYPE_DSI== lcm_params->type) DSI_Deinit(); printk(\"\\t\\t[fail]\\n\"); } } } #ifdefHQ_PROJECT_A75 /*HQ ynn 2012-06-29 modified for no lcd poweron*/ if(FALSE== isLCMFound)// ynn { lcm= lcm_driver_list[0]; lcm->set_util_funcs(&lcm_utils); lcm->get_params(&s_lcm_params); lcm_params= &s_lcm_params; lcm_drv= lcm; isLCMFound= TRUE; } #endif } done: returnlcm_drv; }／／当找到这个lcm的话，就将找到的lcm赋值给lc_drv；将获得的s_lcm_params赋值给lcm_params，并将isLCMFound这个标志变量设置为TRUE，代表我已经找到了LCM。 2.3：disp_dump_lcm_parameters(lcm_params) disp_dump_lcm_parameters(lcm_params)：将获得的lcm_params进行打印出来 2.4：disp_drv_init_context disp_drv_init_context： staticBOOL disp_drv_init_context(void) { if(disp_drv != NULL && lcm_drv != NULL){ returnTRUE; } if(!isLCMFound) DISP_DetectDevice();//进而判断我们有没有找到设备，如果没有的话，调用这个函数再进一次找设备的过程，和上面的selectDevice函数是一样的 disp_drv_init_ctrl_if();//和上面的一样是在初始化control接口 switch(lcm_params->type)//下面是在根据我们的lcm的类型，取出disp_drv的值，这里我们会将我们属于哪一种模式的Lcm就将DISP_DRIVER这个结构赋值过去，这个代码的路径是在/mediatek/source/kernel/drivers/video/这个路径下面有每一种模式的结构的定义。 { caseLCM_TYPE_DBI : disp_drv = DISP_GetDriverDBI(); break; caseLCM_TYPE_DPI : disp_drv = DISP_GetDriverDPI(); break; caseLCM_TYPE_DSI : disp_drv = DISP_GetDriverDSI(); break; default: ASSERT(0); } if(!disp_drv) return FALSE; returnTRUE; } 到这里的话，我们的DISP_SelectDevice这个函数就已经讲解完了。那么我们的mtk_find_lcm_driver这个函数也就讲解完了。 在这里我们就返回到mtkfb.c中的Probe函数了，讲解下面的内容。 接下来： MTK_FB_XRES = DISP_GetScreenWidth(); MTK_FB_YRES =DISP_GetScreenHeight(); fb_xres_update= MTK_FB_XRES; fb_yres_update= MTK_FB_YRES; printk(\"[MTKFB]XRES=%d, YRES=%d\\n\", MTK_FB_XRES, MTK_FB_YRES); MTK_FB_BPP =DISP_GetScreenBpp(); MTK_FB_PAGES =DISP_GetPages(); init_waitqueue_head(&screen_update_wq); 上面是获得mtkfb的参数和创建等待队列。 screen_update_task= kthread_create( screen_update_kthread,NULL, \"screen_update_kthread\");//创建一个线程，这个线程根据名字可以大概的猜测出来是用来update屏幕的内容的。 L既然看到了这个线程的话，那么就看下这个线程到底在干嘛吧？ screen_update_kthread：屏幕刷新的线程 screen_update_kthread staticint screen_update_kthread(void *data) { structsched_param param = { .sched_priority = RTPM_PRIO_SCRN_UPDATE};//设置线程的优先级，下面会用到 sched_setscheduler(current,SCHED_RR, &param);设置当前线程的优先级别 for( ;; ) { wait_event_interruptible(screen_update_wq,atomic_read(&has_pending_update));//这里是一个for的无限循环，我们将当前线程进入screen_update_wq等待队列，这个时候我们就会进入睡眠，既然有进入睡眠的函数，那么就有地方将他唤醒，在下面我们会讲解唤醒的函数。并且设置autio机制，只能被一个线程占有。 MTKFB_LOG(\"wqwakeup\\n\"); mtkfb_update_screen_impl();一旦这个线程被唤醒的话，那么就会调用这个函数。 atomic_set(&has_pending_update,0); if (kthread_should_stop()) break; } return 0; } 3.1：mtkfb_update_screen_impl mtkfb_update_screen_impl staticvoid mtkfb_update_screen_impl(void) { BOOLdown_sem = FALSE; MTKFB_FUNC(); //printk(\"\\n\\n\\n\\n mtkfb_update_screen_impl in init current->pid\\n\\n\\n\\n\",current->pid); if(down_interruptible(&sem_overlay_buffer)){//尝试获得信号量，如果获得不成功的话，那么就进入睡眠 printk(\"[FB Driver]can't get semaphore in mtkfb_update_screen_impl()\\n\"); } else{ down_sem= TRUE; sem_overlay_buffer_cnt--; } #ifdefined(MTK_M4U_SUPPORT) { unsigned int i; /// check if the MVAaddress is invalid, turn off the layer for(i=0;i<FB_LAYER;i++){ if(LCD_IsLayerEnable((LCD_LAYER_ID)i)){ if(!MTKFB_SearchMVA(LCD_LayerGetAddress(i))){ LCD_LayerEnable((LCD_LAYER_ID)i,FALSE); } } } } #endif DISP_CHECK_RET(DISP_UpdateScreen(0,0, fb_xres_update, fb_yres_update));//调用DISP_UpdateScreen函数进行update if(down_sem){ sem_overlay_buffer_cnt++; up(&sem_overlay_buffer); } } 3.1.2:DISP_STATUSDISP_UpdateScreen DISP_STATUSDISP_UpdateScreen(UINT32 x, UINT32 y, UINT32 width, UINT32 height) { DISP_LOG(\"updatescreen, (%d,%d),(%d,%d)\\n\", x, y, width, height); if(down_interruptible(&sem_update_screen)) { printk(\"ERROR:Can't get sem_update_screen in DISP_UpdateScreen()\\n\"); returnDISP_STATUS_ERROR; } #ifdefined(MTK_LCD_HW_3D_SUPPORT)//判断我们的屏幕是否支持3D效果 LCD_CHECK_RET(DISP_Set3DPWM(DISP_Is3DEnabled(), DISP_is3DLandscapeMode() )); #endif //if LCM is powered down, LCD would never recieve the TE signal // if(is_lcm_in_suspend_mode || is_engine_in_suspend_mode) gotoEnd;//判断有没有进入suspend状态下 LCD_CHECK_RET(LCD_WaitForNotBusy()); if(lcm_params->type==LCM_TYPE_DSI&& lcm_params->dsi.mode == CMD_MODE) DSI_CHECK_RET(DSI_WaitForNotBusy()); if(lcm_drv->update) {//调用lcm_drv.update函数进行更新参数，在下面会进行讲解 lcm_drv->update(x,y, width, height); } LCD_CHECK_RET(LCD_SetRoiWindow(x,y, width, height));//设置屏幕的显示窗口的大小 LCD_CHECK_RET(LCD_FBSetStartCoord(x,y)); if(-1 != direct_link_layer) { //MT6516IDP_EnableDirectLink(); // FIXME }else { disp_drv->update_screen();//调用对应的displaydriver的update_screen函数在下面会进行讲解。 } End: up(&sem_update_screen); returnDISP_STATUS_OK; } 3.1.2.1：lcm_update .update = lcm_update, staticvoid lcm_update(unsigned int x, unsigned int y, unsignedint width, unsigned int height) { unsignedint x0 = x; unsignedint y0 = y; unsignedint x1 = x0 + width - 1; unsignedint y1 = y0 + height - 1; unsignedchar x0_MSB = ((x0>>8)&0xFF); unsignedchar x0_LSB = (x0&0xFF); unsignedchar x1_MSB = ((x1>>8)&0xFF); unsignedchar x1_LSB = (x1&0xFF); unsignedchar y0_MSB = ((y0>>8)&0xFF); unsignedchar y0_LSB = (y0&0xFF); unsignedchar y1_MSB = ((y1>>8)&0xFF); unsignedchar y1_LSB = (y1&0xFF); unsignedint data_array[16]; data_array[0]=0x00053902; data_array[1]=(x1_MSB<<24)|(x0_LSB<<16)|(x0_MSB<<8)|0x2a; data_array[2]=(x1_LSB); data_array[3]=0x00053902; data_array[4]=(y1_MSB<<24)|(y0_LSB<<16)|(y0_MSB<<8)|0x2b; data_array[5]=(y1_LSB); data_array[6]=0x002c3909; // data_array[6]=0x002c3901; //上面是设置传输数据的信息，这些地址是写死的，当有数据的时候，我们就会触发DMA中断，DMA直接将数据放到目的地，我们就会将数据显示到LCD上面 dsi_set_cmdq(data_array,7, 0);//最终调用到dsi_set_cmdq函数 } 看下dsi_set_cmdq函数的实现： #definedsi_set_cmdq(pdata, queue_size,force_update) lcm_util.dsi_set_cmdq(pdata, queue_size, force_update) 调用的是lcm_util.dsi_set_cmdq函数。 在disp_drv.c里面 .dsi_set_cmdq =(void (*)(unsigned int *, unsigned int, unsigned char))DSI_set_cmdq 上面的kthread_create函数只是在创建一个新的线程，但是这个线程不会立刻执行，需要调用wake_up_process函数，这个线程才会真正的进行执行，但是当执行的时候，我们会执行wait_event_interruptible(screen_update_wq,atomic_read(&has_pending_update));这个函数，如果atomic_read(&has_pending_update)这个contion不是true的话，那么就会将当前的线程加入screen_update_wq这个等待队列。所以这个线程又会进入睡眠了，不知道你们有没有想到如果进入睡眠的话，那么是谁在唤醒这个线程呢？？对了就是我们在进面申请的中断，这个中断处理函数会进行唤醒这个线程将LCD进行update数据的动作。 4、LCD中断和Lcm_update函数之间的衔接 4.1:在上面的代码中我们讲解了kthread_create函数创建的线程在干嘛？下面继续我们的代码执行过程。 wake_up_process(screen_update_task); { ///registerLCD complete interrupt callback DISP_INTERRUPT_CALLBACK_STRUCTcbStruct; cbStruct.pFunc= mtkfb_lcd_complete_interrupt;//为cbStruct.pFunc成员进行赋值，下面会使用这个里面的成员 cbStruct.pParam= NULL; ///regster callback if(DISP_STATUS_OK !=DISP_SetInterruptCallback(DISP_LCD_TRANSFER_COMPLETE_INT,&cbStruct))//4.1.1会进行讲解这个函数在干嘛？，我们会将傻瓜你买你的cdStruct变量传递给这个函数 { ASSERT(0); } } 4.1.1：DISP_SetInterruptCallback(DISP_LCD_TRANSFER_COMPLETE_INT,&cbStruct) DISP_STATUSDISP_SetInterruptCallback(DISP_INTERRUPT_EVENTS eventID,DISP_INTERRUPT_CALLBACK_STRUCT *pCBStruct) { UINT32 offset; ASSERT(pCBStruct != NULL); disp_drv_init_context();//这个函数我们在前面的代码中已经讲解过了，这里就不再讲解了 if(eventID >=DISP_LCD_INTERRUPT_EVENTS_START && eventID <=DISP_LCD_INTERRUPT_EVENTS_END ) //我们会根据我们设置的id的不同。而进行不同的case的执行，我只讲解一种case，执行流程是一样的 { ///register callback offset = eventID -DISP_LCD_INTERRUPT_EVENTS_START; DISP_CallbackArray[offset].pFunc= pCBStruct->pFunc;//根据我们的不同的Id，我们为DISP_CallbackArray数组里面的成员赋值 DISP_CallbackArray[offset].pParam= pCBStruct->pParam; LCD_CHECK_RET(LCD_SetInterruptCallback(_—DISP_InterruptCallbackProxy));//看下这个函数在做什么？LCD_STATUSLCD_SetInterruptCallback(void (*pCB)(DISP_INTERRUPT_EVENTS)) { lcdContext.pIntCallback= pCB; returnLCD_STATUS_OK; } //上面其实是将——DISP_InterruptCallbackProxy函数赋值给lcdContext.pIntCallback函数，这个函数我们会在LCD的中断处理函数中进行调用，下面我们看下这个函数到底在干嘛 LCD_CHECK_RET(LCD_EnableInterrupt(eventID)); } else if(eventID >=DISP_DSI_INTERRUPT_EVENTS_START && eventID <=DISP_DSI_INTERRUPT_EVENTS_END ) { ///register callback offset = eventID -DISP_DSI_INTERRUPT_EVENTS_START + DISP_LCD_INTERRUPT_EVENTS_NUMBER; DISP_CallbackArray[offset].pFunc= pCBStruct->pFunc; DISP_CallbackArray[offset].pParam= pCBStruct->pParam; DSI_CHECK_RET(DSI_SetInterruptCallback(_DISP_InterruptCallbackProxy)); DSI_CHECK_RET(DSI_EnableInterrupt(eventID));//根据我们的event的类型不同，我们去控制我们的LCD的寄存器 } else if(eventID >=DISP_DPI_INTERRUPT_EVENTS_START && eventID <=DISP_DPI_INTERRUPT_EVENTS_END ) { offset = eventID -DISP_DPI_INTERRUPT_EVENTS_START + DISP_LCD_INTERRUPT_EVENTS_NUMBER +DISP_DSI_INTERRUPT_EVENTS_NUMBER; DISP_CallbackArray[offset].pFunc= pCBStruct->pFunc; DISP_CallbackArray[offset].pParam= pCBStruct->pParam; DPI_CHECK_RET(DPI_SetInterruptCallback(_DISP_InterruptCallbackProxy)); DPI_CHECK_RET(DPI_EnableInterrupt(eventID)); } else { DISP_LOG(\"Invalidevent id: %d\\n\", eventID); ASSERT(0); return DISP_STATUS_ERROR; ///TODO: error log } return DISP_STATUS_OK; } 4.1.1.1：_DISP_InterruptCallbackProxy staticvoid _DISP_InterruptCallbackProxy(DISP_INTERRUPT_EVENTS eventID) { UINT32 offset; if(eventID >=DISP_LCD_INTERRUPT_EVENTS_START && eventID <=DISP_LCD_INTERRUPT_EVENTS_END ) { offset = eventID -DISP_LCD_INTERRUPT_EVENTS_START; if(DISP_CallbackArray[offset].pFunc) { DISP_CallbackArray[offset].pFunc(DISP_CallbackArray[offset].pParam); } } …................... ….................. } 看到没有，我们会根据Id的值从DISP_CallbackArray数组中取对应的pFun函数，这个函数也就是cbStruct.pFunc =mtkfb_lcd_complete_interrupt; cbStruct.pParam = NULL; 以上的函数和参数，再执行这个函数。 4.1.1.2:mtkfb_lcd_complete_interrupt mtkfb_lcd_complete_interrupt: staticvoid mtkfb_lcd_complete_interrupt(void *param) { if(atomic_read(&has_pending_update)) { wake_up_interruptible(&screen_update_wq);//这里会进行唤醒我们在上面创建更新LCD的线程， } #ifdefined(MTK_HDMI_SUPPORT) hdmi_source_buffer_switch(); if(is_hdmi_active()) { hdmi_update(); } #endif 到这里还没有将我们的Interrupt函数联系以来。下面来联系： 5：LCD的中断处理函数 我们再次回到/mediatek/platform/mt6577/kernel/driver/video/lcd_drv.c里面 request_irq(MT6577_LCD_IRQ_ID,_LCD_InterruptHandler,IRQF_TRIGGER_LOW, \"mtklcd\", NULL) 回顾下中断处理函数： staticirqreturn_t _LCD_InterruptHandler(int irq, void *dev_id) { LCD_REG_INTERRUPT status =LCD_REG->INT_STATUS; if (status.COMPLETED) { #ifdefCONFIG_MTPROF_APPLAUNCH // eng enable, user disable LOG_PRINT(ANDROID_LOG_INFO,\"AppLaunch\", \"LCD frame buffer update done !\\n\"); #endif wake_up_interruptible(&_lcd_wait_queue); if(_lcdContext.pIntCallback) _lcdContext.pIntCallback(DISP_LCD_TRANSFER_COMPLETE_INT); DBG_OnLcdDone(); } if (status.SYNC)// this is TEmode 0 interrupt { if(_lcdContext.pIntCallback) _lcdContext.pIntCallback(DISP_LCD_SYNC_INT); DBG_OnTeDelayDone(); lcd_esd_check= false; } #if0 //TE mode 1 if(status.HTT) { if(_lcdContext.pIntCallback) _lcdContext.pIntCallback(DISP_LCD_HTT_INT);//看到没有，我们这里就会调用pINtCallback函数，也就是我们在上面的mtkfb_lcd_complete_interrupt函数，只有调用了这个函数，那么我们的lcd更新画面的线程才会被调用 DBG_OnTeDelayDone(); } #endif LCD_OUTREG32(&LCD_REG->INT_STATUS,0); return IRQ_HANDLED; } #endif 到目前为止，LCD的代码的执行的整个过程就已经讲解完了。","title":"LCD 驱动过程详解"},{"content":"如何从我自己的应用中启动App Store？同时如何链接到商店中我自己的应用？ -[UIApplication openURL:] 可以处理传入的链接到应用和媒体NSURL 对象，启动对应的商店应用。根据以下步骤获取链接，可以是应用，歌曲，itunes中的专辑，同时链接它到你的iPhone应用。 在电脑中启动iTunes 搜索你要添加的项目 右击或者control点击在iTunes中的项目名称在弹出菜单中循选择\"Copy iTunes Store URL\" 使用-[UIApplication openURL:] 打开修改的URL字符串和NSURL 对象。 注意：你也可以使用iTunes Link Maker 工具来获取应用歌曲或者保存在iTuns中的专辑的链接。参见iTunes Link Maker FAQ了解更多关于工具的信息。 下面是从原生应用中启动App Store的例子。 NSString *iTunesLink = @http://itunes.apple.com/us/app/id284417350?mt=8; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:iTunesLink]];  有一些iTunes链接，包括iTunes相关链接，在链接到对应的应用程序前会返回多个重定向。你可以使用NSURLConnection静默的处理这些重定向，并在重定向完成时打开最终的URL。这能够让你的应用支持直接转换到商店而无需启动Safari。下面是展示如何完成这个动作。 注意：如果你的iTunes链接时在UIWebView中你可以使用这个方法在-[UIWebViewDelegate webView:shouldStartLoadWithRequest:navigationType:] 委托方法中拦截链接。 在iPhone中处理iTunes相关的链接 // Process a LinkShare/TradeDoubler/DGM URL to something iPhone can handle - (void)openReferralURL:(NSURL *)referralURL {     NSURLConnection *con = [[NSURLConnection alloc] initWithRequest:[NSURLRequest requestWithreferralURL]  delegate:self startImmediately:YES];     [con release]; }  // Save the most recent URL in case multiple redirects occur // \"iTunesURL\" is an NSURL property in your class declaration - (NSURLRequest *)connection:(NSURLConnection *)connection willSendRequest:(NSURLRequest *)request redirectResponse:(NSURLResponse *)response {     self.iTunesURL = [response URL];     if( [self.iTunesURL.host hasSuffix:@\"itunes.apple.com\"])     {         [connection cancel];         [self connectionDidFinishLoading:connection];         return nil;      }      else      {        return request;      } }  // No more redirects; use the last URL saved - (void)connectionDidFinishLoading:(NSURLConnection *)connection {     [[UIApplication sharedApplication] openself.iTunesURL]; }","title":"从iPhone应用中启动App Store"},{"content":"////  MoveScaleImageController.h//  MoveScaleImage////  Created by  on 12-4-24.//  Copyright (c) 2012年 __MyCompanyName__. All rights reserved.//#import <UIKit/UIKit.h>#import \"MoveScaleImageView.h\"@interface MoveScaleImageController : UIViewController<UIScrollViewDelegate>{    UIScrollView *myScrollView;    UIImageView *myImageView;}@property(retain,nonatomic)UIScrollView *myScrollView;@property(retain,nonatomic)UIImageView *myImageView;@end ////  MoveScaleImageController.m//  MoveScaleImage////  Created by  on 12-4-24.//  Copyright (c) 2012年 __MyCompanyName__. All rights reserved.//#import \"MoveScaleImageController.h\"@interface MoveScaleImageController ()@end@implementation MoveScaleImageController@synthesize myScrollView;@synthesize myImageView;-(void)dealloc{    [myScrollView release];    [myImageView release];    [super dealloc];}-(void)loadView{    [super loadView];    self.view.backgroundColor = [UIColor lightGrayColor];    //    UIButton *btn = [UIButton buttonWithType:UIButtonTypeRoundedRect];    UIButton *btn = [[UIButton alloc]initWithFrame:CGRectMake(110, 200, 100, 50)];//    [btn setFrame:CGRectMake(110, 200, 100, 40)];    [btn setBackgroundColor:[UIColor whiteColor]];    [btn setTitle:@\"点击查看图片\" forState:UIControlStateNormal];    [btn.titleLabel setFont:[UIFont systemFontOfSize:13]];    [btn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];    [btn addTarget:self action:@selector(clickEvent:) forControlEvents:UIControlEventTouchUpInside];    [self.view addSubview:btn];    [btn release];        //下面是我要剪切区域的覆盖层//    if(self.centerOverLayView==nil)//    {//        UIView *centerView=[[UIView alloc] initWithFrame:CGRectMake(20, 100, 280, 210)];//        self.centerOverLayView=centerView;//        [centerView release];//    }//    self.centerOverLayView.backgroundColor=[UIColor clearColor];//    self.centerOverLayView.layer.borderColor=[UIColor orangeColor].CGColor;//    self.centerOverLayView.layer.borderWidth=2.0;//    [self.view addSubview:self.centerOverLayView];    }-(void)clickEvent:(id)sender{    NSLog(@\"***********clickeventad\");    myScrollView = [[UIScrollView alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height)];    if(self.myScrollView==nil)    {        UIScrollView *scrollView=[[UIScrollView alloc] initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height)];        self.myScrollView=scrollView;        [scrollView release];    }    self.myScrollView.backgroundColor=[UIColor blueColor];    self.myScrollView.delegate=self;    self.myScrollView.multipleTouchEnabled=YES;    self.myScrollView.minimumZoomScale=1.0;    self.myScrollView.maximumZoomScale=10.0;    [self.view addSubview:self.myScrollView];        UIImage *_image = [UIImage imageNamed:@\"image.jpg\"];    CGFloat imageView_X = (_image.size.width > self.view.frame.size.width) ? self.view.frame.size.width : _image.size.width;    CGFloat imageView_Y;    CGFloat origin;    if(_image.size.width > self.view.frame.size.width){        origin = self.view.frame.size.width/_image.size.width;        imageView_Y = _image.size.height*origin;    }    myImageView = [[UIImageView alloc]initWithFrame:CGRectMake((self.view.frame.size.width-imageView_X)/2, (self.view.frame.size.height-imageView_Y)/2, imageView_X, imageView_Y)];       if(self.myImageView==nil)    {        UIImageView *imageView=[[UIImageView alloc] initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height)];        self.myImageView=imageView;        [imageView release];    }   //    [myImageView setImage:_image];        UIImage *originImage=[[UIImage alloc]initWithCGImage:_image.CGImage];    [myImageView setImage:originImage];//    [myImageView setFrame:CGRectMake(0, 0, _image.size.width, _image.size.height)];        [self.myScrollView addSubview:self.myImageView];        UIButton *closeBtn = [[UIButton alloc]initWithFrame:CGRectMake(10, 10, 50, 50)];    [closeBtn setBackgroundColor:[UIColor redColor]];    [closeBtn setAlpha:0.5];    [closeBtn addTarget:self action:@selector(closeEvent:) forControlEvents:UIControlEventTouchUpInside];    [self.view addSubview:closeBtn];    [closeBtn release];    //    UIView *backView = [[UIView alloc] initWithFrame:CGRectInset(self.view.frame, 5, 5)];//    backView.alpha = 0.5;//    backView.backgroundColor = [UIColor blackColor];////    [self.view addSubview:backView];//    //    UIImage* image=[UIImage imageNamed:@\"image.jpg\"];//    MoveScaleImageView*fileContent = [[MoveScaleImageView alloc]initWithFrame:CGRectMake(0, 44, 320, 436)];//    [fileContent setImage:image];//    ////    [backView addSubview:fileContent];//    [self.view addSubview:fileContent];//    //    [backView release];//    [fileContent release];}-(void)closeEvent:(id)sender{    [self.myImageView setHidden:YES];    [self.myScrollView setHidden:YES];}#pragma mark UIScrollView delegate methods//实现图片的缩放-(UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView{    NSLog(@\"**************viewForZoomingInScrollView\");    return self.myImageView;}//实现图片在素芳过程中居中- (void)scrollViewDidZoom:(UIScrollView *)scrollView{    CGFloat offsetX = (scrollView.bounds.size.width > scrollView.contentSize.width)?(scrollView.bounds.size.width - scrollView.contentSize.width)/2 : 0.0;    CGFloat offsetY = (scrollView.bounds.size.height > scrollView.contentSize.height)?(scrollView.bounds.size.height - scrollView.contentSize.height)/2 : 0.0;    self.myImageView.center = CGPointMake(scrollView.contentSize.width/2 + offsetX,scrollView.contentSize.height/2 + offsetY);}- (void)viewDidLoad{    [super viewDidLoad];// Do any additional setup after loading the view.}- (void)viewDidUnload{    [super viewDidUnload];    // Release any retained subviews of the main view.}- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation{    return (interfaceOrientation == UIInterfaceOrientationPortrait);}@end","title":"IOS手指控制图片的缩放"},{"content":"本文为网上资源整理，多出收集转载自别处，感谢原作者。        Android的界面能用png最好是用png了，因为32位的png颜色过渡平滑且支持透明。jpg是像素化压缩过的图片，质量已经下降了，再拿来做9path的按钮和平铺拉伸的控件必然惨不忍睹，要尽量避免。 对于颜色繁杂的，比如照片墙纸之类的图片（有些应用的启动画面喜欢搞这种），那用jpg是最好不过了，这种图片压缩前压缩后肉眼分辨几乎不计，如果保存成png体积将是jpg的几倍甚至几十倍，严重浪费体积。 Drawable 资源是对图像的一个抽象，你可以通过 getDrawable(int) 得到并绘制到屏幕上。这里有几种不同类型的 Drawable ：   Bitmap File     一个 Bitmap 图像文件（ .png 、 .jpg 或 .gif ）。 BitmapDrawable 。 Nine-Patch File     一个带有伸缩区域的 PNG 文件，可以基于 content 伸缩图片（ .9.png ）。 NinePatchDrawable 。 State List     一个 XML 文件，为不同的状态引用不同的 Bitmap 图像（例如，当按钮按下时使用不同的图片）。 StateListDrawable 。 Color     定义在 XML 中的资源，指定一个矩形（圆角可以有）的颜色。 PaintDrawable 。 Shape     一个 XML 文件，定义了一个几何形状，包括颜色和渐变。 ShapeDrawable 。     JPEG—照片的标准格式，不支持透明。 GIF—被限制在256色因此对于大块纯色和简单图像非常好。它支持透明但是会产生锯齿边缘。 PNG—.jpg和.gif的漂亮结合，具有.jpg图片的质量和.gif的透明度，而且没有锯齿。  ","title":"android 图片格式选择"},{"content":"  图层：Layers       CCLayer同样是CCNode的子类，通常用addChild方法把 CCLayer的子类添加到CCScene中。CCSence提供了一个表演的舞台，而CCLayer提供了舞台中的幕布。 例  在一个scene中建多个layer层 class MenuLayer1 : public CCLayer{ }  class MenuLayer2 : public CCLayer{ } class MenuLayer3 : public CCLayer{ } class MenuLayer4 : public CCLayer{ }     通过switchTo方法进行layer的替换 // 替换到MenuLayer1 void MenuLayer2::menuCallback(CCObject* sender) {      ((CCLayerMultiplex*)m_pParent)->switchTo(0); } MenuLayer1(0), MenuLayer(1), MenuLayer(2)....      CCLayer 对象定义了可描绘的区域，定义了描绘的规则。CCLayer可以实现半透明的效果，令您看到它背后的layers。概括地说：CCLayer 用于定义外观和事件behavior。所以，当编写cocos2d程序的时候，大部分工作就是编写CCLayer的子类去实现所要的效果。    CCLayer 负责处理事件event。Events 会从第一个向最后一个layers传递，直至某个layer获取event并处理它。 虽然某个时候，你需要客户化一个CCLayer类， 但cocos2d已经实现了多种功能的layers（比如菜单layer: CCMenu, 颜色层layer: CCColorLayer,等等）。 Layers 可以包含CCSprite 对象, CCLabel 对象 和其它layer对象。layers是CCNode的子类，所以他们也可以使用actions来转 换坐标. See Actions for more detail about actions. CCLayer:   在同一个场景中需要多个CCLayer时： 方法1 CCScene* scene CCLayer* backgroundscene CCLayer* userInterfaceLayer return 方法2 创建CCScene的子类，然后在各个场景的init方法中生成CCLayer层和其它的对象","title":"cocos2d的Layers"},{"content":"Particle Engine介绍         本文介绍我自己开发的一个游戏编辑器,Particle Engine的主要功能和基本操作;介绍分为三个部分,第一部分介绍开发PE的原因和PE的主要功能;第二部分介绍PE的界面组成;最后一个部分通过PE创建一个简单的Hello World 一什么是PE          PE是ParticleEngine的英文缩写,也就是粒子引擎的意思,这个编辑器最初是为了方便编辑粒子系统而设计的,后来整合了游戏对象,关卡编辑等功能,形成现在这个样子.                   设计PE的主要目的是为了使游戏设计师和游戏美术更直观,高效的开发出2D游戏.PE是基于cocos2d-x引擎,面向游戏逻辑和数据的游戏工具.PE开发出来的游戏是跨平台的,支持在windows,andriod和iphone平台.只需要将生成的资源打包成平台相关的文件,就可以在不同的平台下运行. 二 PE界面介绍          PE的界面组成如下:          1.      场景窗口,显示和编辑游戏对象如粒子,场景等 2.      游戏对象窗口以树形结构显示了游戏场景中的各种对象及对象之间的关系,例如UI,粒子,背景和时间条等 3.      资源列表,以文件列表的形式显示了游戏中引用到的各种资源,如字体,图片和脚本等 4.      属性窗口,显示了当前选中对象的属性,如坐标,缩放和引用文件路径等 5.      菜单栏,操作编辑器的菜单,如打开,保存文件,调度运行和设置等   三 Hello World          我们将通过PE来创建一个简单Hello World的例子(如下图)来大致了解一下PE的特性   下面我们一步一步的来操作 1.点击菜单 File下的NewProject,或者直接用快捷键ctrl+n   2.在弹出的菜单中输入游戏文件名,然后点击保存 3.生成以下界面 4.在游戏对象列表下,选中scene,单击右键,然后在弹出的菜单中点击创建-àCCLabelBMFont,创建一个位图label 5.游戏场景窗口生成了一个位图label 6.在游戏对象列表中左键点击选中刚才创建的label对象 7.查看属性窗口,有以下显示 可以看到这是一个label的一些基本属性,如果位置,缩放等 8.下面让我们来更改字体的显示,由Default变成HelloWorld! 选中string属性,输入Hello World! 此时场景界面如下   9.点击Run菜单下的Iphone或者按F5   10.出下以下界面 一个简单的Hello World就诞生了,虽然这还算不上一个游戏,但我们通过这个小小的例子大概的了解了PE制作游戏的工作流程,在后续的内容中,我将会详细的讲一些实现细节和设计方案!","title":"[置顶] Particle Engine介绍"},{"content":"这个错误搞了我一天了。原来我是做C#开发的，第一次做java，语法不是特别熟悉，另外Eclipse的开发环境也不熟悉。这个错误搞了我一整天了，搞得我都疲惫了，都准备放弃了，后来觉得，我这辈子为了一些看起来很重大的小事放弃了很多重要的人和事，觉得划不来，不能这样，更何况这是一些小事....算了，不八了。 本人的程序特点 1、服务器有个xml文件。 2、下载到本地的SD卡中 3、Android程序读取SD卡中的文件。 读取后报错说格式不对。 后来晚上，问一个朋友，他告诉我Eclipse有个DDMS可以查看SD卡的文件，我打开一看，原来真的下载到SD卡中的文件格式不正确。但服务器的格式是正确的，为什么这样呢？ 后来查看了MARS老师写的FileUtils类，他的写入文件的函数利用的是byte[]方式写入，一开始，他定义的byte[] buffer = byte[4*1024]，这么一个变量。 java的IO操作在读取FileInputSteam流的时候，如果读到最后了还没有填满这个buffer，则又从头开始读，一直要填满这个buffer，再给文件写入。 所以，下载到SD卡中的文件，一直是很大的，原因就是多了很多重复的数据。 后来，我把这个函数改成了一个byte一个byte的读，这样就不会出问题了，因为没有数据比一个byte还小吧。O(∩_∩)O哈哈~。 output = new FileOutputStream(file);\t\t\t//byte[] buffer = new byte[1024];\t\t\tint buffer;\t\t\twhile((buffer = input.read()) != -1){\t\t\t\t//output.write(buffer);\t\t\t\toutput.write(buffer);\t\t\t}\t\t\toutput.flush();","title":"Android开发时出现org.apache.harmony.xml.ExpatParser$ParseException:not well-formed错误时，我所犯的错误"},{"content":"继续NSString,由于用的多，所以应该重点掌握 1、求字符串长度 NSString *myName = @\"AOBAMA\";        int length  = (int)[myName length];//发现返回值类型是NSUInteger,不强转有警告，自己也不知道强转是不是常用的方法，望看到的网友能告知一下        NSLog(@\"字符串的长度是：%d\",length);        if ([myName length] > 5) {            NSLog(@\"AAAAA\");//打印AAAAA        } 2、字符串的相关转换       改变大小写 NSString *string = @\"Where are You,Boy!\";        //都大写        NSLog(@\"%@\",[string uppercaseString]);//打印WHERE ARE YOU,BOY!        //都小写        NSLog(@\"%@\",[string lowercaseString]);//打印where are you,boy!        //所有单词首字母大写，其它字母小写        NSLog(@\"%@\",[string capitalizedString]);//打印Where Are You,Boy! 将字符串转化成基本数据类型 NSString *aboutFloat = @\"3.14\";        NSString *aboutBool = @\"NO\";                NSLog(@\"%f\",[aboutFloat floatValue]);//打印3.140000        NSLog(@\"%d\",[aboutBool boolValue]);//打印0                //把float型转化为整型        NSLog(@\"%d\",[aboutFloat intValue]);//打印3 把两个字符串合并成一个字符串 //方法一        NSString *str1 = @\"Hello\";        NSString *str2 = @\" World\";        NSString *str3 = [[NSString alloc]initWithFormat:@\"%@%@\",str1,str2];        NSLog(@\"str1与str2合并成str3的结果为：%@\",str3);//打印结果：str1与str2合并成str3的结果为：Hello World                //方法二        NSString *str4 = [str1 stringByAppendingString:str2];        NSLog(@\"str1与str2合并成str4的结果为：%@\",str4);//打印结果：str1与str2合并成str4的结果为：Hello World                //连接多个字符串        NSString *str5 = [str1 stringByAppendingFormat:@\"%@%@%@\",str1,str2,str3];        NSLog(@\"str5为：%@\",str5);//打印结果：str5为：HelloHello WorldHello World 3、是否以一个字符串开头hasPrefix:，是否以一个字符串结尾hasSuffix NSString *str6 = @\"who are you\";                BOOL isStart1 = [str6 hasPrefix:@\"wh\"];        BOOL isStart2 = [str6 hasPrefix:@\"h\"];        BOOL isEnd1 = [str6 hasSuffix:@\"u\"];        BOOL isEnd2 = [str6 hasSuffix:@\"o\"];                NSLog(@\"结果：%d,,,%d,,,%d,,,%d\",isStart1,isStart2,isEnd1,isEnd2);//结果：1,,,0,,,1,,,0 4、将字符串按规则截取成数组  NSString *str7 = @\"you/have/a/baby\";        NSArray *array = [str7 componentsSeparatedByString:@\"/\"];        NSLog(@\"%@\",array);//数组可以直接打印不用遍历                /*打印结果         (         you,         have,         a,         baby         )         */ 5、字符串的截取  NSString *str8 = [str7 substringFromIndex:2];//从第二个位置开始街区包括2，当然以0开头        NSLog(@\"%@\",str8);//    u/have/a/baby                NSString *str9 = [str7 substringToIndex:5];//从开始到规定的位置，但不包括该位置        NSLog(@\"%@\",str9);//     you/h                //根据范围截取        NSRange range = NSMakeRange(2, 3);//先定义范围,也可以这样定义NSRange range = {2,3};                NSLog(@\"location..%ld length...%ld\",range.location,range.length);//  location..2 length...3                range.location = 3;//包括2        range.length =4;//从2开始长度为3的子字符串                NSLog(@\"location..%ld length...%ld\",range.location,range.length);//   location..3 length...4                NSString *str10 = [str7 substringWithRange:range];        NSLog(@\"%@\",str10);//    /hav6、字符串查询 NSRange range2 = [str7 rangeOfString:@\"have\"];        NSRange range3 = [str7 rangeOfString:@\"aaa\"];                NSLog(@\"location1...%ld\",range2.location);        NSLog(@\"location2...%ld\",range3.location); 打印结果： location1...4 location2...9223372036854775807 我们可以根据要查询的字符串在源字符串中的位置来判断查找结果。 9223372036854775807既为NSIntegerMax的值 所以我们在判断的时候可以这样 if(range3 == NSIntegerMax) { NSLog(@\"该字符串包含\"); } 关于NSMutableString（可变字符串） NSMutableString继承与NSString,所以NSString中的所有方法都适用于它 1、插入字符串 NSMutableString *str = [[NSMutableString alloc]initWithFormat:@\"hello\"];        [str insertString:@\"wwwwwww\" atIndex:3];                NSLog(@\"%@\",str); 打印结果： helwwwwwwwlo 2、删除字符串 [str deleteCharactersInRange:NSMakeRange(1, 4)];        NSLog(@\"%@\",str); 打印结果： hwwwwwlo 3、替换字符串 [str replaceCharactersInRange:NSMakeRange(1, 3) withString:@\"world\"];        NSLog(@\"%@\",str); 打印结果： hworldwwlo","title":"[置顶] Objective-c的Foundation中常用类2——NSString和NSMutableString"},{"content":"在这里灰常的感谢我的好朋友 严亮同学，思路很严谨，逻辑不错。 （泥马，这实现起来还是有点困难哇，只好等大神门开源了，我自己继续去研究去，或者我做个开源？） 转载请说明出处，尊重原创：（不然就米人原创了，不就途个 作者专属嘛，不能完全拿走主义） a21064346涂相奇（——TXQ——）Cocoa开发 移动开发 QQ:110293734 欢迎交流 http://blog.csdn.net/a21064346/article/details/8446431点击打开链接 比方说这个点 严亮  12:57:44 然后 以绘出来的对象的中心点 为基点，观察基点到你触发点构成的这条线的动向来区分 严亮  12:58:09 比方说  角度变化的浮动范围超过了 15度，则认为是 旋转 严亮  12:58:52 长度发生变化的浮动范围超过了 10像素，则认为是 缩放 严亮  12:58:57 应该可以，这样的话。 严亮  12:59:28 如果浮动范围都超过了，则 两个变化同时刷新跟进。 严亮  13:04:31 还有一个识别方式： 严亮  13:05:04 跟踪指头在1~3 帧内的 点成线的 射线范围 严亮  13:05:39 这样有个好处，识别会很实时，前一个方法会有点延迟的感觉 严亮  13:14:24 严亮  13:14:46 希望能帮到你哈 严亮  13:24:06 重新加了点东西，只用看这幅就够了 严亮  13:24:29 严亮  13:25:48 修改了下文字。。。 严亮  13:25:58 ok，完整版 严亮  13:26:56 象限的分布区域大小，需要多测试，找到平衡点 严亮  13:27:05 不一定是 直角。","title":"IOS 实现 单指（one finger）操作：旋转 缩放。（理想中的逻辑）"},{"content":"本文译自：http://developer.android.com/guide/topics/text/spell-checker-framework.html Android平台提供能够让你在应用程序中执行和访问拼写检查的拼写检查器框架。这个框架是由Android平台提供的文本服务API之一。 要在应用程序中使用该框架，你就要创建一个特殊的Android服务类型，该服务会生成一个拼写检查器的session对象。基于你提供的文本，该session对象会返回由拼写检查器生成的拼写建议。 拼写检查器的生命周期 下图显示了拼写检查器服务的生命周期： 图1.拼写检查服务的生命周期。 要进行拼写检查，你的应用程序就要启动它的拼写检查器的实现。客户端在应用程序中，如Activity或独立的UI元素，首先从服务端申请一个拼写检查的session，然后使用这个session来获得对应文本的拼写建议。当客户端终止了它的操作时，它要关闭它的用于拼写检查的session。如果需要，你的应用程序可以在任何时候关闭拼写检查服务器。 实现一个拼写检查器的服务 要在你的应用程序中使用拼写检查器的框架，就要添加一个包含session对象定义的拼写检查服务组件。你还可以给你的应用程序添加一个控制设置的可选的Activity。你好必须要添加一个描述拼写检查服务的XML元数据文件，并且把对应的元素添加到清单文件中。 拼写检查器的类 使用下面的类来定义服务和session对象： SpellCheckerService的子类： SpellCheckerService类实现了Service类和拼写检查器框架的接口。在你的子类中，你必须实现下面的方法： createSession()   这个一个工厂方法，它能够给想要做拼写检查操作的客户端返回一个SpellCheckerService.Session对象。 这个类实现的更多的信息请看Spell Checker Service示例应用 SpellCheckerService.Session   这是一个拼写检查服务提供给客户端的对象，用它把文本传递给拼写检查器并接收拼写建议。在这个类中，你必须实现以下方法： onCreate()    在对createSession()方法的响应中，系统会调用这个方法，在这个方法中，你可以基于当前的语言环境等来初始化SpellCheckerService.Session对象。 onGetSentenceSuggestionsMultiple()    这个方法执行实际的拼写检查。这个方法会返回SentenceSuggestionsInfo对象的数组，其中包含了对传入句子的拼写建议。 你可以有选择的实现onCancel()，这个方法处理取消拼写检查的请求，onGetSuggestions()用于处理一个单词的建议请求，onGetSuggestionsMultiple()用于批量处理单词建议的请求。 注意：你必须用异步和线程安全的方式来全面的实现拼写检查。一个拼写检查器可以同时被运行在不同核心上的不同线程来调用。SpellCheckerService和SpellCheckerService.Session对象会自动的完成此事。","title":"Android的文本和输入---拼写检查器（一）"},{"content":"1、在Android手机启用USB调试功能 2、在Windows系统中打开命令提示符（开始菜单，选择运行，输入cmd回车即可），使用CD命令切换到Android-SDK\\tools目录下(即adb.exe文件目录下)，Android-SDK为你前面安装Android SDK指定的目录。 3、在命令提示符进入Android-SDK\\tools目录后，输入adb devices回车，你应该可以看到一串序列号，接着输入adb shell pm set-install-location 2，回车，搞定！Android 系统现在会默认安装所有应用程序到SD卡，同时也会启动大部分程序可以移动到手机内部存储。 4、如果想重新设置应用程序默认安装到手机内部存储，可以按照上面的方法，输入adb shell pm set-install-location 0回车即可。  哪些应用程序应该保留在手机内部存储上  需要和Android系统交互并且在后台运行的程序   动态壁纸  Widget小工具  绑定Widget的应用程序（程序安装在SD卡widget将无法使用） 使用上面的方法设置应用程序默认安装到SD卡后，上面提到的这四种类型的程序应该手工转移到手机内存上，原因如下：当你把手机SD卡挂载为系统磁盘后，Android系统将不需要访问安装在内存卡上的应用程序，所以安装在内存卡上的应用程序将被关闭。如果你安装在SD卡的程序需要手机开机时自动启动，不过安装在SD卡的应用程序肯定比安装在手机内存上的应用程序运行更慢，所以SD卡上那些自动运行的程序将无法识别自己的位置，系统会报错，这些程序将无法正常使用。 移动SD卡上的应用程序到手机内存 既然上面这四种程序必须要安装在手机内存才能正常运行，而现在系统又默认安装所有程序到SD卡，这就需要把这些程序手机转移到内存上，手机操作太麻烦，可以在Android Market上下载安装App 2 SD程序，这个程序会自动识别应用程序安装的位置，并且可以很方便的在SD卡和手机内存里方便的互相转移，并且支持批量操作，非常方便。  ","title":"Android eclipse 运行项目设置程序默认安装到SD卡"},{"content":"在一些操作系统中，开启Zombies调试功能会对ARC代码的行为有一些副作用。包括iOS和OS X应用都会受影响。这在iOS 6或更新以及在OS X 10.8或更新中已经被修复。 在iOS 6 / OS X 10.8之前, 使用 the Zombies instrument 或 NSZombieEnabled ，或者 \"Enable Zombie Objects\" Xcode diagnostic, 会导致ARC在释放操作时无法清理实例变量。你的 -dealloc 方法还是会运行，但是任何没有显式置为nil的实例变量都是不可以访问的。如果有实例变量是某个对象的强引用，那么该变量将会被这个不再使用的实例变量始终保持在内存中。 因此，在使用Zombies调试时，强烈建议在iOS 6 +或OS X 10.8+上运行应用。 注意：在iOS5 模拟器中运行的应用的行为和他们在iOS 5中的表现是一致的，即便是模拟器是运行在OS X 10.8中。","title":"为什么在Zombies调试时代码表现不一致?"},{"content":"移动应用程序的市场竞争非常激烈。要让用户在众多的应用程序中注意到你的作品，需要努力的工作和持续的努力。你需要尝试本节中所述的部分或全部销售和推广战术。如果你是为了乐趣或是为了丰富你的履历表而开发应用程序，那么推广方式可以更自由一些。但是推广应用程序仍是值得的：如果你的应用程序十分流行，以至于潜在客户或雇主听说过它们，那么他们就更有可能看重你。 如果编写应用程序是你的主要业务，情况就不同了。为了最有效地利用有限的时间和资源，需要追踪所做的所有工作及其效果。你需要花费时间和资金来运用以下战术： ●   追踪花的每一分钱和每分钟。 ●   使用电子表格跟踪在应用程序上的全部投资。 ●   把时间折算成每天的承包率。 ●   每周汇总一次数据来监控投资情况。 把资金投入不起作用的广告是没有意义的。在营销的过程中，会得到一个非常痛苦的教训：将投入增加一倍，通常只换来百分之几的销量增长。更好的做法是找出合适的营销渠道，将资金和时间投入到这些渠道中。 在开始创建广告文案文本和信息，以及开始为徽标和其他创意付费之前，需要知道你在销售什么。是什么使你的应用程序与众不同？为什么会有人买它？如果你像我一样，在骨子里是一个工程师，那么这些问题将会使你畏缩，觉得找不出这些问题的答案！的确是这样。坐在办公桌前是不可能回答出这些问题的。你需要走出办公室，与人交谈。你需要看到有人在使用你的应用程序。这个过程要重复进行。在早期阶段，发布或构建设计概念之前，就应该让很多人尝试你的应用程序，这样就能够知道其他人对应用程序的看法，而这对你来说会是宝贵的信息。他们的观点可能与你的观点完全不同。测试用户那些看起来是无用的评论很可能向你指出独特的卖点。 注意：不要秘密的开发，试图“完善”你的应用程序。这样不会知道市场上需要什么样的产品。走出去，找出用户真正感兴趣的。 从与试用用户的交谈中，会对应用程序的独特之处形成自己的看法，并知道使用哪些信息进行营销最为有效。过度细化这个过程没有意义。现在你可以发布应用程序并评估结果。结果是否支持你对应用程序及其用户群的看法？数据是否显示一些完全不同的东西，例如你根本不知道存在的充满热情的用户群？不要害怕在推出应用程序后继续完善和调整应用程序。 有一个书面的营销计划很重要。在应用程序上线前的每个星期，你应该为非开发的营销和推广活动做好计划。持续几个月的博客推广可以建立忠实的读者群体，这样的效果比在发布应用程序时进行广告突击会好很多。你的目标应该是让用户知道你是谁，在开发什么，以便使他们准备好在你的应用程序发布时购买。 你可能很容易把重点放在代码和工程方面。不过，为了从应用程序中赚到钱，还需要走出去销售它们。下面介绍一些实用的战术来实现这些销售目标！ 标准战术 你的应用程序需要有一个网站。如果应用程序是现有的网站或服务的扩展，这是很容易的。而如果应用程序是你的主产品，则仍然需要创建一个网站。这个网站是一个与用户交互的地方，他们可以管理自己的账户，并获得你的支持。它也可作为在线推广的营销基地。应用程序如果没有网站，那么即使有优秀的图形设计，仍会显得不够专业。 你的网站需要有一个用户论坛。不管应用程序是多么易用，问题是难免的。你希望有一个地方可以让用户互相帮助。论坛不仅可以解决这个问题，还可以帮助你建立一个宝贵的常见问题的列表，这比你自己随意猜测要可靠多了。论坛还是你与忠实用户互动和为他们提供特别优惠的地方。维护和管理应用程序的论坛需要花费工作和时间。需要把这部分预算计入每周的活动中。一个管理良好的论坛将很有价值，值得建立。 利用社交媒体来推广应用程序是现在标准的做法。因此，你应该确保有Twitter和Facebook账户，并使用更有针对性、用户更可能对你的应用程序更感兴趣的社交媒体，如Quora网站。维护自己在社交媒体中的影响需要一定的时间和精力，也需要为此做好计划。如果你不保持与用户互动，应用程序将无法获得长远的成功。至少，需要为订阅的用户群提供定期的更新。在高端，你可以建立强大的影响力，这有助于巩固客户群。如果应用程序侧重于技术，应该利用旧的社交媒体的优势，如Google Groups或Internet Relay Chat，许多面向技术的用户更乐意使用这些沟通手段。 此外，关注面向市场的邮件列表的效果很好。电子邮件仍然是Internet上最常用的沟通手段。邮件列表的订阅者往往是真正的粉丝，可以直接向他们的收件箱发送邮件。每月的新闻邮件可以提供使用提示、技巧、行业新闻和对你的应用程序所在领域有用的信息。它可以链接到辅助的应用程序和服务。像这样包含高质量内容的邮件会为你创建良好的口碑。使用像MailChimp等服务将邮件发送到邮件列表中的电子邮件，可以避免垃圾邮件黑名单和用户订阅管理等问题。也需要为此预算时间。如果应用程序很成功，或者有营销预算，那么可以逐渐将这部分工作外包。一个好的营销人员可以帮你建立并保持活跃用户量。 注意：你可以看到，当应用程序越来越更成功时，编码占用的时间会越来越少。这是直接利用应用程序谋生不可避免的结果。 当推出应用程序之后，需要处理一些标准的推广活动。例如，需要将应用程序提交到所有的应用程序目录和评论网站，如www.appstorehq.com和http://bestapps.com。将应用程序提交到这些网站是一个吃力不讨好的工作；如果负担得起，应该外包它。 你还需要为应用程序开发一个标准的简短宣传材料，包括文字和图片。然后应该为每个要链接到的目录创建一个着陆页。通过使用单独的页面，可以跟踪每个目录的有效性。还可以为A/B测试使用不同的版本，在着陆页上尝试不同的内容。然后，可以使用这些内容，在应用程序商店列表中来描述应用程序。 在任何成功推出的应用程序中，还有一个重要的手段是博客。需要有一些博客来评论你的应用程序。不要担忧没有读者。甚至不定期更新的博客都有足够的读者。标准的做法是写一封礼貌而简短的电子邮件，说明你的应用程序的关键点，并提供免费下载，让博主可以使用并评论。你可以使用应用程序商店的优惠券支付博主下载应用程序的费用。不用说，要选择内容与你的应用程序相关的博客。要让博客介绍你的应用程序，没有什么万能的方法。你需要逐渐与他们分别建立良好的关系。 注意：不要指望从博主那里得到积极的回应，特别是从流行博客的博主，因为他们会收到很多这样的请求。选择那些不太受欢迎的博客，他们会受宠若惊为你的应用程序写评语。这些博客仍然是有价值的，并会继续在网上流传，为你的应用程序和网站提供基本流量。 获得传统媒体的报道也是很有挑战性的。你需要通过http://prnewswire.com发布一篇新闻稿。不过，如果没有这部分预算，可以自己将新闻稿发送到你认为相关的媒体网站。确保应用程序的网站有“宣传资料袋”(这是一个页面，包含应用程序的基本细节、你的介绍和你的背景，以及以前的新闻稿页面列表)。编写有效的新闻稿并获得传统媒体的报道，这是一个庞大的主题，值得仔细研究。 需要将应用程序提交到可以找到的尽可能多的移动应用程序比赛。移动行业会议通常会有相关的比赛(但要小心那些收费很高的比赛，它们通常不划算)。这有两个好处。首先，你可能会赢，甚至得到安置。至少，你会出现在参赛作品列表中。其次，会有专业人士来审查你的应用程序，并进行极为严格的评估。从参赛作品中，你可能会得到非常有价值的反馈。在提交应用程序来进行比赛时，可以重用你发送给博主的邮件内容和提交给目录的内容。许多比赛还需要应用程序的YouTube演示视频。创建这样的一个视频很值得，因为你可以在其他推广活动中重复使用。我在网站http://mobileapps.listkitty.com上维护一个最新的移动比赛名单，可能会对你有用。 如果你的主要收入来自应用程序的销售，而不是广告或在应用程序内的销售，就需要考虑提供应用程序的精简版本，使用户可以先试用。精简版本应该大大降低功能，并以各种方式加以限制。你可以使用这个版本来促使用户购买完整版本。但是精简版本仍然应该有用，否则可能不会被应用程序商店接受。 注意：精简版还有另一种的危险：负面评论。免费软件大多都受到这个问题的困扰，精简版本尤为严重。因为对软件满意的用户不会卸载应用程序，所以除非他们主动返回应用程序商店来评价你的应用程序，否则他们没有机会这样做。另一方面，那些不满的用户，在卸载它时可能会评价你的应用程序。普通用户只是试用你的应用程序，或没有你的应用程序的服务账户，这必然会降低用户的体验，导致他们发布负面评论。因此，虽然精简版可能会有助于促进销售，但它也可能会适得其反。需要仔细权衡这一点：你的目标用户善变吗？应用程序满足了他们的重要需要吗？如果事情不是按着你的计划进行，就要准备撤下精简版。 最终的标准战术几乎不需要说明：需要为应用程序制定合适的价格！为此，应该以类似应用程序的价格为基准价格。如果你的价格高于或低于预期的价格太多，会损害你的利润。游戏类的应用程序一般相当便宜。扩展现有服务的应用程序可以更贵一些。如果你的服务在某些方面是独特的，或具有很高的价值，就可以提高它的价格。 昂贵战术 如果你有营销预算，那么推广应用程序时，就有了额外的选择。然而，你要小心衡量和跟踪每一份资金投入的地方。有可能将大量资金花费到在线广告上而得不到任何成果，这种情况并不少见。本小节提供了一些网站链接来作为所讨论服务类型的示例。提供这些链接并不表示赞同这些服务。此外，你需要自己研究，才能找到适合自己的预算和需求的服务。 宣传应用程序最主要的地方是应用程序目录网站，这样可以针对那些真正在寻找应用程序的目标用户。根据网站的情况，每个月可能要为一个应用程序的广告支付数百或数千美元。 也可以将目标定为高端读者的内容网站，如http://alistapart.com，这是特别针对iPhone应用程序打广告的网站。对于这种类型的广告，真的需要使用广告网络，如http://fusionads.net。这种营销战术非常昂贵。只有当你正在推广一个品牌，或有非常明确的收入模式时，使用这种战术才合理。 也可以在其他应用程序内宣传你的应用程序。有些网络提供了这种服务，但是费用会很高。使用这种战术时，你是在向针对性很强的用户群做广告，他们肯定有智能手机。 www.admob.com是这类广告的市场领导者。通过使用这种战术，可以很快生成大量的广告浏览器，所以你需要确保自己的营销机构准备好来处理潜在客户的涌入。对这种类型的推广，还需要准备支付可观的费用。 要创建一个持续的营销活动(包括社交媒体和主要内容网站)，可能需要借助应用程序推广机构，如www.apalon.com。通常，这样的服务提供了一定范围内的固定价格推广套餐，可以让你的应用程序出现在多个相应站点中。 如果有预算，这是将应用程序推广的繁重工作外包的一种很划算的方式。这些机构已经开发了媒体关系，这使他们在推广应用程序时比你自己努力要高效得多。这是他们提供的一部分价值。 最后，根据你的业务，可能会发现离线推广应用程序也很有用。传统的媒体，如报纸、电台和电视等拥有大批观众，如果你的公司或客户是知名品牌，这可能是吸引用户的正确方式。不是只有国家级媒体才有用，地区媒体也可以收到良好的效果。作为应用程序的开发人员，可以提出这样的营销策略作为建议，但最好把具体实现方法留给专家。 游击战术 如果是独立的开发人员，没有预算，该怎么办呢？如何让人们购买你的应用程序？这时你需要一些游击战术！如果遵循传统规则，你是没有机会的。相反，你应该努力尝试那些用钱买不到的东西，想方设法让用户喜欢你。 可以为应用程序做的最重要的事情是为它建立一个社区。这个社区由圈内的忠实用户组成，他们会因为喜欢你的应用程序而免费推广它。他们周围的普通用户会对你的应用程序产生好感。你需要从头创建这个社区。 为应用程序社区奠定基础的方法之一是招募测试用户。你要亲自向这些用户介绍，并说服他们试用你的应用程序。你给他们提供尚未在应用程序商店提供的预发布版本。在任何情况下，进行独立的用户测试都是至关重要的，但你也可以利用开发过程中的这个测试，为社区的发展播下种子。你需要让这群人感觉到他们在参与一件很有意义的事。你需要准备与他们持续保持沟通，无论是面对面还是通过电话，同时需要认真采纳他们的反馈。这样，你将使他们感觉到自己也是应用程序的专用所有者。社区建设本身就是一门复杂的艺术。关于这方面，也有一些书和许多博客。做一些研究，掌握窍门，并开发自己的粉丝群。 社区如此宝贵的原因之一是它能够帮助宣传你的应用程序。让你的忠实粉丝在Twitter上转发你的公告；而喜欢你的Facebook状态消息，是在线应用程序推广的一个重要因素。还可以更进一步。为信息的传播者提供奖励非常有效。奖励可以很简单，从tweet转发比赛，到提供应用程序商店的购买信贷。在奖励方法上发挥创意，让它们适合你的用户群和应用程序。通过建立一种激励措施来推广游戏，可以大大提高你的应用程序产生的影响。 还可以改进奖励战术，为发现错误的人提供奖励。这看起来有些危险，有悖常理，但实际上却可以取得巨大的成功。发现错误的用户几乎都是真正的用户，他们真正关心你的程序，会找出包含错误的边缘情况。奖励他们应用程序商店或其他相应服务的礼券。对于高科技的人群，我发现，thinkgeek.com礼券很受欢迎。通过公开奖励发现错误的人，使用户感觉到你对自己的应用程序和业务的诚意。而且你得到了免费的质量保证！ 奖励模型有许多的用途。dropbox.com文件共享工具已成为使用奖励进行病毒式营销的金牌标准。仔细看下该模型的工作方式。当你介绍一个朋友到Dropbox，并且他(或她)通过你的推荐注册之后，你会获得额外的免费存储空间。而你的朋友也会得到比自己直接注册更多的免费存储空间。你的推荐不会被视为不当行为，因为现在是在帮助朋友。这是一个令人难以置信的强大方法，可以用在自己的应用程序中。 这种方法的关键是在应用程序中始终有一个分享屏幕。这是一个方便访问的网页(也许是顶级菜单项)提供了许多分享选项。你可以提供电子邮件、短信、社交网站分享、社会新闻以及其他任何适合自己客户群的信息。应该使用社交网站友好的大图标，并使该页面简单而直观。应用程序中的这个页面可以产生比大多数其他形式的推广多得多的用户。 有人收到下载和购买你的应用程序的邀请后，你需要帮助此人克服存在的任何疑虑。这时你建立的支持网站和在线社区就能够发挥作用了。不同的用户会受不同媒体类型的影响。你需要提供应用程序的完整文字说明和幻灯片演示。为此，可以使用一些服务，如http://slideshare.net。还可以重复使用为参赛作品创建的视频演示。你需要得到一些来自你最狂热的粉丝的心声，这些真的有用，即使它们可能有点俗气！ 销售数字产品时，肯定会遇到盗版问题。那些越狱的用户和那些有手机root权限的用户可以从一些不道德网站下载破解的应用程序。这就是生活。你要么整夜失眠，担心销量受损，要么将它当作市场的另一个挑战。问题的事实是多数盗版者买不起你的应用程序。他们要么是未成年，要么不能使用信贷。不过，你可以这样思考：现在这个时代你必须争取每个细小的网上关注，争取每一位用户，甚至是盗版者也是有一定价值的。他们可能会说服他们更有道德的朋友来购买你的应用程序。如果他们真的很喜欢它，可能会在自己的博客中大加赞赏。他们可能会提高你的“免费”用户的数量。你应该向他们进行推广。不要害怕使你的应用程序成为“pesterware”，让盗版的版本不断弹出窗口，要求用户购买正版产品。虽然破解者可能从破坏应用程序的版权感到乐趣，但他们没有兴趣费力地重新编码来消除弹出窗口。所以要将盗版转变成你的优势，接受它的发生并采取行动，而不是因此失眠。 游击战术中最困难的是发布高价值内容的博客。这里没有神奇的方法。真的要做一些繁重的工作才获得一定的成效。然而，有着大量用户群体的博客所带来的潜在价值是巨大的，而且可以持续多年。你可以撰写与你的应用程序相关的博客，肯定会有用。当然，你应该控制在每篇博客中销售应用程序的冲动。这一主题已经有很多书介绍，所以你可以找些这样的图书阅读。对此我给出的一个意见是数量有时会胜过质量。你写的越多，效果越好。你永远无法预知哪篇文章将流行。一名记者朋友曾经对我说，对每一篇文章都应该“发表后忘记”，一周发帖一次绝对是最低要求。 还有最后一个很简单的游击战术：在电子邮件签名中推广应用程序。在你发送的每封电子邮件底部包括一个到你的应用程序的链接，你会惊奇地发现这有多有效。 总结 上面介绍了销售应用程序的多种战略和战术。不过这只是一个起点。现在你应该知道自己在什么地方欠缺知识，应该到哪里去寻找更多信息，以及如何为你的应用程序策划、执行和运作基本的营销活动。 即使是开发人员，也不应该害怕接触这些营销活动。你可能会发现它们比想象的更有趣。当你从第一次销售中感受到兴奋感后，会体验到一些特别的东西，几乎会上瘾。运作营销活动将提高你的专业水平，所以不应该回避。如果你有条不紊地进行这些活动，是不会有什么问题的。   《移动云计算应用开发入门经典》试读电子书免费提供，有需要的留下邮箱，一有空即发送给大家。 别忘啦顶哦！","title":"移动云计算中选择推广应用程序的战术"},{"content":"【木头Cocos2d-x 026】Lua篇（第01章）：让Lua和C++牵手   网上关于Lua的教程似乎还没有泛滥，最近刚好学习在Cocos2d-x使用Lua，当然了，我是写教程狂，我会分享我的学习心得的~ （旁白：我噗~！每次你写东西我就要吐槽，你不累么= =）     这是第一课，先来让Lua和C++认识一下，顺便让它们逛街吃饭牵小手什么的... （旁白：。。。吹，继续吹）     注：本系列教程部分内容参考《游戏人工智能编程 案例精粹》一书。   笨木头花心贡献，啥？花心？不呢，是用心~ 转载请注明，原文地址：http://blog.csdn.net/musicvs/article/details/8440707    正文：     1. Lua的堆栈和全局表 我们来简单解释一下Lua的堆栈和全局表，堆栈大家应该会比较熟悉，它主要是用来让C++和Lua通信的，是的，它们并不认识对方，只能通过堆栈来沟通，就像写信一样。 （旁白：它们不会用微信吗？！微信~！不知道？）   Lua的全局表又是什么呢？可以想象成是一个map哈希表结构，比如Lua有一个变量： name = “hello” 那么，全局表就存放了”name”和”hello”的对应关系，Lua可以通过name在全局表中查找到hello。应该是这样的~ （旁白：应该= =！）   2. Lua和C++的第一次通信 现在来设计一个场景，C++在一次JavaScript开发者大会上看到Lua在演讲，于是C++被Lua深深吸引了。 （旁白：JavaScript大会...那为毛是Lua在演讲~！）   我们来看看这位美丽的Lua小姐长什么样： -- hello.lua 文件myName = \"beauty girl\"   OK，一位简单又美丽Lua小姐。 然后，C++想知道Lua叫什么名字，所以，它们必须要通信了。来看看通信流程：   请注意红色数字，代表通信顺序： 1） C++想获取Lua的myName字符串的值，所以它把myName放到Lua堆栈（栈顶），以便Lua能看到 2） Lua从堆栈（栈顶）中获取myName，此时栈顶再次变为空 3） Lua拿着这个myName去Lua全局表查找myName对应的字符串 4） 全局表返回一个字符串”beauty girl” 5） Lua把取得的“beauty girl”字符串放到堆栈（栈顶） 6） C++可以从Lua堆栈中取得“beauty girl”，也就是这位美丽的Lua小姐的名字了~ 世界如此美妙，这是如此的简单。 （旁白：好吧，这次不吐槽，确实简单...）   不过，（旁白：我就知道~！我就知道事情没有那么简单！）这只是最简单的情况，实际上各种C++和Lua的操作比这要复杂多了，但基本原理是一样的。 好的，趁着旁白还没有吐槽，我们要结束第一章了，希望能帮到大家。 （旁白：说得好像我好喜欢抢戏似的，我像这样的人吗？= = 等等~!例子呢?Demo呢?）   噢，Demo将在下一章介绍。 （旁白：吊胃口。。。绝对是在吊胃口...你以为我会期待吗，魂淡...心好痒~！）     . .","title":"【木头Cocos2d-x 026】Lua篇（第01章）：让Lua和C++牵手"},{"content":"【木头Cocos2d-x 027】Lua篇（第02章）：Demo讲解之Lua和C++牵手   上一章传送门：http://blog.csdn.net/musicvs/article/details/8440707   本章我们来学习一个小Demo，也就是上一章中的场景：C++从Lua中获取一个全局变量的字符串。     笨木头花心贡献，啥？花心？不呢，是用心~ 转载请注明，原文地址：http://blog.csdn.net/musicvs/article/details/8440919    正文：   1. 引入头文件 我们来看看要在C++中使用Lua，需要些什么东西 /*    文件名：    HelloLua.h    描　述：    Lua Demo   创建人：    笨木头 (CSDN博客：http://blog.csdn.net/musicvs)    创建日期：   2012.12.24 */  #ifndef __HELLO_LUA_H_#define __HELLO_LUA_H_#include \"cocos2d.h\"extern \"C\" {#include <lua.h>#include <lualib.h>#include <lauxlib.h>};using namespace cocos2d;class HelloLua : public CCLayer {public:    CREATE_FUNC(HelloLua);    virtual bool init();    static CCScene* scene();};#endif 看到红色粗体的代码了吗？（旁白：在哪呢？在哪啊？） 在这： extern \"C\" { #include <lua.h> #include <lualib.h> #include <lauxlib.h> }; （旁白：你妹纸的...你不能先贴出来再问吗？~！）   记住了，Lua是C语言库，所以在C++中使用必须用extern “C”声明，让编译器知道。 有了这些，我们就能开始使用Lua了。 （旁白：等等，总感觉有点不对劲= =）   啊，对了，还少一样东西，不过这个不需要我们做了，那就是引入Lua的库，没有库，我们怎么包含头文件都没用。 不过没关系，Cocos2d-x本来就支持Lua，所以这一步我们省下了，为了保险起见，我在新建Demo项目的时候勾选了支持Lua。 建议大家首先能创建一个支持Lua的Cocos2d-x项目，并且能编译运行，然后再继续往下看~ （旁白：你就不能教我们引入Lua库么？= =）   我教？我不懂~   2. 开始使用 来看看我们的cpp文件，我们要开始使用Lua了~！ #include \"HelloLua.h\"CCScene* HelloLua::scene() {    CCScene* scene = CCScene::create();    CCLayer* layer = HelloLua::create();    scene->addChild(layer);    return scene;}bool HelloLua::init() {    lua_State* pL = lua_open();    luaopen_base(pL);    luaopen_math(pL);    luaopen_string(pL);    /* 1.执行Lua脚本,返回0代表成功 */    /* 2.重置栈顶索引 */    /* 3.判断栈顶的值的类型是否为String, 返回非0值代表成功 */　　/* 4.获取栈顶的值 */　　    lua_close(pL);    return true;}   为了不一下子就一大堆代码吓坏大家，我把部分代码先删了，我们来看看现在这个代码的情况： 1） HelloLua是一个场景（旁白：废话...） 2） HelloLua有一个init函数（旁白：你妹纸的，进入正题好不？） 3） 我就喜欢旁白吐槽~（旁白：....） 4） 要使用Lua，首先要有一个lua_State，这是什么呢？我引用《游戏人工智能编程案例精粹》一书的一句话（191页）：“每一个运行的脚本文件都在一个动态分配的叫做lua_State的数据结构中运行”。不明白的话，也没有关系，我们就把lua_State当成是一个Lua的身体，Lua在做任何事情的时候都不能没有身体。 5） 接下来看到几句话：luaopen_base(pL);luaopen_math(pL);luaopen_string(pL); Lua有一些标准库，要使用这些库，就要用luaopen_**去加载这些库 6） 然后最后还有一句话：lua_close(pL)，一看就知道了，用来释放内存的。 7） 旁白呢？（旁白：心情不好...不想吐槽）   3. 执行Lua脚本 现在我们来一步步完善我们的代码，执行Lua脚本很简单，看看： bool HelloLua::init() {    lua_State* pL = lua_open();    luaopen_base(pL);    luaopen_math(pL);    luaopen_string(pL);    /* 1.执行Lua脚本,返回0代表成功 */    int err = luaL_dofile(pL, \"helloLua.lua\");    CCLOG(\"open : %d\", err);    /* 2.重置栈顶索引 */    lua_settop(pL, 0);    lua_getglobal(pL, \"myName\");    /* 3.判断栈顶的值的类型是否为String, 返回非0值代表成功 */　　/* 4.获取栈顶的值 */　　    lua_close(pL);    return true;}   （旁白：不吐槽都不行了。。。你是不是把第2步也不小心放出来了？= =） 我们还要新建一个lua文件，很简单，新建一个文本文件，把后缀名改为lua就行了。现在我们来创建一个helloLua.lua文件： -- helloLua.lua文件myName = \"beauty girl\"   （旁白：别老是忽略我好吧。。。第2步是怎么回事？！） 好，lua文件也有了，在C++中只要调用luaL_dofile就能执行lua脚本了，注意了，必须把lua_State也作为参数传给luaL_dofile，前面已经说了，身体不能少。     4. 重置栈顶索引， 将全局变量放到堆栈中 大家没有发现吗？我把第2步也放出来了~ （旁白：啊喂~！我说了好多次了，我发现了啊~！）   lua_settop(pL, 0);是为了确认让栈顶的索引置为0，因为我们操作栈的时候是根据索引来操作的。置0之后，我们入栈的第一个元素的索引就是1。 那，lua_getglobal(pL, “myName”);又是什么呢？咋一看好像是从lua中取得myName这个全局变量的值，但并不是这样的，虽然最终也是这样。 （旁白：你妹纸的，说清楚点）   我们之前说过了，Lua和C++是不能直接通信的，要通过堆栈来通信。 因此，lua_getglobal(pL, “myName”);只是把myName放到了栈中，然后lua就会通过myName去全局表寻找，找到myName对应的字符串“beauty girl”，再放到栈中。（第01章的时候介绍过的步骤，还记得吗？不记得的建议大家去看看~） （旁白：停！让我缓冲一下...） （旁白： 1.C++把myName放到堆栈 2.lua从堆栈取得myName 3.lua用myName去lua全局表查找获取myName对应的字符串，得到“beauty girl”字符串，然后再放回堆栈 4.最后C++就可以从堆栈中取得“beauty girl”字符串？  好~！明白了~）   5. 最后一步，C++取得字符串 我们来看看完整的代码： bool HelloLua::init() {    lua_State* pL = lua_open();    luaopen_base(pL);    luaopen_math(pL);    luaopen_string(pL);    /* 1.执行Lua脚本,返回0代表成功 */    int err = luaL_dofile(pL, \"helloLua.lua\");    CCLOG(\"open : %d\", err);    /* 2.重置栈顶索引 */    lua_settop(pL, 0);    lua_getglobal(pL, \"myName\");    /* 3.判断栈顶的值的类型是否为String, 返回非0值代表成功 */    int isstr = lua_isstring(pL, 1);    CCLOG(\"isstr = %d\", isstr);    /* 4.获取栈顶的值 */    const char* str = lua_tostring(pL, 1);    CCLOG(\"getStr = %s\", str);    lua_close(pL);    return true;}   lua_getglobal已经完成了很多工作了，现在堆栈上就放着“beauty girl”字符串，我们只要去取就可以了。 获取堆栈的值有很多种方法，分别对应不同的变量类型： lua_toboolean lua_toNumber lua_tocfunction lua_tostring 我就不全部举例了，现在我们要用lua_tostring来获取栈顶的值。 最后，在AppDelegate.cpp中把默认启动场景设为我们的HelloLua场景，用调试模式运行项目，将看到以下日志： open : 0 isstr = 1 getStr = beauty girl 好，本章到此结...（旁白：等等！第3步是什么？你还没有解释啊，魂淡~！）   对了对了，Lua还提供了很多函数供我们判断堆栈中的变量类型，比如lua_isstring、lua_isnumber等等，和lua_tostring等函数是对应的。返回非0值表示类型正确。 一般在取值之前都要判断一下，不能程序很可能意外崩溃~！ （旁白：吓 = =！）   好~本章到此结束~ 6. 赠送的 最后再告诉大家一个笑眯眯~ 那就是用lua_pop(pL, 1); 可以清除指定堆栈上的数据~ 噗，闪人~ （旁白：我帮他解释一下。。。是小秘密。。。不是笑眯眯= =）   . .    ","title":"【木头Cocos2d-x 027】Lua篇（第02章）：Demo讲解之Lua和C++牵手"},{"content":"适用环境：Android 2.1 分享给给位初学者，当中有不错的效果值得学习收藏的哦~ 先上传12个经典源码~后续测试内容敬请期待~~~ 1.冒险类游戏：终极大逃亡 http://www.apkbus.com/android-88896-1-1.html 2.奇艺高清UI界面源码 http://www.apkbus.com/android-88507-1-1.html 3.是男人就下100层英文原版 http://www.apkbus.com/android-88877-1-1.html 4.界面还不错的足球游戏分享 http://www.apkbus.com/android-88851-1-1.html 5.动画顺序播放源码 http://www.apkbus.com/android-88515-1-1.html 6.无损捕鱼达人源码 http://www.apkbus.com/android-88511-1-1.html 7.策略型大型战争游戏 http://www.apkbus.com/android-88881-1-1.html 8.斗地主源码分享 http://www.apkbus.com/android-88862-1-1.html 9.再放精品推箱子游戏 http://www.apkbus.com/android-88523-1-1.html 10.简易音乐播放器源码 http://www.apkbus.com/android-88512-1-1.html 11.ViewPager+Fragment实现QQ界面 http://www.apkbus.com/android-88510-1-1.html 12.图片浏览源码 http://www.apkbus.com/android-88503-1-1.html 更多资源尽在：http://www.apkbus.com/Android-44-1.html","title":"推荐12个Android开发源码（包括应用、游戏、效果等等）"},{"content":"本系列博客是由扭曲45原创，欢迎转载，转载时注明出处，http://blog.csdn.net/cg0206/article/details/8441644 TOI全称Time of Impact，中文的意思是撞击时间，在Box2d中，我们用b2TimeOfImpact来确定两个形状运动时的撞击时间(TOI)。同时b2TimeOfImpact也主要防止两个形状快速移动时可能在一个时间步内彼此穿越对方的情况，也就是我们经常所说的隧道效应。 我们就一起看源码吧。 1)、b2TimeOfImpact.h文件。 // b2TimeOfImpace的输入参数struct b2TOIInput{\tb2DistanceProxy proxyA;  //距离代理A\tb2DistanceProxy proxyB;  //距离代理B\tb2Sweep sweepA;          //扫描A\tb2Sweep sweepB;          //扫描B\tfloat32 tMax;\t\t     //定义扫频间隔 [0, tMax]};//b2TimeOfImpact的输出参数struct b2TOIOutput{\tenum State\t{\t\te_unknown,      //未知\t\te_failed,       //失败\t\te_overlapped,   //重叠\t\te_touching,     //触碰\t\te_separated     //分离\t};\tState state;       //状态\tfloat32 t;         //扫频间隔};/*************************************************************************** 功能描述：在两个形状穿透之前，及时的求出上边界。用分数表示时间            在[0,tMax]之间。它使用扫频分离轴和可能丢失一些像非隧道效应碰撞的\t\t\t中间体，如果你改变时间间隔，你需要重新调用这个函数\t\t\t注意：使用b2Distance去求在一个撞击时间内的接触点和法线* 参数说明：output：TOI输出参数指针\t        input ：TOI输入参数指针* 返 回 值： (void)**************************************************************************/void b2TimeOfImpact(b2TOIOutput* output, const b2TOIInput* input); 我们可以看到此处定义了用于保存TOI信息的结构体，分别是b2TOIInput、b2TOIOutput结构体，表示碰撞时间的输入和输出参数。对于b2TimeOfImpact函数，则是这篇文章的主角，用于防止两物体之间的隧道效应，关于此函数的具体情况，等到实现的时候在详细的和大家聊聊。   2)、b2TimeOfImpact.cpp文件。 我们再来看看b2TimeOfImpact.cpp文件。为了更好的看源码，将分成以下三点： 全局变量的定义 b2SeparationFunction结构体的实现 b2TimeOfImpact函数的实现   1、全局变量的定义 int32 b2_toiCalls, b2_toiIters, b2_toiMaxIters;   //调用次数、toi的迭代次数、toi的最大迭代次数（两层循环中取最大的那个）int32 b2_toiRootIters, b2_toiMaxRootIters;        //根总共迭代次数、在所有根迭代中最大的那次 2、b2SeparationFunction结构体的实现 struct b2SeparationFunction{\tenum Type\t{\t\te_points,           //点\t\te_faceA,            //面A\t\te_faceB             //面B\t};\t/**************************************************************************\t* 功能描述：如果不需要就返回间距值\t* 参数说明：cache ：单纯形缓存指针\t            proxyA：多边形A的指针\t\t\t\tsweepA：扫频对象的引用\t\t\t\tproxyB：多边形B的指针\t\t\t\tsweepB：扫频对象的引用\t\t\t\tt1    ：扫频间隔\t* 返 回 值： 间距值\t**************************************************************************/\tfloat32 Initialize(const b2SimplexCache* cache,\t\tconst b2DistanceProxy* proxyA, const b2Sweep& sweepA,\t\tconst b2DistanceProxy* proxyB, const b2Sweep& sweepB,\t\tfloat32 t1)\t{\t\t//赋值代理\t\tm_proxyA = proxyA;\t\tm_proxyB = proxyB;\t\t// 获取缓存中的顶点数，并验证\t\tint32 count = cache->count;\t\tb2Assert(0 < count && count < 3);\t\t//赋值扫频\t\tm_sweepA = sweepA;\t\tm_sweepB = sweepB;\t\t//获取变换\t\tb2Transform xfA, xfB;\t\tm_sweepA.GetTransform(&xfA, t1);\t\tm_sweepB.GetTransform(&xfB, t1);\t\t//一个顶点\t\tif (count == 1)\t\t{\t\t\t//赋值，获得A、B的局部顶点\t\t\tm_type = e_points;\t\t\tb2Vec2 localPointA = m_proxyA->GetVertex(cache->indexA[0]);\t\t\tb2Vec2 localPointB = m_proxyB->GetVertex(cache->indexB[0]);\t\t\t//获取变换后的A、B点\t\t\tb2Vec2 pointA = b2Mul(xfA, localPointA);\t\t\tb2Vec2 pointB = b2Mul(xfB, localPointB);\t\t\t//获取从B到的A的向量，返回其长度，并标准化\t\t\tm_axis = pointB - pointA;\t\t\tfloat32 s = m_axis.Normalize();\t\t\treturn s;\t\t}\t\telse if (cache->indexA[0] == cache->indexA[1])\t\t{\t\t\t// 两个点在B上和一个在A上\t\t\t//赋值，获取B上的两个局部顶点\t\t\tm_type = e_faceB;\t\t\tb2Vec2 localPointB1 = proxyB->GetVertex(cache->indexB[0]);\t\t\tb2Vec2 localPointB2 = proxyB->GetVertex(cache->indexB[1]);\t\t\t//获取B2到B1形成向量的垂直向量，并标准化\t\t\tm_axis = b2Cross(localPointB2 - localPointB1, 1.0f);\t\t\tm_axis.Normalize();\t\t\t//获取法向量\t\t\tb2Vec2 normal = b2Mul(xfB.q, m_axis);\t\t\t// 获取B1到B2的中间点\t\t\tm_localPoint = 0.5f * (localPointB1 + localPointB2);\t\t\tb2Vec2 pointB = b2Mul(xfB, m_localPoint);\t\t\t// 获取局部点A，并求得点A\t\t\tb2Vec2 localPointA = proxyA->GetVertex(cache->indexA[0]);\t\t\tb2Vec2 pointA = b2Mul(xfA, localPointA);\t\t\t// 获取距离\t\t\tfloat32 s = b2Dot(pointA - pointB, normal);\t\t\t// 距离为负，置反\t\t\tif (s < 0.0f)\t\t\t{\t\t\t\tm_axis = -m_axis;\t\t\t\ts = -s;\t\t\t}\t\t\treturn s;\t\t}\t\telse\t\t{\t\t\t// 两个点在A上和一个或者两个点在B上\t\t\tm_type = e_faceA;\t\t\tb2Vec2 localPointA1 = m_proxyA->GetVertex(cache->indexA[0]);\t\t\tb2Vec2 localPointA2 = m_proxyA->GetVertex(cache->indexA[1]);\t\t\t//获取A2到A1形成向量的垂直向量，并标准化\t\t\tm_axis = b2Cross(localPointA2 - localPointA1, 1.0f);\t\t\tm_axis.Normalize();\t\t\t//获取法向量\t\t\tb2Vec2 normal = b2Mul(xfA.q, m_axis);\t\t\t//获取A1和A2的中间点\t\t\tm_localPoint = 0.5f * (localPointA1 + localPointA2);\t\t\tb2Vec2 pointA = b2Mul(xfA, m_localPoint);\t\t\t//获取局部点，并求得点B\t\t\tb2Vec2 localPointB = m_proxyB->GetVertex(cache->indexB[0]);\t\t\tb2Vec2 pointB = b2Mul(xfB, localPointB);\t\t\t//获取距离，并处理\t\t\tfloat32 s = b2Dot(pointB - pointA, normal);\t\t\tif (s < 0.0f)\t\t\t{\t\t\t\tm_axis = -m_axis;\t\t\t\ts = -s;\t\t\t}\t\t\treturn s;\t\t}\t}\t/**************************************************************************\t* 功能描述：寻找最小距离\t* 参数说明：indexA ：点A的索引\t            indexB ：点B的索引\t\t\t\tt      ：时间值\t* 返 回 值： 最小距离\t**************************************************************************/\tfloat32 FindMinSeparation(int32* indexA, int32* indexB, float32 t) const\t{\t\t//声明变换A、B，用于获取在t时间里获得窜改变换\t\tb2Transform xfA, xfB;\t\tm_sweepA.GetTransform(&xfA, t);\t\tm_sweepB.GetTransform(&xfB, t);\t\t//处理不同的类型\t\tswitch (m_type)\t\t{\t\tcase e_points:                                //点\t\t\t{\t\t\t\t//通过转置旋转m_axis获取单纯形支撑点的方向向量\t\t\t\tb2Vec2 axisA = b2MulT(xfA.q,  m_axis);\t\t\t\tb2Vec2 axisB = b2MulT(xfB.q, -m_axis);\t\t\t\t//通过方向向量获取局部顶点的索引\t\t\t\t*indexA = m_proxyA->GetSupport(axisA);\t\t\t\t*indexB = m_proxyB->GetSupport(axisB);\t\t\t\t//通过索引获取局部顶点\t\t\t\tb2Vec2 localPointA = m_proxyA->GetVertex(*indexA);\t\t\t\tb2Vec2 localPointB = m_proxyB->GetVertex(*indexB);\t\t\t\t//通过变换局部点获取两形状之间的顶点\t\t\t\tb2Vec2 pointA = b2Mul(xfA, localPointA);\t\t\t\tb2Vec2 pointB = b2Mul(xfB, localPointB);\t\t\t\t//求两形状的间距，并返回。\t\t\t\tfloat32 separation = b2Dot(pointB - pointA, m_axis);\t\t\t\treturn separation;\t\t\t}\t\tcase e_faceA:                              //面A\t\t\t{\t\t\t\t//通过转置旋转m_axis获取单纯形支撑点的方向向量\t\t\t\t//通过变换局部点获取当前图形的点\t\t\t\tb2Vec2 normal = b2Mul(xfA.q, m_axis);\t\t\t\tb2Vec2 pointA = b2Mul(xfA, m_localPoint);\t\t\t\t//通过转置旋转m_axis获取单纯形支撑点的方向向量\t\t\t\tb2Vec2 axisB = b2MulT(xfB.q, -normal);\t\t\t\t//通过索引获取局部顶点\t\t\t\t*indexA = -1;\t\t\t\t*indexB = m_proxyB->GetSupport(axisB);\t\t\t\t//通过变换局部点获形状B的顶点\t\t\t\tb2Vec2 localPointB = m_proxyB->GetVertex(*indexB);\t\t\t\tb2Vec2 pointB = b2Mul(xfB, localPointB);\t\t\t\t//求两形状的间距，并返回。\t\t\t\tfloat32 separation = b2Dot(pointB - pointA, normal);\t\t\t\treturn separation;\t\t\t}\t\tcase e_faceB:                             //面B\t\t\t{\t\t\t\t//通过转置旋转m_axis获取单纯形支撑点的方向向量\t\t\t\t//通过变换局部点获取当前图形的点\t\t\t\tb2Vec2 normal = b2Mul(xfB.q, m_axis);\t\t\t\tb2Vec2 pointB = b2Mul(xfB, m_localPoint);\t\t\t\t//通过转置旋转m_axis获取单纯形支撑点的方向向量\t\t\t\tb2Vec2 axisA = b2MulT(xfA.q, -normal);\t\t\t\t//通过索引获取局部顶点\t\t\t\t*indexB = -1;\t\t\t\t*indexA = m_proxyA->GetSupport(axisA);\t\t\t\t//通过变换局部点获形状A的顶点\t\t\t\tb2Vec2 localPointA = m_proxyA->GetVertex(*indexA);\t\t\t\tb2Vec2 pointA = b2Mul(xfA, localPointA);\t\t\t\t//求两形状的间距，并返回。\t\t\t\tfloat32 separation = b2Dot(pointA - pointB, normal);\t\t\t\treturn separation;\t\t\t}\t\tdefault:\t\t\tb2Assert(false);\t\t\t*indexA = -1;\t\t\t*indexB = -1;\t\t\treturn 0.0f;\t\t}\t}\t/**************************************************************************\t* 功能描述：当前时间步里两形状的距离\t* 参数说明：indexA ：点A的索引\t            indexB ：点B的索引\t\t\t\tt      ：时间值\t* 返 回 值： 当前时间步里两形状的距离\t**************************************************************************/\tfloat32 Evaluate(int32 indexA, int32 indexB, float32 t) const\t{\t\tb2Transform xfA, xfB;\t\tm_sweepA.GetTransform(&xfA, t);\t\tm_sweepB.GetTransform(&xfB, t);\t\tswitch (m_type)\t\t{\t\tcase e_points:                                //点\t\t\t{\t\t\t\t//通过转置旋转m_axis获取顶点的方向向量\t\t\t\tb2Vec2 axisA = b2MulT(xfA.q,  m_axis);\t\t\t\tb2Vec2 axisB = b2MulT(xfB.q, -m_axis);\t\t\t\t//通过变换局部点获形状A、B的顶点\t\t\t\tb2Vec2 localPointA = m_proxyA->GetVertex(indexA);\t\t\t\tb2Vec2 localPointB = m_proxyB->GetVertex(indexB);\t\t\t\t//获取当前时间步内的两形状上的点\t\t\t\tb2Vec2 pointA = b2Mul(xfA, localPointA);\t\t\t\tb2Vec2 pointB = b2Mul(xfB, localPointB);\t\t\t\t//计算间距，并返回间距\t\t\t\tfloat32 separation = b2Dot(pointB - pointA, m_axis);\t\t\t\treturn separation;\t\t\t}\t\tcase e_faceA:                                 //面A\t\t\t{\t\t\t\t//旋转m_axis向量，获取法向量，同时根据局部点求形状A上的点\t\t\t\tb2Vec2 normal = b2Mul(xfA.q, m_axis);\t\t\t\tb2Vec2 pointA = b2Mul(xfA, m_localPoint);\t\t\t\t//通过转置旋转m_axis获取单纯形支撑点的方向向量\t\t\t\tb2Vec2 axisB = b2MulT(xfB.q, -normal);\t\t\t\t//通过索引获取局部顶点，进而通过变换局部点获取当前时间步内的点\t\t\t\tb2Vec2 localPointB = m_proxyB->GetVertex(indexB);\t\t\t\tb2Vec2 pointB = b2Mul(xfB, localPointB);\t\t\t\t//获取间距\t\t\t\tfloat32 separation = b2Dot(pointB - pointA, normal);\t\t\t\treturn separation;\t\t\t}\t\tcase e_faceB:                                 //面B\t\t\t{\t\t\t\t//旋转m_axis向量，获取法向量，同时根据局部点求形状B上的点\t\t\t\tb2Vec2 normal = b2Mul(xfB.q, m_axis);\t\t\t\tb2Vec2 pointB = b2Mul(xfB, m_localPoint);\t\t\t\t//通过转置旋转m_axis获取单纯形支撑点的方向向量\t\t\t\tb2Vec2 axisA = b2MulT(xfA.q, -normal);\t\t\t\t//通过索引获取局部顶点，进而通过变换局部点获取当前时间步内的点\t\t\t\tb2Vec2 localPointA = m_proxyA->GetVertex(indexA);\t\t\t\tb2Vec2 pointA = b2Mul(xfA, localPointA);\t\t\t\t//获取间距\t\t\t\tfloat32 separation = b2Dot(pointA - pointB, normal);\t\t\t\treturn separation;\t\t\t}\t\tdefault:\t\t\tb2Assert(false);\t\t\treturn 0.0f;\t\t}\t}\tconst b2DistanceProxy* m_proxyA;          //代理A\tconst b2DistanceProxy* m_proxyB;          //代理B\tb2Sweep m_sweepA, m_sweepB;               //扫描A、B\tType m_type;                              //类型变量\tb2Vec2 m_localPoint;                      //局部点\tb2Vec2 m_axis;                            //方向向量，主要用于变换次向量之后求形状的顶点}; 关于b2SeparationFunction结构体主要用于查找两个形状间距的相关操作。我们主要来说说其内部函数的实现。 关于Initialize函数主要初始化成员变量，并返回两个形状之间的距离。 关于FindMinSeparation函数主要是根据不同的单纯形类型在时间步内寻找最小距离，并返回其两个顶点的索引，作为两形状是否碰撞的见证点。 关于Evaluate函数主要是根据不同的单纯形类型和FindMinSeparation所查到的见证点获取当前两形状的距离。   3、 b2TimeOfImpact函数的实现 //CCD（continuous collision detection，持续碰撞检验）经过局部的分离轴方法。//这种寻求进展通过计算最大的时间保持分离。void b2TimeOfImpact(b2TOIOutput* output, const b2TOIInput* input){\t//调用次数自加\t++b2_toiCalls;\t//赋值output\toutput->state = b2TOIOutput::e_unknown;\toutput->t = input->tMax;\t//获取距离代理\tconst b2DistanceProxy* proxyA = &input->proxyA;\tconst b2DistanceProxy* proxyB = &input->proxyB;\t//获取扫频\tb2Sweep sweepA = input->sweepA;\tb2Sweep sweepB = input->sweepB;\t// 大型旋转可以使根检索器失效，所以我们标准化扫频角度\tsweepA.Normalize();\tsweepB.Normalize();\t//获取扫频间隔\tfloat32 tMax = input->tMax;\t//获取两个形状半径之和\tfloat32 totalRadius = proxyA->m_radius + proxyB->m_radius;\tfloat32 target = b2Max(b2_linearSlop, totalRadius - 3.0f * b2_linearSlop);\t//允许误差\tfloat32 tolerance = 0.25f * b2_linearSlop;\t//验证有效值\tb2Assert(target > tolerance);\tfloat32 t1 = 0.0f;\t//最大迭代次数\tconst int32 k_maxIterations = 20;\t// TODO_ERIN b2Settings\t//\tint32 iter = 0;\t// 初始化距离输入参数\tb2SimplexCache cache;\tcache.count = 0;\tb2DistanceInput distanceInput;\tdistanceInput.proxyA = input->proxyA;\tdistanceInput.proxyB = input->proxyB;\tdistanceInput.useRadii = false;\t// 外面的循环逐步尝试计算新的分离轴\t// 当一个轴是重复的(没有进展)，这个循环终止\tfor(;;)\t{\t\tb2Transform xfA, xfB;\t\tsweepA.GetTransform(&xfA, t1);\t\tsweepB.GetTransform(&xfB, t1);\t\t// 获取形状之间的距离。我们也可以使用这个结果去获得一个分离轴\t\tdistanceInput.transformA = xfA;\t\tdistanceInput.transformB = xfB;\t\tb2DistanceOutput distanceOutput;\t\tb2Distance(&distanceOutput, &cache, &distanceInput);\t\t// 如果形状重叠，我们放弃连续碰撞\t\tif (distanceOutput.distance <= 0.0f)\t\t{\t\t\t//失败！\t\t\toutput->state = b2TOIOutput::e_overlapped;\t\t\toutput->t = 0.0f;\t\t\tbreak;\t\t}\t\tif (distanceOutput.distance < target + tolerance)\t\t{\t\t\t//胜利！\t\t\toutput->state = b2TOIOutput::e_touching;\t\t\toutput->t = t1;\t\t\tbreak;\t\t}\t\t// 初始化分离轴\t\tb2SeparationFunction fcn;\t\tfcn.Initialize(&cache, proxyA, sweepA, proxyB, sweepB, t1);#if 0\t\t// Dump the curve seen by the root finder\t\t{\t\t\tconst int32 N = 100;\t\t\tfloat32 dx = 1.0f / N;\t\t\tfloat32 xs[N+1];\t\t\tfloat32 fs[N+1];\t\t\tfloat32 x = 0.0f;\t\t\tfor (int32 i = 0; i <= N; ++i)\t\t\t{\t\t\t\tsweepA.GetTransform(&xfA, x);\t\t\t\tsweepB.GetTransform(&xfB, x);\t\t\t\tfloat32 f = fcn.Evaluate(xfA, xfB) - target;\t\t\t\tprintf(\"%g %g\\n\", x, f);\t\t\t\txs[i] = x;\t\t\t\tfs[i] = f;\t\t\t\tx += dx;\t\t\t}\t\t}#endif\t\t//在分离轴上计算TOI（碰撞时间），我们先后解决最深处的点。这个循环是以顶点数为终止条件的\t\tbool done = false;\t\tfloat32 t2 = tMax;\t\tint32 pushBackIter = 0;\t\tfor (;;)\t\t{\t\t\t// 在t2上查找最深点，存储见证点索引\t\t\tint32 indexA, indexB;\t\t\tfloat32 s2 = fcn.FindMinSeparation(&indexA, &indexB, t2);\t\t\t// 是否是最终的外形分离\t\t\tif (s2 > target + tolerance)\t\t\t{\t\t\t\t//胜利！\t\t\t\toutput->state = b2TOIOutput::e_separated;\t\t\t\toutput->t = tMax;\t\t\t\tdone = true;\t\t\t\tbreak;\t\t\t}\t\t\t//分离值是否达到误差值\t\t\tif (s2 > target - tolerance)\t\t\t{\t\t\t\t// 推进扫描\t\t\t\tt1 = t2;\t\t\t\tbreak;\t\t\t}\t\t\t// 使用见证点计算最初的间距\t\t\tfloat32 s1 = fcn.Evaluate(indexA, indexB, t1);\t\t\t// 检验最初重叠。有可能发生根检索器超出了迭代总的次数的现象。\t\t\tif (s1 < target - tolerance)\t\t\t{\t\t\t\toutput->state = b2TOIOutput::e_failed;\t\t\t\toutput->t = t1;\t\t\t\tdone = true;\t\t\t\tbreak;\t\t\t}\t\t\t// 检查触碰\t\t\tif (s1 <= target + tolerance)\t\t\t{\t\t\t\t// 胜利！t1必须保留TOI(只有可能是0)\t\t\t\toutput->state = b2TOIOutput::e_touching;\t\t\t\toutput->t = t1;\t\t\t\tdone = true;\t\t\t\tbreak;\t\t\t}\t\t\t//计算1D root ： f(x) - target = 0\t\t\tint32 rootIterCount = 0;\t\t\tfloat32 a1 = t1, a2 = t2;\t\t\tfor (;;)\t\t\t{\t\t\t\t// 混合使用割线规则和二分法\t\t\t\tfloat32 t;\t\t\t\tif (rootIterCount & 1)\t\t\t\t{\t\t\t\t\t// 割线规则来提高收敛\t\t\t\t\tt = a1 + (target - s1) * (a2 - a1) / (s2 - s1);\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\t// 二分法保证进度\t\t\t\t\tt = 0.5f * (a1 + a2);\t\t\t\t}\t\t\t\tfloat32 s = fcn.Evaluate(indexA, indexB, t);\t\t\t\tif (b2Abs(s - target) < tolerance)\t\t\t\t{\t\t\t\t\t// 赋值\t\t\t\t\tt2 = t;\t\t\t\t\tbreak;\t\t\t\t}\t\t\t\t// 确保我们查找根\t\t\t\tif (s > target)\t\t\t\t{\t\t\t\t\ta1 = t;\t\t\t\t\ts1 = s;\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\ta2 = t;\t\t\t\t\ts2 = s;\t\t\t\t}\t\t\t\t//根迭代器\t\t\t\t++rootIterCount;\t\t\t\t++b2_toiRootIters;\t\t\t\t// 循环到达50次后，退出\t\t\t\tif (rootIterCount == 50)\t\t\t\t{\t\t\t\t\tbreak;\t\t\t\t}\t\t\t}\t\t\t\t\t\tb2_toiMaxRootIters = b2Max(b2_toiMaxRootIters, rootIterCount);\t\t\t//记录顶点迭代器\t\t\t++pushBackIter;\t\t\t//达到顶点的最大次数，退出\t\t\tif (pushBackIter == b2_maxPolygonVertices)\t\t\t{\t\t\t\tbreak;\t\t\t}\t\t}\t\t//根迭代器\t\t++iter;\t\t//toi的迭代次数自增\t\t++b2_toiIters;\t\tif (done)\t\t{\t\t\tbreak;\t\t}\t\tif (iter == k_maxIterations)\t\t{\t\t\t//没有找到根\t\t\toutput->state = b2TOIOutput::e_failed;\t\t\toutput->t = t1;\t\t\tbreak;\t\t}\t}\t//获取toi最大迭代器\tb2_toiMaxIters = b2Max(b2_toiMaxIters, iter);} 关于b2TimeOfImpact函数，主要以3重for循环为主线的，第一层for循环主要是逐步尝试计算新的分离轴，并当出现一个轴是重复的时，终止循环。第二层for循环主要是在分离轴上计算TOI（碰撞时间），我们先后解决最深处的点。这个循环是以顶点数为终止条件的。第三层for循环主要使用割线规则和二分法进行求解在t时间内，两物体碰撞的具体的时间值。这个循环是以找到在误差允许的范围内的时间值或者循环50次为终止条件的。 另外想说一下，在这里我们每个循环的写法是for(;;)这样的，个人感觉不太雅致，也不能看一眼而不用思索的就知道是死循环的写法，如改成while(true)或者while(1)更好。 关于两物体间是否碰撞了？在Box2d中目前我们至少知道3种可以判断的方法，它们分别是： a)、通过两物体的aabb，判断是否重叠。 b)、通过GJK算法算出两物体间的距离，根据距离判断是否碰撞 c)、通过SAT分离轴算法看是否能找出两物体间的分离轴，如果找得出就没有碰撞，找不出则碰撞。   Ok，碰撞部分终于学完了，下面我们将继续学习动力学部分。不早了，各位早安。。。 ps：   以上文章仅是一家之言，若有不妥、错误之处，请大家多多指出。同时也希望能与大家多多交流，共同进步。","title":"Box2d源码学习<十四>TOI之碰撞时间的实现"},{"content":"（欢迎大家加入android技术交流QQ群：209796692） 实现ContentProvider MIME 类型 ContentProvider 有两个方法返回MIME类型。  getType()  一个对任何provider都要实现的方法。  getStreamTypes()  如果你的provider提供的是文件，此方法是期望被实现的。  表的MIME类型们 getType()方法返回一个MIME格式的String ，此String描述了由content URI参数计算出的数据类型。Uri 可以是一个模式而不是一个具体的URI；此时，你应该返回对应于那些符合content URI模式的的数据的类型。 对于普通的数据类型，比如文本， HTML或 JPEG，getType()应该返回标准的MIME类型。关于标准MIME类型的一个完整的列表能在IANA MIME Media Types 网站上找到。  对于指向表数据的一行或多行的content URI们，getType()应返回一个Android vendor-specific MIME 格式：  · 类型部分：vnd  · 子类型部分：  · 如果URI指向单行：android.cursor.item/  · 如果URI 指向多行：android.cursor.dir/  · Provider-specific 部分：vnd.<name>.<type>  你要提供 <name> 和 <type>。<name>的值应是一个全局唯一的，并且<type> 的值对于对应的URI模式也需是唯一的。对<name> 的一个好的选择是用你公司的名字或你的应用的Android包名的一部分。对于<type>的一个好的选择是使用标志与URI相关连的表的字符串。  例如，如果一个provider的authority是com.example.app.provider，并且它曝露了一个叫做table1的表，那么表示表中多行的MIME类型就是：  vnd.android.cursor.dir/vnd.com.example.provider.table1 表示单行的MIME类型是：  vnd.android.cursor.item/vnd.com.example.provider.table1 表示文件的MIME 们 如果你的provider提供文件，就要实现getStreamTypes()。这个方法对传入的content URI返回一个由指向文件们的MIME类型组成的String 数组，你应该跟据MIME类型过虑参数过虑MIME 类型们，所以你只返回那些客户端真正相要的MIME类型们。  例如，假设一个provider提供图像文件，有 .jpg， .png，和 .gif类型。如果一个应用使用过滤字符串image/* (表示某些是\"image\"的东西)调用ContentResolver.getStreamTypes() ，那么ContentProvider.getStreamTypes() 方法应返回数组：  { \"image/jpeg\", \"image/png\", \"image/gif\"} 如果应用只对.jpg 文件感兴趣，它应使用过滤字符串 *\\/jpeg 调用 ContentResolver.getStreamTypes()，并且 ContentProvider.getStreamTypes()应该返回：  {\"image/jpeg\"} 如果你的provider没有提供过滤字符串中所请求的MIME， getStreamTypes() 应返回 null.  实现一个Contract（契约）类 Contract class是一个public final 类，它包含有定义URI们的常量，列的名字，MIME类型们，以及其它用于provider的元数据。这个类建立了一个provider和其它应用之间的契约以保证在URI、列名等项的值发生变化时依然能被正确的操作。 一个契约类对开发者有帮助，因为它提供了一个好识别的名字，而不用直接使用数字，于是开发者就不会为列名或URI们使用错误的值。因为它是一个类，它就可以包含Javadoc文档。集成开发环境，比如Eclipse可以跟据契约类自动完成常量名并为常量显示Javadoc。  开发者不能从你的应用操作契约类的类文件，但是他们可以从你提供的.jar文件中静态的把它编译到他们的应用中 。  ContactsContract 类和它的嵌套类们就是契约类的例子。  实现Content Provider 权限 对android系统的所有方面的权限在主题Security and Permissions中有详细的描述。主题 Data Storage 中也描术了安全和权限对各种存储类型的影响。简略的说，重要的几点是：  · 默认下，存储在设备的内部存储器上的数据文件是你的应用和provider私有的。  · 你创建的SQLiteDatabase 数据库是你的应用和provider私有的。  · 默认上，保存到外部存储器上的数据文件是公有的和全局可读的。你不能使用一个content provider来限制外部存储上的文件的操作，因为其它应用可以使用其它API 来读写它们。  · 那些用于在你的设备内部存储器上打开或创建文件或SQLite数据的方法们可能会暗中给予其它应用读写的权限。如果你使用一个内部文件或数据库作为你的provider的数据仓库，并且你给予它们\"world-readable\" 或\"world-writeable\" 权限，你在manifest中对你的provider的权限声明将不能保护你的数据。内部存储上的文件和数据库的的默认权限是\"private\"，并且你也不应该改变你的provider的数据仓库的权限。  如果你想使用content provider 的权限来控制对你的数据的操作，那么你应该存储你的数据到内部文件，SQLite 数据库，或\"cloud\" (例如，在一个远程服务上)，并且你应该保持文件和数据库私属于你的应用。  实现权限 所有的应用都可以从你的provider读或写你的provider写，即使后台的数据是私有的。因为默认下你的provider 没有权限设置。要改变这种情况，可以在manifest文件中设置你的provider的权限，使用<provider> 元素的属性或其儿子元素。你可以设置应用于整个provider的权限，或只应用于特定表的，或特定记录的，或所有三者的。  你在manifest文件中用一个或多个<permission> 元素定义你的provider的权限。要使用于你的provider的权限是唯一的，为使用android:name属性使用Java风格的范围限定。例如， 为读权限命名为com.example.app.provider.permission.READ_PROVIDER.  下面所列的描述说明了provider权限的范围，开始是应用于整个provider的然后变成更细颗粒度。更细颗粒度的权限优先级高于大范围的权限：  单一的read-write provider-level权限  一个权限，它控制对整个provider的读和写权限，用<provider> 元素的android:permission 属性指定。  分开的读和写provider-level权限 控制整个provider的一个读权限和一个写权限。你用<provider> 元素的android:readPermission和android:writePermission属性指定它们。它们的优先级比android:permission更高。 Path-level 权限 对你的provider中的content URI的读、写，或读/写权限。你使用<provider> 元素<path-permission> 子元素指定的指定每个URI的权限，你可以指定一个读/写权限，一个读权限，或一个写权限，或所有三者。读和写权限优先级高于读/写权限。并且，path-level权限优先级高于 provider-level权限。 临时权限 也是一个权限级别，它代表了临时获取并赋于一个应用的权限，即使这个应用不具有权限。临时权限特性减少了一个应用需要在其mainifest中声明的权限的数量。当你打开了临时权限，只有那些持续操作你的所有数据的应用们才需要对你的provider有“持久的”权限.  考虑一下你实现一个email provider和应用，当你想允许一个外部图像查看应用通过你的provider来显示图像附件时所需的权限。要想不用声明权限就给予图像查看应用所需的权限，就需设置图像的content URI的临时权限。这样设计你的email 应用：当用户想要显示一个图像，你的应用发送一个intent给图像查看应用，这个intent包含了图像的content URI 和权限。图像查看应用之后可以请求你的email provider来获取图像，即使图像查看应用对你的provider不具有普通的读权限。  要开启临时权限，既可以设置<provider>元素的android:grantUriPermissions 属性，也可以添加一个或多个 <grant-uri-permission> 子元素到你的<provider> 元素。如果你使用临时权限，你必须在从你的provider删除对一个content URI的支持时调用Context.revokeUriPermission() ，如果这个content URI关联了一个临时权限的话。  属性的值决定了你的provider具有什么操作的可操作性。如果属性被设置为true，那么系统将为你的整个provider获取临时权限，覆盖任何其它通过provider-level或path-level 获取的权限。  如果这个flag 设置为false, 那么你必须添加<grant-uri-permission> 子元素到你的<provider> 元素上。每个子元素指定了哪个content URI 或哪些URI们授予了临时权限。 要把临时权限委托给一个应用，intent必须包含FLAG_GRANT_READ_URI_PERMISSION 或FLAG_GRANT_WRITE_URI_PERMISSION 标志，或两者都有。它们可用setFlags() 方法设置。  如果android:grantUriPermissions 属性不存在，就被认为是false。 ","title":"[置顶] android Content Provider详解八-实现ContentProvider MIME 类型"},{"content":"http://stackoverflow.com/questions/10005907/eclipse-android-plugin-libncurses-so-5 真机调试时候，使用adb devices会出现不能识别出现: song@song-Lenovo:~/下载$ adb devices List of devices attached  emulator-5554   device                    ／／eclipse的虚拟机 ????????????    no permissions 同时在使用elipse调试的时候也不能选择真机，解决办法： 1、设置usb权限 $ lsusb Bus 001 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching Hub Bus 002 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching Hub Bus 003 Device 002: ID 17ef:6019 Lenovo  Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub Bus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub Bus 001 Device 010: ID 0bb4:0cac HTC (High Tech Computer Corp.)  Bus 002 Device 003: ID 0c45:62f0 Microdia  列表中， Bus 001 Device 010: ID 0bb4:0cac HTC (High Tech Computer Corp.) . 这一行为手机的usb使用端口，记录一下，id为 0bb4:0cac   $sudo vim /etc/udev/rules.d/70-android.rules  加入以下内容：  SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"0bb4\", ATTRS{idProduct}==\"0cac\",MODE=\"0666\"   运行命令，重启udev：  $sudo chmod a+rx /etc/udev/rules.d/70-android.rules  $sudo service udev restart  2、 重新启动adb server $adb kill-server 设置完成了，重新插入设备 $ adb devices List of devices attached  emulator-5554   device HT13LTD01429    device","title":"linux下adb libncurses.so.5错误"},{"content":"很多应用都需要显示图片，比如视频类应用、拍照类应用，但是在大数情况下用户都会改变窗口大小， 以获得最佳效果，在Qt中如果只设置了显示图片而没有对自适应窗口做出设置，用户拖拽边框的时候， 整个控件上就会出现大片空白部分，怎么解决这个问题呢？ QImage、QPixmap等绘图设备类都提供scaled()函数，下面是Qt文档对于scaled()函数介绍： 函数原型： QImage QImage::scaled ( int width, int height, Qt::AspectRatioMode aspectRatioMode = Qt::IgnoreAspectRatio, Qt::TransformationMode transformMode = Qt::FastTransformation ) const This is an overloaded function. Returns a copy of the image scaled to a rectangle with the given width and height according to the given aspectRatioMode and transformMode. If either the width or the height is zero or negative, this function returns a null image. 翻译： 这是一个重载函数，按照指定的宽和高，根据纵横比模式和转换模式从原有图像返回一个经过比例转换的图像，如果宽高为0，返回一个空图像 所以，获取控件的改变后的宽高，就能设定图像转换的宽高转换比例，用scaled()的返回重新进行绘图即可自适应窗口，以下是个例子: void Widget::paintEvent(QPaintEvent *){    QImage img((unsigned char*)im.data,im.cols,                   im.rows,QImage::Format_RGB888);    QPainter painter(this);    if(0==flag)        painter.drawImage(0,0,nImg);    /*        一定要加标记位判断，控件在绘制之前的size为NULL，        所以scaled()返回值也为NULL，会提示nImg是空的    */    else if(1==flag)    {        nImg=img.scaled(width(),height());        painter.drawImage(0,0,nImg);    }} Ps: 图像是按比例变化的，如果放大很多，会出现模糊等现象","title":"Qt实现图像自适应窗口大小之scaled()函数使用"},{"content":"1  概述 有时我们需要将业务数据存储在移动设备上，以确保在离线状态下也可以访问。离线存储的方式有多种，本文就为大家介绍通过JSON文件存储业务数据，然后在Android客户端实现数据的读取和绘制。 2  准备JSON文件 首先需要准备JSON文件，本例中我已经将业务数据发布在地图服务中，所以通过ArcGIS REST服务的要素查询方式获得JSON格式的数据。 下图是测试用的服务图层： 在“Beijing”这个地图服务中的“教育科研_point_wm”图层页面底部找到“Query”按钮，如下图： 点击Query按钮，进入要素查询页面，如下图： 这里可以根据需要设置查询过滤条件，本文设置了恒等条件“1=1”，即获取全部要素，输出字段设置为全部字段，返回要素几何体，此外需要设置返回结果的格式为json，如下图： 设置好查询条件和返回参数后，点击其中一个Query按钮，即可获得满足条件的JSON格式的要素集，如下图： 将全部内容复制，创建一个新的文本文件并黏贴这些内容，将文件保存为features.json格式，如下图： 至此JSON文件的业务数据就准备好了，将其传到Android手机或平板设备上以供读取。 3 Android客户端读取 由于ArcGIS Android SDK提供了现场的调用接口，客户端只需要几行代码即可加载JSON文件，并以Graphic绘制出来。关键代码如下： \t\t\tJsonFactory factory = new JsonFactory();\t\t\tURI uri = new URI(\"file:///mnt/sdcard/Basemap/Beijing/POI/features2.json\");\t\t\tFile file = new File(uri);\t\t\tJsonParser jsonParser = factory.createJsonParser(new FileInputStream(file));\t\t\t\t\t\tFeatureSet features = FeatureSet.fromJson(jsonParser); \t\t\t\t\t\tGraphic[] graphics = features.getGraphics();\t\t\tGraphicsLayer poi = new GraphicsLayer();\t\t\t\t\t\tSimpleMarkerSymbol sym = new SimpleMarkerSymbol(Color.BLUE, 8, SimpleMarkerSymbol.STYLE.CIRCLE);\t\t\t\t\t\tSimpleRenderer renderer = new SimpleRenderer(sym);\t\t\t\t\t\t\t\t\tpoi.setRenderer(renderer);\t\t\tpoi.addGraphics(graphics);\t\t\t\t\tmap.addLayer(poi); 通过以上代码，应该就可以加载JSON文件中的要素集到GraphicsLayer中了，但是实际运行中却报错如下： 分析发现，原来是编码格式问题，需要将JSON文件保存为UTF-8格式，所以将features.json另存一下即可，如下图： 另存后，再传到手机或平板电脑上，再测试，效果如下： 图上的蓝色点即是加载的JSON格式的业务数据，可以用来做后续更多的查询分析等操作。","title":"ArcGIS Android应用客户端加载JSON格式业务数据"},{"content":"在用Ubuntu 12.10 64bit系统编译android 2.3代码时，一直都编译不过去，不知到什么原因，后来发现好象是因为gcc和g++为4.7与android 2.3 code 不兼容，因此需要为g++ 和 gcc 降级，同时降为4.4.7。 g++ 和 gcc版本必须一致，否则会报错。 sudo apt-get install gcc-4.4 sudo apt-get install g++-4.4 然后执行一下命令进行版本切换， 切换gcc:    rm -rf /usr/bin/gcc   sudo ln -s /usr/bin/gcc-4.4 /usr/bin/gcc   然后使用 gcc -v 检查版本。 切换g++ 步骤一样。 然后继续编译，期间可能还发生g++ selected multilib '32' not installed的错误，需要： sudo apt-get install g++-4.4-multilib 然后继续编译","title":"在ubuntu 12.10 上编译android 2.3 经历"},{"content":"SIGSEGV (Segmentation fault) 访问了没有权限的内存地址（系统内存地址等） Access to an invalid memory address. The address exist, but your program does not have access to it. SIGBUS (Bus error) 访问了无效的内存地址 Access to an invalid memory address. The address does not exist, or the alignment is invalid. SIGABRT OC和ios系统层面上的crash信号， 比如重复释放了一个object指针等。 SIGFPE (Floating point exception) 浮点数运算异常 Invalid arithmetic operation. Can be related to integer operations, despite the name. SIGSEGV和SIGBUS都是属于硬件层面的信号。","title":"ios常见的crash信号类型"},{"content":"GLES-Render 是用来做 Box2D 的 debug draw 功能的，比较重要。 在 cocos2d-x 2.0 模板工程里面没有看到这个东西的影子， 而且我又有需要，便拿 cocos2d-iphone 2.0 的改了一个来用。 注意的一个地方是 shader 成员可以从  cocos2d shader 缓存里面拿，不用自己创建一个。 因为这里我是探索，所以就自己创建了一个玩玩儿。 代码如下： GLES-Render.h /** Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com** iPhone port by Simon Oliver - http://www.simonoliver.com - http://www.handcircus.com** This software is provided 'as-is', without any express or implied* warranty.  In no event will the authors be held liable for any damages* arising from the use of this software.* Permission is granted to anyone to use this software for any purpose,* including commercial applications, and to alter it and redistribute it* freely, subject to the following restrictions:* 1. The origin of this software must not be misrepresented; you must not* claim that you wrote the original software. If you use this software* in a product, an acknowledgment in the product documentation would be* appreciated but is not required.* 2. Altered source versions must be plainly marked as such, and must not be* misrepresented as being the original software.* 3. This notice may not be removed or altered from any source distribution.*///// File modified for cocos2d integration// http://www.cocos2d-iphone.org//#ifndef GLES_RENDER_H#define GLES_RENDER_H#import \"cocos2d.h\"#ifdef __CC_PLATFORM_IOS#import <OpenGLES/EAGL.h>#elif defined(__CC_PLATFORM_MAC)#import <OpenGL/OpenGL.h>#endif#include \"Box2D.h\"#include \"ccShaders.h\"USING_NS_CC;struct b2AABB;// This class implements debug drawing callbacks that are invoked// inside b2World::Step.class GLESDebugDraw : public b2Draw {\tfloat32 mRatio;\tCCGLProgram* mShaderProgram;\tGLint mColorLocation;\tvoid initShader( void );public:\tGLESDebugDraw();\tGLESDebugDraw( float32 ratio );\tvoid DrawPolygon(const b2Vec2* vertices, int32 vertexCount, const b2Color& color);\tvoid DrawSolidPolygon(const b2Vec2* vertices, int32 vertexCount, const b2Color& color);\tvoid DrawCircle(const b2Vec2& center, float32 radius, const b2Color& color);\tvoid DrawSolidCircle(const b2Vec2& center, float32 radius, const b2Vec2& axis, const b2Color& color);\tvoid DrawSegment(const b2Vec2& p1, const b2Vec2& p2, const b2Color& color);\tvoid DrawTransform(const b2Transform& xf);    void DrawPoint(const b2Vec2& p, float32 size, const b2Color& color);    void DrawString(int x, int y, const char* string, ...);    void DrawAABB(b2AABB* aabb, const b2Color& color);};#endif // GLES_RENDER_H GLES-Render.cpp /* * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com * * iPhone port by Simon Oliver - http://www.simonoliver.com - http://www.handcircus.com * * This software is provided 'as-is', without any express or implied * warranty.  In no event will the authors be held liable for any damages * arising from the use of this software. * Permission is granted to anyone to use this software for any purpose, * including commercial applications, and to alter it and redistribute it * freely, subject to the following restrictions: * 1. The origin of this software must not be misrepresented; you must not * claim that you wrote the original software. If you use this software * in a product, an acknowledgment in the product documentation would be * appreciated but is not required. * 2. Altered source versions must be plainly marked as such, and must not be * misrepresented as being the original software. * 3. This notice may not be removed or altered from any source distribution. *///// File modified for cocos2d integration// http://www.cocos2d-iphone.org//#import \"cocos2d.h\"#include \"GLES-Render.h\"#include <cstdio>#include <cstdarg>#include <string>using namespace std;GLESDebugDraw::GLESDebugDraw() : mRatio( 1.0f ) {\tthis->initShader();}GLESDebugDraw::GLESDebugDraw( float32 ratio ) : mRatio( ratio ) {\tthis->initShader();}void GLESDebugDraw::initShader( void ) {\tmShaderProgram = new CCGLProgram();        /**     * 0.CCString 方法存在问题~     *///    mShaderProgram->initWithVertexShaderFilename(\"Position_uColor.vsh\", \"Position_uColor.fsh\");        /**     * 1.报 shader 文件编译错误~     *///    string t_oStr0(\"#ifdef GL_ES\\nprecision lowp float;\\n#endif\\nvarying vec4 v_fragmentColor;\\nvoid main() {\\ngl_FragColor = v_fragmentColor;\\n}\");//    string t_oStr1(\"attribute vec4 a_position;\\nuniform\tmat4 u_MVPMatrix;\\nuniform\tvec4 u_color;\\nuniform float u_pointSize;\\n#ifdef GL_ES\\nvarying lowp vec4 v_fragmentColor;\\n#else\\nvarying vec4 v_fragmentColor;\\n#endif\\nvoid main()\\n{\\ngl_Position = u_MVPMatrix * a_position;\\ngl_PointSize = u_pointSize;\\nv_fragmentColor = u_color;\\n}\");//    mShaderProgram->initWithVertexShaderByteArray(t_oStr0.c_str(), t_oStr1.c_str());        /**     * 2.终于成功了~     */    mShaderProgram->initWithVertexShaderByteArray(ccPosition_uColor_vert, ccPosition_uColor_frag);        mShaderProgram->addAttribute(\"aVertex\", kCCVertexAttrib_Position);    mShaderProgram->link();    mShaderProgram->updateUniforms();\tmColorLocation = glGetUniformLocation( mShaderProgram->getProgram(), \"u_color\");}void GLESDebugDraw::DrawPolygon(const b2Vec2* old_vertices, int32 vertexCount, const b2Color& color) {\tccGLUseProgram(mShaderProgram->getProgram());\tmShaderProgram->setUniformForModelViewProjectionMatrix();\tccVertex2F vertices[vertexCount];\tfor( int i=0;i<vertexCount;i++) {\t\tb2Vec2 tmp = old_vertices[i];\t\ttmp *= mRatio;\t\tvertices[i].x = tmp.x;\t\tvertices[i].y = tmp.y;\t}\tglUniform4f( mColorLocation, color.r, color.g, color.b, 1);\tglVertexAttribPointer(kCCVertexAttrib_Position, 2, GL_FLOAT, GL_FALSE, 0, vertices);\tglDrawArrays(GL_LINE_LOOP, 0, vertexCount);\tCHECK_GL_ERROR_DEBUG();}void GLESDebugDraw::DrawSolidPolygon(const b2Vec2* old_vertices, int32 vertexCount, const b2Color& color){\tccGLUseProgram(mShaderProgram->getProgram());\tmShaderProgram->setUniformForModelViewProjectionMatrix();\tccVertex2F vertices[vertexCount];\tfor( int i=0;i<vertexCount;i++) {\t\tb2Vec2 tmp = old_vertices[i];\t\ttmp = old_vertices[i];\t\ttmp *= mRatio;\t\tvertices[i].x = tmp.x;\t\tvertices[i].y = tmp.y;\t}\tglUniform4f( mColorLocation, color.r*0.5f, color.g*0.5f, color.b*0.5f,0.5f);\tglVertexAttribPointer(kCCVertexAttrib_Position, 2, GL_FLOAT, GL_FALSE, 0, vertices);\tglDrawArrays(GL_TRIANGLE_FAN, 0, vertexCount);\tglUniform4f( mColorLocation, color.r, color.g, color.b,1);\tglDrawArrays(GL_LINE_LOOP, 0, vertexCount);\tCHECK_GL_ERROR_DEBUG();}void GLESDebugDraw::DrawCircle(const b2Vec2& center, float32 radius, const b2Color& color){\tccGLUseProgram(mShaderProgram->getProgram());\tmShaderProgram->setUniformForModelViewProjectionMatrix();\tconst float32 k_segments = 16.0f;\tint vertexCount=16;\tconst float32 k_increment = 2.0f * b2_pi / k_segments;\tfloat32 theta = 0.0f;\tGLfloat\t\t\t\tglVertices[vertexCount*2];\tfor (int32 i = 0; i < k_segments; ++i)\t{\t\tb2Vec2 v = center + radius * b2Vec2(cosf(theta), sinf(theta));\t\tglVertices[i*2]=v.x * mRatio;\t\tglVertices[i*2+1]=v.y * mRatio;\t\ttheta += k_increment;\t}\tglUniform4f( mColorLocation, color.r, color.g, color.b,1);\tglVertexAttribPointer(kCCVertexAttrib_Position, 2, GL_FLOAT, GL_FALSE, 0, glVertices);\tglDrawArrays(GL_LINE_LOOP, 0, vertexCount);\tCHECK_GL_ERROR_DEBUG();}void GLESDebugDraw::DrawSolidCircle(const b2Vec2& center, float32 radius, const b2Vec2& axis, const b2Color& color){\tccGLUseProgram(mShaderProgram->getProgram());\tmShaderProgram->setUniformForModelViewProjectionMatrix();\tconst float32 k_segments = 16.0f;\tint vertexCount=16;\tconst float32 k_increment = 2.0f * b2_pi / k_segments;\tfloat32 theta = 0.0f;\tGLfloat\t\t\t\tglVertices[vertexCount*2];\tfor (int32 i = 0; i < k_segments; ++i)\t{\t\tb2Vec2 v = center + radius * b2Vec2(cosf(theta), sinf(theta));\t\tglVertices[i*2]=v.x * mRatio;\t\tglVertices[i*2+1]=v.y * mRatio;\t\ttheta += k_increment;\t}\tglUniform4f( mColorLocation, color.r *0.5f, color.g*0.5f, color.b*0.5f,0.5f );\tglVertexAttribPointer(kCCVertexAttrib_Position, 2, GL_FLOAT, GL_FALSE, 0, glVertices);\tglDrawArrays(GL_TRIANGLE_FAN, 0, vertexCount);\tglUniform4f( mColorLocation, color.r, color.g, color.b,1);\tglDrawArrays(GL_LINE_LOOP, 0, vertexCount);\t// Draw the axis line\tDrawSegment(center,center+radius*axis,color);\tCHECK_GL_ERROR_DEBUG();}void GLESDebugDraw::DrawSegment(const b2Vec2& p1, const b2Vec2& p2, const b2Color& color){\tccGLUseProgram(mShaderProgram->getProgram());\tmShaderProgram->setUniformForModelViewProjectionMatrix();\tglUniform4f( mColorLocation, color.r, color.g, color.b,1);\tGLfloat\t\t\t\tglVertices[] = {\t\tp1.x * mRatio, p1.y * mRatio,\t\tp2.x * mRatio, p2.y * mRatio\t};\tglVertexAttribPointer(kCCVertexAttrib_Position, 2, GL_FLOAT, GL_FALSE, 0, glVertices);\tglDrawArrays(GL_LINES, 0, 2);\tCHECK_GL_ERROR_DEBUG();}void GLESDebugDraw::DrawTransform(const b2Transform& xf){\tb2Vec2 p1 = xf.p, p2;\tconst float32 k_axisScale = 0.4f;\tp2 = p1 + k_axisScale * xf.q.GetXAxis();\tDrawSegment(p1, p2, b2Color(1,0,0));\tp2 = p1 + k_axisScale * xf.q.GetYAxis();\tDrawSegment(p1,p2,b2Color(0,1,0));}void GLESDebugDraw::DrawPoint(const b2Vec2& p, float32 size, const b2Color& color){\tccGLUseProgram(mShaderProgram->getProgram());\tmShaderProgram->setUniformForModelViewProjectionMatrix();\tglUniform4f( mColorLocation, color.r, color.g, color.b,1);//\tglPointSize(size);\tGLfloat\t\t\t\tglVertices[] = {\t\tp.x * mRatio, p.y * mRatio\t};\tglVertexAttribPointer(kCCVertexAttrib_Position, 2, GL_FLOAT, GL_FALSE, 0, glVertices);\tglDrawArrays(GL_POINTS, 0, 1);//\tglPointSize(1.0f);\tCHECK_GL_ERROR_DEBUG();}void GLESDebugDraw::DrawString(int x, int y, const char *string, ...){\t//\tNSLog(@\"DrawString: unsupported: %s\", string);\t//printf(string);\t/* Unsupported as yet. Could replace with bitmap font renderer at a later date */}void GLESDebugDraw::DrawAABB(b2AABB* aabb, const b2Color& c){\tccGLUseProgram(mShaderProgram->getProgram());\tmShaderProgram->setUniformForModelViewProjectionMatrix();\tglUniform4f( mColorLocation, c.r, c.g, c.b,1);\tGLfloat\t\t\t\tglVertices[] = {\t\taabb->lowerBound.x * mRatio, aabb->lowerBound.y * mRatio,\t\taabb->upperBound.x * mRatio, aabb->lowerBound.y * mRatio,\t\taabb->upperBound.x * mRatio, aabb->upperBound.y * mRatio,\t\taabb->lowerBound.x * mRatio, aabb->upperBound.y * mRatio\t};\tglVertexAttribPointer(kCCVertexAttrib_Position, 2, GL_FLOAT, GL_FALSE, 0, glVertices);\tglDrawArrays(GL_LINE_LOOP, 0, 8);\tCHECK_GL_ERROR_DEBUG();}","title":"cocos2d-x 2.0 版本的 GLES-Render"},{"content":"在Qt4中，QProcess作为QIODevice的继承类，主要用来实现启动外部应用程序，并且进行进程间通信的。 调起外部程序，主要有两种方式: start()和startDetached()。这两种方式的区别是，start()后的进程与原有进程属于父子进程关系，当父进程退出后，被调起的进程也会结束；而startDetached()会在程序调起完成后，将这两个进程分离开来。 (1) start()方法可以这样使用: QProcess *pProcess = new QProcess(this);pProcess->start(process_path);不过这里本人有个疑问， pProcess应该是什么时候去delete的呢？如果不使用new来创建，而在栈上创建QProcess对象有什么区别(如：QProcess process)？ (2) startDetached()的方法可以这样使用(): QProcess::startDetached(process_path);QProcess类还重载了这几个方法,如 bool startDetached ( const QString & program, const QStringList & arguments, const QString & workingDirectory, qint64 * pid = 0 ) bool startDetached ( const QString & program, const QStringList & arguments ) bool startDetached ( const QString & program ) 参数workingDirectory指定了程序运行的工作目录，当有数据输出时，会根据此来获得输出的相对路径及位置。 参数arguments应该是在该程序被启动后，用作数据传递吧；没有实践过这个参数，有待验证。 而这几个方法被设计为静态方法，很想知道这样设计的好处(免于创建对象外)和原理。 (3)对于QProcess的机制，大致可以理解为：在Qt4版本之前，QProcess是利用socket的双向通道机制实现了进程间的通信；但由于QProcess实际上只是实现了单向通信功能，浪费了socket的部分资源，在Qt4改用无名管道的通信机制(使用至少两个单向通信的管道来实现进程间通信)。 对于QProcess的应用场合，和信号/槽机制有点相对：信号/槽机制用于内部对象间通信；而QProcess则用于与外部对象通信，或所谓进程间通信。","title":"【Qt开发】调起外部程序/进程"},{"content":"Android应用通常由一个或者多个组件组成,这些组件包括Activity,Service, BroardcastReceiver, ContentProvider等   Activity是Android应用中负责与用户交互的组件,为用户提供可视化的用户界面，如果应用需要多个用户界面，那么这个应用就需要多个Activity，多个Activity一起组成Activity栈，当前活动的Activity位于栈顶。Activity组件需要继承Activity基类。   Service与Activity的地位并列，也是一个单独的Android组件，两者的区别在于：Service通常后台运行，不需要与用户交互，也没有图形用户界面。Service组件拥有自己的独立生命周期，通常为其他组件提供后台服务或者监控其他组件的运行状态，Service需要继承Service基类。   BroardcastReceiver是Android应用中的一个重要组件。从代码的角度看BroardcastReceiver非常类似与事件编程中的监听器，只是其监听的对象是Android应用中的其他组件。实现BroardcastReceiver比较简单，只需要继承BroardcastReceiver基类，并重写onReceiver方法即可。当其他组件通过sendBroardcast、sendStickyBroardcast或者sendOrderedBroardcast方法发送广播消息的时候，如果该BroardcastReceiver也对该消息感兴趣，BroardcastReceiver的onReceive方法将会被触发。   ContentProvider 对于Android应用而言，他们必须相对独立，各自运行在自己的Dalvik虚拟机实例中，如果不同的应用之间需要实现实时的数据交换。Android系统为跨应用的数据交换提供了一个标准：ContentProvider。当用户实现自己的ContentProvider时，需要实现以下抽象方法： Insert：向ContentProvider插入数据 Delete：删除ContentProvider中指定的数据 Update：更新ContentProvider中指定的数据 Query：从ContentProvider中查询数据 通常与ContentProvider结合使用的是ContentResolver，一个应用使用ContentProvider暴露自己的数据，而另外一个应用使用ContentResolver来访问数据。   Intent和IntentFilter 严格来说，Intent并不是Android的组件，但是其作用非常大，它是Android中不同组件之间通信的载体。Intent可以启动应用中的另外一个Activity，也可以启动一个Service组件，还可以发送一条广播来触发系统中的BroardcastReceiver。也就是说Activity，Service，BroardcastReceiver三个组件之间的通信都是通过Intent作为载体的，只是不同组件使用Intent的机制策略稍有不同。","title":"Android应用中的组件功能简介"},{"content":"如今，伴随移动互联网应用逐步深入人们日常生活与工作，依靠高速信息传输网络，很多人即可足不出户就能享受到快捷、方便、高速的网络服务,3G网络已经开始逐渐普及开来.但是随着移动互联网上人们的多样化需求,高速,大流量的网络传输对于传输带宽提出了新的要求,也正是意识到这个问题,未来的发展也指向了4G. 2007年，由全球700多家运营商组成的贸易协会GSMA选定LTE为4G移动通讯标准。 　　LTE在全球已呈现出快速增长的态势。美国最大的移动运营商Verizon于2010年12月正式商用FDD-LTE网络，目前已覆盖美国165个城市和111个机场，覆盖人口达1.86亿，FDD-LTE用户已超过540万，占全球LTE商用用户的60%。截止今年3月底全球已有91个LTE商用网络在47个国家开始运行，至2012年底还将有超过40个网络投入运行，LTE的用户总量将高达4400万，5年内将突破10亿。与此同时,中国移动也已经完成了TD-LTE的试验网设备招标,并在多个城市开始试商用,按照中国移动的规划,到2013年TD-LTE网络基站规模将超过20万,投资总额达到1800亿元。中国移动与浙江电视台经济生活频道合作，在新闻直播中通过使用TD-LTE网络，实现4G网络电视直播,直播画面图像清晰流畅。 　　4G标准的运营需要整个生态环境的支持,通信运营商,芯片设计厂商等针对产业链上游进行布局与提供核心技术支持,是推动4G网络运营与发展的核心力量.国际芯片设计厂依靠自身的通信方面的技术积累与经验,占据着市场重要的位置. 他们与国内通信运营商支持着3G网络的运营.通讯芯片的研发与上市,需要大量的资金与技术工作量,同时还需要每代的技术堆叠与积累.国内芯片厂商在这一领域还在不断积累与成熟过程中,作为国内领先的芯片厂商新岸线早在今年上半年就发布了支持GSM/WCDMA双模基带芯片Telink7619，并相继推出了基于Telink7619的基带芯片的相关方案, 而新岸线后续基带产品开发方向直指LTE。据新岸线相关负责人介绍，新岸线的LTE方案计划同时兼容TDD/FDD模式，还会结合之前的3G方案的技术，实现真正的多模LTE基带方案。目前产品研发进展顺利。新岸线表示，目标明年正式推出4G LTE的基带方案。 　　LTE作为3G的演进,已经成为未来的新标准，新岸线结合自身计算通讯一体化的目标，基带处理器芯片和计算处理器芯片均已逐步实现市场化, 明年新岸线计划发布LTE的方案，势必为其在布局手机市场提供更为核心的优势和基础。","title":"国内芯片厂商发力4G, 新岸线2013年将推LTE方案"},{"content":"List<String>  list = new ArrayAdapter<String>;  list.add(“test1”); list.add(“test2”); ArrayAdapter adpter = new ArrayAdapter(this,R.layout.item,R.id.textId,list); Spinner.setAdapter(adapter); Spinner.serPrompt(“标题”);  //设置spinner展开后框体的title   第一个参数指上下文对象 第二个参数指定下拉框的样式 第三个参数指定TextView的id，R.id.textid 在R.layout.item中定义 第四个参数提供数据源 package com.example.sp;  import java.util.ArrayList; import java.util.List;  import android.app.Activity; import android.os.Bundle; import android.view.Menu; import android.view.View; import android.widget.ArrayAdapter; import android.widget.Button; import android.widget.Spinner;  public class MainActivity extends Activity {  \tprivate Spinner spinner; \tprivate Button bt; \tprivate  List<String> list ;     @SuppressWarnings(\"unused\") \t@Override     public void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.activity_main);         spinner = (Spinner)findViewById(R.id.spinner);         bt = (Button)findViewById(R.id.bt);         list = new ArrayList<String>();         list.add(\"text\");         list.add(\"text\");         ArrayAdapter<String> adapter = new ArrayAdapter<String>(this,R.layout.item, R.id.text,list);         spinner.setAdapter(adapter);         spinner.setPrompt(\"ceshi\");         bt.setOnClickListener(new Button.OnClickListener() { \t\t\t \t\t\tpublic void onClick(View v) { \t\t\t\t// TODO Auto-generated method stub \t\t\t\tlist.add(\"要添加的数据\"); \t\t\t} \t\t});              }     @Override     public boolean onCreateOptionsMenu(Menu menu) {         getMenuInflater().inflate(R.menu.activity_main, menu);         return true;     } } Item.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"     android:layout_width=\"match_parent\"     android:layout_height=\"match_parent\"     android:orientation=\"vertical\" >      <TextView     android:id=\"@+id/text\"     android:layout_width=\"fill_parent\"     android:layout_height=\"wrap_content\">   <\/TextView> <\/LinearLayout> Activity_main.xml <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"     xmlns:tools=\"http://schemas.android.com/tools\"     android:layout_width=\"fill_parent\"     android:orientation=\"vertical\"     android:layout_height=\"fill_parent\" >     <Spinner         android:id=\"@+id/spinner\"         android:layout_width=\"fill_parent\"         android:layout_height=\"wrap_content\" />      <Button         android:id=\"@+id/bt\"         android:layout_width=\"fill_parent\"         android:layout_height=\"wrap_content\"         android:text=\"add\" >     <\/Button> <\/LinearLayout> 为了使样式更好看，可以让设置TextView属性，改变样式","title":"Spinner--动态增加数据"},{"content":"package net.sunniwell.app;     import android.app.Activity;     import android.os.Bundle;     import android.telephony.CellLocation;     import android.telephony.PhoneStateListener;     import android.telephony.TelephonyManager;     public class TelManager extends Activity {         @Override    protected void onCreate(Bundle savedInstanceState) {       super.onCreate(savedInstanceState);       TelephonyManager tm = (TelephonyManager) this.getSystemService(TELEPHONY_SERVICE);              /*      * 电话状态：      * 1.tm.CALL_STATE_IDLE=0          无活动      * 2.tm.CALL_STATE_RINGING=1  响铃      * 3.tm.CALL_STATE_OFFHOOK=2  摘机      */      tm.getCallState();//int              /*      * 电话方位：      *       */      tm.getCellLocation();//CellLocation              /*      * 唯一的设备ID：      * GSM手机的 IMEI 和 CDMA手机的 MEID.       * Return null if device ID is not available.      */      tm.getDeviceId();//String              /*      * 设备的软件版本号：      * 例如：the IMEI/SV(software version) for GSM phones.      * Return null if the software version is not available.       */      tm.getDeviceSoftwareVersion();//String              /*      * 手机号：      * GSM手机的 MSISDN.      * Return null if it is unavailable.       */      tm.getLine1Number();//String              /*      * 附近的电话的信息:      * 类型：List<NeighboringCellInfo>       * 需要权限：android.Manifest.permission#ACCESS_COARSE_UPDATES      */      tm.getNeighboringCellInfo();//List<NeighboringCellInfo>              /*      * 获取ISO标准的国家码，即国际长途区号。      * 注意：仅当用户已在网络注册后有效。      *       在CDMA网络中结果也许不可靠。      */      tm.getNetworkCountryIso();//String              /*      * MCC+MNC(mobile country code + mobile network code)      * 注意：仅当用户已在网络注册时有效。      *    在CDMA网络中结果也许不可靠。      */      tm.getNetworkOperator();//String              /*      * 按照字母次序的current registered operator(当前已注册的用户)的名字      * 注意：仅当用户已在网络注册时有效。      *    在CDMA网络中结果也许不可靠。      */      tm.getNetworkOperatorName();//String              /*      * 当前使用的网络类型：      * 例如： NETWORK_TYPE_UNKNOWN  网络类型未知  0        NETWORK_TYPE_GPRS     GPRS网络  1        NETWORK_TYPE_EDGE     EDGE网络  2        NETWORK_TYPE_UMTS     UMTS网络  3        NETWORK_TYPE_HSDPA    HSDPA网络  8         NETWORK_TYPE_HSUPA    HSUPA网络  9        NETWORK_TYPE_HSPA     HSPA网络  10        NETWORK_TYPE_CDMA     CDMA网络,IS95A 或 IS95B.  4        NETWORK_TYPE_EVDO_0   EVDO网络, revision 0.  5        NETWORK_TYPE_EVDO_A   EVDO网络, revision A.  6        NETWORK_TYPE_1xRTT    1xRTT网络  7      */      tm.getNetworkType();//int              /*      * 手机类型：      * 例如： PHONE_TYPE_NONE  无信号        PHONE_TYPE_GSM   GSM信号        PHONE_TYPE_CDMA  CDMA信号      */      tm.getPhoneType();//int              /*      * Returns the ISO country code equivalent for the SIM provider's country code.      * 获取ISO国家码，相当于提供SIM卡的国家码。      *       */      tm.getSimCountryIso();//String              /*      * Returns the MCC+MNC (mobile country code + mobile network code) of the provider of the SIM. 5 or 6 decimal digits.      * 获取SIM卡提供的移动国家码和移动网络码.5或6位的十进制数字.      * SIM卡的状态必须是 SIM_STATE_READY(使用getSimState()判断).      */      tm.getSimOperator();//String              /*      * 服务商名称：      * 例如：中国移动、联通      * SIM卡的状态必须是 SIM_STATE_READY(使用getSimState()判断).      */      tm.getSimOperatorName();//String              /*      * SIM卡的序列号：      * 需要权限：READ_PHONE_STATE      */      tm.getSimSerialNumber();//String              /*      * SIM的状态信息：      *  SIM_STATE_UNKNOWN          未知状态 0      SIM_STATE_ABSENT           没插卡 1      SIM_STATE_PIN_REQUIRED     锁定状态，需要用户的PIN码解锁 2      SIM_STATE_PUK_REQUIRED     锁定状态，需要用户的PUK码解锁 3      SIM_STATE_NETWORK_LOCKED   锁定状态，需要网络的PIN码解锁 4      SIM_STATE_READY            就绪状态 5      */      tm.getSimState();//int              /*      * 唯一的用户ID：      * 例如：IMSI(国际移动用户识别码) for a GSM phone.      * 需要权限：READ_PHONE_STATE      */      tm.getSubscriberId();//String              /*      * 取得和语音邮件相关的标签，即为识别符      * 需要权限：READ_PHONE_STATE      */      tm.getVoiceMailAlphaTag();//String              /*      * 获取语音邮件号码：      * 需要权限：READ_PHONE_STATE      */      tm.getVoiceMailNumber();//String              /*      * ICC卡是否存在      */      tm.hasIccCard();//boolean              /*      * 是否漫游:      * (在GSM用途下)      */      tm.isNetworkRoaming();//                 }         }","title":"android系统如何获取imei号码,获取手机型号和系统版本号"},{"content":"一、Handler的定义:    Handler主要用于接收子线程发送过来的数据, 并用此数据配合主线程进行UI的更新。    当应用程序启动时，Android首先会开启一个主线程 (UI线程)，主线程主要为管理界面中的UI控件，进行事件的分发，好比如，你要点击一个 Button控件，Android就会通过此Buttond的监听器分发事件到此Button上，以此来响应你的操作。如果此时是一个需要耗时长的操作，例如：联网读取数据，或者读取本地较大的一个文件的时候，就不能把这些操作放在主线程当中了，如果被放在主线程中的话，界面会出现假死现象，如果5秒钟还没有完成的话，会收到Android系统的一个错误提示“强制关闭”。这个时候就需要把这些耗时的操作，放在一个子线程当中了，因为子线程可能会涉及到UI的更新，当新线程中有涉及到操作UI的操作时，就会对主线程产生危险，因此，Android提供了Handler作为主线程和子线程的纽带。也就是说，更新UI只能在主线程当中进行更新，在子线程中操作是危险的。    由于Handler是运行在主线程当中(UI线程中)，它与子线程主要是通过Message对象来传递数据，这个时候，Handler就承担着接收子线程传过来的(子线程用sedMessage()方法传递)Message对象(里面包含数据)，把这些消息放入主线程队列中，配合主线程进行更新UI。    注意：Handler 对象初始化后，就默认与对它初始化的进程的消息队列绑定，因此可以利用Handler所包含的消息队列，制定一些操作的顺序。   二、Handler的主要作用 1. 传递Message，用于接收子线程发送过来的数据, 并用此数据配合主线程更新UI。     在Android中，对于UI的操作通常需要放在主线程中进行操作。如果在子线程中有关于UI的操作，那么就需要把数据消息作为一个Message对象发送到消息队列中，然后，由Handler中的handlerMessge()方法处理传过来的数据信息，并操作UI。当然，Handler对象是在主线程中初始化的，它需要绑定在主线程的消息队列中。     类sendMessage(Message msg)方法实现发送消息的操作。在初始化Handler对象时重写的handleMessage()方法是用来来接收Messgae并进行相关操作的。 2. 传递Runnable对象，用于通过Handler绑定的消息队列，安排不同操作的执行顺序。     Handler对象在进行初始化的时候，会默认的自动绑定消息队列。利用类post方法，可以将Runnable对象发送到消息队列中，按照队列的机制按顺序执行不同的Runnable对象中的run方法。 三、Handler的一些特点 handler可以分发Message对象或Runnable对象到主线程中，每个Handler实例，都会被绑定到创建它的线程中(一般是位于主线程)。        Handler中分发消息的一些方法： post(Runnable) postAtTime(Runnable,long) postDelayed(Runnable long) sendEmptyMessage(int) sendMessage(Message) sendMessageAtTime(Message,long) sendMessageDelayed(Message,long) 以上post类方法允许你排列一个Runnable对象到主线程队列当中； sendMessage类方法，允许你安排一个带数据的Message对象到队列中。 注意：    默认情况下，Handler接受的是当前线程下的消息循环实例（使用Handler(Looper looper)、Handler(Looper looper, Handler.Callback callback) 可以指定线程），同时一个消息队列可以被当前线程中的多个对象进行分发、处理（在UI线程中，系统已经有一个Activity来处理了，你可以再起若干个 Handler来处理）。在实例化Handler的时候，Looper可以是任意线程的，只要有Handler的指针，任何线程也都可以 sendMessage。Handler对于Message的处理不是并发的。一个Looper 只有处理完一条Message才会读取下一条，所以消息的处理是阻塞形式的（handleMessage()方法里不应该有耗时操作，可以将耗时操作放在 其他线程执行，操作完后发送Message（通过sendMessges方法）,然后由handleMessage()更新UI）。","title":"Handler机制"},{"content":"package net.canking.turnmute;import java.util.List;import net.canking.manager.AudioM;import net.canking.turnmute.R.string;import android.hardware.Sensor;import android.hardware.SensorEvent;import android.hardware.SensorEventListener;import android.hardware.SensorManager;import android.media.AudioManager;import android.os.Bundle;import android.provider.ContactsContract.CommonDataKinds.Event;import android.app.Activity;import android.content.Context;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.Button;import android.widget.TextView;import android.support.v4.app.NavUtils;public class MainActivity extends Activity {\tprivate SensorManager mSensorManager;\tprivate Button buttonOpen, buttonClose;\tprivate TextView tView;\tprivate String modeStr;    private AudioM audioM;    private Sensor sensor;    private  final SensorEventListener mSensorEventListener = \t\tnew SensorEventListener() {\t\t\t\tpublic void onSensorChanged(SensorEvent event) {\t\t\t// TODO Auto-generated method stub\t\t\tif(event.sensor.getType() == Sensor.TYPE_ORIENTATION){\t\t\t\tfloat fPitchAngle = event.values[SensorManager.DATA_Y];\t\t\t\tif(fPitchAngle<-120){\t\t\t\t\taudioM.setMode(AudioManager.RINGER_MODE_SILENT);\t\t\t\t\ttView.setText(getString(R.string.tip)+\"静音\");\t\t\t\t}else {\t\t\t\t\taudioM.setMode(AudioManager.RINGER_MODE_NORMAL);\t\t\t\t\ttView.setText(getString(R.string.tip)+\"普通\");\t\t\t\t}\t\t\t}\t\t}\t\t\t\tpublic void onAccuracyChanged(Sensor sensor, int accuracy) {\t\t\t// TODO Auto-generated method stub\t\t\t\t\t}\t};             @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        getView();        mSensorManager = (SensorManager)getSystemService(Context.SENSOR_SERVICE);        audioM = new AudioM(MainActivity.this);        modeStr = audioM.getAudioManagetMode();        sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION);        addListener();    }        private void  getView() {\t\tbuttonOpen = (Button)findViewById(R.id.open);\t\tbuttonClose = (Button)findViewById(R.id.close);\t\ttView = (TextView)findViewById(R.id.textView1);\t\t\t}        private void addListener(){    \t/*mSensorEventListener =     \t\tnew SensorEventListener() {\t\t\t\t\t\t\t\tpublic void onSensorChanged(SensorEvent event) {\t\t\t\t\t// TODO Auto-generated method stub\t\t\t\t\tif(event.sensor.getType() == Sensor.TYPE_ORIENTATION){\t\t\t\t\t\tfloat fPitchAngle = event.values[SensorManager.DATA_Y];\t\t\t\t\t\tif(fPitchAngle<-120){\t\t\t\t\t\t\taudioM.setMode(AudioManager.RINGER_MODE_SILENT);\t\t\t\t\t\t\ttView.setText(getString(R.string.tip)+\"静音\");\t\t\t\t\t\t}else {\t\t\t\t\t\t\taudioM.setMode(AudioManager.RINGER_MODE_NORMAL);\t\t\t\t\t\t\ttView.setText(getString(R.string.tip)+\"普通\");\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t}\t\t\t\t\t\t\t\tpublic void onAccuracyChanged(Sensor sensor, int accuracy) {\t\t\t\t\t// TODO Auto-generated method stub\t\t\t\t\t\t\t\t\t}\t\t\t};*/\t\tbuttonOpen.setOnClickListener(new Button.OnClickListener() {\t\t\t\t\t\tpublic void onClick(View v) {\t\t\t\t// TODO Auto-generated method stub\t\t\t\t\t\t\t\tmSensorManager.registerListener(mSensorEventListener, sensor,\t\t\t\t\t\tSensorManager.SENSOR_DELAY_NORMAL);\t\t\t}\t\t});\t\tbuttonClose.setOnClickListener(new Button.OnClickListener() {\t\t\t\t\t\tpublic void onClick(View v) {\t\t\t\t// TODO Auto-generated method stub\t\t\t\tmSensorManager.unregisterListener(mSensorEventListener);\t\t\t}\t\t});    }\t@Override\tprotected void onResume() {\t\t// TODO Auto-generated method stub\t\tsuper.onResume();\t\ttView.setText(getString(R.string.tip)+modeStr);\t}\t@Override\tprotected void onPause() {\t\t// TODO Auto-generated method stub\t\tsuper.onPause();\t    MainActivity.this.onDestroy();\t    MainActivity.this.finish();\t}} 重力感应主要是依靠手机的加速度传感器(accelerometer)来实现        在Android的开发中一共有八种传感器但是不一定每一款真机都支持这些传感器。因为很多功能用户根本不care的所以可能开发商会把某些功能屏蔽掉。还是得根据真机的实际情况来做开发，今天我们主要来讨论加速度传感器的具体实现方式。 传感器名称如下： 加速度传感器(accelerometer) 陀螺仪传感器(gyroscope) 环境光照传感器(light) 磁力传感器(magnetic field) 方向传感器(orientation) 压力传感器(pressure) 距离传感器(proximity) 温度传感器(temperature)   1. 降噪处理，如果做过LBS软件的大家可能明白偏移修正，在GPS无法正常获取数据较间断时地图不能乱飘，这里Sensor也不例外，除了使用采样数据平均值获取外，可以间隔采样的方法来处理。细节的算法我们将在下节给出示例代码。 2. 感应器的敏感度，在Android中提供了四种延迟级别分别为 SENSOR_DELAY_FASTEST 最低延迟，一般不是特别敏感的处理不推荐使用，该种模式可能造成手机电力大量消耗，由于传递的为原始数据，算法不处理好将会影响游戏逻辑和UI的性能，所以Android开发网不推荐大家使用。 SENSOR_DELAY_GAME 游戏延迟，一般绝大多数的实时性较高的游戏都使用该级别。 int SENSOR_DELAY_NORMAL 标准延迟，对于一般的益智类或EASY级别的游戏可以使用，但过低的采样率可能对一些赛车类游戏有跳帧现象。 int SENSOR_DELAY_UI 用户界面延迟，一般对于屏幕方向自动旋转使用，相对节省电能和逻辑处理，一般游戏开发中我们不使用。 有关Android游戏开发中的Sensor感应示例今天我们将一起来讨论，对于目前最新的Android 2.2平台而言仍然没有具体的感应判断逻辑，下面我们一起定义下常用的感应动作事件。首先Android123提醒大家由于是三轴的立体空间感应所以相对于轨迹球、导航键的上下左右外，还提供了前后的感应，所以我们定义最基本的六种空间方向。 public static final int CWJ_UP = 0; public static final int CWJ_DOWN = 1; public static final int CWJ_LEFT = 2; public static final int CWJ_RIGHT = 4; public static final int CWJ_FORWARD = 8; //向前 public static final int CWJ_BACKWARD = 16; //向后 复制代码 应用实例：已通过测试（只可以自己机器没感应）  ","title":"android 重力感应手机方向"},{"content":"版权所有，转载请说明转自 http://my.csdn.net/weiqing1981127   Linux内核 1.Linux内核主要由进程调度(SCHED)、内存管理(MM)、虚拟文件系统(VFS)、网络接口(NET)和进程通信(IPC)五个子系统组成。 1.1进程调度控制系统中的多个进程对CPU的访问，使得多个进程能在CPU中”微观串行，宏观并行”地执行。 1.2内存管理的主要作用是控制多个进程安全地共享主内存区域，当CPU提供内存管理单元(MMU)时，Linux内存管理完成为每个进程进行虚拟内存到物理内存的转换。一般而言，Linux的每一个进程享有4GB的内存空间，0-3GB为用户空间，3-4GB为内核空间，这 1GB的内核空间又被划分为物理内存映射区、虚拟内存分配区、高端页面映射区和系统保留映射区。物理内存映射区最大长度为896MB，系统物理内存0-896MB就映射到这个物理内存映射区，系统物理内存大于896MB的数据属于高端内存，会被映射到高端页面映射区。由此可见，在3-4GB的内核空间中，从低地址到高地址依次为：物理内存映射区，隔离带，虚拟内存分配区，隔离带，高端内存映射区，专用页面映射区和保留区。 为了了解内存管理单元MMU，我们还需要知道TLB(块表)和TTW(转换表漫游，又叫慢表，当TLB中没有缓冲对应的地址转换关系时，需要通过多级页表的访问来获得虚拟地址和物理地址的对应关系，TTW成功后，结果写入TLB)。 1.3虚拟文件系统隐藏各种硬件的具体细节，为所有的设备提供统一的接口。 1.4网络接口提供了对各种网络标准的存取和各种网络硬件的支持。 1.5进程通信支持提供进程之间的通信，包括信号量、共享内存、管道等。   2.Linux内核五个部分的关系 第一，进程调度和内存管理之间的关系：相互依赖，程序要运行必须为之创建进程，而创建进程第一件事就是将程序和数据装入内核。第二，进程通信与内存管理的关系：进程间通信需要依靠内存管理支持共享内存机制。第三，虚拟文件系统和网络接口的关系：虚拟文件系统利用网络接口支持网络文件系统(NFS)，也利用内存管理支持RAMDISK设备。第四，虚拟文件系统与内存管理的关系：内存管理利用虚拟文件系统支持交换，当一个进程存储的内存映射被换出时，内存管理向文件系统发出请求，同时挂起当前正在运行的进程。   Linux内核的引导 1.Boot Loader 的主要任务 依赖于 CPU 体系结构的代码，比如设备初始化代码等，通常都放在 stage1 中，而且通常都用汇编语言来实现，以达到短小精悍的目的。而 stage2 则通常用C语言来实现，这样可以实现给复杂的功能，而且代码会具有更好的可读性和可移植性。 2.Boot Loader 的 stage1 通常包括以下步骤(以执行的先后顺序)： (1) 硬件设备初始化。 (2)为加载 Boot Loader 的 stage2 准备 RAM 空间。 (3)拷贝 Boot Loader 的 stage2 到 RAM 空间中。 (4)设置好堆栈（sp）。 (5)跳转到 stage2 的 C 入口点（IP）。 3.Boot Loader 的 stage2 通常包括以下步骤(以执行的先后顺序)： (1)初始化本阶段要使用到的硬件设备。 (2)检测系统内存映射(memory map)。 (3)将 kernel 映像和根文件系统映像从 flash 上读到 RAM 空间中。 (4)为内核设置启动参数。 (5)调用内核。 4.嵌入式系统在复位后就直接运行bootloader，当bootloader的控制权被释放，内核阶段就开始了，内核在进行一些初始化操作之后，就调用/init/main.c中的start_kernel函数，该函数会调用一系列初始化函数来设置中断，执行进一步的内存配置。之后，/arch/i386/kernel/process.c中kernel_thread被调用以启动第一个核心线程，该线程执行init函数，作为核心线程的init函数完成外设及其驱动程序的加载和初始化，挂接跟文件系统，搜索init程序的顺序是/sbin/init、/etc/init、/bin/init和/bin/sh。   处理器 中央处理器体系架构可以分为两类：冯诺依曼结构和哈佛结构。冯诺依曼结构把程序和操作数都放在同一个存储器中，这个存储器通过总线与处理器相连，而哈佛结构是把程序放在程序存储器内，通过程序总线与处理器相连，然后把操作数放在操作数存储器中，通过操作数总线与处理器相连。 中央处理器从指令的角度也可以分为RISC(精简指令集计算机)和CISC(复杂指令集计算机)。 中央处理器按应用领域可以分为通用处理器(GPP)、数字信号处理器(DSP)和专用处理器及ASIC。其中GPP包括MCU(微控制器，又叫单片机)和(MPU微处理器)；DSP包括定点DSP和浮点DSP。   存储器 存储器分为非易失性存储器(NVM)和RAM。其中NVM包括ROM、flash和光磁介质存储器；RAM包括SRAM、DRAM和特定应用的RAM。 NOR Flash：Intel公司，程序可以直接在NOR内运行。 NAND Flash：东芝公司，NAND以块方式进行访问，不支持芯片内执行，容量大，价格低，擦写次数和速度以及编程速度远超NOR。但是会出错，应用ECC检查错误。   其他 1.阻塞I/O意味着一直等待设备可访问后再访问，非阻塞I/O中使用poll函数意味着查询设备是否可访问，异步通知使用fasync函数意味着设备通知自身可访问，阻塞和非阻塞都属于同步。 2.中断根据中断入口跳转的方法不同，分为向量中断和非向量中断，向量中断是由硬件提供中断服务程序的入口地址，非向量中断由软件提供中断服务的入口地址(比如系统调用时的int $80中断)。    ","title":"Linux内核总述"},{"content":"在做展讯平台的时候遇到四叶草锁屏，下滑可以快速进入拍照应用，经调试发现每次打开都是新的activity，并没有还原之前锁屏之前相机的状态，通过代码跟踪和调试发现，与Intent设置启动参数有关，改动点见文中fix begin和fix end 标志：   public void onTrigger(View v,  Intent intent) {\tif(mCallback!=null)\t{\t\tLog.d(\"cara\",\"onTrigger mCallback=\"+mCallback);\t         mCallback.pokeWakelock();\t\t\tmStatus1.setVisibility(View.GONE); \t\tmStatus2.setVisibility(View.GONE); \t\tmDragHint.setVisibility(View.VISIBLE); \t\tmIntent = null;\t\tif(intent != null){\t\t\tmIntent = new Intent(intent);\t\t\t//fix begin\t\t\tmIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);\t\t\tmIntent.addCategory(Intent.CATEGORY_LAUNCHER);\t\t\t//fix end\t\t\tmContext.startActivity(mIntent);\t\t\t}        \t\tmHandler.postDelayed(new Runnable() {\t\t\tpublic void run() {\t\t\t\tif(mCallback!= null)\t\t\t\t\tmCallback.goToUnlockScreen();\t\t\t\t\t\t\t}\t\t}, 250);           \t\t}\t} onTrigger函数是每次滑动到屏幕到一个解锁位置(比如滑动到相机应用或者滑动到解锁点的时候)会触发这个函数 Intent设置这样的参数后就相当于从Launcher里面进入应用了，可以完美的还原相机应用之前的状态。    ","title":"android 用Luncher启动应用的方式"},{"content":"在2012-01-03曾写过一篇博客“Ubuntu下载Android源代码和内核”其中提到的jdk的安装方式，在文章中用到的是sudo apt-get install ***命令的安装的的JDK，但是现在发现这个方法不行，现在再介绍别的方法： 首先下载JDK安装包，在此我分享一个下载地址，我保存在微盘上的一个地址：http://vdisk.weibo.com/s/lBr8K 当初在公司下的时候很慢，如果网速快的话可以去官方地址上下载，最好用IE浏览器下载， http://www.oracle.com/technetwork/java/javase/downloads/jdk6u38-downloads-1877406.html 下载完的文件为：jdk-6u38-linux-i586.bin 安装步骤： 1.      首先创建一个目录用来存放bin文件，并且用来保存解压的文件，我创建的目录jdk 2.      改变.bin文件的权限,  chmod u+x jdk-6u38-linux-i586.bin 3.      执行命令 ./ jdk-6u38-linux-i586.bin 如果不行的话就sudo  ./ jdk-6u38-linux-i586.bin 4.      现在配置环境变量，修改文件为  /home/etc/profile 在文件的最后加上： #set javaenvironment JAVA_HOME=/home/ubuntu/jdk/jdk1.6.0_38 exportJRE_HOME=/home/ ubuntu/jdk /jdk1.6.0_38/jre exportCLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH exportPATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH 最后记着要重启机器，设置的环境变量才能起作用   Ubuntu与windows共享文件： 先进入Ubuntu系统，点击VMware Workstation菜单:VM --- Install VMware Tools ，会在Ubuntu系统桌面上创建一个光盘的图标，表示将VMware tool的安装文件载入到Ubuntu的光驱中了。 　　然后在终端中输入下面的命令： 　　切换到VMware Tools目录 　　cd /cdrom/VMware Tools 　　拷贝VMwareTools-6.0.0-55017.tar.gz文件到根目录 　　cp VMwareTools-6.0.0-55017.tar.gz / 　　注：不同的VMware版本文件名可能不同。 　　切换到根目录 　　cd / 　　执行解压命令,解压缩tar包 　　tar vzxf VMwareTools-6.0.0-55017.tar.gz 　　切换到vmware-tools-distrib目录 　　cd vmware-tools-distrib/ 　　安装VMware Tools 　　./vmware-install.pl 　　一路回车,安装完毕","title":"Ubuntu下安装JDK"},{"content":"在viewDidLoad()的方法中，第一次启动就加入手势控制的代码： //通过用户手势来处理     UISwipeGestureRecognizer *recognizer;      recognizer = [[UISwipeGestureRecognizer alloc]initWithTarget:self action:@selector(handleSwipeFrom:)];     [recognizer setDirection:(UISwipeGestureRecognizerDirectionRight)];     [self.view addGestureRecognizer:recognizer];     [recognizer release]; 在方法handleSwipFrom这个方法捕获了手势之后，处理一定的逻辑，我这里主要是弹出当前的界面 -(void)handleSwipeFrom:(UISwipeGestureRecognizer *)recognizer{              if (recognizer.direction == UISwipeGestureRecognizerDirectionRight) {         [self.navigationController popViewControllerAnimated:YES];     } } 手势功能比较健壮，可以通过上下左右四个方向来控制手势，捕获手势。","title":"ios 手势控制屏幕的功能"},{"content":"wireless建立连接后由一个程序定时检查连接状态，并计算出ChannelQuality，根据计算出的ChannelQuality决定是否重新Roaming, MlmeInit设置检查的时间，BeaconLostTime是超时时间，driver记录上一次收到beacon的jiffies值，当当前jiffies值超过上一次受到的jiffies+BeaconLostTime时，设置ChannelQuality=0,然后断开连接。 wireless中，其通过发送Null frame告诉AP其还live。 小弟接触kernel编程不久，不清楚kernel如何获取系统当前时间，只是通过jiffies值来记录bootup时间。哪个大哥知道的，告知下啊。万分感谢。","title":"wireless连接中AP断电，STA如何判断"},{"content":"package cn.com;import java.io.IOException;import android.app.Activity;import android.content.ContentResolver;import android.database.Cursor;import android.media.ExifInterface;import android.os.Bundle;import android.provider.MediaStore;public class MainActivity extends Activity {    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.main);        //测试1        //getVideosInfo();        //测试2        //getPhotosInfo();        //测试3        getAudiosInfo();    }        //获取设备上所有的视频信息\tprivate void getVideosInfo() {\t\tContentResolver contentResolver=getContentResolver();\t\tString [] videoColumns=new String[]{\t\t\t\tMediaStore.Video.Media._ID,\t\t\t\tMediaStore.Video.Media.DATA,\t\t\t\tMediaStore.Video.Media.TITLE,\t\t\t\tMediaStore.Video.Media.MIME_TYPE\t\t};//      两种方法均可\t\t//\t\tCursor cursor=//\t    this.managedQuery(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, mediaColumns, null, null, null);\t\tCursor cursor=contentResolver.query\t\t(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, videoColumns, null, null, null);\t\twhile (cursor.moveToNext()) {\t\t\tString _id=\t\t\tcursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Video.Media._ID));\t\t\tString filePath=\t\t\tcursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Video.Media.DATA));\t\t\tString title=\t\t\tcursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Video.Media.TITLE));\t\t\tString mime_type=\t\t\tcursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Video.Media.MIME_TYPE));\t\t    System.out.println(\"_id=\"+_id);\t\t    System.out.println(\"title=\"+title);\t\t    System.out.println(\"filePath=\"+filePath);\t\t    System.out.println(\"mime_type=\"+mime_type);\t\t}\t}\t\t //获取设备上所有的照片信息\t private void getPhotosInfo() {\t\t\tContentResolver contentResolver=getContentResolver();\t\t\tString [] photoColumns=new String[]{\t\t\t\t\tMediaStore.Images.Media._ID,\t\t\t\t\tMediaStore.Images.Media.DATA,\t\t\t\t\tMediaStore.Images.Media.TITLE,\t\t\t\t\tMediaStore.Images.Media.MIME_TYPE,\t\t\t\t\tMediaStore.Images.Media.SIZE,\t\t\t\t\tMediaStore.Images.Media.ORIENTATION\t\t\t};//\t      两种方法均可\t\t//\t\t\tCursor cursor=//\t\t    this.managedQuery(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, mediaColumns, null, null, null);\t\t\tCursor cursor=contentResolver.query\t\t\t(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, photoColumns, null, null, null);\t\t\twhile (cursor.moveToNext()) {\t\t\t\tString _id=\t\t\t\tcursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Images.Media._ID));\t\t\t\tString filePath=\t\t\t\tcursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA));\t\t\t\tString title=\t\t\t\tcursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Images.Media.TITLE));\t\t\t\tString mime_type=\t\t\t\tcursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Images.Media.MIME_TYPE));\t\t\t\tString size=\t\t\t\tcursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Images.Media.SIZE));\t\t\t\t//得到照片旋转角度方法一\t\t\t\tString orientation0=cursor.getString\t\t\t\t(cursor.getColumnIndexOrThrow(MediaStore.Images.Media.ORIENTATION));\t\t\t    System.out.println(\"_id=\"+_id);\t\t\t    System.out.println(\"size=\"+size);\t\t\t    System.out.println(\"title=\"+title);\t\t\t    System.out.println(\"filePath=\"+filePath);\t\t\t    System.out.println(\"mime_type=\"+mime_type);\t\t\t    System.out.println(\"第一处 orientation0=\"+orientation0);\t\t\t    try {\t\t\t\t\tExifInterface exifInterface=new ExifInterface(filePath);\t\t\t\t\tString image_length=\t\t\t\t\texifInterface.getAttribute(ExifInterface.TAG_IMAGE_LENGTH);\t\t\t\t\tString image_width=\t\t\t\t\texifInterface.getAttribute(ExifInterface.TAG_IMAGE_WIDTH);\t\t\t\t\tString orientation1=\t\t\t\t\texifInterface.getAttribute(ExifInterface.TAG_ORIENTATION);\t\t\t\t\tString dateTime=\t\t\t\t\texifInterface.getAttribute(ExifInterface.TAG_DATETIME);\t\t\t\t\tSystem.out.println(\"image_length=\"+image_length);\t\t\t\t\tSystem.out.println(\"image_width=\"+image_width);\t\t\t\t\tSystem.out.println(\"dateTime=\"+dateTime);\t\t\t\t\t//得到照片旋转角度方法二\t\t\t\t\t//应该结合ExifInterface源码分析.\t\t\t\t\t//此处有待于进一步分析和验证\t\t\t\t\tswitch (Integer.valueOf(orientation1)) {\t\t\t\t\tcase 1:\t\t\t\t\t\tSystem.out.println(\"第二处旋转角度=\"+0);\t\t\t\t\t\tbreak;\t\t\t\t\tcase 2:\t\t\t\t\t\t//matrix.invert(matrix);\t\t\t\t\t\tbreak;\t\t\t\t\tcase 3:\t\t\t\t\t\t//matrix.setRotate(180);\t\t\t\t\t\tSystem.out.println(\"第二处旋转角度=\"+180);\t\t\t\t\t\tbreak;\t\t\t\t\tcase 4:\t\t\t\t\t\t//matrix.invert(matrix);\t\t\t\t\t\t//matrix.setRotate(180);\t\t\t\t\t\tSystem.out.println(\"第二处旋转角度=\"+180);\t\t\t\t\t\tbreak;\t\t\t\t\tcase 5:\t\t\t\t\t\t//matrix.setRotate(90);\t\t\t\t\t\t//matrix.invert(matrix);\t\t\t\t\t\tSystem.out.println(\"第二处旋转角度=\"+90);\t\t\t\t\t\tbreak;\t\t\t\t\tcase 6:\t\t\t\t\t\t//matrix.setRotate(90);\t\t\t\t\t\tSystem.out.println(\"第二处旋转角度=\"+90);\t\t\t\t\t\tbreak; \t\t\t\t\tcase 7: \t\t\t\t\t\t//matrix.invert(matrix);\t\t\t\t\t\t//matrix.setRotate(90);\t\t\t\t\t\tSystem.out.println(\"第二处旋转角度=\"+90);\t\t\t\t\t\tbreak;    \t\t\t\t\tcase 8:\t\t\t\t\t\t//matrix.setRotate(270);\t\t\t\t\t\tSystem.out.println(\"第二处旋转角度=\"+270);\t\t\t\t\t\tbreak;\t\t\t\t\tdefault: \t\t\t\t\t\tbreak;\t\t\t\t\t}\t\t\t\t\tSystem.out.println(\"XXXXXXXXXXXXXXXXXXX\");\t\t\t\t} catch (IOException e) {\t\t\t\t\te.printStackTrace();\t\t\t\t}\t\t\t\t\t\t\t}\t\t \t }\t \t //获取设备上所有的音频信息\t private void getAudiosInfo() {\t\t\tContentResolver contentResolver=getContentResolver();\t\t\tString [] audioColumns=new String[]{\t\t\t\t\tMediaStore.Audio.Media._ID,\t\t\t\t\tMediaStore.Audio.Media.DATA,\t\t\t\t\tMediaStore.Audio.Media.TITLE,\t\t\t\t\tMediaStore.Audio.Media.MIME_TYPE\t\t\t};//\t      两种方法均可\t\t//\t\t\tCursor cursor=//\t\t    this.managedQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, mediaColumns, null, null, null);\t\t\tCursor cursor=contentResolver.query\t\t\t(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, audioColumns, null, null, null);\t\t\twhile (cursor.moveToNext()) {\t\t\t\tString _id=\t\t\t\tcursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID));\t\t\t\tString filePath=\t\t\t\tcursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DATA));\t\t\t\tString title=\t\t\t\tcursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE));\t\t\t\tString mime_type=\t\t\t\tcursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.MIME_TYPE));\t\t\t    System.out.println(\"_id=\"+_id);\t\t\t    System.out.println(\"title=\"+title);\t\t\t    System.out.println(\"filePath=\"+filePath);\t\t\t    System.out.println(\"mime_type=\"+mime_type);\t\t\t\t\t\t\t}\t\t \t }   }","title":"Android中MediaStore使用示例"},{"content":"要写UIAutomator的testcase，首先要用Eclipse创建一个Java Project 需要将Junit 的lib加入到工程里 还要添加android.jar和uiautomator.jar，这两个文件在android sdk中，没有升级SDK的朋友，建议升级到最新的SDK，因为uiautomator还有些不完善，在老的SDK上有些功能还不能用 此处插播招聘：国内移动互联网新锐公司，招聘测试工程师，欢迎有android设备的测试经验，熟悉monkeyrunner，shell脚本，roobtium等自动化测试工具的英才加入。 有意者请将简历发送至 autozeppelingc@gmail.com。 创建好工程后，就可以写case了，我们使用官方帮助中的例子，为了简单，采用官网上的例子，并且精简至一个home命令，方便大家把流程先跑起来 http://developer.android.com/tools/testing/testing_ui.html \t// Import the uiautomator libraries\tpackage com.uia.example.my;\timport com.android.uiautomator.core.UiObject;\timport com.android.uiautomator.core.UiObjectNotFoundException;\timport com.android.uiautomator.core.UiScrollable;\timport com.android.uiautomator.core.UiSelector;\timport com.android.uiautomator.testrunner.UiAutomatorTestCase;\tpublic class test extends UiAutomatorTestCase {   \t   public void testDemo() throws UiObjectNotFoundException {   \t      // Simulate a short press on the HOME button.\t      getUiDevice().pressHome();\t   }\t} 创建一个编译配置文件 <android-sdk>/tools/android create uitest-project -n <name> -t 1 -p <path> 说明一下各个参数的作用，如果已经将android sdk的路径配置到了系统的path中，输入命令“android create uitest-project”就可以查看到相应的帮助  -n --name    : Project name.  就是在eclipse中创建的项目的名字。 -t --target  : Target ID of the new project. [required]   这个id是本机上android targets的id，可以通过命令 “android list”来查询，得到如下图的结果，选择android-17以上版本前面所对应的id 根据我电脑的情况我的命令是这样的 D:\\work\\android-sdk\\tools>android create uitest-project -n UiAutomator -t 6 -p D:\\work\\eclipse\\workshop\\UiAutomator 创建成功的输出如下 从eclipse中可以看到有3个新增加的文件 在build.xml上点击右键，选择“Run As” -> \"Ant Build\",可以看到下面的输出，这个输出实际上是一个帮助，是对build.xml的作用进行说明的。在build.xml中配置上相应的选项可以完成相应的操作。 在build.xml的配置上，将default后面的选项改为\"build\"后，就可以build jar包了。 同样执行Run As操作，就可以build 成功了。目标文件声称在工程目录下的bin文件夹下。 剩下的操作就和官方网站上一样了。将jar push到手机中，然后执行就可以了 adb push UiAutomator.jar /data/local/tmp/ adb shell uiautomator runtestLaunchSettings.jar-c com.uia.example.my.test","title":"android uiautomator学习（一）创建工程"},{"content":"1：概述     最近两周都在做PIC在线升级的功能，最终看到升级成功的提示，难以掩盖成功的喜悦。决定把我两周中遇到的问题和大家分享一下，希望能给正在做升级功能的人一些帮助。有理解错误的地方请大家给以指正。 2：基本流程     硬件连接：PC<=====>232转485<=====>PIC<=====>EEPROM     软件逻辑：                    1) MFC发送开始升级指令--->PIC初始化接收485BUF--->校验包--->写数据至EEPROM                    2) MFC发送文件结束指令--->PIC写升级文件标志至EEPROM--->Reset                    3) PIC读取EEPROM升级标志--->跳转至固定Program地址--->擦除原有program--->读取EEPROM--->写PIC Flash--->Reset      最终实现状态：在未断电重启的情况下，成功升级PIC程序，MFC程序检测升级成功。 3：错误包处理      MFC端：当MFC应用程序读取ACK包，检查状态为错误会重传此序号包。错误重传延续5次。      PIC端  ：当读取EEPROM数据写PIC Flash，会读取写入数据比对，如若出错将重新写入。 4：部分代码 PIC写升级文件部分代码： while (g_485_rec_buff.data_len  < len){    ClrWdt();    Delay100TCYx(100);    if(error++ > 30) return;}error = 0;\tcheck = CheckSum(ptr, len - 1);if(pdata->checksum !=  check){    pdata->pack.state = WRONG;        g_485_rec_buff.data_len = 0;       h_485_usart2_write_nbyte((char *)&pdata->pack, sizeof(UPPACK));    continue;}\t\tif(pdata->pack.state == END){   binfo.valid[0] = 'U';   binfo.valid[1] = 'P';   eeprom_write_page(EEPROM_UPDATE_INFO_ADDR, (unsigned char *)&binfo,sizeof(binfo));   break;}if(pdata->pack.state == SENDING){   eeprom_write_page(EEPROM_UPDATE_DATA_ADDR + binfo.file_size, pdata->data,  pdata->pack.len);   binfo.file_size += pdata->pack.len;   pdata->pack.state = RIGHT;      g_485_rec_buff.len = 0;         h_485_usart2_write_nbyte((char *)&pdata->pack, sizeof(UPPACK));   continue;} MFC重传部分代码 while(TRUE){\tmemset((unsigned char *)&lpdata, 0, sizeof(UPDATA));\tnRBytes = fread((char *)&lpdata.data, 1, BUFFSIZE, fp);\tif(nRBytes <= 0) break;\tlpdata.pack.len = nRBytes;\tlpdata.pack.seq = seq++;    // package seq\tlpdata.pack.state = SENDING;RESEND: // if wrong will be send the same data until five times.\tlpdata.checksum = CheckSum((unsigned char *)&lpdata, sizeof(UPDATA) - 1);\tCleanSendBuf(scom.hCom);\tWriteBytes(scom.hCom, (char *)&lpdata, sizeof(UPDATA));\tSleep(300);\tmemset((char *)&uppack, 0, sizeof(UPPACK));\tif(ReadBytes(scom.hCom, (char *)&uppack, sizeof(UPPACK)) > 0)\t{\t\tif(uppack.state == WRONG)\t\t{\t\t\tif(ErrorNum++ <= 5)\t\t\t{\t\t\t\tgoto RESEND;\t\t\t}\t\t\telse\t\t\t{\t\t\t\tErrorNum = 0;\t\t\t\tSleep(400);\t\t\t\tgoto ERRORUP;\t\t\t}\t\t\t}\t\t\tErrorNum = 0;\t\t\tif(uppack.state == RIGHT)\t\t\t{\t\t\t\ti += 64;\t\t\t\tm_progress_update.SetPos(i);\t\t\t\tcontinue;\t\t\t}\t\t\tgoto RESEND;\t\t}\t\telse\t\t{\t\t\tgoto ERRORUP;\t\t}\t}} 5：部分截图 6：遇到问题错误总结      1) MPLAB 编译器中编写指针赋值时，出现485无法接收数据的现象。      2) MPLAB 编译器中如果传参为运算乘时，出现运算错误。      3) EEPROM 在写最大页128Bytes时，需要写128 * N的地址。否则出现写入数据不完全的现象。具体我也没有理解。      4) 在擦除PIC 时，注意计算其擦除块的大小，避免擦除固定升级代码。      5) 固定升级代码中一定不能调用固定升级代码区域之外的函数。以免擦除后再次调用程序跑飞的现象。      6) 在计算固定升级代码时，中间不能有间隔。MPLAB会把其他小代码量的函数烧写其中。最好从最大地址算起。","title":"PIC在线升级源码分析"},{"content":"从11月底开始投简历到昨天工作确定，我经历了一开始的茫然，不自信，到最后的自信，心里有很多话想说，可是思绪万千无从理起。首先要感谢黑马，给了我一个方向，让我找到了人生的目标。 　　刚到黑马的时候，我家宝宝才4个月大，我还处于考研失败的自我怀疑中，而滔哥老打击我说，你带着小孩，在黑马学习很辛苦，你肯定赶不上。万事开头难，一开始每天的知识量大，因为夜里要起夜，为了保证上课效率，每天晚上不到10点就睡觉，傍晚回家得给宝宝洗澡，逗他玩，学习时间也就2个多小时，很多的代码都没有办法敲一遍，我有点烦躁不安。但是凭着为了宝宝一定要努力的信念，我坚持下来了，并且慢慢喜欢上编程，喜欢上有些难题忽然迎刃而解时那种畅快的感觉，喜欢上为了实现某个功能自己去专研学习的劲头，喜欢上沉溺在代码中的感觉。 　　在黑马的4个月里，无时无刻不感受到那种和谐又温暖的感觉——老师们或可爱，或幽默，严肃又不失细心，老方博学，王哥幽默风趣，华哥机智，超哥细心，还有其他的老师。。。同学们彼此相互关爱，那一声“孩儿他妈”，那一声“慧姐”，总能温暖我的心；遇到问题彼此讨论，彼此相挺，彼此帮助，感动着我。 　　在简历这件事上面，我一直没有放太大的注意力，在智联招聘和51job上面放了简历都没有人理我。其他同学项目也差不多，但是面试机会很多。上个礼拜别人跟我说，可能是简历的名称没有改，是默认的——我的简历。试想一下，自己就是面试官，看到一份简历的名称是我的简历，那肯定是看都不会看这份简历一眼的。对于自己在简历上面写的技术一定要弄得清楚透彻，像tcp和udp，socket之间的关系之类的。每次面试前要再脑海中模拟面试场景，这样面试的时候才能对答如流，另外面试完要不断地总结经验。 　　有目标就会有动力，希望每个黑马人都能够实现自己的梦想。最后要再次谢谢黑马，给我的人生增加了一段精彩的体验，一个全新的方向。 入学发言视频地址：http://player.youku.com/player.php/sid/XNDM5NDU0OTI4/v.swf","title":"一个为宝宝而努力的女程序员经历！！！！！！"},{"content":"STM32的串口采用DMA方式接收数据测试 文博客链接:http://blog.csdn.net/jdh99,作者:jdh,转载请注明. 参考链接:http://www.amobbs.com/forum.php?mod=viewthread&tid=5511863&highlight=dma%E6%8E%A5%E6%94%B6 环境： 主机:WINXP 开发环境:MDK4.23 MCU:STM32F103CBT6 说明: 串口可以配置成用DMA的方式接收数据,不过DMA需要定长才能产生接收中断,如何接收可变长度的数据呢? 方法有以下3种: 1.将RX脚与一路时钟外部引脚相连,当串口一帧发完,即可利用此定时器产生超时中断.这个实时性较高,可以做到1个字节实时监测. 2.不改变硬件,开启一个定时器监控DMA接收,如果超时则产生中断.这个实时性不高,因为超时时间必须要大于需要接收帧的时间,精度不好控制. 3.STM32单片机有的串口可以监测总线是否处于空闲,如果空闲则产生中断.可以用它来监测DMA接收是否完毕.这种方式实时性很高. 本文采用第3种方式.在波特率576000下大数据包冲击证明可行. 源代码: //串口接收DMA缓存#define UART_RX_LEN\t\t128extern uint8_t Uart_Rx[UART_RX_LEN]; //串口接收DMA缓存uint8_t Uart_Rx[UART_RX_LEN] = {0}; //---------------------串口功能配置---------------------\t//打开串口对应的外设时钟      RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 , ENABLE); \t//串口发DMA配置  \t//启动DMA时钟    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);\t//DMA发送中断设置\tNVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel4_IRQn;\tNVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;\tNVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;\tNVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\tNVIC_Init(&NVIC_InitStructure);\t//DMA1通道4配置\tDMA_DeInit(DMA1_Channel4);\t//外设地址\tDMA_InitStructure.DMA_PeripheralBaseAddr = (u32)(&USART1->DR);\t//内存地址\tDMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)Uart_Send_Buffer;\t//dma传输方向单向\tDMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;\t//设置DMA在传输时缓冲区的长度\tDMA_InitStructure.DMA_BufferSize = 100;\t//设置DMA的外设递增模式，一个外设\tDMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;\t//设置DMA的内存递增模式\tDMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;\t//外设数据字长\tDMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;\t//内存数据字长\tDMA_InitStructure.DMA_MemoryDataSize = DMA_PeripheralDataSize_Byte;\t//设置DMA的传输模式\tDMA_InitStructure.DMA_Mode = DMA_Mode_Normal;\t//设置DMA的优先级别\tDMA_InitStructure.DMA_Priority = DMA_Priority_High;\t//设置DMA的2个memory中的变量互相访问\tDMA_InitStructure.DMA_M2M = DMA_M2M_Disable;\tDMA_Init(DMA1_Channel4,&DMA_InitStructure);\tDMA_ITConfig(DMA1_Channel4,DMA_IT_TC,ENABLE);\t\t//使能通道4\t//DMA_Cmd(DMA1_Channel4, ENABLE);\t//串口收DMA配置  \t//启动DMA时钟    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);\t//DMA1通道5配置\tDMA_DeInit(DMA1_Channel5);\t//外设地址\tDMA_InitStructure.DMA_PeripheralBaseAddr = (u32)(&USART1->DR);\t//内存地址\tDMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)Uart_Rx;\t//dma传输方向单向\tDMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;\t//设置DMA在传输时缓冲区的长度\tDMA_InitStructure.DMA_BufferSize = UART_RX_LEN;\t//设置DMA的外设递增模式，一个外设\tDMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;\t//设置DMA的内存递增模式\tDMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;\t//外设数据字长\tDMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;\t//内存数据字长\tDMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;\t//设置DMA的传输模式\tDMA_InitStructure.DMA_Mode = DMA_Mode_Normal;\t//设置DMA的优先级别\tDMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;\t//设置DMA的2个memory中的变量互相访问\tDMA_InitStructure.DMA_M2M = DMA_M2M_Disable;\tDMA_Init(DMA1_Channel5,&DMA_InitStructure);\t//使能通道5\tDMA_Cmd(DMA1_Channel5,ENABLE);\t\t      //初始化参数      //USART_InitStructure.USART_BaudRate = DEFAULT_BAUD;      USART_InitStructure.USART_WordLength = USART_WordLength_8b;      USART_InitStructure.USART_StopBits = USART_StopBits_1;      USART_InitStructure.USART_Parity = USART_Parity_No;      USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;      USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;        USART_InitStructure.USART_BaudRate = DEFAULT_BAUD; \t//初始化串口     USART_Init(USART1,&USART_InitStructure);      //TXE发送中断,TC传输完成中断,RXNE接收中断,PE奇偶错误中断,可以是多个       //USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);\t\t//中断配置\tUSART_ITConfig(USART1,USART_IT_TC,DISABLE);\tUSART_ITConfig(USART1,USART_IT_RXNE,DISABLE);\tUSART_ITConfig(USART1,USART_IT_IDLE,ENABLE);  \t//配置UART1中断  \tNVIC_PriorityGroupConfig(NVIC_PriorityGroup_3);    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;               //通道设置为串口1中断      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;       //中断占先等级0      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;              //中断响应优先级0      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;                 //打开中断      NVIC_Init(&NVIC_InitStructure);           \t//采用DMA方式发送\tUSART_DMACmd(USART1,USART_DMAReq_Tx,ENABLE);\t//采用DMA方式接收\tUSART_DMACmd(USART1,USART_DMAReq_Rx,ENABLE);    //启动串口      USART_Cmd(USART1, ENABLE); //串口1接收中断   void USART1_IRQHandler(void)                               {   \tuint32_t temp = 0;\tuint16_t i = 0;\t\tif(USART_GetITStatus(USART1, USART_IT_IDLE) != RESET)    {    \t//USART_ClearFlag(USART1,USART_IT_IDLE);    \ttemp = USART1->SR;    \ttemp = USART1->DR; //清USART_IT_IDLE标志    \tDMA_Cmd(DMA1_Channel5,DISABLE);\t\ttemp = UART_RX_LEN - DMA_GetCurrDataCounter(DMA1_Channel5);\t\tfor (i = 0;i < temp;i++)\t\t{\t\t\tData_Receive_Usart = Uart_Rx[i];\t\t  \t//启动串口状态机\t\t\tusart_state_run(); \t\t}\t\t//设置传输数据长度\t\tDMA_SetCurrDataCounter(DMA1_Channel5,UART_RX_LEN);    \t//打开DMA\t\tDMA_Cmd(DMA1_Channel5,ENABLE);    } \t\t__nop(); } 测试结果: 条件:单片机运行于72M,与PC通信速率为460800.PC每隔100ms发送一个9个字节的包:c5 5c 6 0 6F 10 5 4e f7. 测试:单片机每次收到此包,一个IO作电平跳转,然后处理返回一包. 示波器显示: 放大显示:","title":"STM32的串口采用DMA方式接收数据测试"},{"content":"#pragma mark Core Animation- (IBAction)buttonPressed1:(id)sender {    UIButton *button = (UIButton *)sender;    NSInteger tag = button.tag;        CATransition *animation = [CATransition animation];    animation.delegate = self;    animation.duration = kDuration;    animation.timingFunction = UIViewAnimationCurveEaseInOut;        switch (tag) {        case 101:            animation.type = kCATransitionFade;            break;        case 102:            animation.type = kCATransitionPush;            break;        case 103:            animation.type = kCATransitionReveal;            break;        case 104:            animation.type = kCATransitionMoveIn;            break;        case 201:            animation.type = @\"cube\";            break;        case 202:            animation.type = @\"suckEffect\";            break;        case 203:            animation.type = @\"oglFlip\";            break;        case 204:            animation.type = @\"rippleEffect\";            break;        case 205:            animation.type = @\"pageCurl\";            break;        case 206:            animation.type = @\"pageUnCurl\";            break;        case 207:            animation.type = @\"cameraIrisHollowOpen\";            break;        case 208:            animation.type = @\"cameraIrisHollowClose\";            break;        default:            break;    }        switch (self.typeID) {        case 0:            animation.subtype = kCATransitionFromLeft;            break;        case 1:            animation.subtype = kCATransitionFromBottom;            break;        case 2:            animation.subtype = kCATransitionFromRight;            break;        case 3:            animation.subtype = kCATransitionFromTop;            break;        default:            break;    }    self.typeID += 1;    if (self.typeID > 3) {        self.typeID = 0;    }        NSUInteger green = [[self.view subviews] indexOfObject:self.greenView];    NSUInteger blue = [[self.view subviews] indexOfObject:self.blueView];    [self.view exchangeSubviewAtIndex:green withSubviewAtIndex:blue];        [[self.view layer] addAnimation:animation forKey:@\"animation\"];}#pragma mark UIView动画- (IBAction)buttonPressed2:(id)sender {    UIButton *button = (UIButton *)sender;    NSInteger tag = button.tag;        CGContextRef context = UIGraphicsGetCurrentContext();    [UIView beginAnimations:nil context:context];    [UIView setAnimationCurve:UIViewAnimationCurveEaseInOut];    [UIView setAnimationDuration:kDuration];    switch (tag) {        case 105:            [UIView setAnimationTransition:UIViewAnimationTransitionCurlDown forView:self.view cache:YES];            break;        case 106:            [UIView setAnimationTransition:UIViewAnimationTransitionCurlUp forView:self.view cache:YES];            break;        case 107:            [UIView setAnimationTransition:UIViewAnimationTransitionFlipFromLeft forView:self.view cache:YES];            break;        case 108:            [UIView setAnimationTransition:UIViewAnimationTransitionFlipFromRight forView:self.view cache:YES];            break;        default:            break;    }        NSUInteger green = [[self.view subviews] indexOfObject:self.greenView];    NSUInteger blue = [[self.view subviews] indexOfObject:self.blueView];    [self.view exchangeSubviewAtIndex:green withSubviewAtIndex:blue];        [UIView setAnimationDelegate:self];    // 动画完毕后调用某个方法    //[UIView setAnimationDidStopSelector:@selector(animationFinished:)];    [UIView commitAnimations];}","title":"IOS常用动画效果"},{"content":"嵌入式Linux下Nand Flash相关操作流程 嵌入式Linux系统采用MTD子系统来进行存储的访问和管理。MTD（Memory Technology Device）是用于访问memory设备的Linux子系统。MTD的主要目的是为了使新的memory设备的驱动更加简单，为此它在硬件和上层之间提供了一个抽象的接口。MTD设备可分为四层，这四层从上到下分别是设备节点、MTD设备层、MTD原始设备层和硬件驱动层。 （1）、Flash硬件驱动层：负责驱动Flash硬件 （2）、MTD原始设备层：一部分是MTD该层的通用代码；另一部分是各个特定的Flash的数据。 重要的数据结构：struct mtd_info，其中定义了大量的关于MTD的数据和操作函数。 struct mtd_info { u_char type; uint32_t flags; uint64_t size;// Total size of the MTD /* \"Major\" erase size for the device. Na茂ve users may take this * to be the only erase size available, or may use the more detailed * information below if they desire */ uint32_t erasesize; /* Minimal writable flash unit size. In case of NOR flash it is 1 (even * though individual bits can be cleared), in case of NAND flash it is * one NAND page (or half, or one-fourths of it), in case of ECC-ed NOR * it is of ECC block size, etc. It is illegal to have writesize = 0. * Any driver registering a struct mtd_info must ensure a writesize of * 1 or larger. */ uint32_t writesize; uint32_t oobsize;   // Amount of OOB data per block (e.g. 16) uint32_t oobavail;  // Available OOB bytes per block /* * If erasesize is a power of 2 then the shift is stored in * erasesize_shift otherwise erasesize_shift is zero. Ditto writesize. */ unsigned int erasesize_shift; unsigned int writesize_shift; /* Masks based on erasesize_shift and writesize_shift */ unsigned int erasesize_mask; unsigned int writesize_mask; // Kernel-only stuff starts here. const char *name; int index; /* ecc layout structure pointer - read only ! */ struct nand_ecclayout *ecclayout; /* Data for variable erase regions. If numeraseregions is zero, * it means that the whole device has erasesize as given above. */ int numeraseregions; struct mtd_erase_region_info *eraseregions; /* * Erase is an asynchronous operation.  Device drivers are supposed * to call instr->callback() whenever the operation completes, even * if it completes with a failure. * Callers are supposed to pass a callback function and wait for it * to be called before writing to the block. */ int (*erase) (struct mtd_info *mtd, struct erase_info *instr); /* This stuff for eXecute-In-Place */ /* phys is optional and may be set to NULL */ int (*point) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, void **virt, resource_size_t *phys); /* We probably shouldn't allow XIP if the unpoint isn't a NULL */ void (*unpoint) (struct mtd_info *mtd, loff_t from, size_t len); /* Allow NOMMU mmap() to directly map the device (if not NULL) * - return the address to which the offset maps * - return -ENOSYS to indicate refusal to do the mapping */ unsigned long (*get_unmapped_area) (struct mtd_info *mtd,    unsigned long len,    unsigned long offset,    unsigned long flags); /* Backing device capabilities for this device * - provides mmap capabilities */ struct backing_dev_info *backing_dev_info; int (*read) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf); int (*write) (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf); /* In blackbox flight recorder like scenarios we want to make successful   writes in interrupt context. panic_write() is only intended to be   called when its known the kernel is about to panic and we need the   write to succeed. Since the kernel is not going to be running for much   longer, this function can break locks and delay to ensure the write   succeeds (but not sleep). */ int (*panic_write) (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf); int (*read_oob) (struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops); int (*write_oob) (struct mtd_info *mtd, loff_t to, struct mtd_oob_ops *ops); /* * Methods to access the protection register area, present in some * flash devices. The user data is one time programmable but the * factory data is read only. */ int (*get_fact_prot_info) (struct mtd_info *mtd, struct otp_info *buf, size_t len); int (*read_fact_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf); int (*get_user_prot_info) (struct mtd_info *mtd, struct otp_info *buf, size_t len); int (*read_user_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf); int (*write_user_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf); int (*lock_user_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len); /* kvec-based read/write methods.   NB: The 'count' parameter is the number of _vectors_, each of   which contains an (ofs, len) tuple. */ int (*writev) (struct mtd_info *mtd, const struct kvec *vecs, unsigned long count, loff_t to, size_t *retlen); /* Sync */ void (*sync) (struct mtd_info *mtd); /* Chip-supported device locking */ int (*lock) (struct mtd_info *mtd, loff_t ofs, uint64_t len); int (*unlock) (struct mtd_info *mtd, loff_t ofs, uint64_t len); /* Power Management functions */ int (*suspend) (struct mtd_info *mtd); void (*resume) (struct mtd_info *mtd); /* Bad block management functions */ int (*block_isbad) (struct mtd_info *mtd, loff_t ofs); int (*block_markbad) (struct mtd_info *mtd, loff_t ofs); struct notifier_block reboot_notifier;  /* default mode before reboot */ /* ECC status information */ struct mtd_ecc_stats ecc_stats; /* Subpage shift (NAND) */ int subpage_sft; void *priv; struct module *owner; struct device dev; int usecount; /* If the driver is something smart, like UBI, it may need to maintain * its own reference counting. The below functions are only for driver. * The driver may register its callbacks. These callbacks are not * supposed to be called by MTD users */ int (*get_device) (struct mtd_info *mtd); void (*put_device) (struct mtd_info *mtd); }; 而特定的Flash数据则放在/drivers/mtd/maps/子目录下，每个文件都描述了一块板子上的Flash。 （3）、MTD设备层：Linux系统可以定义出MTD的块设备（主设备号31，mtdblock.c文件，mtdblk_dev结构）和字符设备（设备号90，mtdchar.c）。 static struct mtdblk_dev{ struct mtd_info *mtd; int count; struct mutex cache_mutex; unsigned char *cache_data; unsigned long cache_offset; unsigned int cache_size; enum { STATE_EMPTY, STATE_CLEAN, STATE_DIRTY } cache_state; } *mtdblks[MAX_MTD_DEVICES]; （4）、设备节点：通过mknod在/dev子目录下建立MTD字符设备节点和MTD块设备节点，通过访问此设备节点极客访问MTD字符设备和块设备。 二、NandFlash驱动中的重要结构体 1、struct s3c2410_nand_info 表示一个nand Flash控制器相关信息。 /**  * struct s3c2410_nand_info - NAND controller state.  * @mtds: An array of MTD instances on this controoler.  * @platform: The platform data for this board.  * @device: The platform device we bound to.  * @area: The IO area resource that came from request_mem_region().  * @clk: The clock resource for this controller.  * @regs: The area mapped for the hardware registers described by @area.  * @sel_reg: Pointer to the register controlling the NAND selection.  * @sel_bit: The bit in @sel_reg to select the NAND chip.  * @mtd_count: The number of MTDs created from this controller.  * @save_sel: The contents of @sel_reg to be saved over suspend.  * @clk_rate: The clock rate from @clk.  * @cpu_type: The exact type of this controller.  */ struct s3c2410_nand_info { /* mtd info */ struct nand_hw_controlcontroller; struct s3c2410_nand_mtd*mtds; struct s3c2410_platform_nand*platform; /* device info */ struct device *device; struct resource*area; struct clk *clk; void __iomem *regs; void __iomem *sel_reg; int sel_bit; int mtd_count; unsigned long save_sel; unsigned long clk_rate; enum s3c_cpu_typecpu_type; #ifdef CONFIG_CPU_FREQ struct notifier_blockfreq_transition; #endif } 2、struct s3c2410_nand_mtd表示Nand Flash硬件设备驱动层的MTD设备结构体。 * struct s3c2410_nand_mtd - driver MTD structure  * @mtd: The MTD instance to pass to the MTD layer.  * @chip: The NAND chip information.  * @set: The platform information supplied for this set of NAND chips.  * @info: Link back to the hardware information.  * @scan_res: The result from calling nand_scan_ident(). */ struct s3c2410_nand_mtd { struct mtd_infomtd; struct nand_chipchip; struct s3c2410_nand_set*set; struct s3c2410_nand_info*info; int scan_res; }; 3、struct nand_chip定义了具体的物理Nand Flash芯片最底层的硬件接口操作函数及硬件相关信息。   struct nand_chip - NAND Private Flash Chip Data  * @IO_ADDR_R: [BOARDSPECIFIC] address to read the 8 I/O lines of the flash device  * @IO_ADDR_W: [BOARDSPECIFIC] address to write the 8 I/O lines of the flash device  * @read_byte: [REPLACEABLE] read one byte from the chip  * @read_word: [REPLACEABLE] read one word from the chip  * @write_buf: [REPLACEABLE] write data from the buffer to the chip  * @read_buf: [REPLACEABLE] read data from the chip into the buffer  * @verify_buf: [REPLACEABLE] verify buffer contents against the chip data  * @select_chip: [REPLACEABLE] select chip nr  * @block_bad: [REPLACEABLE] check, if the block is bad  * @block_markbad: [REPLACEABLE] mark the block bad  * @cmd_ctrl: [BOARDSPECIFIC] hardwarespecific funtion for controlling  * ALE/CLE/nCE. Also used to write command and address  * @dev_ready: [BOARDSPECIFIC] hardwarespecific function for accesing device ready/busy line  * If set to NULL no access to ready/busy is available and the ready/busy information  * is read from the chip status register  * @cmdfunc: [REPLACEABLE] hardwarespecific function for writing commands to the chip  * @waitfunc: [REPLACEABLE] hardwarespecific function for wait on ready  * @ecc: [BOARDSPECIFIC] ecc control ctructure  * @buffers: buffer structure for read/write  * @hwcontrol: platform-specific hardware control structure  * @ops: oob operation operands  * @erase_cmd: [INTERN] erase command write function, selectable due to AND support  * @scan_bbt: [REPLACEABLE] function to scan bad block table  * @chip_delay: [BOARDSPECIFIC] chip dependent delay for transfering data from array to read regs (tR)  * @state: [INTERN] the current state of the NAND device  * @oob_poi: poison value buffer  * @page_shift: [INTERN] number of address bits in a page (column address bits)  * @phys_erase_shift: [INTERN] number of address bits in a physical eraseblock  * @bbt_erase_shift: [INTERN] number of address bits in a bbt entry  * @chip_shift: [INTERN] number of address bits in one chip  * @options: [BOARDSPECIFIC] various chip options. They can partly be set to inform nand_scan about  * special functionality. See the defines for further explanation  * @badblockpos: [INTERN] position of the bad block marker in the oob area  * @cellinfo: [INTERN] MLC/multichip data from chip ident  * @numchips: [INTERN] number of physical chips  * @chipsize: [INTERN] the size of one chip for multichip arrays  * @pagemask: [INTERN] page number mask = number of (pages / chip) - 1  * @pagebuf: [INTERN] holds the pagenumber which is currently in data_buf  * @subpagesize: [INTERN] holds the subpagesize  * @ecclayout: [REPLACEABLE] the default ecc placement scheme  * @bbt: [INTERN] bad block table pointer  * @bbt_td: [REPLACEABLE] bad block table descriptor for flash lookup  * @bbt_md: [REPLACEABLE] bad block table mirror descriptor  * @badblock_pattern: [REPLACEABLE] bad block scan pattern used for initial bad block scan  * @controller: [REPLACEABLE] a pointer to a hardware controller structure  * which is shared among multiple independend devices  * @priv: [OPTIONAL] pointer to private chip date  * @errstat: [OPTIONAL] hardware specific function to perform additional error status checks  * (determine if errors are correctable)  * @write_page: [REPLACEABLE] High-level page write function  */ struct nand_chip { void  __iomem *IO_ADDR_R; void  __iomem *IO_ADDR_W; uint8_t (*read_byte)(struct mtd_info *mtd); u16 (*read_word)(struct mtd_info *mtd); void (*write_buf)(struct mtd_info *mtd, const uint8_t *buf, int len); void (*read_buf)(struct mtd_info *mtd, uint8_t *buf, int len); int (*verify_buf)(struct mtd_info *mtd, const uint8_t *buf, int len); void (*select_chip)(struct mtd_info *mtd, int chip); int (*block_bad)(struct mtd_info *mtd, loff_t ofs, int getchip); int (*block_markbad)(struct mtd_info *mtd, loff_t ofs); void (*cmd_ctrl)(struct mtd_info *mtd, int dat,    unsigned int ctrl); int (*dev_ready)(struct mtd_info *mtd); void (*cmdfunc)(struct mtd_info *mtd, unsigned command, int column, int page_addr); int (*waitfunc)(struct mtd_info *mtd, struct nand_chip *this); void (*erase_cmd)(struct mtd_info *mtd, int page); int (*scan_bbt)(struct mtd_info *mtd); int (*errstat)(struct mtd_info *mtd, struct nand_chip *this, int state, int status, int page); int (*write_page)(struct mtd_info *mtd, struct nand_chip *chip,      const uint8_t *buf, int page, int cached, int raw); int chip_delay; unsigned int options; int page_shift; int phys_erase_shift; int bbt_erase_shift; int chip_shift; int numchips; uint64_t chipsize; int pagemask; int pagebuf; int subpagesize; uint8_t cellinfo; int badblockpos; nand_state_t state; uint8_t *oob_poi; struct nand_hw_control  *controller; struct nand_ecclayout*ecclayout; struct nand_ecc_ctrl ecc; struct nand_buffers *buffers; struct nand_hw_control hwcontrol; struct mtd_oob_ops ops; uint8_t *bbt; struct nand_bbt_descr*bbt_td; struct nand_bbt_descr*bbt_md; struct nand_bbt_descr*badblock_pattern; void *priv; }; 4、struct s3c2410_nand_set定义了nand Flash芯片的分区信息和名字。 * struct s3c2410_nand_set - define a set of one or more nand chips  * @disable_ecc: Entirely disable ECC - Dangerous  * @flash_bbt: Openmoko u-boot can create a Bad Block Table  * Setting this flag will allow the kernel to  * look for it at boot time and also skip the NAND  * scan.  * @nr_chips: Number of chips in this set  * @nr_partitions: Number of partitions pointed to by @partitions  * @name: Name of set (optional)  * @nr_map: Map for low-layer logical to physical chip numbers (option)  * @partitions: The mtd partition list  *  * define a set of one or more nand chips registered with an unique mtd. Also  * allows to pass flag to the underlying NAND layer. 'disable_ecc' will trigger  * a warning at boot time.  */ struct s3c2410_nand_set { unsigned int disable_ecc:1; unsigned int flash_bbt:1; int nr_chips; int nr_partitions; char *name; int *nr_map; struct mtd_partition*partitions; struct nand_ecclayout*ecc_layout; };","title":"友善之臂Mini2440之嵌入式Linux下Nand Flash相关操作流程"},{"content":"Android为我们提供了一个好工具adb，全称 Android Debug Bridge。下面结合自己在项目中的经历，跟大家分享一下 adb 这个工具一些较常用到的命令。 1.查询有几个android设备连接adb server >adb devices List of devices attached 0123456789ABCDEF        device 2.安装某个apk到android设备中 >adb install -r B:\\test\\6577\\PinyinIME.apk 2509 KB/s (1284852 bytes in 0.499s)         pkg: /data/local/tmp/PinyinIME.apk Success -r 表示强制安装，当系统中原本有这个apk时加上这个选项可保证安装了新的apk。 3.从本地复制文件到设备 >adb push B:\\test\\6577\\PinyinIME.apk /data/app 3491 KB/s (1284852 bytes in 0.359s) 4.从设备复制文件到本地 >adb pull /data/app ./ pull: building file list... pull: /data/app/com.android.inputmethod.pinyin-2.apk -> ./com.android.inputmethod.pinyin-2.apk pull: /data/app/PinyinIME.apk -> ./PinyinIME.apk pull: /data/app/com.google.android.inputmethod.pinyin-1.apk -> ./com.google.android.inputmethod.pinyin-1.apk 3 files pulled. 0 files skipped. 4766 KB/s (10981224 bytes in 2.249s) 这个命令的意思是把设备中/data/app目录下的所有的apk复制到本地的当前目录下。 5.进入shell 这样，你就可以像在 linux 下面敲命令了。 >adb shell root@android:/ # logcat 6.重启adb server >adb kill-server >adb start-server * daemon not running. starting it now on port 5037 * * daemon started successfully * 这些命令真的是经常用到的，一定要记住哦～  adb还有很多的用法，可以用adb help。 >adb help Android Debug Bridge version 1.0.26  -d                            - directs command to the only connected USB device                                  returns an error if more than one USB device is present.  -e                            - directs command to the only running emulator.                                  returns an error if more than one emulator is running.  -s <serial number>            - directs command to the USB device or emulator with                                  the given serial number. Overrides ANDROID_SERIAL                                  environment variable.  -p <product name or path>     - simple product name like 'sooner', or                                  a relative/absolute path to a product                                  out directory like 'out/target/product/sooner'.                                  If -p is not specified, the ANDROID_PRODUCT_OUT                                  environment variable is used, which must                                  be an absolute path.  devices                       - list all connected devices  connect <host>[:<port>]       - connect to a device via TCP/IP                                  Port 5555 is used by default if no port number is specified.  disconnect [<host>[:<port>]]  - disconnect from a TCP/IP device.                                  Port 5555 is used by default if no port number is specified.                                  Using this ocmmand with no additional arguments                                  will disconnect from all connected TCP/IP devices. device commands:   adb push <local> <remote>    - copy file/dir to device   adb pull <remote> [<local>]  - copy file/dir from device   adb sync [ <directory> ]     - copy host->device only if changed                                  (-l means list but don't copy)                                  (see 'adb help all')   adb shell                    - run remote shell interactively   adb shell <command>          - run remote shell command   adb emu <command>            - run emulator console command   adb logcat [ <filter-spec> ] - View device log   adb forward <local> <remote> - forward socket connections                                  forward specs are one of:                                    tcp:<port>                                    localabstract:<unix domain socket name>                                    localreserved:<unix domain socket name>                                    localfilesystem:<unix domain socket name>                                    dev:<character device name>                                    jdwp:<process pid> (remote only)   adb jdwp                     - list PIDs of processes hosting a JDWP transport   adb install [-l] [-r] [-s] <file> - push this package file to the device and install it                                  ('-l' means forward-lock the app)                                  ('-r' means reinstall the app, keeping its data)                                  ('-s' means install on SD card instead of internal storage)   adb uninstall [-k] <package> - remove this app package from the device                                  ('-k' means keep the data and cache directories)   adb bugreport                - return all information from the device                                  that should be included in a bug report.   adb help                     - show this help message   adb version                  - show version num DATAOPTS:  (no option)                   - don't touch the data partition   -w                           - wipe the data partition   -d                           - flash the data partition scripting:   adb wait-for-device          - block until device is online   adb start-server             - ensure that there is a server running   adb kill-server              - kill the server if it is running   adb get-state                - prints: offline | bootloader | device   adb get-serialno             - prints: <serial-number>   adb status-window            - continuously print device status for a specified device   adb remount                  - remounts the /system partition on the device read-write   adb reboot [bootloader|recovery] - reboots the device, optionally into the bootloader or recovery program   adb reboot-bootloader        - reboots the device into the bootloader   adb root                     - restarts the adbd daemon with root permissions   adb usb                      - restarts the adbd daemon listening on USB   adb tcpip <port>             - restarts the adbd daemon listening on TCP on the specified port networking:   adb ppp <tty> [parameters]   - Run PPP over USB.  Note: you should not automatically start a PPP connection.  <tty> refers to the tty for PPP stream. Eg. dev:/dev/omap_csmi_tty1  [parameters] - Eg. defaultroute debug dump local notty usepeerdns adb sync notes: adb sync [ <directory> ]   <localdir> can be interpreted in several ways:   - If <directory> is not specified, both /system and /data partitions will be updated.   - If it is \"system\" or \"data\", only the corresponding partition     is updated. environmental variables:   ADB_TRACE                    - Print debug information. A comma separated list of the following values                                  1 or all, adb, sockets, packets, rwx, usb, sync, sysdeps, transport, jdwp   ANDROID_SERIAL               - The serial number to connect to. -s takes priority over this if given.   ANDROID_LOG_TAGS             - When used with the logcat option, only these debug tags are printed.","title":"Android adb的常用命令"},{"content":"小小原创，转载请注明出处：http://iphone.xiaoxiaostudio.net/2012/12/19/ios上的反射用法 以前一直没有注意过iPhone开发中反射的用法，java C#等也都是有反射的，用起来还是挺方便的，因为目前开发的需要，就想到了用反射来完成一下。 1.通过类名来创建对象 Class testClass=NSClassFromString(@”testClass”); id object=[[testClass alloc] init]; 2.通过反射的方式，实现该对象的指定函数 例如：我想调用object 对象的 setDelegate方法（其实是给属性赋值，与方法一样的），用下面的代码，先判断该对象是否存在这样的方法，存在的话，就去执行。 if ([object respondsToSelector:@selector(setDelegate:)]) { [object performSelector:@selector(setDelegate:) withObject:self]; }   3.如何得到类的名称 NSString * className =NSStringFromClass(testClass);","title":"iOS上的反射用法"},{"content":"          最近调研android视频录制、另一部手机实时观看，大致有以下几种思路。   1. android手机充当服务器，使用NanoHTTPD充当服务器，另一部手机或者pc通过输入http://手机的ip:8080网址观看。 这种方案可以参考 ipcamera-for-android开源项目，网址  http://code.google.com/p/ipcamera-for-android/source/checkout   可以运行的源代码可以在这下载            http://download.csdn.net/detail/xiaoliouc/4933558   缺点：android手机必须支持MP4+ARM_BN格式，有些手机不兼容，延时有点厉害   2. android手机采用juv-rtmp-client.jar包，网上有收费的包，但可以搜索破解包，通过rtmp协议发布服务到red5服务器。服务器当然是red5了，可以用red5自带的的OFLA Demo做测试。客户端代码可以参考ivideochat，下载地址              http://download.csdn.net/detail/xiaoliouc/4933594   电脑可以直接通过安装了flash player浏览器观看，手机呢，可以找一个支持rtmp协议的播放器了。   缺点：需要flash支持   3.android手机通过camera类拍摄视频。把一帧一帧的图像压缩通过socket发送到服务器，服务器可以直接观看。而要想让另一台手机也能观看，可以让服务器转发来实现。 例子网上有很多，        http://download.csdn.net/detail/xiaoliouc/4933610 缺点：通过一帧一帧的发送数据，传输过程耗费大量流量。玩玩可以，但实际项目中不可取。   4.android手机通过camera类拍摄视频，把拍摄的视频通过h264编码，可以采用软编码（使用x264库或者opencore软件库），java类通过jni调用编译后的so文件来实现。然后通过基于udp的rtp协议传输到服务器。为什么不使用tcp协议呢，因为tcp的重传机制会产生延时和抖动，而单独使用udp传输协议本身是面向无连接的，不能提供质量保证，需要在udp协议只上采用rtp或者rtcp提供流量控制和拥塞控制服务。服务器通过ffmpeg对接收的h264解码并播放。播放可以使用VLC media player。如果对c++比较熟悉，可以看看live555这个开源项目。 缺点：需要懂得的知识很多，jni啊，h264编码解码 ，rtp协议等。使用软编码，效率比较低，耗cpu耗电啊。   5.android手机通过mediaRecorder类拍摄视频，其中当然包括音频了。把拍摄的视频通过h264编码，可以采用硬编码（面向手机的硬件直接操作），只能针对3gp，mp4视频格式。方法参考  http://blog.csdn.net/zblue78/article/details/6078040 这篇博客，里面讲的很详细，提取h264的sps，pps，可以参考      http://blog.csdn.net/peijiangping1989/article/details/6934317      winHex是一款好用的16进制查看工具，下载地址           http://download.csdn.net/detail/xiaoliouc/4928773   代码网上有很多，个人理解是：mediaRecorder录制视频（3gp，MP4），可以通过mMediaRecorder.setPreviewDisplay(mSurfaceHolder.getSurface());预览视频，通过localsocket发送到本地的localserversocket的h264实时视频流。 这个过程涉及到硬编码，硬编码个人理解是，在预览过程或者提前确定视频的sps，pps，head（一般为0x00000001），不同的手机硬件不一样。把得到的这些参数写入h264，得到正确的h264视频流文件，然后把流通过rtp协议（或者其他）发送到服务器。服务器端对得到的h264用ffmepg解码，播放。   貌似项目客户需要在苹果电脑，手机上播放。这个时候HLS协议就出来了，头疼的东西，服务器采用nginx，ffmpeg解码。nginx服务器搭建过程，ffmpeg安装过程  见我前几篇文章。    然后用ffmpeg对解码后的mp4文件进行ts切片，生成带有索引的m3u8文件，然后客户端就可以通过浏览器http://ip :port/ *.m3u8访问。   过程貌似是这样的，但自己由于刚接触不到一个周，还不太理解。       6.前面讲的都是单向视频，如果是双向视频，其实就是视频会议了，可以参考sipdroid开源源代码了，网址           http://code.google.com/p/sipdroid/source/checkout   由于没有时间，就不研究这个了。        ","title":"android视频录制、另一部手机实时观看方案"},{"content":"这是我的测试中 baidu地图和Google地图 的显示情况， 显然 百度的更详细一些，google地图在电脑上的表现还是很好的，所以做手机地图测试我开始也是用google的，没想到  实现过程  超麻烦，首先是申请API key , google apikey现在的申请地址也换了，让我找了好半天，现是下面这个链接 https://developers.google.com/maps/documentation/android/v1/maps-api-signup?hl=zh-CN   打开后就是悲催的 无法显示  千辛万苦，跋山涉水，翻山越岭 （此处省略一万字）终于注册到了。。。。。。。 才开始 地图开发 ，尼玛， 下面是工程结构（左图），  需要注意的是 开发google地图应用 |需要创建 google apis 虚拟机，普通虚拟机不行，之前我可走了大弯路，由于我的SDK里只有android-10和android-14  没想到开发地图应用需要创建 google apis 虚拟机,  我就加了个maps包， 代码完全正常, （右图）  就是运行的时候提示错误，我在网上查那个错误信息，按照网上的各种 方法修改都不行， 在群里也是各种问，全部 无果，，后来查到一个 说要创建 google apis 虚拟机，然后我就在网上查找google apis 包，解压到sdk\\add-ons里，重启eclipse 就可以创建 google apis 虚拟机和工程了， 布局文件 main.xml  , 其中 apiKey 就是填写在Google上申请到的apikey [html] view plaincopy <com.google.android.maps.MapView         android:id=\"@+id/myMapView1\"         android:layout_width=\"fill_parent\"         android:layout_height=\"fill_parent\"         android:layout_x=\"0px\"         android:layout_y=\"102px\"         android:apiKey=\"0Gjfd4yOVZC0yPDlP26cBY46WfJ2MWz9urcu7JQ\"         <span style=\"color:#ffffff;\">         /><\/span>   主Activity   包括自定义图层绘制 public class GooglemapActivity extends MapActivity {\tprivate MapController mMapController01;\tprivate MapView mMapView01;\tprivate Button mButton01, mButton02, mButton03;\tprivate EditText mEditText01;\tprivate EditText mEditText02;\tprivate int intZoomLevel = 0;\t/* Map启动时的预设坐标： */\t// private double dLat=34.818881;\t// private double dLng=113.68235;\tprivate double dLat;\tprivate double dLng;\t@Override\tprotected void onCreate(Bundle icicle) {\t\tsuper.onCreate(icicle);\t\tsetContentView(R.layout.main);\t\t/* 定位到自己当前位置 */\t\tmyself();\t\t/* 建立MapView对象 */\t\tmMapView01 = (MapView) findViewById(R.id.myMapView1);\t\t// 取得MapController对象(控制MapView)\t\tmMapController01 = mMapView01.getController();\t\tmMapView01.setEnabled(true);\t\tmMapView01.setClickable(true);\t\t/* 设定MapView的显示选项（卫星、街道） */\t\t// mMapView01.setSatellite(false); //卫星图\t\tmMapView01.setStreetView(true);// 街道图\t\t/* 预设放己的层级 */\t\tintZoomLevel = 15;\t\tmMapController01.setZoom(intZoomLevel);\t\tmMapView01.setBuiltInZoomControls(true);// 显示缩放控件\t\tmMapView01.displayZoomControls(true);//\t\tmMapView01.setTraffic(true);// 交通图\t\t/* 设定Map的中点为预设经纬度 */\t\trefreshMapView();\t\tDrawable marker = getResources().getDrawable(R.drawable.da_marker_red);\t\tmarker.setBounds(0, 0, marker.getIntrinsicWidth(),\t\t\t\tmarker.getIntrinsicHeight());// Intrinsic固有\t\tmMapView01.getOverlays().add(new MyItemizedOverlay(marker, this));\t\tmEditText01 = (EditText) findViewById(R.id.myEdit1);\t\tmEditText02 = (EditText) findViewById(R.id.myEdit2);\t\t/* 送出查询的Button */\t\tmButton01 = (Button) findViewById(R.id.myButton1);\t\tmButton01.setOnClickListener(new Button.OnClickListener() {\t\t\t@Override\t\t\tpublic void onClick(View v) {\t\t\t\t/* 经纬度空白检查 */\t\t\t\tif (mEditText01.getText().toString().equals(\"\")\t\t\t\t\t\t|| mEditText02.getText().toString().equals(\"\")) {\t\t\t\t\tshowDialog(\"经度或纬度填写不正确!\");\t\t\t\t} else {\t\t\t\t\t/* 取得输入的经纬度 */\t\t\t\t\tdLng = Double.parseDouble(mEditText01.getText().toString());\t\t\t\t\tdLat = Double.parseDouble(mEditText02.getText().toString());\t\t\t\t\t/* 依输入的经纬度重整Map */\t\t\t\t\trefreshMapView();\t\t\t\t}\t\t\t}\t\t});\t\t/* 放大Map的Button */\t\tmButton02 = (Button) findViewById(R.id.myButton2);\t\tmButton02.setOnClickListener(new Button.OnClickListener() {\t\t\t@Override\t\t\tpublic void onClick(View v) {\t\t\t\tintZoomLevel++;\t\t\t\tif (intZoomLevel > mMapView01.getMaxZoomLevel()) {\t\t\t\t\tintZoomLevel = mMapView01.getMaxZoomLevel();\t\t\t\t}\t\t\t\tmMapController01.setZoom(intZoomLevel);\t\t\t}\t\t});\t\t/* 缩小Map的Button */\t\tmButton03 = (Button) findViewById(R.id.myButton3);\t\tmButton03.setOnClickListener(new Button.OnClickListener() {\t\t\t@Override\t\t\tpublic void onClick(View v) {\t\t\t\tintZoomLevel--;\t\t\t\tif (intZoomLevel < 1) {\t\t\t\t\tintZoomLevel = 1;\t\t\t\t}\t\t\t\tmMapController01.setZoom(intZoomLevel);\t\t\t}\t\t});\t}\t// 同一类型覆盖物的绘制\tclass MyItemizedOverlay extends ItemizedOverlay<OverlayItem> {\t\t// 属性\t\tprivate Drawable marker;\t\tprivate Context mContext;\t\tprivate List<OverlayItem> geoList = new ArrayList<OverlayItem>();\t\t// 经纬度的属性\t\tprivate double mLat1 = 34.818881;\t\tprivate double mLon1 = 113.68235;\t\tprivate double mLat2 = 39.607723;\t\tprivate double mLon2 = 116.397741;\t\tprivate double mLat3 = 39.917723;\t\tprivate double mLon3 = 116.6552;\t\t// 构造方法\t\tpublic MyItemizedOverlay(Drawable marker, Context context) {\t\t\tsuper(boundCenterBottom(marker));\t\t\tthis.marker = marker;\t\t\tthis.mContext = context;\t\t\t// 构造地理坐标\t\t\tGeoPoint p1 = new GeoPoint((int) (mLat1 * 1E6), (int) (mLon1 * 1E6));\t\t\tGeoPoint p2 = new GeoPoint((int) (mLat2 * 1E6), (int) (mLon2 * 1E6));\t\t\tGeoPoint p3 = new GeoPoint((int) (mLat3 * 1E6), (int) (mLon3 * 1E6));\t\t\tgeoList.add(new OverlayItem(p1, \"P1\", \"这是我的当前位置\"));\t\t\tgeoList.add(new OverlayItem(p2, \"P2\", \"point2\"));\t\t\tgeoList.add(new OverlayItem(p3, \"P3\", \"point3\"));\t\t\tpopulate();// 执行填充方法\t\t}\t\t// 绘制方法\t\tpublic void draw(Canvas canvas, MapView mapView, boolean shadow) {\t\t\t// 投影，用于屏幕像素点坐标系统与地球经纬度点坐标系统的转换\t\t\tProjection projection = mapView.getProjection();\t\t\tfor (int index = size() - 1; index >= 0; index--) {\t\t\t\tOverlayItem overlayItem = this.getItem(index);\t\t\t\tString title = overlayItem.getTitle();\t\t\t\tPoint point = projection.toPixels(overlayItem.getPoint(), null);\t\t\t\tPaint painttext = new Paint();\t\t\t\tpainttext.setColor(Color.BLACK);\t\t\t\tpainttext.setTextSize(15);\t\t\t\tcanvas.drawText(title, point.x - 30, point.y - 25, painttext);\t\t\t}\t\t\tsuper.draw(canvas, mapView, shadow);\t\t\tboundCenterBottom(marker);\t\t}\t\t// 添加成员方法\t\t@Override\t\tprotected OverlayItem createItem(int i) {\t\t\treturn geoList.get(i);\t\t}\t\t@Override\t\tpublic int size() {\t\t\treturn geoList.size();\t\t}\t\t// 添加点击事件\t\tpublic boolean onTap(int i) {\t\t\tsetFocus(geoList.get(i));\t\t\tToast.makeText(this.mContext, geoList.get(i).getSnippet(),\t\t\t\t\tToast.LENGTH_LONG).show();// snippet片段\t\t\treturn true;\t\t}\t\tpublic boolean onTap(GeoPoint point, MapView mapView) {\t\t\treturn super.onTap(point, mapView);\t\t}\t}\t/* 重整Map的method */\tpublic void refreshMapView() {\t\tGeoPoint p = new GeoPoint((int) (dLat * 1E6), (int) (dLng * 1E6));\t\tmMapView01.displayZoomControls(true);\t\t/* 将Map的中点移出GeoPoint */\t\tmMapController01.animateTo(p);\t\tmMapController01.setZoom(intZoomLevel);\t}\t@Override\tprotected boolean isRouteDisplayed() {\t\treturn false;\t}\tpublic void myself() {\t\tLocationManager lm = (LocationManager) getSystemService(LOCATION_SERVICE);\t\tLocation l = lm.getLastKnownLocation(LocationManager.GPS_PROVIDER);\t\tif (l == null) {\t\t\tToast.makeText(GooglemapActivity.this, \"无法获取自己的位置\",\t\t\t\t\tToast.LENGTH_SHORT).show();\t\t\t/* 默认 的位置 */\t\t\tdLat = 34.818881;\t\t\tdLng = 113.68235;\t\t} else {\t\t\t// GeoPoint gp = new GeoPoint((int)(l.getLatitude() * 1E6),\t\t\t// (int)(l.getLongitude() * 1E6));\t\t\t// mMapController01.animateTo(gp);\t\t\t// // mMapController01.setZoom(17);\t\t\tdLat = (int) (l.getLatitude() * 1E6);\t\t\tdLng = (int) (l.getLongitude() * 1E6);\t\t}\t}\t/* 显示Dialog的method */\tprivate void showDialog(String mess) {\t\tnew AlertDialog.Builder(GooglemapActivity.this).setTitle(\"Message\")\t\t\t\t.setMessage(mess)\t\t\t\t.setNegativeButton(\"确定\", new DialogInterface.OnClickListener() {\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\t\t\t\t\t}\t\t\t\t}).show();\t}} 百度地图API  for android 首页 http://developer.baidu.com/map/sdk-android.htm 点击左侧导航 的  获取密钥 -->  填写信息 --> 然后就申请成功了， 很轻松吧 中文好有爱啊，说明文档啥的 下下来一看就懂了，而且还有demo，代码的实现过程跟google差不多","title":"google 地图和baidu地图 在android上的实现过程详解和对比 包含 自定义图层的绘制"},{"content":"我们都知道[tableView reloadData];可以将整个tableview的数据刷新，但有些时候我们可能只更改了某一行或多行的数据，不想全部重新来过，怎么办呢？ 这就要用到下面这个方法了。 - (void)reloadRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation NS_AVAILABLE_IOS(3_0); 示例代码如下： NSIndexPath  *indexPath_1=[NSIndexPath indexPathForRow:1 inSection:0]; NSArray      *indexArray=[NSArray  arrayWithObject:indexPath_1]; [regTableView  reloadRowsAtIndexPaths:indexArray withRowAnimation:UITableViewRowAnimationAutomatic]; 详细请点击本人博客","title":"UITableView刷新单行数据的方法"},{"content":"Git学习笔记（4）--分支 gitGit  几乎所有版本控制系统都以某种形式支持分支。分支允许你从开发主线上脱离下来，再不影响主线的情况下完成你的工作或者实现你的idea。与很多版本控制系统比起来，Git的分支操作非常迅速。这使得Git从分布式版本控制系统中脱颖而出。 这里再次推荐童鞋先看看这篇文章，以对Git的工作组成和分支概念有直观的了解 《Git分支管理是一门艺术》 分支的概念 了解分支前，我们需要了解提交commit这个概念，每个提交可以简单的理解成为一个快照。多次提交可以构成一个线性结构，1->2->3->...，类似单链表，一般的你可以把这条直线看作你的主分支--稳定版。 而分支相当于指向某个commit的分支，一般的，系统会自动使用master作为分支的默认名字，他指向最后一次提交。当你在master分支上的时候，每次你提交的时候，他都会随着你的commit前移，永远指向最新的。 当你创建新的分支test的时候，就像当与在此线性结构上开出一条新的走向，从单链表变成树，当你再次提交时，这个新的分支指针test会随着提交前移，就像之前的master一样。你可以切换回master，或者在test上再次创建分支，随着你不断创建分支，这个树的结构会变得非常复杂。甚至到难以解读的程度，因此，在正式工作时，一定要谨慎创建分支，每个分支的作用都要记清楚并在合适的时间与主分支合并。 你可以使用这个命令查看分支 git branch                 查看分支 git branch -r              查看远程分支 git branch -a              查看所有分支 git branch --no-merge      查看所有未合并分支 git branch --merge         查看所有已经合并的分支 分支的创建，删除和切换 你可以用如下命令创建分支 git branch <newbranch> 切换到新的分支 git checkout <newbranch> 或者直接使用这个命令创建并切换到新分支 git checkout -b <newbranch> 你可意识用如下命令删除分支 git branch -d <newbranch> 但是未合并的分支不能使用这个命令来删除 如果你坚持删除未合并的分支，可以用这个命令 git branch -D <newbranch> 分支的合并 分支的合并可以将你的开发成果加入到产品中，合并的成功与否至关重要。因此Git对这部分非常重视。你可以使用这个命令将目标分支合并到当前分支（！！注意，是合并\"到\"你现在所在的分支） git merge <destbranch> 举个例子，首先确认自己在master分支上，创建文件test，输入内容\"2\"，提交，我建立并切换到分支test，向文件末尾输入内容\"567\"，提交，切换回分支master，在文件末尾输入内容234.提交。此时合并，命令如下 #git checkout master(如果你不在master上) #echo \"2\">test #git commit -a -m \"init\" #git checkout -b test #echo \"567\">>test #git commit -a -m \"bemergedbranch\" #git checkout master #echo \"234\">>test #git commit -a -m \"mergebranch\" #git merge test Auto-merging test CONFLICT (content): Merge conflict in test Automatic merge failed; fix conflicts and then commit the result. #git status # On branch master # Unmerged paths: #   (use \"git add/rm <file>...\" as appropriate to mark resolution) # # both modified:      test # no changes added to commit (use \"git add\" and/or \"git commit -a\") 查看test内容 #cat test 2 <<<<<<< HEAD 234 ======= 567 >>>>>>> test 可以看到以下三个分隔标志 <<<<<<< HEAD ======= >>>>>>> test 这个内容简单明了，我就不多说了，合并时只需删除这些，并留下想要的内容即可。 比如，我觉得主分支上的内容比较合适，因此我删除 <<<<<<< HEAD ======= >>>>>>> test 567 只留下 234 运行git merge # On branch master # Unmerged paths: #   (use \"git add/rm <file>...\" as appropriate to mark resolution) # # both modified:      test # no changes added to commit (use \"git add\" and/or \"git commit -a\") 使用add将其提交 #git add test 一切ok了。从这里我们可以看到分支合并还是基于变化的，如果你先修改test，然后回到分支master，不修改master直接合并，那么可以看到分支会被直接合并掉。就算你把2改成3，4，5...这个很容易理解，就不多说了。 mergetool 重磅推出mergetool，一个神奇的工具。mergetool是一个可视化的工具。 输入命令 #git mergetool 最开始，他会让你选择使用什么工具，你可以选择适合自己的工具。 merge tool candidates: meld opendiff kdiff3 tkdiff xxdiff tortoisemerge gvimdiff diffuse ecmerge p4merge araxis emerge vimdiff Merging the files: test Normal merge conflict for 'test':   {local}: modified   {remote}: modified Hit return to start merge resolution tool (meld): test seems unchanged. 我这里用的是默认的meld，meld的界面如下 修改过程一样，但是关系更加分明。 衍合 衍合的原理是回到两个分支的共同祖先，提取你所在分支每次提交产生的差异，然后将这些差异保存成临时文件（差异补丁文件，很好理解吧），然后从当前分支转换到你需要衍合入的分支，依序使用每个差异补丁文件。 频繁的衍合会极大的方便你的工作，但是请不要将它衍合进你的稳定版本。 关于衍合的妙用我体会的还不是很深。请有经验的童鞋指正。","title":"Git学习笔记（4）--分支"},{"content":"CCMenu这是一个抽象的东西，容纳菜单项CCMenuItem的容器 CCMenuItem继承图： Button::ButtonTest(void) {  //设置字体大小  CCMenuItemFont::setFontSize( 30 );  //根据名字设置字体     CCMenuItemFont::setFontName(\"Courier New\");  //设置能点击     setTouchEnabled(true);     // Font Item      //参数说明：第一个图片名字，第二参数截图menuitemsprite.png的一个对象(x,y,w,h),说明此处的x,y为图片的坐标喔~     CCSprite* spriteNormal = CCSprite::create(\"menuitemsprite.png\", CCRectMake(0,23*2,115,23));     CCSprite* spriteSelected = CCSprite::create(\"menuitemsprite.png\", CCRectMake(0,23*1,115,23));     CCSprite* spriteDisabled = CCSprite::create(\"menuitemsprite.png\", CCRectMake(0,23*0,115,23));  //创建一个CCMenuItemSprite，参数：添加三种状态CCSprite,添加item1的节点，注册返回监听     CCMenuItemSprite* item1 = CCMenuItemSprite::create(spriteNormal, spriteSelected, spriteDisabled, this, menu_selector(MenuTestLayer::menuCallback) );         // 创建一个CCMenuItemImage,参数:同上     CCMenuItem* item2 = CCMenuItemImage::create(\"SendScoreButton.png\", \"SendScoreButtonPressed.png\", this, menu_selector(MenuTestLayer::menuCallback2) );     // 创建一个CCLabelAtlas标签(Atlas一般是指图片集合)，参数：内容(图片资源中存在，如果不存在，不显示)，图片，宽，高     CCLabelAtlas* labelAtlas = CCLabelAtlas::create(\"0123456789\", \"fonts/labelatlas.png\", 16, 24, '.');  //创建一个CCMenuItemLebel标签     CCMenuItemLabel* item3 = CCMenuItemLabel::create(labelAtlas, this, menu_selector(MenuTestLayer::menuCallbackDisabled) );     item3->setDisabledColor( ccc3(32,32,64) );//设置不能点击的颜色(一般采用灰色)     item3->setColor( ccc3(200,200,255) );//设置item3标签颜色         // 创建一个CCMenuItemFont     CCMenuItemFont *item4 = CCMenuItemFont::create(\"I toggle enable items\", this, menu_selector(MenuTestLayer::menuCallbackEnable) );     item4->setFontSizeObj(20);     item4->setFontName(\"Marker Felt\");         // 创建一个CCLabelBMFont标签，参数:内容，字体配置fnt文件     CCLabelBMFont* label = CCLabelBMFont::create(\"configuration\", \"fonts/bitmapFontTest3.fnt\");     CCMenuItemLabel* item5 = CCMenuItemLabel::create(label, this, menu_selector(MenuTestLayer::menuCallbackConfig));     item5->setScale( 0.8f );     // 创建一个CCMenuItemFont     CCMenuItemFont::setFontName(\"Marker Felt\");     CCMenuItemFont *item6 = CCMenuItemFont::create(\"Priority Test\", this, menu_selector(MenuTestLayer::menuCallbackPriorityTest));     // 创建一个CCMenuItemFont     CCMenuItemFont* item7 = CCMenuItemFont::create(\"Quit\", this, menu_selector(MenuTestLayer::onQuit));     //为CCMenuItemFon添加一个颜色循环变化动画....item7也是父类CCNode的子类，自然也可以添加动画啦     CCActionInterval* color_action = CCTintBy::create(0.5f, 0, -255, -255);     CCActionInterval* color_back = color_action->reverse();     CCFiniteTimeAction* seq = CCSequence::create(color_action, color_back, NULL);     item7->runAction(CCRepeatForever::create((CCActionInterval*)seq));  //创建CCMenu菜单，其他可认为是菜单项     CCMenu* menu = CCMenu::create( item1, item2, item3, item4, item5, item6, item7, NULL);     menu->alignItemsVertically();//可以理解为设置成垂直排列  //menu->alignItemsHorizontally();//水平排列         // elastic effect     CCSize s = CCDirector::sharedDirector()->getWinSize();         int i=0;     CCNode* child;     CCArray * pArray = menu->getChildren();     CCObject* pObject = NULL;  //将pArray里面的对象转成CCObject对象,原因获得坐标等信息     CCARRAY_FOREACH(pArray, pObject)     {         if(pObject == NULL)             break;         child = (CCNode*)pObject;         CCPoint dstPoint = child->getPosition();         int offset = (int) (s.width/2 + 50);         if( i % 2 == 0)             offset = -offset;                 child->setPosition( CCPointMake( dstPoint.x + offset, dstPoint.y) );         child->runAction( CCEaseElasticOut::create( CCMoveBy::create(2, CCPointMake(dstPoint.x - offset,0)), 0.35f) );         i++;     }     m_disabledItem = item3; item3->retain();     m_disabledItem->setEnabled( false );     addChild(menu);     menu->setPosition(ccp(s.width/2, s.height/2)); }","title":"cocos2d-x Button控件总结"},{"content":"如何实现在一个ScrollView里添加多个ListView，并且让ListView伸张到最长。 用最外层ScrollView做滚动条。ListView本身不滚动。 全世界最简单的办法： 复写ListView里面的onMeasure方法，设置让其不滚动！   public void onMeasure(int widthMeasureSpec, int heightMeasureSpec)    {            int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE >> 2,                            MeasureSpec.AT_MOST);            super.onMeasure(widthMeasureSpec, expandSpec);   }  ","title":"如何实现在一个ScrollView里添加多个ListView，并且让ListView伸张到最长。"},{"content":"在AndroidManifest.xml中，<meta-data>元素可以作为子元素，被包含在<activity>、<application> 、<service>和<receiver>元素中，但 不同的父元素，在应用时读取的方法也不同。 1 ：在Activity的应用。     xml代码段：    <activity...>        <meta-data android:name=\"myMsg\" android:value=\"hello my activity\"><\/meta-data>     <\/activity>         java代码段：    ActivityInfo info=this.getPackageManager()                           .getActivityInfo(getComponentName(),                           PackageManager.GET_META_DATA);     String msg=info.metaData.getString(\"myMsg\");     System.out.println(\"myMsg:\"+msg); 2：在application的应用。    xml代码段：   <application...>        <meta-data android:value=\"hello my application\" android:name=\"myMsg\"><\/meta-data>    <\/application>       java代码段：     ApplicationInfo appInfo = this.getPackageManager()                                   .getApplicationInfo(getPackageName(),                           PackageManager.GET_META_DATA);     String msg=appInfo.metaData.getString(\"myMsg\");     System.out.println(\"myMsg:\"+msg); 3：在service的应用。    xml代码段：    <service android:name=\"MetaDataService\">       <meta-data android:value=\"hello my service\" android:name=\"myMsg\"><\/meta-data>    <\/service>    java代码段：    ComponentName cn=new ComponentName(this, MetaDataService.class);    ServiceInfo info=this.getPackageManager()                         .getServiceInfo(cn, PackageManager.GET_META_DATA);     String msg=info.metaData.getString(\"myMsg\");     System.out.println(\"myMsg:\"+msg); 4: 在receiver的应用。    xml代码段:     <receiver android:name=\"MetaDataReceiver\">             <meta-data android:value=\"hello my receiver\" android:name=\"myMsg\"><\/meta-data>             <intent-filter>                 <action android:name=\"android.intent.action.PHONE_STATE\"><\/action>             <\/intent-filter>     <\/receiver>    java代码段：     ComponentName cn=new ComponentName(context, MetaDataReceiver.class);     ActivityInfo info=context.getPackageManager()                              .getReceiverInfo(cn, PackageManager.GET_META_DATA);     String msg=info.metaData.getString(\"myMsg\");     System.out.println(\"myMsg:\"+msg);    以上例子在android2.1运行通过","title":"Android 读取<meta-data>元素的数据"},{"content":"一直对 cocos2d 的 opengl 混合机制不太明晰，昨日纠查 bug 的时候连带着注意了一下， CCNode 中包含了一个 m_glServerState 的成员，这个东西是与 混合开启与否相关联的， 混合默认是开启的。 CCLayerColor、CCSprite 等类型里面包含了一个 m_blendFunc 成员，这个东西是与采用怎么样的混合方式相关联的。 在 CCProtocols.h 的 CCBlendProtocol 的 @brief 注释里面可以看到， 默认是采用 {GL_ONE, GL_ONE_MINUS_SRC_ALPHA} 或  {GL_SRC_ALPHA，GL_ONE_MINUS_SRC_ALPHA} 的混合方式，选择哪种与 premultiplied alpha 相关。 当一个场景被绘制的时候，会根据子节点的 z 值来决定绘制的先后顺序， 在具体绘制某个可视子节点的时候，会根据该节点的 m_blendFunc 成员来决定用什么样的方式混合。 cocos2d 只是对 opengles 简化使用的一种封装！这里存在一个问题： 在 CCRenderTexture 上面绘制东西的时候，绘制几何图元 或 拿 sprite 对象执行 visit 动作的时候， 如果不调用  glBlendFunc 来指定混合方式的话，就会沿用绘制上一个 sprite 的混合方式。 显然这就让此次操作的结果带有不确定性，因为谁也没办法预料之前绘制的最后一个 sprite 采用的是何种混合方式。 （这里说的有点儿夸张了，实际上很多数情况下都不会对 sprite 的 blendFunc 做设置） 最稳妥的方式就是：在 CCRenderTexture 上面绘制的东西的时候即时设置一下混合方式，消除不确定性 代码：ccGLBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA); 需求多变，但是记住默认的混合参数是没有害处的，默认的为 {GL_ONE, GL_ONE_MINUS_SRC_ALPHA}。 另外一个问题就是，该采用何种的 shader？ 毫无疑问，我在刚接触 shader 的时候也是碰了一鼻子灰， 经过一连串开发的磨砺，我才逐渐得以一窥全貌 （不敢托大，这里的全貌指的是有了一个大体的正确认识，gles1都还未能摸透就被迫迁移到2，这令我亚历山大） cocos2d 缓存了一些常用的 shader，分别是用于一些特别的绘制情形。 打个比方来说，现在有一个需求，要绘制 50 个相同颜色的点， 要达到最高的性能，可以用 kCCShader_Position_uColor 这个枚举值所代表的 shader 来画， 这个 uColor 的 u 表示 uniform，具有 “统一” 的意思， 也就是说，不管花多少个点，都只能采用同一种颜色。 但如果我要绘制五十个不同颜色的点呢？ 这确实是个问题，很显然已经超出上面那个缓存的 shader 对象所掌管的能力范围了。 不过这依然不是一个难题，用 kCCShader_PositionColor 从缓存里面拿相应的 shader 就能满足需求了~ 具体方式是传入一个长度为 50 的颜色数组，再传入一个长度为 50 的位置数组，然后绘制。 挺能的啊，再出个难题！那五光十色的材质是怎么贴出来的呢？ 答案也是  shader，而且是具备贴材质能力的 shader， 具体是那种我就不指明了，自己去摸索吧~ （提示：请于之前提及过的两个枚举值的定义处寻找答案） 又扩展了一些知识，当然这些知识是与主体有所关联的， 因为在 CCRenderTexture 上面绘制东西的时候也有关于 shader 方面的东西要注意， 与混合方式差不多的意思，不过这里的是 shader 是否启用 vertexArrayAttribute 没做仔细测试，不清楚 cocos2d  缓存的 kCCShader_Position_uColor 是否默认就启用了 Position 的 vertexArrayAttribute 同上，为了消除不确定因素，这里最好也是使用一下下面的代码： ccGLEnableVertexAttribs(kCCVertexAttribFlag_Position); 上一些代码来看一看吧（一个专门用来往 RenderTexture 上面画东西的单例类）： ItemRender.h ////  ItemRender.h//  DreamStack////  Created by Bruce Yang on 12-12-26.//  Copyright (c) 2012年 __MyCompanyName__. All rights reserved.//#ifndef DreamStack_ItemRender_h#define DreamStack_ItemRender_h#include \"cocos2d.h\"#include \"Box2D.h\"USING_NS_CC;class ItemRender {public:    void drawSolidPolygon(const b2Vec2* vertices, int32 vertexCount);        void drawSolidCircle(const b2Vec2& center, float32 radius);        static ItemRender* sharedInstance();    private:    // 采用 cocos2d 缓存的 shader 对象~    void setupCachedShader();        // 采用由自己亲手创建的 shader 对象~    void setupMyShader();        ItemRender();    ~ItemRender();        static ItemRender* m_pItemRender;\tCCGLProgram* m_pGLProgram;\tGLint m_iColorLocation;};#endif ItemRender.cpp ////  ItemRender.cpp//  DreamStack////  Created by Bruce Yang on 12-12-26.//  Copyright (c) 2012年 __MyCompanyName__. All rights reserved.//#include \"ItemRender.h\"/** * p~ */void ItemRender::drawSolidPolygon(const b2Vec2* vertices, int32 vertexCount) {        m_pGLProgram->use();\tm_pGLProgram->setUniformForModelViewProjectionMatrix();        ccGLEnableVertexAttribs(kCCVertexAttribFlag_Position);    ccGLBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);        glUniform4f( m_iColorLocation, 1.f, 1.f, 1.f, 1.f);    glVertexAttribPointer(kCCVertexAttrib_Position, 2, GL_FLOAT, GL_FALSE, 0, vertices);\tglDrawArrays(GL_TRIANGLE_FAN, 0, vertexCount);    \tCHECK_GL_ERROR_DEBUG();}void ItemRender::drawSolidCircle(const b2Vec2& center, float32 radius) {        m_pGLProgram->use();\tm_pGLProgram->setUniformForModelViewProjectionMatrix();        ccGLEnableVertexAttribs(kCCVertexAttribFlag_Position);    ccGLBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);    \tconst float32 t_fSegsCount = 32.f;\tint t_iVertsCount = 32;\tconst float32 t_fIncrement = 2.f * b2_pi / t_fSegsCount;\tfloat32 theta = 0.f;    \tGLfloat glVertices[t_iVertsCount * 2];\tfor (int32 i = 0; i < t_fSegsCount; ++ i) {\t\tb2Vec2 v = center + radius * b2Vec2(cosf(theta), sinf(theta));\t\tglVertices[i * 2] = v.x;\t\tglVertices[i * 2 + 1] = v.y;\t\ttheta += t_fIncrement;\t}    \tglUniform4f( m_iColorLocation, 1.f, 1.f, 1.f, 1.f);\tglVertexAttribPointer(kCCVertexAttrib_Position, 2, GL_FLOAT, GL_FALSE, 0, glVertices);\tglDrawArrays(GL_TRIANGLE_FAN, 0, t_iVertsCount);    \tCHECK_GL_ERROR_DEBUG();}#pragma markItemRender* ItemRender::sharedInstance() {    if (!m_pItemRender) {        m_pItemRender = new ItemRender();    }    return m_pItemRender;}void ItemRender::setupCachedShader() {    m_pGLProgram = CCShaderCache::sharedShaderCache()->programForKey(kCCShader_Position_uColor);    m_iColorLocation = glGetUniformLocation(m_pGLProgram->getProgram(), \"u_color\");}void ItemRender::setupMyShader() {    m_pGLProgram = NULL;    m_iColorLocation = (GLint)0;}ItemRender::ItemRender() {    this->setupCachedShader();}ItemRender::~ItemRender() {    }ItemRender* ItemRender::m_pItemRender = 0; 还有就是，带 ccGL- 前缀的方法都是 cocos2d 封装的一层带缓存作用的方法。 其内部机制也非常简单，就是判断一下当前要改变到的值和老值是否相同，不同的话才去修改该值。 后续还会对 cocos2d-x 2.x，opengles 2.0 做更深入细致的探索，敬请关注~","title":"在使用 CCRenderTexture、shader 绘制几何图元时需要注意的一些细节问题"},{"content":"        PackageManager.getPackageSizeInfo(String packageName, IPackageStatsObserver observer)不可用，改为PackageManager.getPackageSizeInfo(String packageName, int userHandle, IPackageStatsObserver observer), 至于增加的参数userHandle的解释是：The user whose size information should be retrieved。下面是PackageManager内部的用法：     public void getPackageSizeInfo(String packageName, IPackageStatsObserver observer) {        getPackageSizeInfo(packageName, UserHandle.myUserId(), observer);    }         因此，把UserHandle.myUserId()的实作部分整合进来就可用了：     private void getPacakgeStats(String pkgName) {        if (pkgName != null) {            try {                Method getPackageSizeInfo = mPm.getClass().getDeclaredMethod(\"getPackageSizeInfo\", String.class,                        int.class, IPackageStatsObserver.class);                /**                 * after invoking, PkgSizeObserver.onGetStatsCompleted() will be called as callback function. <br>                 * About the third parameter ‘Process.myUid() / 100000’，please check:                 * <android_source>/frameworks/base/core/java/android/content/pm/PackageManager.java:                 * getPackageSizeInfo(packageName, UserHandle.myUserId(), observer);                 */                getPackageSizeInfo.invoke(mPm, pkgName, Process.myUid() / 100000, new PkgSizeObserver());            } catch (Exception e) {                Log.e(TAG, e.toString());            }        }    }","title":"android4.2上获取应用程序大小的变更点"},{"content":"dumpsys简单介绍：该命令用户打印出当前系统信息，默认打印出所有service信息，可以在命令后面加入activity参数，只打印出activity相关的信息。 可跟参数有以下这些： SurfaceFlinger, accessibility, account, activity, alarm, appwidget, audio, backup, battery, batteryinfo, bluetooth, bluetooth_a2dp, clipboard, connectivity, content, cpuinfo, device_policy, devicestoragemonitor, diskstats, dropbox, entropy, hardware, hdmi, input_method, iphonesubinfo, isms, location, media.audio_flinger, media.audio_policy, media.camera, media.player, meminfo, mount, netstat, network_management, notification, package, permission, phone, power, search, sensor, simphonebook, statusbar, telephony.registry, throttle, uimode, usagestats, vibrator, wallpaper, wifi, window 例如：>adb shell dumpsys package>package.txt package>package.txt 是使用管道将信息打印的package.txt中，再使用文本编辑器打开帮助我们更好的搜索和分析。 打开package.txt，部分内容如下所示： Libraries:   android.test.runner -> /system/framework/android.test.runner.jar   com.jayway.android.robotium -> /system/framework/robotium.jar   com.mediatek.location.provider -> /system/framework/com.mediatek.location.provider.jar   com.google.widevine.software.drm -> /system/framework/com.google.widevine.software.drm.jar   javax.obex -> /system/framework/javax.obex.jar   com.android.future.usb.accessory -> /system/framework/com.android.future.usb.accessory.jar   com.android.location.provider -> /system/framework/com.android.location.provider.jar Features:   android.hardware.wifi   android.hardware.location.network   android.hardware.telephony   android.hardware.location   android.software.sip   android.hardware.touchscreen.multitouch.jazzhand   android.hardware.touchscreen.multitouch   android.hardware.screen.landscape   android.hardware.screen.portrait   android.hardware.faketouch   android.hardware.camera   android.hardware.wifi.direct   android.hardware.usb.accessory   android.hardware.touchscreen.multitouch.distinct   android.hardware.bluetooth   android.software.sip.voip   android.hardware.sensor.light   android.hardware.microphone   android.hardware.location.gps   android.hardware.telephony.gsm   android.hardware.camera.front   android.software.live_wallpaper   android.hardware.touchscreen   android.hardware.sensor.accelerometer","title":"adb shell dumpsys 命令——打印当前系统信息"},{"content":"因为涉及到一些QC代码, 所以不粘贴代码了, 仅记录思路. [第一个内存dump分析] From Android system log    WARN [  11903.510399] (598:616) BroadcastQueue  Timeout of broadcast BroadcastRecord{41d635a0 android.intent.action.SCREEN_ON} - receiver=android.app.LoadedApk$ReceiverDispatcher$InnerReceiver@41695c58, started 10007ms ago PROBABLE CAUSE OF PROBLEM: Timeout Receiver: android.app.LoadedApk$ReceiverDispatcher$InnerReceiver .... Generating Dalvik backtraces. This might take some time .... Receiver: might be pid 615 ***** Dalvik stack for pid 615 ***** #0  android.media.AudioSystem.setParameters (Native Method) #1  android.media.AudioService$AudioServiceBroadcastReceiver.onReceive (AudioService.java:3779) #2  android.app.LoadedApk$ReceiverDispatcher$Args.run (LoadedApk.java:765) #3  android.os.Handler.handleCallback (Handler.java:615) #4  android.os.Handler.dispatchMessage (Handler.java:94) #5  android.os.Looper.loop (Looper.java:147) #6  com.android.server.ServerThread.run (SystemServer.java:219) -- Break frame -- 可以看出是SystemServer.Handler.handleCallback派送消息到处理节点上不能及时处理完. 这样SoftwareWatchdog发出到该消息队列的MONITOR消息就不能得到处理, SWWD就killSystem了. Examining the user stack of the thread, find In system_server.ServerThread main messagequeue thread, AudioService$AudioServiceBroadcastReceiver.onReceive() calls AudioSystem.setParameters(...) to handle SCREEN_ON/SCREEN_OFF.             } else if (action.equals(Intent.ACTION_SCREEN_ON)) {                 AudioSystem.setParameters(\"screen_state=on\");             } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {                 AudioSystem.setParameters(\"screen_state=off\");             } 这么个消息派送到这儿来合理吗? 需要确认一下. 总消息泵!! Examining the user stack, find ServerThread is in binder communication--talkWithDriver--ioctl. Examining the kernel stack, find the thread is in binder_thread_read to wait for transaction reply. Examining the binder transaction stack, the target binder_thread is 173, that is mediaserver as a binder worker thread. Threads info of mediaserver. PID: 173    TASK: ee6cc700  CPU: 0   COMMAND: \"mediaserver\"   PID: 524    TASK: ed94ea00  CPU: 0   COMMAND: \"AudioCommand\"   PID: 525    TASK: ed94dc00  CPU: 0   COMMAND: \"ApmCommand\"   PID: 526    TASK: ed94fb80  CPU: 0   COMMAND: \"mediaserver\"   PID: 527    TASK: ed94e300  CPU: 0   COMMAND: \"FastMixer\"   PID: 638    TASK: edad5880  CPU: 0   COMMAND: \"AudioOut_2\"   PID: 640    TASK: edad4e00  CPU: 0   COMMAND: \"Binder_1\"   PID: 1026   TASK: d39f8a80  CPU: 0   COMMAND: \"Binder_2\"   PID: 2980   TASK: e78b7800  CPU: 0   COMMAND: \"Binder_3\"   PID: 3098   TASK: e8b64e00  CPU: 0   COMMAND: \"Binder_4\"   PID: 7491   TASK: d259e680  CPU: 0   COMMAND: \"Binder_5\" mediaserver is handling \"screen_state=off\" in AudioFlinger::setParameters(...) and is waiting on the lockMutex::Autolock _l(mLock); call stack of thread 173. #0  __futex_syscall3 () at bionic/libc/arch-arm/bionic/futex_arm.S:59 #1  0x4021e1d0 in _normal_lock (shared=0, mutex=0x410707b0) at bionic/libc/bionic/pthread.c:1067 #2  pthread_mutex_lock_impl (mutex=0x410707b0) at bionic/libc/bionic/pthread.c:1189 #3  0x401e8816 in android::Mutex::lock (this=<optimized out>) at frameworks/native/include/utils/Mutex.h:112 #4  0x401f78cc in Autolock (mutex=..., this=<synthetic pointer>) at frameworks/native/include/utils/Mutex.h:65 #5  android::AudioFlinger::setParameters (this=0x410707a0, ioHandle=0, keyValuePairs=...) at frameworks/av/services/audioflinger/AudioFlinger.cpp:1118 #6  0x40361858 in android::BnAudioFlinger::onTransact (this=0x410707a0, code=<optimized out>, data=..., reply=0xbed92b94, flags=16) at frameworks/av/media/libmedia/IAudioFlinger.cpp:899 #7  0x402f4392 in android::BBinder::transact (this=0x410707a4, code=19, data=..., reply=0xbed92b94, flags=16) at frameworks/native/libs/binder/Binder.cpp:108 #8  0x402f6f16 in android::IPCThreadState::executeCommand (this=0x41070468, cmd=<optimized out>) at frameworks/native/libs/binder/IPCThreadState.cpp:1034 #9  0x402f7340 in android::IPCThreadState::joinThreadPool (this=0x41070468, isMain=<optimized out>) at frameworks/native/libs/binder/IPCThreadState.cpp:473 #10 0x400ebc3e in main (argc=<optimized out>, argv=<optimized out>) at frameworks/av/media/mediaserver/main_mediaserver.cpp:67 Naitive的代码中哪个线程占有pthread_mutex是没有好办法找的, 只能浏览代码. 上面线程在在哪个类的方法中等待锁, 就在进程组内所有线程的用户态调用栈中检查哪个线程也执行在该类的方法中. 如果线程太多, 可以先把在等待同一个互斥量的线程使用futex哈希表排除掉. 如上面线程173在AudioFlinger方法中等, 那么就找执行在AudioFlinger方法中的线程, 可以找到是1026占有互斥量. The AudioFlinger::mLock(at 0x410707b0) is held by thread 1026 \"Binder_2\", which is in AudioFlinger::createTrack(...). Thread 3098 and thread 2980 are also waiting on the same lock. call stack of thread 1026. #0  __futex_syscall3 () at bionic/libc/arch-arm/bionic/futex_arm.S:59 #1  0x4021e1d0 in _normal_lock (shared=0, mutex=0x40e4c02c) at bionic/libc/bionic/pthread.c:1067 #2  pthread_mutex_lock_impl (mutex=0x40e4c02c) at bionic/libc/bionic/pthread.c:1189 #3  0x401e8816 in android::Mutex::lock (this=<optimized out>) at frameworks/native/include/utils/Mutex.h:112 #4  0x401f160e in Autolock (mutex=..., this=<synthetic pointer>) at frameworks/native/include/utils/Mutex.h:65 #5  android::AudioFlinger::PlaybackThread::createTrack_l (this=0x40e4c008, client=..., streamType=AUDIO_STREAM_SYSTEM, sampleRate=48000, format=AUDIO_FORMAT_PCM_16_BIT, channelMask=1, frameCount=4096,     sharedBuffer=..., sessionId=206, flags=2, tid=13284, status=0x424a2c00) at frameworks/av/services/audioflinger/AudioFlinger.cpp:2122 #6  0x401f5a54 in android::AudioFlinger::createTrack (this=0x410707a0, pid=<optimized out>, streamType=AUDIO_STREAM_SYSTEM, sampleRate=48000, format=AUDIO_FORMAT_PCM_16_BIT, channelMask=1, frameCount=4096,     flags=2, sharedBuffer=..., output=2, tid=13284, sessionId=0x424a2ca4, status=0x424a2ca8) at frameworks/av/services/audioflinger/AudioFlinger.cpp:524 #7  0x403614da in android::BnAudioFlinger::onTransact (this=0x410707a0, code=<optimized out>, data=..., reply=0x424a2e04, flags=16) at frameworks/av/media/libmedia/IAudioFlinger.cpp:764 #8  0x402f4392 in android::BBinder::transact (this=0x410707a4, code=1, data=..., reply=0x424a2e04, flags=16) at frameworks/native/libs/binder/Binder.cpp:108 #9  0x402f6f16 in android::IPCThreadState::executeCommand (this=0x41208618, cmd=<optimized out>) at frameworks/native/libs/binder/IPCThreadState.cpp:1034 #10 0x402f7340 in android::IPCThreadState::joinThreadPool (this=0x41208618, isMain=<optimized out>) at frameworks/native/libs/binder/IPCThreadState.cpp:473 #11 0x402faf58 in android::PoolThread::threadLoop (this=0x4107f088) at frameworks/native/libs/binder/ProcessState.cpp:67 #12 0x40314e38 in android::Thread::_threadLoop (user=0x4107f088) at frameworks/native/libs/utils/Threads.cpp:793 #13 0x4031499e in thread_data_t::trampoline (t=<optimized out>) at frameworks/native/libs/utils/Threads.cpp:132 #14 0x4021ee74 in __thread_entry (func=0x40314905 <thread_data_t::trampoline(thread_data_t const*)>, arg=0x41207a40, tls=0x424a2f00) at bionic/libc/bionic/pthread.c:217 #15 0x4021e5cc in pthread_create (thread_out=0x4107ee88, attr=0xbed92aa8, start_routine=0x40314905 <thread_data_t::trampoline(thread_data_t const*)>, arg=0x41207a40) at bionic/libc/bionic/pthread.c:356 #16 0x00000000 in ?? () Thread 1026 is waiting for ThreadBase::mLock(at 0x40e4c02c)held by thread 638 which is in thread body AudioFlinger::PlaybackThread::threadLoop(...) call stack of thread 638, \"AudioOut_2\" #0  close () at bionic/libc/arch-arm/syscalls/close.S:10 #1  0x40068d30 in pcm_close (pcm=0x41208860) at hardware/qcom/audio/libalsa-intf/alsa_pcm.c:756 #2  0x40e25a68 in android_audio_legacy::ALSADevice::standby (this=0x41072008, handle=0x4107c0d8) at hardware/qcom/audio/alsa_sound/ALSADevice.cpp:1107 #3  0x40e1c8b4 in android_audio_legacy::AudioStreamOutALSA::standby (this=0x4107c610) at hardware/qcom/audio/alsa_sound/AudioStreamOutALSA.cpp:373 #4  0x40e1f884 in android_audio_legacy::out_standby (stream=<optimized out>) at hardware/qcom/audio/alsa_sound/audio_hw_hal.cpp:110 #5  0x401e7100 in android::AudioFlinger::PlaybackThread::threadLoop_standby (this=<optimized out>) at frameworks/av/services/audioflinger/AudioFlinger.cpp:3182 #6  0x401f1dac in android::AudioFlinger::PlaybackThread::threadLoop (this=0x40e4c008) at frameworks/av/services/audioflinger/AudioFlinger.cpp:2918 #7  0x40314e38 in android::Thread::_threadLoop (user=0x40e4c008) at frameworks/native/libs/utils/Threads.cpp:793 #8  0x4031499e in thread_data_t::trampoline (t=<optimized out>) at frameworks/native/libs/utils/Threads.cpp:132 #9  0x4021ee74 in __thread_entry (func=0x40314905 <thread_data_t::trampoline(thread_data_t const*)>, arg=0x40e547b0, tls=0x41ca2f00) at bionic/libc/bionic/pthread.c:217 #10 0x4021e5cc in pthread_create (thread_out=0x40e547d8, attr=0xbed929b8, start_routine=0x40314905 <thread_data_t::trampoline(thread_data_t const*)>, arg=0x40e547b0) at bionic/libc/bionic/pthread.c:356 #11 0x00000000 in ?? () kernel stack of thread 638, PID: 638    TASK: edad5880  CPU: 0   COMMAND: \"AudioOut_2\"  #0 [<c0774fc8>] (__schedule) from [<c077546c>]  #1 [<c077546c>] (schedule_preempt_disabled) from [<c0774254>]  #2 [<c0774254>] (__mutex_lock_slowpath) from [<c07743f4>]  #3 [<c07743f4>] (mutex_lock) from [<c05b10b0>]  #4 [<c05b10b0>] (sitar_hph_pa_event) from [<c05a38cc>]        <==******  #5 [<c05a38cc>] (dapm_seq_check_event) from [<c05a4638>]  #6 [<c05a4638>] (dapm_seq_run_coalesced) from [<c05a4f4c>]  #7 [<c05a4f4c>] (dapm_seq_run.isra.7) from [<c05a57d8>]  #8 [<c05a57d8>] (dapm_power_widgets) from [<c05a5a80>]  #9 [<c05a5a80>] (soc_dapm_stream_event) from [<c05a759c>] #10 [<c05a759c>] (snd_soc_dapm_stream_event) from [<c05a8e84>] #11 [<c05a8e84>] (soc_pcm_close) from [<c05a96b8>] #12 [<c05a96b8>] (soc_dpcm_be_dai_shutdown) from [<c05aaf0c>] #13 [<c05aaf0c>] (soc_dpcm_fe_dai_close) from [<c0588330>] #14 [<c0588330>] (snd_pcm_release_substream) from [<c05883a8>] #15 [<c05883a8>] (snd_pcm_release) from [<c01293dc>] #16 [<c01293dc>] (fput) from [<c0125fa4>] #17 [<c0125fa4>] (filp_close) from [<c0126078>] #18 [<c0126078>] (sys_close) from [<c000dec0>] Thread 638 is in sitar_hph_pa_event(..) and waiting on the kernel mutex at 0xeeb7054c and is scheduled out. 1635static int sitar_hph_pa_event(struct snd_soc_dapm_widget *w, 1636 struct snd_kcontrol *kcontrol, int event) 1637{ 1638 struct snd_soc_codec *codec = w->codec; 1639 struct sitar_priv *sitar = snd_soc_codec_get_drvdata(codec); 1640 u8 mbhc_micb_ctl_val; 1641 pr_debug(\"%s: event = %d\\n\", __func__, event); 1642 1643 switch (event) {   SITAR_ACQUIRE_LOCK(sitar->codec_resource_lock);   }     } 内核态的mutex就好说点了, mutex有个DEBUG_选项时, 可以使用struct mutex::owner来找出占有互斥量的进程. The mutex.owner is task_struct 0xeebbc000, which is kernel thread 114.    PID    PPID  CPU   TASK    ST  %MEM     VSZ    RSS  COMM     114      2   0  eebbc000  UN   0.0       0      0  [irq/325-sitar-h] kthread 114 is in irq_thread interrupt handling. From the kernel call stack, The execution is in snd_soc_jack_report(...)and trys to acquire codec mutex at 0xeeaf4e14. 62void snd_soc_jack_report(struct snd_soc_jack *jack, int status, int mask) 63{ 64 struct snd_soc_codec *codec; 74 75 codec = jack->codec; 76 dapm =  &codec->dapm; 77 78 mutex_lock(&codec->mutex);  79 80 oldstatus = jack->status; 109 snd_jack_report(jack->jack, jack->status); 110 111out: 112 mutex_unlock(&codec->mutex); 113} The codec mutex at 0xeeaf4e14 is owned by task_struct at 0xedad5880, which is pid 638! Check the above kernel stack trace of thread 638 and find the codec mutex is acquired in  snd_soc_dapm_stream_event(...).  3091int snd_soc_dapm_stream_event(struct snd_soc_pcm_runtime *rtd, 3092 const char *stream, int event) 3093{ 3094 struct snd_soc_codec *codec = rtd->codec; 3095 3096 if (stream == NULL) 3097  return 0; 3098 3099 mutex_lock(&codec->mutex);   3100 soc_dapm_stream_event(&codec->dapm, stream, event); 3101 mutex_unlock(&codec->mutex); 3102 3103 return 0; 3104} So, the root cause is mutexes dead-lock in kernel space between kernel context of pid 638 and irq/325-sitar-h. [第二个内存dump分析] 同第一个类似, 虽然互斥占有链不同. 就不用记录代码了. 仅记流水账以加强一下理疗效果. From Android system log    WARN [   2212.508383] (594:614) BroadcastQueue  Timeout of broadcast BroadcastRecord{42df1ee8 com.android.internal.policy.impl.PhoneWindowManager.DELAYED_KEYGUARD} - receiver=android.app.LoadedApk$ReceiverDispatcher$InnerReceiver@42e43818, started 60004ms ago PROBABLE CAUSE OF PROBLEM: Timeout Receiver: android.app.LoadedApk$ReceiverDispatcher$InnerReceiver .... Generating Dalvik backtraces. This might take some time .... Receiver: might be pid 613 ***** Dalvik stack for pid 613 ***** #0  android.media.AudioSystem.setParameters (Native Method) #1  android.media.AudioService$AudioServiceBroadcastReceiver.onReceive (AudioService.java:3779) #2  android.app.LoadedApk$ReceiverDispatcher$Args.run (LoadedApk.java:765) #3  android.os.Handler.handleCallback (Handler.java:615) #4  android.os.Handler.dispatchMessage (Handler.java:94) #5  android.os.Looper.loop (Looper.java:147) #6  com.android.server.ServerThread.run (SystemServer.java:219) -- Break frame -- This thread is probably doing a binder call as kernel backtrace includes binder_ioctl Thread at the other end of the binder: 735 Same as first issue, Thread 735 is in the mediaserver Process. PID: 171    TASK: ee67c700  CPU: 0   COMMAND: \"mediaserver\"   PID: 499    TASK: ed98d180  CPU: 0   COMMAND: \"AudioCommand\"   PID: 500    TASK: ed98e680  CPU: 1   COMMAND: \"ApmCommand\"   PID: 513    TASK: edc96300  CPU: 0   COMMAND: \"mediaserver\"   PID: 521    TASK: ed98ca80  CPU: 0   COMMAND: \"FastMixer\"   PID: 621    TASK: eaa07800  CPU: 0   COMMAND: \"AudioOut_2\"   PID: 622    TASK: eaa07b80  CPU: 0   COMMAND: \"Binder_1\"   PID: 735    TASK: e10bd500  CPU: 0   COMMAND: \"Binder_2\"   PID: 3183   TASK: e111bb80  CPU: 0   COMMAND: \"Binder_3\"   PID: 5351   TASK: eebbdf80  CPU: 0   COMMAND: \"Binder_4\" Binder_2 is in AudioFlinger::setParameters and is waiting on mutex (pthread_mutex_t *) = 0x411857d0; The mutex is AutoMutex lock(mHardwareLock) and is held by thread 500. In Userspace, Thread 500 is in system call ioctl(...) in adev_set_fm_volume(..) in AudioFlinger:::setFmVolume(float value) holding the lock AutoMutex lock(mHardwareLock). And In Kernel Space, Thread 500 is waiting on kernel mutex 0xeeb70214 held by thread 521. Checking kernel call stack of Thread 521, find that it is waiting on kernel mutex 0xeeb7054c held by thread 4538 which is a workqueue work kthread.    PID    PPID  CPU   TASK    ST  %MEM     VSZ    RSS  COMM    4538      2   0  e4a2aa00  UN   0.0       0      0  [kworker/0:0] Checking the kworker's stack trace, find it is waiting on kernel mutex 0xeeaf4e14 held by task_struct 0xed98ca80, pid 521!! So, The roor cause is kernel mutexes dead-lock. Break or avoid the dead-lock to solve the issues. ","title":"Two more complicated dead-lock issues of android app"},{"content":"注：本文由BeyondVincent(破船)翻译首发         转载请注明出处：BeyondVincent(破船)@DevDiv.com   第27日-倾斜仪:         今天，我介绍最后一个传感器：倾斜仪。在Windows Phone中，有点类似Motion类提供的功能。倾斜仪利用X、Y和Z轴上的3个值来计算出3个重要的值：Pitch（俯仰）、Yaw（偏航）和Roll（滚转）。如果你涉及到航空领域，那么你可能会知道这三个的意思，它们的意思是旋转围绕XYZ轴的值。看下面的示例：（点击图片，可以看到动画效果） PDF下载地址： 第27日-倾斜仪 更多内容请浏览下面链接： Windows 8 开发31日","title":"Windows Store apps开发[85]Windows 8 开发31日-第27日-倾斜仪"},{"content":"char* 转为NSString* NSStringEncoding enc = CFStringConvertEncodingToNSStringEncoding (kCFStringEncodingGB_18030_2000); char* c_test = \"先先先\"； int nLen = strlen(c_test); NSString* str = [[NSString alloc]initWithBytes:c_test length:nLen encoding:enc ]; 创建一个mac os的工程，加入代码： [cpp] view plaincopy const NSStringEncoding *encodings = [NSString availableStringEncodings];              NSMutableString *str = [[NSMutableString alloc] init];              NSStringEncoding encoding;              while ((encoding = *encodings++) != 0)       {                      [str appendFormat: @\"%@ === %li\\n\", [NSString localizedNameOfStringEncoding:encoding], encoding];       }       NSLog(@\"%@\",str);   得到： Western (Mac OS Roman) === 30 Japanese (Mac OS) === 2147483649 Traditional Chinese (Mac OS) === 2147483650 Korean (Mac OS) === 2147483651 Arabic (Mac OS) === 2147483652 Hebrew (Mac OS) === 2147483653 Greek (Mac OS) === 2147483654 Cyrillic (Mac OS) === 2147483655 Devanagari (Mac OS) === 2147483657 Gurmukhi (Mac OS) === 2147483658 Gujarati (Mac OS) === 2147483659 Thai (Mac OS) === 2147483669 Simplified Chinese (Mac OS) === 2147483673 Tibetan (Mac OS) === 2147483674 Central European (Mac OS) === 2147483677 Symbol (Mac OS) === 6 Dingbats (Mac OS) === 2147483682 Turkish (Mac OS) === 2147483683 Croatian (Mac OS) === 2147483684 Icelandic (Mac OS) === 2147483685 Romanian (Mac OS) === 2147483686 Celtic (Mac OS) === 2147483687 Gaelic (Mac OS) === 2147483688 Keyboard Symbols (Mac OS) === 2147483689 Farsi (Mac OS) === 2147483788 Cyrillic (Mac OS Ukrainian) === 2147483800 Inuit (Mac OS) === 2147483884 Unicode (UTF-16) === 10 Unicode (UTF-7) === 2214592768 Unicode (UTF-8) === 4 Unicode (UTF-32) === 2348810496 Unicode (UTF-16BE) === 2415919360 Unicode (UTF-16LE) === 2483028224 Unicode (UTF-32BE) === 2550137088 Unicode (UTF-32LE) === 2617245952 Western (ISO Latin 1) === 5 Central European (ISO Latin 2) === 9 Western (ISO Latin 3) === 2147484163 Central European (ISO Latin 4) === 2147484164 Cyrillic (ISO 8859-5) === 2147484165 Arabic (ISO 8859-6) === 2147484166 Greek (ISO 8859-7) === 2147484167 Hebrew (ISO 8859-8) === 2147484168 Turkish (ISO Latin 5) === 2147484169 Nordic (ISO Latin 6) === 2147484170 Thai (ISO 8859-11) === 2147484171 Baltic (ISO Latin 7) === 2147484173 Celtic (ISO Latin 8) === 2147484174 Western (ISO Latin 9) === 2147484175 Romanian (ISO Latin 10) === 2147484176 Latin-US (DOS) === 2147484672 Greek (DOS) === 2147484677 Baltic (DOS) === 2147484678 Western (DOS Latin 1) === 2147484688 Greek (DOS Greek 1) === 2147484689 Central European (DOS Latin 2) === 2147484690 Cyrillic (DOS) === 2147484691 Turkish (DOS) === 2147484692 Portuguese (DOS) === 2147484693 Icelandic (DOS) === 2147484694 Hebrew (DOS) === 2147484695 Canadian French (DOS) === 2147484696 Arabic (DOS) === 2147484697 Nordic (DOS) === 2147484698 Russian (DOS) === 2147484699 Greek (DOS Greek 2) === 2147484700 Thai (Windows, DOS) === 2147484701 Japanese (Windows, DOS) === 8 Simplified Chinese (Windows, DOS) === 2147484705 Korean (Windows, DOS) === 2147484706 Traditional Chinese (Windows, DOS) === 2147484707 Western (Windows Latin 1) === 12 Central European (Windows Latin 2) === 15 Cyrillic (Windows) === 11 Greek (Windows) === 13 Turkish (Windows Latin 5) === 14 Hebrew (Windows) === 2147484933 Arabic (Windows) === 2147484934 Baltic (Windows) === 2147484935 Vietnamese (Windows) === 2147484936 Western (ASCII) === 1 Japanese (Shift JIS X0213) === 2147485224 Chinese (GBK) === 2147485233 Chinese (GB 18030) === 2147485234 Japanese (ISO 2022-JP) === 21 Japanese (ISO 2022-JP-2) === 2147485729 Japanese (ISO 2022-JP-1) === 2147485730 Chinese (ISO 2022-CN) === 2147485744 Korean (ISO 2022-KR) === 2147485760 Japanese (EUC) === 3 Simplified Chinese (GB 2312) === 2147486000 Traditional Chinese (EUC) === 2147486001 Korean (EUC) === 2147486016 Japanese (Shift JIS) === 2147486209 Cyrillic (KOI8-R) === 2147486210 Traditional Chinese (Big 5) === 2147486211 Western (Mac Mail) === 2147486212 Simplified Chinese (HZ GB 2312) === 2147486213 Traditional Chinese (Big 5 HKSCS) === 2147486214 Ukrainian (KOI8-U) === 2147486216 Traditional Chinese (Big 5-E) === 2147486217 Western (NextStep) === 2 Non-lossy ASCII === 7 Western (EBCDIC Latin Core) === 2147486721 Western (EBCDIC Latin 1) === 2147486722 得到这么多神奇的数字，这些神奇的数字就是对应的编码格式。 http://blog.csdn.net/ydj213/article/details/8296414","title":"IOS中的编码格式—char*汉字转为NSString*"},{"content":"有时,我们需要获得电池的信息,特别是在全屏模式下,我们希望实时掌握手机的相关信息(比如电池,时间等)需要用到一些方法: 先看一下怎么获得系统时间: Calendar calendar = Calendar.getInstance; int hour = calendar.get(Calendar.Hour_OF_DAY); 照例,可以获得系统详细的时间和日期,值得注意的是:在设置日期格式时,要注意月份和分钟分别开来: SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd hh:mm \");//设置日期格式 月份是大写的MM,而时间是小写的,一旦搞错将得不到正解的信息 下面看看电池信息:  * 电池信息的取得，调用registerReceiver()方法。 第1个参数，设置BroadcastReceiver实例 第2个参数，设置追加了Intent.ACTION_BATTERY_CHANGED处理的IntentFilter实例。 ● 在BroadcastReceiver的onReceive()事件，接收到的Intent.ACTION_BATTERY_CHANGED，包括下面的信息。 “status”（int类型）…状态，定义值是BatteryManager.BATTERY_STATUS_XXX。 “health”（int类型）…健康，定义值是BatteryManager.BATTERY_HEALTH_XXX。 “present”（boolean类型） “level”（int类型）…电池剩余容量 “scale”（int类型）…电池最大值。通常为100。 “icon-small”（int类型）…图标ID。 “plugged”（int类型）…连接的电源插座，定义值是BatteryManager.BATTERY_PLUGGED_XXX。 “voltage”（int类型）…mV。 “temperature”（int类型）…温度，0.1度单位。例如 表示197的时候，意思为19.7度。 “technology”（String类型）…电池类型，例如，Li-ion等等。 看一个实例: import android.app.Activity;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.os.Bundle;import android.widget.TextView;public class get_imformation_battery extends Activity { private TextView tvBatteryLevel; private BroadcastReceiver mBatteryInfoReceiver = new BroadcastReceiver() {  @Override  public void onReceive(Context context, Intent intent) {   String action = intent.getAction();   if (Intent.ACTION_BATTERY_CHANGED.equals(action)) {    int level = intent.getIntExtra(\"level\", 0);    int scale = intent.getIntExtra(\"scale\", 100); //电池最大值。通常为100    tvBatteryLevel.setText(\"Battery level: \"      + String.valueOf(level * 100 / scale) + \"%\");        //其它信息    {     int level1 = intent.getIntExtra(\"level\", -1);// 获取电池剩余电量     int health = intent.getIntExtra(\"health\", -1);// 获取电池剩余电量的状态     int voltage = intent.getIntExtra(\"voltage\", -1);// 获取电压值     int temperature = intent.getIntExtra(\"temperature\", -1);// 获取电池的温度     System.out.println(level1 + \":\" + health + \":\" + voltage       + \":\" + temperature);    }   }  } }; @Override public void onResume() {  super.onResume();  registerReceiver(mBatteryInfoReceiver, new IntentFilter(    Intent.ACTION_BATTERY_CHANGED)); } @Override public void onPause() {  super.onPause();  unregisterReceiver(mBatteryInfoReceiver); } @Override public void onCreate(Bundle savedInstanceState) {  super.onCreate(savedInstanceState);  //setContentView(R.layout.main);  //tvBatteryLevel = (TextView) findViewById(R.id.tvBatteryLevel); }}  ","title":"Android开发-获取设备电池信息及时间日期等详细信息"},{"content":"OpenGL中的6种坐标系 OpenGL中存在6种坐标系， 1. Object or model coordinates 2. World coordinates 3. Eye (or Camera) coordinates 4. Clip coordinates 5. Normalized device coordinates 6. Window (or screen) coordinates 经常用到的  世界坐标  物体坐标， 屏幕坐标  ，眼坐标 物体坐标是以物体某一点为原点而建立的“世界坐标”，该坐标系仅对该物体适用，用来简化对物体各部分坐标的描述。物体放到场景中时，各部分经历的坐标变换相同，相对位置不变，所以可视为一个整体，与人类的思维习惯一致。 眼坐标是以视点为原点，以视线的方向为Z+轴正方向的坐标系中的方向。OpenGL管道会将世界坐标先变换到眼坐标，然后进行裁剪，只有在视线范围(视见体)之内的场景才会进入下一阶段的计算。 同样的，有投影变换矩阵栈(Projection)，栈顶矩阵就是当前投影变换矩阵，负责将场景各坐标变换到眼坐标，由所得到的结果是裁剪后的场景部分，称为裁剪坐标。前面提到过的视见体设定其实就是在建立该矩阵。 设备坐标：OpenGL 的重要功能之一就是将三维的世界坐标经过变换、投影等计算，最终算出它在显示设备上对应的位置，这个位置就称为设备坐标。在屏幕、打印机等设备上的坐标是二维坐标。值得一提的是，OpenGL可以只使用设备的一部分进行绘制，这个部分称为视区或视口(viewport)。投影得到的是视区内的坐标(投影坐标)，从投影坐标到设备坐标的计算过程就是设备变换了。 坐标其实跟现实世界中差不多，我们可以把自己当成当前的  相机（眼），  看向某 一个物体， 而所处的空间就是世界。 举个例子， opengl 中的旋转 可以采用   gl.glRotatef(30, 1, y, z)     物体绕着自身 X轴  旋转，  此时是以 世界为参照物  而当我们的  眼睛 绕着物体旋转时，如果以我们的眼睛为参照物  ， 可以认为 是  物体自身在旋转， 其它方法跟上篇一样 一  物体本身旋转 \t@Override\tpublic void onDrawFrame(GL10 gl) {\t\t// TODO Auto-generated method stub\t\t//每次rota 增加原有的0.5   因为我们这边每次绘制的时候 会               \t//gl.glLoadIdentity(); 重置原来的位置,  旋转的轴   感觉应该是  如果是绕X轴旋转  感觉是将X轴平移到 中垂线的交点，然后\t\t//绕着该轴旋转 ，没验证过rota+=0.5;//清楚颜色，深度缓存gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);//开启模型试图矩阵gl.glMatrixMode(GL10.GL_MODELVIEW);//加载一个基本矩阵 可以理解为重置矩阵，因为每次draw后 会保留原来的矩阵，如果不重置矩阵 ，在translate时 物体就会越离越远gl.glLoadIdentity();//眼睛设的视野距离为 -1，-20的坐标，则只有在该范围内 的物体才能看到 将物体移动到 z =-3处gl.glTranslatef(0, 0, -3f);//定义坐标点 数组 Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.gl.glRotatef(rota, 1, 0,0);gl.glVertexPointer(3, GL10.GL_FLOAT, 0,getFloatBuffer(lines));//启用定点数组 跟下面disable 相互对应 gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);//设置画笔颜色gl.glColor4f(1.0F, 0F,0F,1.0F);//绘制三角形gl.glDrawArrays(GL10.GL_TRIANGLES, 0,3);gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);} gl.glLoadIdentity();是加载一个单位矩阵， opengl 还提供了gl.glPushMatrix(),gl.glPopMatrix()  将当前矩阵放入入栈 和出栈，  开销比 gl.glLoadIdentity()小  gl.glPushMatrix(); gl.glTranslatef(0, 0, -3f); //定义坐标点  数组  Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4. gl.glRotatef(rota, 1, 0,0); gl.glVertexPointer(3, GL10.GL_FLOAT, 0,getFloatBuffer(lines)); //启用定点数组   跟下面disable 相互对应   gl.glEnableClientState(GL10.GL_VERTEX_ARRAY); //设置画笔颜色 gl.glColor4f(1.0F, 0F,0F,1.0F); //绘制三角形 gl.glDrawArrays(GL10.GL_TRIANGLES, 0,3); gl.glPopMatrix(); 二 通过改变  眼睛 所在位置 从而达到物体旋转 GLU.gluLookAt(GL10 gl, float eyeX, float eyeY, float eyeZ,             float centerX, float centerY, float centerZ, float upX, float upY,             float upZ) eye  为眼睛所处的距离      center 为眼睛看向的点   比如 看向    （0,0 ，-3 ）这个点      up为 眼睛所处的 角度    (0,1,0）就可以理解为站着   （0，-1,0）倒立 下面是通过 改变 我们眼睛 （相机）的位置 来实现 物体旋转 float rota=0.5f;\t@Override\tpublic void onDrawFrame(GL10 gl) {\t\t// TODO Auto-generated method stub\t//清楚颜色，深度缓存\t\tgl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);\t\t\t\t//开启模型试图矩阵\t\tgl.glMatrixMode(GL10.GL_MODELVIEW);\t\t\t\t//改变眼睛所处的位置，眼睛看向的点 是物体所处坐标的中心点   此处  为，0,0,-3 ( 移动到了-3处，   绕着中心点旋转，到圆心的坐标 就可以通过    //cos^2X +sin^2Y=R^2 这个公式来推导了\t\tgl.glLoadIdentity();\t\tGLU.gluLookAt(gl,0,(float)Math.cos(Math.toRadians(rota))*3,(float)Math.sin(Math.toRadians(rota))*3-3,0,0,-3,0, 1, 0);\t\t\t\trota+=0.5;\t\t//加载一个基本矩阵 可以理解为重置矩阵，因为每次draw后 会保留原来的矩阵，如果不重置矩阵 ，在translate时 物体就会越离越远\t\t//眼睛设的视野距离为    -1，-20的坐标，则只有在该范围内 的物体才能看到    将物体移动到 z =-3处\t\tgl.glTranslatef(0, 0, -3f);\t\t//定义坐标点  数组  Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.\t\t//gl.glRotatef(rota, 1, 0,0);\t\tgl.glVertexPointer(3, GL10.GL_FLOAT, 0,getFloatBuffer(lines));\t\t//启用定点数组   跟下面disable 相互对应  \t\tgl.glEnableClientState(GL10.GL_VERTEX_ARRAY);\t\t\t\t//设置画笔颜色\t\tgl.glColor4f(1.0F, 0F,0F,1.0F);\t\t//绘制三角形\t\tgl.glDrawArrays(GL10.GL_TRIANGLES, 0,3);\t\tgl.glDisableClientState(GL10.GL_VERTEX_ARRAY);\t\t\t}","title":"android opengles 坐标系 旋转改变 视角位置"},{"content":"最近我们在做一个LCM两屏或三屏兼容的问题,所以首先要在uboot里面读出各屏的id,然后再将读得到的id传给recovery和kernel,实现机器的正常显示. 一.首先实现uboot读lcm的id.           1.bootable/bootloader/lk/target/msm7627a_sku3_Q6_D/rules.mk是uboot里面宏开关,打开所显示的屏宏 DEFINES += DISPLAY_MIPI_CMD_PANEL_ILI9487=1 DEFINES += DISPLAY_MIPI_CMD_PANEL_HX8357=1           2.去初始化mipi的地方先读id. bootable/bootloader/lk/platform/msm_shared/mipi_dsi.c               在函数int mipi_dsi_panel_initialize(struct mipi_dsi_panel_config *pinfo) {        ...... #if defined(DISPLAY_MIPI_CMD_PANEL_ILI9487)||defined(DISPLAY_MIPI_CMD_PANEL_HX8357)     mipi_dsi_cmd_bta_sw_trigger();     dat = mipi_viroyal_manufacture_id();     if(dat == 0x90)     {         lcm_flag = 8357;        //hx8357-c     }     else     {         lcm_flag = 9487;        //ili9487     }          pinfo_tmp =get_panel_info();     memcpy(pinfo, pinfo_tmp, sizeof(struct mipi_dsi_panel_config)); #endif        ...... }            3.读到id后再初始化屏                 struct mipi_dsi_panel_config *get_panel_info(void) {               ......... #elif (DISPLAY_MIPI_CMD_PANEL_ILI9487)||(DISPLAY_MIPI_CMD_PANEL_HX8357)     if (lcm_flag == 8357)         return &hx8357_cmd_panel_info;     else         return &ili9487_cmd_panel_info; #endif                .......... } 这样在uboot里面就成功可以显示图片了,下面是如何将lcm_flag的值传给kernel了. 二.传lcm_flag给kernel      1.uboot里面要做的bootable/bootloader/lk/app/aboot/aboot.c          其实原生态的android系统就有一个将uboot传给kernel的例子,那就是跟踪代码static const char *boot_splash = \" splash=1\";           我做的也是效仿系统做的,先定义一个字符串 static const char *lcm_flg_ili9486 = \" lcmflag=9486\"; static const char *lcm_flg_nt35310 = \" lcmflag=5310\"; 然后在下面的函数copy到kernel void boot_linux(void *kernel, unsigned *tags,         const char *cmdline, unsigned machtype,         void *ramdisk, unsigned ramdisk_size) {    .....         if(!boot_into_recovery)     {         cmdline_len += strlen(boot_splash);         #if DISPLAY_TYPE_MIPI         if (lcm_flag == 8357)         cmdline_len += strlen(lcm_flg_hx8357c);         else         cmdline_len += strlen(lcm_flg_ili9487);         #endif    .....        if (!boot_into_recovery)         {         #if DISPLAY_TYPE_MIPI             if (lcm_flag == 8357)                src = lcm_flg_hx8357c;             else                src = lcm_flg_ili9487;         #endif         if (have_cmdline) --dst;         while ((*dst++ = *src++));    ..... } 这样uboot里面的动作就做完了,即是将uboot里面的数据copy到一个数组里面,这个数组能从uboot传给kernel. 三.kernel接受uboot传来的字符串 msm7627a/kernel/arch/arm/mach-msm/board-msm7x27a.c 在这个函数里面接受(依据自己用的平台阿,要灵活),同样是模仿boot_splash,在代码里添加接受字符串,并转化为数字 /* LK lcm_flag, 0 - off, 1 - on */ int lcm_flag = 0; static int __init lk_lcmflag_setup(char *str) {     lcm_flag = simple_strtol(str, NULL, 0);     printk(\"lcmflag = %d\\n\", lcm_flag);     return 1; } __setup(\"lcmflag=\", lk_lcmflag_setup); 这样就算是取到lcm_flag的值了,然后在具体的驱动中extern int lcm_flag即可,简单吧.其实技术就那样,很怕人认真,呵呵.开个玩笑. 四.把uboot里面的id还要给recovery      上面做完其实lcm可以在uboot和kernel正常显示了,但有一个位置显示会比较诡异,那就是进入\"恢复出厂设置\"的时候,会有一个诡异的画面,哥研究了2天,最终得出结论原来是recovery没有正常的接受到正确的屏的id,于是乎就将正确的id传给内核       还是从bootable/bootloader/lk/app/aboot/aboot.c入手,现在就是要记住关键字static const char *boot_splash_recovery = \" splash=0\";        我就仿效boot_splash_recovery将lcm_flag添加再下面的函数中: void boot_linux(void *kernel, unsigned *tags,         const char *cmdline, unsigned machtype,         void *ramdisk, unsigned ramdisk_size) {   ....     #if DISPLAY_SPLASH_IN_KERNEL     if(!boot_into_recovery)     {                  ........     }     else     {         cmdline_len += strlen(boot_splash_recovery);         #if DISPLAY_TYPE_MIPI          if (lcm_flag == 8357)              cmdline_len += strlen(lcm_flg_hx8357c);          else              cmdline_len += strlen(lcm_flg_ili9487);          #endif     } #endif   ....    if(!boot_into_recovery)         {                       .............         }         else         {             src = boot_splash_recovery;             if (have_cmdline) --dst;             have_cmdline = 1;             while ((*dst++ = *src++));             #if DISPLAY_TYPE_MIPI             if (lcm_flag == 8357)                 src = lcm_flg_hx8357c;             else                 src = lcm_flg_ili9487;             #endif             if (have_cmdline) --dst;             while ((*dst++ = *src++));         }        ...... }     这样recovery就能完全接受uboot里面传来的值,其他的就不用做了.到这里整个系统都可以完全显示完整正确的图片.","title":"如何将uboot里面的参数传给recovery或kernel"},{"content":"mainActivity如下: package cn.com;import android.media.MediaPlayer;import android.media.MediaPlayer.OnCompletionListener;import android.media.MediaPlayer.OnErrorListener;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.widget.ImageView;import android.widget.TextView;import android.app.Activity;/** * 重要错误总结: * Eclipse报错prepareAsync called in state 8 * 原因: * 在initView()方法中: * mMediaPlayer=MediaPlayer.create(MainActivity.this, R.raw.big); * 为此mMediaPlayer设置了要播放的资源 * 但是在点击stop按钮以后,执行了mMediaPlayer.release(); * 这样的话就释放了资源.所以报错 * 解决办法: * 在每次点击play的时候,都执行MediaPlayer.create() * 注意: * 可以在每次点击暂停的时候保存现在播放的位置即: * position=mMediaPlayer.getCurrentPosition(); * 然后在每次播放的时候 * mMediaPlayer.seekTo(position); * 这样就会从暂停处继续播放 *  * */public class MainActivity extends Activity {\tprivate TextView mTextView;\tprivate MediaPlayer mMediaPlayer;    private ImageView mPlayerImageView;    private ImageView mPauseImageView;    private ImageView mStopImageView;    private boolean isPause=false;    private boolean isStop=false;    private boolean isStart=false;    private int currentPosition=0;    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.main);        initView();    }   private void initView(){\t   mTextView=(TextView) findViewById(R.id.textView);\t   mPlayerImageView=(ImageView) findViewById(R.id.playerImageButton);\t   mPlayerImageView.setOnClickListener(new ButtonOnClickListener());\t   mPauseImageView=(ImageView) findViewById(R.id.pauseImageButton);\t   mPauseImageView.setOnClickListener(new ButtonOnClickListener());\t   mStopImageView=(ImageView) findViewById(R.id.stopImageButton);\t   mStopImageView.setOnClickListener(new ButtonOnClickListener());\t   mMediaPlayer=new MediaPlayer();\t  // mMediaPlayer=MediaPlayer.create(MainActivity.this, R.raw.big);\t   mMediaPlayer.setOnCompletionListener(new OnCompletionListener() {\t\tpublic void onCompletion(MediaPlayer mp) {\t\t\tmMediaPlayer.release();\t\t\tmTextView.setText(\"音乐播放完毕\");\t\t}\t});\t   mMediaPlayer.setOnErrorListener(new OnErrorListener() {\t\tpublic boolean onError(MediaPlayer mp, int what, int extra) {\t\t\tmMediaPlayer.release();\t\t\tmTextView.setText(\"音乐播放错误\");\t\t\treturn false;\t\t}\t});   }   \tprivate class ButtonOnClickListener implements OnClickListener {\t\tpublic void onClick(View v) {\t\t\tswitch (v.getId()) {\t\t\tcase R.id.playerImageButton:\t\t\t\tif (!isStart) {\t\t\t\t\ttry {\t\t\t\t\t\t mMediaPlayer=MediaPlayer.create(MainActivity.this, R.raw.big);\t\t\t\t\t\t//mMediaPlayer.prepare();\t\t\t\t\t\tmMediaPlayer.seekTo(currentPosition);\t\t\t\t\t\tmMediaPlayer.start();\t\t\t\t\t\tmMediaPlayer.setLooping(true);\t\t\t\t\t\tmTextView.setText(\"开始音乐播放\");\t\t\t\t\t\tisStart = true;\t\t\t\t\t\tisPause = false;\t\t\t\t\t\tisStop = false;\t\t\t\t\t} catch (Exception e) {\t\t\t\t\t}\t\t\t\t}\t\t\t\tbreak;\t\t\tcase R.id.pauseImageButton:\t\t\t\tif (mMediaPlayer != null) {\t\t\t\t\tif (!isStop) {\t\t\t\t\t\tif (!isPause) {\t\t\t\t\t\t\tmMediaPlayer.pause();\t\t\t\t\t\t\tmTextView.setText(\"暂停音乐播放\");\t\t\t\t\t\t\tcurrentPosition=mMediaPlayer.getCurrentPosition();\t\t\t\t\t\t\tisPause = true;\t\t\t\t\t\t\tisStop = false;\t\t\t\t\t\t\tisStart = false;\t\t\t\t\t\t} else {\t\t\t\t\t\t\tmMediaPlayer.start();\t\t\t\t\t\t\tmTextView.setText(\"继续播放音乐\");\t\t\t\t\t\t\tisStart = true;\t\t\t\t\t\t\tisPause = false;\t\t\t\t\t\t\tisStop = false;\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t}\t\t\t\tbreak;\t\t\tcase R.id.stopImageButton:\t\t\t\tif (mMediaPlayer != null) {\t\t\t\t\tif (isStart) {\t\t\t\t\t\tif (!isStop) {\t\t\t\t\t\t\tmMediaPlayer.stop();\t\t\t\t\t\t\tmMediaPlayer.release();\t\t\t\t\t\t\tmTextView.setText(\"停止音乐播放\");\t\t\t\t\t\t\tcurrentPosition=0;\t\t\t\t\t\t\tisStop = true;\t\t\t\t\t\t\tisPause = false;\t\t\t\t\t\t\tisStart = false;\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t}\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tbreak;\t\t\t}\t\t}\t}  } main.xml如下: <RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:tools=\"http://schemas.android.com/tools\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\" >    <TextView        android:id=\"@+id/textView\"        android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\"        android:layout_centerHorizontal=\"true\"        android:text=\"测试MediaPlayer\"        android:textSize=\"30sp\"    />    <LinearLayout         android:layout_width=\"wrap_content\"        android:layout_height=\"70dip\"        android:orientation=\"horizontal\"        android:layout_below=\"@id/textView\"     >        <ImageView             android:id=\"@+id/playerImageButton\"            android:layout_width=\"70dip\"            android:layout_height=\"70dip\"            android:src=\"@drawable/player\"         />        <ImageView             android:id=\"@+id/pauseImageButton\"            android:layout_width=\"70dip\"            android:layout_height=\"70dip\"            android:src=\"@drawable/pause\"            android:layout_marginLeft=\"20dip\"         />        <ImageView             android:id=\"@+id/stopImageButton\"            android:layout_width=\"70dip\"            android:layout_height=\"70dip\"            android:src=\"@drawable/stop\"            android:layout_marginLeft=\"20dip\"         />    <\/LinearLayout><\/RelativeLayout>  ","title":"Android播放音乐"},{"content":"常用的一些占位符： %@：字符串占位符 %d:整型 %ld:长整型 %f:浮点型 %c:char类型 %%：%的占位符 尽管有那么多的占位符，但是好像没有发现BOOL型的数据的占位符，这也是比较纠结的地方，看了一下别人是怎么解决这个问题的  BOOL studyBool = YES;        NSLog(@\"打印BOOL型数据%@\",studyBool?@\"YES\":@\"NO\");//打印BOOL型数据YES        NSLog(@\"打印BOOL型数据%d\",studyBool);//打印BOOL型数据1                BOOL alsoBool = NO;        NSLog(@\"打印BOOL型数据%@\",alsoBool?@\"YES\":@\"NO\");//打印BOOL型数据NO        NSLog(@\"打印BOOL型数据%d\",alsoBool);//打印BOOL型数据0 详细介绍：********************************************************** %@:             Objective-C对象,印有字符串返回descriptionWithLocale:如果于的话,或描述相反.CFTypeRef工作对象,返回的结果的CFCopyDescription功能.(这个翻译有问题建议按照自己的理解方式理解)。 %%:             为'%'字符; %d,%D,%i:   为32位整型数(int); %u,%U:        为32位无符号整型数(unsigned int); %hi:   为有符号的16位整型数(short); %hu:  为无符号的16位整型数(unsigned shord); %qi:   为有符号的64位整型数(long long); %qu:  为无符号的64位整型数(unsigned long long); %x:    为32位的无符号整型数(unsigned int),打印使用数字0-9的十六进制,小写a-f; %X:    为32位的无符号整型数(unsigned int),打印使用数字0-9的十六进制,大写A-F; %qx:   为无符号64位整数(unsigned long long),打印使用数字0-9的十六进制,小写a-f; %qX:   为无符号64位整数(unsigned long long),打印使用数字0-9的十六进制,大写A-F; %o,%O:   为32位的无符号整数（unsigned int),打印八进制数; %f:      为64位的浮点数(double); %e:      为64位的浮点数(double),打印使用小写字母e,科学计数法介绍了指数的增大而减小; %E:      为64位的浮点数(double),打印科学符号使用一个大写E介绍指数的增大而减小; %g:      为64位的浮点数(double),用%e的方式打印指数,如果指数小于4或者大于等于精度,那么%f的风格就会有不同体现; %G:      为64位的浮点数(double),用%E的方式打印指数,如果指数小于4或者大于等于精度,那么%f的风格就会有不同体现; %c:       为8位的无符号字符%c(unsigned char),通过打印NSLog()将其作为一个ASCII字符,或者,不是一个ASCII字符,八进制格式\\ddd或统一标准的字符编码的十六进制格式\\udddd,在这里d是一个数字; %C:       为16位Unicode字符%C(unichar),通过打印NSLog()将其作为一个ASCII字符,或者,不是一个ASCII字符,八进制格式\\ddd或统一标准的字符编码的十六进制格式\\\\udddd,在这里d是一个数字; %s:       对于无符号字符数组空终止,%s系统中解释其输入编码,而不是别的,如utf-8; %S:       空终止一系列的16位Unicode字符; %p:       空指针(无效*)，打印十六进制的数字0-9和小写a-f,前缀为0x; %L:       在明确规定的长度下,进行修正,下面的一批数据a,A,e,E,f,F,g,G应用于双精度长整型的参数; %a:       为64位的浮点数(double),按照科学计数法打印采用0x和一个十六进制数字前使用小写小数点p来介绍指数的增大而减小; %A:       为64位的浮点数(double),按照科学计数法打印采用0X和一个十六进制数字前使用大写字母小数点P界扫指数的增大而减小； %F:       为64位的浮点数(double),按照十进制表示法进行打印； %z:       修改说明在%z长度以下d,i,o,u,x,X适用于某一指定类型的转换或者适用于一定尺寸的整数类型的参数; %t:       修改说明在%t长度以下d,i,o,u,x,X适用于某一指定类型或一定尺寸的整数类型的转换的参数; %j:       修改说明在%j长度以下d,i,o,u,x,X适用于某一指定类型或一定尺寸的整数类型的转换的参数。 英文文档 格式定义 The format specifiers supported by the NSString formatting methods and CFString formatting functions follow the IEEE printf specification; the specifiers are summarized in Table 1. Note that you can also use the “n$” positional specifiers such as %1$@ %2$s. For more details, see the IEEE printf specification. You can also use these format specifiers with the NSLog function. Table 1 Format specifiers supported by the NSString formatting methods and CFString formatting functions 定义 说明 %@ Objective-C object, printed as the string returned by descriptionWithLocale: if available, or description otherwise. Also works with CFTypeRef objects, returning the result of the CFCopyDescription function. %% ‘%’ character %d, %D, %i Signed 32-bit integer (int) %u, %U Unsigned 32-bit integer (unsigned int) %hi Signed 16-bit integer (short) %hu Unsigned 16-bit integer (unsigned short) %qi Signed 64-bit integer (long long) %qu Unsigned 64-bit integer (unsigned long long) %x Unsigned 32-bit integer (unsigned int), printed in hexadecimal using the digits 0–9 and lowercase a–f %X Unsigned 32-bit integer (unsigned int), printed in hexadecimal using the digits 0–9 and uppercase A–F %qx Unsigned 64-bit integer (unsigned long long), printed in hexadecimal using the digits 0–9 and lowercase a–f %qX Unsigned 64-bit integer (unsigned long long), printed in hexadecimal using the digits 0–9 and uppercase A–F %o, %O Unsigned 32-bit integer (unsigned int), printed in octal %f 64-bit floating-point number (double) %e 64-bit floating-point number (double), printed in scientific notation using a lowercase e to introduce the exponent %E 64-bit floating-point number (double), printed in scientific notation using an uppercase E to introduce the exponent %g 64-bit floating-point number (double), printed in the style of %e if the exponent is less than –4 or greater than or equal to the precision, in the style of %f otherwise %G 64-bit floating-point number (double), printed in the style of %E if the exponent is less than –4 or greater than or equal to the precision, in the style of %f otherwise %c 8-bit unsigned character (unsigned char), printed by NSLog() as an ASCII character, or, if not an ASCII character, in the octal format \\\\ddd or the Unicode hexadecimal format \\\\udddd, where d is a digit %C 16-bit Unicode character (unichar), printed by NSLog() as an ASCII character, or, if not an ASCII character, in the octal format \\\\ddd or the Unicode hexadecimal format \\\\udddd, where d is a digit %s Null-terminated array of 8-bit unsigned characters. %s interprets its input in the system encoding rather than, for example, UTF-8. %S Null-terminated array of 16-bit Unicode characters %p Void pointer (void *), printed in hexadecimal with the digits 0–9 and lowercase a–f, with a leading 0x %L Length modifier specifying that a following a, A, e, E, f, F, g, or G conversion specifier applies to a long double argument %a 64-bit floating-point number (double), printed in scientific notation with a leading 0x and one hexadecimal digit before the decimal point using a lowercase p to introduce the exponent %A 64-bit floating-point number (double), printed in scientific notation with a leading 0X and one hexadecimal digit before the decimal point using a uppercase P to introduce the exponent %F 64-bit floating-point number (double), printed in decimal notation %z Length modifier specifying that a following d, i, o, u, x, or X conversion specifier applies to a size_t or the corresponding signed integer type argument %t Length modifier specifying that a following d, i, o, u, x, or X conversion specifier applies to a ptrdiff_t or the corresponding unsigned integer type argument %j Length modifier specifying that a following d, i, o, u, x, or X conversion specifier applies to a intmax_t or uintmax_t argument 平台依赖 Mac OS X uses several data types—NSInteger, NSUInteger,CGFloat, and CFIndex—to provide a consistent means of representing values in 32- and 64-bit environments. In a 32-bit environment, NSInteger and NSUInteger are defined as int and unsigned int, respectively. In 64-bit environments, NSInteger and NSUInteger are defined as long and unsigned long, respectively. To avoid the need to use different printf-style type specifiers depending on the platform, you can use the specifiers shown in Table 2. Note that in some cases you may have to cast the value. Table 2 Format specifiers for data types 类型 定义 建议 NSInteger %ld or %lx Cast the value to long NSUInteger %lu or %lx Cast the value to unsigned long CGFloat %f or %g %f works for floats and doubles when formatting; but see below warning when scanning CFIndex %ld or %lx The same as NSInteger pointer %p %p adds 0x to the beginning of the output. If you don’t want that, use %lx and cast to long. long long %lld or %llx long long is 64-bit on both 32- and 64-bit platforms unsigned long long %llu or %llx unsigned long long is 64-bit on both 32- and 64-bit platforms The following example illustrates the use of %ld to format an NSInteger and the use of a cast. 1 2 NSInteger i = 42; printf(\"%ld\\n\", (long)i); In addition to the considerations mentioned in Table 2, there is one extra case with scanning: you must distinguish the types for float and double. You should use %f for float, %lf for double. If you need to use scanf (or a variant thereof) with CGFloat, switch to double instead, and copy the double to CGFloat. 1 2 3 4 CGFloat imageWidth; double tmp; sscanf (str, \"%lf\", &amp;tmp); imageWidth = tmp; It is important to remember that %lf does not represent CGFloat correctly on either 32- or 64-bit platforms. This is unlike %ld, which works for long in all cases.","title":"[置顶] Objective-c中的占位符,打印BOOL类型数据"},{"content":"  FBReaderJ  FBReaderJ用于Android平台的电子书阅读器，它支持多种电子书籍格式包括：oeb、ePub和fb2。此外还支持直接读取zip、tar和gzip等压缩文档。 更多FBReaderJ信息   Angle  Angle是一款专为Android平台设计的，适合快速开发的2D游戏引擎，基于OpenGL ES技术开发。该引擎全部用Java代码编写，并且可以根据自己的需要替换里面的实现。 更多Angle信息   android-shuffle  android-shuffle是一个GTD（Getting Things Done）个人备忘记事本。 更多android-shuffle信息   Open GPS Tracker  GPSTracker是一个能够使用Android地图记录你的驾车或旅行路线的项目，出发前打开软件选择开始记录，你所经过的路线就会实时显示在地图上，同时还会显示当前的行驶速度。程序会按用户自己设置的标题自动存路线留做日后查看，也可以把路线分享给朋友。GPSTracker项目是一个Map方面的完整应用，包括两个主要组成部分，第一部分是一个收集和存储GPS追踪数据的系统服务，第二部分是Map Activity控制跟踪数据并在地图上显示提供接口。GPSTracker项目用到了osmdroid项目的部分功能，其中OpenStreetMap是一个可供自由编辑的世界地图，允许您查看，编辑或者使用世界各地的地理数据来帮助您。 更多Open GPS Tracker信息   Rokon  Rokon是一个强大、可扩展、灵活的Android 2D游戏引擎，基于OpenGL ES技术开发，物理引擎为Box2D，因此能够实现一些较为复杂的物理效果，有人将它称为Cocos2d-iPhone引擎的Android版（因为业务逻辑和编码风格上也确实很像）。  ）。 更多Rokon信息   LGame  LGame是一款国人开发的Java游戏引擎，有Android及PC(J2SE)两个开发版本。其底 层绘图器LGrpaphics封装有J2SE以及J2ME提供的全部Graphics API（PC版采用Graphics2D封装，Android版采用Canvas模拟实现），所以能够将J2SE或J2ME开发经验直接套用其中，两版本 间主要代码能够相互移植。Android版内置有Admob接口，可以不必配置XML直接硬编码Admob广告信息。该引擎除了基本的音效、图形、物理、精灵等常用组件以外，也内置有Ioc、xml、http等常用Java组件的封装，代价是jar体积较为庞大，PC版 已突破1.2MB，Android版有所简化也在500KB左右。此外，该引擎还内置有按照1:1实现的J2ME精灵类及相关组件，可以将绝大多数 J2ME游戏平移到Android或PC版中。 更多LGame信息   OpenIntents  通过\"Intents\"，Android给连接软件和动态替换组件提供了优秀的基础。Google定义了一批intents（如：打电话啊，联系人清单上选择一个联系人，打开浏览器，电池更换的时候提供提示，等等，详细清单请看：available intents和intent class) 但是任何程序可以自由定义额外的intents和content-providers。我们可以很容易的联想到独立开发的程序（比如在这次的比赛中）极少有可能会和新定义的intents和接口良好的一起工作。 我们这个项目的目标是收集很可能在多个项目中都有用的想法（而且很可能已经被其他独立程序员实现了），定义一批比较合理且扩展性比较好的一批intents和接口，提供基础但稳定有效的实现，可以被其他Android程序所应用的，特别是其他参加比赛的程序员们。OpenIntents本身也会参加这次的比赛。我们提供小的样品程序来演示OpenIntents的用法和特性。 因为我们专注于经常被使用到的那些intents，Google也很可能在不久的将来提供他们自己的标准intents（比如关于日历的。。。）当那个发生的时候，我们会提供透明的接口来直接呼叫Google的实现方法，而你已有的程序可以直接使用Google的新功能而不需要改变任何东西。而且，由于你的程序在设计初期就是已经支持intents的了，当Google的intents出来的时候，你可以很方便的直接他们的intents。还有可能的是Google可能会借用一些OpenIntents开发的intents。无论如何，如果你的程序使用OpenIntents，在和其他使用OpenIntents程序提供互相支持的同时，你会得到额外的附加值，从而全面增强用户体验。  更多OpenIntents信息   android-bluetooth  非常官方Android Bluetooth API支持远程设备扫描、远程设备配对，服务发现（SDP）和客户端RFCOMM串行连接。 更多android-bluetooth信息   Android apktool  Android apktool是一个用来处理APK文件的工具,可以对APK进行反编译生成程序的源代码和图片、XML配置、语言资源等文件,也可以添加新的功能到APK文件中。用该工具来汉化Android软件然后重新打包发布是相当简单的。 更多Android apktool信息   quake2android  quake2android是一个将《雷神之锤2》（Quake2）游戏移植到Android平台上的开源项目。支持谷歌Nexus One，三星Galaxy S，摩托罗拉Droid X等手机。 更多quake2android信息   AndEngine  AndEngine是一个开源的，基于OpenGL实现的Android 2D游戏引擎。这里提供一些基于AndEngine实现的示例。 更多AndEngine信息   android-opencv  android-opencv是一个将OpenCV移到Android手机平台的开源项目，该项目使用OpenCV最新的一个分枝并利用一个改良过的Android NDK进行构建。 更多android-opencv信息   android-dalvik-vm-on-java   android-dalvik-vm-on-java该项目的目标是开发一个采用Java实现的Android Dalvik虚拟机。目的是为了学习Dalvik VM的思想和架构。当前支持Dalvik可执行文件格式（.dex），完整的Dalvik指令系统，J2ME CLDC API，多线程（包括同步阻塞，等待和通知）。 更多android-dalvik-vm-on-java 信息   Android PC_BCR  Android PC_BCR让你能够使用你的Android手机做为PC机的外围条形码扫描仪。扫描的条形码将通过WiFi网络连接传PC机中。这个开源项目由多个组件组成，在手机设备上PC_BCR使用ZXing扫描仪器来扫描条形码，然后程序通过网络传到PC中，PC中有专门的PC_BCR程序接收。 更多Android PC_BCR信息   android-sms  android-sms能够将Android SMS短信备份到Gmail中的Android开源程序。 更多android-sms信息   jPCT-AE  jPCT-AE是一个将jPCT移植至Android平台上3D图形引擎。 更多jPCT-AE信息   AndTweet  AndTweet是一个轻量级Twitter客户端，支持利用触摸和键盘进行快速操作。 收录时间：2010-09-23 19:38:14 更多AndTweet信息   android-smspopup   android-smspopup这个Android应用程序能够拦截收到的短消息并在一个弹出框中显示消息内容和联系人头像。此外还可以自定义LED颜色，振动模式，当第一次提醒显示没有看到时会重复提醒用户哪些信息没有看过。 收录时间：2010-09-23 19:33:11 更多android-smspopup 信息   MyTracks  My Tracks能够记录你在户外活动的GPS轨迹并实时显示时间，速度，距离和海拔等信息。还可以将这些信息上传至Google Spreadsheets并在Google My Maps中显示。 收录时间：2010-09-23 19:23:11 更多MyTracks信息   i-jetty  i-jetty是一个将开源Web容器Jetty移植到Google Android手机平台上的开源项目。让你可以在手机上运行现有的Web应用。 收录时间：2010-10-08 21:51:44 更多i-jetty信息   webOdroid  webOdroid这个开源项目提供了一组完整的工具，能够根据现有网站创建一个Android应用程序。它提供的特性包括： 一个功能齐全的RSS浏览器 能够显示文章列表的ListView或GridView控件。 提供易于定制的模板 在网站上执行远程搜索 根据文章标题提供搜索建议 异步下载和缓存RSS供稿和图片 动态抽取和裁剪文章的图片 通过一个专用的Joomla组件能够集成Joomla网站的搜索功能 收录时间：2010-10-21 23:41:43 更多webOdroid信息   android-json-rpc  android-json-rpc是一个在android程序中使用的JSON-RPC客户端类库。它提供了一个简单的API来执行JSON-RPC服务调用。 收录时间：2010-10-31 21:41:35 更多android-json-rpc信息   BikeRoute  BikeRoute是一个Android应用程序提供基于GPS线路计划和定位功能。支持A到B路径规划，附近的单车停放处的位置，一步一步的指示，路线图，卫星导航等功能。 收录时间：2010-11-05 23:56:37 更多BikeRoute信息   Andorid PDF Viewer  Andorid PDF Viewer是一个运行在ANDROID手机上的PDF文件查看器。它是pdf-rendere：https://pdf-renderer.dev.java.net/的一个移植实现。 收录时间：2010-11-15 18:00:32 更多Andorid PDF Viewer信息   Spring Android  Spring Android 是Spring框架的扩展，用于简化 Android 本地应用程序的开发。 收录时间：2010-11-21 17:04:59 更多Spring Android信息   AchartEngine  AChartEngine是一个针对Android程序开发的开源图表生成类库。支持以下几种图表类型： 折线图 区域图 散点图 time chart 柱状图 饼状图 bubble chart doughnut chart range (high-low) bar chart 收录时间：2010-12-06 08:49:40 更多AchartEngine信息   Opencore  Opencore是google联合packetvideo推出的多媒体开源框架，其中的h.264解码器在目前所有的开源h.264解码器中最好的，在win32和armv4上测试通过，性能好很多，大概提升20%! OpenCore的另外一个常用的称呼是PacketVideo，它是Android的多媒体核心。在防站的过程中，PacketVideo是一家 公司的 名称，而OpenCore是这套多媒体框架的软件层的名称。在Android的开发者中间，二者的含义基本相同。对比Android的其它程序 库，OpenCore的代码非常庞大，它是一个基于C++的实现，定义了全功能的操作系统移植层，各种基本的功能均被封装成类的形式，各层次之间的接口多 使用继承等方式。 OpenCore是一个多媒体的框架，从宏观上来看，它主要包含了两大方面的内容：     * PVPlayer：提供媒体播放器的功能，完成各种音频（Audio）、视频（Video）流的回放（Playback）功能     * PVAuthor：提供媒体流记录的功能，完成各种音频（Audio）、视频（Video）流的以及静态图像捕获功能 收录时间：2011-01-03 16:36:22 更多Opencore信息   Android Tools  Android Tools是一个轻量级IDE用于创建、构建、安装和测试Android应用程序。可方便的通过点击访问Android的命令、目录和文件。它还提供一个内置的文本编辑器。Android Tools能够让学习和使用Android变得更加简便。 收录时间：2011-01-12 08:53:23 更多Android Tools信息   android-binding  android-binding这个开源项目提供了一个框架用于将android view widgets与数据模型相绑定。帮助您在android应用程序中实现MVC或MVVM模式。 收录时间：2011-02-11 08:46:09 更多android-binding信息   Robotium  Robotium是一个测试框架能够方便你为Android应用程序编写强大、健壮的自动黑盒测试用例。利用Robotium的支持，用例开发人员能够编写功能、系统和验收测试方案Robotium支持Activities、Dialogs、Toasts、Menus和Context Menus。 收录时间：2011-02-24 20:37:52 更多Robotium信息","title":"2013年Android 开源框架和开源的代码汇总"},{"content":"还在苦恼于如何发布应用到Android市场吗？请跟随本教程，本教程将教你通过几个简单步骤完成发布应用到Android市场。 虽然步骤很简单，但也有相当多的地方是非常有用的。你可能需要一位非常优秀的平面设计师，帮你创建一个引人注目的图标，并显示在市场的网站和应用程序上。同时，本教程将告诉你在发布过程中存在的一些不确定性因素。 第0步：创建一个应用程序 如果你还没有一个应用程序，显然你需要先创建一个。那么创建一个完整的应用程序，就要看你的想法和技能水平了，这可能需要花几周，甚至数年才能完成！呵呵，先开个玩笑。:) 第1步：上传签名的APK 如果你有签名的APK，请到Android市场发布网站。如果你还没有，你需要先将APK签名。如果这是你第一次发布，你还需要支付25美元，申请一个Google钱包帐户来收钱。   现在，请找到上传App的按钮，然后点击它： 此时，你会看到一个上传新APK的对话框，然后选择你之前准备好的APk文件。 第2步：上传宣传媒体 Android市场可以使用多张图片来显示你的应用程序，并展示给用户看。用户在下载你的app之前，首先看到是这些图片。所以精心设计你的图片，会让你app有更多的下载量。这时候，好的营销人员和设计师将会派上用场。 Android市场需要两张截图。理想的情况下，它们应该是从一个高分辨率的设备上截的图。无论如何，这些必须是适用在常见屏幕分辨率的设备上。它们应该是一张完整的截图，不能有美术处理，也不能有边框。   Android市场还需要高分辨率版本的应用程序图标。这是一个512×512像素的应用程序启动图标。   Android市场允许你提供一个小的宣传图形。当应用程序有最新版本的时候，谷歌可能会在任何地方使用它。虽然这是可选的，还是强烈推荐。图形不能包含边框。   Android市场同样可以使用一个更大的图形。这是1024×500的图片，假设它有50个像素的边缘，这样的主要内容应该是在924×400像素的中心方块；也假设图像会按比例缩小，所以它的图形元素要大。虽然这也是可选的，但我们也建议使用它。如果没有这个特色图片，谷歌将不会显示你的应用程序在所有可能的放置的位置。 Android市场可以链接到YouTube视频，展示你的app。这也是可选的，但给你提供了一个有效的视频广告的机会。你可以炫耀你的app所有很酷的功能，并解释为什么值得人们去下载它。影片应尽量短 - 不要浪费客户的时间。 第3步：填写应用程序信息 接下来，你需要填写一些应用程序的信息。这是非常重要的一步，早期用户都是通过这些了解你的app，然后决定是否下载。后期，评论会变得非常重要了。 这些信息当中，有一项是提供多语言。如果你有提供翻译，这是最好的。虽然这里有一个选项是自动翻译，毕竟是机器翻译，并不那么完美，但总比没有的好。因为不是所有人在Android Market上浏览时，他们都有翻译工具。   然后，你需要在这里填写应用程序的名称，在30个字符之内；以及应用程序的描述，在4000个字符之内。   更新说明是用来突出最新版本有什么不同的。我们建议尽可能多的在500个字符之内。因为不是所有的用户都会去升级版本，以及阅读更新说明。 宣传文字要非常短、最大80个字符，它会在用户看到完整的描述之前显示。确保它简洁而有力量。 最后，设置你的应用程序的类型（在应用和游戏两者中选择）。然后设置一个合适的分类。如果你不确定，请浏览其他发布商发布跟你一样的应用程序在哪个分类中。这是特别重要的一点，在我看来分类不是很多(目前只有6个)。 第4步：设置发布选项 下面是关于内容保护，适用年龄段，国家和定价的选项。   刚开始,不要使用拷贝保护功能。而使用授权服务，这有点复杂，但比起支付应用好多了。 对于定价，要么选择免费，要么选择付费(如果选择永久免费，后期是不能改成付费的)。然后选择国家，每一个国家都可以设定价格(或选择自动填充)。你也可以随意的排除一些国家。这可能会违反要求我们向这些国家出售应用的法律。 第5步：填写联系方式和同意条款 此时，你必须填写你的联系方式。这样用户就可以联系到你。每一个应用程序可以有不同的联系方式。也可以通过你的app发送反馈信息到这里。   最后，你必须告诉谷歌，你的申请符合他们的条款，遵守美国出口的法律。没关系，只要你的应用在市场上上架，它都必须遵守美国出口的法律。 第6步：激活APK 请切换到“APK files”选项卡，然后点击保存按钮(在右上角处)。请确保在你点击发布按钮之前，至少有一个APK是激活状态。   当你做完这些。现在就到了最后一步，也是最激动人心的一步… 第7步：发布你的应用 现在，当所有的信息都已填好，所有的图片都已上传，APK也是激活的···那你还在等什么？赶紧发布吧！   不用担心那个错误的超链接显示，只要它后面没有带正数，就是发布成功的状态。 发布很快，要不了一分钟，你就可以直接用包名连接到你的市场了，像这样： https://market.android.com/details?id=com.mamlambo.livewallpaper.stars 总结 现在你已经知道发布应用到Android市场的步骤，这对你会是很有用的。只要完成了你的app，下一步就可以发布了。 去吧。尝试发布一个你的应用程序到Android市场。","title":"Android 发布应用到市场"},{"content":"安卓Android和Java语言的异同、关系和区别，安卓Android是一种以Linux为基础的开放源码操作系统，主要使用于便携设备。2011年第一季度，安卓在全球的市场份额首次超过塞班系统，跃居全球第一。 2012年2月数据，安卓占据全球智能手机操作系统市场52.5%的份额，中国市场占有率为68.4%。自google收购安卓之后，安卓开发者更是风生水起。安卓开发前景看好，安卓手机市场大卖，安卓应用人气火爆，安卓程序员也待遇渐长。所以，越来越多的大学生开始选择学习安卓，学习安卓倒是个好方向，可也不能盲目，首先要理解安卓的特点，明确自己的学习方向。那么学习安卓需要掌握些什么呢?  Java是现在人们热谈的话题，现在学习java的人也是越来越多。随着市场的需求，Java培训机构也是遍地开花，网络上的各种java教程也是大量出现，这足以让我们认识到java的火热程度。许多做安卓的程序员以前都是做JAVA的，甚至还有不少程序员是即做JAVA又做安卓，所以，如果想做安卓应用的话，不妨先学些JAVA. 　　安卓系统是基于linux为核心的，而linux是用c语言和少量汇编语言写成的，如果你想研究安卓，就去学c语言吧。现在大学里面和计算机相关的专业甚至理工类专业一般都会开设C语言课程，只是很多同学在大学期间并没有好好学习，如果对它掌握的不太好或者很久没用了，建议先从将其好好复习一下，将其基本的语法再好好回顾一下，最好能搭建一个环境来运行、调试它。如果没有学过，不妨也提前学习一下。   　　安卓上得应用大多是用java编写的，如果你想编写手机游戏和应用，就去学java吧。安卓应用程序开发是以Java语言为基础的，所以没有扎实的Java基础知识，只是机械的照抄别人的代码，是没有任何意义的。建议在安卓课程前期的java学习阶段中，需要用心的学好。 Java是现在人们热谈的话题，现在学习java的人也是越来越多。随着市场的需求，Java培训机构也是遍地开花，网络上的各种java教程也是大量出现，这足以让我们认识到java的火热程度。许多做安卓的程序员以前都是做JAVA的，甚至还有不少程序员是即做JAVA又做安卓，所以，如果想做安卓应用的话，不妨先学些JAVA.   Android 虽然使用Java语言 作为开发工具 ，但是在实际开发中发现，还是与Java SDK 有一些不同的地方。Android SDK引用了大部分的Java SDK，少数部分被Android SDK抛弃，比如说界面部分，java.awt package除了java.awt.font被引用外，其他都被抛弃，在Android平台开发中不能使用。将Java 游戏 移植到Android平台的过程中，Android  SDK与Java SDK的区别是很需要注意的地方。现将Android SDK中引用自Java SDK的package列举如下，并简要说明这些Java包的功能： 包 描述 java.awt.font 提供与字体相关的类和接口 。 java.beans 包含与开发 beans 有关的类，即基于  JavaBeansTM 架构 的组件 。 java.io 通过数据流、序列化和文件系统提供系统输入和输出。 java.lang 提供利用 Java 编程语言进行程序设计的基础类。 java.math 提供用于执行任意精度整数算法 (BigInteger) 和任意精度小数算法 (BigDecimal) 的类。 java.net 为实现网络应用程序提供类。 java.nio 定义作为数据容器的缓冲区，并提供其他 NIO 包的概述。 java.security 为安全 框架 提供类和接口。 java.sql 提供使用 JavaTM 编程语言访问并处理存储 在数据源（通常是一个关系数据库）中的数据的  API 。 java.text 提供以与自然语言无关的方式来处理文本、日期、数字和消息的类和接口。 java.util 包含集合框架、遗留的  collection 类、事件模型 、日期和时间设施、国际化和各种实用工具类（字符串标记生成器、随机数生成器和位数组）。 Java扩展包 javax.crypto 为  cryptographic（加密）操作提供类和接口。 javax.microedition.khronos.egl javax.microedition.khronos.opengles                           Java Binding for the OpenGL ES(R) API javax.net 提供用于网络应用程序的类。 javax.security.auth 此包提供用于进行身份验证 和授权的框架。 javax.security.auth.callback 此包提供与应用程序进行交互所必需的类，以便检索信息（例如，包括用户名和密码的身份验证数据）或显示信息（例如，错误和警告消息）。 javax.security.auth.login 此包提供可插入的身份验证框架。 javax.security.auth.x500 此包包含应该用来在 Subject 中存储 X500 Principal 和 X500 Private Crendentials 的类。 javax.security.cert 为公钥证书类。 javax.sql 为通过 JavaTM 编程语言进行服务器端数据源访问和处理提供 API。 javax.xml 根据 XML 规范定义核心 XML 常量和功能。 Android SDK引用了Java SDK  80%的package，这些package也是在实际开发中经常使用的，如果需要了解数据包的详细信息，请点击各个包的链接。 以下展示了Android SDK 中一些与网络有关的package。 Android  SDK 网络包 包 描述 java.net 提供与联网有关的类，包括流和数据包（datagram）sockets、Internet 协议和常见 HTTP 处理。该包是一个多功能网络资源。有经验的 Java 开发人员可以立即使用这个熟悉的包创建应用程序。 java.io 虽然没有提供显式的联网功能，但是仍然非常重要。该包中的类由其他 Java 包中提供的 socket 和连接使用。它们还用于与本地文件（在与网络进行交互时会经常出现）的交互。 java.nio 包含表示特定数据类型的缓冲区的类。适合用于两个基于 Java 语言的端点之间的通信。 org.apache.* 表示许多为 HTTP 通信提供精确控制和功能的包。可以将 Apache 视为流行的开源 Web 服务器。 android.net 除核心  java.net.* 类以外，包含额外的网络访问 socket。该包包括 URI 类，后者频繁用于 Android 应用程序开发，而不仅仅是传统的联网方面。 android.net.http 包含处理 SSL 证书的类。 android.net.wifi 包含在 Android 平台上管理有关 WiFi（802.11 无线 Ethernet）所有方面的类。并不是所有设备都配备了 WiFi 功能，特别是 Android 在 Motorola 和 LG 等手机制 造商的 “翻盖手机” 领域获得了成功。 android.telephony.gsm 包含用于管理和发送  SMS（文本）消息的类。一段时间后，可能会引入额外的包来来为非 GSM 网络提供类似的功能，比如 CDMA 或 android.telephony.cdma 等网络。     Android开发环境搭建所需资源、安装和配置步骤图解        Android海量源码、教程与资料   数字电视接口规范大全（行业标准）                      程序员必备：英语口语学习教程大全  20本Linux电子书学习教程                    2013年25家IT高科技公司薪酬排行榜   2013年Android平台8大预测                   优秀Android开发人员必须注意的10个误区  Android开发应该掌握的28大内容和10大建议      成为“Android高手”的6个境界  90后就业“钱景”分析:IT行业仍是最佳选择       90后就业“钱景”:IT仍是最佳选择 -------------------------------------------------------------------------------------------------------------- 终生受益的43个健康常识--值得珍藏                           面试如何着装：不同职位穿着大不同      2013年国内就业率最高的50个本科专业排名              女生面试如何着装及禁忌    50个“最有钱景专业”的毕业生年薪一览表               毕业后头5年决定你的一生  千万别熬夜:身体器官晚上工作时间表一览                  90后就业“钱景”:IT仍是最佳选择     --------------------------------------------------------------------------------------------------------------  211工程大学最新名单(共112所)                              985工程大学最新名单(共39所)  中国“国家实验室”最新名单（共20所）                 “特色985”大学最新名单（共29所）  2013年国内工科大学排名100强名单                          2013年中国大学580强排行榜  女孩教你追女孩的终极技巧                                       2013年世界各国人均GDP排名  中国各省市面积和人口最新排名                                世界各国国土面积和人口排名  经典英语口语学习教程和资料集合大全                     2013年25家IT高科技公司薪酬排行榜  --------------------------------------------------------------------------------------------------------------  ","title":"Android和Java的关系和区别"},{"content":"Git学习笔记（2）--Git基本操作 Gitgit 首先 介绍一本Git的书，<<Pro Git>>，此书的网络版是可以免费获取的，是一本非常好的介绍Git的书籍。 然后，介绍一下我的运行环境，是ubuntu10.10，Git版本是1.7.1。 现在，进入正题介绍一下基本的Git命令，通过这些命令，你可以搭建一个单机版的Git库，开始你的工作，并且，在你是用Git管理你的软件时，你绝大部分时间使用的命令就是这几个。 这些命令有： git init          初始化Git库 git add           向Git库提交文件修改（包括创建文件） git commit        基于此分支提交一个更改 git reset         去除目标提交之后的一切提交记录（世界清净级大招） git log           查看当前分支下的提交记录 git status        查看当前状态 git checkout      切换分支或回到某次提交 git branch        创建分支，查看分支等 git merge         合并目标分支到当前分支 从现在开始，我们一一实践这些命令 首先我们创建文件夹GitTest #mkdir GitTest #cd GitTest 然后创建文件readme，test并在test输入字符串“1” #touch readme #echo \"1\">test 接下来，执行一下三个操作 #git init                          创建git仓库 #git config user.name yym          配置作者名 #git config user.email yym@**.com  配置email #git add .                         向git仓库中添加文件（.表示当前目录及其子目录下所有文件） #git commit -m \"initial\"           进行第一次提交 现在，分别运行三个命令 #ls -a .  ..  .git  readme  test 如果你看到.git恭喜你，你已经有了一个Git仓库，如果你没看到，抱歉，请重新安装Git。 #git status # On branch master nothing to commit (working directory clean) 翻译一下，你在分支master上，没什么可以提交的（工作文件夹很干净） 这里有两个概念需要解释，都很重要：分支，干净 1.branch分支是Git的一个重要概念，可以说Git是以这个概念为核心设计的。你可以把分支理解为你当前的工作发展方向，你的程序所在的位置，你的未来。一般来说，会有如下分支稳定版本bug修复分支，程序发展分支1～n，特性分支，发展分支，主分支等等。分支的管理和权限分配构成里项目的组织结构，这就像数据结构之于算法。 关于分支的妙用，这里推荐一个篇文章 《Git分支管理是一门艺术》 2.干净，这是一个美妙的词。干净代表你的程序没有什么需要提交的修改，意味着你完成了这个阶段性成果，当然这是在你的程序是正确的情况下。 #git log commit 5b1ac4cff1bc7d91622ba6d5f733db1d2ba2af0f Author: yym <yym@**.com> Date:   Wed Sep 28 17:56:06 2011 +0800     initial commit代表提交，后面的hash值是这次提交的唯一标志，接下来是作者与时间，然后就是这次提交的名称。简洁直观 接下来，我们修改readme文件及test文件 #echo I\" create this dir for learning Git\">>readme #echo “test”>test 注意>>和>的区别 创建文件notrack #touch notrack 然后我们输入 #git status # On branch master # Changed but not updated: #   (use \"git add <file>...\" to update what will be committed) #   (use \"git checkout -- <file>...\" to discard changes in working directory) # # modified:   readme # modified:   test # # Untracked files: #   (use \"git add <file>...\" to include in what will be committed) # # notrack no changes added to commit (use \"git add\" and/or \"git commit -a\") 很好，我们发现，我们还在master分支上（当然！），然后，我们发现readme与test处于修改未更新状态，notrack处于未追踪状态。这是什么意思呢？ 要回答这个问题，就需要介绍一个很要的概念。在Git的世界中，文件被分为3类： 1.未追踪，也就是说在此文件夹下，但是未被Git库追踪。 2.未修改，这代表这个文件未被改变 3.修改未更新，这就是上面的状态了 4.已暂存，处于这种状态，那就是等着提交（commit）了 现在我们需要用到add命令，将修改提交打Git库中。 #git add readme # On branch master # Changes to be committed: #   (use \"git reset HEAD <file>...\" to unstage) # # modified:   readme # # Changed but not updated: #   (use \"git add <file>...\" to update what will be committed) #   (use \"git checkout -- <file>...\" to discard changes in working directory) # # modified:   test # # Untracked files: #   (use \"git add <file>...\" to include in what will be committed) # # notrack 此时，你就可以将修改提交到Git库中，当然，你也可以将test文件的修改也暂存一起提交。这里我只提交单个文件的修改 #git commit -m \"2nd commit\" #git status # On branch master # Changed but not updated: #   (use \"git add <file>...\" to update what will be committed) #   (use \"git checkout -- <file>...\" to discard changes in working directory) # # modified:   test # # Untracked files: #   (use \"git add <file>...\" to include in what will be committed) # # notrack no changes added to commit (use \"git add\" and/or \"git commit -a\") 可以看到，刚才的readme文件的修改已经被提交了 #git log commit ae79a590fa13673a584bc5cea08eaa260a7dd473 Author: yym <yym@**.com> Date:   Wed Sep 28 18:10:48 2011 +0800     2nd commit commit 52a2d3bb92cc54a69f43a6118ca3ee1d1b520156 Author: yym <yym@**.com> Date:   Wed Sep 28 18:01:29 2011 +0800     initial 这是提交记录，就不多说了。现在，我们把test文件也提交了。 #git add test #git commit -m \"3rd commit\" #git log commit b8d7f73a84944bc38a36990512ab5d9ceda77fef Author: yym <yym@**.com> Date:   Thu Sep 29 09:34:51 2011 +0800     3rd commit commit ae79a590fa13673a584bc5cea08eaa260a7dd473 Author: yym <yym@**.com> Date:   Wed Sep 28 18:10:48 2011 +0800     2nd commit commit 52a2d3bb92cc54a69f43a6118ca3ee1d1b520156 Author: yym <yym@**.com> Date:   Wed Sep 28 18:01:29 2011 +0800     initial 突然，你想回退到2nd commit，想看看当时test文件中的内容。 你可以使用命令 #git checkout ae79a590fa13673a584bc5cea08eaa260a7dd473 #cat 1 1 看完test之前的内容后，你觉得还是第三次提交的内容比较合适，又想回到第三次提交，同样的，你可以 #git checkout  b8d7 #cat test test 你可以不必打出所有位数，只要你保证他是独一无二的，但是你至少需要打出四位。 好吧，不要觉得我是个反复无常的人，现在我有觉得3rd commit完全是多余，我想回到2nd，彻底丢弃之后的内容。只需输入如下命令 #git reset --hard ae79 #git log commit ae79a590fa13673a584bc5cea08eaa260a7dd473 Author: yym <yym@**.com> Date:   Wed Sep 28 18:10:48 2011 +0800     2nd commit commit 52a2d3bb92cc54a69f43a6118ca3ee1d1b520156 Author: yym <yym@**.com> Date:   Wed Sep 28 18:01:29 2011 +0800     initial 最后，觉得每次都要add所有修改文件太麻烦了？ ok git commit -a -m \"CommitName\" 你可以使用如上命令跳过暂存区域，或者你也可以把它看作是自动add已修改文件 关于Git的一部分基本操作就介绍到这里，下文会介绍Git的另一部分常用操作。","title":"Git学习笔记（2）--Git基本操作"},{"content":"activity_1.xml如下: <?xml version=\"1.0\" encoding=\"utf-8\"?><RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\"    >        <TextView         android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\"        android:layout_centerInParent=\"true\"        android:text=\"Activity 1\"        android:textSize=\"50sp\"    />      <cn.com.BottomMenuView        android:layout_width=\"fill_parent\"        android:layout_height=\"70dip\"        android:layout_alignParentBottom=\"true\"     /><\/RelativeLayout> activity_2.xml如下: <?xml version=\"1.0\" encoding=\"utf-8\"?><RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\"    >        <TextView         android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\"        android:layout_centerInParent=\"true\"        android:text=\"Activity 2\"        android:textSize=\"50sp\"    />      <cn.com.BottomMenuView        android:layout_width=\"fill_parent\"        android:layout_height=\"70dip\"        android:layout_alignParentBottom=\"true\"     /><\/RelativeLayout>   activity_3.xml如下: <?xml version=\"1.0\" encoding=\"utf-8\"?><RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\"    >        <TextView         android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\"        android:layout_centerInParent=\"true\"        android:text=\"Activity 3\"        android:textSize=\"50sp\"    />      <cn.com.BottomMenuView        android:layout_width=\"fill_parent\"        android:layout_height=\"70dip\"        android:layout_alignParentBottom=\"true\"     /><\/RelativeLayout> activity_4.xml如下: <?xml version=\"1.0\" encoding=\"utf-8\"?><RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\"    >        <TextView         android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\"        android:layout_centerInParent=\"true\"        android:text=\"Activity 4\"        android:textSize=\"50sp\"    />      <cn.com.BottomMenuView        android:layout_width=\"fill_parent\"        android:layout_height=\"70dip\"        android:layout_alignParentBottom=\"true\"     /><\/RelativeLayout> bottommenu.xml如下: <?xml version=\"1.0\" encoding=\"utf-8\"?><LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    android:layout_width=\"match_parent\"    android:layout_height=\"70dip\"    android:orientation=\"horizontal\" >    <LinearLayout         android:id=\"@+id/menu_LinearLayout1\"        android:layout_width=\"match_parent\"        android:layout_height=\"wrap_content\"        android:clickable=\"true\"        android:background=\"@drawable/photo1\"        android:layout_weight=\"1\"    />    <LinearLayout         android:id=\"@+id/menu_LinearLayout2\"        android:layout_width=\"match_parent\"        android:layout_height=\"wrap_content\"        android:clickable=\"true\"        android:background=\"@drawable/photo2\"        android:layout_weight=\"1\"    />    <LinearLayout         android:id=\"@+id/menu_LinearLayout3\"        android:layout_width=\"match_parent\"        android:layout_height=\"wrap_content\"        android:clickable=\"true\"        android:background=\"@drawable/photo3\"        android:layout_weight=\"1\"    />    <LinearLayout         android:id=\"@+id/menu_LinearLayout4\"        android:layout_width=\"match_parent\"        android:layout_height=\"wrap_content\"        android:clickable=\"true\"        android:background=\"@drawable/photo4\"        android:layout_weight=\"1\"    />    <\/LinearLayout> manifest.xml如下: <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"    package=\"cn.com\"    android:versionCode=\"1\"    android:versionName=\"1.0\" >    <uses-sdk        android:minSdkVersion=\"8\"        android:targetSdkVersion=\"15\" />    <application        android:icon=\"@drawable/ic_launcher\"        android:label=\"@string/app_name\"        android:theme=\"@style/AppTheme\" >         <activity            android:name=\".Activity1\">            <intent-filter>                <action android:name=\"android.intent.action.MAIN\" />                <category android:name=\"android.intent.category.LAUNCHER\" />            <\/intent-filter>         <\/activity>          <activity            android:name=\".Activity2\">         <\/activity>          <activity            android:name=\".Activity3\">         <\/activity>          <activity            android:name=\".Activity4\">         <\/activity>    <\/application><\/manifest>      ","title":"自定义View仿TabHost的实现(二)"},{"content":"Activity1如下: package cn.com;import android.app.Activity;import android.os.Bundle;public class Activity1 extends Activity{     @Override    protected void onCreate(Bundle savedInstanceState) {    \tsuper.onCreate(savedInstanceState);    \t//设置setTitle应该在setTitle之前    \t//否则不起作用    \tsetTitle(\"Activity1\");    \tsetContentView(R.layout.activity_1);    }} Activity2如下: package cn.com;import android.app.Activity;import android.os.Bundle;public class Activity2 extends Activity{     @Override    protected void onCreate(Bundle savedInstanceState) {    \tsuper.onCreate(savedInstanceState);    \t//设置setTitle应该在setTitle之前    \t//否则不起作用    \tsetTitle(\"Activity2\");    \tsetContentView(R.layout.activity_2);    }} Activity3如下: package cn.com;import android.app.Activity;import android.os.Bundle;public class Activity3 extends Activity{     @Override    protected void onCreate(Bundle savedInstanceState) {    \tsuper.onCreate(savedInstanceState);    \t//设置setTitle应该在setTitle之前    \t//否则不起作用    \tsetTitle(\"Activity3\");    \tsetContentView(R.layout.activity_3);    }} Activity4如下: package cn.com;import android.app.Activity;import android.os.Bundle;public class Activity4 extends Activity{     @Override    protected void onCreate(Bundle savedInstanceState) {    \tsuper.onCreate(savedInstanceState);    \t//设置setTitle应该在setTitle之前    \t//否则不起作用    \tsetTitle(\"Activity4\");    \tsetContentView(R.layout.activity_4);    }} BottomMenuView如下: package cn.com;import android.app.Activity;import android.content.Context;import android.content.Intent;import android.util.AttributeSet;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.LinearLayout;//自定义View.仿TabHost的实现public class BottomMenuView extends LinearLayout{\tprivate Context mContext;\tprivate LinearLayout mLinearLayout1;\tprivate LinearLayout mLinearLayout2;\tprivate LinearLayout mLinearLayout3;\tprivate LinearLayout mLinearLayout4;\tprivate String mCurrentActivityTitle;\tprivate final static String ACTIVITY_NAME_1=\"Activity1\";\tprivate final static String ACTIVITY_NAME_2=\"Activity2\";\tprivate final static String ACTIVITY_NAME_3=\"Activity3\";\tprivate final static String ACTIVITY_NAME_4=\"Activity4\";\tpublic BottomMenuView(Context context, AttributeSet attrs) {\t\tsuper(context, attrs);\t\tmContext=context;\t\tinitView();\t}\tprivate void initView(){\t\tView bottomMenuView=\t\tLayoutInflater.from(mContext).inflate(R.layout.bottommenu, null, false);\t\tViewGroup.LayoutParams params=\t\tnew LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.FILL_PARENT);\t\tthis.addView(bottomMenuView,params);\t\t\t\tmLinearLayout1=(LinearLayout)\t\tbottomMenuView.findViewById(R.id.menu_LinearLayout1);\t\tmLinearLayout2=(LinearLayout)\t\tbottomMenuView.findViewById(R.id.menu_LinearLayout2);\t\tmLinearLayout3=(LinearLayout)\t\tbottomMenuView.findViewById(R.id.menu_LinearLayout3);\t\tmLinearLayout4=(LinearLayout)\t\tbottomMenuView.findViewById(R.id.menu_LinearLayout4);\t\t\t\tBottomMenuOnClickListener clickListener=new BottomMenuOnClickListener();\t\tmLinearLayout1.setOnClickListener(clickListener);\t\tmLinearLayout2.setOnClickListener(clickListener);\t\tmLinearLayout3.setOnClickListener(clickListener);\t\tmLinearLayout4.setOnClickListener(clickListener);\t\tsetEveryMenuStatus();\t}\t\t/**\t * \t * 1 在每个menu对应的Activity中设置其Title\t * 2 在此判断当前显示是哪一个Activity.使得\t *   当前Activity对应的Menu不可再次点击.\t */\tprivate void setEveryMenuStatus(){\t\tmCurrentActivityTitle=(String) ((Activity)mContext).getTitle();\t\tif (mCurrentActivityTitle.equals(ACTIVITY_NAME_1)) {\t\t\tmLinearLayout1.setClickable(false);\t\t}else if (mCurrentActivityTitle.equals(ACTIVITY_NAME_2)) {\t\t\tmLinearLayout2.setClickable(false);\t\t}else if (mCurrentActivityTitle.equals(ACTIVITY_NAME_3)) {\t\t\tmLinearLayout3.setClickable(false);\t\t}else if (mCurrentActivityTitle.equals(ACTIVITY_NAME_4)) {\t\t\tmLinearLayout4.setClickable(false);\t\t}\t}\t\tprivate class BottomMenuOnClickListener implements OnClickListener{\t\tpublic void onClick(View v) {\t\t\tswitch (v.getId()) {\t\t\tcase R.id.menu_LinearLayout1:\t\t\t\tIntent intent1=new Intent(mContext, Activity1.class);\t\t\t\tmContext.startActivity(intent1);\t\t\t\tbreak;\t\t\tcase R.id.menu_LinearLayout2:\t\t\t\tIntent intent2=new Intent(mContext, Activity2.class);\t\t\t\tmContext.startActivity(intent2);\t\t\t\tbreak;\t\t\tcase R.id.menu_LinearLayout3:\t\t\t\tIntent intent3=new Intent(mContext, Activity3.class);\t\t\t\tmContext.startActivity(intent3);\t\t\t\tbreak;\t\t\tcase R.id.menu_LinearLayout4:\t\t\t\tIntent intent4=new Intent(mContext, Activity4.class);\t\t\t\tmContext.startActivity(intent4);\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tbreak;\t\t\t}\t\t\t\t\t}\t\t\t}}  ","title":"自定义View仿TabHost的实现(一)"},{"content":"转载请说明出处，谢谢。 原文出处：点击打开链接 今天研究了一下关于layer的anchorPoint问题。 附图： 原文出处：点击打开链接 位置坐标 position＋anchorPoint（左下角0,0原点坐标系）。 要确定一个添加layer的位置，首先确定相对view的position（也可以是自己的position），然后确定anchorPoint 的实际位置可以通过公式计算： 实际位置.x = position.x+layerWidth*(0.5-anchorPoint.x) 实际位置.y = position.y+layerHeight*(0.5-anchorPoint.y) 上图是从网上找来的一张图，方便大家理解。 可以看出，红色点（5,5）为红色框框的位置。确定好红框位置后(使图C点与（5.5）重合)，根据anchorPoint计算出实际需要移动的距离，按住红框的中心（center）移出anchorPoint.x距离（width的百分比），移出anchorPoint.y距离（hight）的百分比，得到的图像便是最后位置了。","title":"锚点(anchorPoint)"},{"content":"最近做一个项目，需要跟服务器连接，所有传出的数据都是json格式的，就需要进行相互之间的转换。在网上找了好多例子，功能都实现了，但都是运用第三方库。有一个特别奇怪的地方就是，在将json格式的数据转换为字典时，导入了一个json包。在向服务器提交数据时，需要将字典封装为json格式，需要导入另外一个包。这就导致问题产生了，两个都是json包，一样的名字，功能却不一样，在同一个工程中就会报错，编译通不过。最后只好另辟蹊径，还好找到了两个相当简单的例子，在这里给大家分享咯： 首先将从服务器获得的json格式的数据转换为nsdictionary,上一篇已经说过，是ios5自带的NSJSon方法，在这里再重复一下： iOS 5加入了NSJSONSerialization类，可以将JSON和Foundation objects相互转换。来看一段图片的代码示例：{\"taken\": \"2011/07/13\",\"width\": \"3072\",\"height\": \"2304\",\"latitude\": \"39.52\",\"longitude\": \"-106.05\",\"url\": \"http://mypictures.com/12345.png\"}解析起来很简单，代码示例：NSError *error = nil;NSData *data = [NSData dataWithContentsOfURL:webServiceURL];NSDictionary *photo = [NSJSONSerializationJSONObjectWithData:dataoptions:NSJSONReadingMutableLeaveserror:&error];NSNumber *width = [photo objectForKey:@\"width\"];NSNumber *height = [photo objectForKey:@\"height\"]; 搞定，现在你就可以对其进行解析了，而不需要任何的第三方库。 接着看怎么把NSDictionary类型的数据转换为json，这个目前没找到ios自带方法，引用了第三方库JSONKit，就两个文件，json.h+.m.导入工程即可 下面就是代码了，仔细看哦，一晃就过了啊 NSString *returnString=[dic JSONString];//dic就是你将要转换成字典，而returnString就是齐刷刷的json数据了当然得导入头文件 #import \"JSONKit.h\" ok，大功告成，功能以基本实现。 在查找资料过程中，也发现一些不错的文章，放在这里供大家一块学习了 JSON 到 NSObject 互相转换","title":"iOS 中字典与json格式的相互转换"},{"content":" 使用XCode的提示功能，只需要记住类的名字及常用的函数就好了，其他的函数可以根据提示来查看，按ESC键可以查看该类的函数          Foundtion框架           Cocoa程序的编写主要要用到两个框架，Foundation和ApplicationKit(UIKit),其中Foundation框架主要定义了一些基础类，而ApplicationKit主要定义了一些用于Mac开发的几面基础类，而IOS的界面开发主要是用UIKit。Foundation框架中的所有类都继承自NSObject，这就是所谓的上帝吧。Foundation主要提供了与图形用户界面没有直接关系的功能的一些类，比如：字符串、数值、容器集合等等相关的类。          1、有关数字对象的处理             把数字包装成数字对象     int age = 24;    BOOL isMarry = NO;    float pi = 3.14f;    //使用类方法，其他的基本数据类型和如下两种方式相同    NSNumber *myAge = [NSNumber numberWithInt:age];    NSNumber *aboutMarry = [NSNumber numberWithBool:isMarry];    //使用初始化方法    NSNumber *aboutPi = [[NSNumber alloc]initWithFloat:pi];             把数字对象再转换成基本数据类型     age = [myAge intValue];    isMarry = [aboutMarry boolValue];    pi = [aboutPi floatValue];          2、字符串的常见应用             由于oc是基于c的，为了区别起见，oc中的字符串必须以@开头，@后引号内的类容为字符串本身内容             NSString对象一旦创建就不能再修改，如果想创建一个可以修改的字符串对象，则使用NSMutableString，这里的NSS他ring好比java中的String类，而NSMutableString类好比java中StringBuffer                 //创建一个字符串        //方法一        NSString *name = @\"Jim Green\";        //方法二        //创建一个空字符串        NSString *name1 = [[NSString alloc]init];//实例方法                //创建非空字符串        NSString *name3 = [[NSString alloc]initWithString:@\"Jim Green\"];                       //有关创建格式化符字符串        NSString *myself = [[NSString alloc]initWithFormat:@\"我是%@,今年%d岁,知道PI的值是%f\",name3,age,pi]; 有关字符串的比较：  //以下打印结果为相等       NSString *str1 = @\"niao\";        NSString *str2 = @\"niao\";                if (str1 == str2) {                        NSLog(@\"相等\");        }else            NSLog(@\"不相等\");                if ([str1 isEqualToString: str2]) {                        NSLog(@\"相等\");        }else            NSLog(@\"不相等\");               //此处的打印结果也相等(在常量区创建)        NSString *str3 = [[NSString alloc]initWithString:@\"ge\"];        NSString *str4 = [[NSString alloc]initWithString:@\"ge\"];                if (str3 == str4) {                        NSLog(@\"相等\");        }else            NSLog(@\"不相等\");                //此处打印也相等        if ([str3 isEqualToString: str4]) {                        NSLog(@\"相等\");        }else            NSLog(@\"不相等\");                //********************************************************分界线         //在堆区创建        NSString *str5 = [NSString stringWithFormat:@\"ni%d\",5];        NSString *str6 = [NSString stringWithFormat:@\"ni%d\",5];                //此处打印不相等        if (str5 == str6) {         NSLog(@\"5相等6\");         }else             NSLog(@\"5不相等6\");         //此处打印也相等        if ([str5 isEqualToString: str6]) {            NSLog(@\"5相等6\");         }else            NSLog(@\"5不相等6\");          分界线以上的无论是==还是isEqualToString都是相等，分界线以下的==打印不相等，isEqualToString打印的是相等，这里用isEqualToString比较相等很容易理解,关于用等号比较          那是因为用==比较的是对象指针的地址，而不是对象本身          而分界线以上的对象都是在敞亮区创建的，所以用==比较是相等的          而分解先以下的是在堆区创建的，所以用==比较是不相等的          str5与str6是在堆区创建了两个对象，所以对象的地址是不同的所以用==比较不同，而对象的内容是相同的，所以isEqualToString比较相同。  比较字符串的大小 NSString *str7 = @\"a\";        NSString *str8 = @\"b\";        NSString * str9 = @\"A\";                NSLog(@\"比较结果为：%@\",[str7 compare:str8]?@\"YES\":@\"NO\");//比较结果为：YES        //忽略大小写        NSLog(@\"忽略大小写1，%ld\",[str7 caseInsensitiveCompare:str8]);//忽略大小写1，-1        NSLog(@\"忽略大小写2，%ld\",[str9 caseInsensitiveCompare:str7]);//忽略大小写2，0","title":"[置顶] Objective-c中Foundation中的几个常用类1"},{"content":"     最近项目中用到了libgdx   于是便抽空看了下opengles，关于安卓的资料也不多，不过opengles 各个平台的代码页都差不多，IOS的资料还是比较丰富的 ，网上找到最多的就是一个三角形旋转。      推荐一些学习opengl先要学的东西吧，  维基百科上很清楚  矩阵  这个非常重要  基本  opengl里面很多效果实现 都靠矩阵变化 opengl中的坐标   不同于 android 本身的坐标系     物体坐标  世界坐标    屏幕坐标映射到  世界坐标     涉及到一些算法     射线拾取 ，包围算法 等。。。 。。      先贴代码了 public class OpenglLess1Activity extends Activity {\t@Override\tprotected void onCreate(Bundle savedInstanceState) {\t\t// TODO Auto-generated method stub\t\tsuper.onCreate(savedInstanceState);\t\t        GLSurfaceView view = new GLSurfaceView(this);        view.setRenderer(new OpenglLess1Render());        setContentView(view);\t}} import java.nio.ByteBuffer;import java.nio.ByteOrder;import java.nio.FloatBuffer;import javax.microedition.khronos.egl.EGLConfig;import javax.microedition.khronos.opengles.GL10;import android.opengl.GLSurfaceView.Renderer;import android.util.Log;public class OpenglLess1Render implements Renderer {\tprotected float near=1;  \tprotected float far=20;\tprotected float ratio;\tfloat[] lines=new float[]{-1f,0f,0f, //顶点坐标\t\t\t1.0f,0f,0f,\t\t\t0f,1.0f,0f};\t\t@Override\tpublic void onSurfaceCreated(GL10 gl, EGLConfig config) {\t\t// TODO Auto-generated method stub\t\t// 对透视进行修正\t\tgl.glHint(GL10.GL_PERSPECTIVE_CORRECTION_HINT, GL10.GL_FASTEST);\t\t// 启用阴影平滑\t\tgl.glShadeModel(GL10.GL_SMOOTH);\t\tgl.glClearColor(0, 0, 0, 0);\t\t// 设置深度缓存\t\tgl.glClearDepthf(1.0f);\t\t// 启用深度测试\t\tgl.glEnable(GL10.GL_DEPTH_TEST);\t\t// 作为深度测试的类型\t\tgl.glDepthFunc(GL10.GL_LEQUAL);\t}\t@Override\tpublic void onSurfaceChanged(GL10 gl, int width, int height) {\t\t// TODO Auto-generated method stub\t\tratio = (float) width / height;\t\tLog.e(\"lin\",\"width=\"+width+\" height=\"+height+\" ratio=\"+ratio);\t\t// 设置OpenGl场景大小\t\tgl.glViewport(0, 0, width, height);\t\t// 设置矩阵投影\t\tgl.glMatrixMode(GL10.GL_PROJECTION);\t\tgl.glLoadIdentity();\t\t// 设置串口的大小   near,far视野的距离   假设眼睛在原点   往Z轴负方向看   超过视野距离则看不见  \t\tgl.glFrustumf(-ratio, ratio, -1, 1, near, far);\t\t// 选择模型观察矩阵\t\tgl.glMatrixMode(GL10.GL_MODELVIEW);\t\tgl.glLoadIdentity();\t}\t@Override\tpublic void onDrawFrame(GL10 gl) {\t\t// TODO Auto-generated method stub\t\t//清楚颜色，深度缓存\t\tgl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);\t\t\t\t//开启模型试图矩阵\t\tgl.glMatrixMode(GL10.GL_MODELVIEW);\t\t\t\t//加载一个基本矩阵 可以理解为重置矩阵，因为每次draw后 会保留原来的矩阵，如果不重置矩阵 ，在translate时 物体就会越离越远\t\tgl.glLoadIdentity();\t\t//眼睛设的视野距离为    -1，-20的坐标，则只有在该范围内 的物体才能看到    将物体移动到 z =-3处\t\tgl.glTranslatef(0, 0, -3f);\t\t//定义坐标点  数组  Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.\t\tgl.glVertexPointer(3, GL10.GL_FLOAT, 0,getFloatBuffer(lines));\t\t//启用定点数组   跟下面disable 相互对应  \t\tgl.glEnableClientState(GL10.GL_VERTEX_ARRAY);\t\t\t\t//设置画笔颜色\t\tgl.glColor4f(1.0F, 0F,0F,1.0F);\t\t//绘制三角形\t\tgl.glDrawArrays(GL10.GL_TRIANGLES, 0,3);\t\tgl.glDisableClientState(GL10.GL_VERTEX_ARRAY);\t}\t\t/**\t * 分配内存空间    2.2 以前的版本冒失不需要这样实现 \t * 浮点变量 每个占4字节\t * @param coords\t * @return\t */\tpublic FloatBuffer getFloatBuffer(float[] coords) {\t\tByteBuffer vbb = ByteBuffer.allocateDirect(coords.length * 4);\t\tvbb.order(ByteOrder.nativeOrder());\t\tFloatBuffer mFVertexBuffer = vbb.asFloatBuffer();\t\tmFVertexBuffer.put(coords);\t\tmFVertexBuffer.position(0);\t\treturn mFVertexBuffer;\t}}        ","title":"Android Opengles 学习一"},{"content":"前几章参考： 1-引言 2-Objective-C 编程 3-类、对象和方法 4-数据类型和表达式 5-循环结构 6-选择结构 要注意的一件事情（这个和C语言差不多，就是头文件引用规则）： 导入的文件要用一对引号引起来，而不是<Foundation/Foundation.h>中的“<”和\">\"字符。双引号适用于本地文件（你自己创建的文件），而不是系统文件，这样就通知编译器在哪里能够找到指定的文件。 接口和实现的要求： 接口文件包含类的公开信息，即能够与这个类的使用者共享一些信息。另一方面，实现部分包含的是私有信息，即实例变量和代码。 合成存取方法： 从Objective-C2.0开始，可自动生成设值方法和取值方法（统称为存取方法）。具体步骤如下： 1）在接口部分中使用@property指令标识属性。 @interface Fraction : NSObject @property int numerator, denominator; @end 2）在实现部分使用@synthesize指令即可。 @inplementation Fraction @synthesize numerator, denominator; @end 如果使用了@property指令，就不需要在实现部分声明相应的实例变量。 通常，如果有称为x的属性，那么在实现部分包括以下行会导致编译器自动实现一个取值方法x和一个设置方法setX： @synthesize x; 因为生成的存取方法是高效的，并且在使用多个核心的多台机器上，使用多线程时也可正常运行。（这里的说法呢，就是说线程安全的） 访问属性： 可以使用点运算符.，或发送消息[] [myFraction numerator]; myFraction.numerator; 一般格式： instance.property = value; 等价于 [instance setProperty: value] 需要指出的是，也可以对自定义的方法使用点运算符，不仅仅是使用在synthesize上（即属性）。 注意： 点运算符和发消息都是可以的，但是，点运算符通常使用在属性上，用于设置或取得实例变量的值。方法在Apple的文档中被标记为任务（Task），任务通常不是由dian运算符执行的，而是使用传统的方括号形式的消息表达式作为首选的语法。 另外，使用合成（synthesize）的存取方法，属性名称的前面不要以new、alloc、copy和init这些此开头。这与编译器的一些假定有关，因为编译器会合成相应的方法。 关于方法： 在编写新方法时，省略参数名不是一种好的编程风格，因为它是程序很难读懂并且很不直观，特别是当使用的方法参数特别重要时，更是如此。 [aFraction set:1 :3]这是不好的 [aFraction set:1 over:3]这是好的 - （void）add：(Fraction *) f； 这条语句说明add:方法的参数是Fraction类对象的一个引用。星号是必须的，所以声明(Fraction) f是不正确的。 局部变量： 局部变量是基本的C数据类型，并没有默认的初始值，所以在使用前要先赋值。局部对象变量默认初始化为nil。和实例变量不同（它们在多次方法调用时保持自己的值），这些局部变量没有记忆力。也就是说，当方法返回时，这些变量的值都消失了。每次调用方法时，该方法中的局部变量都使用变量声明重新初始化一次。 方法的参数： 方法的参数名也是局部变量。执行方法时，通过方法传递的任何参数都被复制到局部变量中。因为方法使用参数的副本，所以不能改变通过方法传递的原值。这一点很重要。 另外，如果参数是对象，可以更改其中的实例变量值。当你传递一个对象作为参数时，实际上是传递了一个数据存储位置的引用。正因为如此，你才能够修改这些数据。 static关键字： 在变量声明前加上关键字static，可以使局部变量保留多次调用一个方法所得的值。和其它基本数据类型的局部变量不同。静态变量的初始值为0。此外，它们只在程序开始执行时初始化一次，并且在多次调用方法时保存这些数值。 记住：只能在定义静态变量和局部变量的方法中访问这些变量。 总的说来，这一章里面的很过概念还是比较重要的，在别的语言里也有描述这些。","title":"7-类"},{"content":"命令行查看sqlite3表结构的命令 sqlite3 xxxxx.db SQLite version 3.7.15.1 2012-12-19 20:39:10 Enter \".help\" for instructions Enter SQL statements terminated with a \";\" sqlite>  方法1  sqlite> .select * from sqlite_master where type=\"table\"; 方法2 sqlite> .schema [表名]    默认输出所有的表, 建表SQL语句。 推荐方法2","title":"sqlite3 表结构查询"},{"content":"android开机动画显示原理： 开机时，系统自动检测在/system/media/目录或/data/local/目录有没有bootanimation.zip文件。如果有，这按照bootanimation.zip里面的png排列顺序依次显示开机图片，开起来就是动画效果；否则按照android默认的方式显示开机动画。 android开机动画叫源码位于frameworks/base/cmds/bootanimation下，这个程序编译后生成/syetem/bin/bootanimation，将/data/local/bootanimation.zip或/system/media/bootanimation.zip里面的png图片以动画的形式播放出来。 先来分析一下源码： frameworks/base/cmds/bootanimation/BootAnimation.cpp 首先看一下定义的常量： #define USER_BOOTANIMATION_FILE \"/data/local/bootanimation.zip\"#define SYSTEM_BOOTANIMATION_FILE \"/system/media/bootanimation.zip\"#define SYSTEM_ENCRYPTED_BOOTANIMATION_FILE \"/system/media/bootanimation-encrypted.zip\"   BootAnimation::readyToRun() 进入一个if判断语句 if ((encryptedAnimation &&            (access(SYSTEM_ENCRYPTED_BOOTANIMATION_FILE, R_OK) == 0) &&            (mZip.open(SYSTEM_ENCRYPTED_BOOTANIMATION_FILE) == NO_ERROR)) ||            ((access(USER_BOOTANIMATION_FILE, R_OK) == 0) &&            (mZip.open(USER_BOOTANIMATION_FILE) == NO_ERROR)) ||            ((access(SYSTEM_BOOTANIMATION_FILE, R_OK) == 0) &&            (mZip.open(SYSTEM_BOOTANIMATION_FILE) == NO_ERROR))) {        mAndroidAnimation = false;    }   BootAnimation::threadLoop() if (mAndroidAnimation) {r = Android(); // 执行android字体闪动的图片} else {r = movie(); // 执行bootanimation.zip中提供的动画图片}      BootAnimation::Android()会加载\"images/android-logo-mask.png\"和\"images/android-logo-shine.png\"  BootAnimation::movie()会加载bootanimation.zip中的内容 我们下载的源码里默认是没有那些个.zip动画的，所以总会跳到android字体闪动的画面。 知道原理之后，自定义开机画面就简单了，我们直接在/system/media/目录或是在/data/local/目录加上bootanimation.zip文件就可以了。 bootanimation.zip文件由下面几个文件目录组成： desc.txt         动画属性描述文件 part0             第一阶段动画图片的目录 （动画是由一帧帧图片组成的） part1             第二阶段动画图片的目录 ... partn            一般来说就两个文件夹part0、part1，两个文件夹里面放着编号号的png图片。 desc.txt文件内容格式如下： 320 480 5 p 1 0 part0 p 0 0 part1 解释下： 320为图片的宽，480为图片的高，后面的那个5表示帧数，即每秒播放的图片张数。 p为描述符，后面的1表示播放一次，后面的0表示阶段切换时间，part0表示png资源路径。 p为描述符，后面的0表示本阶段无限循环（直到开机结束），再后面的0表示本阶段切换时间，part1表示路径。 自己生成bootanimation.zip时，只要编辑好desc文档，再把相应的png图片资源放到各自的文件夹即可，准备好这些直接压缩生成bootanimation.zip文件（注意不要压缩文件，直接选择存储方式压缩，要不然不能正确获取到png图片，开机时会一直黑屏），然后把.zip文件用adb push到/system/media或是/data/local目录，重启，这是应该就会显示自定义的开机动画了。    ","title":"自定义android开机动画"},{"content":"错误总结: MediaPlayer报错prepareAsync called in state 8 原因: 在进入Activity后在Oncreate()方法中: mMediaPlayer=MediaPlayer.create(MainActivity.this, R.raw.big); 为此mMediaPlayer设置了要播放的资源 但是在点击stop按钮以后,执行了mMediaPlayer.release(); 这样的话就释放了资源.所以再次点击播放的时候报错 解决办法: 在每次点击play的时候,都执行MediaPlayer.create() 注意: 可以在每次点击暂停的时候保存现在播放的位置即: position=mMediaPlayer.getCurrentPosition(); 然后在每次播放的时候 mMediaPlayer.seekTo(position); 这样就会从暂停处继续播放","title":"MediaPlayer报错prepareAsync called in state 8"},{"content":"1、 去下载SDK： http://zbar.sourceforge.net/iphone/index.html 。 2、新建你的IOS Project。 3、导入ZbarSDK，直接拖动你下载的ZbarSDK到你的项目，并且选择copy选项。 4、添加如下framework 5、在appDelegate文件的以下方法中加入如下： - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {     //your code     [ZBarReaderView class];     return YES; } 复制代码 6、在你需要使用扫描功能的ViewController.h文件添加如下： #import <UIKit/UIKit.h> #import \"ZBarSDK.h\" @interface ScanViewController : UIViewController<ZBarReaderViewDelegate> {     ZBarReaderView *readerView;     ZBarCameraSimulator *cameraSim; } @property (retain, nonatomic) IBOutlet ZBarReaderView *readerView; @end 复制代码 7、在你需要使用扫描功能的ViewController.m文件添加如下： #import \"ScanViewController.h\" @interface ScanViewController () @end @implementation ScanViewController @synthesize readerView; - (void)viewDidLoad {     [super viewDidLoad];         //your code         readerView.readerDelegate = self;     [readerView setAllowsPinchZoom:YES];     if (TARGET_IPHONE_SIMULATOR) {         cameraSim = [[ZBarCameraSimulator alloc] initWithViewController:self];         cameraSim.readerView = readerView;     } } -(void)viewDidAppear:(BOOL)animated {     [readerView start]; } -(void)viewDidDisappear:(BOOL)animated {     [readerView stop]; } -(void) readerView:(ZBarReaderView *)readerView didReadSymbols:(ZBarSymbolSet *)symbols fromImage:(UIImage *)image {     NSString *codeData = [[NSString alloc] init];;     for (ZBarSymbol *sym in symbols) {         codeData = sym.data;         break;     }     UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@\"掃描結果\" message:codeData delegate:self cancelButtonTitle:@\"OK\" otherButtonTitles:nil, nil];     [alert show]; } -(void) imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info {     // 得到条形码结果     id<NSFastEnumeration> results =     [info objectForKey: ZBarReaderControllerResults];     ZBarSymbol *symbol = nil;     for(symbol in results)         break;     //获得到条形码     //NSString *dataNum=symbol.data;     //扫描界面退出     [picker dismissModalViewControllerAnimated: YES]; } 复制代码 8、至于需要如何美化你的扫描界面或者其他的使用方式，将在以后的帖子中继续探讨。 9、最终界面上一张粗糙的模拟器截图：","title":"扫码"},{"content":"Android UI界面由以下树形结构组成, 从图中可以看出, UI界面是有View与ViewGroup两大类控件组成，在下面树形图中不管是View还是ViewGroup都是从android.view.View中派生, 而ViewGroup作为容器, 它可以装载和管理其下的一些列由android.view.View派生出来的元素(View和ViewGroup):               由android.view.View派生出来的单一控件元素常见的有TextView, Button, ImageView等, 派生出的容器有LinearLayout, FrameLayout 等, 也有一些由ViewGroup派生出来的控件做为单一控件元素使用的， 比如说ListView, 当然我们也可以把ListView当做容器使用。Android通过布局可以完成很多有创意富有美感的界面， ViewGroup的作用很大，这里单独拿出来研究。   　　ViewGroup实现了android.view.ViewParent和android.view.ViewManager两个接口, 赋予其装载子控件和管理子控件的能力。这篇主要讲Android控件如何绘制到界面上的。 　　控件显示到界面上主要分三个流程, 如下图。这是一个非常自然的想法, 得到大小后才可以布局, 布局好了才可以绘制; 这三个流程都是按照上图树形结构递归的。对于这三个流程，只要对Android控件稍有研究的人都           会发现， 每一个控件都有measure(), layout(), draw()方法, 下面分别分析其作用: measure 递归:      1、判断是否需要重新计算大小     2、调用onMeasure, 如果是ViewGroup类型， 则遍历所有子控件的measure方法，计算出子控件大小,     3、使用setMeasuredDimension(int, int)确定自身计算的大小     由于第二步会调用子控件的measure方法, 在子控件的大小计算当中也会经历这三步动作， 直到整个树遍历完, 此时此控件及其子控件的大小都确定了, 在这里强调控件的大小是由父控件和自身决定的，当然取决在于父控件， 控件自身只提供参考值， 这是因为控件的measure方法是由父控件调用的, 而父控件的控件有限，可能不完全按照你的申请要求给出, 这里留待以后讨论关于布局参数问题。 在android.view.View对于measure流程已经实现了一部分: public final void measure(int widthMeasureSpec, int heightMeasureSpec) {     ...　　　// measure ourselves, this should set the measured dimension flag back     onMeasure(widthMeasureSpec, heightMeasureSpec);     ...} 对于android.view.View来说它不需要遍历子控件了, 下面贴出一个我实现的一个onMeasure ： @Override    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {        //获取mode和size, 方便给children分配空间        final int widthMode = MeasureSpec.getMode(widthMeasureSpec);        final int widthSize = MeasureSpec.getSize(widthMeasureSpec);        final int heightMode = MeasureSpec.getMode(heightMeasureSpec);        final int heightSize = MeasureSpec.getSize(heightMeasureSpec);        //TODO 这里可以检查你的大小, 或者mode        final int count = getChildCount();        for(int i = 0; i < count; i++) {            final View view = getChildAt(i);            //这里只是举一个例子, 这里给child多少大小根据实际来定            int childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(100, MeasureSpec.EXACTLY);            int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(100, MeasureSpec.EXACTLY);            view.measure(childWidthMeasureSpec, childHeightMeasureSpec);        }        // 得出自己计算出的大小, 这里也是一个例子, 可以根据所有子控件占多大空间        // 给出, 这里也根据要实现的效果看, 这部分建议看LinearLayout等容器的源码        setMeasuredDimension(widthSize, heightSize);    }   layout 递归:      1、设置自身相对父控件的位置并判断是否需要重新布局，使用setFrame(left, top, right, bottom);     2、调用onLayout()布局子控件 在android.view.View也实现了此流程的一部分: public void layout(int l, int t, int r, int b) {    ...    onLayout(changed, l, t, r, b);    ...} 下面我也简单的实现了第二步: @Override    protected void onLayout(boolean changed, int l, int t, int r, int b) {        final int count = getChildCount();        int widthSpan = 0;        int heightSpan = 0;        for(int i = 0; i < count; i++) {            final View child = getChildAt(i);            child.layout(widthSpan, heightSpan, child.getMeasuredWidth(), child.getMeasuredHeight());            widthSpan += child.getMeasuredWidth();            heightSpan += child.getMeasuredHeight();        }    } 这是一个简陋的Grid布局。  draw递归:      1、绘制背景      2、调用onDraw()绘制控件内容     3、调用dispatchDraw()绘制所有的子控件     4、绘制渐变边界等     5、绘制装饰品, 比如滑动条等 draw递归在android.view.View已经有完整的实现, 自定义ViewGroup时一般只需要重写onDraw实现如何绘制内容就够了, 当然所有的流程都可以重写, 如果需要的话。下面看一下android.view.View里面draw递归的原型： public void draw(Canvas canvas) {        // Step 1, draw the background, if needed        ...// Step 2, draw the content        onDraw(canvas);        // Step 3, draw the children        dispatchDraw(canvas);        // Step 4, draw the fade effect and restore layers        ...　　　　　　　　 //Step 5, draw decorations        onDrawScrollBars(canvas);}      上面三个递归, 解决了一颗控件树的显示问题, 现在大家会很奇怪, 到底是谁发起这个递归, 即最上层的父控件到底是谁, 查看源码可以看到, 在android.view下面有一个ViewRoot(更新后变成ViewRootImpl)隐藏类， 在其performTraversals()方法中发起这三个递归，这个类没有研究太深入, 以后补上。在performTraversals()中大概的流程是： private void performTraversals() {     final View host = mView;     ...     host.measure();     ...     host.layout();     ...     host.draw();     ...} 这样就实现了一个大的递归, 把完整的界面给绘制出来了。下面我自己写一个实现ViewGroup的Demo： package com.ui.viewgroup;import android.content.Context;import android.graphics.Canvas;import android.util.AttributeSet;import android.view.View;import android.view.ViewGroup;public class ViewGroupImpl extends ViewGroup {    public class LayoutParams extends ViewGroup.LayoutParams {        public int left = 0;        public int top = 0;        public LayoutParams(int width, int height) {            super(width, height);        }        public LayoutParams(int left, int top, int width, int height) {            super(width, height);            this.left = left;            this.top = top;        }    }    public ViewGroupImpl(Context context) {        this(context, null);    }    public ViewGroupImpl(Context context, AttributeSet attrs) {        super(context, attrs);    }    public void addInScreen(View child, int left, int top, int width, int height) {        addView(child, new LayoutParams(left, top, width, height));    }    @Override    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {        final int widthMode = MeasureSpec.getMode(widthMeasureSpec);        final int widthSize = MeasureSpec.getSize(widthMeasureSpec);        final int heightMode = MeasureSpec.getMode(heightMeasureSpec);        final int heightSize = MeasureSpec.getSize(heightMeasureSpec);        // 检测控件大小是否符合要求        if(widthMode == MeasureSpec.UNSPECIFIED || heightMode == MeasureSpec.UNSPECIFIED) {            throw new IllegalArgumentException(\"不合法的MeasureSpec mode\");        }        // 计算子控件大小        final int count = getChildCount();        for(int i = 0; i < count; i++) {            final View child = getChildAt(i);            final LayoutParams lp = (LayoutParams)child.getLayoutParams();            //确定大小的            final int childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(lp.width,                    MeasureSpec.EXACTLY);            final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(lp.height,                    MeasureSpec.EXACTLY);            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);        }        // 设置计算的控件大小        setMeasuredDimension(widthSize, heightSize);    }    @Override    protected void onLayout(boolean changed, int l, int t, int r, int b) {        final int count = getChildCount();        LayoutParams lp;        for(int i = 0; i < count; i++) {            final View child = getChildAt(i);            lp = (LayoutParams)child.getLayoutParams();            //相对父控件坐标            child.layout(lp.left, lp.top, lp.left + lp.width, lp.top + lp.width);        }    }    // draw递归 不需要我们接管,    @Override    public void draw(Canvas canvas) {        super.draw(canvas);    }    @Override    protected void onDraw(Canvas canvas) {        super.onDraw(canvas);    }    @Override    protected void dispatchDraw(Canvas canvas) {        super.dispatchDraw(canvas);    }} Activity: @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        ViewGroupImpl viewGroupImpl = new ViewGroupImpl(this);        setContentView(viewGroupImpl, new LayoutParams(LayoutParams.MATCH_PARENT,                LayoutParams.MATCH_PARENT));        // 因为此时无法获取viewGroupImpl的实际大小, 所以只好假设一个大小        final int parentWidth = 400;        final int parentHeight = 700;        final int maxWidthSize = parentWidth / 4;        final int maxHeightSize = parentHeight / 4;        Random random = new Random();        for(int i = 0; i < 50; i++) {            int left = random.nextInt(parentWidth) - 10;            int top = random.nextInt(parentHeight) - 10;            int width = random.nextInt(maxWidthSize) + 10;            int height = random.nextInt(maxHeightSize) + 10;            ImageView child = new ImageView(this);            child.setImageResource(R.drawable.ic_launcher);            viewGroupImpl.addInScreen(child, left, top, width, height);        } 下面是效果图:","title":"ViewGroup学习之绘制过程"},{"content":"今天试图实现这么一个功能：通过presentViewController呈现某一个viewController，并且在这个页面中添加一个UINavigationController，可以达到在这个页面进行逐步跳转页面功能。 最初我是在跳转后的页面的initWithNibName等初始化函数添加UINavigationController，然后设置RootViewController为self，这样是实现了可以从当前界面跳转到其他界面，但是很快发现一个问题，当在界面中执行dismissViewController时，不会自动执行这个界面的dealloc()函数，也就意味着，内存中并没有释放之前present的那个界面，那个界面在添加UINavigationController时被retain了，可是几经尝试，在那个界面最终还是不容易自动执行dealloc()函数。 最后，我的解决方法是，在需要presentViewController处，添加UINavigationController，并设置rootViewController为需要present的view，present时将navigation那个对象传过去。具体实现代码如下： KYPGRegistRootViewController *viewRegist = [[KYPGRegistRootViewController alloc] initWithNibName:@\"KYPGRegistRootViewController\" bundle:nil];    UINavigationController *navRegist = [[UINavigationController alloc] initWithRootViewController:viewRegist];    [viewRegist release];    if ([self respondsToSelector:@selector(presentViewController:animated:completion:)]) {        [self.navigationController presentViewController:navRegist animated:YES completion:nil];    }else{        [self.navigationController presentModalViewController:navRegist animated:YES];    }    [navRegist release];","title":"（iPhone/iPad开发）present某一个ViewController后，试图添加UINavigationController遇到的一些问题"},{"content":"Videobuf 下面来介绍以下videobuffer相关的一些东西。 V4L2核心api提供了一套标准的方法来处理视频缓冲，这些方法允许驱动实现read(),mmap(), overlay()等操作。同样也有方法支持DMA的scatter/gather操作，并且支持vmallocbuffer(这个大多用在USB驱动上)。 videobuf层功能是一种在v4l2驱动和用户空间当中的依附层，这话看起来有点绕，说白了就是提供一种功能框架，用来分配和管理视频缓冲区，它相对独立，却又被v4l2驱动使用。它有一组功能函数集用来实现许多标准的POSIX系统调用，包括read(),poll()和mmap()等等，还有一组功能函数集用来实现流式(streaming)IO的v4l2_ioctl调用，包括缓冲区的分配，入队和出队以及数据流控制等操作。使用videobuf需要驱动程序作者遵从一些强制的设计规则，但带来的好处是代码量的减少和v4l2框架API的一致。 缓冲类型 并不是所有的视频设备都使用相同的缓冲类型。实际上，有三种通用的类型： –被分散在物理和内核虚拟地址空间的缓冲，几乎所有的用户空间缓冲都是这种类型， 如果可能的话分配内核空间的缓冲也很有意义，但是不幸的是，这个通常需要那些支持离散聚合DMA操作的硬件设备。 –物理上离散的但是虚拟地址是连续的，换句话说，就是用vmalloc分配的内核缓冲。这些缓冲很难用于DMA操作。 – 物理上连续的缓冲。 videobuf可以很好地处理这三种类型的缓冲，但是在此之前，驱动程序作者必须选择一种类型，并且以此类型为基础设计驱动。 数据结构，回调函数和初始化 根据选择的类型，包含不同的头文件，这些头文件在include/media/下面 <media/videobuf-dma-sg.h> <media/videobuf-vmalloc.h> <media/videobuf-dma-contig.h> v4l2驱动需要包含一个videobuf_queue的实例用来管理缓冲队列，同时还要一个链表来维护这个队列，另外还要一个中断安全的spin_lock来保护队列的操作。 下一步就是要填充一个回调函数集来处理实际的缓冲区队列，这个函数集用videobuf_queue_ops来描述： struct videobuf_queue_ops { int *(buf_setup)(struct videobuf_queue*q, uint *count, uint *size); int *(buf_prepare)(structvideobuf_queue *q, struct videobuf_buffer *vb, enum v4l2_field field); void *(buf_queue)(structvideobuf_queue*q,struct videobuf_buffer *vb); void *(buf_release)(...); } buf_setup在IO处理请求之前被调用。目的是告诉videobuf关于IO的信息。 count参数提供一个缓冲区个数的参考，驱动必须检查它的合理性，一个经验是大于等于2，小于等于32个。Size参数指定了每一帧数据的大小。 buf_prepare每一个缓冲(videobuf_buffer结构描述的)将被传递给该回调函数，用来配置缓冲的height,width和fileds。如果field参数被设置为 VIDEOBUF_NEEDS_INIT，那么驱动将把vb传递给videobuf_iolock()这个函数。除此之外，该回调函数通常也将为vb分配内存，最后把vb的状态置为VIDEOBUF_PREPARED。 buf_queue当一个vb需要被放入IO请求队列时，调用该回调。它将把这个buffer放到可用的buffer链表当中去，然后把状态置为VIDEOBUF_QUEUED。 buf_release当一个buffer不再使用的时候，调用该回调函数。驱动必须保证 buffer上没有活跃的IO请求，之后就可以将这个buffer传递给合适的 free函数，根据申请的buffer类型调用对应的释放函数： scatter/gather类型的调用 videobuf_dma_unmap(structvideobuf_queue, videobuf_dmabuf) videobuf_dma_free(videobuf_dmabuf) vmalloc类型的调用 videobuf_vmalloc_free(videobuf_buffer) contiguous类型的调用 videobuf_dma_contig_free(videobuf_queue,videobuf_buffer) 有一种方法可以保证buffer上没有IO请求，调用函数 videobuf_waiton(videobuf_buffer,non_blocking, intr) 文件操作(v4l2_file_operations) 到了这儿，很多工作也就做完了，剩下的事情就是将对videobuf的调用传递给具体的驱动实现了。首先就是打开操作，这个操作要先对videobuf_queue进行初始化，初始化取决于申请的buffer是什么类型，有如下三种初始化函数可供调用： void videobuf_queue_sg_init(structvideobuf_queue *q, struct videobuf_queue_ops *ops, struct device *dev, spinlock_t *irqlock, enum v4l2_buf_type type, enum v4l2_field_ field, unsigned int msize, void *priv， struct mutex *ext_lock) void videobuf_queue_vmalloc_init(structvideobuf_queue *q, struct videobuf_queue_ops *ops, struct device *dev, spinlock_t *irqlock, enum v4l2_buf_type type, enum v4l2_field field, unsigned int mszie, void *priv， struct mutex *ext_lock); voidvideobuf_queue_dma_contig_init(struct videobuf_queue *q, struct videobuf_queue_ops *ops, struct device *dev, spinlock_t *irqlock, enum v4l2_buf_type type, enum v4l2_field field, unsigned int mszie, void *priv， struct mutex *ext_lock); 以上三种初始化函数，有相同的参数，这些参数的从他们的名称就可以看出来锁代表的意义是什么。 这里着重说下v4l2_buf_type类型， V4L2_BUF_TYPE_VIDEO_CAPTURE 指定buf的类型为capture，用于视频捕获设备 V4L2_BUF_TYPE_VIDEO_OUTPUT 指定buf的类型output，用于视频输出设备 V4L2_BUF_TYPE_VIDEO_OVERLAY 指定buf的类型为overlay，用于overlay设备 V4L2_BUF_TYPE_VBI_CAPTURE 用于vbi捕获设备 V4L2_BUF_TYPE_VBI_OUTPUT 用于vbi输出设备 V4L2_BUF_TYPE_SLICED_VBI_CAPTURE 用于切片vbi捕获设备 V4L2_BUF_TYPE_SLICED_VBI_OUTPUT 用于切片vbi输出设备 V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY 用于视频输出overlay设备 V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE 用于多平面存储格式的视频捕获设备 V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE用于多平面存储格式的视频输出设备 v4l2_field指定video的field，也就是说interleaved或者progressive的，一般都是指定为V4L2_FIELD_NONE,用于逐行扫描的设备。 V4L2捕获设备驱动可以支持两种API：read()系统调用和更为复杂的流机制。一般的做法是两种都支持以确保所有的应用都可以使用该设备。videobuf框架使得这种驱动的编写变得更为简单。比如说要实现read()系统调用，那么驱动程序只需要调用 ssize_t videobuf_read_one(structvideobuf_queue *q, char __user *data, size_t count,loff_t *ppos, int nonblocking) ssize_t videobuf_read_streaming(structvideobuf_queue *q, char __user *data, size_t count, loff_t *ppos,int vbihack, int nonblocking) 这两个函数都是把帧数据读入到data当中，然后返回实际上读取的字节数。不同的是前者只读取一帧数据，而后者可以选择读取多帧。一个典型的应用read()系统调用必须开启捕获设备，然后返回之前停止该设备。 poll()系统调用通常由以下函数来实现： unsigned intvideobuf_poll_stream(struct file *file, struct videobuf_queue *q, poll_table *wait) 注意，实际最终使用的q是可用的第一个buffer。 当内核空间缓冲的流IO请求完成后，驱动还必须支持mmap系统调用以使能用户空间可以访问data数据。在v4l2驱动中，通常很复杂的mmap的实现被简化了，只需要调用下面这个函数就可以了： int videobuf_mmap_mapper(structvideobuf_queue *q, struct vma_area_struct * vma) 剩下的事情就交给videobuf核心层来完成好了。 release函数需要调用两个单独的函数来完成： void videobuf_stop(structvideobuf_queue *q); int videobuf_mmap_free(structvideobuf_queue *q) 前者终止所有buffer的IO操作。后者保证所有的buffer被unmap掉，如果已经被unmap掉的话，这个buffer就会被传递给buf_release回调函数。如果buffer还没有被unmap，那么后者将返回一个错误代码。 Ioctl操作： v4l2api涵盖了很长一组驱动回调函数来响应用户的ioctl操作，有很大一部分和流IO操作相关的都是直接调用到videobuf里面来。相关的函数如下： int videobuf_reqbufs(structvideobuf_queue *q, structv4l2_requestbuffers *req); int videobuf_querybuf(structvideobuf_queue *q, struct v4l2_buffer *vb) int videobuf_qbuf(strurctvideobuf_queue *q, struct v4l2_buffer *vb) int videobuf_dqbuf(structvideobuf_queue *q, struct v4l2_buffer *vb) int videobuf_streamon(structvideobuf_queue *q); int videobuf_streamoff(structvideobuf_queue *q); Buffer的分配 讲到这儿，我们讨论了很多关于buffer的话题，但是却没有提到他们是怎么分配的。Scatter/gather例子比较复杂，驱动程序可以完全让videobuf层去完成buffer的分配，在这种情况下，buffer将被分配为匿名用户空间页并且实际上将非常分散。如果应用程序使用用户空间的buffer的话，驱动也就不需要分配了，videobuf层将小心的调用get_user_pages()并且填充离散列表数组(scatterlistarray)。 如果驱动程序要自己做内存分配，那么将在vidioc_reqbufs函数中进行，在调用了videobuf_reqbufs()之后，首先第一步就是要调用到 struct videobuf_dmabuf*videobuf_to_dma(struct videobuf_buffer *buf) 返回的videobuf_dmabuf包含了一对相关的域 struct scatterlist *sglist; int sglen; 驱动必须分配合适大小的scatterlist数组，并且将分配的内存片和指针对应起来，sglen指定了scatterlist数组的大小。 驱动当中如果使用了vmalloc()来分配内存的话，就不用关心buffer的分配了，videobuf层将处理具体的细节，一些驱动程序使用了小技巧，就是在系统启动的时候就分配好了dma内存，以避免动态申请有的时候会申请不到的问题，但是对于此类的设计，videobuf层目前还不能很好的胜任。在3.0以上的内核当中，出现了一种新的框架videobuf2，已经解决了这个问题，我们会在后面详细介绍这个框架。 Filling缓冲区 videobuf层的最后一部分就是关于将帧数据传递到buffer中的实现。这一部分没有直接的回调函数，通常都是在设备的中断响应中来完成。对于所有类型的驱动，流程大概是这个样子的： – 获取下一个buffer，并且确保有人正在等待这个buffer – 得到一个内存指针，然后将视频数据放到那个地方 -- 标记buffer完成，并且唤醒等待的进程 第一步，buffer可以通过驱动管理的一个链表获得，这个链表由buf_queue回调函数填充，所以驱动最先要是链表初始化为空,并且如果链表当中的buffer没有一个进程在其上等待的话，是不能被移除或者填充的。 另外buffer在被map到dma之前，要把它的状态设置为VIDEOBUF_ACTIVE,这将保证在设备传输数据的时候videobuf层不去尝试任何操作。 第二步，得到一个内存指针，对于scatter/gather类型的内存来说，可以从scatterlist当中找到内存指针；对于vmalloc类型的来说调用 void * videobuf_to_vmalloc(structvideobuf_buffer *vb) 对于连续物理内存类型来说调用 dma_addr_tvideobuf_to_dma_contig(struct videobuf_buffer *buf) 第三步，就是设置videobuf_buffer中的大小，并且把buffer的状态设置为VIDEOBUF_DONE,然后在完成队列上调用wake_up().到此，buffer就真正的属于videobuf层了，驱动程序不用再去关心它如何被调度。 最后，一个很好的关于v4l2的例子就是drviers/media/video/vivi.c,它使用了vmalloc类型的videobuf,可以通过阅读这份例子来学习v4l2驱动的写法。","title":"深入理解linux内核v4l2框架之videobuf"},{"content":"Videobuf2框架 1. 什么是videobuf2框架？ 它是一个针对多媒体设备的v4l2兼容驱动框架，是用户空间应用程序和设备驱动的中间层。它为驱动提供更为底层的模块化的内存管理功能。 它能够使得驱动开发变得简单，减少代码量，帮助合理的连续的实现驱动当中的v4l2接口。 videobuf2的内存管理是完全模块化的，这就允许在不改变更高级别缓冲管理框架的情况下可以为设备和平台定制内存管理方法。 框架提供了一下三种: 实现了v4l2_ioctl的流控和文件操作 高级的视频缓冲，视频队列和状态管理 视频缓冲内存分配和管理 2.为什么要新开发一种框架呢？ 在当前的videobuf实现当中，有很多问题，在2010年举行的赫尔欣基峰会上重点提到了这么几个： V4L2 API出现异常和错误的内存管理设计 不能停止stream请求，缓冲在streamoff的时候被释放 VIDIOC_REQBUFS 不释放内存，也不能重新分配内存 视频内存在mmap，qbuf或者页错误的时候才分配 每个缓冲都有一个等待队列 扩展性不够强，尤其对于嵌入式多媒体设备来说支持不够 很难加入定制的内存分配和管理机制 不支持对缓存一致性和IOMMU设备 不够灵活，只有一个包办一切的函数来处理内存锁定，缓存，sg-list的创建 很多未使用的域，还有代码的重复，模糊晦涩的命名 很多驱动程序作者发布基于videobuf的基础组件.开发者也承认videobuf的功绩，也乐意使用它，但是由于灵活性不够现在不能这么做了。 3.重新设计的目的 修正V4L2API的实现，修复videobuf的问题和缺陷 分离缓冲队列管理和内存管理 在内存的分配和管理上更加灵活，可以嵌入定制的机制 更加有针对性的驱动回调函数，在不同的地方调用 支持新的V4L2API扩展，例如多平面视频帧存储的支持 4. 驱动回调函数 对称的驱动回调函数设计： buf_init 在内存被分配后或者一个新的USERPTR缓冲入队之后调用一次，比如用来锁定页，验证连续性，设置IOMMU映射等等。 buf_prepare每个QBUF都要调用，用来同步缓存，拷贝数据到buffer等 buf_finish每个DQBUF调用，用来同步缓存，从buffer中取回数据等 buf_cleanup 在free/release内存的时候调用 其余的回调函数也有重新设计： queue_negotiate现在合并了多平面的扩展；驱动返回所需要的缓冲数和每个缓冲的平面数。 plane_setup 驱动返回平面的尺寸大小 这两个调用取代了老的buf_setup buf_queue 保留了原来的功能，将buffer放入请求队列。 5. 内存分配和处理 内存处理这块设计得更加个性化，使得内存分配可以定制，定制的函数放在一个叫做v4l2_alloc_ctx的结构体当中。它的目的是给videobuf提供操作函数，并且存放一些私有数据。私有数据可以被嵌入到更大的一些结构体当中。 Struct vb2_alloc_ctx { const struct vb2_mem_ops *mem_ops; } struct vb2_foo_alloc_conf { strucdt vb2_alloc_ctx alloc_ctx; /* private data*/ } 更重要的是引入了一个buffer上下文结构的概念，在每次分配之后，分配器返回他们自己，定制的和每个buffer的结构。这个结构可以当作cookie传递给其他的内存处理方法。 存放在分配器上下文的内存操作可以被其他的分配器取代，详细的文档可以参考videobuf2-core.h。 一个非常好的例子从三星galaxy S系列的android手机内核源码中的videbuf2-cma.c，可以看看这个例子。","title":"深入理解linux内核v4l2框架之videobuf2"},{"content":"在使用 cocos2d for iphone 的时候就觉得 CCRenderTexture 的使用有些奇葩， 它内含了一个 CCSprite 成员变量，谓之曰方便使用， 也许是未能理解到设计者的妙处，我一直对这个都是心存疑虑。 CCRenderTexture，从名称来看，它应该被划分到 Texture 的范畴， 以直观的方式来思考，那么我应该是用 CCSprite 的 spriteWithTexture:(CCRenderTexture*) 这个方法来使用这个东西。 但实际上不是这样的，须以 spriteWithTexture:renderTexture.sprite.texture 的方式来使用。 这令我不爽，但是也还妨害无大。 到了  cocos2d-x 里面以后，我才发现，cocos2d-x 并不是简简单单对 cocos2d-iphone 做了翻译， 它还改变了一些东西，用过的肯定都会发现，spriteWithFile 改成 create() 了， 而且还不仅仅只是限于 CCSprite，很多类型都采用了 create() 的静态构造策略， 我非常喜欢这一点，以往是 [CCSprite spriteWithFile]，现在是 CCSprite::create() ，能少好几个字符， 代码多起来了以后，这点儿小方便就能节省不少的时间。 扯远了，ok，回到正题~ cocos2d-x 里面，CCRenderTexture 的 sprite 成员还被预设性的加到了该 CCRenderTexture 对象里面。 我只在 debug 模式下做开发，所有 assert 是有效的。 这样的话，要像我之前在 cocos2d-iphone 里面那样重新 new 一个 CCSprite 对象来使用这个 CCRenderTexture 动态纹理的话， 就不行了，因为 CCNode addChild 里面的断言 parent != NULL 过不了， 简而言之就是： 1。 CCRenderTexture 的 Sprite 成员没法再给加到别的 layer 里面去了， 因为他已经有 CCRenderTexture 这个 “父亲” 了，要加的话你只能把 CCRenderTexture 对象加到某个 layer 里面去， 然后 CCRenderTexture 的 sprite 成员自然而然也就被加到 layer 里面去了。 这样有一个弊端，也是导致我思索这个问题的直接诱因。 在  cocos2d-x 里面，CCRenderTexutre 生成的动态纹理 CCTexture2D 对象是脱离 CCTextureCache 独立存在的， 这块动态纹理所占据的内存会在该 CCRenderTexture 销毁的时候被清理掉。 如果我采用的是 cocos2d-box2d 模板，我在遍历 b2World 对象里面的各种附着了 sprite 的body 的时候， 发现有需要将某个 body 连带他上面附着的 sprite 删除掉了，而且这个动作一直充斥在游戏运行的过程中的话， 那我在销毁 sprite 的时候就没那么简单了，我还得判断一下这个 sprite 的父节点是不是 CCRenderTexture 才行， 是的话连带这个 CCRenderTexture 都得干掉。 （注：动态纹理占据的内存只会在 CCRenderTexture 被销毁的时候释放！ 简单销毁 CCRenderTexture 的 sprite 成员是不具有实际释放纹理的作用的） 当然，这也并不是什么非常非常难的操作，但这让我觉得别扭。 所以经过思考，我觉得吧 CCRenderTexture 的设计稍作更改： 1。创建一个新的类型 BYRenderTexture（BY 的寓意为 Bruce Yang，也就是我的英文名了） 这个 BYRenderTexture 到底和 CCRenderTexture 有何不同呢？ BYRenderTexture 里面剔除了这个 鸡肋的 Sprite 成员变量。 这虽然只是很小的改动，但是由我的经验来看，把扩展功能放在一个新建的类型里面， 下次要用的时候翻出来会容易的多 （假入直接在 cocos2d 源码里面做改动，可能在完成数个 cocos2d 项目过后， 你做的扩展就会被淹没在大海里面，被忘却或者变地非常难以检索）。 2。扩展一个 CCSprite 类型 —— BYSprite BYSprite 主要新增了一个 createWithRenderTexture(BYRenderTexture*)  的静态创建方法。 它的优点就在于使用直观，在他释放的时候同时也会将 BYRenderTexture 的动态纹理释放干净。 下面贴上相关代码： BYRenderTexture 仅移除 CCSprite 成员变量及相关 getter&& setter， 另外，将 m_pTexture->release() 这一行代码由 BYRenderTexture() 的后几行转移到 ~BYRenderTexture() 析构里面的第一行。 重点是 BYSprite 的代码，如下： BYSprite.h ////  BYSprite.h//  DreamStack////  Created by user on 12-12-26.//  Copyright (c) 2012年 __MyCompanyName__. All rights reserved.//#ifndef DreamStack_BYSprite_h#define DreamStack_BYSprite_h#include \"cocos2d.h\"#include \"BYRenderTexture.h\"USING_NS_CC;class BYSprite : public CCSprite {private:    BYRenderTexture* m_pRenderTex;public:    static BYSprite* createWithRenderTexture(BYRenderTexture* in_pRenderTex);        BYSprite(BYRenderTexture* in_pRenderTex);    ~BYSprite();    };#endif BYSprite.cpp ////  BYSprite.cpp//  DreamStack////  Created by Bruce Yang on 12-12-26.//  Copyright (c) 2012年 __MyCompanyName__. All rights reserved.//#include \"BYSprite.h\"BYSprite* BYSprite::createWithRenderTexture(BYRenderTexture* in_pRenderTex) {    BYSprite* t_pSprite = new BYSprite(in_pRenderTex);    if (t_pSprite && t_pSprite->initWithTexture(in_pRenderTex->getTexture())) {        t_pSprite->autorelease();        return t_pSprite;    }    CC_SAFE_DELETE(t_pSprite);    return NULL;}BYSprite::BYSprite(BYRenderTexture* in_pRenderTex) : m_pRenderTex(in_pRenderTex) {    CCAssert(in_pRenderTex, \"入参不可为空~\");    in_pRenderTex->retain();    m_pRenderTex = in_pRenderTex;}BYSprite::~BYSprite() {//    printf(\" ### ~BYSprite\\n\");    m_pRenderTex->release();} 使用也很简单(这里仅创建了一块全白的动态纹理做测试)： CCTexture2DPixelFormat t_oFmt = kCCTexture2DPixelFormat_RGBA8888;BYRenderTexture* t_pRt = BYRenderTexture::create(in_fWidth, in_fHeight, t_oFmt);t_pRt->beginWithClear(1.f, 1.f, 1.f, 1.f);t_pRt->end();    m_pSprite = BYSprite::createWithRenderTexture(t_pRt);m_pSprite->setFlipY(true);t_pLayerParent->addChild(m_pSprite)","title":"更改 cocos2d-x CCRenderTexture 的使用方式"},{"content":"解决办法： 　　1.VS平台上，选工具-选项-项目和解决方案-MS BUILD 项目生成输出详细信息中选择“诊断”，目的是在调试窗口中看出那个过程编译的时间最久。MOBILE平台一般问题都是出在PlatformVerificationTask上 　　2.进入.NET环境的安装位置：C:\\WINDOWS\\Microsoft.NET\\Framework\\v3.5 ，修改Microsoft.CompactFramework.Common.targets中关于PlatformVerificationTask的部分 　　3.参考上面的英文说明进行修改， 　　Name=\"PlatformVerificationTask\"> 　　修改成 　　Name=\"PlatformVerificationTask\" Condition=\"'$(SkipPlatformVerification)' == 'true'\"> 　　4.重启VS2008，进行编译看速度是否正常，若不正常，上面的TRUE值再改为FALSE，再重新启动VS2008，问题一般可解决。","title":"VS2008编译Windows Mobile项目很慢情况的解决办法"},{"content":"- (void)webViewDidFinishLoad:(UIWebView *)webView{    NSString *height_str= [webView stringByEvaluatingJavaScriptFromString: @\"document.body.offsetHeight\"];    int height = [height_str intValue];    webView.frame = CGRectMake(0,0,320,height);    NSLog(@\"height: %@\", [webView stringByEvaluatingJavaScriptFromString: @\"document.body.offsetHeight\"]);}废话不多说 上代码～～～求相互交流～","title":"UIWebView获得内容的高－作出自适应高的UIWebView"},{"content":"在oc中两个方法是否相同，与参数类型和返回值无关，之和方法名有关 如：在oc中的同一个累中出现这种函数形式就是错误的 -（void）theAge:(int)age name:(NSString *)name -(NSString *) theAge:(int)age name:(NSString *)name oc继承的语法规则是： @interface 子类:父类 权限控制： 修饰符                  类内部                      子类                        任何地方 private yes protected yes yes public yes yes                           yes 几个有关类的方法： -（BOOL）isKindOfClass:(Class)aClass;对象是不是aClass的成员或子类 -（BOOL）isMemberOfClass:(Class)aClass;对象是不是aClass成员 -（BOOL）isSubClassOfClass:(Class)aClass;对象是不是aClass的子类对象 -（BOOL）respondsToSelector:(SEL)aSelector;对象是否能响应aSelector指定的方法 -（id）performSelector:(SEL)aSelector;对象调用aSelector制定的方法 -（id）performSelector:(SEL)aSelector withObject:(id)object;对象调用aSelector制定的方法，传递参数object -（id）performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2 ;赌侠ing调用aSelector指定的方法，传递参数object1和object2","title":"[置顶] Objective-c权限控制"},{"content":"参考了http://www.cocoawithlove.com/2009/01/multiple-row-selection-and-editing-in.html的实现方法，我从他的方法中提取了最生要的部份，过滤了多余的部份，使代码容易读懂。 原理就是自定义UITableViewCell,在Cell的contentView的最左边放UIImageView，当cell选中的时候，cell的contentView向右移动，让UIImageView显示出来。原理很简单，也很容易实现。值得注意的一点是自定义的cell中一定要实现 - (void)setEditing:(BOOL)editing animated:(BOOL)animated{\t[self setNeedsLayout];}否则在编辑模式下会出现系统的delete button. 不多说，大家请下载源码来看，非常简单。我将源码上传到google code host.  svn checkout http://uitableview-multirowselect.googlecode.com/svn/trunk/ uitableview-multirowselect-read-only","title":"UITableView类似Email的多选删除功能实现"},{"content":"CGPoint position = CGPointMake(0, 142);         [hotScrollerView setContentOffset:position animated:YES];","title":"UIScrollView可以定位到滚动的具体位置，就这么简单"},{"content":"Android中要想实现短信拦截功能，要在AndroidManifest.xml文件中添加接收短信的权限，如下： <uses-permission android:name=\"android.permission.RECEIVE_SMS\"/> Android系统要想拦截短信，要使用广播接收器，所以要编写一个类实现短信拦截功能，这个类要继承BroadcastReceiver，并重写onReceive()方法，在这个方法中进行具体的拦截操作，代码如下： import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.telephony.SmsMessage;import android.util.Log;public class SMSMonitor extends BroadcastReceiver {\tprivate static final String ACTION = \"android.provider.Telephony.SMS_RECEIVED\";\t@Override        public void onReceive(Context context, Intent intent)        {\t    if(intent!=null && intent.getAction()!=null && ACTION.compareToIgnoreCase(intent.getAction())==0)\t    {\t        Object[]pduArray = (Object[]) intent.getExtras().get(\"pdus\");\t        SmsMessage[] messages = new SmsMessage[pduArray.length];\t        \t        for (int i = 0; i<pduArray.length; i++) {\t            messages[i] = SmsMessage.createFromPdu((byte[])pduArray [i]);\t            Log.d(\"SMSMonitor\", \"短信来自: \" + messages[i].getOriginatingAddress());\t            Log.d(\"SMSMonitor\", \"短信内容: \" + messages[i].getMessageBody());\t            \t            if(\"1008\".equals(messages[i].getOriginatingAddress())){//如果短信发送者是1008则拦截，这里就可以进行具体的操作了\t            \tthis.abortBroadcast();//结束广播发给别的程序，这样系统就不会收到短信广播\t                \t            }   \t\t\t\t           \t        }\t        Log.d(\"SMSMonitor\",\"SMS\");\t    }\t}} AndroidManifest.xml文件如下： <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"    package=\"com.example.sms\"    android:versionCode=\"1\"    android:versionName=\"1.0\" >    <uses-sdk        android:minSdkVersion=\"8\"        android:targetSdkVersion=\"15\" />    <uses-permission android:name=\"android.permission.RECEIVE_SMS\"/>    <application        android:icon=\"@drawable/ic_launcher\"        android:label=\"@string/app_name\"        android:theme=\"@style/AppTheme\" >                <receiver android:name=\"SMSMonitor\" >\t\t<intent-filter android:priority=\"1000\">\t\t\t<action android:name=\"android.provider.Telephony.SMS_RECEIVED\" />\t\t<\/intent-filter>\t<\/receiver>    <\/application><\/manifest>   解释：<intent-filter android:priority=\"1000\">设置这个接收器的优先级高于系统的其它短信的接收器，以使自己接收到SMS优先于系统或其它软件 交流探讨到我的新浪微博：http://weibo.com/tianrui1990 ","title":"Android短信拦截"},{"content":"现在生成ipad包的办法 无非是两种  一种是用91助手, itunes  同步 第二种 就是用xocde直接安装      这两种方式 如果是只安装 一台,两台 还好 如果要是需要安装 几百台 或者几千台 那么这个工作量就太大了   苹果早就想到这种情况了 于是苹果给了我们一个 更加方便的办法  准备步骤: 首先要确保 你的ipad iphone 都包含开发证书   其次 你要有一个 可以供外网访问的ftp地址  好了 现在准备就绪 开始制作  首先在选择设备中 选择  确保设备证书都正确  选择 product-Archive   生成后   选择  选择Save for Enterprise or.....  点击Next 此刻注意  图中 红色的区域名字要保持一致   Application URL   链接为外网可以访问到的地址          结尾为     “xxx”.ipa       选择Save   你就会发现   你保存的路径下 多出了 两个文件  进入到你的外网访问地址目录下  OrderMeet.ipa 和OrderMeet.plist 是我们刚刚生成的  那这个 install.html 是什么呢？ 我们打开看看  具体代码为 : <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"> <html>     <head>         <title>OrderMeet<\/title>     <\/head>     <body>         <ul>             <li><a href=\"itms-services://?action=download-manifest&url=http://192.168.1.88:8080/trends_home/Ordermeet_install/ipad/OrderMeet.plist\"> Free to download<\/a>             <\/li>         <\/ul>      <\/body> <\/html> 大家可以把这段代码复制下去   保存成 install.html 上面 http://192.168.1.88:8080/trends_home/Ordermeet_install/ipad/OrderMeet.plist  就是我们刚刚生成.ipa附带的plist文件 好了 以上步骤完成后  用你的ipad  或者iphone 的Sarfri  打开 http://192.168.1.88:8080/trends_home/Ordermeet_install/ipad/install.html 这个地址 点击 下载 稍等片刻 就会看到 ipa项目 已经安装到你的设备里了 。   我的iphone学习群: 151853771  喜欢的请加盟 !! ","title":"[置顶] 手把手叫你 制作一个不需要任何工具 从网页上安装ipa包的办法"},{"content":"工欲善其事，必先利其器。 下面我们就开始搭建Android开发环境。 我采用的方式非常简单，采用的是Android官方提供的ADT Bundle，下载地址http://developer.android.com/sdk/index.html，如果不能下载可以到http://down.51cto.com/data/607919下载。 下载后解压，文件夹中包含两个文件夹，分别为eclipse和sdk，进入eclipse文件夹打开eclipse.exe进行一下配置就可以使用了，配置步骤如下 Window ==> Preferences ==> Android ==> SDK Location选择SDK的安装目录，OK 当然有人用的是自己的eclipse，下载的sdk自己进行安装，本来我也这么干的，但是太麻烦，也没有成功，如果想那么干，可以找找android环境搭建教程，有很多。 直接下载的bundle可能sdk只有最新的，如需其他的版本，可以运行SDK Manager自行更新下载。","title":"[置顶] Android开发学习之二——Android开发环境搭建"},{"content":"最近在公司做一个移动客户端，混合应用模式开发，使用的Jquerymobile，自己对jquerymobile不是很熟悉，利用空闲的时间从头开始学习jquerymobile。希望通过自己的努力，和记录能够使自己对于jquerymobile有一定的了解。 花了几分钟写了一个jquerymobile的最简单的页面，学习每个技术都是先写hello XX，所以我这次第一次写的是hello jquerymobile。代码如下： <!doctype html><html><head>    <meta charset=\"utf-8\">    <title>第一个jquerymobile页面<\/title>    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />     <link rel=\"stylesheet\" href=\"jqm/jquery.mobile-1.2.0.min.css\"/>    <script src=\"jqm/jquery-1.8.2.min.js\"><\/script>    <script src=\"jqm/jquery.mobile-1.2.0.min.js\"><\/script><\/head><body>\t<div id=\"first\" data-role=\"page\">        <div id=\"header\" data-role=\"header\">        \t<h1>这是第一个jquerymobile页面<\/h1>        <\/div>        <div id=\"content\" data-role=\"content\">        \tHello Jquerymobile!!        <\/div>        <div id=\"footer\" data-role=\"footer\">        \t<h4>Footer<\/h4>        <\/div>    <\/div><\/body><\/html> 这是一个很简单的页面，但是有几点需要说明。 在代码中使用的是本地下载的css、js，但是真正做网站的时候不建议这样，建议使用jquerymobile的CDN去加载文件，代码如下： <link rel=\"stylesheet\" href=\"http://code.jquery.com/mobile/1.2.0/jquery.mobile-1.2.0.min.css\" /><script src=\"http://code.jquery.com/jquery-1.8.2.min.js\"><\/script><script src=\"http://code.jquery.com/mobile/1.2.0/jquery.mobile-1.2.0.min.js\"><\/script> 引用js的时候，一定要先写jquery然后再写jquerymobile，否则会出错。因为jquerymobile依赖jquery。 还有在head中的一段代码： <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" /> 这行代码的功能是：设置移动设备中浏览器缩放的宽度与等级。通常情况下，移动设备的浏览器默认以“900px”的宽度显示页面，这种宽度会导致屏幕缩小，页面放大，不适合浏览。如果在页面中添加 元素，并设置“content”的属性值为“width=device-width,initial-scale=1”，可以使页面的宽度与移动设备的屏幕宽度相同，更加适合用户浏览。 在代码中我们并没有对header和footer加什么样式，但是显示的结果是有样式的，这样的原因是jquerymobile自动为它们添加了样式。  ","title":"jquerymobile-1 第一个jquerymobile页面"},{"content":"今天把openmoko的qemu模拟器以及uboot加入到OpenWrt-Dreambox的支持行列中了 原本的OpenWrt是支持openmoko的，但是最新的OpenWrt一两个月之前把它删掉了，OpenWrt-Dreambox/trunk也没有放 如果想尝试openmoko，可以使用OpenWrt-Dreambox/bracnes/sun分支，它将是专门针对嵌入式开发板的分支： svn://svn.openwrt.org.cn/dreambox/branches/sun 下面放些qemu模拟器启动openmoko的照片，相比于android和qtopia，它别有另一番的感觉 这是uboot的界面 uboot的menu选项 开始启动内核 进度条 主界面  ","title":"OpenWrt-Dreambox支持openmoko以及其qemu模拟器啦"},{"content":"Android SDK 目录和作用的分析详解   1、add-ons这里面保存着附加库，比如GoogleMaps，当然你如果安装了OphoneSDK，这里也会有一些类库在里面。 2、docs这里面是Android SDKAPI参考文档，所有的API都可以在这里查到。 3、market_licensing作为AndroidMarket版权保护组件，一般发布付费应用到电子市场可以用它来反盗版。 4、platforms是每个平台的SDK真正的文件，里面会根据APILevel划分的SDK版本，这里就以Android2.2来说，进入后有一个android-8的文件夹，android-8进入后是Android2.2SDK的主要文件，其中ant为ant编译脚本，data保存着一些系统资源，images是模拟器映像文件，skins则是Android模拟器的皮肤，templates是工程创建的默认模板，android.jar则是该版本的主要framework文件，tools目录里面包含了重要的编译工具，比如aapt、aidl、逆向调试工具dexdump和编译脚本dx。 5、platform-tools保存着一些通用工具，比如adb、和aapt、aidl、dx等文件，Android123提示，这里和platforms目录中tools文件夹有些重复，主要是从android2.3开始这些工具被划分为通用了。 6、samples是Android SDK自带的默认示例工程，里面的apidemos强烈推荐初学者运行学习，对于SQLite数据库操作可以查看NotePad这个例子，对于游戏开发Snake、LunarLander都是不错的例子，对于Android主题开发Home则是androidm5时代的主题设计原理。 7、tools作为SDK根目录下的tools文件夹，这里包含了重要的工具，比如ddms用于启动Android调试工具，比如logcat、屏幕截图和文件管理器，而draw9patch则是绘制android平台的可缩放png图片的工具，sqlite3可以在PC上操作SQLite数据库，而monkeyrunner则是一个不错的压力测试应用，模拟用户随机按键，mksdcard则是模拟器SD映像的创建工具，emulator是Android SDK模拟器主程序，不过从android 1.5开始，需要输入合适的参数才能启动模拟器，traceview作为android平台上重要的调试工具。 8、usb_driver顾名思义，保存着android平台google官方机型的驱动如nexusone、nexuss，同时也有一些老机型驱动的支持，比如说htcdream、htcmagic和motorola的droid。   Android开发环境搭建所需资源、安装和配置步骤图解        Android海量源码、教程与资料   数字电视接口规范大全（行业标准）                      程序员必备：英语口语学习教程大全  20本Linux电子书学习教程                    2013年25家IT高科技公司薪酬排行榜   2013年Android平台8大预测                   优秀Android开发人员必须注意的10个误区  Android开发应该掌握的28大内容和10大建议      成为“Android高手”的6个境界  90后就业“钱景”分析:IT行业仍是最佳选择       90后就业“钱景”:IT仍是最佳选择 -------------------------------------------------------------------------------------------------------------- 终生受益的43个健康常识--值得珍藏                           面试如何着装：不同职位穿着大不同      2013年国内就业率最高的50个本科专业排名              女生面试如何着装及禁忌    50个“最有钱景专业”的毕业生年薪一览表               毕业后头5年决定你的一生  千万别熬夜:身体器官晚上工作时间表一览                  90后就业“钱景”:IT仍是最佳选择     --------------------------------------------------------------------------------------------------------------  211工程大学最新名单(共112所)                              985工程大学最新名单(共39所)  中国“国家实验室”最新名单（共20所）                 “特色985”大学最新名单（共29所）  2013年国内工科大学排名100强名单                          2013年中国大学580强排行榜  女孩教你追女孩的终极技巧                                       2013年世界各国人均GDP排名  中国各省市面积和人口最新排名                                世界各国国土面积和人口排名  经典英语口语学习教程和资料集合大全                     2013年25家IT高科技公司薪酬排行榜  --------------------------------------------------------------------------------------------------------------","title":"详解Android SDK 目录和作用"},{"content":"实现效果如下：ExpandableListView滑动的时候，父视图停留在activity的最上方。 关键代码如下： package com.telecom.video;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import android.app.Activity;import android.content.Context;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.view.ViewGroup.MarginLayoutParams;import android.widget.AbsListView;import android.widget.AbsListView.OnScrollListener;import android.widget.AdapterView;import android.widget.ExpandableListView;import android.widget.ExpandableListView.OnGroupClickListener;import android.widget.ExpandableListView.OnGroupCollapseListener;import android.widget.ExpandableListView.OnGroupExpandListener;import android.widget.LinearLayout;import android.widget.TextView;import com.telecom.video.beans.CityBeans;import com.telecom.video.beans.Province;import com.telecom.video.view.adp.CityListViewAdapter;/** * 城市选择列表 *  *  */public class CityListActivity extends Activity {\tpublic LinearLayout\t\t\tll_top;\tprivate int\t\t\t\t\tthe_group_expand_position\t= -1;\tprivate int\t\t\t\t\tindicatorGroupHeight;\tprivate boolean\t\t\t\tisExpanding\t\t\t\t\t= false;\tprivate TextView\t\t\ttv_citylist_province;\tprivate ExpandableListView\texpandableListView;\tprivate Context\t\t\t\tcontext;\t@Override\tprotected void onCreate(Bundle savedInstanceState) {\t\tsuper.onCreate(savedInstanceState);\t\tsetContentView(R.layout.city_list);\t\tcontext = CityListActivity.this;\t\tll_top = (LinearLayout) findViewById(R.id.ll_citylist_top);\t\tll_top.setVisibility(View.GONE);\t\ttv_citylist_province = (TextView) findViewById(R.id.tv_citylist_province);\t\texpandableListView = (ExpandableListView) findViewById(R.id.el_expandableListView);\t\tfinal List<Province> list = getLocalData();\t\tCityListViewAdapter adapter = new CityListViewAdapter(context, list);\t\texpandableListView.setAdapter(adapter);\t\texpandableListView.setGroupIndicator(null);\t\t// int groupCount = expandableListView.getCount();\t\t// for (int i = 0; i < groupCount; i++) {\t\t// expandableListView.expandGroup(i);\t\t// }\t\texpandableListView.setOnGroupExpandListener(new OnGroupExpandListener() {\t\t\t@Override\t\t\tpublic void onGroupExpand(int groupPosition) {\t\t\t\tthe_group_expand_position = groupPosition;\t\t\t\tll_top.setVisibility(View.VISIBLE);\t\t\t\t// lineView.setVisibility(View.VISIBLE);\t\t\t\tisExpanding = true;\t\t\t\tif (the_group_expand_position != -1) {\t\t\t\t\ttv_citylist_province.setText(list.get(the_group_expand_position).getInitial() + \"  \"\t\t\t\t\t\t\t+ list.get(the_group_expand_position).getProvince());\t\t\t\t}\t\t\t}\t\t});\t\texpandableListView.setOnGroupCollapseListener(new OnGroupCollapseListener() {\t\t\t@Override\t\t\tpublic void onGroupCollapse(int groupPosition) {\t\t\t\tif (isExpanding) {\t\t\t\t\tll_top.setVisibility(View.GONE);\t\t\t\t\t// lineView.setVisibility(View.GONE);\t\t\t\t}\t\t\t\tthe_group_expand_position = -1;\t\t\t\tisExpanding = false;\t\t\t}\t\t});\t\tll_top.setOnClickListener(new OnClickListener() {\t\t\t@Override\t\t\tpublic void onClick(View v) {\t\t\t\t// linear.setVisibility(View.GONE);\t\t\t\tif (isExpanding) {\t\t\t\t\tll_top.setVisibility(View.GONE);\t\t\t\t\t// lineView.setVisibility(View.GONE);\t\t\t\t\texpandableListView.collapseGroup(the_group_expand_position);\t\t\t\t\tisExpanding = false;\t\t\t\t}\t\t\t}\t\t});\t\texpandableListView.setOnGroupClickListener(new OnGroupClickListener() {\t\t\t@Override\t\t\tpublic boolean onGroupClick(ExpandableListView parent, View v, int groupPosition, long id) {\t\t\t\tif (the_group_expand_position == -1) {\t\t\t\t\texpandableListView.expandGroup(groupPosition);\t\t\t\t\texpandableListView.setSelectedGroup(groupPosition);\t\t\t\t\tthe_group_expand_position = groupPosition;\t\t\t\t\tll_top.setVisibility(View.VISIBLE);\t\t\t\t\t// lineView.setVisibility(View.VISIBLE);\t\t\t\t\tisExpanding = true;\t\t\t\t}\t\t\t\telse if (the_group_expand_position == groupPosition) {\t\t\t\t\t\t\t\tll_top.setVisibility(View.GONE);\t\t\t\t\t\t\t\t\t\texpandableListView.collapseGroup(groupPosition);\t\t\t\t\tthe_group_expand_position = -1;\t\t\t\t\tisExpanding = false;\t\t\t\t}\t\t\t\telse {\t\t\t\t\texpandableListView.collapseGroup(the_group_expand_position);\t\t\t\t\texpandableListView.expandGroup(groupPosition);\t\t\t\t\texpandableListView.setSelectedGroup(groupPosition);\t\t\t\t\tthe_group_expand_position = groupPosition;\t\t\t\t}\t\t\t\treturn true;\t\t\t}\t\t});\t\t\texpandableListView.setOnScrollListener(new OnScrollListener() {\t\t\t@Override\t\t\tpublic void onScrollStateChanged(AbsListView view, int scrollState) {}\t\t\t@Override\t\t\tpublic void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {\t\t\t\t\t\t\t\tint npos = view.pointToPosition(0, 0);\t\t\t\tif (npos != AdapterView.INVALID_POSITION) {\t\t\t\t\tlong pos = expandableListView.getExpandableListPosition(npos);\t\t\t\t\tint childPos = ExpandableListView.getPackedPositionChild(pos);\t\t\t\t\tint groupPos = ExpandableListView.getPackedPositionGroup(pos);\t\t\t\t\tif (childPos == AdapterView.INVALID_POSITION) {\t\t\t\t\t\tView groupView = expandableListView.getChildAt(npos\t\t\t\t\t\t\t\t- expandableListView.getFirstVisiblePosition());\t\t\t\t\t\tindicatorGroupHeight = groupView.getHeight();\t\t\t\t\t}\t\t\t\t\tif (indicatorGroupHeight == 0) {\t\t\t\t\t\treturn;\t\t\t\t\t}\t\t\t\t\tif (isExpanding) {\t\t\t\t\t\tif (the_group_expand_position != -1) {\t\t\t\t\t\t\ttv_citylist_province.setText(list.get(the_group_expand_position).getInitial() + \"  \"\t\t\t\t\t\t\t\t\t+ list.get(the_group_expand_position).getProvince());\t\t\t\t\t\t}\t\t\t\t\t\tif (the_group_expand_position != groupPos) {\t\t\t\t\t\t\tll_top.setVisibility(View.GONE);\t\t\t\t\t\t}\t\t\t\t\t\telse {\t\t\t\t\t\t\tll_top.setVisibility(View.VISIBLE);\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t}\t\t\t\tif (the_group_expand_position == -1) {\t\t\t\t\treturn;\t\t\t\t}\t\t\t\tint showHeight = t();\t\t\t\tMarginLayoutParams layoutParams = (MarginLayoutParams) ll_top.getLayoutParams();\t\t\t\tlayoutParams.topMargin = -(indicatorGroupHeight - showHeight);\t\t\t}\t\t});\t}\tprivate int t() {\t\tint showHeight = indicatorGroupHeight;\t\tint nEndPos = expandableListView.pointToPosition(0, indicatorGroupHeight);\t\tif (nEndPos != AdapterView.INVALID_POSITION) {\t\t\tlong pos = expandableListView.getExpandableListPosition(nEndPos);\t\t\tint groupPos = ExpandableListView.getPackedPositionGroup(pos);\t\t\tif (groupPos != the_group_expand_position) {\t\t\t\tView viewNext = expandableListView.getChildAt(nEndPos - expandableListView.getFirstVisiblePosition());\t\t\t\tshowHeight = viewNext.getTop();\t\t\t}\t\t}\t\treturn showHeight;\t}\tprivate List<Province> getLocalData() {\t\ttry {\t\t\tString[] cityData = this.getResources().getStringArray(R.array.arrays_city);\t\t\tString[] provinceData = this.getResources().getStringArray(R.array.arrays_province);\t\t\tMap<String, List<CityBeans>> map = new HashMap<String, List<CityBeans>>();\t\t\tList<Province> list = new ArrayList<Province>();\t\t\tfor (int i = 0; i < cityData.length; i++) {\t\t\t\tString item = cityData[i];\t\t\t\tString[] a = item.split(\"\\\\|\");\t\t\t\tCityBeans city = new CityBeans(a[0], a[1], a[2]);\t\t\t\tif (map.containsKey(city.getProvince())) {\t\t\t\t\tList<CityBeans> citys = map.get(city.getProvince());\t\t\t\t\tcitys.add(city);\t\t\t\t}\t\t\t\telse {\t\t\t\t\tList<CityBeans> citys = new ArrayList<CityBeans>();\t\t\t\t\tcitys.add(city);\t\t\t\t\tmap.put(city.getProvince(), citys);\t\t\t\t}\t\t\t}\t\t\tfor (int i = 0; i < provinceData.length; i++) {\t\t\t\tString item = provinceData[i];\t\t\t\tString[] a = item.split(\"\\\\|\");\t\t\t\tProvince province = new Province();\t\t\t\tprovince.setInitial(a[0]);\t\t\t\tprovince.setProvince(a[1]);\t\t\t\tif (map.containsKey(province.getProvince())) {\t\t\t\t\tprovince.setList_citys(map.get(province.getProvince()));\t\t\t\t}\t\t\t\tlist.add(province);\t\t\t}\t\t\treturn list;\t\t} catch (Exception e) {\t\t\te.printStackTrace();\t\t}\t\treturn null;\t}}布局： <?xml version=\"1.0\" encoding=\"utf-8\"?><FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    android:layout_width=\"fill_parent\"    android:layout_height=\"fill_parent\" >    <ExpandableListView        android:id=\"@+id/el_expandableListView\"        android:layout_width=\"fill_parent\"        android:layout_height=\"fill_parent\" >    <\/ExpandableListView>    <LinearLayout        android:id=\"@+id/ll_citylist_top\"        android:layout_width=\"fill_parent\"        android:layout_height=\"wrap_content\"        android:layout_gravity=\"center_horizontal\"        android:background=\"@drawable/city_province_bg\" >        <TextView            android:id=\"@+id/tv_citylist_province\"            android:layout_width=\"wrap_content\"            android:layout_height=\"wrap_content\"            android:layout_gravity=\"center_vertical\"            android:padding=\"5dp\" />    <\/LinearLayout><\/FrameLayout> 声明：参考了eoe上一个哥们的博客，具体的地址忘记了。 需要工程可以留言联系我。 马上元旦放假：顺道祝大家元旦快乐！游玩注意安全。","title":"android实现仿照QQ好友列表滑动效果"},{"content":"问题背景：一个Button同时设置了OnLongClick和OnClick监听。达到相机拍照，第一次长按聚焦，第二次点击拍照的效果。OnLongClick是由单独的线程执行的，如果返回false，则OnLongClick执行完毕后，会自动执行OnClick。 如果设置返回true，则OnLongClick触发执行完后便不会再执行OnClick了，这正要我要达到的效果。 参考：http://www.cnblogs.com/Tiger-Dog/articles/1944791.html","title":"Android：Button同时设置OnLongClick、OnClick模拟相机长按聚焦 短按拍照的功能"},{"content":"有时，Android系统控件无法满足我们的需求，因此有必要自定义View。具体方法参见官方开发文档：http://developer.android.com/guide/topics/ui/custom-components.html 一般来说，自定义控件都会去重写View的onMeasure方法，因为该方法指定该控件在屏幕上的大小。 protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) onMeasure传入的两个参数是由上一层控件传入的大小，有多种情况，重写该方法时需要对计算控件的实际大小，然后调用setMeasuredDimension(int, int)设置实际大小。 onMeasure传入的widthMeasureSpec和heightMeasureSpec不是一般的尺寸数值，而是将模式和尺寸组合在一起的数值。我们需要通过int mode = MeasureSpec.getMode(widthMeasureSpec)得到模式，用int size = MeasureSpec.getSize(widthMeasureSpec)得到尺寸。 mode共有三种情况，取值分别为MeasureSpec.UNSPECIFIED, MeasureSpec.EXACTLY, MeasureSpec.AT_MOST。 MeasureSpec.EXACTLY是精确尺寸，当我们将控件的layout_width或layout_height指定为具体数值时如andorid:layout_width=\"50dip\"，或者为FILL_PARENT是，都是控件大小已经确定的情况，都是精确尺寸。 MeasureSpec.AT_MOST是最大尺寸，当控件的layout_width或layout_height指定为WRAP_CONTENT时，控件大小一般随着控件的子空间或内容进行变化，此时控件尺寸只要不超过父控件允许的最大尺寸即可。因此，此时的mode是AT_MOST，size给出了父控件允许的最大尺寸。 MeasureSpec.UNSPECIFIED是未指定尺寸，这种情况不多，一般都是父控件是AdapterView，通过measure方法传入的模式。 因此，在重写onMeasure方法时要根据模式不同进行尺寸计算。下面代码就是一种比较典型的方式： @Override     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {         setMeasuredDimension(getMeasuredLength(widthMeasureSpec, true), getMeasuredLength(heightMeasureSpec, false));     }               private int getMeasuredLength(int length, boolean isWidth) {         int specMode = MeasureSpec.getMode(length);         int specSize = MeasureSpec.getSize(length);         int size;         int padding = isWidth ? getPaddingLeft() + getPaddingRight()                 : getPaddingTop() + getPaddingBottom();         if (specMode == MeasureSpec.EXACTLY) {             size = specSize;         } else {             size = isWidth ? padding + mWave.length / 4 : DEFAULT_HEIGHT                     + padding;             if (specMode == MeasureSpec.AT_MOST) {                 size = Math.min(size, specSize);             }         }         return size;     } ","title":"Android中自定义View的MeasureSpec使用"},{"content":"在Android中，Activity和View都能接收触摸和按键事件，如果响应事件只需要在继承类里复写事件函数即可。 1.在只有Activity的情况： 1）Touch事件触发流程：    首先触发dispatchTouchEvent   然后触发onUserInteraction   再次onTouchEvent   如果是点击的话，紧跟着下列事件（点击分俩步，ACTION_DOWN,ACTION_up)   触发dispatchTouchEvent   再次onTouchEvent   当ACTION_up事件时不会触发onUserInteraction（可查看源代码） 2）键盘事件触发流程：  首先触发dispatchKeyEvent 然后触发onUserInteraction 再次onKeyDown 如果按下紧接着松开，则是俩步 紧跟着触发dispatchKeyEvent 然后触发onUserInteraction 再次onKeyUp 注意与触摸不同，当松开按键时onUserInteraction也会触发。 　总之：  Activity.dispatchTouchEvent(MotionEvent) - 这允许你的活动可以在分发给窗口之前捕获所有的触摸事件。（同理 dispatchKeyEvent） 2.Activity里有一个Layout,在Layout里有个按钮情况： 如果在按钮上触发一个CLICK事件，那么事件传递流程： 首先触发ACTIVITY的dispatchTouchEvent然后触发ACTIVITY的onUserInteraction然后触发LAYOUT的dispatchTouchEvent然后触发LAYOUT的onInterceptTouchEvent然后触发BUTTON的onTouch（这是一个ACTION_DOWN事件）紧跟着是一个ACTION_UP事件触发ACTIVITY的dispatchTouchEvent注意不再触发ACTIVITY的onUserInteraction，因为他对ACTION_UP不起作用。然后触发LAYOUT的dispatchTouchEvent然后触发LAYOUT的onInterceptTouchEvent然后触发BUTTON的onTouch最后触发BUTTON的onClick.如果你在ONTOUCH事件里返回true,消费了此事件，那么ONCLICK将不会被响应但是如果你不写ONCLICK事件，而ONTOUCH事件返回FLASE 以上摘录：http://blog.csdn.net/G_rrrr/article/details/4861189　　 3.总结： Android事件触发流程： ------------------------------------------------------------------- 首先触发ACTIVITY的dispatchTouchEvent 然后触发ACTIVITY的onUserInteraction 然后触发LAYOUT的dispatchTouchEvent 然后触发LAYOUT的onInterceptTouchEvent ------------------------------------------------------------------- 查看：http://hi.baidu.com/lck0502/blog/item/7eeb452a846ff196023bf654.html ================================================================================================================= 在ViewGroup（即上面Layout）情况特别分析： 针对由于触摸（Touch）而触发的事件。 Android的事件：onClick, onScroll, onFling等等，都是由许多个Touch组成的。其中Touch的第一个状态肯定是ACTION_DOWN, 表示按下了屏幕。之后，touch将会有后续事件，可能是： ACTION_MOVE //表示为移动手势 ACTION_UP //表示为离开屏幕 ACTION_CANCEL //表示取消手势，不会由用户产生，而是由程序产生的 一个Action_DOWN, n个ACTION_MOVE, 1个ACTION_UP，就构成了Android中众多的事件。 在Android中，有一类控件是中还可以包含其他的子控件，这类控件是继承于ViewGroup类，例如：ListView, Gallery, GridView。 还有一类控件是不能再包含子控件，例如：TextView。 本文的主要讨论对象就是ViewGroup类的控件嵌套时事件触发情况。 对于ViewGroup类的控件，有一个很重要的方法，就是onInterceptTouchEvent()，用于处理事件并改变事件的传递方向，它的返回值是一个布尔值，决定了Touch事件是否要向它包含的子View继续传递，这个方法是从父View向子View传递。 而方法onTouchEvent()，用于接收事件并处理，它的返回值也是一个布尔值，决定了事件及后续事件是否继续向上传递，这个方法是从子View向父View传递。 Touch事件在 onInterceptTouchEvent()和onTouchEvent以及各个childView间的传递机制完全取决于onInterceptTouchEvent()和onTouchEvent()的返回值。返回值为true表示事件被正确接收和处理了，返回值为false表示事件没有被处理，将继续传递下去（只是传递方向不一样，onInterceptTouchEvent()向子View传，而onTouchEvent()向父View传)。 具体情况如下： ACTION_DOWN事件会传到某个ViewGroup类的onInterceptTouchEvent，如果返回false，则DOWN事件继续向子ViewGroup类的onInterceptTouchEvent传递，如果子View不是ViewGroup类的控件，则传递给它的onTouchEvent。 如果onInterceptTouchEvent返回了true,则DOWN事件传递给它的onTouchEvent，不再继续传递，并且之后的后续事件也都传递给它的onTouchEvent。 如果某View的onTouchEvent返回了false，则DOWN事件继续向其父ViewGroup类的onTouchEvent传递；如果返回了true，则后续事件会直接传递给其onTouchEvent继续处理。（后续事件只会传递给对于必要事件ACTION_DOWN返回了true的onTouchEvent） 总结一下就是：onInterceptTouchEvent可以接受到所有的Touch事件，而onTouchEvent则不一定。","title":"Android Activity 和 ViewGroup中事件触发和传递机制"},{"content":"当我们自定义了一个UIButton时，如果采用重绘的方式，将drawRect事件重写了，原有自带的点击的效果就没有了，这时，我们也要自己来重新写的。 例如下面效果的按钮 - (id) initWithFrame:(CGRect)frame { if ((self = [super initWithFrame:frame])) { [self addObserver:self forKeyPath:@\"highlighted\" options:0 context:nil]; //增加对highlighted属性的观察 } return self; } -(void)dealloc { [self removeObserver:self forKeyPath:@\"highlighted\"];//移除对highlighted属性的观察 [super dealloc]; } -(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context { if ([keyPath isEqualToString:@\"highlighted\"]) { [self setNeedsDisplay];//当按钮被按下时，重绘按钮 } } 完整代码请点这里","title":"自定义UIButton--iPhone按钮控件点击效果写法"},{"content":"公司给配了台新的macbook pro ，高兴了很久，当当我装不上svn 的时候，有种不想用的冲动。  1.  装完xcode 4.5之后 ，xcode 自带SVN  但是你需要下载一个 command Toools  跟xcode 4.5 是集成在一起的打开Xcode ，点击菜单项“Xcode”-“Preferences”（快捷键：Command+,），然后选择“DownLoads”页面，然后下载安装 “Command Line Tools”：   2.  下载完之后打开终端 在里面 ：  svn ls  你的svn路径    例如 svn：n ls https://192.168.1.205:8443/svn/AugustXcodeProBackUp    输入完毕后 ，让你输入 安装程序的密码，  然后就是用户名，密码 。 如果输入错误会有相关的提示，错误的原因只有一个要么是过期 要么就是密码不对。   3 点开 xode 首页 ，点击connect to a repository  ，在location中填入 svn的地址，出现next ，点击继续，在继续，再输入这个地址的时候 注意： 有的版本是输入 你在终端中的那个地址就OK  但是我发现我的行不通，后面的解决办法是 在你的ip地址前面加上   svn://用户名+@+svn路径 就ok了  如：https://xxxxx@192.168.1.205:8443/svn/AugustXcodeProBackUp  ","title":"xcode 4.5 装在SVN"},{"content":"使用NSLog记录日志是很方便的操作，但是有时候也希望能够像C/C++编程一样使用一些预定义的宏，比如获取当前文件名、行号等，在XCode中其实也有这样的功能。 XCode的c预处理器提供了一些标准宏，另外Objective-C语言还提供了隐含的_cmd参数，可以用来获取当前方法的selector，以及将selector与class转换为字符串的函数。 可以在NSLog中使用这些宏及函数来增强日志功能。 能够在c/c++/Objective-C中使用的预处理宏有： 宏 格式 描述 __func__  %s 当前函数名 __LINE__ %d 当前行号 __FILE__  %s 当前文件名，包含完整的路径信息 __PRETTY_FUNCTION__ %s  与__func__类似，但是函数名中包含了c++类型信息 能够在Objective-C中使用的表达式/函数有： 函数 格式 描述 NSStringFromSelector(_cmd) %@  返回当前selector名 NSStringFromClass([self class])  %@ 返回当前对象的类名 [[NSString stringWithUTF8String:__FILE__] lastPathComponent] %@ 返回当前文件名，不含路径信息 [NSThread callStackSymbols]  %@ 返回当前调用栈信息 注意：Log尽量不要让最终用户可以看到，防止敏感信息泄露。","title":"Objective C Log日志提高 预定义宏使用"},{"content":"从通知栏中选IME的子类型 Android系统会管理所有的由IME所暴露的子类型。IME子类型被视为IME的从属模式。在通知栏中，用户能够给当前的IME选择一个有效的子类型，如下图所示： 图4.从通知栏中选择IME子类型。 图5.在系统设置中设置你喜好的子类型。 从系统设置中选择IME子类型 用户能够在系统设置区的“Language&input”设置面板中控制如何使用子类型。在软键盘的示例中，InputMethodSettingsFragment.java文件中包含了在IME设置中方便启用子类型的的实现。更多信息请参照Android SDK中的SoftKeyboard示例。 图6.选择IME的语言。 通常IME要考虑的因素 在实现你的IME时，还要考虑以下事情： 1. 在IME的UI中为用户提供直接的设置选项； 2. 因为在设备上可以安装多种IME，因此要在输入法的UI中给用户提供直接切换IME的方法； 3.  要快速的显示IME的UI，因此要按照需要来预装或加载大尺寸的资源，以便用户在进入文本域后就能看到该IME。要缓存资源和视图，以便输入法的后续调用。 4. 相反，在输入窗口被隐藏后，你应该释放大块的内存占用，以便应用程序能够有足够的内存来运行。如果IME的隐藏需要几秒钟，那么要考虑使用延迟消息来释放资源。 5. 确保用户能够尽可能多的输入与IME相匹配的语言的字符。要记住，用户可以在密码或用户名称中使用标点符号，因此你的IME有必要提供不同的字符来让用户输入口令并获得对设备的访问。  ","title":"Android的文本和输入---创建输入法（五）"},{"content":"      首先还是一贯作风，我们先看案例：                              静态图看不出来效果，如果用过此软件（扎客）的同学们都知道，她的背景会动.怎么样，是不是觉得很时尚,起码比静态的要好(个人观点).其实实现起来并不复杂，这个如果让做游戏程序员做简直太小儿科了，这里我说明一点，其实我们做应用的也应该多少了解下游戏编程思维，起码对我们做应用有很好的帮助.       下面我简单介绍下实现方式.        实现原理：自定义一个SurfaceView控件.对之不停的onDraw,使得其背景动起来.        对于SurfaceView如果不了解的同学们麻烦你先上网查找下，网上相关介绍很多.        这里我简单介绍下其功能：首先这个控件是View的子类.好处就是可以在线程中（非UI线程）对UI进行更新. MySurfaceView.java package com.jj.dynamic;import android.content.Context;import android.graphics.Bitmap;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.PorterDuff;import android.util.AttributeSet;import android.view.SurfaceHolder;import android.view.SurfaceView;import android.view.SurfaceHolder.Callback;public class MySurfaceView extends SurfaceView implements Callback, Runnable {\tprivate Context mContext;\tprivate SurfaceHolder surfaceHolder;\tprivate boolean flag = false;// 线程标识\tprivate Bitmap bitmap_bg;// 背景图\tprivate float mSurfaceWindth, mSurfaceHeight;// 屏幕宽高\tprivate int mBitposX;// 图片的位置\tprivate Canvas mCanvas;\tprivate Thread thread;\t// 背景移动状态\tprivate enum State {\t\tLEFT, RINGHT\t}\t// 默认为向左\tprivate State state = State.LEFT;\tprivate final int BITMAP_STEP = 1;// 背景画布移动步伐.\tpublic MySurfaceView(Context context, AttributeSet attrs) {\t\tsuper(context, attrs);\t\tflag = true;\t\tthis.mContext = context;\t\tsetFocusable(true);\t\tsetFocusableInTouchMode(true);\t\tsurfaceHolder = getHolder();\t\tsurfaceHolder.addCallback(this);\t}\t/***\t * 进行绘制.\t */\tprotected void onDraw() {\t\tdrawBG();\t\tupdateBG();\t}\t/***\t * 更新背景.\t */\tpublic void updateBG() {\t\t/** 图片滚动效果 **/\t\tswitch (state) {\t\tcase LEFT:\t\t\tmBitposX -= BITMAP_STEP;// 画布左移\t\t\tbreak;\t\tcase RINGHT:\t\t\tmBitposX += BITMAP_STEP;// 画布右移\t\t\tbreak;\t\tdefault:\t\t\tbreak;\t\t}\t\tif (mBitposX <= -mSurfaceWindth / 2) {\t\t\tstate = State.RINGHT;\t\t}\t\tif (mBitposX >= 0) {\t\t\tstate = State.LEFT;\t\t}\t}\t/***\t * 绘制背景\t */\tpublic void drawBG() {\t\tmCanvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR);// 清屏幕.\t\tmCanvas.drawBitmap(bitmap_bg, mBitposX, 0, null);// 绘制当前屏幕背景\t}\t@Override\tpublic void run() {\t\twhile (flag) {\t\t\tsynchronized (surfaceHolder) {\t\t\t\tmCanvas = surfaceHolder.lockCanvas();\t\t\t\tonDraw();\t\t\t\tsurfaceHolder.unlockCanvasAndPost(mCanvas);\t\t\t\ttry {\t\t\t\t\tThread.sleep(100);\t\t\t\t} catch (InterruptedException e) {\t\t\t\t\te.printStackTrace();\t\t\t\t}\t\t\t}\t\t}\t}\t@Override\tpublic void surfaceCreated(SurfaceHolder holder) {\t\tmSurfaceWindth = getWidth();\t\tmSurfaceHeight = getHeight();\t\tint mWindth = (int) (mSurfaceWindth * 3 / 2);\t\t/***\t\t * 将图片缩放到屏幕的3/2倍.\t\t */\t\tbitmap_bg = BitmapUtil.ReadBitmapById(mContext, R.drawable.hypers_bg,\t\t\t\t(int) mWindth, (int) mSurfaceHeight);\t\tthread = new Thread(this);\t\tthread.start();\t}\t@Override\tpublic void surfaceChanged(SurfaceHolder holder, int format, int width,\t\t\tint height) {\t}\t@Override\tpublic void surfaceDestroyed(SurfaceHolder holder) {\t\tflag = false;\t}}上诉代码相当简单，我也不过多介绍.相信大家都看得懂. 下面是我们只需要在Main.xml中引用即可. <?xml version=\"1.0\" encoding=\"utf-8\"?><com.jj.dynamic.MySurfaceView xmlns:android=\"http://schemas.android.com/apk/res/android\"    android:layout_width=\"fill_parent\"    android:layout_height=\"fill_parent\" ><\/com.jj.dynamic.MySurfaceView>这个的效果图我就不展示了.就是一个时时变动的背景图片，下面我展示下我最近在开发的一个内部小型项目，针对开年会娱乐场所用的.（里面东西都是会动的.）看是简单我加了好多动画特效，做这个页面花了我一个星期呢.             怎么样，看起来还不错吧.其实我只是想说明一点.我们应用中完全可以把游戏融入进去，这样我们可以得到另一番景象，不过话说回来，这样也会带来相应的负面影响，因为都是画上去的，所以工作量也会翻倍.总之根据自己需要来开发就好了. 下面我上传下APK，大家可以下载安装下看看，说不定你可以从中找到灵感. HypersParty.apk 下面我们再看一个页面： 我想说明的是这个密码后面的EditText的问题，要加上去很简单，我们直接可以通过布局搞定，下面我们看布局文件 这里我没有上布局文件代码，是因为我觉得看这个视图更好理解一点，不是么，有很多一上来就把布局文件啪啦啪啦贴出来，还得读取半天. 我说下诡异问题.看下面张图片： 这张图片是我点击键盘后让键盘小时候的结果（注：此时软键盘可以遮挡输入框）.其实如果你再次点击edittext，其实它还在原位，只是surfaceView在绘制的时候影响到了，原因不明.(下面我说个更诡异的问题，真是一个接一个，弄的我有想摔手机的心都有了.我的测试机是华为S8600,android2.3的，然后我用oppo手机android4.0测试的时候用截图工具竟然截不出来上面这张bug图片，手机助手显示是OK，但是手机上显示是BUG，NND,当时郁闷的要死，不管了这也不是重点.) 解决方法很简单：我们只需要在我们的activity中执行这段话就ok了.(同样适用于自定义的dialog.) \t\tgetWindow().setSoftInputMode(\t\t\t\tWindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE\t\t\t\t\t\t| WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN);网上有的说可以在配置文件中配置，可是我配置了竟然无动于衷.大家可以去研究研究，总之代码这种方案可行. 效果图： 问题又出来了，看着怎么这么别扭呢，为什么密码跑了那么高呢? 这个问题没有解决，希望同学们有解决方案的朋友们麻烦告知下，（尝试多次不行，个人感觉系统是以edittext为对象，将之弹起，中间的距离和edittext本身在布局中的位置有关，如果在底部的话，那么正好在键盘的上面）。 有文章说   getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN); 这句话可以解决，可惜试了试不尽人意. 总之看着还说的过去，临时就这样了，昨天在群里问了问，有朋友们提出，弄一个透明的dialog，activity，想想虽然没有这么搞的，但是确实可行，只要你处理得好，根本看不出来他们不是一个布局. 最后简单说明一点：其实在surfaceView中一般不需要加edittext控件的，比如说游戏，即使要的话，也会弹出一个性感的dialog.在其中加载控件（尤其是edittext）几乎就不会有这样的需求，即使有了，我们换个思维实现就OK了.","title":"android 动态背景的实现以及SurfaceView中添加EditText控件"},{"content":"android 有一个闹铃管理的东西叫:AlarmManager;这个用来管理闹铃的发起和停止,我们可以service,broadcastreceiver或Activity来接受AlarmManager发出的信息,AlarmManager类通过getSystemService(Activity.ALARM_SERVICE)方法来实例化;在这里注意下这几个方法:     // 取消已经注册的与参数匹配的闹铃        void cancel(PendingIntent operation)              //注册一个新的闹铃       void set( int  type,  long  triggerAtTime, PendingIntent operation)              //注册一个重复类型的闹铃       void setRepeating( int  type,  long  triggerAtTime,  long  interval, PendingIntent operation)                //设置时区       void setTimeZone(String timeZone)  再来介绍下闹铃的几种样式: public static final int ELAPSED_REALTIME        //当系统进入睡眠状态时，这种类型的闹铃不会唤醒系统。直到系统下次被唤醒才传递它，该闹铃所用的时间是相对时间，是从系统启动后开始计时的,包括睡眠时间，可以通过调用SystemClock.elapsedRealtime()获得。系统值是3。        public static final int ELAPSED_REALTIME_WAKEUP        //能唤醒系统，用法同ELAPSED_REALTIME，系统值是2  。        public static final int RTC        //当系统进入睡眠状态时，这种类型的闹铃不会唤醒系统。直到系统下次被唤醒才传递它，该闹铃所用的时间是绝对时间，所用时间是UTC时间，可以通过调用 System.currentTimeMillis()获得。系统值是1 (0x00000001) 。        public static final int RTC_WAKEUP        //能唤醒系统，用法同RTC类型，系统值为 0 。        Public static final int POWER_OFF_WAKEUP        //能唤醒系统，它是一种关机闹铃，就是说设备在关机状态下也可以唤醒系统，所以我们把它称之为关机闹铃。使用方法同RTC类型，系统值为4。 下面看下小DEMO: 入口:AlarmActivity package com.glacier.demo;import java.util.Calendar;import android.app.Activity;import android.app.AlarmManager;import android.app.PendingIntent;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.DatePicker;import android.widget.DatePicker.OnDateChangedListener;import android.widget.TextView;import android.widget.TimePicker;import android.widget.TimePicker.OnTimeChangedListener;/*** * 闹铃管理(提示:设置过去的时间会一直提示:大家在把时间设置成闹铃的时间取消即可) * @author wangyubin * */public class AlarmActivity extends Activity implements OnClickListener {\tprivate TextView mTitleTv, mDatePickerTv, mTimePickerTv;\tprivate DatePicker mDatePicker;\tprivate TimePicker mTimePicker;\tprivate Button mInstallBtn, mCancelBtn;\tprivate Calendar calendar;\tprivate int year, month, day, hour, minute;\t@Override\tpublic void onCreate(Bundle savedInstanceState) {\t\tsuper.onCreate(savedInstanceState);\t\tsetContentView(R.layout.activity_alarm);\t\tinit();\t}\tprivate void init() {\t\tmTitleTv = (TextView) findViewById(R.id.tv_title);\t\tmDatePicker = (DatePicker) findViewById(R.id.datePicker);\t\tmTimePicker = (TimePicker) findViewById(R.id.timePicker);\t\tmDatePickerTv = (TextView) findViewById(R.id.tv_datepicker);\t\tmTimePickerTv = (TextView) findViewById(R.id.tv_timepicker);\t\tmInstallBtn = (Button) findViewById(R.id.btn_install);\t\tmCancelBtn = (Button) findViewById(R.id.btn_cancel);\t\tcalendar = Calendar.getInstance();\t\t// 得到当前时间并设置到日历里面\t\tcalendar.setTimeInMillis(System.currentTimeMillis());\t\t// 获取到当前的时间\t\tyear = calendar.get(Calendar.YEAR);\t\tmonth = calendar.get(Calendar.MONTH);\t\tday = calendar.get(Calendar.DATE);\t\thour = calendar.get(Calendar.HOUR_OF_DAY);\t\tminute = calendar.get(Calendar.MINUTE);\t\t// 设置date控件的初始化以及监听\t\tmDatePicker.init(year, month, day, new OnDateChangedListener() {\t\t\tpublic void onDateChanged(DatePicker view, int year,\t\t\t\t\tint monthOfYear, int dayOfMonth) {\t\t\t\tmDatePickerTv.setText(\"您选择的日期是：\" + year + \"年\"\t\t\t\t\t\t+ (monthOfYear + 1) + \"月\" + dayOfMonth + \"日\");\t\t\t\tAlarmActivity.this.year = year;\t\t\t\tAlarmActivity.this.month = monthOfYear;\t\t\t\tAlarmActivity.this.day = dayOfMonth;\t\t\t}\t\t});\t\t// 设置24小时制\t\tmTimePicker.setIs24HourView(true);\t\tmTimePicker.setOnTimeChangedListener(new OnTimeChangedListener() {\t\t\tpublic void onTimeChanged(TimePicker view, int hourOfDay, int minute) {\t\t\t\tmTimePickerTv.setText(\"您选择的时间是：\" + hourOfDay + \"时\" + minute\t\t\t\t\t\t+ \"分\");\t\t\t\tAlarmActivity.this.hour = hourOfDay;\t\t\t\tAlarmActivity.this.minute = minute;\t\t\t}\t\t});\t\t// 设置闹铃按钮监听\t\tmInstallBtn.setOnClickListener(this);\t\tmCancelBtn.setOnClickListener(this);\t}\t@Override\tpublic void onClick(View v) {\t\t// TODO Auto-generated method stub\t\tswitch (v.getId()) {\t\t// 这里讲一个我们遇到的命名的问题:仔细看case后面都带一个大括号,这样里面的switch里面的局部变量就变成了单独的case里面的局部变量,防止命名冲突\t\tcase R.id.btn_install: {\t\t\t// 设置闹铃的时间(年,月,日,时,分,秒)\t\t\tcalendar.set(year, month, day, hour, minute, 0);\t\t\tIntent intent = new Intent(this, AlamrReceiver.class);\t\t\t// 设置intent的动作,识别当前设置的是哪一个闹铃,有利于管理闹铃的关闭\t\t\tintent.setAction(year + \"年\" + month + \"月\" + day + \"日\" + hour + \"时\"\t\t\t\t\t+ minute + \"分\");\t\t\t// 用广播管理闹铃\t\t\tPendingIntent pi = PendingIntent.getBroadcast(this, 0, intent, 0);\t\t\t// 获取闹铃管理\t\t\tAlarmManager am = (AlarmManager) getSystemService(Activity.ALARM_SERVICE);\t\t\t// 设置闹钟\t\t\tam.set(AlarmManager.RTC_WAKEUP, calendar.getTimeInMillis(), pi);\t\t\t// 设置闹钟重复时间\t\t\tam.setRepeating(AlarmManager.RTC_WAKEUP,\t\t\t\t\tcalendar.getTimeInMillis(), 10 * 1000, pi);\t\t\t// 获取到的月份是0~11,所以要加1\t\t\tint newMonth = month + 1;\t\t\tmTitleTv.setText(\"您选择的闹铃为:\" + year + \"年\" + newMonth + \"月\" + day\t\t\t\t\t+ \"日\" + hour + \"时\" + minute + \"分\");\t\t\tbreak;\t\t}\t\tcase R.id.btn_cancel: {\t\t\tIntent intent = new Intent(this, AlamrReceiver.class);\t\t\t// 找出当前控件选择的闹铃时间,并关闭当前选择的闹铃\t\t\tintent.setAction(year + \"年\" + month + \"月\" + day + \"日\" + hour + \"时\"\t\t\t\t\t+ minute + \"分\");\t\t\tPendingIntent pi = PendingIntent.getBroadcast(this, 0, intent, 0);\t\t\tAlarmManager am = (AlarmManager) getSystemService(Activity.ALARM_SERVICE);\t\t\tam.cancel(pi);\t\t\tint newMonth = month + 1;\t\t\tmTitleTv.setText(\"您取消了\" + year + \"年\" + newMonth + \"月\" + day + \"日\"\t\t\t\t\t+ hour + \"时\" + minute + \"分\" + \"的闹铃!!!\");\t\t\tbreak;\t\t}\t\t}\t}}下面看下广播的接收: package com.glacier.demo;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.widget.Toast;/** * 闹铃接受器 * @author wangyubin * */public class AlamrReceiver  extends BroadcastReceiver {        @Override      public void onReceive(Context context, Intent intent) {          // TODO Auto-generated method stub         Toast.makeText(context, \"闹钟时间到:\"+intent.getAction(), Toast.LENGTH_LONG).show();      }  } 这个广播需要注册成: <receiver            android:name=\".AlamrReceiver\"            android:process=\":remote\" >        <\/receiver> android:process=\":remote\" 要注意是为了这个广播能被AlarmManager调用 还有布局文件activity_alarm: <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:tools=\"http://schemas.android.com/tools\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\"    android:layout_gravity=\"center_horizontal\"    android:orientation=\"vertical\" >    <TextView        android:id=\"@+id/tv_title\"        android:layout_width=\"fill_parent\"        android:layout_height=\"wrap_content\"        android:gravity=\"center\"        android:text=\"@string/btn_install\" />    <DatePicker        android:id=\"@+id/datePicker\"        android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\"        android:layout_marginTop=\"27dp\" />    <TextView        android:id=\"@+id/tv_datepicker\"        android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\" />    <TimePicker        android:id=\"@+id/timePicker\"        android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\" />        <TextView        android:id=\"@+id/tv_timepicker\"        android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\" />    <LinearLayout        android:layout_width=\"fill_parent\"        android:layout_height=\"wrap_content\"        android:orientation=\"horizontal\" >        <Button            android:id=\"@+id/btn_install\"            android:layout_width=\"wrap_content\"            android:layout_height=\"wrap_content\"            android:layout_marginTop=\"10dp\"            android:layout_weight=\"1\"            android:text=\"@string/btn_install\" />        <Button            android:id=\"@+id/btn_cancel\"            android:layout_width=\"wrap_content\"            android:layout_height=\"wrap_content\"            android:layout_marginTop=\"10dp\"            android:layout_weight=\"1\"            android:text=\"@string/btn_cancel\" />    <\/LinearLayout><\/LinearLayout> 还有两个String: <string name=\"btn_install\">设置闹铃<\/string> <string name=\"btn_cancel\">取消闹铃<\/string> 看真机下效果:想抓弹出来的吐司没抓到 猿码:点击打开下载","title":"[置顶] android 设置单个闹铃并取消单个闹铃"},{"content":"下面的内容是对其他人基于vi命令的一个总结，所以说应该是比较全面的。很高兴与大家分享。 进入vi的命令 vi filename :打开或新建文件，并将光标置于第一行首 vi +n filename ：打开文件，并将光标置于第n行首 vi + filename ：打开文件，并将光标置于最后一行首 vi +/pattern filename：打开文件，并将光标置于第一个与pattern匹配的串处 vi -r filename ：在上次正用vi编辑时发生系统崩溃，恢复filename vi filename....filename ：打开多个文件，依次进行编辑 移动光标类命令 h ：光标左移一个字符 l ：光标右移一个字符 space：光标右移一个字符 Backspace：光标左移一个字符 k或Ctrl+p：光标上移一行 j或Ctrl+n ：光标下移一行 Enter ：光标下移一行 w或W ：光标右移一个字至字首 b或B ：光标左移一个字至字首 e或E ：光标右移一个字至字尾 ) ：光标移至句尾 ( ：光标移至句首 }：光标移至段落开头 {：光标移至段落结尾 nG：光标移至第n行首 n+：光标下移n行 n-：光标上移n行 n$：光标移至第n行尾 H ：光标移至屏幕顶行 M ：光标移至屏幕中间行 L ：光标移至屏幕最后行 0：（注意是数字零）光标移至当前行首 $：光标移至当前行尾 屏幕翻滚类命令 Ctrl+u：向文件首翻半屏 Ctrl+d：向文件尾翻半屏 Ctrl+f：向文件尾翻一屏 Ctrl＋b；向文件首翻一屏 nz：将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部。 插入文本类命令 i ：在光标前 I ：在当前行首 a：光标后 A：在当前行尾 o：在当前行之下新开一行 O：在当前行之上新开一行 r：替换当前字符 R：替换当前字符及其后的字符，直至按ESC键 s：从当前光标位置处开始，以输入的文本替代指定数目的字符 S：删除指定数目的行，并以所输入文本代替之 ncw或nCW：修改指定数目的字 nCC：修改指定数目的行 删除命令 ndw或ndW：删除光标处开始及其后的n-1个字 do：删至行首 d$：删至行尾 ndd：删除当前行及其后n-1行 x或X：删除一个字符，x删除光标后的，而X删除光标前的 Ctrl+u：删除输入方式下所输入的文本 搜索及替换命令 /pattern：从光标开始处向文件尾搜索pattern ?pattern：从光标开始处向文件首搜索pattern n：在同一方向重复上一次搜索命令 N：在反方向上重复上一次搜索命令 ：s/p1/p2/g：将当前行中所有p1均用p2替代 ：n1,n2s/p1/p2/g：将第n1至n2行中所有p1均用p2替代 ：g/p1/s//p2/g：将文件中所有p1均用p2替换 选项设置 all：列出所有选项设置情况 term：设置终端类型 ignorance：在搜索中忽略大小写 list：显示制表位(Ctrl+I)和行尾标志（$) number：显示行号 report：显示由面向行的命令修改过的数目 terse：显示简短的警告信息 warn：在转到别的文件时若没保存当前文件则显示NO write信息 nomagic：允许在搜索模式中，使用前面不带“\\”的特殊字符 nowrapscan：禁止vi在搜索到达文件两端时，又从另一端开始 mesg：允许vi显示其他用户用write写到自己终端上的信息 最后行方式命令 ：n1,n2 co n3：将n1行到n2行之间的内容拷贝到第n3行下 ：n1,n2 m n3：将n1行到n2行之间的内容移至到第n3行下 ：n1,n2 d ：将n1行到n2行之间的内容删除 ：w ：保存当前文件 ：e filename：打开文件filename进行编辑 ：x：保存当前文件并退出 ：q：退出vi ：q!：不保存文件并退出vi ：!command：执行shell命令command ：n1,n2 w!command：将文件中n1行至n2行的内容作为command的输入并执行之，若不指定n1，n2，则表示将整个文件内容作为command的输入 ：r!command：将命令command的输出结果放到当前行 寄存器操作 \"?nyy：将当前行及其下n行的内容保存到寄存器？中，其中?为一个字母，n为一个数字 \"?nyw：将当前行及其下n个字保存到寄存器？中，其中?为一个字母，n为一个数字 \"?nyl：将当前行及其下n个字符保存到寄存器？中，其中?为一个字母，n为一个数字 \"?p：取出寄存器？中的内容并将其放到光标位置处。这里？可以是一个字母，也可以是一个数字 ndd：将当前行及其下共n行文本删除，并将所删内容放到1号删除寄存器中。 VI的使用 -------------------------------------------------------------------------------- 一、插入文本 ┌──┬────────────┐ │命令│描述　　　　　　　　　　│ ├──┼────────────┤ │i 　│在当前字符前插入文本　　│ ├──┼────────────┤ │I 　│在行首插入文本 　　　 　│ ├──┼────────────┤ │a 　│在当前字符后添加文本　　│ ├──┼────────────┤ │A 　│在行末添加文本　　　　　│ ├──┼────────────┤ │o 　│在当前行后面插入一空行　│ ├──┼────────────┤ │O 　│在当前行前面插入一空行　│ ├──┼────────────┤ │R 　│以改写方式输入文本　　　│ └──┴────────────┘ 二、移动光标 ┌─────┬───────────┐ │命令　　　│描述　　　　　　　　　│ ├─────┼───────────┤ │j或下箭头 │向下移动一行　　　　　│ ├─────┼───────────┤ │k或上箭头 │向上移动一行　　　　　│ ├─────┼───────────┤ │h或左箭头 │左移一个字符　　　　　│ ├─────┼───────────┤ │l或右箭头 │右移一个字符　　　　　│ ├─────┼───────────┤ │w 　　　　│右移一个词　　　　　　│ ├─────┼───────────┤ │W 　　　　│右移一个以空格分隔的词│ ├─────┼───────────┤ │b 　　　　│左移一个词　　　　　　│ ├─────┼───────────┤ │B 　　　　│左移一个以空格分隔的词│ ├─────┼───────────┤ │0 　　　　│移到行首　　　　　　　│ │Ctrl-F　　│向前翻页　　　　　　　│ ├─────┼───────────┤ │Ctrl-B　　│向后翻页　　　　　　　│ ├─────┼───────────┤ │nG　　　　│到第n行 　　　　　　　│ ├─────┼───────────┤ │G 　　　　│到最后一行　　　　　　│ └─────┴───────────┘ 三、替换文本 ┌─────┬──────┐ │命令　　　│描述　　　　│ ├─────┼──────┤ │$ 　　　　│到行尾　　　│ ├─────┼──────┤ │( 　　　　│到句子的开头│ ├─────┼──────┤ │) 　　　　│到句子的末尾│ ├─────┼──────┤ │{　 　　　│到段落的开头│ ├─────┼──────┤ │}　　 　　│到段落的末尾│ └─────┴──────┘ 四、删除文本 ┌───┬───────────┐ │命令　│描述 　　　　　　 　　│ ├───┼───────────┤ │r 　　│替换一个字符 　　　　 │ ├───┼───────────┤ │c 　　│修改文本直到按下Esc健 │ ├───┼───────────┤ │cw　　│修改下一个词 　　　 　│ ├───┼───────────┤ │cnw　 │修改接下来的n个词 　　│ └───┴───────────┘ 五、文本编辑 ┌──┬──────────────────────┐ │命寺│描述　　　　　　　　　　　　　　　　　　　　│ ├──┼──────────────────────┤ │yy　│将一行文本移到缺省缓冲区中 　　　　 　　　　│ ├──┼──────────────────────┤ │yn　│将下一个词移到缺省缓冲区中 　　 　　　　　　│ ├──┼──────────────────────┤ │ynw │将后面的n个词移到缺省缓冲区中　　　　 　　　│ ├──┼──────────────────────┤ │p 　│如果缺省缓冲区中包含一行文本，则在当前　　　│ │　　│行后面插入一个空行井将缺省缓冲区中的声　　　│ │　　│容粘贴到这一行中；如果缺省缓冲区中包含　　　│ │　　│多个词，把这些词粘贴到光标的右边．　　　　　│ ├──┼──────────────────────┤ │P 　│如果缺省缓冲区中包含一行文本，则正当前 　 　│ │ 　 │行前面插入一个空行井将缺省缓冲区中的内 　 　│ │　　│容粘贴到这一行中；如果缺省缓冲区中包含 　　 │ │ 　 │多个词，把这些词粘贴到光标的左边 　 　 　　│ └──┴──────────────────────┘ 六、保存退出 ┌───────────┬───────────────┐ │命令　　　　　　　　　│描述　　　　　　　　　　　　　│ ├───────────┼───────────────┤ │zz　　　　　　　　　　│保存并退出　　　　　　　　　　│ ├───────────┼───────────────┤ │:w filename　　　　 　│写入文件　　　　　　　　　 　 │ ├───────────┼───────────────┤ │:W　　　　　　　　　　│写入文件　　　　　　　　　　　│ ├───────────┼───────────────┤ │:x　　　　　　　　　　│保存(如果当前文件修改过)并退出│ ├───────────┼───────────────┤ │:q!　　　　　　　　　 │不保存文件，直接退出　　 　　 │ ├───────────┼───────────────┤ │:q　　　　　　　　　　│退出vi　　　　　　　　　　　　│ 一、基本命令介绍 ---- 1．光标命令 k、j、h、l——上、下、左、右光标移动命令。虽然您可以在Linux中使用键盘右边的4个光标键，但是记住这4个命令还是非常有用的。这4个键正是右手在键盘上放置的基本位置。 nG——跳转命令。n为行数，该命令立即使光标跳到指定行。 Ctrl+G——光标所在位置的行数和列数报告。 w、b——使光标向前或向后跳过一个单词。 ---- 2．编辑命令 i、a、r——在光标的前、后以及所在处插入字符命令(i=insert、a=append、r=replace)。 cw、dw——改变(置换)/删除光标所在处的单词的命令 (c=change、d=delete)。 x、d$、dd——删除一个字符、删除光标所在处到行尾的所有字符以及删除整行的命令。 ---- 3．查找命令 ---- /string、?string——从光标所在处向后或向前查找相应的字符串的命令。 ---- 4．拷贝复制命令 ---- yy、p——拷贝一行到剪贴板或取出剪贴板中内容的命令。 二、常见问题及应用技巧 ---- 1．在一个新文件中读/etc/passwd中的内容，取出用户名部分。 ---- vi file ---- :r /etc/passwd 在打开的文件file中光标所在处读入/etc/passwd ---- :%s/:.*//g 删除/etc/passwd中用户名后面的从冒号开始直到行尾的所有部分。 ---- 您也可以在指定的行号后读入文件内容，例如使用命令“:3r /etc/passwd”从新文件的第3行开始读入 /etc/passwd的所有内容。 ---- 我们还可以使用以下方法删掉文件中所有的空行及以#开始的注释行。 ---- #cat squid.conf.default | grep -v ^$ | grep -v ^# ---- 2．在打开一个文件编辑后才知道登录的用户对该文件没有写的权限，不能存盘，需要将所做修改存入临时文件。 ---- vi file ---- :w /tmp/1 保存所做的所有修改，也可以将其中的某一部分修改保存到临时文件，例如仅仅把第20～59行之间的内容存盘成文件/tmp/1，我们可以键入如下命令。 ---- vi file ---- :20,59w /tmp/1 ---- 3．用VI编辑一个文件，但需要删除大段的内容。 ---- 首先利用编辑命令“vi file”打开文件，然后将光标移到需要删除的行处按Ctrl+G显示行号，再到结尾处再按Ctrl+G，显示文件结尾的行号。 ---- :23,1045d 假定2次得到的行号为23和1045，则把这期间的内容全删除，也可以在要删除的开始行和结束行中用ma、mb命令标记，然后利用“:a,bd”命令删除。 ---- 4．在整个文件的各行或某几行的行首或行尾加一些字符串。 ---- vi file ---- :3,$s/^/some string / 在文件的第一行至最后一行的行首插入“some string”。 ---- :%s/$/some string/g 在整个文件每一行的行尾添加“some string”。 ---- :%s/string1/string2/g 在整个文件中替换“string1”成“string2”。 ---- :3,7s/string1/string2/ 仅替换文件中的第3行到第7行中的“string1”成“string2”。 ---- 注意: 其中s为substitute，%表示所有行，g表示global。 ---- 5．同时编辑2个文件，拷贝一个文件中的文本并粘贴到另一个文件中。 ---- vi file1 file2 ---- yy 在文件1的光标处拷贝所在行 ---- :n 切换到文件2 (n=next) ---- p 在文件2的光标所在处粘贴所拷贝的行 ---- :n 切换回文件1 ---- 6．替换文件中的路径。 ---- 使用命令“:%s#/usr/bin#/bin#g”可以把文件中所有路径/usr/bin换成/bin。也可以使用命令“:%s//usr/bin//bin/g”实现，其中“”是转义字符，表明其后的“/”字符是具有实际意义的字符，不是分隔符。","title":"Linux VI 命令全集"},{"content":"很久没有出blog了,因为一直在解Bug,今天我不想成为一个解bug机器,所以我抽出一点时间来整理我本不熟悉的camera.希望各位技术达人勇于拍砖. 目前我调试的是基于高通msm7627a平台的格科微摄像头GC0339.代码主要集中在vendor/qcom/android-open/libcamera2/目录下和vendor/qcom/proprietary/mm-camera/ 目录下. 从vendor/qcom/android-open/libcamera2/目录下看Android.mk,发现7x27a系列只用到了QualcommCameraHardware.cpp文件.我们先从修改色彩效果入手: 函数status_t QualcommCameraHardware::setParameters(const CameraParameters& params)下有个if ((rc = setEffect(params)))       final_rc = rc;  --> status_t QualcommCameraHardware::setEffect(const CameraParameters& params) --> native_set_parms(CAMERA_PARM_EFFECT, sizeof(value),  (void *)&value,(int *)&result);  -->  mCfgControl.mm_camera_set_parm(type,value); --> mm-vamera/targets/tgtcommon/config/config_proc_ctrlcmd.c里面的函数int8_t config_proc_MSM_V4L2_PROC_CTRL_CMD(void *parm1, void *parm2)  --> case CAMERA_SET_PARM_EFFECT:       rc = config_proc_ctrlcmd(CAMERA_SET_PARM_EFFECT, ctrl, ctrlCmd);       break; 因为#define config_proc_ctrlcmd(ctrlcmd, parm1, parm2)  config_proc_##ctrlcmd(parm1, parm2) 所以config_proc_ctrlcmd(CAMERA_SET_PARM_EFFECT, ctrl, ctrlCmd); == int8_t config_proc_CAMERA_SET_PARM_EFFECT(void *parm1, void *parm2);  --> config_set_parm_effect(ctrl, effect); --> effects_set_special_effect(ctrl, effect); 走到 /mm-camera/targets/tgtcommon/effects/effects.c 里面的函数int8_t effects_set_special_effect(void *ctrl, int32_t parm) --> case CAMERA_EFFECT_AQUA:       vfe_util_update_color_conversion(&chrom3a->aqua_color_conversion,         &effect->color_conversion_matrix); 走到高通的Vfe了.这样一个流程来走camera的效果代码.","title":"camera GC0339 Rawdata hal层分析"},{"content":"开发中我们需要对部分功能进行单元测试，启动Activity来测试部分小功能，有点小题大作，杀鸡用牛刀。 我们可以用Android单元测试 Instrumentation 本篇只是入门，起到抛砖的效果 Instrumentation无界面，具有启动能力。 下面通过一个简单的例子来讲解Instrumentation的基本测试方法： 我们测试工程 AndroidManifest.xml <?xml version=\"1.0\" encoding=\"utf-8\"?><manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"    package=\"cn.hpc.assistant\"    android:versionCode=\"1\"    android:versionName=\"1.0\" >    <uses-sdk        android:minSdkVersion=\"8\"        android:targetSdkVersion=\"14\" />     <application        android:name=\".FloatApplication\"        android:allowBackup=\"true\"        android:icon=\"@drawable/ic_launcher\"        android:label=\"@string/app_name\"        android:theme=\"@style/AppTheme\" android:debuggable=\"true\">        <activity            android:name=\"cn.hpc.assistant.MainActivity\"            android:label=\"@string/app_name\" >            <intent-filter>                <action android:name=\"android.intent.action.MAIN\" />                <category android:name=\"android.intent.category.LAUNCHER\" />            <\/intent-filter>        <\/activity>        <uses-library android:name=\"android.test.runner\" /><!--八股文：  引入测试库-->    <\/application><!--  八股文：被测试的目标包与instrumentation的名称。-->    <instrumentation        android:name=\"android.test.InstrumentationTestRunner\"        android:label=\"Tests for My App\"        android:targetPackage=\"cn.hpc.assistant\" /><\/manifest> Mainactivity.java package cn.hpc.assistant;import android.app.Activity;import android.content.Context;import android.graphics.PixelFormat;import android.graphics.Point;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.view.Gravity;import android.view.View;import android.view.WindowManager;import android.view.WindowManager.LayoutParams;import android.widget.TextView;public class MainActivity extends Activity {\tprivate TextView tv = null;\t@Override\tprotected void onCreate(Bundle savedInstanceState) {\t\tsuper.onCreate(savedInstanceState);\t\tsetContentView(R.layout.activity_main);\t\ttv = (TextView) this.findViewById(R.id.text1);\t\tthis.findViewById(R.id.id_btn_fun).setOnClickListener(mOnClickListener);\t}\tView.OnClickListener mOnClickListener = new View.OnClickListener() {\t\t@Override\t\tpublic void onClick(View v) {\t\t\tswitch (v.getId()) {\t\t\tcase R.id.id_btn_fun:\t\t\t\tfun();\t\t\t\tbreak;\t\t\tdefault:\t\t\t}\t\t}\t};\tprivate void fun(){\t\ttv.setText(android.os.Build.MODEL + android.os.Build.getRadioVersion());\t}} 布局文件： <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:tools=\"http://schemas.android.com/tools\"    android:layout_width=\"wrap_content\"    android:layout_height=\"wrap_content\"    android:orientation=\"horizontal\"    tools:context=\".MainActivity\" >    <TextView        android:id=\"@+id/text1\"        android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\"        android:layout_centerHorizontal=\"true\"        android:layout_centerVertical=\"true\"        android:text=\"@string/hello_world\" />    <Button        android:id=\"@+id/id_btn_fun\"        android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\" />    <Button        android:id=\"@+id/id_btn_day\"        android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\"         android:text=\"Day\"/>    <Button        android:id=\"@+id/id_btn_night\"        android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\"        android:text=\"Night\" /><\/LinearLayout> 键的测试文件： package cn.hpc.assistant.test;import junit.framework.Assert;import android.content.Intent;import android.os.SystemClock;import android.test.InstrumentationTestCase;import android.widget.Button;import android.widget.TextView;import cn.hpc.assistant.MainActivity;import cn.hpc.assistant.R;public class TestMyApp extends InstrumentationTestCase {\tMainActivity mActivity = null;\tprivate Button button = null;\tprivate TextView text = null;\tpublic void testSample() throws Throwable {\t\tAssert.assertTrue(1 + 1 == 3); // 测试一个错误的结果\t}\t@Override\tprotected void tearDown() throws Exception {\t\t// TODO Auto-generated method stub\t\tmActivity.finish();\t\tsuper.tearDown();\t}\t@Override\tprotected void setUp() throws Exception {\t\t// TODO Auto-generated method stub\t\tsuper.setUp();\t\tIntent intent = new Intent();\t\tintent.setClassName(\"cn.hpc.assistant\", MainActivity.class.getName());\t\tintent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\t\tmActivity = (MainActivity) getInstrumentation().startActivitySync(\t\t\t\tintent);\t\ttext = (TextView) mActivity.findViewById(R.id.text1);\t\tbutton = (Button) mActivity.findViewById(R.id.id_btn_fun);\t}\t/*\t * \t * 活动功能测试\t */\tpublic void testActivity() throws Exception {\t\t// 测试键壮性，连续运行某项功能100次，点击Button 100次\t\tfor (int i = 0; i < 100; ++i) {\t\t\tgetInstrumentation().runOnMainSync(new PerformClick(button));\t\t\tSystemClock.sleep(500); // 中间间隔 0.5秒\t\t}\t\tassertEquals(\"Android InstrumentationTestCase\", text.getText().toString()); //检查运行后的输出结果\t}\t/*\t * \t * 模拟按钮点击的接口\t */\tprivate class PerformClick implements Runnable {\t\tButton btn;\t\tpublic PerformClick(Button button) {\t\t\tbtn = button;\t\t}\t\tpublic void run() {\t\t\tbtn.performClick();\t\t}\t}} 在android Developer中有如下的解释 protected void setUp () Since: API Level 3 Sets up the fixture, for example, open a network connection. This method is called before a test is executed. setUp ()用来初始设置，如启动一个Activity,初始化资源等。 protected void tearDown () Since: API Level 3 Make sure all resources are cleaned up and garbage collected before moving on to the next test. Subclasses that override this method should make sure they call super.tearDown() at the end of the overriding method. tearDown () 用来垃圾清理与资源回收。 这个测试方法中，模拟了一个按钮点击事件，检查程序运行是否预期的结果。 在这里PerformClick这个方法引入Runnable接口，通过线程来执行模拟事件。这样的好处，不阻滞UI线程。 用Eclipse集成的JUnit工具启动测试 在Eclipse中选择工程Sample，单击右键，在Run as子菜单选项中选择Android JUnit Test 测试后，显示测试中的错误信息， 完毕， 欢迎转载，转载请注明出处。谢谢！ http://blog.csdn.net/hpccn/article/details/8439784","title":"Android单元测试 Instrumentation"},{"content":"一、android是如何管理多媒体文件(音频、视频、图片)的信息。 通过DDMS，我们在/data/data/com.android.providers.media下找到数据库文件 　　 　　打开external.db文件进一步查看：在media表格下，可以看到文件路径(_data)和Uri的标示ID(_id)的对应关系。 　　 二、URI与文件相互转换 　　 1.从URI获得文件路径 string  myImageUrl = \"content://media/external/images/media/***\";     Uri uri = Uri.parse(myImageUrl);           String[] proj = { MediaStore.Images.Media.DATA };        Cursor actualimagecursor = this.ctx.managedQuery(uri,proj,null,null,null);       int actual_image_column_index = actualimagecursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);        actualimagecursor.moveToFirst();              String img_path = actualimagecursor.getString(actual_image_column_index);       File file = new File(img_path);     Uri fileUri = Uri.fromFile(file); 2.由文件路径得到URI Uri mUri = Uri.parse(\"content://media/external/images/media\");              Uri mImageUri = null;              Cursor cursor = managedQuery(                     MediaStore.Images.Media.EXTERNAL_CONTENT_URI, null, null,                     null, MediaStore.Images.Media.DEFAULT_SORT_ORDER);             cursor.moveToFirst();              while (!cursor.isAfterLast()) {                 String data = cursor.getString(cursor                         .getColumnIndex(MediaStore.MediaColumns.DATA));                 if (picPath.equals(data)) {                     int ringtoneID = cursor.getInt(cursor                             .getColumnIndex(MediaStore.MediaColumns._ID));                     mImageUri = Uri.withAppendedPath(mUri, \"\"                             + ringtoneID);                     break;                 }                 cursor.moveToNext();             }","title":"android media库中external的读取"},{"content":"整理了一套Windows Phone 8 开发系列的文章： 蓝色是已经完成的，红色是未完成的： Windows Phone 8 介绍 设计Windows Phone 应用 构建WP8应用程序 WP8的async和await WP8的文件和存储 Windows Phone 8程序的生命周期 Windows Phone后台代理 Windows Phone 本地存储 警告和提醒 磁贴和通知 锁屏通知 使用资源 App间通讯 网络通讯 感应器和蓝牙 语音 地图和位置 钱包 企业部署 与win8代码共用 WP8市场 博客内其他相关内容： wp8 sdk 下载 WP8新特性总结 Windows Phone 的数据存储方式总结 Windows Phone的异步模型 wp7读取项目生成的资源(Resource)文件 wp7开发环境搭建","title":"[置顶] Windows Phone 开发系列文章索引 wp7开发环境搭建"},{"content":"OpenGL是近几年发展起来的一个性能卓越的三维图形标准，它是在SGI等多家 世界闻名的计算机公司的倡导下，以SGI的GL三维图形库为基础制定的一个通 用共享的开放式三维图形标准。目前，包括Microsoft、SGI、IBM、DEC、SUN、 HP等大公司都采用了OpenGL做为三维图形标准，许多软件厂商也纷纷以OpenGL 为基础开发出自己的产品，其中比较著名的产品包括动画制作软件Soft Image 和3D Studio MAX、仿真软件Open Inventor、VR软件World Tool Kit、CAM软 件ProEngineer、GIS软ARC/INFO等等。值得一提的是，随着Microsoft公司在 Windows NT和最新的Windows 95中提供了OpenGL标准及OpenGL三维图形加速卡 （如北京黎明电子技术公司的AGC-3D系列三维图形加速卡）的推出，OpenGL将 在微机中有广泛地应用，同时也为广大用户提供了在微机上使用以前只能在高 性能图形工作站上运行的各种软件的机会。 OpenGL实际上是一个开放的三维图形软件包，它独立于窗口系统和操作系统， 以它为基础开发的应用程序可以十分方便地在各种平台间移植；OpenGL可以 与Visual C++紧密接口，便于实现机械手的有关计算和图形算法，可保证算 法的正确性和可靠性；OpenGL使用简便，效率高。它具有七大功能： 1) 建模 OpenGL图形库除了提供基本的点、线、多边形的绘制函数外，还提 供了复杂的三维物体（球、锥、多面体、茶壶等）以及复杂曲线和曲面 （如Bezier、Nurbs等曲线或曲面）绘制函数。 2) 变换 OpenGL图形库的变换包括基本变换和投影变换。基本变换有平移、 旋转、变比镜像四种变换，投影变换有平行投影（又称正射投影）和透 视投影两种变换。其变换方法与机器人运动学中的坐标变换方法完全一 致，有利于减少算法的运行时间，提高三维图形的显示速度。 3) 颜色模式设置 OpenGL颜色模式有两种，即RGBA模式和颜色索引(Color Index)。 4) 光照和材质设置 OpenGL光有辐射光(Emitted Light)、环境光 (Ambient Light)、漫反射光(Diffuse Light)和镜面光(Specular Light)。 材质是用光反射率来表示。场景(Scene)中物体最终反映到人眼的颜色是光 的红绿蓝分量与材质红绿蓝分量的反射率相乘后形成的颜色。 5) 纹理映射(Texture Mapping) 利用OpenGL纹理映射功能可以十分逼真 地表达物体表面细节。 6) 位图显示和图象增强 图象功能除了基本的拷贝和像素读写外，还提供 融合(Blending)、反走样(Antialiasing)和雾(fog)的特殊图象效果处理。 以上三条可是被仿真物更具真实感，增强图形显示的效果。 7) 双缓存(Double Buffering)动画 双缓存即前台缓存和后台缓存，简而言 之，后台缓存计算场景、生成画面，前台缓存显示后台缓存已画好的画面。 此外，利用OpenGL还能实现深度暗示(Depth Cue)、运动模糊(Motion Blur)等 特殊效果。从而实现了消隐算法。","title":"opengl初识"},{"content":"        在iOS的Safari浏览器上播放缓存的音频供离线使用一直是一个挑战，已经被证明是不可能完成的任务 。但随着网络音频API的发展（仅支持WebKit内核），现在终于实现了-不过还需要经过一些步骤。         坏消息是我们还无法使用应用缓存缓存MP3文件，然后简单地使用XmlHttpRequest进行加载。iOS6上的Safari浏览器可以缓存MP3，但是会拒绝播放它。         但是这不代表着无药可救...         使用Base64编码         因为网络音频API为开发者提供了AudioBuffer，你现在可以马上使用它来转换数据格式，并且把它们直接采用网络音频API来进行播放。例如，如果你把一个MP3文件编码成Base64，你可以把它解码为ArrayBuffer，变成原始的音频数据。         编码音频文件         你可以很容易地使用OpenSSL将MP3文件转换为Base64字符串。MacOS X系统已经预装了OpenSSL，所以只需打开终端程序，然后键入以下命令： openssl base64 -in [infile] -out [outfile]         请确保把[infile]更换为你MP3的路径，而将[outfile]替换为你所选择的编码数据的目标路径。         这将把声音文件输出为Base64编码的字符串。然后，你可以选择使用任何形式的网络存储（例如应用缓存，本地存储，或者webSQL）来缓存字符串。         Base64到ArrayBuffer         为了把Base64字符串解码为ArrayBuffer，你需要使用一个自定义的方法。丹尼尔·格雷罗的base64-binary.js是一个好的脚本，可以准确的实现这个目的。它把Base64字符串转换成一个Uint8Array类型的数组，并将其存储在一个ArrayBuffer中。         一旦做到这一点，你可以简单地采用网络音频API的decodeAudioData()方法来解码音频数据： var buff = Base64Binary.decodeArrayBuffer(sound);myAudioContext.decodeAudioData(buff, function(audioData) {    myBuffer = audioData; });         一旦你的音频数据解码完成，将它传递给音频缓冲源并播放声音： mySource = myAudioContext.createBufferSource();mySource.buffer = myBuffer;mySource.connect(myAudioContext.destination);mySource.noteOn(0);         演示和源代码         此处是在线演示和源代码。         浏览器支持         目前此演示支持Safari 6，Chrome桌面版和iOS6 Safari浏览器。该技术未来可以工作在任何支持网络音频API的浏览器上，所以我希望Chrome移动浏览器能尽快的添加支持。         W3C目前正在完善网络音频API标准。          译自：http://html5doctor.com/taking-web-audio-offline-in-ios-6-safari/          转载请注明出处：蒋宇捷的博客-http://blog.csdn.net/hfahe","title":"在iOS Safari中播放离线音频"},{"content":"感觉ar挺好玩的、所以研究了一下、简单的说一下吧、首先去官网下载sdk我用的是untiy3d、下载地址：https://developer.vuforia.com/resources/sdk/unity，虽然不大、但是下载速度太慢了、然后新建一个工程、把这个sdk包导进去、具体怎么导就不用我细说了、自己找一张照片去官网加工一下，加工地址：https://developer.vuforia.com/targetmanager/deviceTarget/createNonCloudTarget，加工好以后下载下来、导进之前这个工程、然后把ARCamera 的属性设置一下，如图：，然后把ImageTarget预制的属性也设置一下：，旋转自己加工的那个图片，然后再ImageTarget下加上自己要出现的效果、我这里加了一个粒子系统：，然后调整一下摄像机的位置、能够看到图片，和要出现的效果就可以、然后导出来，android或ios应该都可以、我只是导了个android的、ios的没试、然后在android手机上运行、效果能出来、 文采不太好、、、、、","title":"Untiy3d AR（简单实现）"},{"content":"Objecitve-C的重要特性是Runtime（运行时），在Interacting with the Runtime（交互运行）中，运行时函数部分，苹果给出了/usr/lib/libobjc.A.dylib库，这个共享库提供支持动态属性的objective - c语言，通过其接口，可以用于开发将其他语言运行于Objective-C上的中间层（桥接层），库里的函数定义为纯C语言。 例如：class_getName class_getNameReturns the name of a class.const char * class_getName(Class cls)ParametersclsA class object.Return ValueThe name of the class, or the empty string if cls is Nil.Declared Inruntime.h 这里我们要用库里的函数，干个“坏事”，查看苹果SDK的私有方法。 第一步：导入头文件 #import <objc/runtime.h> 第二步：添加下列代码 NSString *className = NSStringFromClass([UIView class]);        const char *cClassName = [className UTF8String];        id theClass = objc_getClass(cClassName);        unsigned int outCount;        Method *m =  class_copyMethodList(theClass,&outCount);        NSLog(@\"%d\",outCount);    for (int i = 0; i<outCount; i++) {        SEL a = method_getName(*(m+1));        NSString *sn = NSStringFromSelector(a);        NSLog(@\"%@\",sn);    } 第三步：想看什么类 就把UIView换成你想要的 当然，如果只是查看私有API，会有更简单的方法，可以使用工具class-dump，也可以通过此链接，https://github.com/kennytm/iphone-private-frameworks/tree/master/UIKit/    查看。 特别注意的是，如果是需要上架的APP，切勿使用私有API，会通不过APP Store的审核。 iOS开发群，大家做技术交流和资源，群号：241048287","title":"iOS开发获取SDK下私有API"},{"content":"在类中，进行编辑下面的代码：     NSLog(@\"main thread begin...\");     [self performSelectorInBackground:@selector(doSomething:) withObject:nil];     NSLog(@\"main thread end.....\"); - (void) doSomething:(id)sender {     NSLog( @\"one thread begin...\" );       NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];     for (int i=0; i<self.StarName_Final.count; i++) {         [self SaveToDataBase:[StarName_Final objectAtIndex:i]];     }     NSLog( @\"one thread end...\" );       [pool release]; }","title":"ios后台处理数据存储线程"},{"content":"1 何谓OOPS Oops是美国人比较常有的口语。就是有点意外，吃惊，或突然的意思。“Oops”并不是很严重，正如在Britney Spears的 “Oops I Did It Again”那首歌的歌词中，也是一种轻描淡写，有时含有抱歉的意思。 http://v.youku.com/v_show/id_XMTM0ODgxMDYw.html 对于Linux内核来说，Oops就意外着内核出了异常，此时会将产生异常时CPU的状态，出错的指令地址、数据地址及其他寄存器，函数调用的顺序甚至是栈里面的内容都打印出来，然后根据异常的严重程度来决定下一步的操作：杀死导致异常的进程或者挂起系统。 最典型的异常是在内核态引用了一个非法地址，通常是未初始化的野指针Null，这将导致页表异常，最终引发Oops。 Linux系统足够健壮，能够正常的反应各种异常。异常通常导致当前进程的死亡，而系统依然能够继续运转，但是这种运转都处在一种不稳定的状态，随时可能出问题。对于中断上下文的异常及系统关键资源的破坏，通常会导致内核挂起，不再响应任何事件。 2 内核的异常级别 2.1 Bug Bug是指那些不符合内核的正常设计，但内核能够检测出来并且对系统运行不会产生影响的问题，比如在原子上下文中休眠。如： BUG: scheduling while atomic: insmod/826/0x00000002 Call Trace: [ef12f700] [c00081e0] show_stack+0x3c/0x194 (unreliable) [ef12f730] [c0019b2c] __schedule_bug+0x64/0x78 [ef12f750] [c0350f50] schedule+0x324/0x34c [ef12f7a0] [c03515c0] schedule_timeout+0x68/0xe4 [ef12f7e0] [c027938c] fsl_elbc_run_command+0x138/0x1c0 [ef12f820] [c0275820] nand_do_read_ops+0x130/0x3dc [ef12f880] [c0275ebc] nand_read+0xac/0xe0 [ef12f8b0] [c0262d98] part_read+0x5c/0xe4 [ef12f8c0] [c017bcac] jffs2_flash_read+0x68/0x254 [ef12f8f0] [c0170550] jffs2_read_dnode+0x60/0x304 [ef12f940] [c017088c] jffs2_read_inode_range+0x98/0x180 [ef12f970] [c016e610] jffs2_do_readpage_nolock+0x94/0x1ac [ef12f990] [c016ee04] jffs2_write_begin+0x2b0/0x330 [ef12fa10] [c005144c] generic_file_buffered_write+0x11c/0x8d0 [ef12fab0] [c0051e48] __generic_file_aio_write_nolock+0x248/0x500 [ef12fb20] [c0052168] generic_file_aio_write+0x68/0x10c [ef12fb50] [c007ca80] do_sync_write+0xc4/0x138 [ef12fc10] [f107c0dc] oops_log+0xdc/0x1e8 [oopslog] [ef12fe70] [f3087058] oops_log_init+0x58/0xa0 [oopslog] [ef12fe80] [c00477bc] sys_init_module+0x130/0x17dc [ef12ff40] [c00104b0] ret_from_syscall+0x0/0x38 --- Exception: c01 at 0xff29658     LR = 0x10031300 2.2 Oops 程序在内核态时，进入一种异常情况，比如引用非法指针导致的数据异常，数组越界导致的取指异常，此时异常处理机制能够捕获此异常，并将系统关键信息打印到串口上，正常情况下Oops消息会被记录到系统日志中去。 Oops发生时，进程处在内核态，很可能正在访问系统关键资源，并且获取了一些锁，当进程由于Oops异常退出时，无法释放已经获取的资源，导致其他需要获取此资源的进程挂起，对系统的正常运行造成影响。通常这种情况，系统处在不稳定的状态，很可能崩溃。 2.3 Panic 当Oops发生在中断上下文中或者在进程0和1中，系统将彻底挂起，因为中断服务程序异常后，将无法恢复，这种情况即称为内核panic。另外当系统设置了panic标志时，无论Oops发生在中断上下文还是进程上下文，都将导致内核Panic。由于在中断复位程序中panic后，系统将不再进行调度，Syslogd将不会再运行，因此这种情况下，Oops的消息仅仅打印到串口上，不会被记录在系统日志中。 Kernelpanic调试举例：   [ 242.788019] bluesleep_outgoing_data: tx was sleeping [  244.012224] ******host_wake is 1 [  245.234647] Disable_key_during_touch=0  [  245.237802] huqiao___button->code=139,state =1  [  245.414640] Disable_key_during_touch=0  [  245.417542] huqiao___button->code=139,state =0  [  245.821424] ******host_wake is 0 [  245.823708] bluesleep_hostwake_isr: [I]waking up... [  245.823713]  [  245.830155] bluesleep_hostwake_task: bluesleep_hostwake_task is called [  245.838356] Unable to handle kernel NULL pointer dereference at virtualaddress 00000008 [  245.845678] pgd = c0004000 [  245.848188] [00000008] *pgd=00000000 [  245.851751] Internal error: Oops: 5 [#1] PREEMPT SMP ARM [  245.857122] Modules linked in: [  245.860080] CPU: 0    Tainted: G        W    (3.4.0-perf-svn874 #1) [  245.866444] PC is at sco_connect_cfm+0x380/0x4e8 [  245.871106] LR is at 0xd880 [  245.873800] pc : [<c07446c0>]    lr :[<0000d880>]    psr: 40000013 [  245.873805] sp : dbe55e78  ip : 00000000  fp : d7d95c00 [  245.885246] r10: d8643998  r9 : d8e5b80d  r8 : d8643830 [  245.890529] r7 : dbe54000  r6 : d9e5b600  r5 : cae27c80 r4 : d8643800 [  245.896968] r3 : 00000008  r2 : 00000000  r1 : d7d96016 r0 : 00000000 [  245.903552] Flags: nZcv  IRQs on  FIQs on  Mode SVC_32 ISA ARM  Segment kernel [  245.910772] Control: 10c5787d  Table: 5a47406a  DAC: 00000015 [  245.916576]  [  245.916579] PC: 0xc0744640: [  245.920751] 4640  e3310000 1afffffa f57ff04f e320f004 e5973004e2433001 e5873004 e5973000 [  245.928910] 4660  ea000042 e59f0190 e300332a e19030b3 e31300040a000004 e2800fc6 e59f1198    如上图，当出现kernel panic的时候，会出现上面所示的堆栈信息。我们可以看到 [  245.866444] PC is atsco_connect_cfm+0x380/0x4e8，就会知道在sco_connect_cfm函数这边出现问题的。一般来说从LR(链接寄存器)这，我们可以知道上面的哪个函数是被hci_proto_connect_cfm所调用的。当看到Unable to handle kernel NULL pointerdereference at virtual address 00000008时，就知道这个函数应用了一个非法地址，在linux中， 将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为“内核空间”。而将较低的3G字节（从虚拟地址 0x00000000到0xBFFFFFFF），供各个进程使用，称为“用户空间），现在内核非法使用了用户空间的地址故存在问题。      关于kernel panic一般很难复现，于是我计划在内核中自己用代码去模拟这个现象。  static inlinevoid hci_proto_connect_cfm(struct hci_conn *conn, __u8 status) { register struct hci_proto *hp; hp = hci_proto[HCI_PROTO_L2CAP]; if (hp && hp->connect_cfm) hp->connect_cfm(conn, status); hp = hci_proto[HCI_PROTO_SCO]; if (hp && hp->connect_cfm) hp->connect_cfm(conn, status); if (conn->connect_cfm_cb) conn->connect_cfm_cb(conn, status); } 当我把函数改变为 static inlinevoid hci_proto_connect_cfm(struct hci_conn *conn, __u8 status) { register struct hci_proto *hp; hp = hci_proto[HCI_PROTO_L2CAP]; if (hp && hp->connect_cfm) hp->connect_cfm(conn, status); conn =  = NULL - 21; // Simulation this phenomenon, hp = hci_proto[HCI_PROTO_SCO]; if (hp && hp->connect_cfm) hp->connect_cfm(conn, status); if (conn->connect_cfm_cb) conn->connect_cfm_cb(conn, status); }        这个现象就会完全的复现。       其实根据 hci_conn 结构体定义，我们就会知道 hcon->type的地址为00000008，于是我们就会明白，在最初的代码中，在调用sco_connect_cfm的时候，传入的变量conn的地址被改变为NULL - 21;但是在前面跑hp->connect_cfm(conn, status)却没有什么问题， conn的地址传进 hp->connect_cfm(conn, status)，也没有什么改变。于是我就开始郁闷了。为什么突然地址变为一个非法的地址？      后来在网上查了下，才发现可能是硬件的问题，使得某一个地址发生了临时的错误而导致的。于是找到了原因，这个bug也就分析结束了。  ","title":"android 内核出现kernel panic的分析"},{"content":"WP7平台的播放器有两种方式可以实现，一种是使用MediaElement控件，另一种是使用系统自带的MediaPlayerLauncher控件。第一种比较灵活，无自有界面，按钮、进度条等基本界面元素都需要由自己去实现。本文重点描述第二种即MediaPlayerLauncher的使用方法。 首先说明，这个控件不需要开发者去写xaml这种界面描述文件，而且必须在真机中才能显示，模拟器内由于没有内置播放器应用，因此无法通过模拟器调试这种控件。基本的用法如下：            MediaPlayerLauncher mediaPlayerLauncher = new MediaPlayerLauncher();            mediaPlayerLauncher.Media = new Uri(global_v.url, UriKind.RelativeOrAbsolute);            mediaPlayerLauncher.Location = MediaLocationType.Data;            mediaPlayerLauncher.Controls = MediaPlaybackControls.All;            mediaPlayerLauncher.Show(); 代码很简单，先声名一个实例，之后mediaPlayerLauncher.Media的赋值是所需要播放文件的源。mediaPlayerLauncher.Location的设置需要注意一下，如果你所播放的文件是随同xap文件一同安装到手机中的，那么就需要将Location设置为MediaLocationType.Install，如果你的文件是在网络或其它方式写入的，那么就需要将Location设置为MediaLocationType.Data，我的应用内的文件均由通过服务器下载到本地，因此就使用了MediaLocationType.Data。mediaPlayerLauncher.Controls可以设置你需要显示的控件种类，我使用的MediaPlaybackControls.All说明显示所有的控件，你可以根据自身的需要进行设置。最后执行mediaPlayerLauncher.Show()就大功告成了！界面与WP7自带的zune界面完全相同！","title":"windows phone 7 mediaplayerlauncher使用方法"},{"content":"现在Fragment被使用的也比较多了，官方也在推荐使用Fragment，尤其是平板上开发显得非常的方便，这里我是在手机里展示的，可以先看一下效果图。 实现也是比较的简单，activity的布局文件里，有两个控件，一个是titles，一个是details, titles是通过指定了了对应的F绕过梦来展现的内容，Fragment本身是一个View，有自己的生命周期。这个Demo里点击titles里的目录在右侧可以显示对应的详情信息。右侧放的是一个Framlayout，在代码里通过语句 DetailsFragment df = (DetailsFragment)getFragmentManager().findFragmentById(R.id.details); 来显示DetailsFragment，把点击的位置通过，DetailsFragment里的静态方法传递过去，返回的是对应的Fragment，在得到了Fragment之后，ft.replace(R.id.details, df);将其显示出来。TitleFragment里面主要就是做了这么多工作。在DetailsFragment里面接收到对应的参数之后（getArguments().getInt(\"index\");），把所对应的详细信息给展示出来。 public class MainActivity extends FragmentActivity {    @Override    public void onCreate(Bundle savedInstanceState) {    \tsuper.onCreate(savedInstanceState);    \tsetContentView(R.layout.activity_main);    }} public class TitleFragment extends ListFragment {\tboolean mDualPane;\t\t//检验是否有DetailFragment，没有就另起一个activity\tint mCurCheckPosition;\t\tpublic void onSaveInstanceState (Bundle outState){\t\tsuper.onSaveInstanceState(outState);\t\toutState.putInt(\"curPosition\", mCurCheckPosition);\t}\t@Override\t//初始化TitleFragment\tpublic void onActivityCreated(Bundle savedInstanceState){\t\tsuper.onActivityCreated(savedInstanceState);\t\tsetListAdapter(new ArrayAdapter<String>(getActivity(), android.R.layout.simple_list_item_1,TITLES));\t\tView detailsFrame = getActivity().findViewById(R.id.details);\t\tmDualPane = detailsFrame != null && detailsFrame.getVisibility()==View.VISIBLE;\t\tif(savedInstanceState != null){\t\t\tmCurCheckPosition = savedInstanceState.getInt(\"curPosition\",0);\t\t}\t\tif(mDualPane){\t\t\tgetListView().setChoiceMode(ListView.CHOICE_MODE_SINGLE);\t\t\tshowDetails(mCurCheckPosition);\t\t}\t}\t\tpublic void onListItemClick(ListView l, View v, int position, long id){\t\tshowDetails(position);\t}\t//显示选中Item对于的内容\tprivate void showDetails(int position) {\t\tint index = position;\t\tif(mDualPane){\t\t\tgetListView().setItemChecked(index, true);\t\t\tDetailsFragment df = (DetailsFragment)getFragmentManager().findFragmentById(R.id.details);\t\t\tif(df == null || df.getShowIndex() != index){\t\t\t\tdf = DetailsFragment.newInstance(index);\t\t\t\tFragmentTransaction ft = getFragmentManager().beginTransaction();\t\t\t\tft.replace(R.id.details, df);\t\t\t\tft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE);\t\t\t\tft.commit();\t\t\t}\t\t}\t}\tpublic static final String[] TITLES =     {            \"Henry IV (1)\",               \"Henry V\",            \"Henry VIII\",                   \"Richard II\",            \"Richard III\",            \"Merchant of Venice\",              \"Othello\",            \"King Lear\"    };} public class DetailsFragment extends Fragment{\t//方法newInstance用于新建一个DetailFragment\tpublic static DetailsFragment newInstance(int index){\t\tDetailsFragment f = new DetailsFragment();\t\tBundle bundle = new Bundle();\t\tbundle.putInt(\"index\", index);\t\t//给Fragment初始化参数\t\tf.setArguments(bundle);\t\treturn f;\t}\t//产生显示内容的View\tpublic View onCreateView(LayoutInflater inflater, ViewGroup container,\t\t\tBundle savedInstanceState){\t\tif(container == null){\t\t\treturn null;\t\t}\t\tScrollView scroller = new ScrollView(getActivity());\t\tTextView text = new TextView(getActivity());\t\t//设置TextView边框大小\t\tint padding = (int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 4, getActivity().getResources().getDisplayMetrics());\t\ttext.setPadding(padding,padding,padding,padding);\t\tscroller.addView(text);\t\ttext.setText(DIALOGUE[getShowIndex()]);\t\treturn scroller;\t}\t//获取新建DetailFragment时声明的参数\tpublic int getShowIndex(){\t\treturn getArguments().getInt(\"index\");\t} Demo下载","title":"Fragment实现两栏展示"},{"content":"原创，转载请注明：http://blog.csdn.net/wang9834664/article/details/8441043 最近在用酷狗音乐听音乐的时候发现字幕效果不错，手痒也试下能不能做出这种效果 先是参考了CSDN资源中的例子，网址如下，顺便吐槽下分真高（10分）： http://download.csdn.net/detail/huhouge/3563401 该例子是用Quartz 2D写的，但是效果不是酷狗的效果，而且背景色无法是透明的，局限性太强。 琢磨了一下午终于让我找出一个方案可以跟酷狗音乐的效果一样 实现原理很简单，步骤如下：         1、创建一个UIScrollView然后一行一行的添加歌词，每行添加一个UIView,再给UIView里边添加一个UILabel用于放歌词         2、在播放歌词时用一个行高大小的UIScrollView里边放入UILabel（另一种颜色的单行歌词），               然后用定时器不断刷新UIScrollView的宽度，这样里边歌词会慢慢的展示出来盖在之前歌词的上面 效果如图： 例子代码在如下位置，自己下去，里边有BUG懒得调试了 http://download.csdn.net/detail/wang9834664/4931679","title":"高仿酷狗音乐的卡拉OK的字幕效果"},{"content":" 这几天心事颇多，加之每天课上代码量很大。夜里千万思绪，辗转难眠，索性起来写下： 自古英雄多薄命，只因代码敲不尽。 仰天大笑出门去，回家还得敲代码。 举杯邀明月，喝完敲代码。 我本将心向被窝，奈何代码罢咯多。 但愿人长久，共同敲代码。 你若不敲代码，我必生死相依。 书山有路勤为径，码农无悔敲代码。 举头望明月，低头敲代码。 有朋自远方来，还敲代码乎？ 日日思君不见君，夜夜独自敲代码。 山无陵, 江水为竭，冬雷震震，夏雨雪，依然敲代码。 今朝有酒今朝醉，醒来赶紧敲代码。 生当做程序，死亦敲代码。 天若有情天亦老，人若有空敲代码。 会当凌绝顶，一起敲代码。 问君能有几多愁，恰似一堆代码敲不完。 明日复明日，何时敲代码？ 温故而知新，可以敲代码。 问世间恨为何物，直教人代码敲不完。 滚滚长江东逝水，代码淹死英雄。 我欲乘风归去，又恐敲不完代码。 悄悄地，我走了，我进入你的电脑，只留下一段代码。","title":"程序员的简单生活"},{"content":"     今天做页面时无知地给UIImageView add了buttton做子视图,一边还纳闷为什么给button加的事件在点击后没有反应...幸好及时问了团队的前辈,跟他确认这个UIbutton实际上没有接收到事件响应,因为坑爹的UIImageView就是不接受事件响应,好吧.那就把button丢到UIView里去.可是问题又来了.UIView和UIImageView叠加在一起了,然后UIView就白白的颜色遮住背景图了. 背景图还是imageView负责啊,设计师的图就是拿来当背景的.这UIView的backgroundColor赋值成UIColor中的clearColor还是不行(吐槽一下,clearColor不是透明色么...),然后突然想起 sendSubviewToBack: Moves the specified subview so that it appears behind its siblings. - (void)sendSubviewToBack:(UIView *)view 于是用这个方法把imageView丢到button所在的View的后面去了.然后..就没有然后了,问题解决了...     我好像是昨晚浏览别人的代码时看到的方法,没想到这么快就用上了...果然没事应该去读读别人的代码啊...","title":"关于UIButton和UIImageView共存的问题."},{"content":"我在网上看到摩讯的分享SDK,然后下载来看看，不过里面缺少了选择图库的功能，于是乎没事就加上 调用图库选择本地图片的功能， 大家有对摩讯有兴趣的话可以去下载来看看   摩讯分享SDK     摩讯社区SDK 先上实现代码： ”分享本地图片“按钮事件： \t\t//选择图片,调用图库\t\tbt4.setOnClickListener(new OnClickListener() {\t\t\t@Override\t\t\tpublic void onClick(View v) {\t\t\t\tIntent intent = new Intent(Intent.ACTION_GET_CONTENT);\t\t\t\tintent.setType(\"image/*\");\t\t\t\tintent.putExtra(\"crop\", true);\t\t\t\t intent.putExtra(\"return-data\", true);\t\t\t\tstartActivityForResult(intent, 2);\t\t\t}\t\t});\t\t 点击之后跳转到图库： 这是一个回调函数,选择完图片，第一个if 判断是否返回成功，第二个if  判断requestCode和上面 startActivity(),里的参数相同,就获取图片  ,注意：在上面按钮里一定要加上这句话： intent.putExtra(\"return-data\", true);  否则返回的data 为空,稍后详 细讲解参数的作用     @Override    protected void onActivityResult(int requestCode, int resultCode, Intent data) {    \t super.onActivityResult(requestCode, resultCode, data);     \tif (resultCode == RESULT_OK) {    \t\tSystem.out.println(\"requestCode\"+requestCode);    \t if (requestCode == 2) {    \t\t Uri uri = data.getData();    \t\t System.out.println(uri.getPath());    \t\t     \t\t   ContentResolver cr = this.getContentResolver();    \t\t       \t\t   try {\t\t\t\tbmp = BitmapFactory.decodeStream(cr.openInputStream(uri));\t\t\t\t\tMCShareLaunchShareHelper.shareContentWithBitmap(\"测试分享本地图片\", bmp, \"your share url\", \"\", MoxunActivity.this);\t\t\t} catch (FileNotFoundException e) {\t\t\t\t// TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t}    \t}    }    } 回调函数跳转返回成功，跳转到分享界面（回调函数中这句话 是我调用的摩讯的分享SDK的功能，跟本文无关 MCShareLaunchShareHelper.shareContentWithBitmap(\"测试分享本地图片\", bmp, \"your share url\", \"\", MoxunActivity.this);）， 中部那个android图片就是所选的那张图片 Android中 调用图库选择图片的参数详解 Intent intent = new Intent(Intent.ACTION_GET_CONTENT, null);    intent.setType(\"image/*\");    //这个参数是确定要选择的内容为图片， intent.putExtra(\"crop\", \"circle\");   //设置了参数，就会调用裁剪，如果不设置，就会跳过裁剪的过程。 intent.putExtra(\"aspectX\", 33);  //这个是裁剪时候的 裁剪框的 X 方向的比例。 intent.putExtra(\"aspectY\",43);  //同上Y 方向的比例. (注意： aspectX, aspectY ，两个值都需要为 整数，如果有一个为浮点数，就会导致比例失效。) //设置aspectX 与 aspectY 后，裁剪框会按照所指定的比例出现，放大缩小都不会更改。如果不指定，那么 裁剪框就可以随意调整了。 intent.putExtra(\"outputX\", 50);  //返回数据的时候的 X 像素大小。  intent.putExtra(\"outputY\", 100);  //返回的时候 Y 的像素大小。 //以上两个值，设置之后会按照两个值生成一个Bitmap, 两个值就是这个bitmap的横向和纵向的像素值，如果裁剪的图像和这个像素值不符合，那么空白部分以黑色填充。 intent.putExtra(\"noFaceDetection\", true); // 是否去除面部检测， 如果你需要特定的比例去裁剪图片，那么这个一定要去掉，因为它会破坏掉特定的比例。  intent.putExtra(\"return-data\", true);  //是否要返回值。 一般都要。我第一次忘加了，总是取得空值，囧！ startActivityForResult(intent, 1);","title":"Android 开发 调用图库选择图片实现和参数详解"},{"content":"开发环境: windows 2008 R2 x64, JDK 7u10, ADT v21.0.1-543035 一.启动 Nexus 7 模拟器失败 模拟器启动出现如下错误: Starting emulator for AVD 'nexus7' Failed to allocate memory: 8 This application has requested the Runtime to terminate it in an unusual way. Please contact the application's support team for more information. 网络搜索解决: 来源:http://code.google.com/p/android/issues/detail?id=36080 方法:用命令行启动,指定内存为 512M,默认1024M有问题 c:\\xxx>emulator -avd nexus7 -memory 512 二.GUI 响应非常慢 模拟器启动出现如下错误: Starting emulator for AVD 'nexus7' emulator: ERROR: Could not load OpenGLES emulation library: Could not load DLL! emulator: WARNING: Could not initialize OpenglES emulation, using software renderer. 界面操作,响应很慢 网络搜索解决: 来源:http://stackoverflow.com/questions/11674306/eclipse-android-emulator-wont-launch 原因是未指定类库地址相关环境变量 方法:添加变量定义:LD_LIBRARY_PATH=/home/xxxx/devel/android-sdk-linux/tools/lib 为此,新建一个批处理来启动模拟器 em.bat,存放在sdk的tools目录下,如下: setlocal set LD_LIBRARY_PATH=K:\\android\\ide\\adt-bundle-windows-x86_64\\sdk\\tools\\lib emulator.exe -avd nexus7 -memory 512 -gpu on 开发中,先用命令行启动模拟器,再在运行调试时,选择当前运行的AVD即可.","title":"Android 开发时遇到的两个模拟器问题"},{"content":"注：本文由BeyondVincent(破船)翻译首发         转载请注明出处：BeyondVincent(破船)@DevDiv.com   第26日-光传感器:         今天，我继续介绍Windows 8设备中的传感器：陀螺仪(Gyrometer)。陀螺仪用来测量转动角速率。加速度计是测量三个轴上的加速度值，而陀螺仪测量的是三个轴上的转动速率，如下图所示（点击查看动态变化效果图）：   Ok，我并不是说在你的Windows 8设备中有一个小的旋转部件。一般在移动和平板设备中，使用的是MEMS陀螺仪，这种陀螺仪利用振动和共振确定转动角速率。同样，在Windows 8设备中，有些支持陀螺仪，而另外一些是不支持陀螺仪的。 PDF下载地址： 第26日-光传感器 更多内容请浏览下面链接： Windows 8 开发31日 一些截图","title":"Windows Store apps开发[84]Windows 8 开发31日-第26日-陀螺仪"},{"content":"最近公司的一个项目需要使用zigbee,购买了网上的现成的模块，通信距离都很远，但是协议等都不公开，价格也很高，不方便使用，最后决定自己画板子，起初使用的是CC2530 + CC2596的组合，发现效果很差，主要是CC2596的外围元器件过多，参数不好调，最后发现网上有人用RFX2401C,之后发现这个芯片竟然外部器件就2个去耦电容，使用非常方便，但是却没有资料，我就发了封邮件给老外，没想到竟然很快就回复了，将RFX2401C的datasheet发给我了，之后就成功的设计了这个带功放的模块，虽然zigbee这么多，但是相关电路或者设计资料却非常少，在此和大家分享一下。 元器件非常少，不需要的外部按键以及LED可以去掉，布线就非常简单了，我使用的是0603的电阻电容，效果比较好。 原理图是这样，PCB可能需要下点功夫，我们没有相关射频仪器，就测不了了，但是至少满足公司设计的要求了。","title":"CC2530 + RFX2401C Zigbee模块"},{"content":"     开始学习v4l2中camera的架构     app调用v4l2框架，然后v4l2框架再调用具体的驱动      如：在app:open----->v4l2:open------->driver:open    v4l2提供的是一个通用的框架，然后驱动去实现具体的内容。    问题：那么v4l2是怎么调用driver的呢？            这个我们看看相关代码就很清楚了。 //drivers/media/video/v4l2-dev.c static int v4l2_open(struct inode *inode, struct file *filp){\tprintk(\"<6>\\nsong:**************v4l2_open************\\n\");\tstruct video_device *vdev;\tint ret = 0;\t/* Check if the video device is available */\tmutex_lock(&videodev_lock);        //这里就是从我们的在驱动中注册的video_device->cdev得到video_device.\tvdev = video_devdata(filp);\t/* return ENODEV if the video device has been removed\t   already or if it is not registered anymore. */\tif (vdev == NULL || !video_is_registered(vdev)) {\t\tmutex_unlock(&videodev_lock);\t\treturn -ENODEV;\t}\t/* and increase the device refcount */\tvideo_get(vdev);\tmutex_unlock(&videodev_lock);        //调用在驱动注册的open方法\tif (vdev->fops->open)\t\tret = vdev->fops->open(filp);\t/* decrease the refcount in case of an error */\tif (ret)\t\tvideo_put(vdev);\treturn ret;}   其它操作和open操作是一样的。 下面来看具体的驱动代码： 1.首先dcam_init() 在初始化的时候要注册一个platform driver： platform_driver_register(&dcam_driver)  然后进行相关初始化：create_instance(i) 相关代码： int __init dcam_v4l2_init(void){    int ret = 0, i;        if(platform_driver_register(&dcam_driver) != 0) {        printk(\"platform device register Failed \\n\");        return -1;    }       // 省略                ret = create_instance(i);                   // 省略return ret;}static struct platform_driver dcam_driver = {    .probe    = dcam_probe,    .remove   = dcam_remove,    .driver   = {        .owner = THIS_MODULE,        .name = \"XXXXX_dcam\",    },};static int __init create_instance(int inst){    struct dcam_dev *dev;    struct video_device *vfd;    int ret, i;    dev = kzalloc(sizeof(*dev), GFP_KERNEL);    if (!dev)        return -ENOMEM;    snprintf(dev->v4l2_dev.name, sizeof(dev->v4l2_dev.name),            \"%s-%03d\", DCAM_MODULE_NAME, inst);    ret = v4l2_device_register(NULL, &dev->v4l2_dev);//初始化v4l2_device    if (ret)        goto free_dev;    /* init video dma queues */    INIT_LIST_HEAD(&dev->vidq.active);    init_waitqueue_head(&dev->vidq.wq);    /* initialize locks */    spin_lock_init(&dev->slock);    mutex_init(&dev->mutex);    ret = -ENOMEM;//为video_device分配内存    vfd = video_device_alloc();    if (!vfd)        goto unreg_dev;//为vfd赋值    *vfd = dcam_template;    vfd->debug = debug;//注册video_device，主要作用是注册cdev，具体看实现，这个函数很重要    ret = video_register_device(vfd, VFL_TYPE_GRABBER, video_nr);    if (ret < 0)        goto rel_vdev;    video_set_drvdata(vfd, dev);    /* Set all controls to their default value. */    for (i = 0; i < ARRAY_SIZE(dcam_qctrl); i++)        dev->qctl_regs[i] = dcam_qctrl[i].default_value;    /* Now that everything is fine, let's add it to device list */    list_add_tail(&dev->dcam_devlist, &dcam_devlist);    snprintf(vfd->name, sizeof(vfd->name), \"%s (%i)\",            dcam_template.name, vfd->num);    if (video_nr >= 0)        video_nr++;    dev->vfd = vfd;    v4l2_info(&dev->v4l2_dev, \"V4L2 device registered as /dev/video%d\\n\",            vfd->num);    return 0;rel_vdev:    video_device_release(vfd);unreg_dev:    v4l2_device_unregister(&dev->v4l2_dev);free_dev:    kfree(dev);    return ret;}static struct video_device dcam_template = {    .name        = \"dcam\",    .fops           = &dcam_fops,    .ioctl_ops     = &dcam_ioctl_ops,    .minor        = -1,    .release    = video_device_release,    .tvnorms              = V4L2_STD_525_60,    .current_norm         = V4L2_STD_NTSC_M,};//现在分析probe函数//主要作用是注册一个miscdeviceint dcam_probe(struct platform_device *pdev){    int ret;    printk(KERN_ALERT\"dcam_probe called\\n\");    ret = misc_register(&dcam_v4l2_dev);//这个可以去查看相关的注册过程    if (ret) {        printk (KERN_ERR \"cannot register miscdev on minor=%d (%d)\\n\",                DCAM_MINOR, ret);        return ret;    }    lock = (struct mutex *)kmalloc(sizeof(struct mutex), GFP_KERNEL);    if (lock == NULL)        return -1;    mutex_init(lock);        printk(KERN_ALERT \"dcam_probe Success.\\n\");    return 0;}static struct miscdevice dcam_v4l2_dev = {    .minor   = DCAM_MINOR,    .name   = \"sc8800g_dcam\",    .fops   = &dcam_fops,}; 这样基本上一个设备就可以正常工作了。","title":"v4l2,camera笔记"},{"content":"iphone5出来了，从不用适配的我们也要像android一样适配不同分辨率的屏幕了。 公司产品新版本需要适配iphone5，经过一番折腾算是搞定了。下面分享给大家： iphone5的屏幕分辨率：1136 x 640 也即是高度变成了568，程序启动时我们需要一张retina图片命名为Default-568h@2x.png。在我们创建工程时xcode会默认为我们创建一个纯黑色的图片替换即可。 最新版的xcode都已支持iphone5调试：选中模拟器---->设备---->iphone(Retina 4-inch)，稍等片刻就可以切换到iphone5模拟器。 要适配iphone5需要将view的autosizing设置为如下状态： 当然还要确认选中另一项 这一项默认会选中的，意思是自动缩放子视图。 如果我们的view没有使用xib那我们可以使用代码设置这些属性： self.view.autoresizingMask = UIViewAutoresizingFlexibleLeftMargin | UIViewAutoresizingFlexibleTopMargin | UIViewAutoresizingFlexibleRightMargin |  UIViewAutoresizingFlexibleBottomMargin  | UIViewAutoresizingFlexibleHeight | UIViewAutoresizingFlexibleWidth;接下来设置子视图（比如button,image等）： 对应代码： .autoresizingMask = UIViewAutoresizingFlexibleLeftMargin | UIViewAutoresizingFlexibleTopMargin; 意思是将控件缩放时与父视图左边和顶部对应。可以根据具体需要设置子控件的autorizingMask相应值。 我们还可以通过代码手动改变iphone5下控件的大小或位置： 首先判定一下设备是否为iphone5： #define DEVICE_IS_IPHONE5 ([[UIScreen mainScreen] bounds].size.height == 568) 接着我们可以在view初始化的时候改变frame: if (DEVICE_IS_IPHONE5) {        [botton setFrame:CGRectMake(0, 450, 320, 440)];} 通过上面的工作，就可以完美适配iphone5了。 哈哈，很简单吧！ 有问题请留言，大家一起交流学习！ 说明：转载请注明出处！","title":"iphone开发之适配iphone5"},{"content":"问题提出 看了一个性能对比的文章，根据实际情况，决定采用mysql-native作为项目的数据库连接器。 使用npm install mysql-native非常顺利 做了简单的测试连接 mysql = require('mysql-native') dbConn =  mysql.createTCPClient('******');\tdbConn.auto_prepare = true;\tvar auth = dbConn.auth('****', '***','****');  //库名，用户名和密码\tdbConn.set('row_as_hash', false); 通过mysql的show processlist，能够看到连接是正常的。 第一件事情，自然是要测试中文的读写，建立一张test_cn的表。 考虑到各个操作系统的兼容性，项目的数据库都配置为UTF-8。 CREATE TABLE `test_cn` (  `aa` varchar(20) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8 写入代码 \t\tvar sql= \"insert into test_cn(aa)values('我')\";\t\tdbConn.query(sql); 设置字符集 发现是乱码，百度按照  https://github.com/vfasky/node-mysql-sexy-query/commit/a2bd1bb5fba923ced3a832d584f2a8f3205b5563  说的 增加 dbConn.set('charset' , 'utf8_general_cs'); 重新执行，发现还是乱码，怀疑没有生效 修改mysql-native代码使其生效 然后直接进入到   node_modules/mysql_native/lib下查看代码 定位到：auth.js中读取了charset的设置，line 67           this.client.charset = this.client.get('charset') ?            Charset.by_name( this.client.get('charset') ) :            Charset.by_number( c.serverStatus.serverLanguage ); 可是在query.js line:105行，发现this.connection.charset是空的，于是  将 this.client.charset = this.client.get('charset') ? ..............修改[非常关键]           this.client.connection.charset = this.client.get('charset') ?            Charset.by_name( this.client.get('charset') ) :            Charset.by_number( c.serverStatus.serverLanguage );\t\t   this.client.charset = this.client.get('charset') ?            Charset.by_name( this.client.get('charset') ) :            Charset.by_number( c.serverStatus.serverLanguage );也就是将client和connection的字符集合都替换掉. 终于看到执行了charset.js的方法 可是执行发现，还是乱码 查看MYSQL连接属性 var d = dbConn.query(\"show variables like '%char%'\");function dump_rows(cmd){   cmd.addListener('row', function(r) { console.dir(r); } );}dump_rows(d); 从输出发现， [ 'character_set_client', 'latin1' ][ 'character_set_connection', 'latin1' ][ 'character_set_database', 'utf8' ][ 'character_set_filesystem', 'binary' ][ 'character_set_results', 'latin1' ][ 'character_set_server', 'utf8' ][ 'character_set_system', 'utf8' ] 从而定位到问题，mysql服务端认为mysql-native模块连接的是基于latin1，因此 \tdbConn.query(\"SET character_set_client=utf8,character_set_connection=utf8\"); 写入中文正确。","title":"node.js mysql-native 中文乱码全攻略"},{"content":"在通常的情况下，802.11系列无线网络产品皆具备良好的兼容性，大部分无线网卡和无线路由器都不会存在兼容性的问题。但出于稳定性的考虑，对于要求较高的场合，小编还是建议使用同一品牌的无线路由器和无线网卡。 　　钢筋混凝土结构的承重墙对无线信号有很强的阻碍作用。因此对“复式”结构住宅和别墅类的家居环境，最佳信号覆盖效果的解决办法是为每层都配置无线路由器。在实际应用中，室内AP的覆盖范围最多可能只能到30米左右。 　　802.11b实际使用速率仅有标称值的40%左右，换算出来的数据传输率约为600KB/s，如果设置为64/128位WEP加密，传送速率还会进一步下降，因此使用时更要注意干扰问题，尽量远离微波炉、无绳电话以及蓝牙设备等。 　　如果突然发现无线信号微弱，而没有做任何物理上的改动。可尝试更改无线信道或添加外置天线的方法来解决。 　　windowsXP内置了对WLAN的支持，即插即用，使用和设置都非常方便。而Windows98、WindowsME以及Windows2000对无线网络的稳定性和易用性均不如WindowsXP，偶尔会有冲突的情况发生。 　　所以，如果硬件配置足够高的话，尽量使用WindowsXP系统。同时还需说明的是，Windows95以前(包括Windows95)的操作系统不支持Wi-Fi。 　　有线网络，可以在一定程度上，通过物理的方式，限制对网络的访问。 　　但是，无线局域网安全问题如果没有慎重的得到考虑，入侵者，可能通过监听无线网络数据，来获得未授权的访问。 　　大多数的WiFi认证的802.11a/b/g无线网络设备。","title":"802.11系列无线网络经验"},{"content":"对于“后11n技术”——802.11ac，大家可能还比较陌生。作为这种新技术的初探，本文将通过问答形式，带领大家初步了解该项技术。 从1999年的802.11b协议开始，WiFi已经经历了两次“提速”： 第一次是2003年从802.11b协议的11Mbps提升至802.11g协议的54Mbps，第二次是从54Mbps直接提升至802.11n协议的300Mbps 。 而目前主流的WiFi标准802.11n，已经支持3条流、高达450Mbps物理层速率。未来，450Mbps的11n作为WiFi的主流，势必成为无法阻挡的趋势。 从理论上讲，802.11n最多可支持4条流、600Mbps的速率，但从产业链发展来看，主流WiFi芯片厂商并未继续4条流的11n开发与生产，转而将精力投入到了一种被称为“后11n技术”的技术，就是本期要介绍的——IEEE 802.11ac。 1、802.11ac标准是否已经确定？ 答：正式标准还没有确定，目前处于Draft2.0的草案阶段。预计2013年将会实现标准化。 2、802.11ac使用哪段频率？ 答：802.11ac使用5GHz频率，不支持2.4GHz。可以认为802.11ac是802.11n在5GHz的演进版本。 3、802.11ac的速率最高可达多少？ 答：8条流、256QAM(Quadrature Amplitude Modulation，相正交振幅调制)、160MHz情况下最高可达6.9Gbps。8条流的MIMO显然需要的芯片设计会很复杂，160MHz的频宽资源在我国也是可望而不可及。 目前可预期的是：3条流、256QAM、80MHz情况下可达1.3Gbps。即使这样，1.3Gpbs速度相比当前最快的450Mbps还能提高200%! 4、802.11ac需要多大带宽？ 答：强制支持40MHz、80MHz带宽，可选支持160MHz和80MHz + 80 MHz带宽。如图所示。 5、802.11ac采用了哪些新技术？ 答：物理层包括256QAM编码、最高8条流、MU-MIMO。 MAC层上包括增强的MPDU/MSDU聚合技术(就是报文可以比11n做更大聚合)，其他包括VHT链路适配(链路能力的协商)。 MU-MIMO实际就是多用户(multi-user)MIMO。802.11n技术支持的MIMO只能是单用户MIMO，即无论是3条流还是2条流，AP和所有STA之间都只能用3条流或者2条流通信。而如果支持了MU-MIMO，那么意味着一个3条流AP可以同时和3个STA分别以1条流的方式通信，而且彼此不会有干扰。这将大幅提高多用户同时接入AP时的吞吐性能，也是802.11ac值得期待的一条重要原因。 6、802.11ac终端成熟度如何？ 答：目前终端还较少，预计2013年标准化之后可以普及。 7、我国的5.8GHz带宽资源是否够802.11ac使用？ 答：目前我国5.8GHz开放频率只有5.725-5.850GHz这段频谱可用，总带宽仅有100MHz左右，肯定无法提供给802.11ac最高的160MHz频宽，即使是使用80MHz频宽，也只能容纳一个这样的频宽，对于AP的批量部署来说，这将成为一个比较大的障碍。 众所周知，美国具有的5GHz开放频段远远多于我国，在802.11ac发展阶段，更多的资源就意味着产业链的更快速发展。 国内目前开放5GHz频率的呼声很高，运营商和各厂商都对5GHz新开放频段望眼欲穿，最终能否在未来几年内放开，我们拭目以待。","title":"后11n技术的802.11ac技术精华问答"},{"content":"在OSTaskSuspend(INT8U prio) 任务挂起函数中的 OS_PRIO_SELF 宏用来表示是否是挂起自己,  其实在ucos-ii中OS_PRIO_SELF主要是为了方便挂起任务自身等同类型的函数编程而设置的, 例如在某一任务中要挂起自身, 这时候在调用层面不需要先获取自身的优先级等操作只需要调用OSTaskSusped(OS_PRIO_SELF)就可完成自身的挂起, 大大简便了挂起自身过程的编程, 也统一了接口, 无论是挂起自身还是挂起别的任务都用这个接口可以实现, 只需要传送不同的参数即可 另外, OS_TCB_RESERVED为  ((OS_TCB *)1)  用在创建任务的时候, 用该宏来占用该优先级,但是尚未初始化, 所以在该函数中使用这个宏表示要挂起的进程正在创建过程中, 尚未初始化完成","title":"ucos-ii中OSTaskSuspend(INT8U prio)任务挂起函数中的 OS_PRIO_SELF注释"}]