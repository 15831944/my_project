[{"content":"使用Java或是.Net 写数据库应用，很多人都用过Hibernate（或NHibernate）可以大大简化数据库编程，而以对象的方式来读写数据库（ORM），Yii提供的Active Record (AR) 也是一个流行的 对象-关系映射 (ORM) 技术。每个 AR 类代表一个数据表（或视图），数据表（或视图）的列在 AR 类中体现为类的属性，一个 AR 实例则表示表中的一行。 常见的 CRUD 操作作为 AR 的方法实现。因此，我们可以以一种更加面向对象的方式访问数据。 这里修改Yii Framework 开发教程(24) 数据库-DAO 示例 ，看看使用Active Record如何读取Employee表。 要访问一个数据表，我们首先需要通过集成 CActiveRecord 定义一个 AR 类。 每个 AR 类代表一个单独的数据表，一个 AR 实例则代表那个表中的一行。 由于 AR 类经常在多处被引用，我们可以导入包含 AR 类的整个目录，而不是一个个导入。 例如，如果我们所有的 AR 类文件都在 protected/models 目录中，我们可以配置应用如下： 'import'=>array(\t'application.models.*',\t), 本例定义Employee类如下： class Employee extends CActiveRecord{\tpublic static function model($className=__CLASS__)\t{\t\treturn parent::model($className);\t}\tpublic function tableName()\t{\t\treturn 'Employee';\t}} 数据表行中列的值可以作为相应 AR 实例的属性访问。比如 $employee->EmployeeId 可以访问Employee的EmployeeId字段。 本例只是读取Employee表，修改SiteController的indexAction方法： public function actionIndex(){\t$model = Employee::model()->findAll();\t$this->render('index', array(\t\t'model' => $model,\t\t));} 可以看到只要一行代码 Employee::model()->findAll()就实现读取数据库表并赋值功能，来看看对应的显示记录的代码： <?php foreach($model as $employee){\techo 'EmployeeId:' . $employee->EmployeeId . '<br />';\techo 'First Name:' . $employee->FirstName . '<br />';\techo 'Last Name:' . $employee->LastName . '<br />';\techo 'Title:' . $employee->Title . '<br />';\techo 'Address:' . $employee->Address . '<br />';\techo 'Email:' . $employee->Email . '<br />';\techo '---------------------- <br />';} ?> 可以看到使用AR可以通过数据库表的字段名（区分大小写）直接访问某个字段值，而无需在类Employee定义，从而大大简化代码。 在前面介绍Model时说过CModel有两个子类，一个是FormModel，另外一个就是CActiveRecord，CActiveRecord定义了数据库访问的CRUD方法，比如 创建记录 要向数据表中插入新行，我们要创建一个相应 AR 类的实例，设置其与表的列相关的属性，然后调用 save() 方法完成插入 $employee=new Employee;$employee->FirstName='James';$employee->LastName='Shen';...$employee->save(); 如果表的主键是自增的，在插入完成后，AR 实例将包含一个更新的主键。如果一个列在表结构中使用了静态默认值（例如一个字符串，一个数字）定义。 读取记录 要读取数据表中的数据，我们可以通过如下方式调用 find 系列方法中的一种 // 查找满足指定条件的结果中的第一行$post=Post::model()->find($condition,$params);// 查找具有指定主键值的那一行$post=Post::model()->findByPk($postID,$condition,$params);// 查找具有指定属性值的行$post=Post::model()->findByAttributes($attributes,$condition,$params);// 通过指定的 SQL 语句查找结果中的第一行$post=Post::model()->findBySql($sql,$params); 如上所示，我们通过 Post::model() 调用 find 方法。 请记住，静态方法 model() 是每个 AR 类所必须的。 此方法返回在对象上下文中的一个用于访问类级别方法（类似于静态类方法的东西）的 AR 实例。 如果 find 方法找到了一个满足查询条件的行，它将返回一个 Post 实例，实例的属性含有数据表行中相应列的值。 然后我们就可以像读取普通对象的属性那样读取载入的值，例如 echo $post->title;。 如果使用给定的查询条件在数据库中没有找到任何东西， find 方法将返回 null 。 调用 find 时，我们使用 $condition 和 $params 指定查询条件。此处 $condition 可以是 SQL 语句中的WHERE 字符串，$params 则是一个参数数组，其中的值应绑定到 $condation 中的占位符。 更新记录 在 AR 实例填充了列的值之后，我们可以改变它们并把它们存回数据表。 $post=Post::model()->findByPk(10);$post->title='new post title';$post->save(); // 将更改保存到数据库 删除记录 如果一个 AR 实例被一行数据填充,我们也可以删除此行数据 $post=Post::model()->findByPk(10); // 假设有一个帖子，其 ID 为 10$post->delete(); // 从数据表中删除此行 注意，删除之后， AR 实例仍然不变，但数据表中相应的行已经没了 其它可以参见Yii中文文档，这里不再详细复述了。 本例显示结果： 本例下载","title":"Yii Framework 开发教程(26) 数据库-Active Record示例"},{"content":"我们已经了解了怎样使用 Active Record (AR) 从单个数据表中获取数据。 在本节中，我们讲解怎样使用 AR 连接多个相关数据表并取回关联（join）后的数据集。 为了使用关系型 AR，我们建议在需要关联的表中定义主键-外键约束。这些约束可以帮助保证相关数据的一致性和完整性。 本例通过修改Yii Framework 开发教程(25) 数据库-Query Builder示例来介绍多个有关系的表如何使用Active Record。 在我们使用 AR 执行关联查询之前，我们需要让 AR 知道一个 AR 类是怎样关联到另一个的。 两个 AR 类之间的关系直接通过 AR 类所代表的数据表之间的关系相关联。 从数据库的角度来说，表 A 和 B 之间有三种关系：一对多（one-to-many，例如 tbl_user 和 tbl_post），一对一（ one-to-one 例如 tbl_user 和tbl_profile）和 多对多（many-to-many 例如 tbl_category 和 tbl_post）。 在 AR 中，有四种关系： BELONGS_TO（属于）: 如果表 A 和 B 之间的关系是一对多，则 表 B 属于 表 A (例如 Post 属于 User); HAS_MANY（有多个）: 如果表 A 和 B 之间的关系是一对多，则 A 有多个 B (例如 User 有多个 Post); HAS_ONE（有一个）: 这是 HAS_MANY 的一个特例，A 最多有一个 B (例如 User 最多有一个 Profile); MANY_MANY: 这个对应于数据库中的 多对多 关系。 由于多数 DBMS 不直接支持 多对多 关系，因此需要有一个关联表将 多对多 关系分割为 一对多 关系。 在我们的示例数据结构中，tbl_post_category 就是用于此目的的。在 AR 术语中，我们可以解释 MANY_MANY 为 BELONGS_TO 和 HAS_MANY 的组合。 例如，Post 属于多个（belongs to many） Category ，Category 有多个（has many） Post. AR 中定义关系需要覆盖 CActiveRecord 中的 relations() 方法。此方法返回一个关系配置数组。每个数组元素通过如下格式表示一个单一的关系。 在Query Builder中我们使用了下面SQL查询语句 SELECT c.FirstName, c.LastName , c.Address,c.EmailFROM customer cINNER JOINemployee eON c.SupportRepId=e.EmployeeIdWHERE e.EmployeeId=4 涉及到两个表格Employee 和 Customer，Employee和Customer之间是一对多的关系，也就是说一个员工可以负责多个客户。Employee到Customer的关系为HAS_MANY， Customer到Employee的关系为HAS_ONE。因此可以定义Employee和Customer如下： //Customer.phpclass Customer extends CActiveRecord{\tpublic static function model($className=__CLASS__)\t{\t\treturn parent::model($className);\t}\tpublic function tableName()\t{\t\treturn 'Customer';\t}}//Employee.phpclass Employee extends CActiveRecord{\tpublic static function model($className=__CLASS__)\t{\t\treturn parent::model($className);\t}\tpublic function tableName()\t{\t\treturn 'Employee';\t}\tpublic function relations()\t{\t\treturn array(\t\t\t'customers'=>array(self::HAS_MANY, 'Customer', 'SupportRepId'),\t\t\t);\t}} 因为本例只使用到由Employee查询对应的Customer，因此只为类定义了relations方法。对应的表和外键为Customer和SupportRepId。 然后修改SiteController的indexAction方法： public function actionIndex(){\t$employee=Employee::model()->findByPk(4);\t$this->render('index', array(\t\t'model' => $employee->customers,\t\t));} AR 类中的关系定义为每个关系向类中隐式添加了一个属性。在一个关联查询执行后，相应的属性将将被以关联的 AR 实例填充。因此由$employee->customers可以查询到Employee对应的Customers记录。 执行关联查询最简单的方法是读取一个 AR 实例中的关联属性。如果此属性以前没有被访问过，则一个关联查询将被初始化，它将两个表关联并使用当前 AR 实例的主键过滤。 查询结果将以所关联 AR 类的实例的方式保存到属性中。这就是传说中的 懒惰式加载（lazy loading，也可译为延迟加载） 方式，例如，关联查询只在关联的对象首次被访问时执行。 本例使用的为延迟加载，延迟加载在某些情况下并不高效。如果我们想获取 N 个帖子的作者，使用这种延迟加载将会导致执行 N 个关联查询。 这种情况下，我们应该改为使用 渴求式加载（eager loading）方式。 渴求式加载方式会在获取主 AR 实例的同时获取关联的 AR 实例。 这是通过在使用 AR 中的 find 或 findAll 方法时配合使用 with 方法完成的。例如： $employee=Post::model()->with('customers')->findAll(); 最后修改一下显示结果的View的代码： <?php foreach($model as $customer){\techo 'First Name:' . $customer->FirstName . '<br />';\techo 'Last Name:' . $customer->LastName . '<br />';\techo 'Address:' . $customer->Address . '<br />';\techo 'Email:' . $customer->Email . '<br />';\techo '---------------------- <br />';} ?> 不同的数据对列名大小写处理方式不同，有的数据库区分大小写，保险起见，Customer的属性使用和列定义同样的大小写。 本例下载 本例介绍了关联Active Record的最基本的用法，其它功能和属性可以参见Yii中文文档，此外如果借助类似CodeSmith这样的工具，如果能够自动生成数据库定义的ActiveRecord代码，就可以大大减轻程序员的代码手工编写工作量。 此外，使用Active Record的便利是以性能为代价的，通常情况下使用Active Record与使用DAO读写数据库性能相比要差一个级别。下表为一个参考值，查找200个演员和1000部电影。 方法 内存使用（M） 执行时间（秒） Active Record 19.74 1.14109 Query Builder 17.98 0.35732 DAO 17.74 0.35038","title":"Yii Framework 开发教程(27) 数据库-关联Active Record示例"},{"content":"java环境变量配置： path=%JAVA_HOME%/bin JAVA_HOME=C:/Java/jdk1.6.0_01 CLASSPATH=.;%JAVA_HOME%/lib/dt.jar;%JAVA_HOME%/lib/tools.jar  eclipse导入格式化模板 1.点击Window->Preference->Java -> Code Style -> Formatter 2.点击右侧Import选择*.xml模板文件导入即可 3.如果需要对模板进行修改，可点击Edit编辑即可 ecplise自动提示： .abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@( ecplise插件及下载地址： EasyExplorer  是一个类似于 Windows Explorer的Eclipse插件，它可以帮助你在不退出Eclipse的环境下浏览本地文件系统 下载地址：从 http://sourceforge.net/projects/easystruts/ 下载的jar包放到eclipse的plugin目录下后，重启eclipse,在eclipse里选中任何一个文件。右键选中 Easy Explorer，就可以打开该文件所在的目录了。 Call Hierarchy 显示一个方法的调用层次。 http://eclipse-tools.sourceforge.net/updates/ SVN版本控制插件 Name: Subclipse 1.2.x (Eclipse 3.2+) URL:  http://subclipse.tigris.org/update_1.2.x Name: Subclipse 1.0.x (Eclipse 3.0/3.1) URL:  http://subclipse.tigris.org/update_1.0.x","title":"eclipse常用配置"},{"content":"最近工作中要用到从ftp上解析Excel，记录一下当前进度 应用jar包 jxl.jar 主要分三步 连接服务器、将目标文件下载到本地、Excel解析 1.连接服务器 // 连接ftp服务器\tprivate boolean connectServer(String ip, String user, String password,\t\t\tString path) throws IOException {\t\t// server：FTP服务器的IP地址；\t\t//user:登录FTP服务器的用户名;\t\t//password：登录FTP服务器的用户名的口令；\t\t//path：FTP服务器上的 路径\t\ttry {\t\t\tftpClient = new FtpClient();\t\t\tftpClient.openServer(ip);\t\t\tftpClient.login(user, password);\t\t\tif (path.length() != 0) { // path是ftp服务下主目录的子目录\t\t\t\tftpClient.cd(path);\t\t\t}\t\t\tftpClient.binary(); // 用2进制上传\t\t\treturn true;\t\t} catch (IOException e) {\t\t\te.printStackTrace();\t\t\treturn false;\t\t}\t} 2.将目标文件下载到本地,要注意ftp的路径和文件名乱码以及本地地址必须存在，另外java project和web project的默认地址也不一致，打成war包放在服务器上的路径和eclipse的路径也不同 // FTP文件下载\tpublic void download() throws IOException {\t\tTelnetInputStream ftpIn = null;\t\tFileOutputStream ftpOut = null;\t\ttry {\t\t\tboolean b = connectServer(ip, userName, password, savePath);\t\t\t// ftpClient.binary();\t\t\tif (b) {\t\t\t\tftpIn = ftpClient.get(fileName); // fileName为FTP服务器上要下载的文件名\t\t\t\tbyte[] buf = new byte[204800];\t\t\t\tint bufsize = 0;\t\t\t\tftpOut = new FileOutputStream(\"D:\" + \"temp\" + \"/\" + fileName); // 存放在本地硬盘的物理位置\t\t\t\twhile ((bufsize = ftpIn.read(buf, 0, buf.length)) != -1) {\t\t\t\t\tftpOut.write(buf, 0, bufsize);\t\t\t\t}\t\t\t\tSystem.out.println(\"download success\");\t\t\t}\t\t} catch (Exception e) {\t\t\te.printStackTrace();\t\t} finally {\t\t\tif (ftpIn != null) {\t\t\t\tftpIn.close();\t\t\t}\t\t\tif (ftpOut != null) {\t\t\t\tftpOut.close();\t\t\t}\t\t\tif (ftpClient != null) {\t\t\t\tftpClient.closeServer();\t\t\t}\t\t}\t}3.Excel解析，循环按sheet、column、row、cell由大到小解析 public void read() {\t\tWorkbook workbook = null;\t\ttry {\t\t\tworkbook = Workbook.getWorkbook(new File(\"D:\" + \"temp\" + \"/\"\t\t\t\t\t+ fileName));\t\t\t Sheet[] sheets =workbook.getSheets();//\t\t\t for(Sheet sheet :sheets){//\t\t\t\t System.out.println(sheet.getRows());//\t\t\t }\t\t\tSheet sheet = workbook.getSheet(0);\t\t\tSystem.out.println(sheet.getName());\t\t\tSystem.out.println(sheet.getColumns());\t\t\tSystem.out.println(sheet.getRows());\t\t\t// }\t\t\tList<String> list = new ArrayList<String>();\t\t\tCell cell = null;// 就是单个单元格//\t\t\tfor (int j = 0; j < sheet.getColumns(); j++) {//\t\t\t\tStringBuffer sb = new StringBuffer();//\t\t\t\tfor (int i = 0; i < sheet.getRows(); i++) {//\t\t\t\t\tcell = sheet.getCell(j, i);//\t\t\t\t\tsb.append(cell.getContents());//\t\t\t\t\tsb.append(\",\");// 将单元格的每行内容用逗号隔开//\t\t\t\t}//\t\t\t\tlist.add(sb.toString());// 将每行的字符串用一个String类型的集合保存。//\t\t\t}\t\t\t\t\t\tfor (int j = 0; j < sheet.getRows(); j++) {\t\t\t\tStringBuffer sb = new StringBuffer();\t\t\t\tfor (int i = 0; i < sheet.getColumns(); i++) {\t\t\t\t\tcell = sheet.getCell(i, j);\t\t\t\t\tsb.append(cell.getContents());\t\t\t\t\tsb.append(\",\");// 将单元格的每行内容用逗号隔开\t\t\t\t}\t\t\t\tlist.add(sb.toString());// 将每行的字符串用一个String类型的集合保存。\t\t\t}\t\t\t// 迭代集合查看每行的数据\t\t\tfor (String ss : list) {\t\t\t\tSystem.out.println(ss);\t\t\t}\t\t} catch (BiffException e) {\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t} catch (IOException e) {\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t} finally {\t\t\tworkbook.close();\t\t}\t}","title":"ftp上下载解析Excel"},{"content":"网格（三）加载小汽车X文件的一个demo          前面我们已经学习了关于网格的一些知识，由于篇幅较大，所以，这里我们将示例单独拿出来作为一篇内容。       1. 首先，当然是通用的头文件d3dUtility.h文件。我们直接来欣赏源代码。 //**********************************************************************************//// Utility.h//**********************************************************************************//#ifndef __d3dUtilityH__#define __d3dUtilityH__#include<d3dx9.h>#include<string>namespace d3d{\t//**********************初始化函数******************************************//\tbool InitiateD3D(HINSTANCE hInstance, int iWidth, int iHeight, bool windowed, \t\t\t\t\t\tD3DDEVTYPE deviceType, IDirect3DDevice9** device);\t//**********************消息循环函数****************************************//\tint EnterMessageLoop(bool (*ptr_display)(float timeDelta));\t//***********************消息处理函数**************************************//\tLRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);\t//**********************模版函数，用于释放资源删除对象等*******************//\ttemplate<class T> void Release(T t)\t{\t\tif(t)\t\t{\t\t\tt->Release();\t// 释放资源\t\t\tt = 0;\t\t}\t}\ttemplate<class T> void Delete(T t)\t{\t\tif(t)\t\t{\t\t\tdelete t;\t// 删除对象\t\t}\t}\t//**********************常用颜色定义****************************************//\tconst D3DXCOLOR\t\t  WHITE(D3DCOLOR_XRGB(255, 255, 255) );\tconst D3DXCOLOR      BLACK( D3DCOLOR_XRGB(  0,   0,   0) );\tconst D3DXCOLOR        RED( D3DCOLOR_XRGB(255,   0,   0) );\tconst D3DXCOLOR      GREEN( D3DCOLOR_XRGB(  0, 255,   0) );\tconst D3DXCOLOR       BLUE( D3DCOLOR_XRGB(  0,   0, 255) );\tconst D3DXCOLOR     YELLOW( D3DCOLOR_XRGB(255, 255,   0) );\tconst D3DXCOLOR       CYAN( D3DCOLOR_XRGB(  0, 255, 255) );\tconst D3DXCOLOR    MAGENTA( D3DCOLOR_XRGB(255,   0, 255) );\t//**********************光照初始化******************************************//\tD3DLIGHT9 IniateDirectionalLight(D3DXVECTOR3* direction, D3DXCOLOR* color);\tD3DLIGHT9 IniatePointLight(D3DXVECTOR3* position, D3DXCOLOR* color);\tD3DLIGHT9 IniateSpotLight(D3DXVECTOR3* direction, D3DXVECTOR3* position, D3DXCOLOR* color);\t//**********************材质************************************************//\tD3DMATERIAL9 IniateMaterial(D3DXCOLOR a, D3DXCOLOR d, D3DXCOLOR s, D3DXCOLOR e, float p);\tconst D3DMATERIAL9 WHITE_MTRL  = IniateMaterial(WHITE, WHITE, WHITE, BLACK, 2.0f);\tconst D3DMATERIAL9 RED_MTRL    = IniateMaterial(RED, RED, RED, BLACK, 2.0f);\tconst D3DMATERIAL9 GREEN_MTRL  = IniateMaterial(GREEN, GREEN, GREEN, BLACK, 2.0f);\tconst D3DMATERIAL9 BLUE_MTRL   = IniateMaterial(BLUE, BLUE, BLUE, BLACK, 2.0f);\tconst D3DMATERIAL9 YELLOW_MTRL = IniateMaterial(YELLOW, YELLOW, YELLOW, BLACK, 2.0f);}#endif           这个头文件是很通用的，这里也就不解释了。           2. 接下来就是对d3dUtility.h文件中声明的变量和函数进行定义的d3dUtility.cpp了。我们直接欣赏源代码。 //*************************************************************************************//// Utility.cpp// 对在Utility.hpp中声明的函数定义//*************************************************************************************//#include\"d3dUtility.h\"#define WINDOWCLASSNAME\t\t\tTEXT(\"Direct3D9App\")#define REGISTERFAILED\t\t\tTEXT(\"RegisterClass()-FAILED\")#define CREATEWINDOWFAILED\t\tTEXT(\"CreateWindow()-FAILED\")#define DIRECT3DCREATE9FAILED\tTEXT(\"Direct3DCreate9()-FAILED\")#define CREATEDEVICEFALIED\t\tTEXT(\"CreateDevice()-FAILED\")#define WINDOWNAME\t\t\t\tTEXT(\"WindowByJosh\")//***************************初始化函数*******************************************//bool d3d::InitiateD3D(HINSTANCE hInstance, int iWidth, int iHeight, bool windowed,\t\t\t\t\t\tD3DDEVTYPE deviceType, IDirect3DDevice9** device){\t//**************************创建主窗口******************************//\tWNDCLASS wc;\twc.style\t\t = CS_HREDRAW | CS_VREDRAW;\twc.lpfnWndProc   = (WNDPROC)d3d::WndProc; \twc.cbClsExtra    = 0;\twc.cbWndExtra    = 0;\twc.hInstance     = hInstance;\twc.hIcon         = LoadIcon(0, IDI_APPLICATION);\twc.hCursor       = LoadCursor(0, IDC_ARROW);\twc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);\twc.lpszMenuName  = 0;\twc.lpszClassName = WINDOWCLASSNAME;\tif(!RegisterClass(&wc))\t{\t\t::MessageBox(0, REGISTERFAILED, 0, 0);\t\treturn false;\t}\tHWND hWnd = 0;\thWnd = ::CreateWindow(WINDOWCLASSNAME, WINDOWNAME, WS_EX_TOPMOST, \t\t\t\t\t\t\t0, 0, iWidth, iHeight, 0, 0, hInstance, 0);\tif(!hWnd)\t{\t\t::MessageBox(0, CREATEWINDOWFAILED, 0, 0);\t\treturn false;\t}\t::ShowWindow(hWnd, SW_SHOW);\t::UpdateWindow(hWnd);\t//************************初始化D3D**********************************//\tHRESULT hr = 0;\t// 1.创建Direct3D设备接口对象，即IDirect3D9对象\tIDirect3D9* d3d9;\td3d9 = Direct3DCreate9(D3D_SDK_VERSION);\tif(!d3d9)\t{\t\t::MessageBox(0, DIRECT3DCREATE9FAILED, 0, 0);\t\treturn false;\t}\t// 2.检验硬件顶点运算\tD3DCAPS9 caps;\td3d9->GetDeviceCaps(D3DADAPTER_DEFAULT, deviceType, &caps);\tint vp = 0;\tif(caps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT )\t\tvp = D3DCREATE_HARDWARE_VERTEXPROCESSING;\telse\t\tvp = D3DCREATE_SOFTWARE_VERTEXPROCESSING;\t// 3.填充D3DPRESENT_PARAMETERS结构\tD3DPRESENT_PARAMETERS d3dpp;\td3dpp.BackBufferWidth            = iWidth;\td3dpp.BackBufferHeight           = iHeight;\td3dpp.BackBufferFormat           = D3DFMT_A8R8G8B8;\td3dpp.BackBufferCount            = 1;\td3dpp.MultiSampleType            = D3DMULTISAMPLE_NONE;\td3dpp.MultiSampleQuality         = 0;\td3dpp.SwapEffect                 = D3DSWAPEFFECT_DISCARD; \td3dpp.hDeviceWindow              = hWnd;\td3dpp.Windowed                   = windowed;\td3dpp.EnableAutoDepthStencil     = true; \td3dpp.AutoDepthStencilFormat     = D3DFMT_D24S8;\td3dpp.Flags                      = 0;\td3dpp.FullScreen_RefreshRateInHz = D3DPRESENT_RATE_DEFAULT;\td3dpp.PresentationInterval       = D3DPRESENT_INTERVAL_IMMEDIATE;\t// 4.创建Direct3D设备对象\thr = d3d9->CreateDevice(D3DADAPTER_DEFAULT, deviceType, hWnd, vp, &d3dpp, device);\tif(FAILED(hr))\t{\t\t//尝试使用16bits深度缓存\t\td3dpp.AutoDepthStencilFormat = D3DFMT_D16;\t\thr = d3d9->CreateDevice(\t\t\tD3DADAPTER_DEFAULT,\t\t\tdeviceType,\t\t\thWnd,\t\t\tvp,\t\t\t&d3dpp,\t\t\tdevice);\t\tif(FAILED(hr))\t\t{\t\t\t::MessageBox(hWnd, CREATEDEVICEFALIED, 0, 0);\t\t\treturn false;\t\t}\t}\td3d9->Release();\t//释放接口对象\treturn true;}//***************************消息循环函数*****************************************//int d3d::EnterMessageLoop( bool (*ptr_display)(float timeDelta) ){\tMSG msg;\t::ZeroMemory(&msg, sizeof(MSG));\tstatic float lastTime = (float)timeGetTime();\twhile(msg.message != WM_QUIT)\t{\t\tif(::PeekMessage(&msg, 0, 0, 0, PM_REMOVE))\t\t{\t\t\t::TranslateMessage(&msg);\t\t\t::DispatchMessage(&msg);\t\t}\t\telse\t\t{\t\t\tfloat currTime = (float)timeGetTime();\t\t\tfloat timeDelta = (currTime - lastTime)*0.001f;\t\t\tptr_display(timeDelta);\t\t\tlastTime = currTime;\t\t}\t}\treturn msg.wParam;}//***************************光照初始化函数************************************************************//D3DLIGHT9 d3d::IniateDirectionalLight(D3DXVECTOR3* direction, D3DXCOLOR* color){\tD3DLIGHT9 light;\t::ZeroMemory(&light, sizeof(D3DLIGHT9));\tlight.Type = D3DLIGHT_DIRECTIONAL;\tlight.Ambient = *color * 0.4f;\tlight.Diffuse = *color;\tlight.Specular = *color * 0.6f;\tlight.Direction = *direction;\treturn light;}D3DLIGHT9 d3d::IniatePointLight(D3DXVECTOR3* position, D3DXCOLOR* color){\tD3DLIGHT9 light;\t::ZeroMemory(&light, sizeof(D3DLIGHT9));\tlight.Type = D3DLIGHT_POINT;\tlight.Ambient = *color * 0.4f;\tlight.Diffuse = *color;\tlight.Specular = *color * 0.6f;\tlight.Position = *position;\tlight.Range = 1000.0f;\tlight.Falloff = 1.0f;\tlight.Attenuation0 = 1.0f;\tlight.Attenuation1 = 0.0f;\tlight.Attenuation2 = 0.0f;\treturn light;}D3DLIGHT9 d3d::IniateSpotLight(D3DXVECTOR3* position, D3DXVECTOR3* direction, D3DXCOLOR* color){\tD3DLIGHT9 light;\t::ZeroMemory(&light, sizeof(D3DLIGHT9));\tlight.Type      = D3DLIGHT_SPOT;\tlight.Ambient   = *color * 0.4f;\tlight.Diffuse   = *color;\tlight.Specular  = *color * 0.6f;\tlight.Position  = *position;\tlight.Direction = *direction;\tlight.Range        = 1000.0f;\tlight.Falloff      = 1.0f;\tlight.Attenuation0 = 1.0f;\tlight.Attenuation1 = 0.0f;\tlight.Attenuation2 = 0.0f;\tlight.Theta        = 0.5f;\tlight.Phi          = 0.7f;\treturn light;}//***************************材质初始化函数*********************************************//D3DMATERIAL9 d3d::IniateMaterial(D3DXCOLOR a, D3DXCOLOR d, D3DXCOLOR s, D3DXCOLOR e, float p){\tD3DMATERIAL9 material;\tmaterial.Ambient = a;\tmaterial.Diffuse = d;\tmaterial.Specular = s;\tmaterial.Emissive = e;\tmaterial.Power = p;\treturn material;}          3. 接下来就是我们的核心代码了。这里，我把它命名为MyGame.cpp。这里直接欣赏源代码。 //***********************************************************************************************//// MyGame.cpp//***********************************************************************************************//#include \"d3dUtility.h\"#include <vector>#include <tchar.h>//****************************全局变量**************************************//const int Width  = 800;const int Height = 600;IDirect3DDevice9*\t\t\t\tDevice = 0;\t\t// 设备接口对象ID3DXMesh*\t\t\t\t\t\tMesh = 0;\t\t//网格接口对象std::vector<D3DMATERIAL9>\t\tMaterials(0);\t//std::vector<IDirect3DTexture9*> Textures(0);\t////******************************Setup函数**********************************//bool Setup(){\tHRESULT hr = 0;\t// 加载XFile\tID3DXBuffer* adjBuffer  = 0;\tID3DXBuffer* mtrlBuffer = 0;\tDWORD\t\t numMtrls\t= 0;\thr = D3DXLoadMeshFromX( TEXT(\"car.x\"), D3DXMESH_MANAGED, Device, &adjBuffer,\t\t\t\t\t\t\t\t&mtrlBuffer, 0, &numMtrls, &Mesh );\tif(FAILED(hr))\t{\t\t::MessageBox(0, TEXT(\"D3DXLoadMeshFromX()-FAILED\"), 0, 0);\t\treturn false;\t}\t// 从XFile文件中取出材质，并加载纹理文件(XFile文件中只提供纹理文件名)\tif( (mtrlBuffer != 0) && (numMtrls != 0))\t{\t\tD3DXMATERIAL* materials = (D3DXMATERIAL*)mtrlBuffer->GetBufferPointer();\t\tfor(int i=0; i<numMtrls; i++)\t\t{\t\t\tmaterials[i].MatD3D.Ambient = materials[i].MatD3D.Diffuse;\t\t\tMaterials.push_back( materials[i].MatD3D );\t\t\tif(materials[i].pTextureFilename != 0)\t\t\t{\t\t\t\tIDirect3DTexture9* texture = 0;\t\t\t\tD3DXCreateTextureFromFile(Device, _T(\"mtrls[i].pTextureFilename\"), &texture);\t\t\t\tTextures.push_back( texture );\t\t\t}\t\t\telse\t\t\t{\t\t\t\tTextures.push_back(0);\t\t\t}\t\t}\t}\td3d::Release<ID3DXBuffer*>(mtrlBuffer);\t// 网格优化\thr = Mesh->OptimizeInplace(D3DXMESHOPT_ATTRSORT | D3DXMESHOPT_COMPACT | D3DXMESHOPT_VERTEXCACHE,\t\t(DWORD*) adjBuffer->GetBufferPointer(), 0, 0, 0);\td3d::Release<ID3DXBuffer*>(adjBuffer);\tif(FAILED(hr))\t{\t\t::MessageBox(0, TEXT(\"OptimizeInplace()-FAILED\"), 0, 0);\t\treturn false;\t}\t// 设置纹理过滤器\tDevice->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);\tDevice->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);\tDevice->SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_POINT);\t// 设置光照\tD3DXVECTOR3 dir(1.0f, -1.0f, 1.0f);\tD3DXCOLOR col(1.0f, 1.0f, 1.0f, 1.0f);\tD3DLIGHT9 light = d3d::IniateDirectionalLight(&dir, &col);\tDevice->SetLight(0, &light);\tDevice->LightEnable(0, true);\tDevice->SetRenderState(D3DRS_NORMALIZENORMALS, true);\tDevice->SetRenderState(D3DRS_SPECULARENABLE, true);\t// 设置摄像机\tD3DXVECTOR3 pos(4.0f, 4.0f, -13.0f);\tD3DXVECTOR3 target(0.0f, 0.0f, 0.0f);\tD3DXVECTOR3 up(0.0f, 1.0f, 0.0f);\tD3DXMATRIX V;\tD3DXMatrixLookAtLH(&V, &pos, &target, &up);\tDevice->SetTransform(D3DTS_VIEW, &V);\t// 设置投影矩阵\tD3DXMATRIX proj;\tD3DXMatrixPerspectiveFovLH(&proj, D3DX_PI * 0.5f,\t\t\t\t\t\t\t\t(float)Width / (float)Height, 1.0f, 1000.0f);\tDevice->SetTransform(D3DTS_PROJECTION, &proj);\treturn true;}//*******************************CleanUp函数*******************************//void CleanUp(){\td3d::Release<ID3DXMesh*>(Mesh);\tfor(int i = 0; i < Textures.size(); i++)\t\td3d::Release<IDirect3DTexture9*>( Textures[i] );}//*******************************Display函数*******************************//bool Display( float timeDelta){\tif(Device)\t{\t\tstatic float y = 0.0f;\t\tD3DXMATRIX yRot;\t\tD3DXMatrixRotationY(&yRot, y);\t\t\t\ty += timeDelta;\t\tif( y>= 6.28f )\t\t\ty = 0.0f;\t\tD3DMATRIX World = yRot;\t\tDevice->SetTransform(D3DTS_WORLD, &World);\t\tDevice->Clear(0, 0, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);\t\tDevice->BeginScene();\t\tfor(int i = 0; i < Materials.size(); i++)\t\t{\t\t\tDevice->SetMaterial( &Materials[i] );\t\t\tDevice->SetTexture(0, Textures[i]);\t\t\tMesh->DrawSubset(i);\t\t}\t\t\tDevice->EndScene();\t\tDevice->Present(0, 0, 0, 0);\t}\treturn true;}//*******************************WndProc***********************************//LRESULT CALLBACK d3d::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam){\tswitch( msg )\t{\tcase WM_DESTROY:\t\t::PostQuitMessage(0);\t\tbreak;\t\t\tcase WM_KEYDOWN:\t\tif( wParam == VK_ESCAPE )\t\t\t::DestroyWindow(hwnd);\t\tbreak;\t}\treturn ::DefWindowProc(hwnd, msg, wParam, lParam);}//*******************************WinMain***********************************//int WINAPI WinMain(HINSTANCE hinstance, HINSTANCE prevInstance, PSTR cmdLine, int showCmd){\tif(!d3d::InitiateD3D(hinstance,\t\tWidth, Height, true, D3DDEVTYPE_HAL, &Device))\t{\t\t::MessageBox(0, TEXT(\"InitD3D() - FAILED\"), 0, 0);\t\treturn 0;\t}\t\t\tif(!Setup())\t{\t\t::MessageBox(0, TEXT(\"Setup() - FAILED\"), 0, 0);\t\treturn 0;\t}\td3d::EnterMessageLoop( Display );\tCleanUp();\tDevice->Release();\treturn 0;}        4. 把这三个文件输入，并且将car.x文件放在工程的根目录下，就可以编译运行了。下面，给出运行的效果图，如下。             好了，最后，我们就完成了一个三维的小汽车旋转的效果了。       另外需要说明的是，X文件一般可以由Maya，3DS MAX等软件建模转换而来。还有，在DirectX SDK中，微软也提供的一些实例当中也有一些模型的X文件，我这里的目录是E:\\Microsoft DirectX SDK\\Samples\\Media。       初学者看这些代码多少会有些云里雾里。这个时候不要急功近利，把一个demo看懂看透，我相信就可以以一反三了。       学习游戏编程是必须要学习3D建模的，这里给出Maya的下载链接和本示例完整工程的下载。       Maya：http://www.cngr.cn/dir/211/280/2012042182573.html       Maya视频教学（零基础）：http://pcedu.pconline.com.cn/videoedu/3dsmax/0910/1861304.html       本示例完整工程下载：http://download.csdn.net/download/chenwu_843402773/4938339                                                                                                                           ———— by   Josh                                                                                                                         2012年12月28日","title":"【阅读笔记之十三】《DIRECTX.9.0.3D游戏开发编程基础》 网格（三）加载小汽车的XFile的demo"},{"content":"import java.awt.Color;import java.awt.Dimension;import java.awt.Graphics;import java.util.Calendar;import java.util.GregorianCalendar;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JPanel;import javax.swing.border.*;import java.awt.BorderLayout;public class Clock extends JFrame{\tpublic Clock()\t{\t\tsetLayout(new BorderLayout(20,20));\t\tStillClock clocker=new StillClock();\t\tBorder b=new LineBorder(Color.gray,2);\t\tclocker.setBorder(b);\t\tJLabel label=new JLabel(clocker.getHour()+\":\"+clocker.getMinute()+\":\"+clocker.getSecond());\t\tlabel.setBorder(b);\t\tclocker.t1.add(clocker,BorderLayout.CENTER);\t\tclocker.t2.add(label,BorderLayout.CENTER);\t\tadd(clocker.t1,BorderLayout.NORTH);\t\tadd(clocker.t2,BorderLayout.CENTER);\t\t/*\t\t *setLayout(new BorderLayout(20,20));\t\tStillClock clocker=new StillClock();\t\tadd(clocker,BorderLayout.CENTER);\t\tJLabel j=new JLabel(clocker.getHour()+\":\"+clocker.getMinute()+\":\"+clocker.getSecond(),JLabel.CENTER);\t\tj.setFont(new java.awt.Font(\"Dialog\",1,15));\t\tadd(j,BorderLayout.SOUTH);\t\t */\t}\tpublic static void main(String[] args) \t{\t\tClock p=new Clock();\t\tp.setTitle(\"Exercise15_7\");\t\tp.setSize(300,300);\t\tp.setLocationRelativeTo(null);\t\tp.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\t\tp.setVisible(true);\t}}class StillClock extends JPanel{\tprivate int hour;\tprivate int minute;\tprivate int second;\tpublic JPanel t1=new JPanel();\tpublic JPanel t2=new JPanel();\tpublic StillClock()\t{\t\tsetCurrentTime();\t}\tpublic StillClock(int hour,int minute,int second)\t{\t\tthis.hour=hour;\t\tthis.minute=minute;\t\tthis.second=second;\t}\tpublic int getHour()\t{\t\treturn hour;\t}\tpublic void setHour(int hour)\t{\t\tthis.hour=hour;\t\trepaint();\t}\tpublic int getMinute()\t{\t\treturn minute;\t}\tpublic void setMinute(int minute)\t{\t\tthis.minute=minute;\t\trepaint();\t}\tpublic int getSecond()\t{\t\treturn second;\t}\tpublic void setSecond(int second)\t{\t\tthis.second=second;\t\trepaint();\t}\tprotected void paintComponent(Graphics g)                  //一般都定义为保护类型\t{\t\tsuper.paintComponent(g);\t\tint clockRadius=(int)(Math.min(getWidth(),getHeight()*0.8*0.5));\t\tint x=getWidth()/2;\t\tint y=getHeight()/2;\t\tg.setColor(Color.blue);\t\tg.drawOval(x-clockRadius, y-clockRadius, 2*clockRadius, 2*clockRadius);\t\tg.drawString(\"12\",x-5, y-clockRadius+12);\t\tg.drawString(\"9\",x-clockRadius+3, y+5);\t\tg.drawString(\"3\",x+clockRadius-10, y+3);\t\tg.drawString(\"6\",x-3, y+clockRadius-3);\t\tint sLength=(int)(clockRadius*0.8);\t\tint xSecond=(int)(x+sLength*Math.sin(second*(2*Math.PI/60)));\t\tint ySecond=(int)(y-sLength*Math.cos(second*(2*Math.PI/60)));\t\tg.setColor(Color.red);\t\tg.drawLine(x,y,xSecond,ySecond);\t\tint mLength=(int)(clockRadius*0.65);\t\tint xMinute=(int)(x+mLength*Math.sin(minute*(2*Math.PI/60)));\t\tint yMinute=(int)(y-mLength*Math.cos(minute*(2*Math.PI/60)));\t\tg.setColor(Color.blue);\t\tg.drawLine(x,y,xMinute,yMinute);\t\tint hLength=(int)(clockRadius*0.5);\t\tint xHour=(int)(x+hLength*Math.sin((hour%12+minute/60.0)*(2*Math.PI/12)));\t\tint yHour=(int)(y-hLength*Math.cos((hour%12+minute/60.0)*(2*Math.PI/12)));\t\tg.setColor(Color.green);\t\tg.drawLine(x, y, xHour, yHour);\t}\tpublic void setCurrentTime()\t{\t\tCalendar calendar=new GregorianCalendar();\t\tthis.hour=calendar.get(Calendar.HOUR_OF_DAY);\t\tthis.minute=calendar.get(Calendar.MINUTE);\t\tthis.second=calendar.get(Calendar.SECOND);\t}\tpublic Dimension getPreferredSize()\t{\t\treturn new Dimension(200,200);\t}}","title":"java实现一个小的时钟（当前时间）"},{"content":"fopen64是linux特有 的,fopen64（）函数和fopen（）函数相同的，只是底层的文件描述符创建是带有O_LARGEFILE标志。 fopen64（）函数为了加载大型文件所做的扩展。 fopen returns FILE*, stream. fopen64 returns int, file descriptor       通常情况下，我们用fopen（）函数来读问件，但是当文件超过2GB的时候，fopen（）将不能读取那个文件，但是fopen64（）可以。       但是如果用fopen（）函数读文件，编译的时候加上-D_FILE_OFFSET_BITS=64指令，则获得的效果和fopen64（）是一样的，因此，我们一般建议用fopen（）函数，因为它更具有通用性，fopen64（）是non-standard，fopen是standard函数。 参考文献： http://cboard.cprogramming.com/c-programming/149806-difference-between-fopen-fopen64.html http://www.mkssoftware.com/docs/man3/fopen.3.asp http://forum.ubuntu.org.cn/viewtopic.php?t=23741","title":"fopen vs fopen64"},{"content":"起因：还是动态生成图表时的问题，因为字段是动态设定的，可以在多个轴、序列中设置字段，这就很有可能会存在字段的重复问题。重复的字段生成Sql并执行是没有问题的，但执行的结果，生成List(执行Hibernate的sqlquery.setResultTransformer(Transformers.ALIAS_TO_ENTITY_MAP).list())时就会有问题了（抛出异常）。所以就要除去查询sql字段中的重复字段。 首先想到的是把字符串分隔成数组，再添加到set中，再用Set中的字段名重新生成不重复的字段名字符串。 代码是这样的： \t\tString s = \"D_NAME,COMPANYID,COMPANY_NAME,PARENT_ID,ID,COMPANYID,COMPANY_NAME,DF_UNIFIED_CODE,DF_CLEARANCE_TAG_ID,\";\t\tString[] s1 = s.split(\",\");\t\tSet set = new HashSet();\t\tfor(String ss : s1){\t\t\tset.add(ss);\t\t}\t\tIterator iter = set.iterator();\t\tString newStr = \"\";\t\twhile(iter.hasNext()){\t\t\tnewStr += iter.next();\t\t} 结果显示，重复的字段并没有去掉。 把set.add(ss);改为 \t\t\tif(!set.contains(ss))\t\t\t\tset.add(ss); 结果依旧。 我不知道java是集合是怎么处理字符串的。请教java老手，说理论上Set中应该是不会重复的，但对出现这样的结果，也没有有效的解决办法。哪位大虾能告诉我这是怎么回事呀？ 然后我就想到使用正则表达式来实现除去字符串的重复字段名。 第一个表达式： (\\b[\\w|_]+\\b,?)(.*)\\1(.*)，代码为： \t\tString s = \"LOWVOLTAGE_LOSS_RATE,YEARMONTH,LOWVOLTAGE_LOSS_RATE,NAME,YEARMONTH,PPQ,PPQ,SPQ,PPQ,PPQ,SPQ,CODE,LOWVOLTAGE_LOSS_RATE\";\t\tPattern p = Pattern.compile(\"(\\\\b[\\\\w|_]+\\\\b,?)(.*)\\\\1(.*)\");\t\tMatcher matcher = p.matcher(s);\t\t\t\twhile(matcher.find()){\t\t\ts = matcher.replaceAll(\"$1$2$3\");\t\t\tSystem.out.println(s);\t\t\tmatcher = p.matcher(s);\t\t}\t\tif(s.endsWith(\",\"))\t\t\ts = s.substring(0,s.length()-1);\t\tString expect = \"LOWVOLTAGE_LOSS_RATE,YEARMONTH,NAME,PPQ,SPQ,CODE\";\t\tAssert.assertEquals(expect, s.substring(0,s.length()-1)); 验证结果为预期结果。 本来以为到这里就已经结束了，可系统刚运行了一会，就报出了错误，跟踪发现，当要处理的字符串为： \"D_NAME,COMPANYID,COMPANY_NAME,PARENT_ID,ID,COMPANYID,COMPANY_NAME,DF_UNIFIED_CODE,DF_CLEARANCE_TAG_ID,\"时，执行的结果会把“DF_CLEARANCE_TAG_ID”替换成“DF_CLEARANCE_TAG_”，这可不是我要的结果！ 经改进后的正则表达式为：(\\b[\\w|_]+\\b,?)(.*)\\b\\1\\b (.*)，再次测试，结果完全满足要求。","title":"正则表达式实现除去重复的单词"},{"content":"线程安全分析        多个线程并发执行会带来安全问题，就好比搬家这项工作，虽然人多了干活会比较快，但是人多很容易损坏物件。在线程安全问题中，非常有名的问题就是银行取钱问题。   银行的取钱流程是这样的：   1.验证用户名和密码   2. 用户输入取款金额   3.系统判断余额是否大于取款金额，如果大于则取款成功；否则，取款失败。   4. 系统更新账户余额    这个流程看起来没有任何问题，但是如果放到多线程并发情况下，就有可能出现问题。比如：    假设你的账户有1000元，当你在柜台成功取出1000元时（注意此时系统还没有将账户余额改为0，账户余额还是为1000 ）。同时你的女朋友在取款机也正在取款，取款机去查询账户余额，发现是1000元，于是又吐给你女朋友1000元。   然后柜台将你的账户余额更新为0，取款机随后也将你的账户余额更新为0。   就这样，我们成功的在1000元的账户里，取出了2000元。这显然是不合理的。   程序模拟    下面让我们写一个多线程程序来模拟多个人取钱操作。    首先封装一个账户类，这个账户有账号和余额两个属性: /** * 账户类 * @author liubing * */public class Account {      //账号      private String accountNo;            //余额      private int balance;            /**       * 构造函数，设置账号和余额       * @param accountNo       * @param balance       */      public Account(String accountNo, int balance) {             this. accountNo = accountNo;             this. balance = balance;      }      public String getAccountNo() {             return accountNo;      }      public void setAccountNo(String accountNo) {             this. accountNo = accountNo;      }      public int getBalance() {             return balance;      }      public void setBalance( int balance) {             this. balance = balance;      }            }   接下来写一个取钱的线程类，模拟用户取钱。 public class DrawCashThread extends Thread{      //模拟用户账户      private Account account;            //模拟取钱数      private int drawCash;      public DrawCashThread(String name, Account account, int drawCash) {             super(name);             this. account = account;             this. drawCash = drawCash;      }            /**       * 模拟多个线程同时取钱操作       */      @Override      public void run() {             //判断账户余额大于取款金额             if( account.getBalance() >= drawCash) {                  System. out.println(getName() + \" 取钱成功，取款金额：\" + drawCash);                                     /*                    try {                        //强制线程切换                        sleep(1);                  } catch (Exception e) {                        e.printStackTrace();                  }                  */                                     //修改余额                   account.setBalance( account.getBalance() - drawCash);                  System. out.println( \"此时余额：\" + account.getBalance());            } else {                  System. out.println(getName() + \" 取钱失败，余额不足！\" );            }                  }                 }    好了，这就是我们根据银行取钱步骤，模拟的账户和取钱操作，接下来，我们写一个主程序测试一下。创建一个账户，然后开启两个线程去取钱。    main函数如下：  public static void main(String[] args) {             //新建我的账户，余额1000元            Account account = new Account( \"我的账户\" , 1000);             //张三来取款1000元             new DrawCashThread( \"张三\", account, 1000).start();             //李四来取款1000元             new DrawCashThread( \"李四\" , account, 1000).start();                  }    多次运行，发现每次的运行结果都不太一样。因为线程的调度是不确定的，大多数的运算结果反而是错的，偶尔出现预期的正确的结果。     注意：单核和多核cpu运算的结果是不一样的，单核的机器运算出正确的结果较多，需要将DrawCashThread代码中的注释打开，强制线程切换，才能看到错误的结果。在多核机器上很容易出现错误结果。    正确的结果：          张三 取钱成功，取款金额：1000 此时余额：0 李四 取钱失败，余额不足！ 错误的结果：                        张三 取钱成功，取款金额：1000 此时余额：0 李四 取钱成功，取款金额：1000 此时余额：-1000 锁机制登场     之所以出现这种错误， 原因就是银行取钱这个操作是原子性的，不应该被打断。两个线程共同修改共享资源--Account对象，造成了非同步的安全性问题。就像搬家一样，有几个哥们居然将冰箱拆开搬走了……     与其告诉他们，冰箱应该整个搬走，不如我们将冰箱整个儿锁起来。   同步代码块     为了解决这个问题，java引入了同步监视器来解决这个问题，使用同步监视器的通用方法就是同步代码块。其语法格式如下：     synchronized (obj) {                                          }    其中obj就是同步监视器，上面代码的含义是：线程开始执行同步代码块之前，必须先获得对同步监视器的锁定。任何时候只能有一条线程可以获得对同步监视器的锁定。同步代码执行结束后，该线程自然释放了对同步监视器的锁定。       这个很好理解，synchronized好比是一个厕所，obj就是一把锁。每个上厕所的人办事之前，先把门儿锁上。办完事把门儿打开，以便别人上厕所。    同步监视器的作用：防止多个线程对共享资源进行并发访问。因为通常选取共享资源作为同步监视器。    所以上面的取钱程序，我们可以考虑使用account作为同步监视器，改造后代码如下：    public class DrawCashThread extends Thread{      //模拟用户账户      private Account account;            //模拟取钱数      private int drawCash;      public DrawCashThread(String name, Account account, int drawCash) {             super(name);             this. account = account;             this. drawCash = drawCash;      }            /**       * 模拟多个线程同时取钱操作       */      @Override      public void run() {             //使用account作为同步监视器，任何线程进入下面同步代码块之前             //先获得对account对象的锁定，其他线程无法获得锁，也就无法修改它             //符合：加锁--修改--释放锁逻辑             synchronized ( account) {                                     //判断账户余额大于取款金额                   if( account.getBalance() >= drawCash) {                        System. out.println(getName() + \" 取钱成功，取款金额：\" + drawCash );                         /*                    try {                        //强制线程切换                        sleep(1);                  } catch (Exception e) {                        e.printStackTrace();                  }                         */                                                 //修改余额                         account.setBalance( account.getBalance() - drawCash);                        System. out.println( \"此时余额：\" + account.getBalance());                  } else {                        System. out.println(getName() + \" 取钱失败，余额不足！\" );                  }            }                  }      }     这次我们将run方法内加入了synchronized同步代码块，使用account对象作为同步资源监视器。任何线程在修改account对象之前，首先要对account进行加锁，在account对象锁定期间，其他线程是无法修改该资源的。修改完成后，该线程释放对account资源的锁定。     这样就可以保证并发线程在任意时刻只有一条线程可以进入修改共享资源的代码区，从而保证了线程的安全性。   同步方法：     与同步代码块对应的，java多线程中还提供了同步方法。同步方法就是synchronized关键字来修饰某个方法。对于同步方法而言，无需显示指定同步监视器，同步方法的同步监视器就是this，也就是该对象本身。     在上面取钱的程序中，不安全的因素就在于多个线程对balance的修改。所以我们就可以讲取钱操作封装成一个同步方法，保证线程对balance的修改是线程安全的即可。    Account改造如下: /** * 账户类 * @author liubing * */public class Account {      //账号      private String accountNo;            //余额      private int balance;            /**       * 构造函数，设置账号和余额       * @param accountNo       * @param balance       */      public Account(String accountNo, int balance) {             this. accountNo = accountNo;             this. balance = balance;      }      public String getAccountNo() {             return accountNo;      }      public void setAccountNo(String accountNo) {             this. accountNo = accountNo;      }      public int getBalance() {             return balance;      }      //因为账户余额不能随便修改，所以取消balance的setter方法//    public void setBalance( int balance) {//          this.balance = balance;//    }            //提供一个线程安全的方法完成取钱操作      public synchronized void drawCash( int drawAccount) {             if( balance >= drawAccount) {                  System. out.println(Thread. currentThread().getName() + \" 取钱成功，取款金额：\" + drawAccount);                                     //修改余额                   balance -= drawAccount;                  System. out.println( \"此时余额：\" + balance );            } else {                  System. out.println(Thread. currentThread().getName() + \" 取钱失败，余额不足！\" );            }      }      }    我们将取钱的方法重构到了Account类，并使用synchronized修饰该方法，使其成为同步方法。同步方法的同步监视器是this，因为对于同一account对象来说，任意时刻只能有一个线程获得对account对象的锁定，然后执行取钱的操作。这样就可以保证线程安全。    对于取钱的线程来说，只要在run方法中调用account对象的drawCash()方法即可，很简单，这里就不给出代码了。       锁机制是以降低程序运行效率为代价的，有一定的负面影响。就像搬家一样，虽然将冰箱锁住了，保证了冰箱的完整安全。但是搬冰箱的人需要相互协调，喊着口号才能搬走冰箱。所以我们在使用锁机制时，将锁控制的范围尽量的集中和缩小，仅对共享资源的操作部分进行锁定和同步，以减少对效率的损耗。      原文链接：http://www.67tgb.com/?p=523   欢迎访问：望月听涛","title":"线程（三）---锁机制"},{"content":"本来计划这周发布日期工具类DateUtil第四版的，但我在翻译“寿星天文历”的过程中，遇到了很多麻烦，加上还有工作要做，因此这周可能无法发布第四版了，无奈只能先来吐槽叙述下。 寿星天文历是许剑伟先生开发的一块精度极高的万年历，采用非常科学先进的天文算法和系列定律，并参考了大量古今农历数据和相关书籍，其最终的计算精度堪比刘安国教授制作的“日梭万年历”，但相比“日梭万年历”，寿星天文历计算未来几千年（9999年）的农历时间更为准确和具有参考价值，支持的查询范围更广（“日梭万年历”只能估算到2100年），并且最为重要的是寿星天文历是开源的！因此为我们程序员提供了一个非常好的工具！ 然而寿星天文历是基于javascript语言开发，并无其他语言版本，所以才有了“翻译”之说。我要将javascript的代码翻译成java代码，起初以为工作量不会太大，但当我真正做起来后才发现，这是一个非常耗人耗力的大工作！ 以前认为语言是一通百通的，但经历这次后，我才深深的认识到：根本不是这么回事。共通的只能说是基本语法和基本类型很相似，其他的很多时候都是不太一样的。而javascript和java更是在理念上有很多差异的，javascript是脚本语言，java是面向对象语言。举几个例子： 1. 计算 8/24。js结果是0.3333333333333333,，java结果是0 2. 类型 js是弱数据类型，java是严格的数据类型。var a; 变量a，可以看成是任何类型，而且类型还会根据赋值的类型不同而动态变化。而java就不是了，它有严格的类型区分，虽然可以通过Object类型去完成，但我相信大多数人是不建议这么做的。 3. 方法、变量代码的最大字节 java某一方法或变量支持书写代码的最大量是65535字节（就是某一方法或变量的代码超级多，注意我说的是书写的代码，而不是方法、变量本身支持的字节，例如List类型的变量可以有上亿的数组成员，但你无法将这上亿个成员一一用代码写出来一并赋给List，只能动态的赋值给List），这是JVM本身的问题，而js却没有限制。 4. substr js中的substr与java的substring可不是一个概念。js的substr中的第二个参数代表的是截取长度length，而java的是结果索引endIndex。并且substr中的length超过字符串本身长度的话，则方法返回的是空串，但java的endIndex超过字符串长度的话就直接报错了。（其实js里也有substring，功能与java的类似，但仍然有不同） 5. 两个字符串的相等判断 js直接“==”即可，但java则是用equals方法 以上只是我列出的几点而已，这么多差异我事先并不是都知道的，虽然我也经常写js，但如此之多的不同，我也是今天才知道的，（吐槽一下，现在才发现自己以前写js其实还是以面向对象的理念去写的，翻译寿星天文历也让我对javascript语言有了新的认识），造成翻译过程中遇到了很多问题，我不得不参照javascript代码去一个个验证java代码，因为里面实在有太多的计算了，我必须检查计算精度。 再有，通过这次翻译，也同样增加了我对java语言的认识和理解，我发现浮点运算，double类型是有误差的，查阅资料才发现bigDecimal才是专门用来高精度计算的，虽然以前就知道一些，但现在才是“真明白”了 总而言之，言而总之，困难是遇到了，但我的心情却是愉悦激动的，也明白自己离“代码艺术大师”还有多远。 日期工具类，我会在近几天之内发布，由于double计算精度的问题，初版并没有大量的更改为bigDecimal（这也是工作量啊），只是将误差较大的计算更改为了bigDecimal类型，其余的虽有误差，但误差非常小，完全可以忽略不计（更何况算法本身就存在误差），所以日后如果我有时间再都改为bigDecimal吧。","title":"翻译“寿星天文历”有感"},{"content":"概述          客户端只是想要发出命令或者请求，不关心请求的真正接收者是谁，也不关心具体如何实现，而且同一个请求的动作可以有不同的请求内容，当然具体的处理功能也不一样，请问该怎么实现？下面我们来学习命令模式 目的        将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。   结构图  详细解析 Command：         定义命令的接口，声明执行的方法。 ConcreteCommand：         命令接口实现对象，是“虚”的实现；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。 Receiver：         接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。 Invoker：         要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。 Client：         创建具体的命令对象，并且设置命令对象的接收者。注意这个不是我们常规意义上的客户端，而是在组装命令对象和接收者，或许，把这个Client称为装配者会更好理解，因为真正使用命令的客户端是从Invoker来触发执行。   对应代码 class Program    {        static void Main(string[] args)        {            Receiver r = new Receiver();            Command c = new ConcreteCommand(r);            Invoker i = new Invoker();            // Set and execute command             i.SetCommand(c);            i.ExecuteCommand();            Console.Read();        }    }    //用来声明执行操作的接口    abstract class Command    {        protected Receiver receiver;        public Command(Receiver receiver)        {            this.receiver = receiver;        }        abstract public void Execute();    }    //ConcreteCommand类，将一个接收者对象绑定于一个操作，调用接收者相应的操作，以实现Execute    class ConcreteCommand : Command    {        public ConcreteCommand(Receiver receiver)            :          base(receiver) { }        public override void Execute()        {            receiver.Action();        }    }    //知道如何实施与执行一个与请求相关的操作，任何类都可能作为一个接收者    class Receiver    {        public void Action()        {            Console.WriteLine(\"执行请求！\");        }    }    //要该命令执行这个请求    class Invoker    {        private Command command;        public void SetCommand(Command command)        {            this.command = command;        }        public void ExecuteCommand()        {            command.Execute();        }    }  生活中得例子        Command模式将一个请求封装为一个对象，从而使不同的请求对客户进行参数化，用餐时的账单是Command模式的一个例子，服务员接受顾客的点单，把它记在账单上封装，这个点单被排队等待做，账单不依赖菜单的，它可以被不同的顾客使用，也可以添加入不同的点单项目。   Command模式实例剖析       Command模式它封装的是命令，把命令的发出者的责任和命令执行者的责任分开，我们知道，一个类是一组操作和相应变量的结合，在订餐的过程中有如下一个类Waiter   //服务员    public class Waiter    {        private IList<Command> orders = new List<Command>();        //设置订单        public void SetOrder(Command command)        {            if (command.ToString() == \"命令模式.BakeChickenWingCommand\")            {                Console.WriteLine(\"服务员：鸡翅没有了，请点别的烧烤。\");            }            else            {                orders.Add(command);                Console.WriteLine(\"增加订单：\" + command.ToString() + \"  时间：\" + DateTime.Now.ToString());            }        }        //取消订单        public void CancelOrder(Command command)        {            orders.Remove(command);            Console.WriteLine(\"取消订单：\" + command.ToString() + \"  时间：\" + DateTime.Now.ToString());        }        //通知全部执行        public void Notify()        {            foreach (Command cmd in orders)            {                cmd.ExcuteCommand();            }        }    }         下面我们得抽象一个抽象的命令，Setorder、CancelOrder、等方法都是Command所具有的，如果单独出来一个命令对象，那就把函数层面的功能提到了类的层面，对命令的抽象是很重要之处。，其他具体的方法命令类都继承于该抽象类。   //抽象命令    public abstract class Command    {        protected Barbecuer receiver;        public Command(Barbecuer receiver)        {            this.receiver = receiver;        }        //执行命令        abstract public void ExcuteCommand();    }    //烤羊肉串命令    class BakeMuttonCommand : Command    {        public BakeMuttonCommand(Barbecuer receiver)            : base(receiver)        { }        public override void ExcuteCommand()        {            receiver.BakeMutton();        }    }    //烤鸡翅命令    class BakeChickenWingCommand : Command    {        public BakeChickenWingCommand(Barbecuer receiver)            : base(receiver)        { }        public override void ExcuteCommand()        {            receiver.BakeChickenWing();        }    } //烤肉串者    public class Barbecuer    {        public void BakeMutton()        {            Console.WriteLine(\"烤羊肉串!\");        }        public void BakeChickenWing()        {            Console.WriteLine(\"烤鸡翅!\");        }    }     客户端的调用    static void Main(string[] args)        {            //开店前的准备            Barbecuer boy = new Barbecuer();            Command bakeMuttonCommand1 = new BakeMuttonCommand(boy);            Command bakeMuttonCommand2 = new BakeMuttonCommand(boy);            Command bakeChickenWingCommand1 = new BakeChickenWingCommand(boy);            Waiter girl = new Waiter();            //开门营业 顾客点菜            girl.SetOrder(bakeMuttonCommand1);            girl.SetOrder(bakeMuttonCommand2);            girl.SetOrder(bakeChickenWingCommand1);            //点菜完闭，通知厨房            girl.Notify();            Console.Read();        }        在客户端的程序中，不依赖于Waiter的SetOrder、CancelOrder、Notify、修改订单等命令，通过Command对这些命令进行了封装，使得它的一个关键抽象类是Command类，它定义了一个操作的接口，同时我们可以看到，这三个命令是方法而已，但是通过Command模式把它们提到了类的层面，虽然违背了面向对象的原则，但它解决了分离命令的请求者和命令的执行者的问题。   Command命令的时机   1：需要在不同的时间指定请求、将请求排队。 2：系统需要支持命令的撤销。 3：如果一个系统要将系统中所有的数据更新到日志里，以便在系统崩溃时，可以根据日志里读回所有的数据更新命令，重新调用Execute()方法一条一条执行这些命令，从而恢复系统在崩溃前所做的数据更新。   命令模式的作用   1：它很容易的设计一个命令队列 2：在需要的情况下，可以教容易的将命令计入日志 3：允许接收请求的一方决定是否要否决请求 4：可以很容易的实现对请求的撤销和重做 5:由于加紧新的具体命令类不影响其它的类，因此增加新的具体命令类很容易，命令模式把请求的一个操作的对象与知道怎么执行一个操作的对象分隔开。   总结 Command模式轻松的实现了“行为请求者”与“行为实现者”的解耦。","title":"[置顶] 设计模式之七 命令模式（Command Pattern）"},{"content":"最近要整点自动翻译的东东，发现最亲民的Google的翻译API关闭了。那么摆在码农的面前大概也只有2条路， 一是，直接使用web版本的的google翻译，然后分析URL，和结果得到翻译结果。然后直接调用，网上好像已经有兄弟们这样干了。 二是，投奔微软的阵营，使用Bing的API， 由于我要翻译的东东好像在bing这儿的翻译效果还可以，另外也训练一下自己的Python能力，做点开源的事情。打算写个Python使用Bing的API代码测试一下。 Bing的翻译API也不是绝对免费，每个月可以翻译2M的字符的数据。这个当然不多，但一般人也够用了。（纯文本的圣经4M多）。超出后如果要再使用也必须付费， 费用好像是2M 40美刀。 另外Bing的API有一些有特色的地方，比如你可以在里面增加一些自己的翻译，帮助修正你的翻译结果，另外其还有语音能力。可以将你输入的语音转换为wav或者mp3文件。上流。 网上有些兄弟写过Bing的API，但是大部分是是对于V1的版本的，V2版本改了验证方式 现在微软已经使用了新的验证方式，使用APPID的方法已经玩不转了。每次使用前必须用一个access token的东东，你必须自己申请一个ClientID和Client密码。有兴趣了解详情的请参考 http://blogs.msdn.com/b/translation/p/gettingstarted1.aspx http://api.microsofttranslator.com   Bing的API有3种调用接口，Ajax，SOAP，HTTP。我用Python搞，估计HTTP的方式更加合适我一点。我的只实现了部分接口， 我实现的Bing 翻译V2的接口包括，翻译，得到翻译候选列表，（一次翻译多个语句）设置翻译内容，得到语音等几个，其他的感觉有点多余，未必用得到。 如果没有token或者Token超时，会自己重新去获取Token，使用起来也比较简单。 还是多说无益，上代码，注释应该足够丰富，大家肯定看的明白。   # coding=utf-8 '''     网上有些兄弟写过，但是大部分是是对于V1的版本的，V2版本改了验证方式 现在微软已经使用了新的验证方式，使用APPID的方法已经玩不转了。必须用一个access token的东东  清参考 http://blogs.msdn.com/b/translation/p/gettingstarted1.aspx http://api.microsofttranslator.com  '''  import urllib import urllib2 import json import time import unittest import xml.etree.ElementTree    class Get_Translate_Data(object):     '''     Get Translate 操作取回的数据的，解析后的得到的数据字段，     '''     def __init__(self):         # #翻译结果匹配程度         self._match_degree = 0         # #翻译结果被用户选择的次数         self._selected_count = 0         # #翻译结果可以认可的比率，MS自己有一套规则，自己上参考网址看         self._rating = 0         # #返回的结果         self._translated_text = \"\"              def __str__(self):         return (\"match_degree:%s selected_count:%s rating:%s translated_text:%s\")\\             % (self._match_degree, self._selected_count, self._rating, self._translated_text)   class Bing_Translator_API(object):     '''           此工具用于使用bing的翻译API，让你快速的得到翻译的结果           我是按照2012年12月22日看到的API V2的要求实现的，           实现的Bing 翻译V2的接口包括，翻译，得到翻译候选列表，（一次翻译多个语句）设置翻译内容，得到语音，     '''     # 最大请求的字符长度，微软的要求     REQ_STR_MAX_LEN = 10000     # add trascation 增加翻译的原文最大长度     ADD_ORIGINALTEXT_LEN = 1000     # add trascation 增加翻译的翻译文字长度     ADD_TRANSLATEDTEXT_LEN = 2000     # SPEEK string的最大值     SPEAK_STRING_LEN = 2000          # 最大返回的结果个数     RSP_RESULT_MAX_NUMBER = 10          # 取得acess token的两个参数，常量     ACCESS_TOKEN_REQ_SCOPE = \"http://api.microsofttranslator.com\"     ACCESS_TOKEN_REQ_GRANT_TYPE = \"client_credentials\"          # POST取得ACESS TOKEN的URL     ACCESS_TOKEN_REQ_URL = \"https://datamarket.accesscontrol.windows.net/v2/OAuth2-13\"     # GET方法得到翻译的结果，只得到一个结果，估计这个最常用     TRANSLATE_REQ_URL = \"http://api.microsofttranslator.com/V2/Http.svc/Translate\"     # POST取得翻译结果的结果的URL,这个是一次可以取回多个翻译结果     GET_TRANSLATE_REQ_URL = \"http://api.microsofttranslator.com/V2/Http.svc/GetTranslations\"     # 检测语句的语言     DETECT_REQ_URL = \"http://api.microsofttranslator.com/V2/Http.svc/Detect\"     # 增加翻译的URL     ADD_TRANSLATION_URL = \"http://api.microsofttranslator.com/V2/Http.svc/AddTranslation\"     # 发音的请求     SPEAK_REQ_URL = \"http://api.microsofttranslator.com/V2/Http.svc/Speak\"            # LC=language code,常用的几个都写在这儿，免得你还要查询     LC_CHINESE_SIMPLIFIED = \"zh-CHS\"     LC_CHINESE_TRADITIONAL = \"zh-CHT\"     LC_ENGLISH = \"en\"     LC_JAPANESE = \"ja\"     LC_KOREAN = \"ko\"     LC_FRENCH = \"fr\"     LC_GERMAN = \"de\"          def __init__ (self, client_id, client_secret, proxy_conf=None):         '''         @param client_id 客户端ID，你在MS网址注册得到的ID         @param client_secret 客户端密钥         @param proxy_conf 代理配置,默认None，不配置,如果配置http，https都要写，                     比如{'http': 'http://proxy.a.com:8080/','https': 'http://proxy.a.com:8080/'},折腾了我一个下午         '''                          # 你请求获得acess token的两个参数，客户端ID，和一个验证密码         self._client_id = client_id         self._client_secret = client_secret                  self._token_opener = None         self._api_opener = None                  # 如果有代理，配置代理         if proxy_conf == None :             self._token_opener = urllib2.build_opener()              self._api_opener = urllib2.build_opener()         else:             self._token_opener = urllib2.build_opener(urllib2.ProxyHandler(proxy_conf), urllib2.HTTPSHandler())             self._api_opener = urllib2.build_opener(urllib2.ProxyHandler(proxy_conf), urllib2.HTTPHandler())                self._access_token = \"\"                  self._expires_time = 0                       def __get_acess_token(self, retry_num=3):         '''         @brief 得到访问的access token，如果已经有了token，而且没有超时，就不继续使用原有的token         @retry_num 重试的次数         '''         # 检查超时与否，如果没有超时，什么都不做         if (time.time() - 10 < self._expires_time):             return 0                      post_data = urllib.urlencode({'client_id':self._client_id, \\                                       'client_secret':self._client_secret, \\                                       'scope':Bing_Translator_API.ACCESS_TOKEN_REQ_SCOPE,                                       'grant_type':Bing_Translator_API.ACCESS_TOKEN_REQ_GRANT_TYPE })          retry_count = 0          resp_data = None                  # 进行N词重试         while (retry_count < retry_num) :             try :                         resp_data = self._token_opener.open(fullurl=Bing_Translator_API.ACCESS_TOKEN_REQ_URL, \\                                                     data=post_data, \\                                                     timeout=10)             except Exception, e:                 retry_count += 1                 self._token_opener.close()                 print str(e), Bing_Translator_API.ACCESS_TOKEN_REQ_URL, retry_count                 continue             break                  self._token_opener.close()         if (retry_count == retry_num):             return -1                  str_data = unicode(resp_data.read())                  # 分析json得到数据和超时时间，                 token_data = json.loads(str_data)         # 注意，不要解码，我画蛇添足的搞了1个小时才发现这个错误         self._access_token = token_data[\"access_token\"]         self._expires_time = time.time() + int(token_data[\"expires_in\"])                              return 0          def translate(self, from_language, to_language , want_translate, content_type=\"text/plain\", category=\"general\", retry_num=3):         '''         @brief 得到翻译,只有一个翻译结果，作为返回值返回,         @notice 这个方法使用的是GET 请求         @param from_language 翻译的语言，参考前面的LC_XXX定义         @param to_language         @param want_translate 要翻译的的文本信息，必须用UTF8的编码，         @param content_type \"text/plain\" 或者\"text/html\"         @param category 分类，估计可以提高翻译的准确度，但MS也没有告知我们可以填写啥，默认\"general\"         @return 一个元组，第一个数值是int,==0表示成功，第二个是成功后翻译的语句，         '''         ret_text = \"\"          if (len(want_translate) > Bing_Translator_API.REQ_STR_MAX_LEN):             return (-1, ret_text)         # 检查token还是否有效，以及是否需要重新获取         ret = self.__get_acess_token(retry_num)         if (ret != 0):             return (ret, ret_text)                          # print self._api_opener.addheaders         # 得到请求的URL         url_all = Bing_Translator_API.TRANSLATE_REQ_URL + \"?\" + urllib.urlencode({'text':want_translate, \\                                    'from':from_language, \\                                    'to':to_language, \\                                    'contentType':content_type, \\                                    'category':category })         url_req = urllib2.Request(url=url_all)         url_req.add_header('Authorization', 'bearer ' + self._access_token)                  retry_count = 0          resp_data = None         # 进行N次重试         while (retry_count < retry_num) :             try :                         resp_data = self._token_opener.open(url_req, timeout=10)             except Exception, e:                 retry_count += 1                 print str(e), url_req, retry_count                 continue             else:                 break             finally:                 self._token_opener.close()                              if (retry_count == retry_num):             return (-1, ret_text)                  # 解析XML结果得到数据         xml_str = resp_data.read()         tag = xml.etree.ElementTree.fromstring(xml_str)         ret_text = tag.text                  return (0, ret_text)           def get_translate(self, from_language, to_language , want_translate, result_list, \\                       content_type=\"text/plain\", category=\"general\", user=\"\", uri=\"\", retry_num=3):         '''         @brief 得到翻译,可能有多个翻译的结果返回，返回的是一个列表，         @notice 这个方法使用的是GET 请求         @param  result_list 返回参数，返回的翻译list的Get_Translator_Data         @param  user 用户名称，默认为\"\",如果对翻译效果不满意，可以改为all         @param  uri  URI         @param 其他参数同translate函数,不多解释         @return 返回0表示成功，其他表示失败         '''                  if (len(want_translate) > Bing_Translator_API.REQ_STR_MAX_LEN):             return -1         # 检查token还是否有效，以及是否需要重新获取         ret = self.__get_acess_token(retry_num)         if (ret != 0):             return ret                           # 得到请求的URL         url_all = Bing_Translator_API.GET_TRANSLATE_REQ_URL + \"?\" + urllib.urlencode({'text':want_translate, \\                                    'from':from_language, \\                                    'to':to_language, \\                                    'maxTranslations':Bing_Translator_API.RSP_RESULT_MAX_NUMBER })                  # 其实不发送下面Post数据也可以发送请求(发送参数=\"\",不能不写，否则是GET请求)，也可以得到结果，我测试过。增加下面这段反而又让我调试了半天         # Post 请求的参数，里面的State是一个事务ID，请求带过去，返回的结果，MS给你带回来，你要希望使用，自己改造         # 这样的到的翻译很多，但效果感觉比较糟糕，估计有些是用户添加的，如果你不喜欢，可以在User的值改为all         post_data = \"<TranslateOptions xmlns=\\\"http://schemas.datacontract.org/2004/07/Microsoft.MT.Web.Service.V2\\\">\"\\                   \"<Category>%s<\/Category>\"\\                   \"<ContentType>%s<\/ContentType>\"\\                   \"<ReservedFlags><\/ReservedFlags>\"\\                   \"<State>20121221<\/State>\"\\                   \"<Uri>%s<\/Uri>\"\\                   \"<User>%s<\/User>\"\\                   \"<\/TranslateOptions>\" % (category, content_type, uri, user)                           url_req = urllib2.Request(url=url_all, data=post_data)         url_req.add_header('Authorization', 'bearer ' + self._access_token)         # 如果要加post数据，这行必须加，否返回500的错误，看了半天C#的例子         url_req.add_header('Content-Type', 'text/xml')         retry_count = 0          resp_data = None         # 进行N次重试         while (retry_count < retry_num) :             try :                         resp_data = self._token_opener.open(url_req, timeout=10)             except Exception, e:                 retry_count += 1                 print str(e), url_req, retry_count                 continue             else:                 break             finally:                 self._token_opener.close()                  if (retry_count == retry_num):             return -1                  # 倒霉的XML namespace，麻烦死了         MS_GETTRNS_NAMESPACES = \"http://schemas.datacontract.org/2004/07/Microsoft.MT.Web.Service.V2\"                  xml_str = resp_data.read()         tag = xml.etree.ElementTree.fromstring(xml_str)         # 前面非要家那个.//，而且还必须有那个XML的名字空间{http://schemas.datacontract.org/2004/07/Microsoft.MT.Web.Service.V2}         tans_list = tag.findall(\".//{%s}TranslationMatch\" % MS_GETTRNS_NAMESPACES)         for tag_item in tans_list:             trans_data = Get_Translate_Data()             for iter_item in tag_item.iter():                 if iter_item.tag == \"{%s}Count\" % MS_GETTRNS_NAMESPACES:                     trans_data._selected_count = int(iter_item.text)                 if iter_item.tag == \"{%s}MatchDegree\" % MS_GETTRNS_NAMESPACES:                     trans_data._match_degree = int(iter_item.text)                 if iter_item.tag == \"{%s}Rating\" % MS_GETTRNS_NAMESPACES:                     trans_data._rating = int(iter_item.text)                 if iter_item.tag == \"{%s}TranslatedText\" % MS_GETTRNS_NAMESPACES:                     trans_data._translated_text = iter_item.text             # print trans_data             result_list.append(trans_data)         return 0                  def detect(self, detect_text, retry_num=3):         '''         @brief 检查语句的语言         @notice 这个方法使用的是GET 请求         @param detect_text 检测的语句，必须用UTF8的编码，         @return 一个元组，第一个数值是int,==0表示成功，否则表示失败，第二个是成功后返回语言的标识，如果失败，返回''         '''         ret_text = \"\"          if (len(detect_text) > Bing_Translator_API.REQ_STR_MAX_LEN):             return (-1, ret_text)         # 检查token还是否有效，以及是否需要重新获取         ret = self.__get_acess_token(retry_num)         if (ret != 0):             return (ret, ret_text)                          # print self._api_opener.addheaders         # 得到请求的URL         url_all = Bing_Translator_API.DETECT_REQ_URL + \"?\" + urllib.urlencode({'text':detect_text})         url_req = urllib2.Request(url=url_all)         url_req.add_header('Authorization', 'bearer ' + self._access_token)                  retry_count = 0          resp_data = None         # 进行N次重试         while (retry_count < retry_num) :             try :                         resp_data = self._token_opener.open(url_req, timeout=10)             except Exception, e:                 retry_count += 1                 print str(e), url_req, retry_count                 continue             else:                 break             finally:                 self._token_opener.close()                              if (retry_count == retry_num):             return (-1, ret_text)                  # 解析XML结果得到数据         xml_str = resp_data.read()         tag = xml.etree.ElementTree.fromstring(xml_str)         ret_text = tag.text                  return (0, ret_text)          def add_translation(self, original_text, translated_text, from_language, to_language, user, \\                         rating=1, content_type=\"text/plain\", category=\"general\", uri=\"\", retry_num=3):         '''         @brief 增加翻译内容，用于改善后面的翻译         @notice 这个方法使用的是GET 请求         @param original_text 原文         @param translated_text 已经翻译的原文         @param from_language          @param to_language         @param usr 用户名称,估计在get的时候会有一些作用            @param rating -10~10         @param content_type \"text/plain\" 或者\"text/html\"         @param category 分类，估计可以提高翻译的准确度，但MS也没有告知我们可以填写啥，默认\"general\"         @param uri          @param retry_num 重试次数         @return 返回0表示成功，其他表示失败         '''                  if (len(original_text) > Bing_Translator_API.ADD_ORIGINALTEXT_LEN):             return -1         if (len(translated_text) > Bing_Translator_API.ADD_TRANSLATEDTEXT_LEN):             return -1         # 检查token还是否有效，以及是否需要重新获取         ret = self.__get_acess_token(retry_num)         if (ret != 0):             return (ret, ret_text)                          # print self._api_opener.addheaders         # 得到请求的URL         url_all = Bing_Translator_API.ADD_TRANSLATION_URL + \"?\" + urllib.urlencode({'originalText':original_text, \\                                    'translatedText':translated_text, \\                                    'from':from_language, \\                                    'to':to_language, \\                                    'rating':rating, \\                                    'contentType':content_type, \\                                    'category':category, \\                                    'user':user,                                    'uri':uri })         url_req = urllib2.Request(url=url_all)         url_req.add_header('Authorization', 'bearer ' + self._access_token)                  retry_count = 0          resp_data = None         # 进行N次重试         while (retry_count < retry_num) :             try :                         resp_data = self._token_opener.open(url_req, timeout=10)             except Exception, e:                 retry_count += 1                 print str(e), url_req, retry_count                 continue             else:                 break             finally:                 self._token_opener.close()                              if (retry_count == retry_num):             return -1                  return 0               def speak(self, speak_text, language, format=\"audio/wav\", options=\"MinSize\", retry_num=3):         '''         @brief 得到翻译,可能有多个翻译的结果返回，返回的是一个列表，         @notice 这个方法使用的是GET 请求         @param  speak_text          @param  language 语言         @param  format 为 audio/wav 或者  audio/mp3         @param  options 为“MaxQuality” 或者 \"MinSize\"         @return 返回0表示成功，其他表示失败         '''                  if (len(speak_text) > Bing_Translator_API.SPEAK_STRING_LEN):             return -1         # 检查token还是否有效，以及是否需要重新获取         ret = self.__get_acess_token(retry_num)         if (ret != 0):             return ret                  ret_speak = \"\"         # 得到请求的URL         url_all = Bing_Translator_API.SPEAK_REQ_URL + \"?\" + urllib.urlencode({'text':speak_text, \\                                    'language':language, \\                                    'format':format, \\                                    'options':options })         url_req = urllib2.Request(url=url_all)         url_req.add_header('Authorization', 'bearer ' + self._access_token)                  retry_count = 0          resp_data = None         # 进行N次重试         while (retry_count < retry_num) :             try :                         resp_data = self._token_opener.open(url_req, timeout=10)             except Exception, e:                 retry_count += 1                 print str(e), url_req, retry_count                 continue             else:                 break             finally:                 self._token_opener.close()                              if (retry_count == retry_num):             return (-1, ret_speak)                  # 解析XML结果得到数据         ret_speak = resp_data.read()                          return (0, ret_speak)  #单元测试，单元测试 class Test_Bing_Translator_API(unittest.TestCase):      def setUp(self):         # self._test_api = Bing_Translator_API(client_id=\"你的客户端ID\",\\         #                                    client_secret=\"你的客户端密钥\")         self._test_api = Bing_Translator_API(client_id=\"你的客户端ID\", \\                                             client_secret=\"你的客户端密钥\", \\                                             proxy_conf={'http': '你的代理服务器:端口/', 'https': '你的代理服务器:端口'})                       def test_translate(self):          ret, trans_str = self._test_api.translate(Bing_Translator_API.LC_CHINESE_SIMPLIFIED, \\                                             Bing_Translator_API.LC_ENGLISH, \\                                             \"中华人民共和国\");         print ret , trans_str              test_string = \"中华人民共和国\"         test_gb2312 = test_string.encode('gb2312')         # 这个地方翻译会错误，所以编码不能用GB2312这类编码         ret, trans_str = self._test_api.translate(Bing_Translator_API.LC_CHINESE_SIMPLIFIED, \\                                             Bing_Translator_API.LC_ENGLISH, \\                                             test_gb2312);         print ret , trans_str          def test_get_translate(self):         result_list = []         ret = self._test_api.get_translate(Bing_Translator_API.LC_CHINESE_SIMPLIFIED, \\                         Bing_Translator_API.LC_ENGLISH, \\                         \"中华人民共和国\",                         result_list);         for trans_data in result_list :             print trans_data         result_list = []         ret = self._test_api.get_translate(Bing_Translator_API.LC_ENGLISH, \\                         Bing_Translator_API.LC_CHINESE_SIMPLIFIED, \\                         \"to\",                         result_list);         for trans_data in result_list :             print trans_data          def test_detect(self):         ret, detect_lan = self._test_api.detect(\"中华人民共和国\")         print ret, detect_lan         ret, detect_lan = self._test_api.detect(\"made in china\")         print ret, detect_lan           def test_add_translation(self):         ret = self._test_api.add_translation(original_text=\"china\", \\                                     translated_text=\"瓷器\", \\                                     from_language=Bing_Translator_API.LC_ENGLISH, \\                                     to_language=Bing_Translator_API.LC_CHINESE_SIMPLIFIED, \\                                     user=\"fullsail\")         print ret         result_list = []         ret = self._test_api.get_translate(Bing_Translator_API.LC_ENGLISH, \\                         Bing_Translator_API.LC_CHINESE_SIMPLIFIED, \\                         \"china\",                         result_list,                         user=\"fullsail\");         for trans_data in result_list :             print trans_data                       def test_speek(self):         ret, ret_speak = self._test_api.speak(speak_text=\"人一走，茶就凉，是自然规律；人没走，茶就凉，是世态炎凉。一杯茶，佛门看到的是禅，道家看到的是气，儒家看到的是礼，商家看到的是利。茶说：我就是一杯水，给你的只是你的想像，你想什么，什么就是你。心即茶，茶即心。\", \\                         language=Bing_Translator_API.LC_CHINESE_SIMPLIFIED);                                       file_hdl = open(\"D:\\\\123.wav\", \"wb+\")         file_hdl.write(ret_speak)         file_hdl.close()      if __name__ == '__main__':     unittest.main()   最早看python应该是8年前了，但直到最近2个月才使用，计算机是实践科学，看了不用，等于浪费，没有任何效果 这次算是一个小小的进步。   【本文作者是雁渡寒潭，本着自由的精神，你可以在无盈利的情况完整转载此文档，转载时请附上BLOG链接:http://www.cnblogs.com/fullsail/ 或者http://blog.csdn.net/fullsail，否则每字一元，每图一百不讲价。对Baidu文库。360doc加价一倍】 想得卻不可得 你奈人生何 該捨的捨不得 只顧著跟往事瞎扯","title":"[置顶] 让Python使用Bing翻译API V2"},{"content":"快速排序是对冒泡排序的一种改进。它的基本思想是：通过一躺排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一不部分的所有数据都要小，然后再按次方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 快速排序(Quick Sort)是一种有效的排序算法。虽然算法在最坏的情况下运行时间为O(n^2)(当序列本身就处于有序状态时候就会出现这个情况)，但由于平均运行时间为O(nlogn)，并且在内存使用、程序实现复杂性上表现优秀，尤其是对快速排序算法进行随机化的可能，使得快速排序在一般情况下是最实用的排序方法之一。 　快速排序被认为是当前最优秀的内部排序方法。 其中一躺快速排序的算法是：    1）、设置两个变量I、J，排序开始的时候I：=1，J：=N；    2）以第一个数组元素作为关键数据，赋值给X，即X：=A[1]；    3）、从J开始向前搜索，即由后开始向前搜索（J：=J-1），找到第一个小于X的值，两者交换；    4）、从I开始向后搜索，即由前开始向后搜索（I：=I+1），找到第一个大于X的值，两者交换；    5）、重复第3、4步，直到I=J //快速排序//基本思想：用递归的思想，取某个数为基准，每次都将参加排序的序列分成两部分，排在基准数左边的数都比它小，排在右边的数都比它大，//直到每个序列基本只有一个数时候，排序基本完成#include <iostream>using namespace std;int partition(int *a,int low,int high){\tint pivotpos = low;\tint pivot = a[low];//定义基准元素\t\tfor(int i=low+1 ; i<=high ; i++){//检测整个序列，进行划分\t\tif(a[i]<pivot){\t\t\tpivotpos++;\t\t\tif(pivotpos != i)\t\t\t\tswap(a[pivotpos],a[i]);//小于基准的全部放到左侧\t\t}\t} \ta[low] = a[pivotpos];\ta[pivotpos]=pivot;//将基准元素就位\treturn pivotpos;//返回基准元素的位置}\tvoid quickSort(int *a,int left,int right){\t\tif(left < right){//结束条件\t\t\t\tint pivotpos = partition(a,left,right);//划分\t\t\t\tquickSort(a,left,pivotpos-1);//对左侧子序进行同样的处理\t\t\t\tquickSort(a,pivotpos+1,right);//对右侧子序进行同样的处理\t\t}\t}void main(){\tint a[]={45,36,18,53,72,30,48,93,15,36};//定义一个数组，用来测试\tfor(int i=0 ;i<10;i++){\t\tcout<<a[i]<<\" \";//输出未排序前的顺序\t}\tcout<<endl;\tcout<<\"After that:\"<<endl;\t\tquickSort(a,0,9);//进行快速排序  \tfor(int i=0;i<10;i++){\t\tcout<<a[i]<<\" \";//输出排序后的顺序\t}\tcout<<endl;}","title":"[置顶] 快速排序 知识点小结"},{"content":"这是本小人书。原名是《using stl》，不知道是谁写的。不过我倒觉得很有趣，所以化了两个晚上把它翻译出来。我没有对翻译出来的内容校验过。如果你没法在三十分钟内觉得有所收获，那么赶紧扔了它。文中我省略了很多东西。心疼那，浪费我两个晚上。 译者：kary contact:karymay@163.net STL概述 STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但这种分离确实使得STL变得非常通用。例如，由于STL的sort()函数是完全通用的，你可以用它来操作几乎任何数据集合，包括链表，容器和数组。 要点 STL算法作为模板函数提供。为了和其他组件相区别，在本书中STL算法以后接一对圆括弧的方式表示，例如sort()。 STL另一个重要特性是它不是面向对象的。为了具有足够通用性，STL主要依赖于模板而不是封装，继承和虚函数（多态性）——OOP的三个要素。你在STL中找不到任何明显的类继承关系。这好像是一种倒退，但这正好是使得STL的组件具有广泛通用性的底层特征。另外，由于STL是基于模板，内联函数的使用使得生成的代码短小高效。 提示 确保在编译使用了STL的程序中至少要使用-O优化来保证内联扩展。STL提供了大量的模板类和函数，可以在OOP和常规编程中使用。所有的STL的大约50个算法都是完全通用的，而且不依赖于任何特定的数据类型。下面的小节说明了三个基本的STL组件： 1）           迭代器提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象。 2）           容器是一种数据结构，如list，vector，和deques ，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器。 3）           算法是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象。函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用。 头文件 为了避免和其他头文件冲突， STL的头文件不再使用常规的.h扩展。为了包含标准的string类，迭代器和算法，用下面的指示符： #include <string> #include <iterator> #include <algorithm> 如果你查看STL的头文件，你可以看到象iterator.h和stl_iterator.h这样的头文件。由于这些名字在各种STL实现之间都可能不同，你应该避免使用这些名字来引用这些头文件。为了确保可移植性，使用相应的没有.h后缀的文件名。表1列出了最常使用的各种容器类的头文件。该表并不完整，对于其他头文件，我将在本章和后面的两章中介绍。 表 1. STL头文件和容器类 #include Container Class <deque> deque <list> list <map> map, multimap <queue> queue, priority_queue <set> set, multiset <stack> stack <vector> vector, vector<bool> 名字空间 你的编译器可能不能识别名字空间。名字空间就好像一个信封，将标志符封装在另一个名字中。标志符只在名字空间中存在，因而避免了和其他标志符冲突。例如，可能有其他库和程序模块定义了sort()函数，为了避免和STL地sort()算法冲突，STL的sort()以及其他标志符都封装在名字空间std中。STL的sort()算法编译为std::sort()，从而避免了名字冲突。 尽管你的编译器可能没有实现名字空间，你仍然可以使用他们。为了使用STL，可以将下面的指示符插入到你的源代码文件中，典型地是在所有的#include指示符的后面： using namespace std; 迭代器 迭代器提供对一个容器中的对象的访问方法，并且定义了容器中对象的范围。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器不仅仅是指针，因此你不能认为他们一定具有地址值。例如，一个数组索引，也可以认为是一种迭代器。 迭代器有各种不同的创建方法。程序可能把迭代器作为一个变量创建。一个STL容器类可能为了使用一个特定类型的数据而创建一个迭代器。作为指针，必须能够使用*操作符类获取数据。你还可以使用其他数学操作符如++。典型的，++操作符用来递增迭代器，以访问容器中的下一个对象。如果迭代器到达了容器中的最后一个元素的后面，则迭代器变成past-the-end值。使用一个past-the-end值得指针来访问对象是非法的，就好像使用NULL或为初始化的指针一样。 提示 STL不保证可以从另一个迭代器来抵达一个迭代器。例如，当对一个集合中的对象排序时，如果你在不同的结构中指定了两个迭代器，第二个迭代器无法从第一个迭代器抵达，此时程序注定要失败。这是STL灵活性的一个代价。STL不保证检测毫无道理的错误。 迭代器的类型 对于STL数据结构和算法，你可以使用五种迭代器。下面简要说明了这五种类型： ·        Input iterators 提供对数据的只读访问。 ·        Output iterators 提供对数据的只写访问 ·        Forward iterators 提供读写操作，并能向前推进迭代器。 ·        Bidirectional iterators提供读写操作，并能向前和向后操作。 ·        Random access iterators提供读写操作，并能在数据中随机移动。 尽管各种不同的STL实现细节方面有所不同，还是可以将上面的迭代器想象为一种类继承关系。从这个意义上说，下面的迭代器继承自上面的迭代器。由于这种继承关系，你可以将一个Forward迭代器作为一个output或input迭代器使用。同样，如果一个算法要求是一个bidirectional 迭代器，那么只能使用该种类型和随机访问迭代器。 指针迭代器 正如下面的小程序显示的，一个指针也是一种迭代器。该程序同样显示了STL的一个主要特性——它不只是能够用于它自己的类类型，而且也能用于任何C或C++类型。Listing 1, iterdemo.cpp, 显示了如何把指针作为迭代器用于STL的find()算法来搜索普通的数组。 表 1. iterdemo.cpp #include <iostream.h> #include <algorithm>   using namespace std;   #define SIZE 100 int iarray[SIZE];   int main() {   iarray[20] = 50;   int* ip = find(iarray, iarray + SIZE, 50);   if (ip == iarray + SIZE)     cout << \"50 not found in array\" << endl;   else     cout << *ip << \" found in array\" << endl;   return 0; } 在引用了I/O流库和STL算法头文件（注意没有.h后缀），该程序告诉编译器使用std名字空间。使用std名字空间的这行是可选的，因为可以删除该行对于这么一个小程序来说不会导致名字冲突。 程序中定义了尺寸为SIZE的全局数组。由于是全局变量，所以运行时数组自动初始化为零。下面的语句将在索引20位置处地元素设置为50,并使用find()算法来搜索值50: iarray[20] = 50; int* ip = find(iarray, iarray + SIZE, 50); find()函数接受三个参数。头两个定义了搜索的范围。由于C和C++数组等同于指针，表达式iarray指向数组的第一个元素。而第二个参数iarray + SIZE等同于past-the-end 值，也就是数组中最后一个元素的后面位置。第三个参数是待定位的值，也就是50。find()函数返回和前两个参数相同类型的迭代器，这儿是一个指向整数的指针ip。 提示 必须记住STL使用模板。因此，STL函数自动根据它们使用的数据类型来构造。 为了判断find()是否成功，例子中测试ip和 past-the-end 值是否相等： if (ip == iarray + SIZE) ... 如果表达式为真，则表示在搜索的范围内没有指定的值。否则就是指向一个合法对象的指针，这时可以用下面的语句显示：: cout << *ip << \" found in array\" << endl; 测试函数返回值和NULL是否相等是不正确的。不要象下面这样使用： int* ip = find(iarray, iarray + SIZE, 50); if (ip != NULL) ...  // ??? incorrect 当使用STL函数时，只能测试ip是否和past-the-end 值是否相等。尽管在本例中ip是一个C++指针,其用法也必须符合STL迭代器的规则。 容器迭代器 尽管C++指针也是迭代器，但用的更多的是容器迭代器。容器迭代器用法和iterdemo.cpp一样，但和将迭代器申明为指针变量不同的是，你可以使用容器类方法来获取迭代器对象。两个典型的容器类方法是begin()和end()。它们在大多数容器中表示整个容器范围。其他一些容器还使用rbegin()和rend()方法提供反向迭代器，以按反向顺序指定对象范围。 下面的程序创建了一个矢量容器（STL的和数组等价的对象），并使用迭代器在其中搜索。该程序和前一章中的程序相同。 Listing 2. vectdemo.cpp #include <iostream.h> #include <algorithm> #include <vector>   using namespace std;   vector<int> intVector(100);   void main() {   intVector[20] = 50;   vector<int>::iterator intIter =     find(intVector.begin(), intVector.end(), 50);   if (intIter != intVector.end())     cout << \"Vector contains value \" << *intIter << endl;   else     cout << \"Vector does not contain 50\" << endl; }   注意用下面的方法显示搜索到的数据： cout << \"Vector contains value \" << *intIter << endl; 常量迭代器 和指针一样，你可以给一个迭代器赋值。例如，首先申明一个迭代器： vector<int>::iterator first; 该语句创建了一个vector<int>类的迭代器。下面的语句将该迭代器设置到intVector的第一个对象，并将它指向的对象值设置为123：: first = intVector.begin(); *first = 123; 这种赋值对于大多数容器类都是允许的，除了只读变量。为了防止错误赋值，可以申明迭代器为： const vector<int>::iterator result; result = find(intVector.begin(), intVector.end(), value); if (result != intVector.end())   *result = 123;  // ??? 警告 另一种防止数据被改变得方法是将容器申明为const类型。 『呀！在VC中测试出错,正确的含义是result成为常量而不是它指向的对象不允许改变，如同int *const p;看来这作者自己也不懂』 使用迭代器编程 你已经见到了迭代器的一些例子，现在我们将关注每种特定的迭代器如何使用。由于使用迭代器需要关于STL容器类和算法的知识，在阅读了后面的两章后你可能需要重新复习一下本章内容。 输入迭代器 输入迭代器是最普通的类型。输入迭代器至少能够使用==和!=测试是否相等；使用*来访问数据；使用++操作来递推迭代器到下一个元素或到达past-the-end 值。 为了理解迭代器和STL函数是如何使用它们的，现在来看一下find()模板函数的定义： template <class InputIterator, class T> InputIterator find(   InputIterator first, InputIterator last, const T& value) {     while (first != last && *first != value) ++first;     return first;   } 注意 在find()算法中，注意如果first和last指向不同的容器，该算法可能陷入死循环。 输出迭代器 输出迭代器缺省只写，通常用于将数据从一个位置拷贝到另一个位置。由于输出迭代器无法读取对象，因此你不会在任何搜索和其他算法中使用它。要想读取一个拷贝的值，必须使用另一个输入迭代器（或它的继承迭代器）。 Listing 3. outiter.cpp #include <iostream.h> #include <algorithm>   // Need copy() #include <vector>      // Need vector   using namespace std;   double darray[10] =   {1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9};   vector<double> vdouble(10);   int main() {   vector<double>::iterator outputIterator = vdouble.begin();   copy(darray, darray + 10, outputIterator);   while (outputIterator != vdouble.end()) {     cout << *outputIterator << endl;     outputIterator++;   }   return 0; } 注意 当使用copy()算法的时候，你必须确保目标容器有足够大的空间，或者容器本身是自动扩展的。 前推迭代器 前推迭代器能够读写数据值，并能够向前推进到下一个值。但是没法递减。replace()算法显示了前推迭代器的使用方法。 template <class ForwardIterator, class T> void replace (ForwardIterator first,               ForwardIterator last,               const T& old_value,               const T& new_value); 使用replace()将[first,last]范围内的所有值为old_value的对象替换为new_value。: replace(vdouble.begin(), vdouble.end(), 1.5, 3.14159); 双向迭代器 双向迭代器要求能够增减。如reverse()算法要求两个双向迭代器作为参数: template <class BidirectionalIterator> void reverse (BidirectionalIterator first,               BidirectionalIterator last); 使用reverse()函数来对容器进行逆向排序: reverse(vdouble.begin(), vdouble.end()); 随机访问迭代器 随机访问迭代器能够以任意顺序访问数据，并能用于读写数据（不是const的C++指针也是随机访问迭代器）。STL的排序和搜索函数使用随机访问迭代器。随机访问迭代器可以使用关系操作符作比较。 random_shuffle() 函数随机打乱原先的顺序。申明为： template <class RandomAccessIterator> void random_shuffle (RandomAccessIterator first,                      RandomAccessIterator last); 使用方法： random_shuffle(vdouble.begin(), vdouble.end()); 迭代器技术 要学会使用迭代器和容器以及算法，需要学习下面的新技术。 流和迭代器 本书的很多例子程序使用I/O流语句来读写数据。例如： int value; cout << \"Enter value: \"; cin >> value; cout << \"You entered \" << value << endl; 对于迭代器，有另一种方法使用流和标准函数。理解的要点是将输入/输出流作为容器看待。因此，任何接受迭代器参数的算法都可以和流一起工作。 Listing 4. outstrm.cpp #include <iostream.h> #include <stdlib.h>    // Need random(), srandom() #include <time.h>      // Need time() #include <algorithm>   // Need sort(), copy() #include <vector>      // Need vector   using namespace std;   void Display(vector<int>& v, const char* s);   int main() {   // Seed the random number generator   srandom( time(NULL) );     // Construct vector and fill with random integer values   vector<int> collection(10);   for (int i = 0; i < 10; i++)     collection[i] = random() % 10000;;     // Display, sort, and redisplay   Display(collection, \"Before sorting\");   sort(collection.begin(), collection.end());   Display(collection, \"After sorting\");   return 0; }   // Display label s and contents of integer vector v void Display(vector<int>& v, const char* s) {   cout << endl << s << endl;   copy(v.begin(), v.end(),     ostream_iterator<int>(cout, \"\\t\"));   cout << endl; } 函数Display()显示了如何使用一个输出流迭代器。下面的语句将容器中的值传输到cout输出流对象中: copy(v.begin(), v.end(),   ostream_iterator<int>(cout, \"\\t\")); 第三个参数实例化了ostream_iterator<int>类型，并将它作为copy()函数的输出目标迭代器对象。“\\t”字符串是作为分隔符。运行结果： $ g++ outstrm.cpp $ ./a.out Before sorting 677   722   686   238   964   397   251   118   11    312 After sorting 11    118   238   251   312   397   677   686   722   964 这是STL神奇的一面『确实神奇』。为定义输出流迭代器，STL提供了模板类ostream_iterator。这个类的构造函数有两个参数：一个ostream对象和一个string值。因此可以象下面一样简单地创建一个迭代器对象： ostream_iterator<int>(cout, \"\\n\") 该迭代起可以和任何接受一个输出迭代器的函数一起使用。 插入迭代器 插入迭代器用于将值插入到容器中。它们也叫做适配器，因为它们将容器适配或转化为一个迭代器，并用于copy()这样的算法中。例如，一个程序定义了一个链表和一个矢量容器: list<double> dList; vector<double> dVector; 通过使用front_inserter迭代器对象，可以只用单个copy()语句就完成将矢量中的对象插入到链表前端的操作： copy(dVector.begin(), dVector.end(), front_inserter(dList)); 三种插入迭代器如下： ·        普通插入器 将对象插入到容器任何对象的前面。 ·        Front inserters 将对象插入到数据集的前面——例如，链表表头。 ·        Back inserters 将对象插入到集合的尾部——例如，矢量的尾部，导致矢量容器扩展。 使用插入迭代器可能导致容器中的其他对象移动位置，因而使得现存的迭代器非法。例如，将一个对象插入到矢量容器将导致其他值移动位置以腾出空间。一般来说，插入到象链表这样的结构中更为有效，因为它们不会导致其他对象移动。 Listing 5. insert.cpp #include <iostream.h> #include <algorithm> #include <list>   using namespace std;   int iArray[5] = { 1, 2, 3, 4, 5 };   void Display(list<int>& v, const char* s);   int main() {   list<int> iList;     // Copy iArray backwards into iList   copy(iArray, iArray + 5, front_inserter(iList));   Display(iList, \"Before find and copy\");     // Locate value 3 in iList   list<int>::iterator p =     find(iList.begin(), iList.end(), 3);     // Copy first two iArray values to iList ahead of p   copy(iArray, iArray + 2, inserter(iList, p));   Display(iList, \"After find and copy\");     return 0; }   void Display(list<int>& a, const char* s) {   cout << s << endl;   copy(a.begin(), a.end(),     ostream_iterator<int>(cout, \" \"));   cout << endl; } 运行结果如下： $ g++ insert.cpp $ ./a.out Before find and copy 5 4 3 2 1 After find and copy 5 4 1 2 3 2 1 可以将front_inserter替换为back_inserter试试。 如果用find()去查找在列表中不存在的值，例如99。由于这时将p设置为past-the-end 值。最后的copy()函数将iArray的值附加到链表的后部。 混合迭代器函数 在涉及到容器和算法的操作中，还有两个迭代器函数非常有用： ·        advance() 按指定的数目增减迭代器。 ·        distance() 返回到达一个迭代器所需（递增）操作的数目。 例如： list<int> iList; list<int>::iterator p =   find(iList.begin(), iList.end(), 2); cout << \"before: p == \" << *p << endl; advance(p, 2);  // same as p = p + 2; cout << \"after : p == \" << *p << endl;   int k = 0; distance(p, iList.end(), k); cout << \"k == \" << k << endl;   advance()函数接受两个参数。第二个参数是向前推进的数目。对于前推迭代器，该值必须为正，而对于双向迭代器和随机访问迭代器，该值可以为负。 使用 distance()函数来返回到达另一个迭代器所需要的步骤。 注意 distance()函数是迭代的，也就是说，它递增第三个参数。因此，你必须初始化该参数。未初始化该参数几乎注定要失败。 函数和函数对象 STL中，函数被称为算法，也就是说它们和标准C库函数相比，它们更为通用。STL算法通过重载operator()函数实现为模板类或模板函数。这些类用于创建函数对象，对容器中的数据进行各种各样的操作。下面的几节解释如何使用函数和函数对象。 函数和断言 经常需要对容器中的数据进行用户自定义的操作。例如，你可能希望遍历一个容器中所有对象的STL算法能够回调自己的函数。例如 #include <iostream.h> #include <stdlib.h>     // Need random(), srandom() #include <time.h>       // Need time() #include <vector>       // Need vector #include <algorithm>    // Need for_each()   #define VSIZE 24        // Size of vector vector<long> v(VSIZE);  // Vector object   // Function prototypes void initialize(long &ri); void show(const long &ri); bool isMinus(const long &ri);  // Predicate function   int main() {   srandom( time(NULL) );  // Seed random generator     for_each(v.begin(), v.end(), initialize);//调用普通函数   cout << \"Vector of signed long integers\" << endl;   for_each(v.begin(), v.end(), show);   cout << endl;     // Use predicate function to count negative values   //   int count = 0;   vector<long>::iterator p;   p = find_if(v.begin(), v.end(), isMinus);//调用断言函数   while (p != v.end()) {     count++;     p = find_if(p + 1, v.end(), isMinus);   }   cout << \"Number of values: \" << VSIZE << endl;   cout << \"Negative values : \" << count << endl;     return 0; }   // Set ri to a signed integer value void initialize(long &ri) {   ri = ( random() - (RAND_MAX / 2) );   //  ri = random(); }   // Display value of ri void show(const long &ri) {   cout << ri << \"  \"; }   // Returns true if ri is less than 0 bool isMinus(const long &ri) {   return (ri < 0); }   所谓断言函数，就是返回bool值的函数。 函数对象 除了给STL算法传递一个回调函数，你还可能需要传递一个类对象以便执行更复杂的操作。这样的一个对象就叫做函数对象。实际上函数对象就是一个类，但它和回调函数一样可以被回调。例如，在函数对象每次被for_each()或find_if()函数调用时可以保留统计信息。函数对象是通过重载operator()()实现的。如果TanyClass定义了opeator()(),那么就可以这么使用： TAnyClass object;  // Construct object object();          // Calls TAnyClass::operator()() function for_each(v.begin(), v.end(), object); STL定义了几个函数对象。由于它们是模板，所以能够用于任何类型，包括C/C++固有的数据类型，如long。有些函数对象从名字中就可以看出它的用途，如plus()和multiplies()。类似的greater()和less-equal()用于比较两个值。 注意 有些版本的ANSI C++定义了times()函数对象，而GNU C++把它命名为multiplies()。使用时必须包含头文件<functional>。 一个有用的函数对象的应用是accumulate() 算法。该函数计算容器中所有值的总和。记住这样的值不一定是简单的类型，通过重载operator+()，也可以是类对象。 Listing 8. accum.cpp   #include <iostream.h> #include <numeric>      // Need accumulate() #include <vector>       // Need vector #include <functional>   // Need multiplies() (or times())   #define MAX 10 vector<long> v(MAX);    // Vector object   int main() {   // Fill vector using conventional loop   //   for (int i = 0; i < MAX; i++)     v[i] = i + 1;     // Accumulate the sum of contained values   //   long sum =     accumulate(v.begin(), v.end(), 0);   cout << \"Sum of values == \" << sum << endl;     // Accumulate the product of contained values   //   long product =     accumulate(v.begin(), v.end(), 1, multiplies<long>());//注意这行   cout << \"Product of values == \" << product << endl;     return 0; } 编译输出如下： $ g++ accum.cpp $ ./a.out Sum of values == 55 Product of values == 3628800 『注意使用了函数对象的accumulate()的用法。accumulate() 在内部将每个容器中的对象和第三个参数作为multiplies函数对象的参数,multiplies(1,v)计算乘积。VC中的这些模板的源代码如下：         // TEMPLATE FUNCTION accumulate template<class _II, class _Ty> inline     _Ty accumulate(_II _F, _II _L, _Ty _V)     {for (; _F != _L; ++_F)         _V = _V + *_F;     return (_V); }         // TEMPLATE FUNCTION accumulate WITH BINOP template<class _II, class _Ty, class _Bop> inline     _Ty accumulate(_II _F, _II _L, _Ty _V, _Bop _B)     {for (; _F != _L; ++_F)         _V = _B(_V, *_F);     return (_V); }         // TEMPLATE STRUCT binary_function template<class _A1, class _A2, class _R>     struct binary_function {     typedef _A1 first_argument_type;     typedef _A2 second_argument_type;     typedef _R result_type;     };         // TEMPLATE STRUCT multiplies template<class _Ty>     struct multiplies : binary_function<_Ty, _Ty, _Ty> {     _Ty operator()(const _Ty& _X, const _Ty& _Y) const         {return (_X * _Y); }     }; 引言：如果你想深入了解STL到底是怎么实现的，最好的办法是写个简单的程序，将程序中涉及到的模板源码给copy下来，稍作整理，就能看懂了。所以没有必要去买什么《STL源码剖析》之类的书籍，那些书可能反而浪费时间。』 发生器函数对象 有一类有用的函数对象是“发生器”(generator)。这类函数有自己的内存，也就是说它能够从先前的调用中记住一个值。例如随机数发生器函数。 普通的C程序员使用静态或全局变量 “记忆”上次调用的结果。但这样做的缺点是该函数无法和它的数据相分离『还有个缺点是要用TLS才能线程安全』。显然，使用类来封装一块：“内存”更安全可靠。先看一下例子： Listing 9. randfunc.cpp #include <iostream.h> #include <stdlib.h>    // Need random(), srandom() #include <time.h>      // Need time() #include <algorithm>   // Need random_shuffle() #include <vector>      // Need vector #include <functional>  // Need ptr_fun()   using namespace std;   // Data to randomize int iarray[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; vector<int> v(iarray, iarray + 10);   // Function prototypes void Display(vector<int>& vr, const char *s); unsigned int RandInt(const unsigned int n);   int main() {   srandom( time(NULL) );  // Seed random generator   Display(v, \"Before shuffle:\");     pointer_to_unary_function<unsigned int, unsigned int>     ptr_RandInt = ptr_fun(RandInt);  // Pointer to RandInt()//注意这行   random_shuffle(v.begin(), v.end(), ptr_RandInt);     Display(v, \"After shuffle:\");   return 0; }   // Display contents of vector vr void Display(vector<int>& vr, const char *s) {   cout << endl << s << endl;   copy(vr.begin(), vr.end(), ostream_iterator<int>(cout, \" \"));   cout << endl; }     // Return next random value in sequence modulo n unsigned int RandInt(const unsigned int n) {   return random() % n; } 编译运行结果如下： $ g++ randfunc.cpp $ ./a.out Before shuffle: 1 2 3 4 5 6 7 8 9 10 After shuffle: 6 7 2 8 3 5 10 1 9 4 首先用下面的语句申明一个对象： pointer_to_unary_function<unsigned int, unsigned int>   ptr_RandInt = ptr_fun(RandInt); 这儿使用STL的单目函数模板定义了一个变量ptr_RandInt，并将地址初始化到我们的函数RandInt()。单目函数接受一个参数，并返回一个值。现在random_shuffle()可以如下调用： random_shuffle(v.begin(), v.end(), ptr_RandInt); 在本例子中，发生器只是简单的调用rand()函数。   关于常量引用的一点小麻烦（不翻译了，VC下将例子中的const去掉） 发生器函数类对象 下面的例子说明发生器函数类对象的使用。 Listing 10. fiborand.cpp #include <iostream.h> #include <algorithm>   // Need random_shuffle() #include <vector>      // Need vector #include <functional>  // Need unary_function   using namespace std;   // Data to randomize int iarray[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; vector<int> v(iarray, iarray + 10);   // Function prototype void Display(vector<int>& vr, const char *s);   // The FiboRand template function-object class template <class Arg> class FiboRand : public unary_function<Arg, Arg> {   int i, j;   Arg sequence[18]; public:   FiboRand();   Arg operator()(const Arg& arg); };   void main() {   FiboRand<int> fibogen;  // Construct generator object   cout << \"Fibonacci random number generator\" << endl;   cout << \"using random_shuffle and a function object\" << endl;   Display(v, \"Before shuffle:\");   random_shuffle(v.begin(), v.end(), fibogen);   Display(v, \"After shuffle:\"); }   // Display contents of vector vr void Display(vector<int>& vr, const char *s) {   cout << endl << s << endl;   copy(vr.begin(), vr.end(),     ostream_iterator<int>(cout, \" \"));   cout << endl; }   // FiboRand class constructor template<class Arg> FiboRand<Arg>::FiboRand() {   sequence[17] = 1;   sequence[16] = 2;   for (int n = 15; n > 0; n—)     sequence[n] = sequence[n + 1] + sequence[n + 2];   i = 17;   j = 5; }   // FiboRand class function operator template<class Arg> Arg FiboRand<Arg>::operator()(const Arg& arg) {   Arg k = sequence[i] + sequence[j];   sequence[i] = k;   i--;   j--;   if (i == 0) i = 17;   if (j == 0) j = 17;   return k % arg; } 编译运行输出如下: $ g++ fiborand.cpp $ ./a.out Fibonacci random number generator using random_shuffle and a function object Before shuffle: 1 2 3 4 5 6 7 8 9 10 After shuffle: 6 8 5 4 3 7 10 1 9 该程序用完全不通的方法使用使用rand_shuffle。Fibonacci 发生器封装在一个类中，该类能从先前的“使用”中记忆运行结果。在本例中，类FiboRand 维护了一个数组和两个索引变量I和j。 FiboRand类继承自unary_function() 模板: template <class Arg> class FiboRand : public unary_function<Arg, Arg> {... Arg是用户自定义数据类型。该类还定以了两个成员函数，一个是构造函数，另一个是operator()（）函数，该操作符允许random_shuffle()算法象一个函数一样“调用”一个FiboRand对象。 绑定器函数对象 一个绑定器使用另一个函数对象f()和参数值V创建一个函数对象。被绑定函数对象必须为双目函数，也就是说有两个参数,A和B。STL 中的帮定器有： ·        bind1st() 创建一个函数对象，该函数对象将值V作为第一个参数A。 ·        bind2nd()创建一个函数对象，该函数对象将值V作为第二个参数B。 举例如下： Listing 11. binder.cpp #include <iostream.h> #include <algorithm> #include <functional> #include <list>   using namespace std;   // Data int iarray[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; list<int> aList(iarray, iarray + 10);   int main() {   int k = 0;   count_if(aList.begin(), aList.end(),     bind1st(greater<int>(), 8), k);   cout << \"Number elements < 8 == \" << k << endl;   return 0; } Algorithm count_if()计算满足特定条件的元素的数目。 这是通过将一个函数对象和一个参数捆绑到为一个对象，并将该对象作为算法的第三个参数实现的。 注意这个表达式: bind1st(greater<int>(), 8) 该表达式将greater<int>()和一个参数值8捆绑为一个函数对象。由于使用了bind1st()，所以该函数相当于计算下述表达式： 8 > q 表达式中的q是容器中的对象。因此，完整的表达式 count_if(aList.begin(), aList.end(),   bind1st(greater<int>(), 8), k); 计算所有小于或等于8的对象的数目。 否定函数对象 所谓否定(negator)函数对象，就是它从另一个函数对象创建而来，如果原先的函数返回真，则否定函数对象返回假。有两个否定函数对象：not1()和not2()。not1()接受单目函数对象，not2()接受双目函数对象。否定函数对象通常和帮定器一起使用。例如，上节中用bind1nd来搜索q<=8的值：   count_if(aList.begin(), aList.end(),     bind1st(greater<int>(), 8), k); 如果要搜索q>8的对象，则用bind2st。而现在可以这样写： start = find_if(aList.begin(), aList.end(),  not1(bind1nd(greater<int>(), 6))); 你必须使用not1，因为bind1nd返回单目函数。 总结：使用标准模板库 (STL) 尽管很多程序员仍然在使用标准C函数，但是这就好像骑着毛驴寻找Mercedes一样。你当然最终也会到达目标，但是你浪费了很多时间。 尽管有时候使用标准C函数确实方便(如使用sprintf()进行格式化输出)。但是C函数不使用异常机制来报告错误，也不适合处理新的数据类型。而且标准C函数经常使用内存分配技术，没有经验的程序员很容易写出bug来。. C++标准库则提供了更为安全，更为灵活的数据集处理方式。STL最初由HP实验室的Alexander Stepanov和Meng Lee开发。最近，C++标准委员会采纳了STL，尽管在不同的实现之间仍有细节差别。 STL的最主要的两个特点：数据结构和算法的分离，非面向对象本质。访问对象是通过象指针一样的迭代器实现的；容器是象链表，矢量之类的数据结构，并按模板方式提供；算法是函数模板，用于操作容器中的数据。由于STL以模板为基础，所以能用于任何数据类型和结构。","title":"三十分钟掌握STL"},{"content":"限定符 {n} 在特定字符后，只能跟着连续的n个特定的字符 举例说明：o{2}不能与”Bob”中的”o”匹配，但可以与“food”中的两个“o”匹配，也可以与“fooooood”中的任意两个连续的“o”匹配  {n,} 在特定字符后边，必需跟着至少“n”个相同的特定的字符 举例说明：o{2,}不能与“Bob”匹配，但可以和“fooooood”中所有的“o”匹配  {n,m} 在特定字符后，必需跟着至少“n”个至多“m”个同样的特定的字符。 举例说明：o{1,3}可以匹配“Bob”中的“o”，也可以匹配“foooood”中的连续的几个“o”  + 举例说明：“zo+”与“zo”和“zoo”等在字母z后面连续出现一个或者多个字母o的字符串匹配 * 举例说明：“zo*”与“z”和“zoo”都能匹配。*等效于{0,} ? 举例说明：“zo?”可以与“z”或“zo”，也可以匹配“zoo”中的“zo”部分，但不能匹配整个“zoo” 选择匹配符          选择匹配符只有一个，就是“|”字符，用于选择匹配两个选项之中的任意一个，它的两个选项是字符“|”两边的尽可能最大的表达式 贪婪匹配和非贪婪匹配 贪婪匹配：默认情况下，正则表达式使用最长（也叫贪婪）匹配原则。如果要将“zoom”中的“zo?”部分替换成“r”，则替换结果是“rom”，而不是“room”；如果要将“zoom”中的“zo*”的部分替换成“r”，那么结果就是“rm”，而不是“rom”或者“room” 非贪婪匹配：当字符“?”紧跟着任何其他限定符（*，?，{n}，{n,}，{n,m}）之后时，匹配模式变成使用最短（也叫非贪婪）匹配原则。例如，在字符串“foooood”中，“fo+?”只匹配“fo”部分，而“fo+”匹配“foooo”部分 字符匹配符           用于指定该符号部分可以匹配多个字符中的任意一个[…] […] 包含中括号中的任意一个 说明：如果字符中包含“]”，需要将它放在第一位，即紧跟在“[”后面。[…]中的字符“\\”仍然作为转义符，若要在[…]中使用“\\”字符本身，则必须是“\\\\” [^…] 刚好与[…]相反，不包含中括号中的一个 说明：只要“^”不出现在“[”的后边，那么的它的意义就是真正的“^” [a-z] 包含a到z的一个或者多个字符。前边的是起始字符，后边的是终止字符。          如果在中括号表达式中包含字面意义的“-”，可以用反斜杠“(\\)”将它标记为原意字符，例如，[a\\-z]，也可以将“-”放在方括号的开始处或者结尾处，例如[-a-z]，[a-z-]。  [^a-z] 与[a-z]的意义正好相反 \\d 可以匹配任意一个数字字符 \\D 与“\\d”的意义恰好相反，不能匹配任意一个数字字符，可以匹配一个非数字字符 \\s 可以匹配任何空白字符；例如[ \\f\\n\\r\\t\\v]，“\\f”换一个符号，“\\n”换行，“\\r”回车，“\\t”制表符，“\\v”。 \\S 与\\s的意义相反，匹配一个非空白的字符，等效于[^ \\f\\n\\r\\t\\v] \\w 匹配[A-Za-z0-9]。 \\W 匹配[^A-Za-z0-9]，也就是与\\w的意思相反   . 可以匹配除了“\\n”之外的任何单个字符。 (.)\\1可以匹配除了“\\n”之外的任意两个连续的相同字符。如要匹配包括“\\n”在内的字符，可以使用[\\w\\W]，[\\d\\D]等模式。 定位符          用于规定匹配模式在目标字符串中出现的出现位置   ^ 规定字符串的起始位置 举例说明：“^o”与“ok”中的o匹配，但不能与“hello”中的“o”匹配。如果设置了RegExp对象的Multiline属性，^还会与行首进行匹配，即与“\\t”或“\\n”之后的位置匹配。  $ 规定字符串的结尾位置 举例说明：“$o”与“hello”中的“o”匹配，但不能与“ok”中的“o”匹配。如果设置了RegExp兑现的Multilien属性，$还会与行尾进行匹配，即与“\\n”或“\\t”之前的位置匹配。    \\b 规定了字与空格间的位置，已经目标字符串的开始和结束的位置 举例说明：“er\\b”可以匹配“never ok”中的“er”，但是不能匹配“very”中的“er”因为“very”中“er”的后边并不是一个单词的分隔符。  \\B 用于匹配非边界的情况 举例说明：与\\b恰好相反      ","title":"正则表达式详解 - 总结篇"},{"content":"菜鸟学习中~看韩顺平的视频，跟着做的笔记~ 1、  tomcat无法正常启动的原因分析 1）  JAVA_HOME配置错误，或者没有配置。 注意：JAVA_HOME路径后面没有分号，若加上，在启动的时候会找dir;这个地址，找不到。 若是不能更改操作系统的环境变量，可用以下方法配置JAVA_HOME。 Tomcat安装目录下，bin/startup.bat中，在25行（set\"CURRENT_DIR=%cd%\"）前面加上set JAVA_HOME=dir，dir是java的安装路径。 2）  若机器已经占用8080端口，则无法启动。 解决方案： （1）先将占用8080端口的程序关闭  用netstat -an查看8080端口是否被占用 用netstat -anb查看哪个应用程序占用8080端口 启动windows任务管理器的进程，查看占用8080的程序，并将其关闭。（查看—选择列(S)…—PID(进程标识符)可看见应用程序对应的端口号） （2）主动改变tomcat的端口 Tomcat安装目录下conf/server.xml，找到Connector标签，改变默认的8080端口值。     <Connector port=\"8080\"protocol=\"HTTP/1.1\"                connectionTimeout=\"20000\"                redirectPort=\"8443\"/> 3）  能正常启动，但是会导航到另外的一个页面。 与浏览器有关：IE浏览器修改管理加载项，将默认导航禁止即可。 4）  访问tomcat的时候，一定保证tomcat服务器是启动的。   2、Tomcat目录说明 bin文件夹  启动和关闭tomcat的脚本文件。 conf配置文件: 1)      server.xml文件 用于配置和server相关的信息，比如tomcat启动的端口号，配置主机（虚拟主机和域名），配置context，即web应用。 2)      web.xml文件 为web应用的配置文件，它必须放在web应用目录/WEB-INF目录下。此文件用于对web应用下的web资源进行配置，例如，将某个web资源配置为网站首页，将servlet程序映射到某个url地址上等等。 例如：通过web.xml文件配置网站首页。   <welcome-file-list> <welcome-file>index.jsp<\/welcome-file>   <\/welcome-file-list>   3）tomcat-users.xml文件 用于配置tomcat的用户密码和权限。 logs目录 存放日志，可查看日志。当tomcat出错时，可查看原因。    lib目录  存放tomcat运行时需要的jar包。 webapps目录   存放web应用（web站点）。注意tomcat6.0以后才支持web站点的管理。   3、虚拟目录，虚拟主机 引出：当把web应用放在webapps目录下时，tomcat会自动管理，如果希望tomcat可以管理其他目录下的web应用，使用虚拟目录配置。 配置虚拟目录在tomcat的conf目录下的server.xml的host节点间加上配置信息： <Contextpath=\"/Hello\" docBase=\"e:\\mywebapps\\Hello\"/> 注意：docBase是程序文档的绝对路径，即虚拟目录的绝对路径，path是网络路径，包括协议、地址、web应用名、资源名等，eg：http://localhost:8080/Hello/ 配置完成后，需要重启tomcat。 Context属性值说明： 1）  reloadable若设为true，表示tomcat会自动更新web应用，开销大。建议，开发阶段可以将reloadable设为true，而发布后，应该将其设为false。 2）  unpackWARs默认为true。如果设为true，则tomcat在发布web应用时，会自动解压；否则，不会自动解压。 打war包：命令行命令：jar -cvf xxx.war *   4、在一台web服务器中配置网站，即如何配置自己的主机名。步骤如下： 1）  在C:\\Windows\\System32\\drivers\\etc的hosts文件中，加上本机地址和要配置的域名，对照localhost的配置。 2）  在tomcat的server.xml文件中，添加一个主机名。 <Hostname=\"www.shoren.com\" appBase=\"E:\\mywebapps\\Hello\">             <Context path=\"/\"  docBase=\"E:\\mywebapps\\Hello\"/>   <\/Host> 3）  按之前步骤设置首页面。 4）  在浏览器中输入http://www.shoren.com:8080/，（此处不可缺少8080端口号）即可。 注意：若在server.html的Host节点中，appBase和docBase设为\"E:\\mywebapps\"，则浏览器中输入的地址就应该加上Hello路径，即http://www.shoren.com:8080/Hello。 如果只在hosts文件中加入ip信息\"www.shoren.com\"，不在server.html中修改，则输入http://www.shoren.com:8080/后，指示的就是localhost的tomcat首页面。结合浏览器请求服务器的过程就比较容易理解了。               向所得的地址发http请求，访问本地的web站点，就是向本机tomcat发请求。Tomcat得到请求后，先解析主机（一个tomcat可管理多台主机，在server.xml文件中的一个Host节点代表一个主机），然后再解析web应用（一个Host有多个web应用），解析资源名。   5、Tomcat体系结构图 这个结构图可以在conf/server.xml文件中体现出来。 改变默认主机： 当我输入localhost:8080时，会跳出tomcat的主页面；输入ip地址:8080时，也会跳出tomcat主页面。这个localhost就是默认的主机。现在希望输入ip地址:8080时，跳出自配置的www.shoren.com主页面。则www.shoren.com就是默认的主机。 步骤：在server.xml中，找到engine（一个tomcat只配有一个engine）标签，将其defaultHost属性改为你要配置的主机名（主机名在host标签中都有）。","title":"servlet学习之tomcat介绍"},{"content":"import java.io.*;//导入操作要用到的类public class main {\tpublic static void main(String args[]) {\t\tFile file = new File(\"c:/test.txt\");// 源文件位置\t\tFileReader fr;\t\ttry {\t\t\tfr = new FileReader(file);\t\t\tBufferedReader in = new BufferedReader(fr);// 包装文件输入流，可整行读取\t\t\tString line;\t\t\ttry {\t\t\t\twhile ((line = in.readLine()) != null) {\t\t\t\t\tString a = pinyin(line);\t\t\t\t\tint shengdiaoLetter = Integer.parseInt(a.substring(\t\t\t\t\t\t\ta.length() - 1, a.length()));\t\t\t\t\ta = a.substring(0, a.length() - 1) + \" \"\t\t\t\t\t\t\t+ a.substring(shengdiaoLetter, shengdiaoLetter + 1);\t\t\t\t\tSystem.out.println(a);\t\t\t\t}\t\t\t} catch (IOException e) {\t\t\t\t// TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t}\t\t} catch (FileNotFoundException e) {\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t}// 创建文件输入流\t}\tprivate static String pinyin(String input) {\t\tint position = 0;\t\tint onlyaeiou = 0;\t\tinput = input.toLowerCase();\t\t// 单个韵母不必说。 （单个的韵母，当然就标它上面了）\t\tif (input.contains(\"a\")) {\t\t\tonlyaeiou++;\t\t}\t\tif (input.contains(\"e\")) {\t\t\tonlyaeiou++;\t\t}\t\tif (input.contains(\"i\")) {\t\t\tonlyaeiou++;\t\t}\t\tif (input.contains(\"o\")) {\t\t\tonlyaeiou++;\t\t}\t\tif (input.contains(\"u\")) {\t\t\tonlyaeiou++;\t\t}\t\tif (input.contains(\"v\")) {\t\t\tonlyaeiou++;\t\t}\t\tif (onlyaeiou == 1) {\t\t\tif (input.contains(\"a\")) {\t\t\t\tposition = input.indexOf(\"a\");\t\t\t}\t\t\tif (input.contains(\"e\")) {\t\t\t\tposition = input.indexOf(\"e\");\t\t\t}\t\t\tif (input.contains(\"i\")) {\t\t\t\tposition = input.indexOf(\"i\");\t\t\t}\t\t\tif (input.contains(\"o\")) {\t\t\t\tposition = input.indexOf(\"o\");\t\t\t}\t\t\tif (input.contains(\"u\")) {\t\t\t\tposition = input.indexOf(\"u\");\t\t\t}\t\t\tif (input.contains(\"v\")) {\t\t\t\tposition = input.indexOf(\"v\");\t\t\t}\t\t\treturn input + position;\t\t}\t\tif (input.contains(\"a\")) {\t\t\tposition = input.indexOf(\"a\");\t\t\treturn input + position;\t\t}\t\t// 没有a母找o e ,\t\telse if (input.contains(\"o\")) {\t\t\tposition = input.indexOf(\"o\");\t\t\treturn input + position;\t\t} else if (input.contains(\"e\")) {\t\t\tposition = input.indexOf(\"e\");\t\t\treturn input + position;\t\t}\t\t// iu 并列标在后，\t\tif (input.contains(\"iu\")) {\t\t\tposition = input.indexOf(\"iu\") + 1;\t\t\treturn input + position;\t\t}\t\tif (input.contains(\"a\")) {\t\t\tposition = input.indexOf(\"a\");\t\t\treturn input + position;\t\t}\t\tif (input.contains(\"e\")) {\t\t\tposition = input.indexOf(\"e\");\t\t\treturn input + position;\t\t}\t\tif (input.contains(\"i\")) {\t\t\tposition = input.indexOf(\"i\");\t\t\treturn input + position;\t\t}\t\tif (input.contains(\"o\")) {\t\t\tposition = input.indexOf(\"o\");\t\t\treturn input + position;\t\t}\t\tif (input.contains(\"u\")) {\t\t\tposition = input.indexOf(\"u\");\t\t\treturn input + position;\t\t}\t\tif (input.contains(\"v\")) {\t\t\tposition = input.indexOf(\"v\");\t\t\treturn input + position;\t\t}\t\treturn input;\t}}","title":"Java 源代码 计算出拼音的声调字母是哪个"},{"content":"AForge.NET是一个专门为开发者和研究者基于C#框架设计的，这个框架提供了不同的类库和关于类库的资源，还有很多应用程序例子，包括计算机视觉与人工智能，图像处理，神经网络，遗传算法，机器学习，机器人等领域。 根据网上的方法，运行程序摄像头出来了，但是怎么截图呢？找到一个显示图片方法如下  private void video_NewFrame(object sender, NewFrameEventArgs eventArgs)        {            Bitmap img = (Bitmap)eventArgs.Frame.Clone();            //do processing here            pictureBox1.Image = img;        } 开始参考这句代码写了：  private void video_NewFrame(object sender, NewFrameEventArgs eventArgs)        {            Bitmap img = (Bitmap)eventArgs.Frame.Clone();            string imgPath = dirc + \"/\" + DateTime.Now.ToString(\"yyyyMMddhhmmss\") + \".jpg\";            img.Save(imgPath);        } 但是点击截图程序就自动不停截了大量的图片，最后导致程序出问题。想了一个笨方法，可以只截一次图：  private int flag = 1;  /// <summary>        /// 截图        /// <\/summary>        private void toolStripButton3_Click(object sender, EventArgs e)        {            flag = 0;            videoSource.NewFrame += new NewFrameEventHandler(video_NewFrame);        }              private void video_NewFrame(object sender, NewFrameEventArgs eventArgs)        {            Bitmap bitmap = (Bitmap)eventArgs.Frame.Clone();            if (flag == 0)            {                string img = dirc + \"/\" + DateTime.Now.ToString(\"yyyyMMddhhmmss\") + \".jpg\";                bitmap.Save(img);                flag = 1;                }        }       完整的程序代码如下： using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Drawing.Imaging;using System.Text;using System.Windows.Forms;using System.IO;using AForge;using AForge.Video;using AForge.Video.DirectShow;using AForge.Imaging;using AForge.Imaging.Filters;namespace Camera{    public partial class Form1 : Form    {        private FilterInfoCollection videoDevices;        private VideoCaptureDevice videoSource;        private int flag = 1;        private string dirc = System.AppDomain.CurrentDomain.BaseDirectory + \"Images\"; //截图保存的目录                       public Form1()        {            InitializeComponent();        }        private void Form1_Load(object sender, EventArgs e)        {            if (!Directory.Exists(dirc))                Directory.CreateDirectory(dirc);            try            {                // 枚举所有视频输入设备                videoDevices = new FilterInfoCollection(FilterCategory.VideoInputDevice);                if (videoDevices.Count == 0)                    throw new ApplicationException();                foreach (FilterInfo device in videoDevices)                {                    tscbxCameras.Items.Add(device.Name);                }                tscbxCameras.SelectedIndex = 0;            }            catch (ApplicationException)            {                tscbxCameras.Items.Add(\"No local capture devices\");                videoDevices = null;            }        }        private void toolStripButton1_Click(object sender, EventArgs e)        {            CameraConn();        }        /// <summary>        /// 连接开启摄像头        /// <\/summary>        private void CameraConn()        {            videoSource = new VideoCaptureDevice(videoDevices[tscbxCameras.SelectedIndex].MonikerString);            videoSource.DesiredFrameSize = new Size(500, 300);            videoSource.DesiredFrameRate = 1;            videPlayer.VideoSource = videoSource;            videPlayer.Start();        }        /// <summary>        /// 关闭摄像头        /// <\/summary>        private void toolStripButton2_Click(object sender, EventArgs e)        {            videPlayer.SignalToStop();            videPlayer.WaitForStop();        }        private void Form1_FormClosing(object sender, FormClosingEventArgs e)        {            toolStripButton2_Click(null, null);        }        /// <summary>        /// 截图        /// <\/summary>        private void toolStripButton3_Click(object sender, EventArgs e)        {            flag = 0;            videoSource.NewFrame += new NewFrameEventHandler(video_NewFrame);        }              private void video_NewFrame(object sender, NewFrameEventArgs eventArgs)        {            Bitmap bitmap = (Bitmap)eventArgs.Frame.Clone();            if (flag == 0)            {                string img = dirc + \"/\" + DateTime.Now.ToString(\"yyyyMMddhhmmss\") + \".jpg\";                bitmap.Save(img);                flag = 1;                }        }           }} 界面效果如下：","title":"c# 利用AForge.NET组件操作摄像头"},{"content":"这一节主要是讲述如何定位一个由野指针引起的heap corruption。","title":"《coredump问题原理探究》windows版8.6节堆布局heap corruption第一个例子"},{"content":"event.keycode值大全  keycode 8 = BackSpace BackSpacekeycode 9 = Tab Tabkeycode 12 = Clearkeycode 13 = Enterkeycode 16 = Shift_Lkeycode 17 = Control_Lkeycode 18 = Alt_Lkeycode 19 = Pausekeycode 20 = Caps_Lockkeycode 27 = Escape Escapekeycode 32 = space spacekeycode 33 = Priorkeycode 34 = Nextkeycode 35 = Endkeycode 36 = Homekeycode 37 = Leftkeycode 38 = Upkeycode 39 = Rightkeycode 40 = Downkeycode 41 = Selectkeycode 42 = Printkeycode 43 = Executekeycode 45 = Insertkeycode 46 = Deletekeycode 47 = Helpkeycode 48 = 0 equal bracerightkeycode 49 = 1 exclam onesuperiorkeycode 50 = 2 quotedbl twosuperiorkeycode 51 = 3 section threesuperiorkeycode 52 = 4 dollarkeycode 53 = 5 percentkeycode 54 = 6 ampersandkeycode 55 = 7 slash braceleftkeycode 56 = 8 parenleft bracketleftkeycode 57 = 9 parenright bracketrightkeycode 65 = a Akeycode 66 = b Bkeycode 67 = c Ckeycode 68 = d Dkeycode 69 = e E EuroSignkeycode 70 = f Fkeycode 71 = g Gkeycode 72 = h Hkeycode 73 = i Ikeycode 74 = j Jkeycode 75 = k Kkeycode 76 = l Lkeycode 77 = m M mukeycode 78 = n Nkeycode 79 = o Okeycode 80 = p Pkeycode 81 = q Q atkeycode 82 = r Rkeycode 83 = s Skeycode 84 = t Tkeycode 85 = u Ukeycode 86 = v Vkeycode 87 = w Wkeycode 88 = x Xkeycode 89 = y Ykeycode 90 = z Zkeycode 96 = KP_0 KP_0keycode 97 = KP_1 KP_1keycode 98 = KP_2 KP_2keycode 99 = KP_3 KP_3keycode 100 = KP_4 KP_4keycode 101 = KP_5 KP_5keycode 102 = KP_6 KP_6keycode 103 = KP_7 KP_7keycode 104 = KP_8 KP_8keycode 105 = KP_9 KP_9keycode 106 = KP_Multiply KP_Multiplykeycode 107 = KP_Add KP_Addkeycode 108 = KP_Separator KP_Separatorkeycode 109 = KP_Subtract KP_Subtractkeycode 110 = KP_Decimal KP_Decimalkeycode 111 = KP_Divide KP_Dividekeycode 112 = F1keycode 113 = F2keycode 114 = F3keycode 115 = F4keycode 116 = F5keycode 117 = F6keycode 118 = F7keycode 119 = F8keycode 120 = F9keycode 121 = F10keycode 122 = F11keycode 123 = F12keycode 124 = F13keycode 125 = F14keycode 126 = F15keycode 127 = F16keycode 128 = F17keycode 129 = F18keycode 130 = F19keycode 131 = F20keycode 132 = F21keycode 133 = F22keycode 134 = F23keycode 135 = F24keycode 136 = Num_Lockkeycode 137 = Scroll_Lockkeycode 187 = acute gravekeycode 188 = comma semicolonkeycode 189 = minus underscorekeycode 190 = period colonkeycode 192 = numbersign apostrophekeycode 210 = plusminus hyphen macronkeycode 211 =keycode 212 = copyright registeredkeycode 213 = guillemotleft guillemotrightkeycode 214 = masculine ordfemininekeycode 215 = ae AEkeycode 216 = cent yenkeycode 217 = questiondown exclamdownkeycode 218 = onequarter onehalf threequarterskeycode 220 = less greater barkeycode 221 = plus asterisk asciitildekeycode 227 = multiply divisionkeycode 228 = acircumflex Acircumflexkeycode 229 = ecircumflex Ecircumflexkeycode 230 = icircumflex Icircumflexkeycode 231 = ocircumflex Ocircumflexkeycode 232 = ucircumflex Ucircumflexkeycode 233 = ntilde Ntildekeycode 234 = yacute Yacutekeycode 235 = oslash Oobliquekeycode 236 = aring Aringkeycode 237 = ccedilla Ccedillakeycode 238 = thorn THORNkeycode 239 = eth ETHkeycode 240 = diaeresis cedilla currencykeycode 241 = agrave Agrave atilde Atildekeycode 242 = egrave Egravekeycode 243 = igrave Igravekeycode 244 = ograve Ograve otilde Otildekeycode 245 = ugrave Ugravekeycode 246 = adiaeresis Adiaeresiskeycode 247 = ediaeresis Ediaeresiskeycode 248 = idiaeresis Idiaeresiskeycode 249 = odiaeresis Odiaeresiskeycode 250 = udiaeresis Udiaeresiskeycode 251 = ssharp question backslashkeycode 252 = asciicircum degreekeycode 253 = 3 sterlingkeycode 254 = Mode_switch使用event对象的keyCode属性判断输入的键值eg：if(event.keyCode==13)alert(“enter!”);键值对应表A　　0X65 　U 　　0X85B　　0X66　 V　　 0X86C　　0X67　 W　　 0X87D　　0X68　 X 　　0X88E　　0X69　 Y　　 0X89F　　0X70　 Z　　 0X90G　　0X71　 0　　 0X48H　　0X72　 1　　 0X49I　　0X73　 2　　 0X50J　　0X74　 3 　　0X51K　　0X75　 4 　　0X52L　　0X76　 5 　　0X53M　　0X77　 6　　 0X54N　　0X78 　7 　　0X55O　　0X79 　8 　　0X56P　　0X80 　9 　　0X57Q　　0X81　ESC　　0X1BR　　0X82　CTRL 　0X11S　　0X83　SHIFT　0X10T　　0X84　ENTER　0XD如果要使用组合键，则可以利用event.ctrlKey，event.shiftKey，event .altKey判断是否按下了ctrl键、shift键以及alt键  ","title":"event.keycode值大全"},{"content":"PipedOutputStream类 和PipedInputStream 类为管道输出流 和管道输入流。通常都是以管道输出流作为管道的起始端，通常管道输出流和管道输入流通过connect方法连接起来，实现数据从管道输出流 流入 管道输入流中。管道输出流提供管道输入流的所有字节。通常都是 PipedOutputStream类介绍： 构造方法：PipedOutputStream();//创建一个尚未连接到管道输入流的管道输出流。                   PipedOutputStream(pipedInputStream in);//创建一个连接到该管道输入流的管道输出流。 主要方法。void write(int b);//将指定 byte 写入传送的输出流。                   void write(byte[] buf);//将该字符数组写入到管道输出流。                   void close();                   void connect(PipedInputStream in);使此管道输出流连接到管道输入流 in。 PipedInputStream类介绍： 构造方法：PipedInputStream();//创建一个尚未连接到管道输出流的管道输入流。                     PipedInputStream(PipedOutputStream in);//创建一个连接到该管道输出入流的管道输入流。 主要方法：int read(byte[] b,int off,int len);//将最多 len 个数据字节从此管道输入流读入 byte 数组                   void connect(PipedOutputStream out);//使此管道输入流连接到管道输出流 out。 代码演示： package PipedDemo;import java.io.IOException;import java.io.PipedInputStream;import java.io.PipedOutputStream;public class PipedDemo {\t/**\t * @param args\t * @throws IOException \t */\tpublic static void main(String[] args) throws IOException {\t\t\t\tPipedInputStream in = new PipedInputStream();\t\tPipedOutputStream out = new PipedOutputStream();\t\t\t\tin.connect(out);\t\tnew Thread(new Input(in)).start();\t\tnew Thread(new Output(out)).start();\t}}class Input implements Runnable{\t\tprivate PipedInputStream in;\tpublic Input(PipedInputStream in) {\t\tsuper();\t\tthis.in = in;\t}\t@Override\tpublic void run() {\t\tbyte []buf = new byte[1024];\t\tint len;\t\ttry {\t\t\tlen = in.read(buf);\t\t\tString s = new String(buf,0,len);\t\t\t\t\t\tSystem.out.println(\"in \"+s);\t\t\tin.close();\t\t} catch (IOException e) {\t\t\t\t\t\te.printStackTrace();\t\t} \t}\t}class Output implements Runnable{\t@Override\tpublic void run() {\t\ttry {\t\t\tout.write(\"管道流。。。。\".getBytes());\t\t} catch (IOException e) {\t\t\t\t\t\te.printStackTrace();\t\t}\t\t\t\t}\t\tprivate PipedOutputStream out;\tpublic Output(PipedOutputStream out) {\t\tsuper();\t\tthis.out = out;\t}}  ","title":"PipedInputStream类 和 PipedOutputStream类 的简单介绍和代码演示"},{"content":"由于WebSocket允许保持长连接,因此当建立连接后服务器可以主动地向Client发送相关信息.下面通过服务端获取当前CPU的使用情况主动发送给网页,让网页实时显示CPU使用情况的曲线图.该事例的主要功能是包括服务端获取CPU使和情况和HTML5使用canvas进行曲线图绘制. 应用效果 实现效果主要是模仿windows的任务管理器,显示每个核的工作情况. C#获取CPU使用情况 可能通过PerformanceCounter来获取具本CPU线程的使用情况,不过在构建PerformanceCounter前先获取到CPU对应的线程数量.获取这个数量可以通过Environment.ProcessorCount属性获取,然后遍历构建每个PerformanceCounter ? 1 2 3 4 5 int coreCount = Environment.ProcessorCount;                     for (int i = 0; i < coreCount; i++)             {                 mCounters.Add(new PerformanceCounter(\"Processor\", \"% Processor Time\", i.ToString()));             } 为了方便计数器的处理,简单地封装了一个基础类,完整代码如下: ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /// <summary>     /// Copyright © henryfan 2012             ///Email:   henryfan@msn.com         ///HomePage:    http://www.ikende.com            ///CreateTime:  2012/12/24 15:10:44     /// <\/summary>     public class ProcessorCounter     {         private List<PerformanceCounter> mCounters = new List<PerformanceCounter>();         public IList<PerformanceCounter> Counters         {             get             {                 return mCounters;             }         }         public void Open()         {             int coreCount = Environment.ProcessorCount;                     for (int i = 0; i < coreCount; i++)             {                 mCounters.Add(new PerformanceCounter(\"Processor\", \"% Processor Time\", i.ToString()));             }         }         public ItemUsage[] GetValues()         {             ItemUsage[] values = new ItemUsage[mCounters.Count];             for (int i = 0; i < mCounters.Count; i++)             {                 values[i] = new ItemUsage();                 values[i].ID = i.ToString();                 values[i].Name = \"CPU \" +i.ToString();                 values[i].Percent =  mCounters[i].NextValue();             }             return values;         }     }     public class ItemUsage     {         public string Name { get; set; }         public float Percent { get; set; }         public  string ID { get; set; }     } 这样一个用于统计CPU所有线程使用情况计数的类就完成了. 页面绘制处理 首先定义一些简单的处理结构 ? 1 2 3 4 5 6 7 8 9 10 11 function ProcessorInfo() {             this.Item = null;             this.Points = new Array();             for (var i = 0; i < 50; i++) {                 this.Points.push(new Point(0, 0));             }         }         function Point(x, y) {             this.X = x;             this.Y = y;         } 主要定义线程信息结构,默认初始化50个座标,当在接收服务线程使用情况的时候,构建一个点添加到数组件尾部同时把第一个移走.通过定时绘制这50个点的曲线这样一个动态的走势就可以完成了. ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 function drawProceessor(item) {             var canvas = document.getElementById('processimg' + item.Item.ID);             var context = canvas.getContext('2d');             context.beginPath();             context.rect(0, 0, 200, 110);             context.fillStyle = 'black';             context.fill();             context.lineWidth = 2;             context.strokeStyle = 'white';             context.stroke();             context.beginPath();             context.moveTo(2, 106);             for (var i = 0; i < item.Points.length; i++) {                    context.lineTo(4 * i + 2, 110 - item.Points[i].Y - 4);             }             context.lineTo(200, 106);             context.closePath();             context.lineWidth = 1;             context.fillStyle = '#7FFF00';             context.fill();             context.strokeStyle = '#7CFC00';             context.stroke();             context.font = '12pt Calibri';             context.fillStyle = 'white';             context.fillText(item.Item.Name, 60, 20);         }         function addUploadItem(info) {             if (cpus[info.ID] == null) {                 var pinfo = new ProcessorInfo();                 pinfo.Item = info;                 $('<canvas id=\"processimg' + info.ID + '\" width=\"200\" height=\"110\"><\/canvas>').appendTo($('#lstProcessors'));                 cpus[info.ID] = pinfo;                 processors.push(pinfo);                 pinfo.Points.shift();                 pinfo.Points.push(new Point(0, info.Percent));                 drawProceessor(pinfo);                } else {                 var pinfo = cpus[info.ID];                 pinfo.Points.shift();                 pinfo.Points.push(new Point(0, info.Percent));             }         } 只需要通过定时器来不停地更新线程使用绘制即可. ? 1 2 3 4 5 setInterval(function () {                 for (var i = 0; i < processors.length; i++) {                     drawProceessor(processors[i]);                 }             }, 1000); 服务端 对于服务端其实可以根据自己的需要来使用websocket协议实现,.net 4.5也提供相应的封装.而这里则使用了beetle对应websocket的扩展协议包,整体代码如下: ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Program : WebSocketJsonServer     {         static void Main(string[] args)         {             TcpUtils.Setup(\"beetle\");             Program server = new Program();             server.Open(8070);             Console.WriteLine(\"websocket start@8070\");             ProcessorCounter counters = new ProcessorCounter();             counters.Open();             while (true)             {                 ItemUsage[] items = counters.GetValues();                 foreach (ItemUsage item in items)                 {                     Console.WriteLine(\"{0}:{1}%\", item.Name, item.Percent);                 }                 JsonMessage message = new JsonMessage();                 message.type = \"cpu useage\";                 message.data = items;                 foreach (TcpChannel channel in server.Server.GetOnlines())                 {                     channel.Send(message);                 }                 System.Threading.Thread.Sleep(995);             }             System.Threading.Thread.Sleep(-1);         }         protected override void OnError(object sender, ChannelErrorEventArgs e)         {             base.OnError(sender, e);             Console.WriteLine(e.Exception.Message);         }         protected override void OnConnected(object sender, ChannelEventArgs e)         {             base.OnConnected(sender, e);             Console.WriteLine(\"{0} connected\", e.Channel.EndPoint);         }         protected override void OnDisposed(object sender, ChannelDisposedEventArgs e)         {             base.OnDisposed(sender, e);             Console.WriteLine(\"{0} disposed\", e.Channel.EndPoint);                      }     } 每秒获取一次CPU的使用情况,并把信息以json的方式发送给当前所有在线的连接. 下载 完整代码:ProcessorsMonitor.rar (686.02 kb)  演示地址:http://html5.ikende.com/ProcessorsMonitor.htm (浏览器使用chrome或IE10)","title":"HTML5-WebSocket实现对服务器CPU实时监控"},{"content":"应该是没有时间的限制。 java的所有技术与框架并不是孤立的，所以学习也没有长短之分。 学习只有深入和肤浅。 肤浅的学习，都学了也就一个月就可以了，但是你找不到工作。 深入的学习，也就一个月，但是你可以找到工作。 惊讶吧！为什么深入学习也只是一个月呢？ 听我慢慢说：学习不是学内容，而是学习方法，你要深入研究其中的一个领域，只有你把兴趣都放到那个领域后，其它的东西你就会很感兴趣，这样你就会融会贯通，同时你不会觉得枯燥，当你有兴趣的时候你也就会为解决了一个一个问题而感到有成就感，这样下去你就会更努力的学习，最后的结果是你不在满足某一个领域，你要扩展思路学习更多的东西（这里的学习是精学），久而久之你就都会了（但是其中一定有你的专长）。 所以你现在要找到一个点，而不是看那么一张图，那张图应该在你学习的过程中慢慢的行成，它或许就是其中的某一个或某多个。 拙见，希望可以帮到你！","title":"java你要学习多长时间？"},{"content":"算法设计例题：最优装载（贪心） memory limit: 32768KB    time limit: 1000MS accept: 24    submit: 68 Description 有一批集装箱要装上一艘载重量为C的轮船。其中集装箱i的重量为wi。最优装载问题要求确定在装载体积不受限制的情况下，将尽可能多的集装箱装上轮船。 Input 输入的第一个为测试样例的个数T（ T <= 100 ），接下来有T个测试样例。每个测试样例的第一行是一个整数n（ n <= 1000 ）和一个非负数C（ C <= 10000 ），分别表示集装箱的个数以及轮船的载重量。接下来有n行，每行一个非负数，表示每个集装箱的重量。 Output 对应每个测试样例输出一行，格式为\"Case #: D V\"，其中'#'表示第几个测试样例（从1开始计），D为轮船可以装载的集装箱数量的最大值，V为满足D最大时轮船的实际载重量。 Sample Input 1 5 100 20 50 120 99 30 Sample Output Case 1: 3 100 Author Eapink 解决代码： #include <iostream> #include <algorithm> using namespace std; int main() { int i,j,testNum,containerNum;//分别为测试个数、集装箱个数 float weight[1000];//集装箱重量 float load;//轮船载重量 cin>>testNum;   for(i=0;i<testNum;i++) {   cin>>containerNum>>load;        for(j=0;j<containerNum;j++)   cin>>weight[j];   sort(weight,containerNum+weight);   //开始装载   int count=0;   float sum=0.0;   for(int k=0;k<containerNum;k++)   {   if(load>=weight[k])   {   sum=sum+weight[k];   load=load-weight[k];   count++;   }   else   break;      }   cout<<\"Case \"<<i+1<<\": \"<<count<<\" \"<<sum<<endl; } return 0; }","title":"最优装载（贪心）"},{"content":"算法设计例题：旅行售货员问题（回溯、分枝限界） memory limit: 5000KB    time limit: 2000MS accept: 4    submit: 5 Description 旅行售货员问题又称TSP问题，问题如下：某售货员要到若干个城市推销商品，已知各城市之间的路程（或旅费），他要选定一条从驻地出发，经过每个城市一遍最后回到驻地的路线，使总的路线（或总的旅费）最小。数学模型为给定一个无向图，求遍历每一个顶点一次且仅一次的一条回路，最后回到起点的最小花费。 Input 输入的第一行为测试样例的个数T（ T < 120 ），接下来有T个测试样例。每个测试样例的第一行是无向图的顶点数n、边数m（ n < 12，m < 100 ），接下来m行，每行三个整数u、v和w，表示顶点u和v之间有一条权值为w的边相连。（ 1 <= u < v <= n，w <= 1000 ）。假设起点（驻地）为1号顶点。 Output 对应每个测试样例输出一行，格式为\"Case #: W\"，其中'#'表示第几个测试样例（从1开始计），W为TSP问题的最优解，如果找不到可行方案则输出-1。 Sample Input 2 5 8 1 2 5 1 4 7 1 5 9 2 3 10 2 4 3 2 5 6 3 4 8 4 5 4 3 1 1 2 10 Sample Output Case 1: 36 Case 2: -1 Author Eapink 解决方法： //旅行售货员问题  （回溯） #include<iostream>   #define N 100   using namespace std;   int n,m,w,           //图的顶点数和边数     graph[N][N],     //图的加权邻接矩阵     c=0,             //当前费用     bestc=-1,         //当前最优值     x[N],            //当前解     bestx[N];        //当前最优解 void backtrack(int k);   void swap(int &a,int &b);   void swap(int &a,int &b)   {       int temp=a;       a=b;       b=temp;   }   void backtrack(int k)   {       if(k==n)       {           if( (c+graph[x[n-1]][x[n]]+graph[x[n]][1]<bestc||bestc==-1) && graph[x[n-1]][x[n]]!=-1 && graph[x[n]][1]!=-1 )           {               bestc=c+graph[x[n-1]][x[n]]+graph[x[n]][1];               for(int i=1;i<=n;i++)               {                   bestx[i]=x[i];               }           }           return ;       }       else       {           for(int i=k;i<=n;i++)           {               if( graph[x[k-1]][x[i]]!=-1 && (c+graph[x[k-1]][x[i]]<bestc || bestc==-1))               {                   swap(x[i],x[k]);                   c+=graph[x[k-1]][x[k]];                   backtrack(k+1);                   c-=graph[x[k-1]][x[k]];                   swap(x[i],x[k]);               }           }       }   }  int main(void)   {   int i,j,tmp=1,testNum; cin>>testNum; while(tmp<=testNum) { cin>>n>>m; for(i=1;i<=n;i++) for(j=1;j<=n;j++) graph[i][j]=-1; for(int k=1;k<=m;k++) { cin>>i>>j>>w; graph[i][j]=w; graph[j][i]=w; } for(i=1;i<=n;i++)   {   x[i]=i;   bestx[i]=i;   }  backtrack(2);   cout<<\"Case \"<<tmp<<\": \"<<bestc<<endl; bestc=-1; c=0; tmp++; } return 0;   }  ","title":"旅行售货问题（回溯）"},{"content":"    前面我们介绍了多线程中的锁机制，锁机制虽然保证了线程的安全性，但是很容易出现死锁现象。当两个线程相互等待对方释放同步监视器时就会发生死锁。对于死锁，虚拟机没有监测和处理机制。一旦出现死锁，整个程序不会发生任何异常，也不会有任何响应，所有的线程处于阻塞状态。    下面我们来模拟一个死锁程序： class A {      public synchronized void foo(B b) {            System. out.println( \"当前线程名：\" + Thread.currentThread().getName()                        + \" 进入了A的foo方法\" );  //①             // 当前线程沉睡，并不释放锁             try {                  Thread. sleep(100);            } catch (Exception e) {                  e.printStackTrace();            }            System. out.println( \"当前线程名：\" + Thread.currentThread().getName()                        + \" 企图调用B的last方法\" );   //③             //调用b的last方法            b.last();      }      public synchronized void last() {            System. out.println( \"进入了A的last方法内部\" );      }}class B {      public synchronized void bar(A a) {            System. out.println( \"当前线程名：\" + Thread.currentThread().getName()                        + \" 进入了B的bar方法\" );  //②             // 当前线程沉睡，并不释放锁             try {                  Thread. sleep(100);            } catch (Exception e) {                  e.printStackTrace();            }            System. out.println( \"当前线程名：\" + Thread.currentThread().getName()                        + \" 企图调用A的last方法\" );   //④             //调用a的last方法            a.last();      }      public synchronized void last() {            System. out.println( \"进入了B的last方法内部\" );      }}public class TestDeadLock implements Runnable {      A a = new A();      B b = new B();      public void init() {            Thread. currentThread().setName(\"主线程\");             a.foo( b);            System. out.println( \"进入主线程之后\" );      }      @Override      public void run() {            Thread. currentThread().setName(\"副线程\");             b.bar( a);            System. out.println( \"进入副线程之后\" );      }      public static void main(String[] args) {            TestDeadLock testDeadLock = new TestDeadLock();                         //新起一个线程             new Thread(testDeadLock).start();             //直接调用init方法，相当于主线程先对a对象进行锁定            testDeadLock.init();      }}      运行结果如下： 当前线程名：主线程 进入了A的foo方法 当前线程名：副线程 进入了B的bar方法 当前线程名：主线程 企图调用B的last方法 当前线程名：副线程 企图调用A的last方法   从运行结果可以看到，程序既不向下运行，也不抛出异常，陷入假死的状态。 死锁机制分析    原因是A ,B 两个类中的方法都是同步方法，也就是A，B对象都是同步锁。在main程序中有两条执行路径，一条线程执行体是TestDeadLock的run方法。另一条线程的执行体TestDeadLock的init方法（在主线程调用）。run方法中让B对象调用bar方法，init方法让A对象调用foo方法。    主线程中的init方法先执行，调用了A对象的foo方法。在调用之前，主线程会首先将A对象锁定。当程序执行到①处时，主线程沉睡，让出cpu。   TestDeadLock的run方法体开始执行，调用B对象的bar方法。在调用之前，TestDeadLock会首先将B对象锁定。当程序执行到②处时，副线程沉睡，让出cpu。    接下来，主线程醒过来，继续执行。执行到③处时，调用B对象的last方法。在调用之前，首先对B对象进行加锁。而此时B对象正被副线程锁定中，所以主线程只好阻塞。   接下来，副线程醒过来，继续执行。执行到④处时，调用A对象的last方法。在调用之前，首先对A对象进行加锁。而此时A对象正在阻塞的主线程锁定，所以副线程也陷入阻塞状态。   这样就出现了主线程保持着A对象的锁，希望对B对象加锁；而副线程保持着B对象的锁，希望对A对象加锁的现象，所以就出现了死锁。      这就是死锁出现的场景（有些公司的面试题中会出现），看明白了写出来并不难。","title":"线程（四）—死锁"},{"content":"题意： 给出整数t1,t2,x1,x2,t0,和公式，(1 ≤ t1 ≤ t0 ≤ t2 ≤ 106, 1 ≤ x1, x2 ≤ 106).求满足(0 ≤ y1 ≤ x1, 0 ≤ y2 ≤ x2)此条件的y1，y2使得t最接近t0，但要保证t>t0.输出y1,y2.多种方案时输出最大的y1,y2. 题解：不4个特判必WA。不过这4个特判不太容易想全。 case 1:t1==t0 && t2!=t0 => y1=x1,y2=0 case 2:t2==t0 && t1!=t0 => y1=0,y2=x2 case 3:t1==t2 =>y1=x1,y2=x2 做法： 枚举y1，然后t2可以解出来。在选最小的，不过也有坑！见程序吧 case 4：非常难想到的是，当y1==0，方程解出y2=0此时显然不对,所以此种情况仍需处理。 #include<iostream>#include<cstring>using namespace std;long long t1,t2,x1,x2,t0,f1,f2;long long cal(long long t1,long long y1,long long t2,long long y2){    return t1*y1+t2*y2-t0*(y1+y2);}void solve(long long y1,long long y2){    if(y2<0)y2=0;else if(y2>x2)y2=x2;//溢出    if(y1==0 && y2==0)return;//WA    if(t1*y1+t2*y2<t0*(y1+y2))return;//不满足t>=t0的条件    if(cal(t1,y1,t2,y2)*(f1+f2)<cal(t1,f1,t2,f2)*(y1+y2)||(f1<0 && f2<0))    {        f1=y1;f2=y2;    }    else    if(cal(t1,y1,t2,y2)*(f1+f2)==cal(t1,f1,t2,f2)*(y1+y2)&&y1+y2>f1+f2)    {        f1=y1;f2=y2;    }}int main(){    long long y2;    while(cin>>t1>>t2>>x1>>x2>>t0)    {        f1=-1,f2=-1;        if(t1==t2)//case        {            f1=x1;f2=x2;        }        else if(t1==t0)//case        {            f1=x1;f2=0;        }        else if(t2==t0)//case        {            f1=0;f2=x2;        }        else        for(long long y1=1;y1<=x1;y1++)        {            if(t0>t2)            {                y2=(t1*y1-t0*y1)/(t0-t2);                solve(y1,y2);            }            else            if(t0<t2)            {                y2=(t1*y1-t0*y1)%(t0-t2)==0?(t1*y1-t0*y1)/(t0-t2):1+(t1*y1-t0*y1)/(t0-t2);                solve(y1,y2);            }        }        //y1=0 case 4!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!        if(t2>=t0)solve(0,x2);        cout<<f1<<\" \"<<f2<<endl;    }    return 0;}","title":"Codeforces 127C Hot Bath"},{"content":"首先创建个WEB工程，然后： http://ws.Apache.org/axis/网站下载Axis安装包.当然还依赖其他包的，我这里在附件里上传了所有应用到得包，方便大家。   二：   然后就写wsdd 文件（注:其实这里真的不用，可以跳过第二步）为了生成这个文件：server-config.wsdd   deploy.wsdd： <deployment xmlns=\"http://xml.apache.org/axis/wsdd/\" xmlns:java=\"\" target=\"_blank\">http://xml.apache.org/axis/wsdd/providers/java\">   <service name=\"HelloWorld\" provider=\"java:RPC\">     <parameter name=\"className\" value=\"HelloWorld\"/>     <parameter name=\"allowedMethods\" value=\"sayHello\"/>   <\/service> <\/deployment>   在DOS下转换目录到%TOMCAT_HOME%\\webapps\\axis\\WEB-INF，命令： java -cp %AXISCLASSPATH% org.apache.axis.client.AdminClient deploy.wsdd 三：   可以自己写第二步中的文件，代码如下：   Wsdd代码   <?xml version=\"1.0\" encoding=\"UTF-8\"?>   <deployment xmlns=\"http://xml.apache.org/axis/wsdd/\" xmlns:java=\"http://xml.apache.org/axis/wsdd/providers/java\">        <globalConfiguration>     <parameter name=\"sendMultiRefs\" value=\"true\"/>     <parameter name=\"disablePrettyXML\" value=\"true\"/>     <parameter name=\"dotNetSoapEncFix\" value=\"true\"/>     <parameter name=\"enableNamespacePrefixOptimization\" value=\"false\"/>     <parameter name=\"sendXMLDeclaration\" value=\"true\"/>     <parameter name=\"sendXsiTypes\" value=\"true\"/>     <parameter name=\"attachments.implementation\" value=\"org.apache.axis.attachments.AttachmentsImpl\"/>   <\/globalConfiguration>        <handler type=\"java:org.apache.axis.handlers.http.URLMapper\" name=\"URLMapper\"/>        <service name=\"Login.jws\" provider=\"java:RPC\">           <parameter name=\"className\" value=\"org.hzy.serveces.SayHello\"/>  //你要改的就是这里，这里写上要调用的类      <parameter name=\"scope\" value=\"request\"/>        <parameter name=\"allowedMethods\" value=\"*\"/>  //代表所有方法      <messageReceiver class=\"org.apache.axis2.receivers.RawXMLINOutMessageReceiver\"/>     <\/service>        <transport name=\"http\">           <requestFlow>              <handler type=\"URLMapper\"/>           <\/requestFlow>        <\/transport>      <\/deployment>       放到 WEB-INF 目录下 和web.xml一起,其中，WEB.XML可以直接从你下载的axis项目中拿来到自己工程就好，或者自己添加：   Xml代码   <servlet>           <servlet-name>AxisServlet<\/servlet-name>           <servlet-class>org.apache.axis.transport.http.AxisServlet<\/servlet-class>       <\/servlet>       <servlet-mapping>           <servlet-name>AxisServlet<\/servlet-name>           <url-pattern>/services/*<\/url-pattern>       <\/servlet-mapping>       四：     服务端提供的方法：     Java代码   package org.hzy.services;      public class SayHello {       public String getName(String name) {           return \"hello====>\" + name;       }   }       五：      客户端访问服务端接口获得数据的方法：   Java代码   package org.hzy.client;      import org.apache.axis.client.Call;   import org.apache.axis.client.Service;      public class TestClient {          public static void main(String[] args) throws Exception {              // 指出service所在URL                   String endpoint = \"http://127.0.0.1:8080/webservice/services/Login.jws\";              // 创建一个服务(service)调用(call)                   Service service = new Service();              Call call = (Call) service.createCall();// 通过service创建call对象                   // 设置service所在URL                   call.setTargetEndpointAddress(new java.net.URL(endpoint));              // 方法名(processService)与MyService.java方法名保持一致                   call.setOperationName(\"getName\");              // Object 数组封装了参数，参数为\"This is Test!\",调用processService(String arg)                   String ret = (String) call.invoke(new Object[] { \"继中\" });              System.out.println(ret);          }      }      包结构: 六：   启动tomcat,先访问http://127.0.0.1:8082/webservice/services，看是否有方法显示，有显示，则代表服务端提供的接口可以成功访问了。   我的效果是这样：   And now... Some Services Login.jws (wsdl) getName 七：       然后在本地跑客户端TestClient，就应该有结果啦，大家试试吧。 备注一下: 如果net与你交互,把http://localhost:8080/webservices/services/Login.jws?wsdl 这个地址给它 他那边会自动解析的,你也可以直接输入: http://localhost:8080/webservices/services/Login.jws?wsdl 测试下,如果成功就会显示xml格式的文件","title":"java实现webservice实例"},{"content":"加入说序列式这样的 1 21 22 11 31 41 54 1 我们得出的结果如下： 1 31 52 14 1 程序如下： use strict;use warnings;my $filename;my %hash;my @information;my $key1;my $key2;print \"please put in the file like this f:\\\\\\\\perl\\\\\\\\data.txt\\n\";chomp($filename=<STDIN>);open(IN,\"$filename\")||die(\"can not open\");while(<IN>){\tchomp;\t@information=split/\\s+/,$_;\tif(exists $hash{$information[0]}{$information[1]})\t{\t\tnext;\t}\telse\t{\t    $hash{$information[0]}{$information[1]}='A';\t}}close IN;open(IN,\"$filename\")||die(\"can not open\");while(<IN>){\t@information=split/\\s+/,$_;\tif(exists $hash{$information[1]}{$information[0]})\t{\t\tdelete $hash{$information[0]}{$information[1]}\t}\telse\t{\t\tnext;\t}}close IN;open(OUT,\">f:\\\\A_B_result.txt\")||die(\"can not open\");foreach $key1 (sort{$a<=>$b} keys %hash){\tforeach $key2 (sort{$a<=>$b} keys %{$hash{$key1}})\t{\t\tprint OUT \"$key1 $key2\\n\";\t}}close OUT;","title":"重复内容删除的小脚本"},{"content":"modem接入技术面临一些相互矛盾的目标，既要通过同一个用户前置接入设备连接远程的多个用户主机，又要提供类似拨号一样的接入控制，计费等功能，而且要尽可能地减少用户的配置操作。 　　PPPOE的目标就是解决上述问题，1998年后期问世的以太网上点对点协议（PPPoverEthernet）技术是由Redback网络公司、客户端软件开发商RouterWare公司以及Worldcom子公司UUNET　　　　　　Technologies公司在IETFRFC的基础上联合开发的。通过把最经济的局域网技术－以太网和点对点协议的可扩展性及管理控制功能结合在一起，网络服务提供商和电信运营商便可利用可靠和熟悉的技术来加速部署高速互联网业务。它使服务提供商在通过数字用户线、电缆调制解调器或无线连接等方式，提供支持多用户的宽带接入服务时更加简便易行。同时该技术亦简化了最终用户在选择这些服务时的配置操作。 PPPOE特点 　　PPPOE在标准PPP报文的前面加上以太网的报头，使得PPPOE提供通过简单桥接接入设备连接远端接入设备，并可以利用以太网的共享性连接多个用户主机，在这个模型下，每个用户主机利用自身的ppp堆栈，用户使用熟悉的界面。接入控制，计费等都可以针对每个用户来进行。 PPPOE的优点： .�安裝与操作方式类似于以往的拨号网络模式，方便用戶使用。 .�用户处的XDSL调制解调器无须任何配置。 .�允许多个用户共享一个高速数据接入链路。 .�适应小型企业和远程办公的要求。 .�终端用户可同时接入多个ISP，这种动态服务选择的功能可以使　ISP容易创建和提供新的业务。 .�兼容现有所有的XDSLModem和DSLAM。 .�可与ISP有接入结构相融合。 PPPOE的帧格式 参数取值ETHER_TYPE： 0x8863 Discovery Stage 0x8864 PPP Session Stage CODE： 0x00 PPP Session Stage 0x09 PPPOE Active Discovery Initiation (PADI) packet 0x07 PPPOE Active Discovery Offer (PADO) packet 0x19 PPPOE Active Discovery Request (PADR) packet 0x65 PPPOE Active Discovery Session-confirmation (PADS) packet 0xa7 PPPOE Active Discovery Terminate (PADT) packet TAG_TYPES： 0x0000 End-Of-List 0x0101 Service-Name 0x0102 AC-Name 0x0103 Host-Uniq 0x0104 AC-Cookie 0x0105 Vendor-Specific 0x0110 Relay-Session-Id 0x0201 Service-Name-Error 0x0202 AC-System-Error 0x0203 Generic-Error PPPOE的实现过程　 　　建立一个以太网上点对点协议会话包括两个阶段：1. 发现（Discovery）阶段 　　在Discovery过程中用户主机以广播方式寻找可以连接的所有接入设备，获得其以太网MAC地址。然后选择需要连接的用户主机并最后获得所要建立的PPP会话的SESSION_ID。在Discovery过程中节点间是客户端－服务器关系， 一个用户主机（客户端）最终要发现一个接入设备（服务器）。在网络拓朴中，一般有不止一个的接入设备可以通信，Discovery阶段允许用户主机发现所有的接入设备，并从中选择一个。当Discovery阶段结束时， 用户主机和接入设备之间都获得了可供以太网上建立PPP连接的全部信息。Discovery阶段保持无连接状态直到一个PPP会话的建立。一旦PPP连接建立，则用户主机和接入设备都必须为PPP虚拟端口分配资源。 PPP 会话阶段 　　用户主机与在发现阶段确定的接入设备进行PPP协商。这个协商过程与标准的PPP协商并没有任何区别。在PPP会话阶段节点间是对等关系。 发现（Discovery）阶段详述 典型的发现（Discovery）阶段共包括4个步骤： 　　1. 用户主机发出PPPOE有效发现初始（PADI）包。以太网目的地址为广播地址0xffffffff， CODE 字段为0x09， SESSION_ID为0x0000。PADI包必须至少包含一个服务名称类型（Service-Name）的标签（标签类型字段为0x0101）， 向接入设备提出所要求提供的服务。一个完整的PADI（包括PPPOE头）不能超过1484字节，以留下充足的预留给agent设备增加Relay-Session-Id标识。 　　2. 接入设备收到在服务范围内的PADI包后，发送PPPOE有效发现提供（PADO） 包以响应请求。其CODE字段为0x07 ，SESSION_ID仍为0x0000。PADO包必须包含一个接入设备名称类型（AC-Name）的标签（标签类型字段为0x0102）以及一个或多个服务名称类型标签，表明可向用户主机提供的服务种类。 　　3.用户主机在可能收到的多个PADO包中选择一个合适的接入设备，选择的原则是根据PADO中接入设备名称类型标签和服务名称类型标签的内容。然后向所选择的接入设备发送PPPOE有效发现请求（PADR）包。其CODE 字段为0x19，SESSION_ID仍为0x0000。PADR包必须包一个服务名称类型标签，确定向接入设备请求的服务种类。当一个用户主机在确定时间没有收到PADO，他会重发一个PADI，同时等待两倍的时间。这种过程可以根据需要重复多次。 　　4.接入设备收到PADR包后准备开始PPP会话，它发送一个PPPOE 有效发现会话确认（ PADS）包。其CODE 字段为0x65 ， SESSION_ID为接入设备所产生的一个唯一的PPPOE会话标识号码。0xffff作为预留资源，目前不能被使用作SESSION_ID。PADS包也必须包含一个服务名称类型的标签确认向用户主机提供的服务。当用户主机收到PADS包确认后，双方就进入PPP会话阶段。如果接入设备不能识别PADR中的服务名称类型的标签，则会回一个包含服务名称错误（ Service-Name-Error ） 标签的PADS ，其SESSION_ID仍然是0x0000。如果用户主机在确定时间没收到PADS包，与没收到PADO作同样处理。 　　还有一种PPPOE有效发现终止（PADT）包，在一个PPP会话建立后它随时可由用户主机或接入设备中任何一方发送，指示PPP会话已终止。PADT包不需要任何标签，其CODE字段为0xa7 ， SESSION_ID 为需要终止的PPP会话的会话标识号码。 安全性 　　为防止DOS（Denial of Service）攻击，接入设备应该可以使用AC-Cookie属性，接入设备应可以根据PADR中的源地址唯一再生成一个值，这样就而已保证PADI的源地址是真正可达，同时限制与这个地址同时连接数量。这个算法细节并没有在RFC2516中具体描述。虽然AC-Cookie在反DOS攻击方面很有效，但它并不能防止所有DOS攻击，在接入设备上也可以采用其他方法来对抗DOS。 常用PPPOE软件 　　PPPOE软件的作用就是连接操作系统的PPP协议和Ethernet协议，并通过PPPOE协议连接 ISPEnterNet:由NTS.COM 开发（现在已经并入Efficient Networks这个有名的设备开发制造公司），自己具备独立的PPP协议，可以不依赖操作系统的拨号网络来提供PPP协议， 具有直接通过网卡和ISP连接的能力，目前是最通用和流行的PPPOE 软件，并且支持多种操作系统，目前已经提供有Windows，Linux，MacOS的版本,并且根据功能的多少又分为100、300、500等多个系列。该软件的300系列最流行，已经被多家特大型的ISP采用，例如法国电信，中国电信，在其网站提供有30天试用版。 WinPoET:由iVasion.com 开发（现在已经改为WindRiver 公司）, 它是PPPOE 协议起草者之一，它在PPPOE软件中也占有极大的份额，许多特大型ISP也采用它。它通过操作系统的拨号网络来提供PPP协议，所以在使用上和我们使用普通56K拨号上网非常相似，它只是在后台悄悄地进行着PPPOE服务。它的网站目前停止了该软件的下载评估，软件只批量卖给ISP RASPPPOE:个人开发的PPPOE驱动软件，小巧精干，没有自己的界面面板完全只是一个驱动程序，也是依靠操作系统拨号网络来提供PPP协议，由于它是以网络协议组件的形式来工作，所以在使用上，完全和使用老式的Modem一样简单。 Access Manager/IHS:实质就是EnterNet 300 ，只是打上了BELL的ISP接入服务部门Sympatico的商标。","title":"PPPOE协议"},{"content":"CJuiDatePicker 用于日期输入，它封装了 JUI datepicker插件，其基本用法如下： <?php echo $form->errorSummary($model); ?> <?php $this->widget('zii.widgets.jui.CJuiDatePicker', array( \t'name'=>'my_date', \t'language'=>'en', \t'options'=>array(\t            // 'show' (the default), 'slideDown', 'fadeIn', 'fold' \t\t\t\t'showAnim'=>'fold', \t\t\t\t'showOn'=>'button', // 'focus', 'button', 'both' \t\t\t\t'buttonText'=>'Select form calendar', \t\t\t\t'buttonImage'=>'images/calendar.png', \t\t\t\t'buttonImageOnly'=>true, \t\t\t\t), \t\t\t'htmlOptions'=>array( \t\t\t\t'style'=>'width:80px;vertical-align:top' \t\t\t\t), \t\t\t)); ?><div class=\"row submit\">    <?php echo CHtml::submitButton('Submit'); ?><\/div><?php $this->endWidget(); ?><\/div><!-- form --> 为了获取输入的日期，首先为CJuiDatePicker的Name属性赋值，本例为my_date，然后定义DataModel class DataModel extends CFormModel{\tpublic $my_date;} 当用户提交时，显示用户输入的日期，修改SiteController的actionIndex public function actionIndex(){\t$model=new DataModel();\tif(!empty($_POST['my_date']))\t{\t\t$model->my_date=$_POST['my_date'];\t\tif($model->validate()) {\t\t\t$this->render('result', array(\t\t\t\t'model' => $model,\t\t\t\t));\t\t   return;\t\t}\t}\t$this->render('index', array(\t\t\t'model' => $model,\t\t\t));} 本例下载","title":"Yii Framework 开发教程(36) Zii组件-DatePicker示例"},{"content":"CJuiButton 显示按钮，CJuiButton 既可以做为Submit（提交）按钮，也可以做为普通按钮。 按钮基本用法如下： <?php $this->widget('zii.widgets.jui.CJuiButton', array('buttonType'=>'submit','name'=>'btnSubmit','value'=>'1','caption'=>'Submit','htmlOptions'=>array('class'=>'ui-button-primary'))); ?><?php $this->widget('zii.widgets.jui.CJuiButton', array(\t'buttonType'=>'button',\t'name'=>'btnClick',\t'caption'=>'Click',\t//'options'=>array('icons'=>'js:{primary:\"ui-icon-newwin\"}'),\t'onclick'=>'js:function(){alert(\"clicked\"); this.blur(); return false;}',)); ?><?php $this->widget('zii.widgets.jui.CJuiButton', array('buttonType'=>'link','name'=>'btnGo','caption'=>'Go',//'options'=>array('icons'=>'js:{secondary:\"ui-icon-extlink\"}'),'url'=>array('site/other'),)); ?> 这三个按钮，第一个做为Submit按钮，第二个作为普通按钮，触发JavaScripts事件，第三个点击后触发otherAction方法。 显示结果如下： 可以为Jui UI组件添加CSS文件，这可以通过配置文件来设置CSS文件： 'components'=>array(\t'clientScript' => array(\t\t\t'scriptMap' => array(\t\t\t\t'jquery-ui.css'=> dirname($_SERVER['SCRIPT_NAME'])\t\t\t\t  .'/css/jui/custom/jquery-ui.css',\t\t\t\t),\t\t\t),\t\t), 这里我们复制YiiPlayground使用的JQuery CSS文件 ，使用新CSS风格后显示如下： 本例下载","title":"Yii Framework 开发教程(35) Zii组件-Button示例"},{"content":"  【OpenCV入门指南】第十一篇 鼠标绘图   前面介绍了图像处理中的Canny边缘检测、轮廓检测、直方图以及直方图均衡化。本篇介绍个互动性强一点内容——用鼠标绘图。在OpenCV中进行鼠标绘图也是非常简易的，主要使用到cvSetMouseCallback函数，下请看介绍。   一．关键函数 1.1  cvSetMouseCallback 函数功能：设置处理鼠标消息的回调函数 函数原型： /* assign callback for mouse events */ CVAPI(void) cvSetMouseCallback(     const char* window_name,     CvMouseCallback on_mouse,     void* param CV_DEFAULT(NULL) ); 函数说明： 第一个参数表示窗口名称。 第二个参数表示鼠标消息的消息处理函数。 第三个参数表示用户定义传入鼠标指定消息处理函数的参数。   1.2 CvMouseCallback 函数功能：鼠标消息的回调函数 函数原型： typedef void (CV_CDECL *CvMouseCallback )(int event, int x, int y, int flags, void* param); 函数说明： 第一个参数表示鼠标消息类型，取值如下： enum {     CV_EVENT_MOUSEMOVE      =0,     CV_EVENT_LBUTTONDOWN    =1,     CV_EVENT_RBUTTONDOWN    =2,     CV_EVENT_MBUTTONDOWN    =3,     CV_EVENT_LBUTTONUP      =4,     CV_EVENT_RBUTTONUP      =5,     CV_EVENT_MBUTTONUP      =6,     CV_EVENT_LBUTTONDBLCLK  =7,     CV_EVENT_RBUTTONDBLCLK  =8,     CV_EVENT_MBUTTONDBLCLK  =9 }; 第二，三个参数表示鼠标的坐标。 第四个参数表示附加事件，取值如下： enum {     CV_EVENT_FLAG_LBUTTON   =1,     CV_EVENT_FLAG_RBUTTON   =2,     CV_EVENT_FLAG_MBUTTON   =4,     CV_EVENT_FLAG_CTRLKEY   =8,     CV_EVENT_FLAG_SHIFTKEY  =16,     CV_EVENT_FLAG_ALTKEY    =32 }; 第五个参数即设置cvSetMouseCallback()中将接收到的参数。   二．示例程序代码 代码示范如下，按下‘r’键可以重新绘图，按下‘s’键则保存图片到磁盘中。 // 鼠标绘图//By MoreWindows (http://blog.csdn.net/MoreWindows)#include <opencv2/opencv.hpp>using namespace std;#pragma comment(linker, \"/subsystem:\\\"windows\\\" /entry:\\\"mainCRTStartup\\\"\")const char *pstrWindowsMouseDrawTitle = \"鼠标绘图(http://blog.csdn.net/MoreWindows)\";// 鼠标消息的回调函数void on_mouse(int event, int x, int y, int flags, void* param){\tstatic bool s_bMouseLButtonDown = false;\tstatic CvPoint s_cvPrePoint = cvPoint(0, 0);\tswitch (event)\t{\tcase CV_EVENT_LBUTTONDOWN:\t\ts_bMouseLButtonDown = true;\t\ts_cvPrePoint = cvPoint(x, y);\t\tbreak;\tcase  CV_EVENT_LBUTTONUP:\t\ts_bMouseLButtonDown = false;\t\tbreak;\tcase CV_EVENT_MOUSEMOVE:\t\tif (s_bMouseLButtonDown)\t\t{\t\t\tCvPoint cvCurrPoint = cvPoint(x, y);\t\t\tcvLine((IplImage*)param, s_cvPrePoint, cvCurrPoint, CV_RGB(0, 0, 20), 3);\t\t\ts_cvPrePoint = cvCurrPoint;\t\t\tcvShowImage(pstrWindowsMouseDrawTitle, (IplImage*)param);\t\t}\t\tbreak;\t}}int main(){\t\tconst int MAX_WIDTH = 500, MAX_HEIGHT = 400;\tconst char *pstrSaveImageName = \"MouseDraw.jpg\";\tIplImage *pSrcImage =  cvCreateImage(cvSize(MAX_WIDTH, MAX_HEIGHT), IPL_DEPTH_8U, 3);\tcvSet(pSrcImage, CV_RGB(255, 255, 255)); //可以用cvSet()将图像填充成白色\tcvNamedWindow(pstrWindowsMouseDrawTitle, CV_WINDOW_AUTOSIZE);\tcvShowImage(pstrWindowsMouseDrawTitle, pSrcImage);\tcvSetMouseCallback(pstrWindowsMouseDrawTitle, on_mouse, (void*)pSrcImage);\tint c;\tdo{\t\tc = cvWaitKey(0);\t\tswitch ((char)c)\t\t{\t\tcase 'r':\t\t\tcvSet(pSrcImage, CV_RGB(255, 255, 255));\t\t\tcvShowImage(pstrWindowsMouseDrawTitle, pSrcImage);\t\t\tbreak;\t\tcase 's':\t\t\tcvSaveImage(pstrSaveImageName, pSrcImage);\t\t\tbreak;\t\t}\t}while (c > 0 && c != 27);\tcvDestroyWindow(pstrWindowsMouseDrawTitle);\tcvReleaseImage(&pSrcImage);\treturn 0;} 运行效果如下图所示：   画一些复杂的图画也可以。 瓶花： 玫瑰： 米老鼠：   呵呵，由于程序只能画黑白图像，要能支持彩色画笔估计画图效果会好的多。   如果我们要写自己写的好OpenCV分享给其它人使用应该怎么做了？请看《【OpenCV入门指南】第十二篇分享OpenCV程序》       《OpenCV入门指南》系列文章地址：http://blog.csdn.net/morewindows/article/category/863841 转载请标明出处，原文地址：http://blog.csdn.net/morewindows/article/details/8426283 欢迎关注微博：http://weibo.com/MoreWindows  ","title":"【OpenCV入门指南】第十一篇 鼠标绘图"},{"content":"C程序最大的特点就是所有的程序都是用函数来装配的。main()称之为主函数，是所有程 序运行的入口。其余函数分为有参或无参两种，均由main()函数或其它一般函数调用，若调用 的是有参函数，则参数在调用时传递。 C/C++语言中的main函数，经常带有参数argc，argv，如下： int main(int argc, char** argv) int main(int argc, char* argv[]) 从函数参数的形式上看，包含一个整型和一个指针数组。当一个C/C++的源程序经过编译、链接后，会生成扩展名为.EXE的可执行文件，这是可以在操作系统下直接运行的文件，换句话说，就是由系统来启动运行的。对main()函数既然不能由其它函数调用和传递参数，就只能由 系统在启动运行时传递参数了。 在操作系统环境下，一条完整的运行命令应包括两部分：命令与相应的参数。其格式为： 命令参数1参数2....参数n¿ 此格式也称为命令行。命令行中的命令就是可执行文件的文件名，其后所跟参数需用空格分隔，并为对命令的进一步补充，也即是传递给main()函数的参数。 命令行与main()函数的参数存在如下的关系： 设命令行为：program str1 str2 str3 str4 str5 其中program为文件名，也就是一个由program.c经编译、链接后生成的可执行文件program.exe，其后各跟5个参数。对main()函数来说，它的参数argc记录了命令行中命令与参数的个数，共6个，指针数组的大小由参数argc的值决定，即为char*argv[6]，指针数组的取值情况如图6-15所示。 数组的各指针分别指向一个字符串。应当引起注意的是接收到的指针数组的各指针是从命令行的开始接收的，首先接收到的是命令，其后 才是参数。 下面的程序演示argc和argv的使用： #include<iostream>using namespace std;int main(int argc,char **argv){\tfor(int i=0;i<argc;i++)\t\tcout<<\"Argument \"<<i<<\" is \"<<argv[i]<<endl;\treturn EXIT_SUCCESS;} 该程序编译运行成功，产生了 test.exe 文件，在打开DOS窗口，用cd命令进入到 test.exe 文件夹下 ，在DOS下输入如下命令： test.exe hello! this is a test! 则运行的结果如下：","title":"[置顶] c/c++ main 函数命令行参数的使用 知识小结"},{"content":"  《OpenCV入门指南》这个系列已经讲解了十一篇，相信大家对OpenCV已经有一个初步的了解了。有网友反映怎么自己写的OpenCV程序拷贝到其它人的电脑上就无法使用？对于电脑高手来说，这个问题简直不值一提。但对新手来说，有篇详细的文章来教他们解决这个问题肯定也能大大节省他们的时间。因此本篇就来解决这个问题——让没安装OpenCV的电脑也能运行我们所写的OpenCV程序。     以上一篇《【OpenCV入门指南】第十一篇鼠标绘图》的程序为例，在没安装OpenCV的电脑（Win7系统）上运行Release生成的opencv_test1.exe会报错。错误内容如下——无法启动此程序，因为计算机中丢失opencv_core231d.dll。尝试重新安装该程序以解决此问题。 由于报错的原因是因为一些DLL没有被加载，因此随程序附加上DLL看看可不可以解决这个问题。 使用VC6自带的Depends.exe查看这个程序依赖哪些DLL。 可以看出程序依赖于opencv_core231d.dll和opencv_highgui231d.dll，到OpenCV的安装目录中找出这二个DLL将其与我们的opencv_test1.exe放在同一目录，再运行。结果还是报错。错误内容如下——应用程序无法正常启动(0xc0150002)。请单击“确定”关闭程序。   到网上查了“应用程序无法正常启动 0xc0150002”的解决方法，有人说要下一个VC支持程序 http://www.microsoft.com/downloads/details.aspx?displaylang=zh-cn&FamilyID=200b2fd9-ae1a-4a14-984d-389c36f85647 不过安装后还是报错！！！！     再搜索下解决方法，原来OpenCV的DLL是分Debug和Release两种的，像opencv_core231d.dll这个文件名最后有个d说明这是Debug下生成的，不加d即opencv_core231.dll才是Release下生成的。   而且很明显Release生成的程序应该去加载Release生成的DLL，因此这个opencv_test1.exe应该去加载opencv_core231.dll和opencv_highgui231.dll。在项目配置中改下将《【OpenCV入门指南】第一篇安装OpenCV》中使用的 opencv_calib3d231d.lib opencv_contrib231d.lib opencv_core231d.lib opencv_features2d231d.lib opencv_flann231d.lib opencv_gpu231d.lib opencv_highgui231d.lib opencv_imgproc231d.lib opencv_legacy231d.lib opencv_ml231d.lib opencv_objdetect231d.lib opencv_ts231d.lib opencv_video231d.lib 换成 opencv_calib3d231.lib opencv_contrib231.lib opencv_core231.lib opencv_features2d231.lib opencv_flann231.lib opencv_gpu231.lib opencv_highgui231.lib opencv_imgproc231.lib opencv_legacy231.lib opencv_ml231.lib  opencv_objdetect231.lib  opencv_ts231.lib opencv_video231.lib  设置配置的方法见这里(可以参考《【OpenCV入门指南】第一篇 安装OpenCV》中的图示)： 在VS2008中点击“项目”，再点击“属性”，依次展开“配置属性”--> “链接器”--> “输入”在“附加依赖项中”添加即可（Release）。   然后再将opencv_core231.dll和opencv_highgui231.dll放到opencv_test1.exe目录下。双击，已经可以成功运行了。     本文这种方法比较原始，规范一点的做法应该是作个安装包来发布程序的。安装包的制作比较复杂，肯定不是一篇两篇博客可以讲透彻的，大家可以搜索下“VS2008 安装与部署”。使用其它打包工具也是个不错的选择。 使用静态编译的方法也可以，不过这样生成的exe程序会比较庞大。可以参考：http://www.opencvchina.com/thread-1368-1-1.html     《OpenCV入门指南》系列文章地址：http://blog.csdn.net/morewindows/article/category/863841 转载请标明出处，原文地址：http://blog.csdn.net/morewindows/article/details/8426295 欢迎关注微博：http://weibo.com/MoreWindows","title":"【OpenCV入门指南】第十二篇 分享OpenCV程序"},{"content":"  观察者模式又叫做发布——订阅模式。   1、定义     观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使他们能够自动更新自己。       根据定义我们可以看出观察者模式有两个对象，而且必须都存在：观察者和被观察者。观察者是具体执行操作的对象，有多个；被观察者如果发生变化，则会通知观察者去执行相应的操作。此外还可以看出，当一个对象的改变需要同时通知其他对象的时候，而且它不知道具体有多少对象需要通知的时候，需要通知的对象能够动态地增加。              在此种模式中，一个目标管理所有依赖于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实作事件处理系统。   2、结构图       通过上图可以看出观察者模式有四种角色，抽象观察者角色，具体观察者角色，抽象主题角色，具体主题角色。主题与观察者都是用接口，观察者利用主题接口向主题注册；而主题利用观察者接口通知观察者。从而让两者之间运行正常，同时又具有松耦合的特点。所以，观察者模式是针对接口编程，不针对实现编程。体现了依赖倒转原则。   3、举例     我们用一个例子来说明     魏管姹在看股票，易管查在看NBA直播，为了不让老板发现，他们就请前台童子喆来通知老板到没到，一天，老板带着童子喆去办公室拿东西，童子喆没有办法通知了，魏管姹被老板发现了。这时，老板可以作为一个通知者，结构图和代码如下。       结构图   代码实现     //通知者接口    interface Subject    {        void Attach(Observer observer);        void Detach(Observer observer);        void Notify();        string SubjectState        {            get;            set;        }    }    //老板类实现接口    class Boss : Subject    {          //同事列表        private IList<Observer> observers = new List<Observer>();        private string action;        //增加观察者        public void Attach(Observer observer)        {            observers.Add(observer);        }        //减少观察者        public void Detach(Observer observer)        {            observers.Remove(observer);        }        //通知观察者        public void Notify()        {            foreach (Observer o in observers)                o.Update();        }        //老板状态        public string SubjectState        {            get { return action; }            set { action = value; }        }    }   //抽象观察者    abstract class Observer    {        protected string name;        protected Subject sub;        public Observer(string name, Subject sub)        {            this.name = name;            this.sub = sub;        }        public abstract void Update();    }    //看股票的同事    class StockObserver : Observer    {        public StockObserver(string name, Subject sub)            : base(name, sub)        { }        //根据主题对象行为更新自己        public override void Update()        {            Console.WriteLine(\"{0}{1}关闭股票行情，继续工作！\", sub.SubjectState, name);        }    }    //看NBA的同事    class NBAObserver : Observer    {        public NBAObserver(string name, Subject sub)            : base(name, sub)        { }               //根据主题对象的行为更新自己        public override void Update()        {            Console.WriteLine(\"{0}{1}关闭NBA,继续工作!\",sub.SubjectState ,name);        }    }   客户端 class Program    {        static void Main(string[] args)        {            //老板胡汉三            Boss huhansan = new Boss();            //两个同事            StockObserver tongshi1 = new StockObserver(\"魏管姹\", huhansan);            NBAObserver tongshi2 = new NBAObserver(\"易管查\", huhansan);                        //增加同事            huhansan.Attach(tongshi1);            huhansan.Attach(tongshi2);            //减少同事            huhansan.Detach(tongshi1);            //老板状态            huhansan.SubjectState = \"我胡汉三回来了！\";            //通知            huhansan.Notify();        }    }   4、事件委托          委托就是一种引用方法的类型，一旦为委托分配了方法，委托将与该方法具有完全相同的行为。委托方法的使用可以像其他任何方法一样，具有参数和返回值。委托可以看做是对函数的抽象，是函数的‘类’，委托的实例将代表一个具体的函数。 使用委托的前提：委托对象所搭载的所有方法必须具有相同的原形和形式，也就是拥有相同的参数列表和返回值。   举例：还是上一个例子，用委托方法实现。   代码实现  //通知者接口    interface Subject    {    void Notify();        string SubjectState        {        get;        set;        }    }    //声明一个委托，无参数，无返回值    delegate void EventHandler();    //老板类    class Boss:Subject    {    //声明一事件Update，类型为委托EventHandler     public event EventHandler Update;       //老板行为    private string action;        //通知时更新    public void Notify()    {      Update();    }                //老板状态        public string SubjectState        {        get{return action;}        set{action=value;}        }    }        看股票同事和看NBA直播同事去掉父类，根据各自的不同更新各自动作 //看股票的同事    class StockObserver    {        private string name;        private Subject sub;        public StockObserver(string name, Subject sub)        {            this.name = name;            this.sub = sub;        }        //关闭股票行情        public void CloseStockMarket()        {            Console.WriteLine(\"{0}{1}关闭股票行情，继续工作！\", sub.SubjectState, name);        }    }    //看NBA直播    class NBAObserver    {        private string name;        private Subject sub;        public NBAObserver(string name,Subject sub)        {        this.name=name;        this.sub=sub;        }        //关闭NBA直播        public void CloseNBADirectSeeding()        {        Console.WriteLine(\"{0}{1}关闭NBA，继续工作！\",sub.SubjectState,name);        }    }       客户端增加减少委托事件 class Program    {        static void Main(string[] args)        {            //老板            Boss huhansan=new Boss ();            //同事            StockObserver tongshi1=new StockObserver(\"魏管姹\",huhansan);            NBAObserver tongshi2=new  NBAObserver (\"易管查\",huhansan);                        //增加委托            huhansan.Update+=new EventHandler (tongshi1.CloseStockMarket );            huhansan.Update+=new EventHandler (tongshi2.CloseNBADirectSeeding );            //老板状态            huhansan.SubjectState =\"我胡汉三回来了！\";            //通知            huhansan.Notify ();        }    }      5、两个例子区别        这两个例子实现的区别：通过委托实现的是把两个子类分开，去掉了父类，把各自的方法更新放在了自己类里面，声明了一个委托，把通知这个事件委托给老板，老板状态一更新，观察者的状态也就随着改变，只要增加一个观察者就增加一个委托事件。而观察者模式是通过具体观察者继承抽象观察者，抽象通知者依赖于抽象观察者。       6、总结     通过观察者模式，把一对多对象之间的通知依赖关系变得更为松散，大大的提高程序的可维护性和可扩展性，也很好的符合了开放—封闭原则。        ","title":"[置顶] 设计模式——剖析观察者模式"},{"content":"在编程时，常常需要集中存放多个数据，例如权限管理里面对角色所具有的权值进行遍历然后返回。当然我们可以使用数组来保存多个对象，数组存放数据的好处就是查找简单，通过数组的下标可以准确的进行定位。但是数组也有其自身的缺陷，其长度不可变化，也就是说一旦初始化数组时指定了数组长度，则这个数组长度是不可变的。所以如果需要保存个数变化的数据，数组就无能为力了。还有一点就是而且数组无法保存具有映射关系的数据（例如记录学生成绩的键值对）。俗话说工欲善其事必先利其器，这时候就轮到集合类上场了。集合类主要负责保存、盛装其他数据，因此集合类也被称为容器类。集合类和数组不一样，数组元素既可以是基本类型的值，也可以是对象（实际上保存的是对象的引用变量）；但集合里只能保存对象（实际上也是保存对象的引用变量，但通常习惯上认为集合里保存的是对象）。 Java的集合类主要由两个接口派生而出：Collection和Map，Collection和Map是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类。 Collection：通过名字理解类的作用，Set和List接口是Collection接口派生的两个子接口，它们分别代表了无序集合和有序集合；Queue是Java提供的队列实现，有点类似于List Map：用于保存具有映射关系的数据 我们可以把Java的所有集合分成三大类，具体到类各有各的特点需要具体类具体分析： 1、其中Set集合类似于一个罐子，把对象添加到Set集合时，Set集合无法记住添加这个元素的顺序，所以Set里面的元素不能重复（否则系统无法准确识别这个元素） 2、List集合像一个数组，它可以记住每次添加元素的顺序，只是List的长度可变。 3、Map集合也像一个罐子，只是它里面的每项数据都由两个值组成。 不同的存储方式决定了读取方式的不同： 1、Set集合中的元素只能根据其元素本身来访问。 2、List集合中的元素，可以直接根据元素的索引来访问。 3、Map集合中的元素根据元素对应的key访问   在网上看了很多关于集合的博客，大多数人总结这些集合的实现类时总想把每个类的每个方法都搞清楚。其实想一想在短时间内这是不可能的，除非具体的用过某个类才会对某个类或者方法有深刻的印象。就像当年学习快捷键似的，N多快捷键怎么办，分门别类啊！集合类也是一样，说白了一共就两大类（Collection，Map），然后再往下分才有了三小类（Set，List，Map）。至于对待他们下边N多实现类和对待当年的快捷键是一个方法，什么常用（常用的三个集合类在图中已经由红色字体标识）就先学什么，不常用就先放一放。还有一点，总结的图应该是简洁的，而且越简洁越好。图中携带的信息越多只能说明自己脑子里的东西越少，因为什么信息都在图中了，脑子也就懒得“记忆”与思考了。","title":"Java中的集合"},{"content":"        结合上篇《多线程的基础》，这次我们写一个多线程的赛跑实例，内容很简单：超人和蜘蛛侠赛跑，因为超人飞的比蜘蛛侠跳的快，为了公平，我们让蜘蛛侠跑的长度小点，裁判负责宣布比赛的开始和结束。 class MultiThread    {        //定义两个线程，分别为超人和蜘蛛侠        private static Thread SuperMan;        private static Thread SpiderMan;        //程序入口，比赛开始        static void Main(string[] args)        {            //初始化数据            InitData();            //裁判吹哨，开始赛跑            JudgeWork();        }        /// <summary>        /// 初始化超人和蜘蛛侠的线程和姓名        /// <\/summary>        private static void InitData()        {            SuperMan = new Thread(new ParameterizedThreadStart(RunnerWork));            SpiderMan = new Thread(new ParameterizedThreadStart(RunnerWork));            SuperMan.Name = \"SuperMan\";            SpiderMan.Name = \"SpiderMan\";        }        /// <summary>        /// 裁判开始比赛，最后宣布胜者        /// <\/summary>        private static void JudgeWork()        {            Console.WriteLine(\"{0}   PK   {1}\", SuperMan.Name, SpiderMan.Name);            Console.WriteLine(\"比赛即将开始，请各位做好准备！\");            Console.WriteLine(\"预备!\");            Console.Read();            //Superman起跑            Console.WriteLine(\"回车枪响，Superman开始起跑！\");            Console.Beep(654, 1200);            SuperMan.Start(500);            //Monster起跑            Console.WriteLine(\"回车枪响，SpiderMan开始起跑！\");            SpiderMan.Start(200);            SuperMan.Join();            SpiderMan.Join();            //宣布赛跑结果            Console.WriteLine(\"我宣布比赛结束\");            //程序暂停12秒            Thread.Sleep(12000);        }        /// <summary>        /// 赛跑的过程        /// <\/summary>        /// <param name=\"obj\">赛跑参数<\/param>        private static void RunnerWork(Object obj)        {            int length = Int32.Parse(obj.ToString());            Thread CurrentThread = Thread.CurrentThread;            string CurThreadName = CurrentThread.Name;            int speed;            //超人速度为20            if (CurThreadName == SuperMan.Name)            {                speed = 50;            }            //蜘蛛侠速度为20            else if (CurThreadName == SpiderMan.Name)            {                speed = 20;            }            //如果不可控线程进入，采用以下速度            else            {                speed = 1;            }            Console.WriteLine(\"{0},开始起跑…………\", CurThreadName);            for (int count = speed; count <= length; count += speed)            {                Thread.Sleep(1000);                Console.WriteLine(\"{0}……跑到了第{1}米\", CurThreadName, count.ToString());            }            Console.WriteLine(\"{0},到达终点！了咧欢迎……\", CurThreadName);        }    }        运行结果：                      比赛刚刚开始,裁判即宣布结束,这不符合常理。仔细分析可以发现，程序可控制的进程一共有三个，即裁判、超人和蜘蛛侠，三个进程相互独立同时进行，所以裁判宣布比赛开始后即按照它的线程继续宣布结束。         我们可以这样：在裁判宣布比赛开始后，让蜘蛛侠和超人的线程执行完毕再执行裁判进程： //防止裁判的主进程先结束，让超人和蜘蛛侠的进程先执行完毕SuperMan.Join();SpiderMan.Join();Console.WriteLine(\"我宣布比赛结束\");        这次的执行结果为：                  赛跑结束,裁判才宣布比赛结束,但是还有问题，裁判总得宣布谁跑赢了吧，台底下这么多粉丝等着呢？这个我们可以用变量的方式保存署名，达到宣布谁为冠军的功能。         为了展示同步异步读写问题，我们让超人赛跑中去拯救世界，然后回来继续比赛；先到达终点的人，自己花时间找粉笔，然后在黑板上署名，其他人看到黑板上有名字就不能再写，裁判宣布署名的人为胜者。 class MultiThread3{    //署名用的黑板    static string NameBoard = \"\";    //定义两个线程，分别为超人和蜘蛛侠    private static Thread SuperMan;    private static Thread SpiderMan;    //程序入口，比赛开始    static void Main(string[] args)    {        //初始化数据        InitData();        //裁判吹哨，开始赛跑        JudgeWork();    }    /// <summary>    /// 初始化超人和蜘蛛侠的线程和姓名    /// <\/summary>    private static void InitData()    {        SuperMan = new Thread(new ParameterizedThreadStart(RunnerWork));        SpiderMan = new Thread(new ParameterizedThreadStart(RunnerWork));        SuperMan.Name = \"SuperMan\";        SpiderMan.Name = \"SpiderMan\";    }    /// <summary>    /// 裁判开始比赛，最后宣布胜者    /// <\/summary>    private static void JudgeWork()    {        Console.WriteLine(\"{0}   PK   {1}\", SuperMan.Name, SpiderMan.Name);        Console.WriteLine(\"比赛即将开始，请各位做好准备！\");        Console.WriteLine(\"预备!\");        Console.Read();        //Superman起跑        Console.WriteLine(\"回车枪响，SuperMan开始起跑！\");        Console.Beep(654, 1200);        SuperMan.Start(500);        //Monster起跑        Console.WriteLine(\"回车枪响，SpiderMan开始起跑！\");        SpiderMan.Start(300);        //防止裁判的主进程先结束，让超人和蜘蛛侠的进程先执行完毕        SuperMan.Join();        SpiderMan.Join();        //宣布赛跑结果        AnnounceWinner();        //程序暂停12秒        Thread.Sleep(12000);    }    /// <summary>    /// 赛跑的过程    /// <\/summary>    /// <param name=\"obj\">赛跑参数<\/param>    private static void RunnerWork(Object obj)    {        int length = Int32.Parse(obj.ToString());        Thread CurrentThread = Thread.CurrentThread;        string CurThreadName = CurrentThread.Name;        int speed;        //超人速度为20        if (CurThreadName == SuperMan.Name)        {            speed = 50;        }        //蜘蛛侠速度为20        else if (CurThreadName == SpiderMan.Name)        {            speed = 20;        }        //如果不可控线程进入，采用以下速度        else        {            speed = 1;        }        Console.WriteLine(\"{0},开始起跑…………\", CurThreadName);        for (int count = speed; count <= length; count += speed)        {            Thread.Sleep(1000);            Console.WriteLine(\"{0}……跑到了第{1}米\", CurThreadName, count.ToString());            //超人跑到一半，去拯救世界            if (count == length / 2)            {                if (CurThreadName == SuperMan.Name)                {                    Console.WriteLine(\"世界末日来临，超人去拯救世界……\");                    string waitInfo = \"..\";                    //超人拯救世界过程                    for (int j = 0; j <= 10; j++)                    {                        Console.WriteLine(\"超人拯救世界中\" + waitInfo);                        waitInfo += \"..\";                        Thread.Sleep(1000);                    }                     Console.WriteLine(\"超人去拯救世界归来，继续赛跑……\");                }            }        }        Console.WriteLine(\"{0},到达终点！乐咧欢迎……\", CurThreadName);        WriteName(CurThreadName);    }    /// <summary>    /// 跑到重点线后，选手自己在黑板上署名    /// <\/summary>     /// <param name=\"name\">选手姓名<\/param>    private static void WriteName(string name)    {        //黑板上没名字，才可以署自己的名字        if (NameBoard.Length == 0)        {            Console.WriteLine(\"{0}去找粉笔了……\", name);            //找粉笔花费的时间            Thread.Sleep(9000);            Console.WriteLine(\"{0}拿着粉笔回来了，开始署名……\", name);            NameBoard = name;            Console.WriteLine(\"{0}署完名后，开心的离开了……\", name);        }        //黑板上有署名时不能再署名        else        {            Console.WriteLine(\"{0}发现已经署名，桑心的离开了……\", name);        }    }    /// <summary>    /// 宣布比赛结果    /// <\/summary>    private static void AnnounceWinner()    {        Console.WriteLine(\"我是裁判，我宣布这次比赛的冠军是{0}\", NameBoard);    }}        运行结果：                           可以看到明明是SuperMan还在拯救地球时，SpiderMan已经到达终点，而裁判宣布的冠军却是SuperMan。仔细分析一下程序即可知道：虽然SpiderMan先到达终点，并且先发现黑板是空的，但是在SpiderMan寻找粉笔的过程中，SuperMan到达终点，并且也发现黑板是空的，于是两人都写上了自己的名字，但是因为后者的会覆盖前者的，所以胜利者成了SuperMan，整个过程如下图所示：                  问题出现的原因在于，SpiderMan到达以后看到黑板，SuperMan仍然看到黑板，即这个黑板对于两个人都是可写的，后者会覆盖前者的内容，这种方式为异步写。         怎么克服这个问题？可以使用Lock锁住临界区代码，如下：         //定义一个对象类型的objLock        private static object objLock = new object();        /// <summary>        /// 跑到重点线后，选手自己在黑板上署名        /// <\/summary>         /// <param name=\"name\">选手姓名<\/param>        private static void WriteName(string name)        {            //采用异步读方式，筛选掉已经看到署名的线程，提高效率            //黑板上没名字，才可以署自己的名字            if (NameBoard.Length == 0)            {                //因为上面为异步读，所以可能多个线程可以进入到这一步                lock (objLock)                {                    //同步读方式                    if (NameBoard.Length == 0)                    {                        Console.WriteLine(\"{0}去找粉笔了……\", name);                        //找粉笔花费的时间                        Thread.Sleep(9000);                        Console.WriteLine(\"{0}拿着粉笔回来了，开始署名……\", name);                        NameBoard = name;                        Console.WriteLine(\"{0}署完名后，开心地离开了……\", name);                    }                    //黑板上有署名时不能再署名                    else                    {                        Console.WriteLine(\"{0}发现已经署名，桑心地离开了……\", name);                    }                }            }        }              需要注意的是，锁住的内容（非临界区代码）必须是共享型的引用型数据，因为如果是局部变量针对一个线程锁不锁对其它线程意义不大；采用引用数据类型，可以保证每个线程锁住内容都指向同一个地址。         为了直观显示，没有抽象出超人、蜘蛛侠和裁判的类，以上就是一个简单的多线程应用实例，当然这是多线程的冰山一角，更多的还有待在以后开发中实践，这次争取在考试系统使用多线程优化抽题和判分等功能。","title":"C#多线程赛跑实例"},{"content":"     在做 jsp 上传图片时，把 java 代码直接改成 jsp，上传时产生 如下异常: 2012-12-31 8:59:21 org.apache.catalina.core.StandardWrapperValve invoke 严重: Servlet.service() for servlet jsp threw exception java.io.IOException: Stream closed    ... 百思不得其解，翻出 jsp 转成 servlet 后的代码。如下(很很的醒目一下)： ... }catch(Exception e){         e.printStackTrace();     }finally{     out.flush(); //     out.close();// 此处为源始代码        DBHelper.freeConnection(connection);     }       out.write('\\r');  // 如上我已经关了 out 对象，但此处还在使用，所以便产生了如开始所描述的异常       out.write('\\n');     } catch (Throwable t) {       if (!(t instanceof SkipPageException)){         out = _jspx_out;         if (out != null && out.getBufferSize() != 0)           try { out.clearBuffer(); } catch (java.io.IOException e) {}         if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);       }     } finally {       _jspxFactory.releasePageContext(_jspx_page_context);     } ... 解决办法：把程序中加红加粗的代码改成： out.flush() ; out = pageContext.pushBody();  // 关于该段程序的解释,doc中已经说的很清楚。如下：（要特别注意一下flush()和clear()方法的区别，因为需求不同程序是不同的） abstract void flush() Flush the stream. abstract void clear() Clear the contents of the buffer. PageContext 实现了抽象类 JspContext  ,方法:pushBody（）， 保存当前的out对象 BodyContent pushBody() Return a new BodyContent object, save the current \"out\" JspWriter, and update the value of the \"out\" attribute in the page scope attribute namespace of the PageContext. public abstract class BodyContent extends JspWriter out 内置对象","title":"JSP 上传图片产生 java.io.IOException: Stream closed"},{"content":"前段时间有学习过unittest这个模块，但是，没有熟练使用，还是存在好多疑问。今天又重新花时间学习，比较彻底的搞清楚了。记录下来，希望对那些有同样疑问的人，有些帮助。 首先，介绍以下unittest的基本用法。 第1种用法（以下代码是官方文档的sample）。 import unittestclass TestSequenceFunctions(unittest.TestCase):    def setUp(self):        self.seq = range(10)    def test_choice(self):        element = random.choice(self.seq)        self.assertTrue(element in self.seq)    def test_sample(self):        with self.assertRaises(ValueError):            random.sample(self.seq, 20)        for element in random.sample(self.seq, 5):            self.assertTrue(element in self.seq)if __name__ == '__main__':    unittest.main() 这是常见的用法，1.从unittest.TestCase继承一个子类。2.定义测试方法，以test开头。3.调用unittest.main()，这个方法会自动执行所有以test开头的测试方法。 第2种调用方法：自己创建一个TestSuite，添加需要执行测试的TestCase，然后使用TestRunner().run(suite)执行测试。 def suite():    suite = unittest.TestSuite()    suite.addTest(TestSequenceFunctions('test_choice')    suite.addTest(TestSequenceFunctions('test_sample')    return sutieif __name__ == '__main__':    unittest.TextTestRunner().run(suite()) TestSuite也可以通过以下的方式获得。这个方法，自动从TestCase子类的test开头的方法创建TestCase对象，并添加到sutie里。 suite = unittest.TestLoader().loadFromTestCase(TestSequenceFunctions) 接下来，介绍unittest模块里的几个主要的类。 TestCase， TestSuite，TestLoader， TestRunner，之间的关系 TestCase：顾名思义，是测试用例类，每个对象都是一个测试用例。TestCase对象具有__call__属性，定义如下，直接调用对象()，将执行run()。 428     def __call__(self, *args, **kwds):429         return self.run(*args, **kwds)run()方法将执行setUp(), testMethod(), tearDown()。当然，完整的内容还包含skip的部分（官方文档有介绍这些），这里暂略过。这里主要看testMethod，这是从对象的属性self._testMethodName获得的一个方法。 342         testMethod = getattr(self, self._testMethodName)再看看TestCase的__init__都做了哪些事情。如下所示，在创建一个TestCase对象时，实际上是指定一个test方法名称，检查这个类是否具有这个属性，否则抛出异常。这个方法名称也就是run()会调用的，缺省的时候是‘runTest’。所以，每个TestCase对应一个测试方法，执行一个测试。 218     def __init__(self, methodName='runTest'):223         self._testMethodName = methodName225         try:226             testMethod = getattr(self, methodName)227         except AttributeError:228             raise ValueError(\"no such test method in %s: %s\" %229                   (self.__class__, methodName)) TestSuite：可以认为是一个容器，包含TestCase对象，或者TestSuite对象。官方定义：aggregation of individual tests cases and test suites。 类的主要成员是_tests列表，用以包含其他suite或者testcase对象。  19     def __init__(self, tests=()): 20         self._tests = [] 21         self.addTests(tests)  56     def addTests(self, tests): 59         for test in tests: 60             self.addTest(test)  46     def addTest(self, test): 54         self._tests.append(test)addTest和addTests方法中，忽略了sanity test的代码。可以看出，只是简单地将test添加到列表中。TestSuite具有__iter__属性，所以可用于列表遍历。  37     def __iter__(self): 38         return iter(self._tests)TestSuite和TestCase一样具有__call__属性，调用run()。run的内容如下，最终执行每个test对象的run方法。  62     def run(self, result): #result是一个对象，用于保存测试结果 63         for test in self: #将调用self.__iter__，最终访问self._tests列表 66             test(result)  #这里调用每个test对象的run方法 67         return result TestLoader：用于从TestCase类创建TestSuite。官方定义：The TestLoader class is used to create test suites from classes and modules。 主要的方法：loadTestsFromTestCase和loadTestsFromModule。 先看看loadTestsFromTestCase，代码如下。首先找出TestCase类中所有以test开头的方法名，默认用'runTest'。然后，使用这些方法名，每个创建一个TestCase对象，并用这些对象创建一个TestSuite容器对象。最后，返回这个suite对象。  48     def loadTestsFromTestCase(self, testCaseClass): 53         testCaseNames = self.getTestCaseNames(testCaseClass)#找出TestCase类中所有以test开头的方法名 54         if not testCaseNames and hasattr(testCaseClass, 'runTest'): 55             testCaseNames = ['runTest'] 56         loaded_suite = self.suiteClass(map(testCaseClass, testCaseNames)) 57         return loaded_suite再看看loadTestsFromModule，代码如下。先找出模块文件中，所有的TestCase子类。然后，从每个TestCase获得一个TestSuite。最后，将所有的TestSuite放在一个TestSuite中返回。  59     def loadTestsFromModule(self, module, use_load_tests=True): 61         tests = [] 62         for name in dir(module): 63             obj = getattr(module, name) 64             if isinstance(obj, type) and issubclass(obj, case.TestCase):#找出模块文件中，所有TestCase子类 65                 tests.append(self.loadTestsFromTestCase(obj))#调用loadTestsFromTestCase获得一个TestSuite对象 68         tests = self.suiteClass(tests) 75         return tests TextTestRunner：执行test对象（可以是TestCase对象，或者TestSuite对象）的run()，以text方式打印结果。主要用到的方法是run()，代码如下。这里我们主要关注'test(result)'这一行。如果test是一个TestSuite对象，将递归的调用它所包含的每个对象的run方法。 140     def run(self, test):141         \"Run the given test case or test suite.\"142         result = self._makeResult()143         registerResult(result)144         result.failfast = self.failfast145         result.buffer = self.buffer146         startTime = time.time()147         startTestRun = getattr(result, 'startTestRun', None)148         if startTestRun is not None:149             startTestRun()150         try:151             test(result)#调用test对象，最终调用run()方法152         finally:153             stopTestRun = getattr(result, 'stopTestRun', None)154             if stopTestRun is not None:155                 stopTestRun()156         stopTime = time.time()157         timeTaken = stopTime - startTime158         result.printErrors() 最后，unittest.main()做些什么 在main.py文件中，将被执行的是runTests()，代码如下。 213     def runTests(self):216         if self.testRunner is None:217             self.testRunner = runner.TextTestRunner#默认创建一个TextTestRunner对象，和第2种用法其实一样218         if isinstance(self.testRunner, (type, types.ClassType)):219             try:220                 testRunner = self.testRunner(verbosity=self.verbosity,221                                              failfast=self.failfast,222                                              buffer=self.buffer)223             except TypeError:224                 # didn't accept the verbosity, buffer or failfast arguments225                 testRunner = self.testRunner()226         else:227             # it is assumed to be a TestRunner instance228             testRunner = self.testRunner229         self.result = testRunner.run(self.test)#执行testRunner.run()，执行test对象的run方法。那么self.test对象是如何来的呢？ 153     def createTests(self):154         if self.testNames is None:155             self.test = self.testLoader.loadTestsFromModule(self.module)#默认执行，将从我们的文件中所有的TestCase类创建TestSuite156         else:157             self.test = self.testLoader.loadTestsFromNames(self.testNames,158                                                            self.module) testLoader的默认值，在TestProgram的__init__中有定义，其实就是一个defaultTestLoader对象。 testLoader=loader.defaultTestLoader,所以，当我们执行unittest.main()时（第一种调用方法），将执行以下两个动作。 首先，创建一个defaultTestLoader，从我们文件中找出所有TestCase子类，并从每个子类中找出所有以test开头的方法名，用以创建一个TestSuite对象，然后将这些TestSuite对象放在一个TestSuite对象中。 接着，创建一个TestRunner，执行run(上一步创建的TestSutie对象），并打印结果。 可以看出，第1种用法和第2中用法一样，首先创建TestSuite，包含所有要执行的TestCase。然后，创建一个TestRunner，调用run()执行所有的TestCase对象。第2种用法，可以自定义更多的内容。第1种用法，默认执行所有以test开头的测试。 总结，应该批评一下自己，在第一次了解unittest时，为什么不搞清楚呢？而要再花一次时间。这表明第一次是浪费了。再者，对于单元测试，其实我也就这一段时间才刚开始使用，还不熟练，谈不上什么门道。但，我能感觉到它的威力，TDD开发确实比我以前的方法好，让我在开发或重构时，更有信心，不再那么提心吊胆了。在没有更好的方法之前，先掌握TDD。庆幸的是，python有unittest。^_^，每天进步一点点。","title":"Unittest使用和代码简介"},{"content":"英文原址：http://www.risc.jku.at/people/ckoutsch/stuff/e_algorithms.html      奥地利符号计算研究所（Research Institute for Symbolic Computation，简称RISC）的Christoph Koutschan博士在自己的页面上发布了一篇文章，提到他做了一个调查，参与者大多数是计算机科学家，他请这些科学家投票选出最重要的算法，以下是这次调查的结果，按照英文名称字母顺序排序。 1.A* 搜索算法——图形搜索算法，从给定起点到给定终点计算出路径。其中使用了一种启发式的估算，为每个节点估算通过该节点的最佳路径，并以之为各个地点排定次序。算法以得到的次序访问这些节点。因此，A*搜索算法是最佳优先搜索的范例。 2.集束搜索（又名定向搜索，Beam Search）——最佳优先搜索算法的优化。使用启发式函数评估它检查的每个节点的能力。不过，集束搜索只能在每个深度中发现最前面的m个最符合条件的节点，m是固定数字——集束的宽度。 3.二分查找（Binary Search）——在线性数组中找特定值的算法，每个步骤去掉一半不符合要求的数据。 4.分支界定算法（Branch and Bound）——在多种最优化问题中寻找特定最优化解决方案的算法，特别是针对离散、组合的最优化。 5.Buchberger算法——一种数学算法，可将其视为针对单变量最大公约数求解的欧几里得算法和线性系统中高斯消元法的泛化。 6.数据压缩——采取特定编码方案，使用更少的字节数（或是其他信息承载单元）对信息编码的过程，又叫来源编码。 7.Diffie-Hellman密钥交换算法——一种加密协议，允许双方在事先不了解对方的情况下，在不安全的通信信道中，共同建立共享密钥。该密钥以后可与一个对称密码一起，加密后续通讯。 8.Dijkstra算法——针对没有负值权重边的有向图，计算其中的单一起点最短算法。 9.离散微分算法（Discrete differentiation） 10.动态规划算法（Dynamic Programming）——展示互相覆盖的子问题和最优子架构算法 11.欧几里得算法（Euclidean algorithm）——计算两个整数的最大公约数。最古老的算法之一，出现在公元前300前欧几里得的《几何原本》。 12.期望-最大算法（Expectation-maximization algorithm，又名EM-Training）——在统计计算中，期望-最大算法在概率模型中寻找可能性最大的参数估算值，其中模型依赖于未发现的潜在变量。EM在两个步骤中交替计算，第一步是计算期望，利用对隐藏变量的现有估计值，计算其最大可能估计值；第二步是最大化，最大化在第一步上求得的最大可能值来计算参数的值。 13.快速傅里叶变换（Fast Fourier transform，FFT）——计算离散的傅里叶变换（DFT）及其反转。该算法应用范围很广，从数字信号处理到解决偏微分方程，到快速计算大整数乘积。 14.梯度下降（Gradient descent）——一种数学上的最优化算法。 15.哈希算法（Hashing） 16.堆排序（Heaps） 17.Karatsuba乘法——需要完成上千位整数的乘法的系统中使用，比如计算机代数系统和大数程序库，如果使用长乘法，速度太慢。该算法发现于1962年。 18.LLL算法（Lenstra-Lenstra-Lovasz  lattice reduction）——以格规约（lattice）基数为输入，输出短正交向量基数。LLL算法在以下公共密钥加密方法中有大量使用：背包加密系统（knapsack）、有特定设置的RSA加密等等。 19.最大流量算法（Maximum flow）——该算法试图从一个流量网络中找到最大的流。它优势被定义为找到这样一个流的值。最大流问题可以看作更复杂的网络流问题的特定情况。最大流与网络中的界面有关，这就是最大流-最小截定理（Max-flow min-cut theorem）。Ford-Fulkerson 能找到一个流网络中的最大流。 20.合并排序（Merge Sort） 21.牛顿法（Newton's method）——求非线性方程（组）零点的一种重要的迭代法。 22.Q-learning学习算法——这是一种通过学习动作值函数（action-value function）完成的强化学习算法，函数采取在给定状态的给定动作，并计算出期望的效用价值，在此后遵循固定的策略。Q-leanring的优势是，在不需要环境模型的情况下，可以对比可采纳行动的期望效用。 23.两次筛法（Quadratic Sieve）——现代整数因子分解算法，在实践中，是目前已知第二快的此类算法（仅次于数域筛法Number Field Sieve）。对于110位以下的十位整数，它仍是最快的，而且都认为它比数域筛法更简单。 24.RANSAC——是“RANdom SAmple Consensus”的缩写。该算法根据一系列观察得到的数据，数据中包含异常值，估算一个数学模型的参数值。其基本假设是：数据包含非异化值，也就是能够通过某些模型参数解释的值，异化值就是那些不符合模型的数据点。 25.RSA——公钥加密算法。首个适用于以签名作为加密的算法。RSA在电商行业中仍大规模使用，大家也相信它有足够安全长度的公钥。 26.Schönhage-Strassen算法——在数学中，Schönhage-Strassen算法是用来完成大整数的乘法的快速渐近算法。其算法复杂度为：O(N log(N) log(log(N)))，该算法使用了傅里叶变换。 27.单纯型算法（Simplex Algorithm）——在数学的优化理论中，单纯型算法是常用的技术，用来找到线性规划问题的数值解。线性规划问题包括在一组实变量上的一系列线性不等式组，以及一个等待最大化（或最小化）的固定线性函数。 28.奇异值分解（Singular value decomposition，简称SVD）——在线性代数中，SVD是重要的实数或复数矩阵的分解方法，在信号处理和统计中有多种应用，比如计算矩阵的伪逆矩阵（以求解最小二乘法问题）、解决超定线性系统（overdetermined linear systems）、矩阵逼近、数值天气预报等等。 29.求解线性方程组（Solving a system of linear equations）——线性方程组是数学中最古老的问题，它们有很多应用，比如在数字信号处理、线性规划中的估算和预测、数值分析中的非线性问题逼近等等。求解线性方程组，可以使用高斯—约当消去法（Gauss-Jordan elimination），或是柯列斯基分解（ Cholesky decomposition）。 30.Strukturtensor算法——应用于模式识别领域，为所有像素找出一种计算方法，看看该像素是否处于同质区域（ homogenous region），看看它是否属于边缘，还是是一个顶点。 31.合并查找算法（Union-find）——给定一组元素，该算法常常用来把这些元素分为多个分离的、彼此不重合的组。不相交集（disjoint-set）的数据结构可以跟踪这样的切分方法。合并查找算法可以在此种数据结构上完成两个有用的操作： 查找：判断某特定元素属于哪个组。 合并：联合或合并两个组为一个组。 32.维特比算法（Viterbi algorithm）——寻找隐藏状态最有可能序列的动态规划算法，这种序列被称为维特比路径，其结果是一系列可以观察到的事件，特别是在隐藏的Markov模型中。","title":"计算机科学中最重要的32个算法"},{"content":"    C＋＋语言是一个面向对象的语言，使用C＋＋编写的代码更加简捷、高效，更具可维护性和可重用性。但是很多人使用了C＋＋语言后却感到C＋＋与C编程没有什么区别。这其实是由于对C＋＋语言的特点和特色理解和使用不够造成的。事实上，没有任何一个程序员使用C语言的编程效率可以超过C＋＋语言的。  　　一、使用new和delete进行动态内存分配和释放 　　运算符new和delete是C＋＋新增的过算符，提供了存储的动态分配和释放功能。它的作用相当于C语言的函数malloc（）和free（），但是性能更为优越。使用new比使用malloc（）有以下的几个优点：  　　（1）new自动计算要分配类型的大小，不使用sizeof运算符，比较省事，可以避免错误。  　　（2）它自动地返回正确的指针类型，不用进行强制指针类型转换。  　　（3）可以用new对分配的对象进行初始化。  　　使用例子：  　　（1）int *p；  　　　　　　p＝new int［10］； ／／分配一个含有10个整数的整形数组  　　　　　　delete［］ p； ／／删除这个数组  　　（2）int *p；  　　　　　p＝new int （100）；／／动态分配一个整数并初始化  　　二、使用inline内连函数替代宏调用  　　对于频繁使用的函数，C语言建议使用宏调用代替函数调用以加快代码执行，减少调用开销。但是宏调用有许多的弊端，可能引起不期望的副作用。例如宏：  　　＃define abs（a） （（a）＜0？（－a）：（a））， 当使用abs（I＋＋）时，这个宏就会出错。  　　所以在C＋＋中应该使用inline内连函数替代宏调用，这样即可达到宏调用的功能，又避免了宏调用的弊端。使用内连函数只需把inline关键字放在函数返回类型的前面。例如： 　   　inline int Add（int a，int b）；／／声明Add（）为内连函数  　　这样编译器在遇到Add（）函数时，不再进行函数调用，而是直接嵌入函数代码以加快程序的执行。  　　三、使用函数重载  　　在C语言中，两个函数的名称不能相同，否则会导致编译错误。而在C＋＋中，函数名相同而参数不同的两个函数被解释为重载。例如：  　　void PutHz(char *str); //在当前位置输出汉字  　　void PutHz(int x,int y,char *str); ／／在x，y处输出汉字  　　使用函数重载可以帮助程序员应付更多的复杂性，避免了使用诸如intabs（）、fabs（）、dabs（）等繁杂的函数名称；同时在大型程序中，使函数名易于管理和使用，而不必绞尽脑汁地去处理函数名。  　　四、使用引用（reference）代替指针进行参数传递  　　在C语言中，如果一个函数需要修改用作参数的变量值的时候 ，参数应该声明为指针类型。例如：  　　　void Add(int *a) {(*a)++;}  　　但是对于复杂的程序，使用指针容易出错，程序也难以读懂。在C＋＋中，对于上述情况 可以使用引用来代替指针，使程序更加清晰易懂。引用就是对变量取的一个别名，对引用进行操作，就相当于对原有变量进行操作。，例如使用引用的函数定义为：  　　void Add(int &a) (a++;); //a为一个整数的引用  　　这个函数与使用指针的上一个函数的功能是一样的，然而代码却更为简洁和清晰易懂。  　　五、使用缺省参数  　　在C＋＋中函数可以使用缺省参数，例如：      void PutHzxy(char *str,int x=-1,int y=-1)      { if (x==-1) x=wherex();        if (y==-1) y=wherey();        moveto(x,y)        PutHz(str);}  　可以有两种方式调用函数PutHzxy（），例如：  　　PutHzxy(\"C++语言\");//使用缺省参数,在当前位置输出  　　PutHzxy(\"C++语言\",10,10);//没有使用缺省参数  　通常的情况下，一个函数应该尽可能地具有更大的灵活性，使用缺省参数为程序员处理更大的复杂性和灵活性提供了有效的方法。所以在C＋＋的代码中都大量的使用了缺省参数。  　　需要说明的是，所有的缺省参数必须出现在不缺省参数的右边。亦即，一旦开始定义取缺省数值的参数，就不可再说明非缺省的参数。  　　例如：  void PutHzxy(char *str,int x=-1,int y=-1); //正确  void PutHzxy(int x=-1,int y=-1,char *str);//错误  　　六、使用“类”对数据进行封装 　　C语言是模块化的程序语言，通过函数的使用和文件的单独编译实现了一定的数据封装功能。但C＋＋通过使用“类”的强大功能，在数据封装、继承等很多的方面比C做得更好。通过使用“类”把数据和对数据的所有操作集合封装在一起，建立了一个定义良好的接口，使程序员在使用一个类的时候可以只关心它的使用，而不必关心它的实现。  　　由于函数也可一定程度上实现对数据的封装，在编写C＋＋程序时何时使用函数，何时使用类，对于C＋＋的初学者难以把握。根据笔者的经验，对于函数和类的使用总结出以下的方法：  　　首先把程序需要完成的功能划分为很多的基本子过程，一个子过程实现一种相对完整的功能。然后根据如下的规则进行划分：  　　（1）如果有一些数据被两个以上的子过程同时使用，应该把这些数据和这些子过程使用“类”进行封装。 　　（2）如果一些数据只被一个子过程使用，应把这些数据和这个子过程合成一个函数。这些数据声明为这个函数的内部临时数据。 　　（3）如果一些数据被一个子过程在不同的时间里几次使用，应把这些数据和这个子过程合成一个函数。这些数据被定义为这个函数的内部静态数据。 　　（4）如果一个子过程的功能在以后可能被修改或扩展，应该把这些过程及其使用的数合成一个类，以便以后使用继承的方法对其功能进行修改和扩充。 　　（5）当（2）、（3）和（4）矛盾时，以（4）为准。  　　例如，对于在C＋＋中使用鼠标这一程序含有10多个子过程，诸如MouseOpen（），MouseHide（）等等。如果是调用DOS的33H中断来实现，因为在程序中各个子过程之间没有共同使用的数据，所以应该把每个子过程定义为函数。  　　又如，如果定义了一个表示图形的数据结构，对于这个图形要进行放大、移动、旋转等子过程。因为这些子过程都要使用公共的图形数据，所以应该把这些子过程和这些图形数据定义为一个类。","title":"C/C++异同"},{"content":"CJuiAutoComplete 在用户输入时可以根据用户输入的前几个字符自动提示用户可以输入的文字。它封装了 JUI autocomplete插件。 基本用法如下 <?php$this->widget('zii.widgets.jui.CJuiAutoComplete', array(\t'name'=>'city',\t'source'=>$data,\t// additional javascript options for the autocomplete plugin\t'options'=>array(\t\t\t\t'minLength'=>'2',\t\t\t\t),\t\t\t'htmlOptions'=>array(\t\t\t\t'style'=>'height:20px;'\t\t\t\t),\t\t\t));?> 自动提示的数据源通过配置source属性来完成，实际应用时可以通过读取数据库，文件等。本例为简单起见，使用一个数组定义在SiteController中。 public function actionIndex(){\t$data=array('Nanjing', 'Beijing', 'Perth',\t\t'Chicago','Paris','Pengnai','Sydney');\t$this->render('index', array(\t\t'data' => $data,\t\t\t));} 本例下载","title":"Yii Framework 开发教程(34) Zii组件-AutoComplete示例"},{"content":"Zii组件中包含了一些基于JQuery的UI组件，这些UI组件定义在包zii.widgets.jui中，包括CJuiAccordion ，CJuiAutoComplete，CJuiDatePicker等。本篇介绍CJuiAccordion，显示一个Accordion组件（类似手风琴可以折叠的UI组件）。这个控件封装了 JUI Accordion插件。 基本用法如下： <?php$this->widget('zii.widgets.jui.CJuiAccordion', array(\t'panels'=>array(\t\t\t\t'panel 1'=>'Content for panel 1',\t\t\t\t'panel 2'=>'Content for panel 2',\t\t\t\t'panel 3'=>$this->renderPartial('_content1',null,true),\t\t\t\t),\t\t\t'options'=>array(\t\t\t\t'collapsible'=>true,\t\t\t\t'active'=>1,\t\t\t\t),\t\t\t'htmlOptions'=>array(\t\t\t\t'style'=>'width:500px;'\t\t\t\t),\t\t\t));?> 通过定义panels 属性定义Accordion的几个可折叠的页面，通过配置 options传送参数给 JUI Accordion插件。 本例下载","title":"Yii Framework 开发教程(33) Zii组件-Accordion示例"},{"content":"CGridView 以表格的形式显示数据，CGridView 也支持分页和排序，CGridView最基本的用法和ListView类型，也是通过设置 data provider，通常是CActiveDataProvider。 修改上个例子Yii Framework 开发教程(31) Zii组件-DetailView 示例，把ListView该为GridView： <?php $this->widget('zii.widgets.grid.CGridView', array(\t'dataProvider'=>$dataProvider,\t'ajaxUpdate'=>false,\t'template'=>'{pager}{summary}{items}{pager}',)); ?> 显示结果如下： 可以看到GridView缺省显示了所有的字段，并使用缺省的格式显示字段，如果需要控制字段显示和格式，可以通过配置 CGridView::columns属性来实现。GridView的每列为一个CGridColumn对象： CGridColumn为所有Grid 列表项的基类，表格的每例可以有一个表头，多个数据单元，和一个可选的表尾单元格。 CButtonColumn 表示该单元格为一个或多个按钮，缺省显示三个按钮， “view”, “update” 和”delete”,可以通过设置 buttons 和 template来更改。 CCheckBoxColumn 表示该单元格为Checkbox，支持只读，单选或多选，通过配置selectableRows来修改 CDataColumn 表示该单元为数据或是表达式，通过配置name或value，前者表示数据模型的属性名称，后者代码一个PHP表达式。 CLinkColumn 表示一个超链接，通过配置 label ， url或 imageUrl来设置链接。 重新定义GridView的columns属性如下： <?php $this->widget('zii.widgets.grid.CGridView', array(\t'id'=>'person-grid',\t'dataProvider'=>$dataProvider,\t'htmlOptions'=>array('style'=>'width:740px'),\t'pager'=>array(\t\t\t\t'maxButtonCount'=>'7',\t\t\t\t),\t\t\t'columns'=>array(\t\t\t\tarray(\t\t\t\t\t'header'=>'Name',\t\t\t\t\t'type'=>'raw',\t\t\t\t\t'value'=>'CHtml::link($data->FirstName .\t\t\t\t\t \" \" . $data->LastName,\t\t\t\t\t $this->grid->controller->createUrl\t\t\t\t\t(\"view\",array(\"CustomerId\"=>$data->CustomerId)))',\t\t\t\t\t),\t\t\t\t'Company',\t\t\t\tarray(\t\t\t\t\t'class'=>'CLinkColumn',\t\t\t\t\t'header'=>'Email',\t\t\t\t\t'imageUrl'=>'images/email.png',\t\t\t\t\t'labelExpression'=>'$data->Email',\t\t\t\t\t'urlExpression'=>'\"mailto://\".$data->Email',\t\t\t\t\t'htmlOptions'=>array('style'=>'text-align:center'),\t\t\t\t\t),\t\t\t\tarray(\t\t\t\t\t'class'=>'CButtonColumn',\t\t\t\t\t'deleteConfirmation'=>'Are you sure to delete this item?',\t\t\t\t\t),\t\t\t\t),));?> 显示如下： 点击姓名可以显示DetailView。 ButtonColumn 的update,search,delete没有添加对应的view ，就留给你自己加上了。 本例下载","title":"Yii Framework 开发教程(32) Zii组件-GridView示例"},{"content":"博客缘由： 只有做项目才能巩固自己学习的知识， 只有做项目才知道自己有多健忘（例如一些函数的应用）， 只有做项目才知道自己真正的不足之处及知识的匮乏， 只有做项目才能让自己提高。 初步构想项目包括三方面语言的： 1.C语言（目前正在做的。。。） 2.C++  （精力有限暂时不做） 3.java  （正在学习基础知识。。。） 一、C语言小项目集锦: 系统系列： 1.同学通讯录系统（完整项目过程-迭代式开发） 2.简单的学生成绩管理系统 （用链表 多个文件） 3.学籍管理系统 4.模拟ATM自动取款机系统 小游戏系列： 1.五子棋   数学系列： 1..数学问题（一）之 杨辉三角 2.数学问题（二）螺旋矩阵 3.数学问题（三）之 约瑟夫环 点击打开链接 4.数学问题（四）之魔幻奇数矩阵（行，列，对角线和相等） 5.数学问题（五）之 矩阵倒置 6.模拟小学生加减乘除混合运算 字符串系列： 1.查找子字符串，并记录查找的第一个子字符串的位置    ","title":"[置顶] 小项目集锦博客目录（不断更新，总结）"},{"content":"全排序简介 从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。当m=n时所有的排列情况叫全排列。 如1,2,3三个元素的全排列为： 　　 1,2,3 　　 1,3,2 　　 2,1,3 　　 2,3,1 　　 3,1,2 　　 3,2,1   算法分析 1）为了方便扩展，采用char数组来保存字符串，字符数字可以定义ASCII中的符号（0-9，A-Z之类的）； 2）对于N个不同元素的全排序序列有N！种，输出了按编号1,2,3,4....N!输出； 3）第一个序列是所有元素的升序排列，最后一个序列是所有元素的降序排列； 4）设计一个方法从当前序列获取下一个序列，若序列是所有元素的降序排列，全排序结束；    具体做法：①从序列的最后一个位置开始扫描，找出第一个当前字符比前一个字符大的位置，若无此位置标示，算法结束；              ②将此位置的前一个字符放和后面的第一个比其大的字符交互，交互后位置之后的字符为降序排列；              ③将以位置开始的降序变为升序，获得下一个序列              ④重复①到③至算法结束。   程序 package test;public class TotalSort {\t// 初始系列，原则上要求按ASCII码升序排序（无重复）\tprivate static char[] charStr = {'1','2','9','A','B','C'};\t/**\t * @param args\t */\tpublic static void main(String[] args) {\t\tint count = 0;\t\twhile(true){// 在getNext方法中输出当前序列，并获取下一个数列，若全排序结束，程序结束。\t\t\tif(getNext(++count)) break;\t\t}\t}\t/**\t * \t * @param count 表示第count个序列\t * @return 全排序是否结束，结束返回true，否则返回false\t */\tpublic static boolean getNext(int count) {\t\tint i,j,n = charStr.length;\t\t\tchar tmp;\t\t\t\t// 输出字符序列\t\tSystem.out.print(count + \" : \");\t\tfor(i = 0; i < n; i++)\t\t\tSystem.out.print(charStr[i]);\t\tSystem.out.println();\t\t\t\t// 寻找当前字符比前一个字符大的字符的位置\t\tfor(i = n-1; i > 0; i--)\t\t\tif(charStr[i] > charStr[i-1]) break;\t\t\t\t// 根据位置进行重排\t\tif(i == 0){ // 位置为0，全排序结束\t\t\treturn true; \t\t}\t\telse{ // 获取下一个序列\t\t\tfor(j = n-1; j >= i; j--){// 前一个位置的数和特定数字交互\t\t\t\tif((charStr[j] - charStr[i - 1]) > 0){\t\t\t\t\t// 交互位置\t\t\t\t\ttmp = charStr[i-1];\t\t\t\t\tcharStr[i-1] = charStr[j];\t\t\t\t\tcharStr[j] = tmp;\t\t\t\t\tbreak;\t\t\t\t}\t\t\t\t}\t\t\t// 将位置以后的字符重新排序（降序变升序）\t\t\tfor(j = i; j < (i + n )/2; j++){\t\t\t\ttmp = charStr[j];\t\t\t\tcharStr[j] = charStr[i + n - 1 - j];\t\t\t\tcharStr[i + n - 1 - j] = tmp;\t\t\t}\t\t}\t\treturn false;\t}}   运行结果 1 : 129ABC 2 : 129ACB 3 : 129BAC 4 : 129BCA 5 : 129CAB 6 : 129CBA 7 : 12A9BC 8 : 12A9CB 9 : 12AB9C 10 : 12ABC9 11 : 12AC9B 12 : 12ACB9 13 : 12B9AC 14 : 12B9CA 15 : 12BA9C 16 : 12BAC9 17 : 12BC9A 18 : 12BCA9 19 : 12C9AB 20 : 12C9BA 21 : 12CA9B 22 : 12CAB9 23 : 12CB9A 24 : 12CBA9 25 : 192ABC 26 : 192ACB 27 : 192BAC 28 : 192BCA 29 : 192CAB 30 : 192CBA 31 : 19A2BC 32 : 19A2CB 33 : 19AB2C 34 : 19ABC2 35 : 19AC2B 36 : 19ACB2 37 : 19B2AC 38 : 19B2CA 39 : 19BA2C 40 : 19BAC2 41 : 19BC2A 42 : 19BCA2 43 : 19C2AB 44 : 19C2BA 45 : 19CA2B 46 : 19CAB2 47 : 19CB2A 48 : 19CBA2 49 : 1A29BC 50 : 1A29CB 51 : 1A2B9C 52 : 1A2BC9 53 : 1A2C9B 54 : 1A2CB9 55 : 1A92BC 56 : 1A92CB 57 : 1A9B2C 58 : 1A9BC2 59 : 1A9C2B 60 : 1A9CB2 61 : 1AB29C 62 : 1AB2C9 63 : 1AB92C 64 : 1AB9C2 65 : 1ABC29 66 : 1ABC92 67 : 1AC29B 68 : 1AC2B9 69 : 1AC92B 70 : 1AC9B2 71 : 1ACB29 72 : 1ACB92 73 : 1B29AC 74 : 1B29CA 75 : 1B2A9C 76 : 1B2AC9 77 : 1B2C9A 78 : 1B2CA9 79 : 1B92AC 80 : 1B92CA 81 : 1B9A2C 82 : 1B9AC2 83 : 1B9C2A 84 : 1B9CA2 85 : 1BA29C 86 : 1BA2C9 87 : 1BA92C 88 : 1BA9C2 89 : 1BAC29 90 : 1BAC92 91 : 1BC29A 92 : 1BC2A9 93 : 1BC92A 94 : 1BC9A2 95 : 1BCA29 96 : 1BCA92 97 : 1C29AB 98 : 1C29BA 99 : 1C2A9B 100 : 1C2AB9 101 : 1C2B9A 102 : 1C2BA9 103 : 1C92AB 104 : 1C92BA 105 : 1C9A2B 106 : 1C9AB2 107 : 1C9B2A 108 : 1C9BA2 109 : 1CA29B 110 : 1CA2B9 111 : 1CA92B 112 : 1CA9B2 113 : 1CAB29 114 : 1CAB92 115 : 1CB29A 116 : 1CB2A9 117 : 1CB92A 118 : 1CB9A2 119 : 1CBA29 120 : 1CBA92 121 : 219ABC 122 : 219ACB 123 : 219BAC 124 : 219BCA 125 : 219CAB 126 : 219CBA 127 : 21A9BC 128 : 21A9CB 129 : 21AB9C 130 : 21ABC9 131 : 21AC9B 132 : 21ACB9 133 : 21B9AC 134 : 21B9CA 135 : 21BA9C 136 : 21BAC9 137 : 21BC9A 138 : 21BCA9 139 : 21C9AB 140 : 21C9BA 141 : 21CA9B 142 : 21CAB9 143 : 21CB9A 144 : 21CBA9 145 : 291ABC 146 : 291ACB 147 : 291BAC 148 : 291BCA 149 : 291CAB 150 : 291CBA 151 : 29A1BC 152 : 29A1CB 153 : 29AB1C 154 : 29ABC1 155 : 29AC1B 156 : 29ACB1 157 : 29B1AC 158 : 29B1CA 159 : 29BA1C 160 : 29BAC1 161 : 29BC1A 162 : 29BCA1 163 : 29C1AB 164 : 29C1BA 165 : 29CA1B 166 : 29CAB1 167 : 29CB1A 168 : 29CBA1 169 : 2A19BC 170 : 2A19CB 171 : 2A1B9C 172 : 2A1BC9 173 : 2A1C9B 174 : 2A1CB9 175 : 2A91BC 176 : 2A91CB 177 : 2A9B1C 178 : 2A9BC1 179 : 2A9C1B 180 : 2A9CB1 181 : 2AB19C 182 : 2AB1C9 183 : 2AB91C 184 : 2AB9C1 185 : 2ABC19 186 : 2ABC91 187 : 2AC19B 188 : 2AC1B9 189 : 2AC91B 190 : 2AC9B1 191 : 2ACB19 192 : 2ACB91 193 : 2B19AC 194 : 2B19CA 195 : 2B1A9C 196 : 2B1AC9 197 : 2B1C9A 198 : 2B1CA9 199 : 2B91AC 200 : 2B91CA 201 : 2B9A1C 202 : 2B9AC1 203 : 2B9C1A 204 : 2B9CA1 205 : 2BA19C 206 : 2BA1C9 207 : 2BA91C 208 : 2BA9C1 209 : 2BAC19 210 : 2BAC91 211 : 2BC19A 212 : 2BC1A9 213 : 2BC91A 214 : 2BC9A1 215 : 2BCA19 216 : 2BCA91 217 : 2C19AB 218 : 2C19BA 219 : 2C1A9B 220 : 2C1AB9 221 : 2C1B9A 222 : 2C1BA9 223 : 2C91AB 224 : 2C91BA 225 : 2C9A1B 226 : 2C9AB1 227 : 2C9B1A 228 : 2C9BA1 229 : 2CA19B 230 : 2CA1B9 231 : 2CA91B 232 : 2CA9B1 233 : 2CAB19 234 : 2CAB91 235 : 2CB19A 236 : 2CB1A9 237 : 2CB91A 238 : 2CB9A1 239 : 2CBA19 240 : 2CBA91 241 : 912ABC 242 : 912ACB 243 : 912BAC 244 : 912BCA 245 : 912CAB 246 : 912CBA 247 : 91A2BC 248 : 91A2CB 249 : 91AB2C 250 : 91ABC2 251 : 91AC2B 252 : 91ACB2 253 : 91B2AC 254 : 91B2CA 255 : 91BA2C 256 : 91BAC2 257 : 91BC2A 258 : 91BCA2 259 : 91C2AB 260 : 91C2BA 261 : 91CA2B 262 : 91CAB2 263 : 91CB2A 264 : 91CBA2 265 : 921ABC 266 : 921ACB 267 : 921BAC 268 : 921BCA 269 : 921CAB 270 : 921CBA 271 : 92A1BC 272 : 92A1CB 273 : 92AB1C 274 : 92ABC1 275 : 92AC1B 276 : 92ACB1 277 : 92B1AC 278 : 92B1CA 279 : 92BA1C 280 : 92BAC1 281 : 92BC1A 282 : 92BCA1 283 : 92C1AB 284 : 92C1BA 285 : 92CA1B 286 : 92CAB1 287 : 92CB1A 288 : 92CBA1 289 : 9A12BC 290 : 9A12CB 291 : 9A1B2C 292 : 9A1BC2 293 : 9A1C2B 294 : 9A1CB2 295 : 9A21BC 296 : 9A21CB 297 : 9A2B1C 298 : 9A2BC1 299 : 9A2C1B 300 : 9A2CB1 301 : 9AB12C 302 : 9AB1C2 303 : 9AB21C 304 : 9AB2C1 305 : 9ABC12 306 : 9ABC21 307 : 9AC12B 308 : 9AC1B2 309 : 9AC21B 310 : 9AC2B1 311 : 9ACB12 312 : 9ACB21 313 : 9B12AC 314 : 9B12CA 315 : 9B1A2C 316 : 9B1AC2 317 : 9B1C2A 318 : 9B1CA2 319 : 9B21AC 320 : 9B21CA 321 : 9B2A1C 322 : 9B2AC1 323 : 9B2C1A 324 : 9B2CA1 325 : 9BA12C 326 : 9BA1C2 327 : 9BA21C 328 : 9BA2C1 329 : 9BAC12 330 : 9BAC21 331 : 9BC12A 332 : 9BC1A2 333 : 9BC21A 334 : 9BC2A1 335 : 9BCA12 336 : 9BCA21 337 : 9C12AB 338 : 9C12BA 339 : 9C1A2B 340 : 9C1AB2 341 : 9C1B2A 342 : 9C1BA2 343 : 9C21AB 344 : 9C21BA 345 : 9C2A1B 346 : 9C2AB1 347 : 9C2B1A 348 : 9C2BA1 349 : 9CA12B 350 : 9CA1B2 351 : 9CA21B 352 : 9CA2B1 353 : 9CAB12 354 : 9CAB21 355 : 9CB12A 356 : 9CB1A2 357 : 9CB21A 358 : 9CB2A1 359 : 9CBA12 360 : 9CBA21 361 : A129BC 362 : A129CB 363 : A12B9C 364 : A12BC9 365 : A12C9B 366 : A12CB9 367 : A192BC 368 : A192CB 369 : A19B2C 370 : A19BC2 371 : A19C2B 372 : A19CB2 373 : A1B29C 374 : A1B2C9 375 : A1B92C 376 : A1B9C2 377 : A1BC29 378 : A1BC92 379 : A1C29B 380 : A1C2B9 381 : A1C92B 382 : A1C9B2 383 : A1CB29 384 : A1CB92 385 : A219BC 386 : A219CB 387 : A21B9C 388 : A21BC9 389 : A21C9B 390 : A21CB9 391 : A291BC 392 : A291CB 393 : A29B1C 394 : A29BC1 395 : A29C1B 396 : A29CB1 397 : A2B19C 398 : A2B1C9 399 : A2B91C 400 : A2B9C1 401 : A2BC19 402 : A2BC91 403 : A2C19B 404 : A2C1B9 405 : A2C91B 406 : A2C9B1 407 : A2CB19 408 : A2CB91 409 : A912BC 410 : A912CB 411 : A91B2C 412 : A91BC2 413 : A91C2B 414 : A91CB2 415 : A921BC 416 : A921CB 417 : A92B1C 418 : A92BC1 419 : A92C1B 420 : A92CB1 421 : A9B12C 422 : A9B1C2 423 : A9B21C 424 : A9B2C1 425 : A9BC12 426 : A9BC21 427 : A9C12B 428 : A9C1B2 429 : A9C21B 430 : A9C2B1 431 : A9CB12 432 : A9CB21 433 : AB129C 434 : AB12C9 435 : AB192C 436 : AB19C2 437 : AB1C29 438 : AB1C92 439 : AB219C 440 : AB21C9 441 : AB291C 442 : AB29C1 443 : AB2C19 444 : AB2C91 445 : AB912C 446 : AB91C2 447 : AB921C 448 : AB92C1 449 : AB9C12 450 : AB9C21 451 : ABC129 452 : ABC192 453 : ABC219 454 : ABC291 455 : ABC912 456 : ABC921 457 : AC129B 458 : AC12B9 459 : AC192B 460 : AC19B2 461 : AC1B29 462 : AC1B92 463 : AC219B 464 : AC21B9 465 : AC291B 466 : AC29B1 467 : AC2B19 468 : AC2B91 469 : AC912B 470 : AC91B2 471 : AC921B 472 : AC92B1 473 : AC9B12 474 : AC9B21 475 : ACB129 476 : ACB192 477 : ACB219 478 : ACB291 479 : ACB912 480 : ACB921 481 : B129AC 482 : B129CA 483 : B12A9C 484 : B12AC9 485 : B12C9A 486 : B12CA9 487 : B192AC 488 : B192CA 489 : B19A2C 490 : B19AC2 491 : B19C2A 492 : B19CA2 493 : B1A29C 494 : B1A2C9 495 : B1A92C 496 : B1A9C2 497 : B1AC29 498 : B1AC92 499 : B1C29A 500 : B1C2A9 501 : B1C92A 502 : B1C9A2 503 : B1CA29 504 : B1CA92 505 : B219AC 506 : B219CA 507 : B21A9C 508 : B21AC9 509 : B21C9A 510 : B21CA9 511 : B291AC 512 : B291CA 513 : B29A1C 514 : B29AC1 515 : B29C1A 516 : B29CA1 517 : B2A19C 518 : B2A1C9 519 : B2A91C 520 : B2A9C1 521 : B2AC19 522 : B2AC91 523 : B2C19A 524 : B2C1A9 525 : B2C91A 526 : B2C9A1 527 : B2CA19 528 : B2CA91 529 : B912AC 530 : B912CA 531 : B91A2C 532 : B91AC2 533 : B91C2A 534 : B91CA2 535 : B921AC 536 : B921CA 537 : B92A1C 538 : B92AC1 539 : B92C1A 540 : B92CA1 541 : B9A12C 542 : B9A1C2 543 : B9A21C 544 : B9A2C1 545 : B9AC12 546 : B9AC21 547 : B9C12A 548 : B9C1A2 549 : B9C21A 550 : B9C2A1 551 : B9CA12 552 : B9CA21 553 : BA129C 554 : BA12C9 555 : BA192C 556 : BA19C2 557 : BA1C29 558 : BA1C92 559 : BA219C 560 : BA21C9 561 : BA291C 562 : BA29C1 563 : BA2C19 564 : BA2C91 565 : BA912C 566 : BA91C2 567 : BA921C 568 : BA92C1 569 : BA9C12 570 : BA9C21 571 : BAC129 572 : BAC192 573 : BAC219 574 : BAC291 575 : BAC912 576 : BAC921 577 : BC129A 578 : BC12A9 579 : BC192A 580 : BC19A2 581 : BC1A29 582 : BC1A92 583 : BC219A 584 : BC21A9 585 : BC291A 586 : BC29A1 587 : BC2A19 588 : BC2A91 589 : BC912A 590 : BC91A2 591 : BC921A 592 : BC92A1 593 : BC9A12 594 : BC9A21 595 : BCA129 596 : BCA192 597 : BCA219 598 : BCA291 599 : BCA912 600 : BCA921 601 : C129AB 602 : C129BA 603 : C12A9B 604 : C12AB9 605 : C12B9A 606 : C12BA9 607 : C192AB 608 : C192BA 609 : C19A2B 610 : C19AB2 611 : C19B2A 612 : C19BA2 613 : C1A29B 614 : C1A2B9 615 : C1A92B 616 : C1A9B2 617 : C1AB29 618 : C1AB92 619 : C1B29A 620 : C1B2A9 621 : C1B92A 622 : C1B9A2 623 : C1BA29 624 : C1BA92 625 : C219AB 626 : C219BA 627 : C21A9B 628 : C21AB9 629 : C21B9A 630 : C21BA9 631 : C291AB 632 : C291BA 633 : C29A1B 634 : C29AB1 635 : C29B1A 636 : C29BA1 637 : C2A19B 638 : C2A1B9 639 : C2A91B 640 : C2A9B1 641 : C2AB19 642 : C2AB91 643 : C2B19A 644 : C2B1A9 645 : C2B91A 646 : C2B9A1 647 : C2BA19 648 : C2BA91 649 : C912AB 650 : C912BA 651 : C91A2B 652 : C91AB2 653 : C91B2A 654 : C91BA2 655 : C921AB 656 : C921BA 657 : C92A1B 658 : C92AB1 659 : C92B1A 660 : C92BA1 661 : C9A12B 662 : C9A1B2 663 : C9A21B 664 : C9A2B1 665 : C9AB12 666 : C9AB21 667 : C9B12A 668 : C9B1A2 669 : C9B21A 670 : C9B2A1 671 : C9BA12 672 : C9BA21 673 : CA129B 674 : CA12B9 675 : CA192B 676 : CA19B2 677 : CA1B29 678 : CA1B92 679 : CA219B 680 : CA21B9 681 : CA291B 682 : CA29B1 683 : CA2B19 684 : CA2B91 685 : CA912B 686 : CA91B2 687 : CA921B 688 : CA92B1 689 : CA9B12 690 : CA9B21 691 : CAB129 692 : CAB192 693 : CAB219 694 : CAB291 695 : CAB912 696 : CAB921 697 : CB129A 698 : CB12A9 699 : CB192A 700 : CB19A2 701 : CB1A29 702 : CB1A92 703 : CB219A 704 : CB21A9 705 : CB291A 706 : CB29A1 707 : CB2A19 708 : CB2A91 709 : CB912A 710 : CB91A2 711 : CB921A 712 : CB92A1 713 : CB9A12 714 : CB9A21 715 : CBA129 716 : CBA192 717 : CBA219 718 : CBA291 719 : CBA912 720 : CBA921  ","title":"【Java算法】快速全排序算法"},{"content":"      Log4J有三个主要部件，它们是记录器（Loggers）、输出源（Appenders）和布局（Logouts）。            简介         Logger按照布局中指定的格式把日志信息写入一个或多个输出源，Log4j 允许开发人员定义多个Logger，每个Logger拥有自己的名字，Logger之间通过名字来表明隶属关系。例如，名称为“com.foo”的logger是名称为“com.foo.Far”的父类，同样，名称为“java”的logger是名称为“java.util”和名称为“java.util.Vector”等等logger的父类。         Appendr可以是控制台、文本文件、XML文件或Socket，甚至还可以把信息写入到Windows事件日志或通过电子邮件发送，这都需要相应的类来处理，这些相关的类是ConsoleAppender、FileAppender、SocketAppender、NtEventLogAppender和JMSAppender。一个Logger可以拥有多个Appender ，即可以将种信息输出到多个位置。         Layout的作用是控制Log信息的输出方式，也就是格式化输出的信息。        语法与格式         设置root，其格式为 log4j.rootLogger=[level],appenderName, ...，其中level就是设置需要输出信息的级别，后面是appenderName的输出的目的地。         Appender，语法：      log4j.appender.appenderName = fully.qualified.name.of.appender.class      log4j.appender.appenderName.option1 = value1       ...       log4j.appender.appenderName.option = valueN        Appender，种类：      org.apache.log4j.ConsoleAppender（控制台）      org.apache.log4j.FileAppender（文件）      org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）      org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生新文件）      org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）        Layout，语法：        log4j.appender.appenderName.layout = fully.qualified.name.of.layout.class      log4j.appender.appenderName.layout.option1 = value1      ....      log4j.appender.appenderName.layout.option = valueN            Layout，种类：        org.apache.log4j.HTMLLayout（以HTML表格形式布局），      org.apache.log4j.PatternLayout（可以灵活地指定布局模式），      org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），      org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）       输出格式：        %m 输出代码中指定的消息 　　%p: 输出日志信息优先级，即DEBUG，INFO，WARN，ERROR，FATAL,         %d: 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921         %r: 输出自应用启动到输出该log信息耗费的毫秒数         %c: 输出日志信息所属的类目，通常就是所在类的全名         %t: 输出产生该日志事件的线程名         %l: 输出日志事件的发生位置，相当于%C.%M(%F:%L)的组合,包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10)         %x: 输出和当前线程相关联的NDC(嵌套诊断环境),尤其用到像java servlets这样的多客户多线程的应用中。         %%: 输出一个”%”字符         %F: 输出日志消息产生时所在的文件名称         %L: 输出代码中的行号         %m: 输出代码中指定的消息,产生的日志具体信息         %n: 输出一个回车换行符，Windows平台为”\\r\\n”，Unix平台为”\\n”输出日志信息换行         可以在%与模式字符之间加上修饰符来控制其最小宽度、最大宽度、和文本的对齐方式。如：                1)%20c：指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，默认的情况下右对齐。                2)%-20c:指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，”-”号指定左对齐。                3)%.30c:指定输出category的名称，最大的宽度是30，如果category的名称大于30的话，就会将左边多出的字符截掉，但小于30的话也不会有空格。                4)%20.30c:如果category的名称小于20就补空格，并且右对齐，如果其名称长于30字符，就从左边交远销出的字符截掉。         关系          下图展现了root Logger、子Logger和Appender的关系。 在《http://blog.csdn.net/dongzi87/article/details/8292865》中记录了详细用法。   以下摘抄一份较全配置信息： log4j.rootLogger=DEBUG,CONSOLE,A1,im log4j.addivity.org.apache=true # 应用于控制台 log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender log4j.appender.Threshold=DEBUG log4j.appender.CONSOLE.Target=System.out log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout log4j.appender.CONSOLE.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n #log4j.appender.CONSOLE.layout.ConversionPattern=[start]%d{DATE}[DATE]%n%p[PRIORITY]%n%x[NDC]%n%t[thread] n%c[CATEGORY]%n%m[MESSAGE]%n%n #应用于文件 log4j.appender.FILE=org.apache.log4j.FileAppender log4j.appender.FILE.File=file.log log4j.appender.FILE.Append=false log4j.appender.FILE.layout=org.apache.log4j.PatternLayout log4j.appender.FILE.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n # Use this layout for LogFactor 5 analysis # 应用于文件回滚 log4j.appender.ROLLING_FILE=org.apache.log4j.RollingFileAppender log4j.appender.ROLLING_FILE.Threshold=ERROR log4j.appender.ROLLING_FILE.File=rolling.log //文件位置,也可以用变量${java.home}、rolling.log log4j.appender.ROLLING_FILE.Append=true //true:添加 false:覆盖 log4j.appender.ROLLING_FILE.MaxFileSize=10KB //文件最大尺寸 log4j.appender.ROLLING_FILE.MaxBackupIndex=1 //备份数 log4j.appender.ROLLING_FILE.layout=org.apache.log4j.PatternLayout log4j.appender.ROLLING_FILE.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n   #应用于socket log4j.appender.SOCKET=org.apache.log4j.RollingFileAppender log4j.appender.SOCKET.RemoteHost=localhost log4j.appender.SOCKET.Port=5001 log4j.appender.SOCKET.LocationInfo=true # Set up for Log Facter 5 log4j.appender.SOCKET.layout=org.apache.log4j.PatternLayout log4j.appender.SOCET.layout.ConversionPattern=[start]%d{DATE}[DATE]%n%p[PRIORITY]%n%x[NDC]%n%t[thread]%n%c[CATEGORY]%n%m[MESSAGE]%n%n   # Log Factor 5 Appender log4j.appender.LF5_APPENDER=org.apache.log4j.lf5.LF5Appender log4j.appender.LF5_APPENDER.MaxNumberOfRecords=2000 # 发送日志给邮件 log4j.appender.MAIL=org.apache.log4j.net.SMTPAppender log4j.appender.MAIL.Threshold=FATAL log4j.appender.MAIL.BufferSize=10 log4j.appender.MAIL.From=web@www.wuset.com log4j.appender.MAIL.SMTPHost=www.wusetu.com log4j.appender.MAIL.Subject=Log4J Message log4j.appender.MAIL.To=web@www.wusetu.com log4j.appender.MAIL.layout=org.apache.log4j.PatternLayout log4j.appender.MAIL.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n # 用于数据库 log4j.appender.DATABASE=org.apache.log4j.jdbc.JDBCAppender log4j.appender.DATABASE.URL=jdbc:mysql://localhost:3306/test log4j.appender.DATABASE.driver=com.mysql.jdbc.Driver log4j.appender.DATABASE.user=root log4j.appender.DATABASE.password= log4j.appender.DATABASE.sql=INSERT INTO LOG4J (Message) VALUES (’[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n’) log4j.appender.DATABASE.layout=org.apache.log4j.PatternLayout log4j.appender.DATABASE.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n   log4j.appender.A1=org.apache.log4j.DailyRollingFileAppender log4j.appender.A1.File=SampleMessages.log4j log4j.appender.A1.DatePattern=yyyyMMdd-HH’.log4j’ log4j.appender.A1.layout=org.apache.log4j.xml.XMLLayout #自定义Appender log4j.appender.im = net.cybercorlin.util.logger.appender.IMAppender log4j.appender.im.host = mail.cybercorlin.net log4j.appender.im.username = username log4j.appender.im.password = password log4j.appender.im.recipient = corlin@cybercorlin.net log4j.appender.im.layout=org.apache.log4j.PatternLayout log4j.appender.im.layout.ConversionPattern =[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n  ","title":"Log4j知识简单整理"},{"content":"【 声明：版权所有，欢迎转载，请勿用于商业用途。  联系信箱：feixiaoxing @163.com】       sqlite之前一直听说过，但是没有怎么使用过。今天从sqlite的官方网站上下载了源码，也就是ww.sqlite.org上面的源代码，简单编译了一下。居然非常好用 。步骤十分简单，可以供大家参考一下。这里只是作为学习数据库使用的，不是作为dll库或者lib库链接到自己的代码中使用的，所以简单生成执行文件即可。     （1）首先到这里下载sqlite的最新代码，即http://www.sqlite.org/download.html这里Source code处的第一个地址下载即可；     （2）文件下载到本地后解压，我们发现其实就是4个文件，即shell.c，sqlite3.c，sqlite3.h，sqlite3ext.h；     （3）本地创建一个vc的console工程，将四个文件加入到工程里面；     （4）直接F7输入，编译器会编译、链接生成一个版本；     （5）在Debug目录下，一个sqlite3的执行文件就做好了。     为了实验一下我们的sqlite是否好用，我们立即启动执行文件，如果还是留在编译器下，直接按下F5就可以，屏幕上会出现这样的打印sqlite>，这时候我们就可以输入内容了，比如说随便创建一张表，       create table tbl1 (one varchar(10), two smallint);     insert into tbl1 values('hello', 10);     insert into tbl1 values('china', 20);     select * from tbl1;     有了上面的操作之后，我们就可以顺利创建一张表，同时在表中插入自己的数据，同时输出打印这些数据是不是非常方便。至于后面的内容，大家可以根据网上的教程，不断地学习和完善。","title":"sqlite的编译、练习"},{"content":"在一些场合无需引入log4j等第三方日志库，例如编写FileNet component时可能只需要简单的日志记录，同时又不能使用配置文件，则直接利用JDK提供的Logger即可。使用它首先根据自己的需要编写一个输出信息格式化类，在使用Logger时先设置log记录位置，设置log文件增长命名方式，设置logger处理级别，设置格式化类等等即可进行使用，具体方式如下代码所示。   import java.io.IOException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.logging.FileHandler;import java.util.logging.Formatter;import java.util.logging.Level;import java.util.logging.LogRecord;import java.util.logging.Logger;public class LoggerTest {\t\tprivate static final Logger logger =  Logger.getLogger(LoggerTest.class.toString());\tpublic static void main(String[] args) {\t\t //设置logger信息\t\tFileHandler fileHandler;\t\ttry {\t\t\tfileHandler = new FileHandler(\"c:/dataMigration%g.log\", 256000,1000000, true);\t\t\tfileHandler.setLevel(Level.ALL);\t\t\tfileHandler.setFormatter(new MyLogHander());\t\t\tlogger.addHandler(fileHandler);\t\t\tlogger.setLevel(Level.ALL);\t\t} catch (SecurityException e) {\t\t\te.printStackTrace();\t\t} catch (IOException e) {\t\t\te.printStackTrace();\t\t}\t\t\t\tlogger.info(\"test logger info\");\t\t\t}}class MyLogHander extends Formatter {\t@Override\tpublic String format(LogRecord record) {\t\tDate date = new Date();\t\tSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss,SSS\");\t\t\t\treturn sdf.format(date) + \"  \" +  record.getLevel() + \":    \" + record.getMessage() + \"\\r\\n\";\t}}  ","title":"JDK Logger使用举例"},{"content":"        VB.NET是在VB的基础上升级的版本，增强了面向对象的支持，VB.NET是在.NET Framework上的面向对象的中间解释性语言，VB是基于对象的面向过程的开发语言，而VB.NET是完全面向对象的开发语言，这几天看视频的过程当中，看的过程中明白，看完就记不起来了，有些不适应的缘故，多多少少感觉到VB.NET的好不是不少啊，这个体验好处的过程还需慢慢的深入的理解与体会。        VB.NET视频看完了，把自己学习的视频都来回的看了看、查资料、图书馆借书（看完视频后最大的欲望就是图书馆借书看看，由于很多东西不太熟悉，渴望明白！）、总结.       首先查了设计的相关概念VB.NET、VB、.NET、.NET Framework、ADO、ADO.NET、DataSet、Recordset、DataReader等相关知识，这些当初只是了解一点点，不是很明白，后来查询完资料后心里多少有点底了，下面和我一起来共同学习这些基本概念及其它们之间的关系       .NET Framework是一种开发的框架简称.NET框架，是基类库(BCL)和公共语言开发运行环境（CLR）组成的软件开发平台，应用程序在.NET Framework上运行，使用vb在.NET Framework上编程，这就是VB.NET. 下面是自己通过总结，颗粒归仓的方法来加深对知识的理解，总结后感觉好多了，不再那么乱了，明白了很多、也有条理多了。 单元一 .NET执行模型       主要是对VB.NET的整体的宏观介绍，自己整理后，心里有数啦   单元二  物件导向          主要是介绍物件导向，“物件导向”是台湾的一种说法，其实际相当于普通话“面向对象”。 单元三 使用类别与基底类别库         主要讲述了使用类别与基底类别库，介绍了类别设计、命名空间（C++、C#、设计模式都学习过）产生很强烈的共鸣，听的还是比较舒服的，接收没什么大问题。 单元四  新一代的Windows       主要是新一代windows的产生，与现有的知识做对比，发现很多很强大的地方，主要是VB.NET与VB6的对比，发现.NET的很多优点，很是强大，代码实现起来也很方便，毕竟是面向对象啊，考虑的周全，这样通过知识间的对比学习使我们的学习效率大大提高，我们就是靠这样一步一步的成长起来的，加油。 单元五 防护式程序设计       主要是在.NET的环境下我们更准确的、高效的来保证软件开发，我们引入了错误处理机制（例外处理和事件追踪），大大的提高了我们开发代码的效率。错误处理机制与vb6中的On Error goto ……来说，好多了，更加的安全、准确。 单元六 资料库设计与SQL  这部分知识也是很好理解的地方，由于原来学习数据库（SQL），很多概念自己都是很熟悉的，但是缺少的实践，毕竟实践才能出真理，相信在后期的实践中深深的理解与体会。   单元七 ADO.NET 主要是讲述了ADO.NET作为一个接口，来对各种数据库来存取、增删改查。   总结          对于一到七这几个部分，因为有以前的基础（C++、C#、SQL、设计模式），理解起来并不困难。主要的不断深入的过程，有些概念只是大概知道是个什么东东，随着学习的深入，这些方面还要注意，加深对概念的理解。         画思维导图是自己原本很乱的思路都理的差不多了，心里也舒服多了，学习到每个阶段最重要的就是总结保证颗粒归仓。","title":"[置顶] VB.NET总结一"},{"content":"实验三 图型结构及其应用 实验项目: 图的存储结构的建立与遍历（搜索） 图的遍历（搜索）算法是图型结构算法的基础，本实验要求编写程序演示图的存储结构的建立和遍历（搜索）过程。 实验要求： (1)能够建立（有向和无向）图的邻接矩阵和邻接表存储结构 (2)能够在邻接矩阵和邻接表存储结构上对（有向和无向）图进行深度优先（递归和非递归都要求）和广度优先搜索 (3)能够存储和显示相应的搜索结果（深度优先或广度优先生成森林（或生成树）、深度优先或广度优先序列和编号） (4)以文件形式输入图的顶点和边，并显示相应的结果。要求顶点不少于10个，边不少于13个 ⑤ 软件功能结构安排合理，界面友好，便于使用 实验备注： 一、上传内容： 1. 实验报告 2. 实验程序源代码；打包为 rar 文件，提交到此处。 二、实验报告格式：见附件“实验报告格式 .doc” 截止时间: 2012年12月31日 星期一 23:55 #include <iostream>#include <cstdio>#define maxlen 100using namespace std;bool visited[maxlen];struct Link{    int v;//v为节点编号    Link * next;};struct node{    char element;    struct Link* firstedge;};//头结点struct Adgraph{    int n,e;    node Ad[maxlen];};//邻接表struct matrix_graph{    int n,e;    int mat[maxlen][maxlen];    char element[maxlen];};void cre1(matrix_graph  &G)//无向图邻接矩阵{    int i,j,x,y;    cin >> G.n >> G.e;    for(i=0; i<G.n; i++)  cin >> G.element[i];    for(i=0; i<G.n; i++)        for(j=0; j<G.n; j++)            G.mat[i][j]=0;    for(i=0; i<G.e; i++)    {        cin >> x >> y;        G.mat[x][y]=1;        G.mat[y][x]=1;    }    for(i=0; i<G.n; i++)    {        for(j=0; j<G.n; j++)            cout << G.mat[i][j] << \" \";        cout << endl;    }}void DFS1(matrix_graph *G,int i)//邻接矩阵深度优先（递归）{    int j;    cout << G->element[i]<< \" \";    visited[i]=true;    for(j=0; j<G->n; j++)if(G->mat[i][j]==1&&!visited[j])  DFS1(G,j);}void DFS1_nonrec(matrix_graph *G,int v)//邻接矩阵深度优先（非递归）{    int STACK[maxlen];    int top=maxlen;    STACK[--top]=v;//第一个压栈    while(top!=maxlen)    {        int w=STACK[top++];        if(!visited[w])        {            cout <<  G->element[w] <<  \" \";            visited[w]=true;        }//取栈顶判断        for(int i=0; i<G->n; i++)if(!visited[i]&&G->mat[w][i])                STACK[--top]=i;//遇到一个没有访问的，压栈,向下搜索    }}void BFS1(matrix_graph *G,int v)//邻接矩阵的广度优先{    int Queue[maxlen],front=0,rear=0,w;    visited[v]=true;    Queue[rear++]=v;    cout << G->element[v] << \" \";    while(front!=rear)    {        v=Queue[front++];        for(w=0; w<G->n; w++)        {            if(!visited[w]&&G->mat[v][w])            {                cout <<G->element[w] << \" \";                visited[w]=true;                Queue[rear++]=w;            }        }    }}void cre2(Adgraph* G){    int k,i,j;    cin >> G->n >> G->e;    for (k=0; k<G->n; k++)    {        cin >> G->Ad[k].element;        G->Ad[k].firstedge=NULL;    }//头结点的初始化    for(k=0; k<G->e; k++)    {        cin >> j >> i;        Link* p=new Link;        p->v=i;        p->next=G->Ad[j].firstedge;        G->Ad[j].firstedge=p;//在表头插入        p=new Link;//建立无向图，所以还要反过来链接        p->v=j;        p->next=G->Ad[i].firstedge;        G->Ad[i].firstedge=p;    }    for(i=0; i<G->n; i++)    {        cout << G->Ad[i].element;        Link *m=G->Ad[i].firstedge;        while(m!=NULL)        {            printf(\"->%c\",G->Ad[m->v].element);            m=m->next;        }        printf(\"->NULL\\n\");    }}void DFS2(Adgraph* G,int v){    Link *p;    cout << G->Ad[v].element << \" \";    visited[v]=true;    p=G->Ad[v].firstedge;    while(p!=NULL)    {        if(!visited[p->v]) DFS2(G,p->v);        p=p->next;    }}void DFS2_nonrec(Adgraph* G,int v){    int STACK[maxlen],top=maxlen;    Link *p=NULL;    STACK[--top]=v;//第一个压栈    while(top!=maxlen)    {        int w=STACK[top++];        if(!visited[w])        {            cout <<  G->Ad[w].element << \" \";            visited[w]=true;        }        for(p=G->Ad[w].firstedge; p!=NULL; p=p->next)            if(!visited[p->v])                STACK[--top]=p->v;//遇到一个没有访问的，压栈,向下搜索    }}void BFS2(Adgraph* G,int v){    int Queue[maxlen],front=0,rear=0;    struct Link *p=NULL;    visited[v]=true;    Queue[rear++]=v;    cout << G->Ad[v].element << \" \";    while(front!=rear)    {        v=Queue[front++];        p=G->Ad[v].firstedge;        while(p!=NULL&&!visited[p->v])        {            cout <<G->Ad[p->v].element << \" \";            visited[p->v]=true;            Queue[rear++]=p->v;            p=p->next;        }    }}int main(){    struct Adgraph G2;    int i,N;    struct matrix_graph G1;    printf(\"1----邻接矩阵(无向图)\\n2----邻接表（无向图）\\n\");    cin >> N;    switch(N)    {    case 0:        return 0;    case 1:        freopen(\"lab3.txt\", \"r\", stdin);        cre1(G1);//建立邻接矩阵        printf(\"DFS:\");        for(i=0; i<G1.n; i++) visited[i]=false;        for(i=0; i<G1.n; i++)if(!visited[i]) DFS1(&G1,i);//递归深先        printf(\"\\nDFS_NONREC:\");        for(i=0; i<G1.n; i++) visited[i]=false;        for(i=0; i<G1.n; i++)if(!visited[i])DFS1_nonrec(&G1,i);//非递归深先        printf(\"\\nBFS:\");        for(i=0; i<G1.n; i++) visited[i]=false;        for(i=0; i<G1.n; i++)if(!visited[i])BFS1(&G1,i);        fclose(stdin);        break;    case 2:        freopen(\"lab3.txt\", \"r\", stdin);        cre2(&G2);        printf(\"DFS:\");        for(i=0; i<G2.n; i++) visited[i]=false;        for(i=0; i<G2.n; i++)if(!visited[i]) DFS2(&G2,i);//递归深先        printf(\"\\nDFS_NONREC:\");        for(i=0; i<G2.n; i++) visited[i]=false;        for(i=0; i<G2.n; i++)if(!visited[i]) DFS2_nonrec(&G2,i);        printf(\"\\nBFS:\");        for(i=0; i<G2.n; i++) visited[i]=false;        for(i=0; i<G2.n; i++)if(!visited[i]) BFS2(&G2,i);        fclose(stdin);        break;    default: break;    }    return 0;}","title":"实验三 图型结构及其应用"},{"content":"大家好，我是小雨，今天给大家讲的主要内容是： 1，ADO.NET基础  2，连接模式数据库访问  3，断开模式数据库访问 ============================= 首先我们来看看第一个内容，ADO.NET基础   ADO.NET模型 ADO.NET的组件  ADO.NET的数据访问模式    我们先来看两幅图     数据集DataSet位于System.Data命名空间下，用于在内存中暂存数据，可以把它看成是内存中的小型数据库。DataSet包含一个或多个数据表（DataTable），表数据可来自数据库、文件或XML数据。  DataSet一旦读取到数据库中的数据后，就在内存中建立数据库的副本，在此之后的所有操作都是在内存中的DataSet中完成，直到执行更新命令为止。   在ADO.NET中，连接数据源有4种数据提供程序。如果要在应用程序中使用任何一种数据提供程序，必须在后台代码中引用对应的命名空间，类的名称也随之变化。    下面我们再说说第二个问题，连接模式数据库访问 1，使用SqlConnection对象连接数据库  2，使用SqlCommand对象执行数据库命令  3，使用SqlDataReader读取数据  4，为SqlCommand传递参数  5，使用SqlCommand执行存储过程 6，使用事务处理   ==============================   连接模式访问数据库的开发流程有以下几个步骤： 创建SqlConnection对象与数据库建立连接； 创建SqlCommand对象对数据库执行SQL命令或存储过程，包括增、删、改及查询数据库等命令； 如果查询数据库的数据，则创建SqlDataReader对象读取SqlCommand命令查询到的结果集，并将查到的结果集绑定到控件上。     使用SqlConnection对象连接数据库 操作数据库的第一步是建立与数据库的连接，因此首先要创建SqlConnection对象。要创建SqlConnection对象必须先了解SqlConnection对象的常用属性和方法。   更多计算机学习资料详情访问：http://itbook.taobao.com/  这是本人的淘宝店铺，欢迎大家前来购书。   ConnectionString属性通常包含以下参数，各参数间用“;”分隔。 Provider：用于设置数据源的OLE DB驱动程序。如：Access为“Microsoft.Jet.OLEDB.4.0”；SQL Server 6.5或之前版本为“SQLOLEDB”。 Data Source：设置数据源的实际路径。 Password：设置登录数据库所使用的密码。 User ID：设置登录数据库时所使用的帐号。 例如，连接Access数据库的的连接参数为： Provider=Microsoft.Jet.OLEDB.4.0;Data Source=D:\\\\abc.mdb 对于SQL7.0或更高版本的SQL数据库，ConnectionString属性包含的主要参数有：   Data Source或Server：设置需连接的数据库服务器名称。 Initial Catalog或Database：设置连接的数据库名称。 AttachDBFilename：数据库的路径和文件名。 User ID 或 uid：登录SQL Server数据库的账户。 Password 或 pwd：登录SQL Server数据库的密码。 Integrated Security：是否使用Windows集成身份验证，值有三种：true、false和SSPI，true和SSPI表示使用Windows集成身份验证。 Connection Timeout：设置SqlConnection对象连接SQL数据库服务器的超时时间，单位为秒，若在所设置的时间内无法连接数据库，则返回失败信息。默认为15秒。   连接数据库时，有两种验证模式： 混合验证模式 Windows集成验证模式 使用混合验证模式的连接参数为： Data Source =localhost; Initial Catalog=northwind; User Id=sa;pwd=123 其中，Data Source =localhost表示连接本机SQL数据库的默认服务器。 使用Windows集成验证模式的连接参数为：  Data Source =localhost; Initial Catalog=northwind; Integrated Security=true 混合验证模式必须在连接字符串中以明文形式保存用户名和密码，因此安全性较差。Windows集成验证模式不发送用户名和密码；仅发送用户通过身份验证的信息。从安全角度考虑，建议使用Windows集成验证模式。   例如：Data Source=.\\SQLEXPRESS; AttachDbFilename=|DataDirectory|\\Student.mdf; Integrated Security=True;User Instance=True 其中，Data Source=.\\SQLEXPRESS表示SQL Server2005的SQLEXPRESS数据库服务器，AttachDbFilename表示数据库的路径和文件名，|DataDirectory|表示网站默认数据库路径App_Data。   SqlConnection对象的常用方法       在创建数据库连接对象时，需要指定连接字符串。通常有以下2种方法获取连接字符串： 创建连接对象，并在应用程序的中硬编码连接字符串。 SqlConnection  对象名称 =  new SqlConnection(\"连接字符串\"); 或 SqlConnection  对象名称  =  new SqlConnection( ); 对象名称. ConnectionString=\"连接字符串\"; 把连接字符串放在应用程序的web.config文件中，再引用web.config文件。 在web.config配置文件的<configuration>节中添加如下的代码。   <connectionStrings>    <add name=\"StudentCnnString\"     connectionString=\"Data Source=.\\SQLEXPRESS;    AttachDbFilename=|DataDirectory|\\Student.mdf;    Integrated Security=True; User Instance=True\"    providerName=\"System.Data.SqlClient\" /> <\/connectionStrings>   web.config文件中有了连接字符串后，就可以从web.config中读取连接字符串。 需要使用System.Configuration.ConfigurationManager类读取连接字符串。代码如下： string strCnn= ConfigurationManager.ConnectionStrings [\"StudentCnnString\"].ConnectionString; //读取连接字符串 SqlConnection cnn = new SqlConnection(strCnn); //定义连接对象 为了使上述代码正常工作，必须使用 using System.Configuration语句引入命名空间。 创建好SqlConnection连接对象后，并没有与数据库建立连接，要建立数据库连接，还必须使用cnn.Open()方法打开数据连接，然后才可以对数据库进行各种操作。操作完数据库后，一定要使用cnn.Close()方法关闭连接。 使用SqlCommand对象执行数据库命令 成功连接数据库后，接着就可以使用SqlCommand对象对数据库进行各种操作，如读取、写入、修改和删除等操作   建立SqlCommand对象的方法有4种： SqlCommand 对象名 = new SqlCommand(); SqlCommand 对象名 = new SqlCommand(\"SQL命令\"); SqlCommand 对象名= new SqlCommand(\"SQL命令\" , 连接对象); SqlCommand 对象名= new SqlCommand(\"SQL命令\" , 连接对象 , 事务对象);   SqlCommand对象的常用方法   1.ExecuteNonQuery方法 ExecuteNonQuery方法只能执行Insert、Update和Delete命令，因此可以增加、修改和删除数据库中的数据。增加、修改和删除数据库中的数据的步骤相同，具体描述如下： 创建SqlConnection对象，设置连接字符串； 创建SqlCommand对象，设置它的Connection和CommandText属性，分别表示数据库连接和需要执行的SQL命令。 打开与数据库连接； 使用SqlCommand对象的ExecuteNonQuery方法执行CommandText中的命令；并根据返回值判断是否对数据库操作成功。 关闭与数据库连接； 2. ExecuteScalar方法 ExecuteScalar方法一般用来执行查询单值的Select命令，它以object类型返回结果表第一行第一列的值。对数据库操作时，具体步骤如下： 创建SqlConnection对象，设置连接字符串； 创建SqlCommand对象，设置它的Connection和CommandText属性； 打开与数据库连接； 使用SqlCommand对象的ExecuteScalar方法执行CommandText中的命令；并返回结果表第一行第一列的值供应用程序使用。 关闭与数据库连接；   使用SqlDataReader读取数据 SqlDataReader对象是一个向前只读的记录指针，用于快速读取数据。对于只需要顺序显示数据表中记录的应用而言，SqlDataReader对象是比较理想的选择。 在读取数据时，它需要与数据源保持实时连接，以循环的方式读取结果集中的数据。这个对象不能直接实例化，而必须调用SqlCommand对象的ExecuteReader方法才能创建有效的SqlDataReader对象。SqlDataReader对象一旦创建，即可通过对象的属性、方法访问数据源中的数据。 SqlDataReader对象的常用属性： FieldCount：获取由SqlDataReader得到的一行数据中的字段数。 isClosed：获取SqlDataReader对象的状态。true表示关闭，false表示打开。 HasRows：表示SqlDataReader是否包含数据。   SqlDataReader对象的常用方法： Close()方法：不带参数，无返回值，用来关闭SqlDataReader对象。 Read()方法：让记录指针指向本结果集中的下一条记录，返回值是true或false。 NextResult()方法：当返回多个结果集时，使用该方法让记录指针指向下一个结果集。当调用该方法获得下一个结果集后，依然要用Read方法来遍历访问该结果集。 GetValue(int i)方法：根据传入的列的索引值，返回当前记录行里指定列的值。由于事先无法预知返回列的数据类型，所以该方法使用Object类型来接收返回数据。 GetValues (Object[] values)方法：该方法会把当前记录行里所有的数据保存到一个数组里。可以使用FieldCount属性来获知记录里字段的总数，据此定义接收返回值的数组长度。 GetDataTypeName(int i)方法：通过输入列索引，获得该列的类型。 GetName(int i)方法：通过输入列索引，获得该列的名称。综合使用GetName和GetValue两方法，可以获得数据表里列名和列的字段。 IsDBNull(int i)方法：判断指定索引号的列的值是否为空，返回True或False。 使用SqlDataReader对象查询数据库的一般步骤： 创建SqlConnection对象，设置连接字符串； 创建SqlCommand对象，设置它的Connection和CommandText属性，分别表示数据库连接和需要执行的SQL命令。 打开与数据库连接； 使用SqlCommand对象的ExecuteReader方法执行CommandText中的命令；并把返回的结果放在SqlDataReader对象中。 通过循环，处理数据库查询结果。 关闭与数据库连接； 使用SqlDataReader对象时，应注意以下几点： 读取数据时，SqlConnection对象必须处于打开状态。 必须通过SqlCommand对象的ExecuteReader()方法，产生SqlDataReader对象的实例。 只能按向下的顺序逐条读取记录，不能随机读取。且无法直接获知读取记录的总数。 SqlDataReader对象管理的查询结果是只读的，不能修改。 在Visual Studio 的Web应用程序中，提供了大量列表绑定控件，如DropDownList、ListBox和GridView控件等，可以直接将SqlDataReader对象绑定到这些控件来显示查询结果。与控件绑定时，主要设置控件的以下属性和方法： DataSource属性：设置控件的数据源，可以是SqlDataReader对象，也可以是DataSet对象。 DataMember属性：当数据源为DataSet对象时，设置控件要显示的数据表名。 DataTextField属性：对于绑定DropDownList、ListBox等控件时，设置显示数据的字段名称。 DataValueField属性：对于绑定DropDownList、ListBox等控件时，设置隐藏值的字段名称。 DataBind方法：设置完控件的绑定属性后，调用该方法将数据绑定到控件上。   使用SqlCommand执行存储过程   存储过程是SQL语句和可选控制流语句的预编译集合，以一个名称存储并作为一个单元处理。对于大中型的应用程序中，使用存储过程具有下列优点： 一次创建和测试好后，可以多次供应用程序调用 数据库人员和Web应用程序开发人员可以独立地工作，简化了分工。 Web应用程序和开发人员不直接访问数据库，提高了数据库的安全性。 存储过程在创建时即在服务器上进行预编译，因此具有较高的执行效率。 一个存储过程可以执行上百条SQL语句，降低网络通信量。 存储过程或数据库结构的更改不会影响应用程序，具有一定的灵活性。 存储过程按返回值的情况，同样分为3种：返回记录的存储过程；返回单个值的存储过程；执行操作的存储过程。使用SqlCommand对象执行存储过程与执行SQL语句一样，分为以下3种情况。 返回记录的存储过程：使用SqlCommand对象的ExecuteReader方法执行，并从数据库中获取查询结果集。 返回标量值的存储过程：使用SqlCommand对象的ExecuteScalar方法执行，并从数据库中检索单个值 执行操作的存储过程：使用SqlCommand对象的ExecuteNoQuery方法执行，并返回受影响的记录数。   使用事务处理 在.Net中，事务处理机制共有4种： 数据库事务 ADO.NET事务 ASP.NET事务 企业服务级事务 断开模式数据库访问 DataSet数据集  使用SqlDataAdapter对象执行数据库命令 断开模式访问数据库的开发流程有以下几个步骤： 创建SqlConnection对象与数据库建立连接； 创建SqlDataAdapter对象对数据库执行SQL命令或存储过程，包括增、删、改及查询数据库等命令； 如果查询数据库的数据，则使用SqlDataAdapter的Fill方法填充DataSet；如果是对数据库进行增、删、改操作，首先要对DataSet对象进行更新，然后使用SqlDataAdapter的Update方法将DataSet中的修改内容更新到数据库中。使用SqlDataAdapter对数据库的操作过程中，连接的打开和关闭是自动完成的，无需手动编码。     DataSet数据集 DataSet是ADO.NET的核心组建之一，位于System.Data命名空间下，是一个内存中的小型数据库。 数据集是包含数据表的对象，可以在这些数据表中临时存储数据以便在应用程序中使用。 如果应用程序要求使用数据，则可以将该数据加载到数据集中，数据集在本地内存中为应用程序提供了待用数据的缓存。即使应用程序从数据库断开连接，也可以使用数据集中的数据。 数据集维护有关其数据更改的信息，因此可以跟踪数据更新，并在应用程序重新连接时将更新发送回数据库。 数据集可以分为类型化和非类型化两种数据集。 类型化数据集是继承自DataSet类，通过“数据集设计器”创建一个新的强类型数据集类。其架构信息如表、行、列等都已内置。由于类型化数据集继承自DataSet类，因此类型化数据集具有DataSet类的所有功能。 非类型化数据集没有相应的内置架构。与类型化数据集一样，非类型化数据集也包含表、列等，但它们只作为集合公开。   1．数据集（DataSet）对象创建 创建DataSet的语法格式为： DataSet 对象名 = new DataSet(); 或 DataSet 对象名 = new DataSet(\"数据集名\"); 例如，创建数据集对象dsStu，代码如下： DataSet dsStu = new DataSet(); 或 DataSet dsStu = new DataSet(\"Student\"); 2．数据表（DataTable）对象的创建 DataSet中的每个数据表都是一个DataTable对象。定义DataTable对象的语法格式为： DataTable 对象名 = new DataTable(); 或 DataTable 对象名 = new DataTable(\"数据表名\"); 例如，创建数据表对象dtStu，代码如下： DataTable dtStuInfo = new DataTable(); dtStuInfo.TableName=\"StuInfo\"; 或 DataTable dtStuInfo = new DataTable(\"StuInfo\"); 创建好的数据表对象，可以添加到数据集对象中，代码如下：   dsStu.Tables.Add(dtStuInfo); 3．数据列（DataColumn）对象的创建 DataTable对象中包含多个数据列，每列就是一个DataColumn对象。定义DataColumn对象的语法格式为： DataColumn 对象名 = new DataColumn(); 或 DataColumn 对象名 = new DataColumn(\"字段名\"); 或 DataColumn 对象名 = new DataColumn(\"字段名\",数据类型); 例如，创建数据列对象stuNoColumn，代码如下： DataColumn stuNoColumn= new DataColumn(); stuNoColumn.ColumnName=\" StuNo\"; stuNoColumn.DataType =System.Type.GetType(\"System.String\"); 或 DataColumn stuNoColumn= new DataColumn(\"StuNo\",  System.Type.GetType(\"System.String\")); 说明：通过DataColumn对象的DataType属性设置字段数据类型时，不可直接设置数据类型，而要按照以下语法格式： 对象名.DataType = System.Type.GetType(\"数据类型\"));   创建好的数据列对象，可以添加到数据表对象中，代码如下：  dtStuInfo.Columns.Add(stuNoColumn); 4．数据行（DataRow）的创建 DataTable对象可以包含多个数据列，每行就是一个DataRow对象。定义DataRow对象的语法格式为：  DataRow 对象名 = DataTable对象.NewRow(); 注意:DataRow对象不能用New来创建，而需要用数据表对象的NewRow方法创建。 例如，为数据表对象dtStu添加一个新的数据行，代码如下：  DataRow dr = dtStuInfo.NewRow(); 访问一行中某个单元格内容的方法为： DataRow对象名[\"字段名\"]或DataRow对象名[序号] 5．视图对象（DataView）的创建 数据视图DataView是一个对象，它位于数据表上面一层，提供经过筛选和排序后的表视图。通过定制数据视图可以选择只显示表记录的一个子集，同时在一个数据表上可定义多个DataView。 定义DataView对象的语法格式为： DataView 对象名= new DataView(数据表对象); 例如： DataView dvStuInfo = new DataView(dtStuInfo); DataView对象可以通过以下2个属性定制不同的数据视图。 RowFilter属性：设置选取数据行的筛选表达式。 Sort属性：设置排序字段和方式。 例如： DataView dvStuInfo = new DataView (ds.Tables(\"StuInfo\")); dvStuInfo.Sort = \"StuNo desc\"; //按StuNo字段降序排，如果要升序，将desc改为asc dvStuInfo.RowFilter = \"Name = '张三'\";//筛选出姓名为张三的学生 6．类型化的数据集 创建类型化的数据集有多种方法，下面介绍如何使用“数据集设计器”创建数据集。 在“解决方案资源管理器中”，鼠标右键单击项目名称，选择“添加新项”菜单。 从“添加新项”对话框中选择“数据集”。 键入该数据集的名称。 单击“添加”按钮。Visual Studio 会提示把强类型数据集放到App_Code目录中，选择“是”按钮。数据集将添加到项目的App_Code目录下，并打开“数据集设计器”。 可以从“工具箱”的“数据集”选项卡中拖数据表等控件到设计器上，设计相应的数据集，该数据集存储在.xsd文件中。 下面将非类型化数据集与类型化数据集比较，类型化数据集有以下两个优势。   类型化数据集的架构信息已经预先“硬编码”到数据集内。也就是说，数据集按将要获取的数据的表、列以及数据类型预先初始化了。这样，执行查询获取实际信息时会稍微快一些，因为数据提供程序分两步填充空DataSet。它首先获取最基础的架构信息，然后再执行查询。 可以通过类型化数据集的属性名称而不是基于字段查找的方式访问表和字段的值。这样，如果使用了错误的表名、字段名或数据类型，就可以在编译时而不是运行时捕获错误。 例如，要访问StuInfo表的第i行Name字段的值，非类型化数据集的方法是dsStu.Tables[\"StuInfo\"].Rows[i][\"Name\"]；类型化的数据集的方法是dsStu.StuInfo[i].Name。   DataAdapter是一个特殊的类，其作用是数据源与DataSet对象之间沟通的桥梁。 DataAdapter提供了双向的数据传输机制，它可以在数据源上执行Select语句，把查询结果集传送到DataSet对象的数据表（DataTable）中，还可以执行Insert、Update和Delete语句，将DataTable对象更改过的数据提取并更新回数据源。   DataAdapte对象包含四个常用属性： SelectCommad属性：是一个Command对象，用于从数据源中检索数据。 InsertCommand、UpdateCommand和DeleteCommand属性：也是Command对象，用于按照对DataSet中数据的修改来管理对数据源中数据的更新。   DataAdapter对象的常用方法： Fill方法：调用Fill方法会自动执行SelectCommand属性中提供的命令，获取结果集并填充数据集的DataTable对象。其本质是通过执行SelectCommand对象的Select语句查询数据库，返回DataReader对象，通过DataReader对象隐式地创建DataSet中的表，并填充DataSet中表行的数据。   Update方法：调用InsertCommand、UpdateCommand和DeleteCommand属性指定的SQL命令，将DataSet对象更新到相应的数据源。在Update方法中，逐行检查数据表每行的RowState属性值，根据不同的RowState属性，调用不同的Command命令更新数据库。DataAdapter对象更新数据库示例图如图所示。 定义SqlDataAdapter对象的方法有4种： SqlDataAdapter对象名= new SqlDataAdapter(); SqlDataAdapter 对象名 = new SqlDataAdapter(SqlCommand对象); SqlDataAdapter 对象名 = new SqlDataAdapter(\"SQL命令\", 连接对象); SqlDataAdapter 对象名 = new SqlDataAdapter(\"SQL命令\", 连接字符串); 例如： SqlDataAdapter daStu = new SqlDataAdapter(\"select * from StuInfo\", cnn); 1、使用SqlDataAdapter对象查询数据库的数据 使用SqlDataAdapter查询数据库的步骤为： 创建数据库连接对象； 利用数据库连接对象和Select语句创建SqlDataAdapter对象； 使用SqlDataAdapter对象的Fill方法把Select语句的查询结果放在DataSet对象的一个数据表中或直接放在一个DataTable对象中； 查询DataTable对象中的数据   2、使用SqlDataAdapter对象增/删/改数据库的数据 使用SqlDataAdapter查询数据库的步骤为： 创建数据库连接对象。 利用数据库连接对象和Select语句创建SqlDataAdapter对象。 根据操作要求配置SqlDataAdapter对象中不同的Command属性。如增加数据库数据，需要配置InsertCommand属性；修改数据库数据，需要配置UpdateCommand属性；删除数据库数据，需要配置DeleteCommand属性。 使用SqlDataAdapter对象的Fill方法把Select语句的查询结果放在DataSet对象的一个数据表中或直接放在一个DataTable对象中。 对DataTable对象中的数据进行增、删、改操作。 修改完成后，通过SqlDataAdapter对象的Update方法将DataTable对象中的修改更新到数据库。  ","title":"ADO.NET数据访问技术"},{"content":"分析：      前两天在写测试用例的时候发现了一个段错误的bug，最后在追踪代码的时候发现问题出在strdup函数上面，结论是，该函数的参数不能为NULL，一旦为NULL，就会报段错误。    出于对问题的探索，我又自己写了一些写测试： （1）    #include <string.h>    intmain()    {      const char *null_src_p = NULL;      char *null_dest_p = strdup(null_src_p);      return 0;    }    最终在执行的时候还是报：Segmentation fault （2） 我找到了strdup的源代码： char *strdup1(const char *str) {     size_t len;     char *copy;     len = strlen(str) + 1;     if ((copy = malloc(len)) == NULL)         return (NULL);     memcpy(copy, str, len);     return (copy); } 继续跟踪发现为题出来strlen，结论：strlen函数参数不能为NULL； （3）我想strlen参数不能是NULL似乎又是另外一个问题了，且听下回继续分解了。 建议：     大家以后再使用strdup的时候千万别忘记了对参数的判断和检查。","title":"关于strdup函数参数为NULL的分析和建议"},{"content":"        给多组大数，求所有相加之和。 #include <stdio.h>#include <string.h>// 该函数实现str1和str2相加，将结果保存在str1中void add(char str1[], char str2[]) {    int i, j;    int l1 = strlen(str1);    int l2 = strlen(str2);    int a[1050], b[1050];    memset(a, 0, sizeof (a));    memset(b, 0, sizeof (b));    for (i=l1-1; i>=0; i--)        a[l1-i-1] = str1[i]-'0';    for (i=l2-1; i>=0; i--)        b[l2-i-1] = str2[i]-'0';    int m = l1 > l2 ? l1 : l2;    int cp = 0;    for (i=0; i<m; i++) {        int tmp = a[i] + b[i] + cp;        a[i] = tmp % 10;        cp = tmp / 10;    }    if (cp) {        a[i] = cp;        m++;    }    for (i=0, j=m-1; j>=0; j--, i++)        str1[i] = a[j]+'0';    str1[i] = '\\0';}int main() {    char str1[1050], str2[1050];    str1[0] = '\\0';    while (scanf(\"%s\", str2) && strcmp(str2, \"0\")) {        add(str1, str2);    }    printf(\"%s\\n\", str1);    return 0;}","title":"UVA 424 - Integer Inquiry 大数相加问题"},{"content":"一、算法实现 插入排序的时间复杂度为O（n^2），其实现算法如下： int insert_sort(int *array, int num){\tint i=0, j=0;\tfor(j=2; j<num-1; j++)\t{\t\ti = j-1;\t\tarray[0] = array[j]; /* array[0]为哨兵 */\t\twhile(array[i] < array[0])\t\t{\t\t\tarray[i+1] = array[i];\t\t\ti--;\t\t}\t\tarray[i+1] = array[0];\t}\treturn 0;} 二、算法调用 #define ARRAY_NUM (10)int main(int argc, void *argc){\tint idx = 0;\tint array[ARRAY_NUM] = {0, 9, 8, 7, 6, 5, 4, 3, 2, 1};\tinsert_sort(array, ARRAY_NUM);\tfor(idx=1; idx<ARRAY_NUM; idx++)\t{\t\tfprintf(stdout, \"array[%d] = %d\\n\", idx, array[idx]);\t}\treturn 0;}","title":"算法导论 之 插入排序[C语言实现]"},{"content":"#include <stdio.h>#include <string.h>#include <stdlib.h>#define MAX_PEER_LEN 64typedef unsigned long                    u64_t;typedef unsigned int                     u32_t;typedef unsigned short                   u16_t;typedef unsigned char                    u8_t;typedef signed char                      s8_t;typedef u32_t ip_addr_t;typedef u16_t port_t;/* gnat header */typedef struct gnat_hdr{ ip_addr_t lcl_addr;            // local address with 32 bytes ip_addr_t ref_addr;            // public address with 32 bytes ip_addr_t rel_addr;            // relay address with 32 bytes port_t lcl_port;               // local port number with 16 bytes port_t ref_port;               // public port number with 16 bytes port_t rel_port;               // relay port number with 16 bytes u16_t type;                    // type of action u16_t id_len;                  // length of actual peer id u8_t peer_id[MAX_PEER_LEN];    // peer_id with 16 bytes defined in peer_length}gnat_hdr_t;typedef struct peer_table{ gnat_hdr_t *peer; struct peer_table *next;} peer_table;/* peer list */typedef struct peer_list{ struct peer_table *first;   struct peer_table *last;   struct peer_table *head;  } peer_list_t;peer_list_t pplist;peer_table *gnat_add_peer(peer_list_t *plist, gnat_hdr_t *peer){ peer_table *ppeer;  ppeer = (peer_table *)calloc(1, sizeof(peer_table)); ppeer->peer = peer;  if ( ppeer == NULL )  return(NULL);  if(plist->first) {  ppeer->next = plist->first->next;  plist->first->next = ppeer; }else{  ppeer->next = plist->head;  plist->head  = ppeer; }  return ppeer;}static peer_table *gnat_search_peer(peer_list_t *plist, u8_t peer_id[]) {  peer_table *pp;  pp = plist->head; while(pp) {  if (!strcmp((char *)pp->peer->peer_id, (const char *)peer_id)) {   break;  }  pp = pp->next; }  return pp;}static u32_t gnat_destroy_peer(peer_list_t *plist, peer_table *peer){ peer_table  **pp;  pp = &plist->head;  while (*pp) {  if ( *pp == peer )   break;  pp = &((*pp)->next); }  if ( *pp == peer) {  *pp = peer->next;    if (plist->first == peer)   plist->first = NULL;    if (plist->last == peer )   plist->last = NULL;  free(peer);    return (0); } else {  return -1; }  return (0);}int main(void){ gnat_hdr_t  msg;    u8_t str[32] = \"peerA\"; peer_table *pp;  msg.id_len = 4; msg.lcl_addr = 0; msg.lcl_port = 0; memcpy(msg.peer_id, str, 6); msg.ref_addr = 0; msg.ref_port =0; msg.rel_addr = 0; msg.rel_port = 0; msg.type = 1;     gnat_add_peer(&pplist, &msg); pp = gnat_search_peer(&pplist, str); printf(\"%d\\n\", pp->peer->id_len); gnat_destroy_peer(&pplist, pp); if((pp = gnat_search_peer(&pplist, str)) == NULL)  printf(\"Delete sucess!\\n\");  return (0);}","title":"最近在做NAT时写的一个双向链表（vc6.0和linux下测试通过）"},{"content":"我在这里用实例来说明： (1)我们建一个文件命名为:a,里面输入  “ls - l”; (2)执行chmod 444 a,然后再执行: sh a,达到我们的目的; (3)用./a执行，提示权限不够. (4)chmod 744 a， 用./执行，ok. (5)sh a也ok。 结论： sh命令是调用的shell解析器，因此只要对文件的权限最低要求是可读就行了，而./则要求得更高一些，要有可读、写、执行权限。","title":"./执行文本和sh命令执行文本的区别"},{"content":"interface 收费  ;定义一个收费接口{  public void  收取费用();}interface 调节温度 ;定义一个调节温度的接口{  public void  controlTemperature();}class  公共汽车 implements 收费  ;公共汽车这个类实现收费这个接口{   public void 收取费用()  ;实现接口时必须实现他的全部功能，即实现所有的函数功能{   System.out.println(\"公共汽车：一元/一张，不计算公里数\");}}class  出租车  implements  收费 , 调节温度  {  public void 收取费用(){  System.out.println(\"出租车 ：1.60元/公里，起价3元\");}public void controlTemperature(){  System.out.println(\"安装了Hair空调\");}}class 电影院  implements  收费 , 调节温度{  public void  收取费用(){  System.out.println(\"电影院:门票，十元/张\");} public  void controlTemperature(){  System.out.println(\"安装了中央空调\");}}class  example10{  public static void main(String args[]){ 公共汽车  七路=new 公共汽车(); 出租车    天宇=new  出租车(); 电影院    红星=new   电影院();  七路.收取费用();  天宇.收取费用();  红星.收取费用();  天宇.controlTemperature();  红星.controlTemperature();}} //接口回调是指：可以把实现某一接口的类创建的对象的引用赋给该接口声明的接口变量中。那么该接口变量就可以调用被类实现的接口中的方法。实际上，当接口变量调用类实现的接口中的方法时，就是通知相应调用接口中的方法interface ShowMessage{ void  显示商标(String s);}class TV implements  ShowMessage{ public void 显示商标(String s){ System.out.println(s);}}class PC  implements   ShowMessage{ public  void  显示商标(String s){  System.out.println(s);}}public class  example11{ public static void  main(String args[]){ ShowMessage  sm; sm=new TV(); sm.显示商标(\"长城牌电视机\"); sm=new  PC(); sm.显示商标(\"联想奔月5008PC\");}}","title":"java书中小例子7-接口"},{"content":"一、算法实现 冒泡排序的时间复杂度为O（n^2），其实现代码如下： int bubble_sort(int *array, int num){\tint i=0, j=0, idx=0, max=0;\tfor(idx=1; idx<num; idx++)\t{\t\tarray[0] = array[1]; /* array[0]为交换空间 */\t\tmax = num-idx+1;\t\tfor(j=2; j<max; j++)\t\t{\t\t\tif(array[j] > array[0])\t\t\t{\t\t\t\tarray[j-1] = array[0];\t\t\t\tarray[0] = array[j];\t\t\t}\t\t\telse\t\t\t{\t\t\t\tarray[j-1] = array[j];\t\t\t\tarray[j] = array[0];\t\t\t}\t\t}\t\tarray[j-1] = array[0];\t}\treturn 0;} 二、函数调用 #define ARRAY_NUM (10)int main(int argc, void *argv[]){\tint idx=0;\tint array[ARRAY_NUM] = {0, 9, 8, 7, 6, 5, 4, 3, 2, 1};\tbubble_sort(array, ARRAY_NUM);\tfor(idx=1; idx<ARRAY_NUM; idx++)\t{\t\tfprintf(stdout, \"array[%d] = %d\\n\", idx, array[idx]);\t}\treturn 0;}","title":"算法导论 之 冒泡排序[C语言实现]"},{"content":"php中有两种自动加载机制函数 __autoload();spl_autoload_register(); 1. __autoload() 可以将需要使用类的时候把文件加载到程序中 <?phpfunction __autoload($className) {    if (file_exists($className . '.php')) {        include $className . '.php';//可细化    } else {        echo $className . '.php is not exists.';        exit;    }}$indexController = new IndexController(); 在程序的运行过程中，php会检测这个$className类是否已经加载，如果没有加载会去执行__autoload()，再去加载$className这个类。在实例化类的对象、访问类中的静态变量和方法等都会去检测类是否已经加载，是否有定义__autoload()函数，如果都没有就会报错。 在复杂点的系统中，用__autoload()来实现类的自动加载可能会很复杂。 2. spl_autoload_register() <?phpspl_autoload_register();$index = new Index(); spl_autoload_register()函数中没有参数，则会自动默认实现void spl_autoload ( string $class_name [,string $file_extensions ] )函数，默认支持.php和.ini function load1($className) {    //include}function load2($className) {    //include}spl_autoload_register('load1');//注册到spl_autoload_functionsspl_autoload_register('load2');$index = new Index(); 会先通过load1去加载类，如果load1中没有，再通过load2去加载，如果还有以次类推。 实现一个自动加载方法比较多，这举例一个 转自http://cn2.php.net/autoload ，Thank tofka at fatihkadirakin dot com <?phpclass autoloader {    public static $loader;    public static function init()    {        if (self::$loader == NULL)            self::$loader = new self();        return self::$loader;    }    public function __construct()    {        spl_autoload_register(array($this,'model'));        spl_autoload_register(array($this,'helper'));        spl_autoload_register(array($this,'controller'));        spl_autoload_register(array($this,'library'));    }    public function library($class)    {        set_include_path(get_include_path().PATH_SEPARATOR.'/lib/');        spl_autoload_extensions('.library.php');        spl_autoload($class);    }    public function controller($class)    {        $class = preg_replace('/_controller$/ui','',$class);                set_include_path(get_include_path().PATH_SEPARATOR.'/controller/');        spl_autoload_extensions('.controller.php');        spl_autoload($class);    }    public function model($class)    {        $class = preg_replace('/_model$/ui','',$class);                set_include_path(get_include_path().PATH_SEPARATOR.'/model/');        spl_autoload_extensions('.model.php');        spl_autoload($class);    }    public function helper($class)    {        $class = preg_replace('/_helper$/ui','',$class);        set_include_path(get_include_path().PATH_SEPARATOR.'/helper/');        spl_autoload_extensions('.helper.php');        spl_autoload($class);    }}//callautoloader::init();?> 也可以根据自己的需要来设计实现","title":"php自动加载"},{"content":"#include <iostream>#include <cstdio>#include <cstring>#define INF 0x7ffffff//如果设为0x7fffffff在执行算法时溢出。#define maxn 100using namespace std;int n;int edge[maxn][maxn];int a[maxn][maxn], path[maxn][maxn];void floyd() {    int i, j, k;    for( i = 0; i < n; i++ ) {        for( j = 0; j < n; j++) {            a[i][j] = edge[i][j];            if( i != j && a[i][j] < INF ) { path[i][j] = i; }            else { path[i][j] = -1; }        }    }    for( k = 0; k < n; k++ ) {        for( i = 0; i < n; i++ ) {            for( j = 0; j < n; j++ ) {                if( k == i || k == j ) { continue; }                if( a[i][k] + a[k][j] < a[i][j] ) {                    a[i][j] = a[i][k] + a[k][j];                    path[i][j] = path[k][j];                }            }        }   }}void output() {    int i, j;    int shortest[maxn];    for( i = 0; i < n; i++ ) {        for( j = 0; j < n; j++ ) {            if( i == j) { continue; }            printf( \"%d->%d\\t%d\\t\", i, j, a[i][j] );            memset( shortest, 0, sizeof(shortest) );            int k = 0;            shortest[k] = j;            while( path[i][shortest[k]] != i) {                k++; shortest[k] = path[i][shortest[k-1]];            }            k++; shortest[k] = i;            for( int t = k; t >0; t-- ) {                printf( \"%d->\", shortest[t] );            }            printf( \"%d\\n\",shortest[0] );        }    }    return;}void init() {    int i, j;    int u, v, w;    scanf(\"%d\", &n);    for( i = 0; i < n; i++ ) {        for( j = 0; j < n; j++ ) {            if(i != j) { edge[i][j] = INF; }            else { edge[i][j] = 0; }        }    }    while( 1 ) {        scanf(\"%d%d%d\", &u, &v, &w);        if( u == -1 && v == -1 && w == -1 ) { break; }        edge[u][v] = w;    }}int main(){    init();    floyd();    output();    return 0;}/**************************测试数据：40 1 10 3 41 2 91 3 22 0 32 1 52 3 83 2 6-1 -1 -1***********************/","title":"Floyd(最短路径问题）"},{"content":"我做的是用于下载文件，当然网址也可以。  window.location = \"../File/模板.xls\"; 一句就够了！","title":"在Javascript(js)或Jquery中直接实现超链接跳转代码示例！"},{"content":" 抽象类StrutsTypeConverter继承了DefaultTypeConverter接口，有如下方法：   abstract  Object convertFromString(Map context, String[] values, Class toClass)           Converts one or more String values to the specified class. abstract  String convertToString(Map context, Object o)           Converts the specified object to a String. Object convertValue(Map context, Object o, Class toClass)   StrutsTypeConverter简化了类型转换代码的编写，StrutsTypeConverter继承DefaultTypeConverter,提供了两个抽象的方法convertFromString()和convertToString,分别表示从页面的字符串转换为后台对象以及从后台对象转为页面的字符串，我们只需要实现这两个抽象方法即可实现类型转换。 将学习（一）中转换器代码修改成如下： package com.struts.converter;import java.util.Map;import org.apache.struts2.util.StrutsTypeConverter;import com.struts.bean.User;public class UserConverter2 extends StrutsTypeConverter{\t@Override\tpublic Object convertFromString(Map arg0, String[] arg1, Class arg2) {\t\tUser user = new User();\t\tString str = arg1[0];\t\tSystem.out.println(arg1.length);\t\tSystem.out.println(arg1[0]);\t\tint index = str.indexOf(\";\");\t\tString username = str.substring(0,index);\t\tString userpass = str.substring(index+1);\t\tuser.setPassword(userpass);\t\tuser.setUsername(username);\t\treturn user;\t}\t@Override\tpublic String convertToString(Map arg0, Object arg1) {\t\tString str = \"\";\t\tif(arg1 instanceof User)\t\t{\t\t\tUser user = (User)arg1;\t\t\tstr = \"username:\"+user.getUsername()+\" ;---- userpass: \"+user.getPassword();\t\t}\t\treturn str;\t}}    ","title":"struts2学习（二）--转换器StrutsTypeConverter"},{"content":"which.bat @echo off & setlocal enabledelayedexpansionif \"%1\" == \"\" (  echo which可以查找PATH路径中是否包含指定程序  echo 用法：which 程序名  goto :ext)set pathstr=%PATH%@echo -------------------------: findfileFOR /F \" tokens=1* delims=;\" %%i IN (\"!pathstr!\") do (    set p=%%i    if \"!p:~-1!\" NEQ \"\\\" (        set p=!p!\\    )    if exist !p!%1 (        @echo 存在目录于:%%i    )set pathstr=%%jgoto findfile)@echo -------------------------:ext@echo on","title":"windows下bat脚本相当于linux的which"},{"content":"1.这里只是单个unicode字符的转换,字符串转换的话需要遍历整个字符串,可用std::string的append添加. 2.如果只是2字节宽的unicode,只需要unicode_char_length = 2就行了。 3.如有问题,请指出. void OneUnicode2UTF8(const char* unicode_char,size_t unicode_char_length,\t\t\tchar* utf_char){\t//unicode: 0x192->110010010 ,utf8:0xC692->1100011010010010\tint value = 0;\tmemcpy(&value,unicode_char,unicode_char_length);\t\tif (value >= 0x0000 && value <= 0x007F)  \t{  \t\tutf_char[0] = unicode_char[0];\t}  \telse if (value >= 0x0080 && value <= 0x07FF)  \t{  \t\tutf_char[0] = ((value >> 6) | 0xC0);\t\tutf_char[1] = ((value & 0x3F) | 0x80);\t}  \telse if (value >= 0x0800 && value <= 0xFFFF)  \t{  \t\tutf_char[0] = ((value >> 12) | 0xE0);\t\tutf_char[1] = ((value >> 6 & 0x3F) | 0x80);\t\tutf_char[2] = ((value & 0x3F) | 0x80);\t}\telse if (value >= 0x10000 && value <= 0x10FFFF)  \t{  \t\tutf_char[0] = (value >> 18 | 0xF0);\t\tutf_char[1] = ((value >> 12 & 0x3F) | 0x80);\t\tutf_char[2] = ((value >> 6 & 0x3F) | 0x80);\t\tutf_char[3] = ((value & 0x3F) | 0x80);\t}\telse\t{\t\tcerr << \"value too big.\" << endl; \t\tassert(0);\t}} 参考文档: http://baike.baidu.com/view/40801.htm","title":"[C/C++]_[Unicode(char*)转UTF8]"},{"content":"背景： 假设一个web工程有3个独立业务子模块，user,home,rpc，3个独立子模块也独立发布，子模块独立发布后可以及时reloadweb工程的业务功能，3个子模块可以在任何服务器上，也可以是3个不同的公司来提供，如下图     一般我们的工程会采用spring来管理bean，在这种情况下要稍微改造下。看上去和热部署也有点类似。 这次的知识点以这个背景为例来进行讲解。   首先看下这样做的一些好处： 1.业务模块的独立按需加载，可以加快web容器的启动，每次只需要启动时加载自己需要的内容 2.发布更新更快速，独立发布子模块影响局部的业务功能   原理： 1.我们先做一个子模块user.jar（在10.20.150.216共享里） user.jar里面就一个spring_user.xml和User.java ------------------- spring_user.xml <bean id=\"user\"class=\"com.wzucxd.User\">      <property name=\"name\"value=\"xxx\" />  <\/bean> ------------------- User.java packagecom.wzucxd;   public class User {       private Integer id;         private String name;       public Integer getId() {         return id;     }       public void setId(Integer id) {         this.id = id;     }       public String getName() {         return name;     }       public void setName(String name) {         this.name = name;     }   }   2.下面就是模拟父容器加载子模块的case 基本思路：通过XmlBeanFactory先加载子模块的bean对象的BeanDefinition，然后将BeanDefinition注册到父容易的beanFactory，最后对加载bean的AppClassloader改造成需要的ClassLoader（这里改造成URLClassLoader）   详细代码以及示例如下   public class Test {       public static void main(String[] args) {         try {                        //读取spring全局配置文件，（这里是一个空内容的文件，没有任何内容），即我们平时web project父容器上下文         //当然平时这里会用ClassPathXmlApplicationContext，看文件所在位置了。。。             ApplicationContextapplicationContext = newFileSystemXmlApplicationContext(\"file://10.20.150.216\\\\share\\\\ebook\\\\j2se\\\\classloader\\\\spring_config.xml\");                //创建全局spring BeanFactory，目的是将所有子模块的bean对象注册到这个父容器上下文中             DefaultListableBeanFactorybeanFactory = (DefaultListableBeanFactory)applicationContext.getAutowireCapableBeanFactory();                //独立模块的spring bean配置文件位置             String configurationFilePath = \"jar:file://10.20.150.216\\\\share\\\\ebook\\\\j2se\\\\classloader/user.jar!/spring_user.xml\";                //这里可以做一个逻辑，如果该配置文件不存在，那么父容器启动的时候这个子模块就不加载             URL url = new URL(configurationFilePath);                //建立远程资源访问             UrlResource urlResource = new UrlResource(url);                XmlBeanFactory xmlBeanFactory = new XmlBeanFactory(urlResource);                String[] beanIds =xmlBeanFactory.getBeanDefinitionNames();                for (String beanId : beanIds) {                  //获得的子模块bean对象                 BeanDefinition bd =xmlBeanFactory.getMergedBeanDefinition(beanId);                  //在这里将子模块bean对象注册到父容易上下文中，完成bean对象的Definition                beanFactory.registerBeanDefinition(beanId, bd);              }                //接着要进行classloader的改变，加载的class文件现在不在classpath下，而是其他地方（远程共享、http服务或者其他协议服务的机器上）             //这时候就需要将父容易中beanFactory的加载bean的classloader改变（父容易中beanFactory默认是AppClassLoader，这种情况下改成用URLClassLoader）             // 以下这行设置BeanFactory的ClassLoader为URLClassLoader，以加载外部类              setBeanClassLoader(beanFactory);                //以下是测试是否注入成功             //从父容器上下文中获取user对象             Object pluginBean =applicationContext.getBean(\"user\");                //测试结果             String val = tryInvoke(pluginBean);              System.out.println(val);           } catch (Exception exc) {              exc.printStackTrace();          }      }         private static void setBeanClassLoader(              DefaultListableBeanFactorybeanFactory)              throws MalformedURLException {          //指明spring_user.xml配置出现的bean对象所在jar位置         String jarFilePath = \"file://10.20.150.216\\\\share\\\\ebook\\\\j2se\\\\classloader\\\\user.jar\";          URL jarUrl = new URL(jarFilePath);         URL[] urls = new URL[] { jarUrl };          URLClassLoader cl = new URLClassLoader(urls);         beanFactory.setBeanClassLoader(cl);      }        private static String tryInvoke(Object bean) throws SecurityException,              NoSuchMethodException,IllegalArgumentException,              IllegalAccessException,InvocationTargetException {            Class<?> paramTypes[] = new Class[0];          Method method =bean.getClass().getDeclaredMethod(\"getName\", paramTypes);          Object paramValues[] = new Object[0];          Object obj = method.invoke(bean, paramValues);         //.....         return (String)obj;     }  }   这里如果我们不改变BeanClassLoader会有什么问题呢？会出现classnofound异常，这个主要原因就是默认的beanfactory classloader是AppClassLoader。   3.当然还有另外一种方式，将jar中的类扫描出来，自己创建个classloader，一个个添加进去，这种方式更加灵活多变。其实还是使用spring的bean管理方式使用比较方便，已经解决了主要场景。     public static void main(String[] args) throws Exception {         URL url = new URL(\"jar:file:d:\\\\user.jar!/\");         URLClassLoader uc = new URLClassLoader(new URL[]{url});         Class<?> cls = uc.loadClass(\"com.wzucxd.User\");         Object obj = cls.newInstance();         System.out.println(obj);     }     最后大家可能会发现，与其说加载远程的独立spring子模块，其实其核心关键还是classloder这个知识的应用扩展，关于classloader的详细内容可以参考以前整的classloader.doc","title":"加载远程服务上的spring独立子模块"},{"content":"多线程是一门复杂的技术，这个表现在各个语言当中。下面我们简单讲解一下python的多线程。 1 多线程定义 class myclass(threading.Thread):     '''python thread demo 1, feel happy today!'''     def __init__(self):         threading.Thread().__init__()     def run(self):         list = range(10)         for item in list:             print '%d'%item+'dddd' 2 多线程的调用 obj = myclass() obj.run() 3 多线程锁资源","title":"python 多线程入门"},{"content":"基本的程序执行寄存器 通用寄存器： 这八个寄存器能用于存放操作数和指针 段寄存器：这些段寄存器最多能保持4个段选择子 FLAGS寄存器：FLAGS寄存器报告正在执行的程序的状态，并允许有限的控制处理器 IP（指令指针）寄存器：IP寄存器包含下一条执行的指令的16位指针 1：通用寄存器 8个通用寄存器AX，BX，CX，DX，SI，DI，BP，SP用于处理以下内容 逻辑和算术操作的操作数 用于地址计算的操作数 内存指针 虽然所有这些寄存器都用于存放操作数，结果和指针，但在引用SP寄存器时要特别小心。 SP寄存器保持堆栈指针，通常步用于其他目的 许多指令寄存器赋予特定的寄存器已存放操作数，例如，串操作指令用CX，SI和DI寄存器的内容 作为操作数 以下是特殊使用要求 AX操作数和结果数据的累计器 BX在DS段中数据的指针 CX串和循环操作的计算器 DX I/O指针 SI指向DS寄存器段中的数据指针，串操作的源指针 DI指向ES寄存器段中的数据的指针，串操作的目标指针 SP堆栈指针（在SS段中） BP堆栈上数据指针 这些通用寄存器中的前四个，即AX，BX，CX，DX通常称为数据寄存器，用以存放操作数；后四个，即SI，DI，BP，SP，通常称为指针寄存器，虽然他们也可以存放操作数，但主要用于地址指针 DS，ES寄存器指向两个数据段。两个数据段的可用性，允许有效而又安全的访问结构不同的数据类型 SS寄存器包含堆栈段的段选择子，所有的堆栈段操作都以SS以找到堆栈段 指令指针： 指令指针（IP）寄存器包含下一条要执行的指令在当前段中的偏移。通常，它是顺序增加的，从一条指令边界至下一条指令，但在执行JMP，Jcc，CALL，RET，和IRETD等指令，它可以向前或向后移动若干条指令 存储器组织 处理器在它的总线上寻址的存储器称为物理存储器，物理存储器按字节序列组织。每一个字节赋予一个唯一的地址，称为物理地址。物理地址空间的范围从0～2的20次方-1的最大值。整个1MB存储器如SP，IP，以及BP或DI等可由CPU处理器的16位偏移量来形成的实际的20位物理地址。这个基地址就是8088中的段寄存器，即代码段寄存器CS，堆栈段寄存器SS，数据段寄存器DS以及附加段寄存器ES中的一个来形成的。在形成的20位物理地址时，段寄存器中的16位数会自动左移4位，然后与16位偏移量相加 每次在需要产生一个20位地址的时候，一个段寄存器会自动被选择，且能自动左移4位再与一个16位地址偏移量相加，一产生所需要的20位物理地址 每当取指令的时候，则自动选择代码段寄存器CS，在加上由IP所决定的16位偏移量，计算得到要取的指令的物理地址 每当涉及到一个堆栈操作时，则自动选择堆栈段寄存器SS，再加上由SP所决定的16位偏移量，计算得到堆栈操作所需要的20位物理地址 每当涉及到一个操作数，则自动选择数据段寄存器DS或附加段寄存器ES，再加上16位偏移量，计算得到操作数的20位物理地址 在不改变段寄存器值的情况下，寻址的最大范围64KB。所以，若有一个任务，他的程序长度，堆栈长度以及数据区域长度都不超过64KB 指针数据类型 指针是内存单元的地址。80*86系列结构定义两种类型的指针：近指针（near）（在8086中是16位，在80386以上处理器中为32位）。Near指针是段内的16位偏移量（也称为有效地址） Near指针在平面存储器模式中用于所有存储器引用，或在分段存储模式中用于同一段内的存储器引用。Far指针是一个48位的逻辑地址，包含16位段选择子和32位的偏移。Far指针用于在分段存储模式中的跨段存储引用 8086指令的操作数寻址方式 8086机器指令有零个或多个操作数 一个操作数能定位在以下地方之一 1：指令中（立即数） 2：寄存器 3：存储单元 4：I/O端口 立即数：某些指令用包含在指令中的数据作为源操作数。这些源操作数称为立即操作数 寄存器操作数：源和目的操作数在寄存器中 存储器操作数： 段超越通常用：处理 交换指令：XCHG XCHG DOPD，SOPD 这时一条交换指令，它有两个操作数：DOPD，和SOPD，该指令的功能是使两个两个操作数交换，这条指令的操作数可以是一个字节或是一个字 CMP比较指令 比较指令完成两个操作数相减，使结果反映在标志位上，但量操作数不变 比较指令主要用于比较两个数之间的关系，即若两者是否相等，或两个中那一个大，在比较指令完后，根据ZF标志即可判断两者是否相等，若两者相等，相减以后结果为零，则ZF为1；否则为0； SF=0，AX>BX","title":"点滴微机原理"},{"content":"    本题为二分的并查集，其实只要在原先的并查集基础上作一下变形。当然此题也还是有技巧的，我们可以对每个节点做个标记，若该节点与父亲节点属于同一类，则标记为,0，否则标记为1。但当我们合并两棵树时，可能会存在两棵树的标记所表达的意思完全相反，此时我们就要通过改变其中一棵树根节点的标记，来保持合并之后的树保持一致。 至于何时有同性恋发生，应该不难判断了，若两个节点属于同一棵树且属于同一类则发生同性恋。 #include<iostream>#include<cstdio>using namespace std;const int maxn=2005;int set[maxn],flag[maxn];//set[i]记录i的父亲节点，flag[i]==0表示该节点的性别与父亲节点相同，否则不相同void init(int n){    for(int i=1;i<=n;i++)    {        set[i]=i;        flag[i]=0;    }}int find1(int x)//返回父亲节点{    while(set[x]!=x)        x=set[x];    return x;}int find2(int x)//返回0或1，判断该节点与根节点是否一致{    int t=0;    while(set[x]!=x)    {        t^=flag[x];        x=set[x];    }    return t;}bool merge(int x,int y)//合并{    int f1=find1(x);    int f2=find1(y);    if(f1==f2)        return false;    set[f1]=f2;    //如果两棵树定义有冲突，则使它们一致（此处通过改变flag[f1]）    if(find2(x)==find2(y))        flag[f1]^=1;    return true;}int main(){    int t,n,m,a,b,C=1;    bool state;    scanf(\"%d\",&t);    while(t--)    {        scanf(\"%d%d\",&n,&m);        init(n);        state=true;        while(m--)        {            scanf(\"%d%d\",&a,&b);            if(!state)                continue;            if(!merge(a,b)&&(find2(a)^find2(b))==0)//同一棵树且性别相同的两个节点                state=false;        }        printf(\"Scenario #%d:\\n\",C++);        if(!state)            printf(\"Suspicious bugs found!\\n\");        else            printf(\"No suspicious bugs found!\\n\");        printf(\"\\n\");//每个样例后面都换行，坑爹的地方    }    return 0;}  ","title":"A Bug's Life hdu1829 并查集"},{"content":"模板为什么要特化，因为编译器认为，对于特定的类型，如果你能对某一功能更好的实现，那么就该听你的。 模板分为类模板与函数模板，特化分为全特化与偏特化。全特化就是限定死模板实现的具体类型，偏特化就是如果这个模板有多个类型，那么只限定其中的一部分。 先看类模板： [cpp] view plaincopyprint? template<typename T1, typename T2>   class Test   {   public:       Test(T1 i,T2 j):a(i),b(j){cout<<\"模板类\"<<endl;}   private:       T1 a;       T2 b;   };      template<>   class Test<int , char>   {   public:       Test(int i, char j):a(i),b(j){cout<<\"全特化\"<<endl;}   private:       int a;       char b;   };      template <typename T2>   class Test<char, T2>   {   public:       Test(char i, T2 j):a(i),b(j){cout<<\"偏特化\"<<endl;}   private:       char a;       T2 b;   };   template<typename T1, typename T2>class Test{public:\tTest(T1 i,T2 j):a(i),b(j){cout<<\"模板类\"<<endl;}private:\tT1 a;\tT2 b;};template<>class Test<int , char>{public:\tTest(int i, char j):a(i),b(j){cout<<\"全特化\"<<endl;}private:\tint a;\tchar b;};template <typename T2>class Test<char, T2>{public:\tTest(char i, T2 j):a(i),b(j){cout<<\"偏特化\"<<endl;}private:\tchar a;\tT2 b;}; 那么下面3句依次调用类模板、全特化与偏特化： [cpp] view plaincopyprint? Test<double , double> t1(0.1,0.2);   Test<int , char> t2(1,'A');   Test<char, bool> t3('A',true);   \tTest<double , double> t1(0.1,0.2);\tTest<int , char> t2(1,'A');\tTest<char, bool> t3('A',true); 而对于函数模板，却只有全特化，不能偏特化： [cpp] view plaincopyprint? //模板函数    template<typename T1, typename T2>   void fun(T1 a , T2 b)   {       cout<<\"模板函数\"<<endl;   }      //全特化    template<>   void fun<int ,char >(int a, char b)   {       cout<<\"全特化\"<<endl;   }      //函数不存在偏特化：下面的代码是错误的    /*  template<typename T2>  void fun<char,T2>(char a, T2 b)  {      cout<<\"偏特化\"<<endl;  }  */   //模板函数template<typename T1, typename T2>void fun(T1 a , T2 b){\tcout<<\"模板函数\"<<endl;}//全特化template<>void fun<int ,char >(int a, char b){\tcout<<\"全特化\"<<endl;}//函数不存在偏特化：下面的代码是错误的/*template<typename T2>void fun<char,T2>(char a, T2 b){\tcout<<\"偏特化\"<<endl;}*/ 至于为什么函数不能偏特化，似乎不是因为语言实现不了，而是因为偏特化的功能可以通过函数的重载完成。","title":"模板的全特化与偏特化"},{"content":"4.11.3 ConditionalInclusion It is possible to control preprocessing itself with conditionalstatements that are evaluated during preprocessing. This provides away to include code selectively, depending on the value ofconditions evaluated during compilation. The #if line evaluates a constant integer expression(which may not include sizeof, casts, or enumconstants). If the expression is non-zero, subsequent lines untilan #endif or #elif or #else areincluded. (The preprocessor statement #elif is likeelse-if.) The expression defined(name)in a #if is 1 if the name has been defined, and 0otherwise. For example, to make sure that the contents of a filehdr.h are included only once, the contents of the file aresurrounded with a conditional like this:    #if !defined(HDR)   #define HDR      #endif The first inclusion of hdr.h defines the nameHDR; subsequent inclusions will find the name defined andskip down to the #endif. A similar style can be used toavoid including files multiple times. If this style is usedconsistently, then each header can itself include any other headerson which it depends, without the user of the header having to dealwith the interdependence. This sequence tests the name SYSTEM to decide whichversion of a header to include:    #if SYSTEM == SYSV       #define HDR \"sysv.h\"   #elif SYSTEM == BSD       #define HDR \"bsd.h\"   #elif SYSTEM == MSDOS       #define HDR \"msdos.h\"   #else       #define HDR \"default.h\"   #endif   #include HDR The #ifdef and #ifndef lines are specializedforms that test whether a name is defined. The first example of#if above could have been written    #ifndef HDR   #define HDR      #endif","title":"Conditional Inclusion"},{"content":"异步channel API 主要引入三个异步类: AsynchronousFileChannel,AsynchronousSocketChannel, and AsynchronousServerSocketChannel. AsynchronousFileChannel跟FileChannel区别：不保存全局的position和offset，可以制定访问位置，也支持并发访问文件不同。 AsynchronousServerSocketChannel AsynchronousSocketChannel：能够绑定到一个制定线程池的组中，这个线程池能够用future或者CompletionHandler来对执行结果进行处理， AsynchronousChannelGroup：执行异步IO的java线程池的组类， AsynchronousChannelGroup.java: public static AsynchronousChannelGroup withFixedThreadPool(int nThreads, ThreadFactory threadFactory) public static AsynchronousChannelGroup withCachedThreadPool(ExecutorService executor,int initialSize) public static AsynchronousChannelGroup withThreadPool(ExecutorService executor)​​​ 我们看使用示例 package com.mime;import java.io.IOException;import java.net.InetSocketAddress;import java.net.StandardSocketOptions;import java.nio.ByteBuffer;import java.nio.channels.AsynchronousChannelGroup;import java.nio.channels.AsynchronousFileChannel;import java.nio.channels.AsynchronousServerSocketChannel;import java.nio.channels.AsynchronousSocketChannel;import java.nio.channels.CompletionHandler;import java.nio.channels.FileLock;import java.nio.charset.Charset;import java.nio.file.Path;import java.nio.file.Paths;import java.nio.file.StandardOpenOption;import java.util.ArrayList;import java.util.List;import java.util.Set;import java.util.TreeSet;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;import java.util.concurrent.ThreadLocalRandom;public class NIO2AsynchronousFileChannel {\tpublic static void main(String[] args) {\t\t\t\tasyFile();\t\tasyFileChannel2();\t\tasyServerSocketChannel();\t}\t// 异步文件读写示例\tpublic static void asyFile() {\t\tByteBuffer buffer = ByteBuffer.allocate(100);\t\tString encoding = System.getProperty(\"file.encoding\");\t\tPath path = Paths.get(\"/tmp\", \"store.txt\");\t\ttry (AsynchronousFileChannel asynchronousFileChannel = AsynchronousFileChannel\t\t\t\t.open(path, StandardOpenOption.READ)) {\t\t\tFuture<Integer> result = asynchronousFileChannel.read(buffer, 0);\t\t\t// 读超时控制\t\t\t// int count = result.get(100, TimeUnit.NANOSECONDS);\t\t\twhile (!result.isDone()) {\t\t\t\tSystem.out.println(\"Do something else while reading ...\");\t\t\t}\t\t\tSystem.out.println(\"Read done: \" + result.isDone());\t\t\tSystem.out.println(\"Bytes read: \" + result.get());\t\t\t// 使用CompletionHandler回调接口异步读取文件\t\t\tfinal Thread current = Thread.currentThread();\t\t\tasynchronousFileChannel.read(buffer, 0,\t\t\t\t\t\"Read operation status ...\",\t\t\t\t\tnew CompletionHandler<Integer, Object>() {\t\t\t\t\t\t@Override\t\t\t\t\t\tpublic void completed(Integer result, Object attachment) {\t\t\t\t\t\t\tSystem.out.println(attachment);\t\t\t\t\t\t\tSystem.out.print(\"Read bytes: \" + result);\t\t\t\t\t\t\tcurrent.interrupt();\t\t\t\t\t\t}\t\t\t\t\t\t@Override\t\t\t\t\t\tpublic void failed(Throwable exc, Object attachment) {\t\t\t\t\t\t\tSystem.out.println(attachment);\t\t\t\t\t\t\tSystem.out.println(\"Error:\" + exc);\t\t\t\t\t\t\tcurrent.interrupt();\t\t\t\t\t\t}\t\t\t\t\t});\t\t} catch (Exception ex) {\t\t\tSystem.err.println(ex);\t\t}\t\tbuffer.flip();\t\tSystem.out.print(Charset.forName(encoding).decode(buffer));\t\tbuffer.clear();\t\t// 异步文件写示例\t\tByteBuffer buffer1 = ByteBuffer\t\t\t\t.wrap(\"The win keeps Nadal at the top of the heap in men's\"\t\t\t\t\t\t.getBytes());\t\tPath path1 = Paths.get(\"/tmp\", \"store.txt\");\t\ttry (AsynchronousFileChannel asynchronousFileChannel = AsynchronousFileChannel\t\t\t\t.open(path1, StandardOpenOption.WRITE)) {\t\t\tFuture<Integer> result = asynchronousFileChannel\t\t\t\t\t.write(buffer1, 100);\t\t\twhile (!result.isDone()) {\t\t\t\tSystem.out.println(\"Do something else while writing ...\");\t\t\t}\t\t\tSystem.out.println(\"Written done: \" + result.isDone());\t\t\tSystem.out.println(\"Bytes written: \" + result.get());\t\t\t// file lock\t\t\tFuture<FileLock> featureLock = asynchronousFileChannel.lock();\t\t\tSystem.out.println(\"Waiting for the file to be locked ...\");\t\t\tFileLock lock = featureLock.get();\t\t\tif (lock.isValid()) {\t\t\t\tFuture<Integer> featureWrite = asynchronousFileChannel.write(\t\t\t\t\t\tbuffer, 0);\t\t\t\tSystem.out.println(\"Waiting for the bytes to be written ...\");\t\t\t\tint written = featureWrite.get();\t\t\t\t// or, use shortcut\t\t\t\t// int written = asynchronousFileChannel.write(buffer,0).get();\t\t\t\tSystem.out.println(\"I’ve written \" + written + \" bytes into \"\t\t\t\t\t\t+ path.getFileName() + \" locked file!\");\t\t\t\tlock.release();\t\t\t}\t\t\t// asynchronousFileChannel.lock(\"Lock operation status:\", new\t\t\t// CompletionHandler<FileLock, Object>() ;\t\t} catch (Exception ex) {\t\t\tSystem.err.println(ex);\t\t}\t}\t// public static AsynchronousFileChannel open(Path file, Set<? extends\t// OpenOption> options,ExecutorService executor, FileAttribute<?>... attrs)\t// throws IOException\tprivate static Set withOptions() {\t\tfinal Set options = new TreeSet<>();\t\toptions.add(StandardOpenOption.READ);\t\treturn options;\t}\t// 使用AsynchronousFileChannel.open(path, withOptions(),\t// taskExecutor))这个API对异步文件IO的处理\tpublic static void asyFileChannel2() {\t\tfinal int THREADS = 5;\t\tExecutorService taskExecutor = Executors.newFixedThreadPool(THREADS);\t\tString encoding = System.getProperty(\"file.encoding\");\t\tList<Future<ByteBuffer>> list = new ArrayList<>();\t\tint sheeps = 0;\t\tPath path = Paths.get(\"/tmp\",\t\t\t\t\"store.txt\");\t\ttry (AsynchronousFileChannel asynchronousFileChannel = AsynchronousFileChannel\t\t\t\t.open(path, withOptions(), taskExecutor)) {\t\t\tfor (int i = 0; i < 50; i++) {\t\t\t\tCallable<ByteBuffer> worker = new Callable<ByteBuffer>() {\t\t\t\t\t@Override\t\t\t\t\tpublic ByteBuffer call() throws Exception {\t\t\t\t\t\tByteBuffer buffer = ByteBuffer\t\t\t\t\t\t\t\t.allocateDirect(ThreadLocalRandom.current()\t\t\t\t\t\t\t\t\t\t.nextInt(100, 200));\t\t\t\t\t\tasynchronousFileChannel.read(buffer, ThreadLocalRandom\t\t\t\t\t\t\t\t.current().nextInt(0, 100));\t\t\t\t\t\treturn buffer;\t\t\t\t\t}\t\t\t\t};\t\t\t\tFuture<ByteBuffer> future = taskExecutor.submit(worker);\t\t\t\tlist.add(future);\t\t\t}\t\t\t// this will make the executor accept no new threads\t\t\t// and finish all existing threads in the queue\t\t\ttaskExecutor.shutdown();\t\t\t// wait until all threads are finished\t\t\twhile (!taskExecutor.isTerminated()) {\t\t\t\t// do something else while the buffers are prepared\t\t\t\tSystem.out\t\t\t\t\t\t.println(\"Counting sheep while filling up some buffers!So far I counted: \"\t\t\t\t\t\t\t\t+ (sheeps += 1));\t\t\t}\t\t\tSystem.out.println(\"\\nDone! Here are the buffers:\\n\");\t\t\tfor (Future<ByteBuffer> future : list) {\t\t\t\tByteBuffer buffer = future.get();\t\t\t\tSystem.out.println(\"\\n\\n\" + buffer);\t\t\t\tSystem.out\t\t\t\t\t\t.println(\"______________________________________________________\");\t\t\t\tbuffer.flip();\t\t\t\tSystem.out.print(Charset.forName(encoding).decode(buffer));\t\t\t\tbuffer.clear();\t\t\t}\t\t} catch (Exception ex) {\t\t\tSystem.err.println(ex);\t\t}\t}\t//异步server socket channel io处理示例\tpublic static void asyServerSocketChannel() {\t\t\t\t//使用threadGroup//\t\tAsynchronousChannelGroup threadGroup = null;//\t\tExecutorService executorService = Executors//\t\t.newCachedThreadPool(Executors.defaultThreadFactory());//\t\ttry {//\t\tthreadGroup = AsynchronousChannelGroup.withCachedThreadPool(executorService, 1);//\t\t} catch (IOException ex) {//\t\tSystem.err.println(ex);//\t\t}//\t\tAsynchronousServerSocketChannel asynchronousServerSocketChannel =//\t\t\t\tAsynchronousServerSocketChannel.open(threadGroup);\t\t\t\tfinal int DEFAULT_PORT = 5555;\t\tfinal String IP = \"127.0.0.1\";\t\tExecutorService taskExecutor = Executors.newCachedThreadPool(Executors\t\t\t\t.defaultThreadFactory());\t\t// create asynchronous server socket channel bound to the default group\t\ttry (AsynchronousServerSocketChannel asynchronousServerSocketChannel = AsynchronousServerSocketChannel\t\t\t\t.open()) {\t\t\tif (asynchronousServerSocketChannel.isOpen()) {\t\t\t\t// set some options\t\t\t\tasynchronousServerSocketChannel.setOption(\t\t\t\t\t\tStandardSocketOptions.SO_RCVBUF, 4 * 1024);\t\t\t\tasynchronousServerSocketChannel.setOption(\t\t\t\t\t\tStandardSocketOptions.SO_REUSEADDR, true);\t\t\t\t// bind the server socket channel to local address\t\t\t\tasynchronousServerSocketChannel.bind(new InetSocketAddress(IP,\t\t\t\t\t\tDEFAULT_PORT));\t\t\t\t// display a waiting message while ... waiting clients\t\t\t\tSystem.out.println(\"Waiting for connections ...\");\t\t\t\twhile (true) {\t\t\t\t\tFuture<AsynchronousSocketChannel> asynchronousSocketChannelFuture = asynchronousServerSocketChannel.accept();\t\t\t\t\t//使用CompletionHandler来处理IO事件//\t\t\t\t\tasynchronousServerSocketChannel.accept(null, new CompletionHandler<AsynchronousSocketChannel, Void>() \t\t\t\t\t//client使用CompletionHandler来处理IO事件\t\t\t\t\t//asynchronousSocketChannel.connect(new InetSocketAddress(IP, DEFAULT_PORT), null,new CompletionHandler<Void, Void>() \t\t\t\t\ttry {\t\t\t\t\t\tfinal AsynchronousSocketChannel asynchronousSocketChannel = asynchronousSocketChannelFuture\t\t\t\t\t\t\t\t.get();\t\t\t\t\t\tCallable<String> worker = new Callable<String>() {\t\t\t\t\t\t\t@Override\t\t\t\t\t\t\tpublic String call() throws Exception {\t\t\t\t\t\t\t\tString host = asynchronousSocketChannel\t\t\t\t\t\t\t\t\t\t.getRemoteAddress().toString();\t\t\t\t\t\t\t\tSystem.out.println(\"Incoming connection from: \"\t\t\t\t\t\t\t\t\t\t+ host);\t\t\t\t\t\t\t\tfinal ByteBuffer buffer = ByteBuffer\t\t\t\t\t\t\t\t\t\t.allocateDirect(1024);\t\t\t\t\t\t\t\t// transmitting data\t\t\t\t\t\t\t\twhile (asynchronousSocketChannel.read(buffer)\t\t\t\t\t\t\t\t\t\t.get() != -1) {\t\t\t\t\t\t\t\t\tbuffer.flip();\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\tasynchronousSocketChannel.write(buffer).get();\t\t\t\t\t\t\t\tif (buffer.hasRemaining()) {\t\t\t\t\t\t\t\t\tbuffer.compact();\t\t\t\t\t\t\t\t} else {\t\t\t\t\t\t\t\t\tbuffer.clear();\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\tasynchronousSocketChannel.close();\t\t\t\t\t\t\t\tSystem.out.println(host\t\t\t\t\t\t\t\t\t\t+ \" was successfully served!\");\t\t\t\t\t\t\t\treturn host;\t\t\t\t\t\t\t}\t\t\t\t\t\t};\t\t\t\t\t\ttaskExecutor.submit(worker);\t\t\t\t\t} catch (InterruptedException | ExecutionException ex) {\t\t\t\t\t\tSystem.err.println(ex);\t\t\t\t\t\tSystem.err.println(\"\\n Server is shutting down ...\");\t\t\t\t\t\t// this will make the executor accept no new threads\t\t\t\t\t\t// and finish all existing threads in the queue\t\t\t\t\t\ttaskExecutor.shutdown();\t\t\t\t\t\t// wait until all threads are finished\t\t\t\t\t\twhile (!taskExecutor.isTerminated()) {\t\t\t\t\t\t}\t\t\t\t\t\tbreak;\t\t\t\t\t}\t\t\t\t}\t\t\t} else {\t\t\t\tSystem.out\t\t\t\t\t\t.println(\"The asynchronous server-socket channel cannot be opened!\");\t\t\t}\t\t} catch (IOException ex) {\t\t\tSystem.err.println(ex);\t\t}\t}} 输出： Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Do something else while reading ...Read done: trueBytes read: 18hello,filechannelRead operation status ...Error:java.nio.channels.AsynchronousCloseExceptionDo something else while writing ...Do something else while writing ...Do something else while writing ...Written done: trueBytes written: 51Waiting for the file to be locked ...Waiting for the bytes to be written ...I’ve written 100 bytes into store.txt locked file!Counting sheep while filling up some buffers!So far I counted: 1Counting sheep while filling up some buffers!So far I counted: 2Counting sheep while filling up some buffers!So far I counted: 3Counting sheep while filling up some buffers!So far I counted: 4Counting sheep while filling up some buffers!So far I counted: 5Counting sheep while filling up some buffers!So far I counted: 6Counting sheep while filling up some buffers!So far I counted: 7Counting sheep while filling up some buffers!So far I counted: 8Counting sheep while filling up some buffers!So far I counted: 9Counting sheep while filling up some buffers!So far I counted: 10Counting sheep while filling up some buffers!So far I counted: 11Done! Here are the buffers:java.lang.InterruptedExceptionWaiting for connections ...","title":"java7 NIO2(8)The Asynchronous Channel API 异步通道API"},{"content":"       用timer实现的定时任务工具类，有registerDelay和register俩个方法，一个是延迟任务，一个是立即执行的方法。该定时器依赖于flash的Enterframe帧频，请注意。使用前请调用init方法初始化。如有不足请指出。 package com.core.timer{\timport flash.display.Sprite;\timport flash.display.Stage;\timport flash.events.Event;\timport flash.utils.Dictionary;\timport flash.utils.getTimer;\t/**    \t * 定时器\t * @author yuebinbin\t * @date 2012-12-30\t * */\tpublic class EnterframeTimer extends Sprite\t{\t\t/** 注册的任务集合 */\t\tprivate var _dic:Dictionary;\t\t/** 任务数量 */\t\tprivate var _count:int;\t\tprivate static var _instance:EnterframeTimer;\t\t\t\tpublic function EnterframeTimer()\t\t{\t\t\tif (_instance != null) {\t\t\t\tthrow new Error();\t\t\t}\t\t}\t\t\t\tpublic static function getInstance():EnterframeTimer\t\t{\t\t\tif (_instance == null) \t\t\t{\t\t\t\t_instance = new EnterframeTimer();\t\t\t}\t\t\treturn _instance;\t\t}\t\t\t\t/** \t\t * 初始化\t\t * */\t\tpublic function init(stage:Stage):void\t\t{\t\t\t_dic = new Dictionary();\t\t\t_count = 0;\t\t\tstage.addEventListener(Event.ENTER_FRAME, execute);\t\t}\t\t\t\tprivate function execute(e:Event):void\t\t{\t\t\tvar timer:int = getTimer();\t\t\tfor each(var obj:Object in _dic) \t\t\t{\t\t\t\tif (obj[\"delayTime\"] == 0 && obj[\"flag\"])\t\t\t\t{\t\t\t\t\tobj[\"fun\"](obj[\"args\"]);\t\t\t\t\tobj[\"times\"] = obj[\"times\"] - 1;\t\t\t\t\tobj[\"flag\"] = false;\t\t\t\t} \t\t\t\telse \t\t\t\t{\t\t\t\t\tif (timer - obj[\"registerTime\"] <= obj[\"delayTime\"] && obj[\"flag\"]) \t\t\t\t\t{\t\t\t\t\t\tcontinue;\t\t\t\t\t}\t\t\t\t\tif (timer - obj[\"registerTime\"] >= obj[\"interval\"])\t\t\t\t\t{\t\t\t\t\t\tobj[\"registerTime\"] = timer;\t\t\t\t\t\tobj[\"fun\"](obj[\"args\"]);\t\t\t\t\t\tobj[\"times\"] = obj[\"times\"] - 1;\t\t\t\t\t\tobj[\"flag\"] = false;\t\t\t\t\t}\t\t\t\t}\t\t\t\t\t\t\t\tif (obj[\"times\"] == 0) \t\t\t\t{\t\t\t\t\tdelete _dic[obj[\"key\"]];\t\t\t\t}\t\t\t}\t\t}\t\t\t\t/**\t\t * 注册任务\t\t * @para interval:间隔时间， times：执行次数， fun:执行函数\t\t * */\t\tpublic function register(interval:int = 1000, times:int = 1, fun:Function = null, ...args):int\t\t{\t\t\tvar key:int = -1;\t\t\tif (fun != null) \t\t\t{\t\t\t\tvar _obj:Object = new Object();\t\t\t\tkey = ++_count;\t\t\t\ttrace(_obj);\t\t\t\ttrace(_obj[\"fun\"]);\t\t\t\t_obj[\"registerTime\"] = getTimer();\t\t\t\t_obj[\"fun\"] = fun;\t\t\t\t_obj[\"interval\"] = interval;\t\t\t\t_obj[\"times\"] = times;\t\t\t\t_obj[\"args\"] = args;\t\t\t\t_obj[\"delayTime\"] = 0;\t\t\t\t_obj[\"flag\"] = true;\t\t\t\t_obj[\"key\"] = key;\t\t\t\t_dic[key] = _obj;\t\t\t}\t\t\treturn key;\t\t}\t\t\t\t/**\t\t * 注册延迟任务\t\t * @para interval:间隔时间， times：执行次数， delayTime：延迟时间， fun:执行函数\t\t * */\t\tpublic function registerDelay(interval:int = 1000, times:int = 1, delayTime:int = 0, fun:Function = null, ...args):int\t\t{\t\t\tvar key:int = -1;\t\t\tif (fun != null) \t\t\t{\t\t\t\tvar _obj:Object = new Object();\t\t\t\tkey = ++_count;\t\t\t\t_obj[\"registerTime\"] = getTimer();\t\t\t\t_obj[\"fun\"] = fun;\t\t\t\t_obj[\"interval\"] = interval;\t\t\t\t_obj[\"times\"] = times;\t\t\t\t_obj[\"args\"] = args;\t\t\t\t_obj[\"delayTime\"] = delayTime;\t\t\t\t_obj[\"flag\"] = true;\t\t\t\t_obj[\"key\"] = key;\t\t\t\t_dic[key] = _obj;\t\t\t}\t\t\treturn key;\t\t}\t\t\t\t/**\t\t * 移除任务\t\t * */\t\tpublic function unregister(key:int):void\t\t{\t\t\tif (key != -1) \t\t\t{\t\t\t\tdelete _dic[key];\t\t\t}\t\t}\t\t/**\t\t * 销毁计时器\t\t * */\t\tpublic function destroy():void\t\t{\t\t\t_dic = null;\t\t\tthis.removeEventListener(Event.ENTER_FRAME, execute);\t\t}\t}} 测试代码： package{\timport com.core.timer.EnterframeTimer;\t\timport flash.display.Sprite;\timport flash.utils.getTimer;\t\tpublic class test extends Sprite\t{\t\tpublic function test()\t\t{\t\t\tEnterframeTimer.getInstance().init(this.stage);\t\t\tEnterframeTimer.getInstance().register(2000,3,function():void{\t\t\t\ttrace(\"#####################\" + getTimer());\t\t\t});\t\t}\t}} 代码输出结果：","title":"AS3定时任务管理工具类"},{"content":"         现在是12月31日16：27分，离2013年还有7小时33分，时间真的很快，不知不觉自己就快23了！         今天想写点东西纪念一下这大学时光里的点点滴滴～          回想在经贸大学的这两年半时间里，一个人收获了很多，，，很多，，，          依稀记得2010，那一年，背着两个大包一个人第一次来到陌生的北方上学，那时候一切都觉得很美好，一个宿舍一块军训，一块吃饭，喝个小酒，一块讨论着班上的那些美女～现在依稀能记得那些零碎的记忆。。。真的很美好！如今大三了，没什么大的事情一般宿舍几个哥们根本聚不到一块了,,,还有就是胖子搬出去住了，说要考司法，丫的～刚开始，感觉很不习惯，现在已经没有什么感觉了！那个时候没事就翘个课，出去聚个餐，那个时候对于时间没有什么概念，那时候翘课的代价是现在你得花几倍的时间去弥补。这让我想起了以前的那些话，你所有不曾料想的问题，都会随着时间的推移与你不期而遇；你所有曾经潇洒的随遇而安，同样也会随时间流逝而让你承担那些似乎命中已经注定的代价。神啊～           大一暑假没有回家，进了实验室，好好在实验室补了一下。感觉自己在实验室呆的那一个月，能比过一个学期的课程，那个时候好好学习了c++,mfc。            哎呀，怎么没什么可写的了，这估计是我在大学里面第一篇自己写博文了，，，呵呵！发现自己现在不会写东西了，这是一个很严重的问题，我发现计算机专业的学生普遍不太会写文章。            大一转眼就过去了，好快，，，，，         对于大二，我现在的记忆是每天都会有各种活动，学生会，运动会，社团，篮球队，那一年我也忘了我参加过多少次聚餐，每次必定会喝醉，没想到酒量就是这么练出来的～哈哈，我就不说了，你懂的！大二重要的一些课却没有好好上，数据结构，这么课程真的相当重要，最后只能从头开始看，一点一点的看，大三这个学期我又去上了这半个学期，感觉现在懂的挺多。大二没有回家，依然留在实验室，大二暑假开始使劲赶。           大二的那个暑假应该是我大学里面的算是一个小小的转折点吧！从那时候开始学习Linux，那个时候实验室就只要一个学长在学，而且没有老师带，一个人慢慢的，刚开始接触Linux真的很有意思！那些绚丽的界面，有趣的命令，那个暑假老师给了我一块ARM11的开发板，刚开始真的不知从和下手，感觉太难了，但后来真的喜欢上了那块开发板了，当你自己把Android系统，linux系统，烧写进开发板的时候，那种成就感，你懂的。。。对于linux一路学下来，从命令到服务器搭建，从linux下c编程 到shell编程，从vi到Emacs，从进程通信到多线程，从linux网络编程到图形界面编程，从linux内核到linux到嵌入式，现在在一点一点的深入下去，我知道嵌入式很难，但我不会放弃的！现在我感觉自己的编程能力比以前好多了，没有什么技巧，就是每天不停的敲代码，看别人的优秀程序，模仿他们，改进他们，最后完全掌握他们。我觉得什么事情都应该植根与大脑深处，因为只有那样，那种技能学识才是真正属于自己的！              要像白痴一样的做一件事情，决定不能过分依赖于别人，假如那个人不再出现在你面前，你会感到很无助的！再也不会像以前那样总是动不动就问别人～            大三过的很平淡，很平淡，晚上再也不会去打什么台球了，这个学期连篮球都没有怎么碰，更别说搞对象了，大三都很忙，因为再不努力一把，以后真的会留下很多遗憾的～这个学期，四点一线：实验室—食堂--寝室--教室。几乎所有的空闲时间都在实验室度过了，每天学习一点，虽然我基础不太好，但我始终相信天道酬勤，终于一天我也会称为高手的，因为我热爱编程，热爱Linux，热爱嵌入式，热爱c/C++,热爱JAVA。我也常常想，我是否适合编程，以后踏入社会是否能够从事自己喜欢的工作，有时也有烦躁的时候，郁闷的时候，有时候累了，疲倦了，我就会叫上红刚出去喝点小酒，玩玩，告诉自己一切都会好起来的！现在不努力，将来连努力的机会都没有了。我又想起了不知是csdn上那个大侠说的：当你打算放弃梦想的时候，告诉自己再多撑一天，一个星期，一个月，再多撑一年吧！等到繁华落尽的时候，你会发现，拒绝退场的结果，是一种怎样的美好！                         我们的逝去乔大叔说了“你的时间有限，所以不要为别人而活，不要被教条所限，不要活在别人的观念里，不要让别人的意见左右自己内心的声音。最重要的是勇敢的去追随自己的心灵和直觉，只有自己的心灵和直觉才知道你自己的真实想法，其他一切都是次要的！”                   再说说csdn吧，真的很感谢它！让我在里面学习了很多东西，感觉csdn高手太多了，自己感觉是一只小小的菜鸟。也正因为那些个牛人，才让我现在疯狂的学习，现在在补充各种知识，真的涨见识了。我相信终会有一天我会超越他们其中一部分的！              总之，2012这一年我付出了，努力了，奋斗了，不过结果如何，我都没有什么遗憾了！我知道：只有一条路不能选择，那就是放弃的路，再长的路，一步步也能走完；再短的路，不迈开双脚也无法到达，只有不断寻找寻找机会的人才能把握机会；不同的信念决定不同的命运～最苦难的时候也许就是离成功不远了               最后，后天就要开始期末考试了，来吧，微机原理，来吧，软件工程，都来吧，Java,计算机网络！           丫的，考完你们，哥就要做火车回家了，回江西了，哈哈，亲们，等着我啊，回家去吃腊肉了！       ","title":"纪念一下我两岁半的大学生活"},{"content":"   从上面继承图层来看，了解Buffer很重要。   Buffer=数据+四个索引   正是四个索引才是的数据可以高效访问，这四个索引是：mark（标记），position（位置），limit（界限），capacity（容量）。   不变式 标记、位置、限制和容量值遵守以下不变式： 0 <= 标记 <= 位置 <= 限制 <= 容量     以下是设置和复位索引以及查询的方法：                              capacity() ：返回此缓冲区的容量。                                   clear() ：清除此缓冲区。                                      flip() ：反转此缓冲区。                                     limit() ：返回此缓冲区的限制。                    limit(int newLimit) ：设置此缓冲区的限制。                                    mark() ：在此缓冲区的位置设置标记。                                position() ：返回此缓冲区的位置。           position(int newPosition) ：设置此缓冲区的位置。                              remaining() ：返回当前位置与限制之间的元素数。                                     reset() ：将此缓冲区的位置重置为以前标记的位置。                                  rewind() ：重绕此缓冲区。 通过代码查看： package org.com.mayi;import java.nio.ByteBuffer;import java.nio.CharBuffer;public class Test_ByteBuffer {\tstatic int capacity1,limit1,position1;\t/**\t * @param args\t */\tpublic static void main(String[] args){\t\tbyte[] b = \"my test\".getBytes();//获取字节数组\t\tByteBuffer bytebuffer =ByteBuffer.allocate(15);//定义一个buffer，并为之分配容量。\t\tbytebuffer.put(b);//把字节放进buffer\t\t\t\t  capacity1 = bytebuffer.capacity();//返回buffer容量\t\t  limit1 = bytebuffer.limit();//返回buffer界限\t\t  position1 = bytebuffer.position();//返回buffer位置\t\t  /*没有设置mark（标记）， */\t\t System.out.println(\"容量：\"+capacity1+\"    界限：\"+limit1+\"   位置： \"+position1+\"    mark:\"+\"需要自己设置\");\t\t \t\t//反转此缓冲区，从结果来看，我们知道，capacity不变，limit=position  ；position=0；\t     //此时的buffer感觉就像队列一样，先进先出。\t\t bytebuffer.flip();\t\t capacity1 = bytebuffer.capacity();\t\t  limit1 = bytebuffer.limit();\t\t  position1 = bytebuffer.position();\t\t System.out.println(\"容量：\"+capacity1+\"    界限：\"+limit1+\"   位置： \"+position1+\"    mark:\"+\"需要自己设置\");\t\t \t\t //重绕此缓冲区，其实就是相当于刷新一下，通知buffer做好读或写的准备，并没有什么改变。\t\t bytebuffer.rewind();\t\t capacity1 = bytebuffer.capacity();\t\t  limit1 = bytebuffer.limit();\t\t  position1 = bytebuffer.position();\t\t System.out.println(\"容量：\"+capacity1+\"    界限：\"+limit1+\"   位置： \"+position1+\"    mark:\"+\"需要自己设置\");\t}}   输出： 容量：15    界限：15   位置： 7    mark:需要自己设置容量：15    界限：7   位置： 0    mark:需要自己设置容量：15    界限：7   位置： 0    mark:需要自己设置    通过查看API文档，又找到一些官方解释：哈哈。。。 清除、反转和重绕 除了访问位置、限制、容量值的方法以及做标记和重置的方法外，此类还定义了以下可对缓冲区进行的操作： clear() 使缓冲区为一系列新的通道读取或相对放置 操作做好准备：它将限制设置为容量大小，将位置设置为 0。 flip() 使缓冲区为一系列新的通道写入或相对获取 操作做好准备：它将限制设置为当前位置，然后将位置设置为 0。 rewind() 使缓冲区为重新读取已包含的数据做好准备：它使限制保持不变，将位置设置为 0。   理解了这四个索引的工作是很重要的，做到数据输入输出时，缓冲区在干什么，心中有数，不至于茫茫然，看别人的代码这样写，你也稀里糊涂的跟着写了。 如果有兴趣，可以查看《java编程思想》的NIO那一章，有很详细的解释，里面是图文结合，比我的好多了。我在这里写下，也只是做一个简单笔记罢了。。。","title":"缓冲器（Buffer）的细节"},{"content":"一、struts概述 1、Struts实现MVC设计模式 （1）Struts实质上就是在JSPModel2的基础山实现一个MVC框架。      1）模型：由业务实现业务逻辑的JavaBean或EJB组件构成      2）控制器：由ActionServlet和Action来实现      3）视图：由一组JSP文件构成 （2）Struts的结构：   2、Struts的工作流程 （1）Web应用启动时加载并初始化ActionServlet，ActionServlet从struts-config.xml中读取配置信息，把它们存放到各种配置对象中。 （2）当ActionServlet接收到一个客户请求时，检索和用户请求匹配的ActionMapping实例，如果不存在，就返回用户请求路径无效的信息。 （3）如果ActionForm实例不存在，就创建一个ActionForm对象，把客户提交的表单数据保存到ActionForm对象中。 （4）根据配置信息决定是否需要表单验证。如果需要验证，就调用ActionForm的validate()。 （5）ActionForm的validate()方法   ①如果返回null或返回一个不包含ActionMessage的ActionErrors对象，就表示表单验证成功。   ②如果返回一个包含一个或多个ActionMessage的ActionErrors对象，就表示表单验证失败，此时ActionServlet将直接把请求转发给包含用户提交表单的JSP组件。在这种情况下，不会再创建Action对象并调用Action的execute()方法。 （6）ActionServlet根据ActionMapping实例包含的映射信息决定将请求转发给哪个Action。如果相应的Action实例不存在，就先创建这个实例，然后调用Action的execute()方法。 （7）Action的execute()方法返回一个ActionForward对象，ActionServlet再把客户请求转发给ActionForward对象指向的JSP组件。 （8）ActionForward对象指向的JSP组件生成动态网页，返回给客户。 二、Struts 1.2 构成 1、struts运行需要的jar包 （1）commons-digester.jar  用于解析配置文件 （2）commons-fileupload.jar  用于实现文件上传（进行了进一步的封装） （3）commons-logging.jar 用于日志处理 （4）commons-beanutils.jar 用于POJO的属性赋值、拷贝等 （5）commons-validator.jar 用于表单验证 2、 struts标记库文件（tld） （1）struts-bean.tld （2）struts-html.tld （3）struts-logic.tld （4）struts-nested.tld （5）struts-tiles.tld 3、配置文件struts-config.xml <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE struts-config PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 1.2//EN\" \"http://struts.apache.org/dtds/struts-config_1_2.dtd\"> <struts-config>   <data-sources />     <form-beans>      <form-bean name=\"xxx\" type=\"ActionForm的类全名\">      <form-bean name=\"LoginForm\" type=\"basic.LoginForm\">   <\/form-beans>   <global-exceptions />   <global-forwards />    <action-mappings > <action path=\"action的路径，在form的action中写的那个路径\"  type=\"Action的类全名\" name=\"form的名字\" scope=\"request|session(默认值)\">         <forward name=\"在自定义的Action中使用的findForward方法的参数\" path=\"跳转页面的路径\" redirect=\"false\"（重定向，默认false）/> <\/action>   <\/action-mappings>   <message-resources parameter=\"资源文件的名字（不加后缀）\" /> <\/struts-config> 4、资源文件   <message-resources parameter=\"ApplicationResources\" >   <\/message-resources> 使用资源文件的步骤： （1）确认资源文件的jar导入 （2）引入标记库 <%@tagliburi=\"/WEB-INF/struts-bean.tld\" prefix=\"bean\" %> （3） 使用： ApplicationResources.properties文件以“消息key、消息文本”格式存放数据 eg. ApplicationResources.properties中： jsp.user=username test.jsp中： <bean:message key=\"jsp.user\"/> 注意：ApplicationResources.properties文件不支持中文，如果想在页面中展示中文只能把中文转为unicode码，命令：native2ascii 原文件名 目标文件名。 国际化：按照浏览器所要求的语言选择资源文件。前面相同，后缀不同。 eg.   <message-resources parameter=\"ApplicationResources\" >  <\/message-resources>  资源文件名为：ApplicationResources_zh.properties(中文)                ApplicationResources_en.properties(英文)  也可以加上国家名    ApplicationResources_zh_CN.properties(中文)    ApplicationResources_en_US.properties(英文) 注意：资源文件的选择：首先查找和浏览器语言匹配的资源文件，如果找不到则找和服务器的语言地区相匹配资源文件，如果还是找不到就查找默认不带语言后缀的资源文件。 三、Struts1.2核心控制流程 1、主要组件： （1）ActionServlet组件：充当Struts框架的中央控制器 （2）RequestProcessor组件：充当每个子应用模块的请求处理器 （3）Action组件：负责处理一项具体的业务。 2、ActionServlet （1）Struts的启动通常从加载ActionServlet开始（如果没有其他Servlet的加载优先级比它高）。ActionServlet在应用一加载时即会被实例化并调用其init方法。 （2）init方法所做的主要工作有：    ①加载struts配置文件，并创建用于封装配置信息的ModuleConfig对象    ②加载资源文件，并创建用于封装资源文件的MessageResources对象。 另外，如果有相应配置的话，init方法还将初始化数据源和PlugIn  注意：   1）如果web.xml有多模块配置，将创建多个ModuleConfig对象和MessageResources对象分别用于封装各个模块的struts配置文件和资源文件。  eg.  多模块：   <init-param>       <param-name>config<\/param-name>       <param-value>/WEB-INF/struts-config.xml<\/param-value>   <\/init-param>     <!-- config后面的/ma表示模块名，访问ma模块里的配置文件的action中的url路径位：应用路径/模块名/url.do  -->    <init-param>       <param-name>config/ma<\/param-name>       <param-value>/WEB-INF/ma/struts-config.xml<\/param-value>    <\/init-param>  <init-param>       <param-name>config/mb<\/param-name>       <param-value>/WEB-INF/mb/struts-config.xml<\/param-value>      <\/init-param> 或者   <init-param>     <param-name>config<\/param-name>     <param-value>/WEB-INF/struts-config.xml<\/param-value>   <\/init-param>   <init-param>     <param-name>config/catalog<\/param-name>     <param-value>/WEB-INF/ma-struts-config.xml<\/param-value>   <\/init-param>   <init-param>     <param-name>config/authorize<\/param-name>     <param-value>/WEB-INF/mb-struts-config.xml<\/param-value>   <\/init-param>   2）针对各个模块所创建的ModuleConfig对象和MessageResources对象将存储在ServletContext中，对应的属性名中有该模块名称的相应标识。  （3）ActionServlet的process()方法的主要工作有： 1）根据请求信息获知所请求的模块名称，从ServletContext中获得与请求模块对应的的 ModuleConfig对象，并存储到request中。  2）根据模块信息获得相应的RequestProcessor对象，一个模块对应一个RequestProcessor 对象，RequestProcessor对象将关联与所属模块对应的ModuleConfig对象。  3）调用RequestProcessor对象的process方法，将request和response作为参数传递给它。 3、RequestProcessor类 （1）Struts框架只允许应用中存在一个ActionServlet类，但每个应用程序模块都有各自的RequestProcessor类实例。 （2）RequestProcessor对象的process方法的主要工作： 1）调用自己的 processPreprocess(request, response)方法，该方法不进行任何操作，用于 子类重写扩展其功能。  2）获得与请求地址所匹配的ActionMapping对象，AcionMapping对象用于封装一个特 定acion的配置信息。  3）根据ActionMapping中的配置信息获得ActionForm对象（该对象将缓存到request 或session中），并将表单数据填充到ActionForm中，然后根据ActionMapping的配置决 定是否验证ActionForm，如果验证，将调用ActionForm的validate方法，若其返回的 ActionErros对象中包含ActionMessage对象则表示验证失败，将转向action配置信息input 属性所指示的地址。  4）如果ActionForm无需验证或验证通过将创建并缓存与请求地址匹配的Action对象， 将ActionMapping对象、ActionForm对象、request和response作为参数调用其execute 方法。  5）根据Action对象的execute方法返回的ActionForward对象，将请求转发或重定向到 该ActionForward所封装的地址。   4、Action类 （1）Action类是用户请求和业务逻辑之间的桥梁 （2）ActionServlet对所有的请求作集中的统一处理，每个不同的Action类具体处理不同的请求。 （3）每个Action类都需要实现execute()方法，RequestProcessor类创建一个Action实例后，就会调用其execute()方法。 （4）struts-config.xml： <action-mappings>    <action path=”/ 路径，当请求时×××.do时 FC就调用该Action的execute方法” type=”Action类的名称（包名.类名）”name=”该Action关联的ActionForm的名称”    <!--如果有，则FC在调用execute方法之前要获得ActionForm对象（第一次调用该Action时创建，然后从request或者session）并且用请求参数对其填充，然后将（ActionForm对象）作为参数调用execute方法 -->     attribute=” 缓存ActionForm对象的名称（key），不写key就是name的值” scope=” 缓存ActionForm的范围（request|session）默认是session” validate=”是否要验证true|false”    <!--如果是true，则FC在填充ActionForm之后，调用Action的execute之前，会验证该ActionForm对象（一种是调用validate方法，另外一种是使用validation框架）-->      input=”” 和validate=”true” 联用，表示验证失败后，FC把请求转向的地址  parameter=”” 是一个附加的属性，对于不同的Action可能有不同的意义    <!--封装该Action可能转发（重定向）的地址信息-->   <forward name=”” 该forward的名称(用于mapping.findForward方法) path=”” 地址必须以“/”开头 redirect=”” 表示是否重定向/>    … … …    <\/ action >  <\/action-mappings> 5、内置的Struts Action类 （1）目的   1）减少Action类的数目   2）便于代码的维护 （2）DispatchAction   1）特点：  ①DispatchAction 类是Action 类的子类；  ②共享同一个Action 的路径；  ③共享一个ActionForm，多个不同action path，可以在同一个类中。  2）DispatchAction 的写法：   public class MyDispatchAction extends DispatchAction{ActionForward login(ActionForm form,HttpServletRequest request,HttpServletResponse response,ActionMapping mapping)throws Exception {     return mapping.findForward(“sucess”)；     }   } 注意：不要覆盖execute()方法 3）DispatchAction 的配置文件：   <action path=\"/dispatch\" type=\" MyDispatchAction \" parameter=\"method\">     <forward name=\"sucess\" path=\"/ message.jsp \"/>   <\/action> 注意：parameter 属性是和表单中隐藏域的名字相对应的 4）DispatchAction 页面：   <form action=“${pageContext.request.contextPath}/dispatch.do\" method=\"post\">     <input type=\"hidden\" name=\"method\"  value=“login\"/>     <!--、使用隐藏域为struts 传递要调用的自定义Action 中方法的名字，通过与strutsconfig.xml 中action 标签的parameter 属性相对应来获取隐藏域的value。-->     <input type=\"submit\" value=\"submit\"/> <\/form> <a href=\"${pageContext.request.contextPath}/dispatch.do?method=login\">Login<\/a> （3）MappingDispatchAction  1）特点： ① MappingDispatchAction 类是DispatchAction 的子类 ②可以匹配多个action 路径 ③可以不共享同一个ActionForm 2）MappingDispatchAction 的写法 public class MyMappingDispatchAction extends MappingDispatchAction{ ActionForward login(ActionForm form,HttpServletRequest request, HttpServletResponse response,ActionMapping mapping) throws Exception{ return mapping.findForward(“success\") } } 3）MappingDispatchAction 的配置文件 <action path=\"/mapping/login\" type=\" MyMappingDispatchAction \"  parameter=“login\"> <forward name=“success\" path=\"/message.jsp\"/> <\/action> 注意：parameter 属性是指定调用方法的名字 4）MappingDispatchAction 页面 <form action=“${pageContext.request.contextPath}/mapping/login.do\" method=\"post\"> <input type=\"submit\" value=\"submit\"/> <\/form> 注意：在JSP 页面中不需要再使用隐藏域来传递参数了，在form 中的action 就可以 直接使用xxx.do 匹配了。 （4）LookupDispatchAction   1）特点：  ①LookupDispatchAction 类也是DispatchAction 类的子类。  ②解决一个表单的多个同名提交按钮的问题。  ③通过使用资源文件，用submit 按钮的value 来作为资源文件中的key 所对应的值，通 过这个值来找到对应的key，再使用这个key 来获得指定Map 中所对应的值，这个值就 是要调用的方法名。 注意：在继承LookupDispatchAction 时，要覆盖getKeyMethodMap()方法，并定义Map， 向Map 中放入指定的键值对。 2）LookupDispatchAction 的写法 public class TestLookupDispatchAction extends LookupDispatchAction { public ActionForward login(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response)throws Exception{ return mapping.findForward(\"success\"); } public ActionForward register(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response)throws Exception{ return mapping.findForward(\"register\"); } public Map getKeyMethodMap() { Map map = new HashMap(); //key 为资源文件的key 值，value 为action 中的方法名。 map.put(\"submit.login\", \"login\"); map.put(\"submit.register\", \"register\"); return map; } } 3）LookupDispatchAction 资源文件 MessageResource.properties文件中?  submit.login=login submit.register=register 4）LookupDispatchAction 的配置文件：    <form-beans >    <form-bean name=\"lookupForm\" type=\"form.LookupForm\" /> <\/form-beans> <action-mappings>      <action path=\"/lookup\" name=\"lookupForm\" type=\"action.TestLookupDispatchAction\" parameter=\"submit\"> <forward name=\"success\" path=\"/jsp/success.jsp\"/> <forward name=\"register\" path=\"/jsp/register.jsp\"/> <\/action> <\/action-mappings> <message-resources parameter=\"MessageResource\" /> 5）LookupDispatchAction 页面： <html:form action=\"/lookup\"  styleId=\"lookupForm\"  styleClass=\"lookupForm\">  userName:<html:text property=\"name\" /><br>  password:<html:password property=\"pwd\" redisplay=\"false\" />  <br>  <br>  <html:submit property=\"submit\">   <bean:message key=\"submit.login\" />  <\/html:submit>  <html:submit property=\"submit\">  <bean:message key=\"submit.register\" />  <\/html:submit> <\/html:form> 注意：页面中的property=\"submit\"与struts-config.xml中action的parameter元素值相同 四、ActionForm 1、为什么使用form？ （1）用户提交的数据封装成对象 （2）表单数据的缓存。 （3）表单信息验证（服务器端验证） 2、ActionForm的生命周期 （1）ActionForm Bean有两种存在范围：request和session 1）如果存在于request范围，它仅在当前的请求/响应生命周期中有效 2）如果存在于session范围，同一个ActionForm实例在整个Http会话中有效 注意：在struts配置文件中，<action>元素的scope属性用来设置ActionForm的范围， 默认值为session。   3、配置ActionForm （1）action和form的关系是：一对多 （2）struts-config.xml <form-beans>  <form-bean name=\"userForm\" type=\"form.UserForm\"/>  … … …  <\/form-beans>  （3）在某一个Action的配置中可以写：  <action path=\"/add\" type=\"action.AddUserAction\" name=\"userForm\"/> 4、Form验证 （1）验证： 1）表单级验证：（不访问数据库） ①JavaScript做的是客户端验证，可以减少服务器端的负担，但不够安全 ②在服务器端的Form验证避免跳过客户端的校验 2）业务逻辑验证： 由Action负责完成 （2）validator()方法 1）调用的条件： ①Form继承ActionForm，并且为ActionForm配置了Action映射，即<form-bean>元素的name属性和<action>元素的name属性匹配。 ②<action>元素的validate属性为true 2）validate()方法 该方法返回ActionErrors对象，如果返回的ActionErrors对象为null，或者 不包含任何ActionMessage对象，就表示没有错误，数据验证通过。如果ActionErrors中包含ActionMessage对象，就表示发生了验证错误。 3）validate()方法主要负责检查数据的格式和语法，而不负责数据是否符合业务逻辑。 （3）Validator框架（验证框架） 1）validate()方法验证的局限性： ①必须通过程序代码来实现验证逻辑，如果验证逻辑发生变化，必须重新编写和编译 程序代码 ②当系统中有多个ActionForm Bean，并且它们包含一些相同的验证逻辑时，开发人员必须对每个ActionForm Bean进行重复编程，完成相同的验证逻辑，这会降低代码的可重用性。 2）主要依赖的jar文件：  ①jakart-oro.jar：提供了一组处理文本的类，具有文本替换、过滤和分割等功能  ②commons-validator.jar：提供了一个简单、可扩展的验证框架，包含了通用的验证方 法和验证规则。 3）条件：  ①validator-rules.xml validation.xml  ②struts-config.xml 写plug-in  <plug-in className=\"org.apache.struts.validator.ValidatorPlugIn\">         <set-property property=\"pathnames\"           value=\"/WEB-INF/validator-rules.xml,                   /WEB-INF/validation.xml\"/>   <\/plug-in> ③Form必须继承ValidatorForm（ActionForm子类） 4）validator-rules.xml中规定了常见的验证需求。一般不需要改变。 5）validation.xml是form验证的配置文件。 <form-validation> <formset> <form name=\"需要验证的form的名，如果有attribute属性重命名，此处 使用重命名。\">  <field property=\"name\" depends=\"required\">  <!--property属性表示要验证的form对象的属性名-->  <!--depends属性表示要适用的验证逻辑（required是validator-rules.xml中规 定的验证方式。） 如果depends属性包含多个验证规则，则用“，”隔开。 如果调用depends属性指定的验证规则时验证失败，就不会再调用下 一个规则。-->  <arg0 key=\"form.username\" />  <!-- validator-rules.xml中的每一个验证逻辑 都对应res文件中的key（key所对应的值是出错信息） 但是出错信息有占位符（{0},{1},{2},…）, arg0表示填充出错信息中，{0}占位符的信息…  注意：实际填充的是key所指字符串在res文件中所对应的值-->  <\/field>  <\/form>  <\/formset>  <\/form-validation> 切记：Validator框架不能用于验证标准的ActionForm类。如果要使用Validator框架， 应该采用ActionForm类的两个子类：DynaValidatorForm（支持动态ActionForm）和ValidatorForm（支持标准ActionForm）。 5、动态ActionForm （1）ActionForm 的缺点：表单的改动会触发FormBean 的大量改动（应用程序停器，而且 FromBean 维护量大）。 （2）动态FormBean 是指，Struts 已提供给我们DynaActionForm(是ActionForm 的子类)，我们只需通过配置文件进行配置。 （3）DynaActionForm的写法： ①struts-config.xml <form-bean name=\"dynaActionForm\"  type=\"org.apache.struts.action.DynaActionForm\">      <form-property name=\"name\" type=\"java.lang.String\" />      <form-property name=\"age\" type=\"java.lang.Integer\"/> <\/form-bean> 注意：Type 表示属性类型，注意若为基本类型时要用其包装类。 <action path=\"/dyna\" name=\"dynaActionForm\"    type=\"action.TestDynaActionFormAction\" scope=\"request\"> <forward name=\"success\"  path=\"/jsp/testDynaActionForm_success.jsp\"><\/forward>  <\/action> ②TestDynaActionForm.jsp     <h1> 测试DynaActionForm<\/h1>     <hr>     <form action=\"dyna.do\" method=\"post\">      姓名：<input type=\"text\" name=\"name\"/> <br>      年龄：<input type=\"text\" name=\"age\" /> <br>      <input type=\"submit\" value=\"保存\"> <br>   <\/form> ③TestDynaActionFormAction.java public class TestDynaActionFormAction extends Action { @Override public ActionForward execute(ActionMapping mapping,  ActionForm form,HttpServletRequest request,  HttpServletResponse response) throws Exception { DynaActionForm daf = (DynaActionForm) form; String name = (String)daf.get(\"name\"); //取daf中的值 Integer age = (Integer)daf.get(\"age\"); System.out.println(\"name:\" + name + \" <===> age:\" + age); return mapping.findForward(\"success\"); } } ④testDynaActionForm_success.jsp（取DynaActionForm的值） <center>     <h1>测试动态ActionForm<\/h1>     <hr>     姓名：${dynaActionForm.map.name } <br>     年龄：${dynaActionForm.map.age }<br> <\/center> （3）访问动态ActionForm 与访问普通ActionForm 的最大区别：属性的访问方式不同。 1）普通ActionForm—— getter setter 方法。 2）动态ActionForm—— DynaActionForm 把所有属性保存在Map 中。 public Object get(String name) public void set(String name, Object value) 注意：DynaActionForm 的校验不太方便。需要继承DynaActionForm，但是写了代码又不能满足动态的功能了。 五、异常处理： 1、处理流程： （1）Action ? throw Exception （2）Action Servlet ? ExceptionHandler （3）ExceptionHandler 处理Exception ExceptionHandler 会读配置文件 ActionMessage -> request Attribute ActionForward （4）ActionServlet ActionForward 2、配置struts 的异常处理 全局的异常处理 <global-exceptions> <exception key=\"error\" path=\"xxx/xxx\" type=\"xxx.xxx.Xxxx\"> <\/global-exceptions> <action path=\"xxx/xxx\" type=\"xxx.xxx.Xxxx\"> .... <exception key=\"xxx\" path=\"xxx/xxx\" type=\"xxx.xxx.Xxxx\"> <\/action> 在exception 标签中的key，也就是在出现异常时会封装在ActionErrors 中，也就是可以在页面中使用。 ActionError(String key, Object value0)，可以通过在构造ActionError 时，指定不同的key 值来对异常进行分类，并且在html:error 标签的自己构造ActionErrors 并使用下面的方法发送void saveErrors(HttpServletRequest request,ActionErrors errors)这个方法用以把封装了异常的ActionErrors 的key 存储到request 中。 六、Struts标签库 1、html标签库 （1）<html:form> 对应html 中的<form>，使用<html:form>会将表单中的属性自动封装成Form，他的action属性可以直接写struts 的配置文件中的path （2）<html:text>、<html:password>、<html:textarea>、<html:hidden>、<html:submit> <html:reset>、<html:checkbox>、<html:radio>、<html:select>、<html:option> 以上者写标签的使用是和html 中的form 相对应的。 （3）<html:options>这个标签用来表示一组选择项 <% java.util.ArrayList list=new java.util.ArrayList(); list.add(new org.apache.struts.util.LabelValueBean(\"show value\",\"value\")); list.add(new org.apache.struts.util.LabelValueBean(\"show value1\",\"value1\")); pageContext.setAttribute(\"vlauelist\" list); %> <html:form action=\"xxx.do\"> <html:select property=\"test\"> <html:options collection=\"valuelist\" property=\"value\" labelProperty=\"label\"/> <\/html:select> <\/html:form> 2、Bean标签库 （1）bean 标签库，是用来访为JavaBean 的属性或者是为Bean 的属性赋值，创建JavaBean，类似于JSP 中的jsp:useBean 动作的功能。 （2）bean 标签库中的标签中大部分都有以下的属性： 1）id=\"xxx\" 指定Bean 的名字标识,Bean 在被读出后将引用保存在以这个id 命名的对象中，也就是在JSP 中使用的变量的引用。 2）name=\"xxxx\"指定要读取Bean 的名字 3）property=\"xxxx\" 4）scope=\"page|request|session|application\" （3）资源读取标签 1）<bean:resource>读取资源文件 2）<bean:cookie>使用这个标签可以对Cookie 进行操作 3）<bean:header>读取header 信息 eg. <bean:resource id=\"indexpage\" name=\"index.jsp\"/> <bean:write name=\"indexpage\"/> <bean:head id=\"head\" name=\"user-agent\"/> <bean:write name=\"head\"/> <bean:cookie id=\"testcookie\" name=\"/taglib/bean-cookie\" value=\"emptyValue\"/> <% if(testcookie.getValue.equals(\"emptyValue\")){ javax.servlet.http.Cookie cook= new javax.servlet.http.Cookie(\"/taglib/beancookie\",\"taglib cookie\"); cook.setComment(\"test\"); cook.setMaxAge(3600); response.addCookie(cook); } %> （4）将资源写到页面的标签 1）<bean:write>将Bean 的属性加入到输出流中 <bean:write name=\"xxx\"/>name 属性是要加入的资源，也就是先前在其他资源标签中的 id 属性定义的名字 2）<bean:define>定义变量 eg. <bean:define id=\"test\" value=\"test in Struts\"> <bean:write name=\"test\"/> 3）<bean:message>读取消息，可以根据key 读取消息。 eg. <bean:message key=\"org.test\"> 七、Struts的Token（令牌）机制 1、Struts 使用Token 机制，来防止恶意的破坏和重复提交问题，也就是点击后退后在再提 交，这是Struts 无法发现的，在form 中生成一个token 码，在session 中也保存有一个同样 的token 码，当表单提交后，判断两个token 码向等后，就会改变session 中的这个token 码， 当然在用回退后，form 的token 码是不会变的，在提交，还会判断两个token 码是否相等， 如果不等就会抛出异常，证明这是过时的垃圾数据。 2、方法： （1）void saveToken(HttpServletRequest request)方法用于将在客户端生成的token 码，保存在session 中。 （2）void resetToken(HttpServletRequest request)方法用于重置token 码，生成新的token 码。 （3）boolean isTokenValid(HttpServletRequest request,boolean reset)判断token 码是否相等，并且是否重置token 码。reset 是设定是否重置token 码，一般设为true。 3、设置token 码 public ActionForward toadd(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response)throws Exception{ saveToken(request); return mapping.findForward(\"next\"); } 4、验证token 码 public ActionForward add(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response)throws Exception{ if(isTokenValid(request, true)){ request.setAttribute(\"message\", \"contratulation!\"); } else { request.setAttribute(\"message\", \"sorry\"); } return mapping.findForward(\"next\"); } 注意：在使用Struts 的Token 时需要讲JSP 页面的<form/>标签改成<html:form/>标签 八、Tiles框架 1、Tiles 是一个框架，他实现了页面的复合视图，页面代码中不仅有数据，也有页面的布局格式。 2、要在基于Struts 应用中使用Tiles 框架，就要在struts-config.xml 中配置 <plugin className=\"org.apache.struts.tiles.TilesPlugin\"> <set-property property=\"definintions-config\"  value=\"/WEB-INF/tiles-defs.xml\"> <!--定义tiles 布局文件tiles-defs.xml--> <\/plugin> 3、 tiles 的布局配置文件tiles-defs.xml <tiles-definitions> <!-- 页面基本布局--> <definition name=\"pms_base\" path=\"/common/pms_layout.jsp\"> <put name=\"title\" value=\"pms title\" /> <put name=\"header\" value=\"/common/header.jsp\" /> <put name=\"body\" value=\"some body page\" /> <put name=\"footer\" value=\"/common/footer.jsp\" /> <\/definition> <!-- 其他页面定义--> <definition name=\"add\" extends=\"pms_base\"> <put name=\"title\" value=\"add\" /> <put name=\"body\" value=\"/person_add.jsp\" /> <\/definition> <\/tiles-definitions> 4、在struts-config.xml 中要把forward 的配置更改一下 <action path=\"/person/toadd\" type=\"alan.pms.action.PersonAction\" name=\"personForm\" scope=\"request\" parameter=\"toAdd\"> <forward name=\"add\" path=\"add\"/> <\/action> 这样就会使页面加上header.jsp 和footer.jsp 显示在配置好的页面中 5、在页面中使用tiles 标签时， 要引入标签库，  <%@taglib uri=\"/WEB-INF/tiles.tld\" prefix=\"tiles\"%> <tiles:insert page=\"xxx.jsp\"> <tiles:put name=\"header\" value=\"header.jsp\"> <tiles:put name=\"footer\" value=\"footer.jsp\"> <\/tiles:insert> 在struts-config.xml 中要把forward 的配置更改一下 <action path=\"/person/toadd\" type=\"alan.pms.action.PersonAction\" name=\"personForm\" scope=\"request\" parameter=\"toAdd\"> <forward name=\"add\" path=\"add\"/> <\/action> 练习题： 1、在Struts框架中，简述Struts是怎样实现MVC模型的。 答：Struts提供了下面这些组件使用MVC开发应用程序：     Model：Struts没有提供model类。这个商业逻辑必须由Web应用程序的开发者以JavaBean 或EJB的形式提供;     View：Struts提供了ActionForm创建Form Bean, 用于在controller和view间传输数据;     此外，Struts提供了自定义JSP标签库，辅助开发者用JSP创建交互式的以表单为基础的应 用程序;     应用程序资源文件保留了一些文本常量和错误消息，可转变为其它语言，可用于JSP中。     Controller：Struts提供了一个action serlvet，接收JSP输入字段形成ActionForm然后调用一个action class。 2、Struts中ActionForm和Action属于MVC的哪一层,为什么?ActionForm的功能有哪些 答：ActionForm的功能： 封装表单数据 提供数据验证方法 提供把属性重新设置位默认值的方法 3、请简单画出Struts技术构建MVC的流程图。 答：见本次串讲的一个图","title":"温习一下Struts1.2x"},{"content":"#include <stdio.h> #define VALIDATE_IS_STRING(f) do{ \\ while ((c = getc(f)) != EOF) {    \\  if (validate_character_is_space(c)) { \\            if (word) {   \\                wcount++; \\            } \\            word = 0; \\        } else if((c >= 65 && c <= 90) || (c >= 97 && c <= 122)) { \\            word = 1; \\        } \\    } \\}while(0) #define PRINTI(x)   printf(\"The words number  is: %d\\n\", x) static FILE * open_file_by_filename(char *filename) { FILE *fp= NULL; if ((fp = fopen(filename, \"r\")) == NULL) {  printf(\"Can not open file, please check your filename!\\n\");  return (NULL); } return (fp);} static unsigned int validate_character_is_space(int ch) { return (unsigned int)(ch - 9) < 5u || ch == ' ';} static int get_string_number_in_file(FILE *filename) { int i = 0, iterate = 1; register int c; register int word = 0; long int wcount = 0; VALIDATE_IS_STRING(filename); return (wcount);} int main(int argc, char **argv) { FILE *fd; int count; if (argc < 2|| argc >=3) {  printf(\"Invalid argument,please set right argument !\\n\");  return (-1); } if ((fd = open_file_by_filename(argv[1])) == NULL)  return (-1); count = get_string_number_in_file(fd); PRINTI(count); fclose(fd); return (0);}","title":"统计大容量文本里面单词的函数（方法）"},{"content":"#include <iostream>#include <cstdio>#include <cstring>#define INF 0x7fffffff#define maxn 100using namespace std;int n, m;int edge[maxn][maxn];int lowcost[maxn];int nearvex[maxn];void prim(int u0) {    int i, j;    int sumweight = 0;    for( i = 1; i <= n; i++ ) {        lowcost[i] = edge[u0][i];        nearvex[i] = u0;    }    nearvex[u0] = -1;    for( i = 1; i <= n; i++ ) {        int minx = INF;        int v = -1;        for( j = 1; j <= n; j++ ) {            if( nearvex[j] != -1 && lowcost[j] < minx ) {                v = j;                minx = lowcost[j];            }        }        if( v != -1) {            printf( \"%d  %d  %d\\n\", nearvex[v], v, lowcost[v] );            nearvex[v] = -1;            sumweight += lowcost[v];            for( j = 1; j <= n; j++ ) {                if( nearvex[j] != -1 && edge[v][j] < lowcost[j] ) {                    lowcost[j] = edge[v][j];                    nearvex[j] = v;                }            }        }    }    printf(\"weight of MST if %d\\n\", sumweight);}void input() {    int i, j;    memset(edge, 0, sizeof(edge));    scanf(\"%d%d\", &n, &m);    int u, v, w;    for( i = 1; i <= m; i++ ) {        scanf(\"%d%d%d\", &u, &v, &w);        edge[u][v] = edge[v][u] = w;    }    for( i = 1; i <= n; i++ ) {        for( j = 1; j <= n; j++ ) {            if( i== j ) { edge[i][j] = 0 ; }            else if(edge[i][j] == 0 ) {                edge[i][j] = INF;            }        }    }}int main(){    int start = 0;    input();    scanf(\"%d\", &start);    prim(start);    return 0;}/************************测试数据：7 91 2 281 6 102 3 162 7 143 4 124 5 224 7 185 6 255 7 243***************************/","title":"prim(最小生成树）"},{"content":"  定义完善的变量： 数据类型和作用域 表义性强的变量名，来说明这些变量 必须赋予焦点 5.1编程原则 有焦点的变量：服务于一个定义明确的目的 无焦点的变量：用于多个目的的变量 焦点的变量 为变量赋予表义性强的名字 增强可读性 淘汰故意缩短的变量名 避免Temp，临时变量，暂时性变量 变量名中混合使用大小写字母 Dim strFirst_Name As String 只对常用变量名和长变量名进行缩写,最长不超过32个字符 缩写规则: 一致性,前后统一 选用表义性强的缩写 对变量名中公用部分缩写，专用部分不应缩写 使用统一的量词 变量名结尾处，使用标准化量词： Dim strCustomerFirst As String Dim strCustomerLast As String Dim strCustomerPrevious As String   显式说明变量 建议：显示说明变量 如：Dim、Private、Public或Static 显示按钮：Explicit Option 最佳数据类型，减少内存需求，加快执行速度，降低出错可能，不同数据类型影响计算结果   数字计算： 防止溢出错误     遵循规则： 存储任何类型的文本，String数据类型，包含任何有效的键盘字符，包括数字和非字母字符 存放True和False这两个值，Boolean数据类型 存放不包含小数位、大于或等于－32768、小于或等于32767的数字，用Integer 存放不带小数位的数字，但是数字值大于或小于Integer数据类型允许的值，Long 包含小数位的数字，Single 大于Single数据类型能够存放的数字，Double 存放美元金额，请使用Currency数据类型 存放日期或时间值，请使用Date 只有在绝对必要时，Variant 变量的作用域，对于过程和模块来说它的可视性，应尽量缩小（降低错误率，防止占用资源） 作用域等级，即：过程作用域、模块作用域、全局作用域","title":"第五章 命名约定——《数据库编程标准规范》"},{"content":"先看代码： #include <windows.h>#define showdbg(str) \\{\\\tMessageBoxA(0,#str,\"\",0);\\};class A{\tpublic:\t\tA()\t\t{\t\t\tshowdbg(\"fuckme\");\t\t}\t\t~A()\t\t{\t\t\tshowdbg(\"end\");\t\t}\t\tvoid dosth()\t\t{\t\t\tshowdbg(\"something\");\t\t}};A a;void main(){\ta.dosth();}  如果采用了默认的编译和链接方式，结果是三个消息框。 但是我想看看这个全局对象a，是怎么初始化的。 编译： cl /c /EHsc msg.cpp  链接： link /entry:main /subsystem:windows /nodefaultlib msg.obj 出现错误：提示未找到_atexit 原因猜测，全局对象它并不会无缘无故地在真正的main函数之前自己初始化。它需要利用到crt函数中的atexit注册某些函数（可能是析构函数）   再使用正常的编译方法： cl msg.cpp 生成 msg.exe 在调试器中观察，发现全局对象的初始化过程是这样的： 在CRT中，msvcrt.dll 调用了链接器默认库(/nodefaultlib)中的_pre_cpp_init函数（这个函数的会被默认编译进入你的程序）。 just so. 所以书上说的全局对象会在MAIN函数之前自动构造，其实是错误的。它不是自动构造的，是CRT帮你做的。    ","title":"c++全局对象的构造时机 by Mr.瑞"},{"content":"【转载】http://www.blogjava.net/bacoo/archive/2009/06/22/283480.html 对模板特化的理解： 特化整体上分为全特化和偏特化，这一点大家都没有什么置疑，但是细分它们各包括哪几种状态就很难界定了，而且很多权威的书上都不一致，管它呢，反正我们能会用各种特化就可以了。 下面就谈谈我个人对特化的划分和定义： 所谓特化，就是将泛型的东东搞得具体化一些，从字面上来解释，就是为已有的模板参数进行一些使其特殊化的指定，使得以前不受任何约束的模板参数，或受到特定的修饰（例如const或者摇身一变成为了指针之类的东东，甚至是经过别的模板类包装之后的模板类型）或完全被指定了下来。 这是网上某个人的一些看法： 模板有两种特化，全特化和偏特化（局部特化） 模板函数只能全特化，没有偏特化（以后可能有）。 模板类是可以全特化和偏特化的。 全特化，就是模板中模板参数全被指定为确定的类型。 全特化也就是定义了一个全新的类型，全特化的类中的函数可以与模板类不一样。 偏特化，就是模板中的模板参数没有被全部确定，需要编译器在编译时进行确定。 在类型上加上const、&、*（ cosnt int、int&、int*、等等）并没有产生新的类型。只是类型被修饰了。模板在编译时，可以得到这些修饰信息。 我个人也比较赞同这位仁兄的划分，全特化的标志就是产生出完全确定的东西，而不是还需要在编译期间去搜寻适合的特化实现，貌似在我的这种理解下，全特化的东西不论是类还是函数都有这样的特点，template <>然后是完全和模板类型没有一点关系的类实现或者函数定义，如果你要说，都完全确定下来了，那还搞什么模板呀，直接定义不就完事了？但是很多时候，我们既需要一个模板能应对各种情形，又需要它对于某个特定的类型（比如bool）有着特别的处理，这中情形下就是需要的了。 既然刚才提到了全特化的标志，那么再说说其他一些共性的东西： 一个特化的模板类的标志：在定义类实现时加上了<>，比如class A<int, T>；而在定义一个模板类的时候，class A后面是没有<>的 全特化的标志：template <>然后是完全和模板类型没有一点关系的类实现或者函数定义 偏特化的标志：template <typename T.....>，就是说还剩下点东西，不像全特化<>整得那么彻底 首先推荐两个不错的网址： http://www.cnblogs.com/cutepig/archive/2009/02/12/1389479.html http://read.newbooks.com.cn/info/175115.html 先说类模板的特化吧： 谁都没的说的全特化： // general version template<class T> class Compare { public:     static bool IsEqual(const T& lh, const T& rh)     {         return lh == rh;     } }; // specialize for float template<> class Compare<float> { public:     static bool IsEqual(const float& lh, const float& rh)     {         return abs(lh - rh) < 10e-3;     } }; 谁都没的说的偏特化： template<class T1, class T2> class A { } template<class T1> class A<T1, int> { } 接下来的特化种类，到底划归到全特化还是偏特化，你自己看着办吧，不过大致就以下这些了，逃不出我们的手掌心了： 特化为引用，指针类型： // specialize for T* template<class T> class Compare<T*> { public:     static bool IsEqual(const T* lh, const T* rh)     {         return Compare<T>::IsEqual(*lh, *rh);     } }; 特化为另外一个类模板： // specialize for vector<T> template<class T> class Compare<vector<T> > { public:     static bool IsEqual(const vector<T>& lh, const vector<T>& rh)     {         if(lh.size() != rh.size()) return false;         else         {             for(int i = 0; i < lh.size(); ++i)             {                 if(lh[i] != rh[i]) return false;             }         }         return true;     } }; 混合型的： template<typename T1, typename T2> class X {...}; template<typename T> class X<vector<T>, int&> {...}; //至于这里怎么都把T2搞没了变成只依赖一个模板参数T了的问题，大家别着急，我来告诉你个本质的东西，把我这么三点就可以了：1.模板参数个数一致；2.只要template <...>里面有东西不是<>，比如typename T，那么特化时就得用到T；3.不进行任何对模板参数的修饰也是不行的，比如template<typename T> class<T>{...}，至少你也得搞个const T之类的吧，呵呵。下面是我搞出来的几种特殊情况，它们都是正确的： template<typename T1, typename T2> class X {}; template<typename T> class X<vector<T>, T&> {}; template<typename T> class X<vector<T>, int&> {}; template<> class X<vector<double>, int&> {}; template<typename T1, typename T2, typename T3> class X<map<T1,T2>, T3&> {}; 最后，还有一种超级牛X的，在tr1里面用以实现function的，以前我都没见过还可以这么玩的： template<typename T> class Y;//这是在声明一个类模板，既然声明了，以后就得按这个规矩来，在我们之前的编程经验里，可以重复声明一个东西没问题，但是为同一个东东重复声明出不同的东西就不可以了，因此你就不能再声明诸如template<typename T1, typename T2> class Y;这样的声明了；其实没有什么是不能声明的，既然我们可以声明变量，声明函数，声明类，那么当然我们也可以声明函数模板或者类模板的。 template<typename R, typename P1, typename P2> class Y<R (P1, P2)> {...};//针对带两个参数，有返回值的函数类型特化，这里R (P1,P2)是定义了一种类型，该类型是一个隐式的函数指针，返回R，参数为P1和P2，这种对函数指针的定义完全等同于R (*)(P1,P2)，但是前一种定义很不常见，大家一般是不会注意到这个地方的。 好了，说了不少关于类模板的特化了，下面再简要说说函数模板的特化： 函数模板的特化只能是全特化，而不能是偏特化，因此对于函数的特化就比较简单了，就是重新搞一遍就可以了，举几个例子如下： template <class T> T mymax(const T t1, const T t2) {    return t1 < t2 ? t2 : t1; } template <> const char* mymax(const char* t1,const char* t2) {    return (strcmp(t1,t2) < 0) ? t2 : t1; } 但是你不能这么搞： template <> bool mymax(const char* t1,const char* t2) {    return (strcmp(t1,t2) < 0); } 其实对于mymax这个模板函数的定义而言，是用一个模板参数控制了三个地方，那么你在特化的时候，就也需要用一个特定的类型修改那三处相应的地方，如果你非要返回bool，那么你只能再定义一个函数模板了： template <class T> bool mymax(const T t1, const T t2) {    return t1 < t2 ? t2 : t1; } 问题又来了，大家都知道函数重载是不关心返回值的，而只关心参数个数以及类型是否不一致，不一致就是重载，但是对于模板函数而言，这个规矩不再成立，因为任何与模板相关的东西都只是个架子放在那里而已，只要它符合语法规则就可以了，这些架子只是在有人要调用它们时才会发挥效力，也就是说，在编译的时候会为你搜寻合适的模板函数或者类，只要能找到就ok了，而且还要求是只找到一个，要是找到多个也不行，呵呵。 其实，对于函数而言，虽然不能偏特化，即不能再在函数名字后面像模板类一样搞个<typename T>出来，但是可以通过函数的重载（注意这里说的重载是指的模板重载，而不是普通意义的函数重载）变通的实现偏特化： template <typename T1, typename T2> bool mymax(T1 t1, T2 t2) {    return t1 < t2 ? t2 : t1; } template <typename T1> bool mymax(T1 t1, int t2) {    return t1 < t2 ? t2 : t1; } 再谈谈函数模板参数的推导，大致有以下几种方法，但是不管怎么推导，都必须得保证在调用函数前能确定模板函数的各个模板参数的类型。 template <typename T1, typename T2> T2 fun(T1 arg1, int arg2) {     T2 t2;     return t2; } 对于上面这种比较特殊的模板函数，你不能通过传递参数来自动得到所有模板参数的类型，因此你必须显示的指定T1和T2的类型，有两种方法可以实现此目的： int (*pfun)(double,int) = fun;//借用函数指针定义 cout<<pfun(12.2,11)<<endl; cout<<fun<int,double>(11, 3.2)<<endl;//直接指定类型 如果上述模板函数改为： template <typename T1, typename T2> T2 fun(T1 arg1, T2 arg2) {     return arg2; } 那么除了上述两种指定模板参数类型的方法之外，由于该模板函数参数的类型都可以借由其参数获得，因此我们省去指定模板参数这一步骤，而直接调用该模板函数： fun(23, 2.3); 最后，再谈谈非类型模板参数的问题，在《C++ Template》的第四章有介绍。 template<typename T, int LEN> struct stack {...}; template<int margin> int add(int x){return x+margin;} 上面两个例子分别对应了类和函数两种情形，有人说非类型的模板参数存在得毫无价值，实则不然，因为我们可以借由一个确定的数值来产生一种新的类型或者新的函数。对于上面两个例子，我觉得用非类型模板参数就很有意义，分别实现了让用户指定stack的大小以及指定需要增加的边际值，关于更多这方面的应用，大家可以在今后的开发过程中逐步发掘，此外，还很有必要强调一下对非类型模板参数的限制，不能使用浮点数、class类型的对象和内部链接对象（例如字符串常量\"hello world!\"）作为实参；它们可以是常整数（包括枚举值）或者指向外部链接对象的指针。 对外部链接对象的指针举个例子： template <char const* name> class MyClass {...}; extern char const s[] = ”hello”; MyClass<s> x;       //OK 好了，模板这块内容我先将这么多。 又从网上搞到点好东东，也贴在这里吧： 类模板： * 如果类模板中含有静态成员，那么用来实例化的每种类型，都会实例化这些静态成员。 * 两个靠在一起的模板尖括号（ > ) 之间需要留个空格，否则，编译器将会认为是在使用operator>>，导致语法错误。 * 特化的实现可以和基本类模板的实现完全不同。 * 类模板可以为模板参数定义缺省值，称为缺省模板实参，并且他们还可以引用之前的模板参数。 * 成员函数模版不能被声明为虚函数。 * 类模板不能和另外一个实体共享一个名称。 eg：   1         int C; 2  3         class C;    // ok,     4  5         int X; 6  7         template < typename T > 8  9         class X;    // error. 和变量X冲突 非类型模板参数： 在编译期或链接期可以确定的常值。这种参数的类型必须是下面的一种： a> 整型或枚举 b> 指针类型( 普通对象的指针，函数指针，成员指针 ) c> 引用类型( 指向对象或者指向函数的引用 ) 其他的类型目前都不允许作为非类型模板参数使用 今天又突然挖掘出来点好东东，贴在这里： template <typename t> void f(t t) {} //f1 template <> void f(int t) {} //f2 void f(int t) {} //f3 void f(char t) {} //f4 f(3); //invoke f3 f('3'); //invoke f4 /** caveat: f3 must be put after f2, or an error occurs: specialization of void f(T) [with T = int] after instantiation; notes: the compiler will use f3 as the instantiation for f1, and use f2 as the specialization for f1; rule: specialization must be before instantiation (*); Above we have discuss the template function, and then we'll focus on member template function. acronym: MTF(member template function); Firstly, you should pay attention to the rule: the specialization of MTF must be the outside of the class, i.e., inline should not be allowed. Secondly, specialization and instantiation still follow the rule (*). But you'd better put the instantiation outside of the class since specialization must be the outside of the class(the root cause is: if you wanna specialize a MTF, you should give compiler the defenition of the templcate firstly. But if you use the specialization as the inline method, the specialization will be anxious since you can put the defination of MTF outside of the class. As you know, the inline member function precedes the non-inline member function. So the compiler will chose the safest way to solve it, i.e., the specialization must be put outside of class declaration). */","title":"C++模板的特化"},{"content":"说起C++的模板及模板特化， 相信很多人都很熟悉 ，但是说到模板特化的几种类型，相信了解的人就不是很多。我这里归纳了针对一个模板参数的类模板特化的几种类型， 一是特化为绝对类型； 二是特化为引用，指针类型；三是特化为另外一个类模板。 这里用一个简单的例子来说明这三种情况： // general version template<class T> class Compare { public: static bool IsEqual(const T& lh, const T& rh) { return lh == rh; } }; 这是一个用于比较的类模板，里面可以有多种用于比较的函数， 以IsEqual为例。 一、特化为绝对类型 也就是说直接为某个特定类型做特化，这是我们最常见的一种特化方式， 如特化为float, double等 // specialize for float template<> class Compare<float> { public: static bool IsEqual(const float& lh, const float& rh) { return abs(lh - rh) < 10e-3; } }; // specialize for double template<> class Compare<double> { public: static bool IsEqual(const double& lh, const double& rh) { return abs(lh - rh) < 10e-6; } }; 二、特化为引用，指针类型 这种特化我最初是在stl源码的的iterator_traits特化中发现的， 如下： template <class _Iterator> struct iterator_traits { typedef typename _Iterator::iterator_category iterator_category; typedef typename _Iterator::value_type value_type; typedef typename _Iterator::difference_type difference_type; typedef typename _Iterator::pointer pointer; typedef typename _Iterator::reference reference; }; // specialize for _Tp* template <class _Tp> struct iterator_traits<_Tp*> { typedef random_access_iterator_tag iterator_category; typedef _Tp value_type; typedef ptrdiff_t difference_type; typedef _Tp* pointer; typedef _Tp& reference; }; // specialize for const _Tp* template <class _Tp> struct iterator_traits<const _Tp*> { typedef random_access_iterator_tag iterator_category; typedef _Tp value_type; typedef ptrdiff_t difference_type; typedef const _Tp* pointer; typedef const _Tp& reference; };   当然，除了T*, 我们也可以将T特化为 const T*, T&, const T&等，以下还是以T*为例： // specialize for T* template<class T> class Compare<T*> { public: static bool IsEqual(const T* lh, const T* rh) { return Compare<T>::IsEqual(*lh, *rh); } }; 这种特化其实是就不是一种绝对的特化， 它只是对类型做了某些限定，但仍然保留了其一定的模板性，这种特化给我们提供了极大的方便， 如这里， 我们就不需要对int*, float*, double*等等类型分别做特化了。 三、特化为另外一个类模板 这其实是第二种方式的扩展，其实也是对类型做了某种限定，而不是绝对化为某个具体类型，如下： // specialize for vector<T> template<class T> class Compare<vector<T> > { public: static bool IsEqual(const vector<T>& lh, const vector<T>& rh) { if(lh.size() != rh.size()) return false; else { for(int i = 0; i < lh.size(); ++i) { if(lh[i] != rh[i]) return false; } } return true; } }; 这就把IsEqual的参数限定为一种vector类型， 但具体是vector<int>还是vector<float>， 我们可以不关心， 因为对于这两种类型，我们的处理方式是一样的，我们可以把这种方式称为“半特化”。 当然， 我们可以将其“半特化”为任何我们自定义的模板类类型： // specialize for any template class type template <class T1>  struct SpecializedType { T1 x1; T1 x2; }; template <class T> class Compare<SpecializedType<T> > { public: static bool IsEqual(const SpecializedType<T>& lh, const SpecializedType<T>& rh) { return Compare<T>::IsEqual(lh.x1 + lh.x2, rh.x1 + rh.x2); } }; 这就是三种类型的模板特化， 我们可以这么使用这个Compare类： // int int i1 = 10; int i2 = 10; bool r1 = Compare<int>::IsEqual(i1, i2); // float float f1 = 10; float f2 = 10; bool r2 = Compare<float>::IsEqual(f1, f2); // double double d1 = 10; double d2 = 10; bool r3 = Compare<double>::IsEqual(d1, d2); // pointer int* p1 = &i1; int* p2 = &i2; bool r4 = Compare<int*>::IsEqual(p1, p2); // vector<T> vector<int> v1; v1.push_back(1); v1.push_back(2); vector<int> v2; v2.push_back(1); v2.push_back(2); bool r5 = Compare<vector<int> >::IsEqual(v1, v2); // custom template class  SpecializedType<float> s1 = {10.1f,10.2f}; SpecializedType<float> s2 = {10.3f,10.0f}; bool r6 = Compare<SpecializedType<float> >::IsEqual(s1, s2);","title":"C++类模板的三种特化类型"},{"content":"先看一下官网注释： Description Renders an custom UI widget using the specified templates. Additional objects can be passed in to the template using the param tags. Freemarker: Objects provided can be retrieve from within the template via $parameters.paramname. Jsp: Objects provided can be retrieve from within the template via <s:property value=\"%{parameters.paramname}\" /> In the bottom JSP and Velocity samples, two parameters are being passed in to the component. From within the component, they can be accessed as:- Freemarker: $parameters.get('key1') and $parameters.get('key2') or $parameters.key1 and $parameters.key2 Jsp: <s:property value=\"%{parameters.key1}\" /> and <s:property value=\"%{'parameters.key2'}\" /> or <s:property value=\"%{parameters.get('key1')}\" /> and <s:property value=\"%{parameters.get('key2')}\" /> Currently, your custom UI components can be written in Velocity, JSP, or Freemarker, and the correct rendering engine will be found based on file extension. Remember: the value params will always be resolved against the ValueStack so if you mean to pass a string literal to your component, make sure to wrap it in quotes i.e. value=\"'value1'\" otherwise, the the value stack will search for an Object on the stack with a method of getValue1(). (now that i've written this, i'm not entirely sure this is the case. i should verify this manana)   If Jsp is used as the template, the jsp template itself must lie within the webapp itself and not the classpath. Unlike Freemarker or Velocity, JSP template could not be picked up from the classpath. templateDir and theme attribute The final path to the template will be built using the templateDir andtemplate attributes, like ${templateDir}/${theme}/${template}. If for example your component is under /components/html/option.jsp, you would have to set templateDir=\"components\", theme=\"html\" and template=\"options.jsp\". For any Struts tag that you use in your component, make sure that you set its templateDir=\"template\" ------------------------------------------------------------------------------------------------------------------------------------- self.tld: <?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE taglib PUBLIC \"-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.2//EN\" \"http://java.sun.com/dtd/web-jsptaglibrary_1_2.dtd\"><taglib>\t<tlib-version>1.0<\/tlib-version>\t<jsp-version>1.2<\/jsp-version>\t<short-name>map<\/short-name>\t<tag>\t\t<name>self<\/name>\t\t<tag-class>servlet.SelfDefinationTag<\/tag-class>\t\t<body-content>JSP<\/body-content>\t<\/tag><\/taglib> 释义：定义了self标签，self标签的处理类为SelfDefinationTag，它是JSP模板文件。 SelfDefinationTag.jsp: <%@ page language=\"java\" pageEncoding=\"gb2312\"%><!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"><%@taglib prefix=\"s\" uri=\"/struts-tags\"%><html>   <body>      <s:component template=\"/components/image.jsp templateDir=\"MyTemplate\" theme=\"xhtml\" />   <\/body><\/html> 释义：Struts2中的component标签是用来方便开发者定义自己开发的标签。（component:组件；template:模板） 这里定义了一个新的JSP文件，在该文件中使用component标签来调用image.jsp这个模板文件。 templateDir：定义模板文件所在的根目录名，若不显示声明则默认为\"template\"; theme：定义主题，若不显示声明则默认为\"xhtml\"。 因此，若templateDir和theme都不声明，则系统调用的模板文件就是/template/xhtml下的模板文件。 image.jsp: <%@ page language=\"java\"  pageEncoding=\"gb2312\"%><%@ taglib uri=\"Self\" prefix=\"s\" %><!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"><html>  <body>      <s:self><\/s:self>  <\/body><\/html> 释义：自定义标签<s:self>，具体的标签含义在下面的SelfDefinationTag标签处理类。 SelfDefinationTag.java: package servlet;import java.io.IOException;import javax.servlet.ServletContext;import javax.servlet.http.HttpServletRequest;import javax.servlet.jsp.JspException;import javax.servlet.jsp.JspWriter;import javax.servlet.jsp.tagext.TagSupport;public class SelfDefinationTag extends TagSupport {\tprivate static final long serialVersionUID = 1L;\tString contextPath;\t\tpublic int doStartTag() throws JspException {\t\t\t\t JspWriter out = pageContext.getOut();\t\t try{\t\t\t out.println(\"<img src=\\\"..\\\\validateImage\\\"/>\");\t\t }catch (IOException ioe1){\t\t\t ioe1.printStackTrace();\t\t }\t\t\t\t\t\treturn EVAL_BODY_INCLUDE  ;\t}\tpublic String getContextPath( HttpServletRequest req ) {\t      String servletPath = req.getServletPath();\t      ServletContext servletContext = pageContext.getServletContext();\t      String realPath = servletContext.getRealPath( servletPath );\t      int lastSlash = realPath.lastIndexOf( System.getProperty( \"file.separator\" ) );\t      if ( lastSlash > -1 ) {\t         String contextPath = realPath.substring( 0, lastSlash + 1 );\t         return contextPath;\t      }\t      return \"\";\t   }\t} 释义：通过实现Struts2的TagSupport接口定义了一个标签处理类，重写了doStartTag()方法。这个自定义标签只是插入了一段HTML图像代码。 注意<img src=\"../validateImage\" />其中的“../”不能掉，这和Html中访问不同单独目录要加“../”是一样的道理。 ValidateImage.java: package servlet;import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.image.BufferedImage;import java.io.IOException;import java.io.OutputStream;import java.util.Random;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.sun.image.codec.jpeg.JPEGCodec;import com.sun.image.codec.jpeg.JPEGEncodeParam;import com.sun.image.codec.jpeg.JPEGImageEncoder;public class ValidateImage extends HttpServlet {\t\tprotected void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{\tresponse.setContentType(\"image/jpeg\");\tcreateImage(response.getOutputStream());\tresponse.setHeader(\"Pragma\",\"No-cache\");\tresponse.setHeader(\"Cache-Control\",\"no-cache\");\tresponse.setDateHeader(\"Expires\", 0);\t}\t\tprivate void createImage(OutputStream out)throws IOException\t{\t\tint width=60, height=20;\t\tBufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\t\tGraphics g = image.getGraphics();\t\tRandom random = new Random();\t\tg.setColor(getRandColor(200,250));\t\tg.fillRect(0, 0, width, height);\t\tg.setFont(new Font(\"Times New Roman\",1,15));\t\t//g.setColor(new Color());\t\t//g.drawRect(0,0,width-1,height-1);\t\tg.setColor(getRandColor(160,200));\t\tfor (int i=0;i<155;i++)\t\t{\t\t\tint x = random.nextInt(width);\t\t\tint y = random.nextInt(height);\t\t        int xl = random.nextInt(12);\t\t        int yl = random.nextInt(12);\t\t\tg.drawLine(x,y,x+xl,y+yl);\t\t}\t\t//String rand = request.getParameter(\"rand\");\t\t//rand = rand.substring(0,rand.indexOf(\".\"));\t\tString sRand=\"\";\t\tfor (int i=0;i<4;i++){\t\t    String rand=String.valueOf(random.nextInt(10));\t\t    sRand+=rand;\t\t    g.setColor(new Color(20+random.nextInt(110),20+random.nextInt(110),20+random.nextInt(110)));\t\t    g.drawString(rand,13*i+6,16);\t\t}//\t\tsession.setAttribute(\"rand\",sRand);\t\tg.dispose();\t\tJPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out);\t\tJPEGEncodeParam param \t= encoder.getDefaultJPEGEncodeParam(image);\t\tparam.setQuality(1.0f, false);\t\tencoder.setJPEGEncodeParam(param);\t\t\t\ttry{\t\t\tencoder.encode(image);\t\t}catch (IOException ioe){\t\t\tioe.printStackTrace();\t\t}\t}\t\tColor getRandColor(int fc,int bc){        Random random = new Random();        if(fc>255) fc=255;        if(bc>255) bc=255;        int r=fc+random.nextInt(bc-fc);        int g=fc+random.nextInt(bc-fc);        int b=fc+random.nextInt(bc-fc);        return new Color(r,g,b);        }\t\t\t\t\t} 释义：生成动态数字图的servlet类，在web.xml中也有该servlet的映射定义。 struts.xml: <?xml version=\"1.0\" encoding=\"gb2312\"?><!DOCTYPE struts PUBLIC\"-//Apache Software Foundation//DTD Struts Configuration 2.0//EN\"\"http://struts.apache.org/dtds/struts-2.0.dtd\"><struts>\t<package name=\"C05.7\" extends=\"struts-default\">\t\t<\/package><\/struts> web.xml: <?xml version=\"1.0\" encoding=\"GB2312\"?><web-app >\t<servlet>\t\t<servlet-name>ValidateImage<\/servlet-name>\t\t<servlet-class>servlet.ValidateImage<\/servlet-class>\t<\/servlet>\t<servlet-mapping>\t\t<servlet-name>ValidateImage<\/servlet-name>\t\t<url-pattern>/validateImage<\/url-pattern>\t<\/servlet-mapping>\t<filter>\t\t<filter-name>struts2<\/filter-name>\t\t<filter-class>\t\t\torg.apache.struts2.dispatcher.FilterDispatcher\t\t<\/filter-class>\t<\/filter>\t\t<filter-mapping>\t\t<filter-name>struts2<\/filter-name>\t\t<url-pattern>*.action<\/url-pattern>\t<\/filter-mapping>\t    <filter-mapping>        <filter-name>struts2<\/filter-name>        <url-pattern>*.jsp<\/url-pattern>    <\/filter-mapping>\t<welcome-file-list>\t\t<welcome-file>index.jsp<\/welcome-file>\t<\/welcome-file-list>\t<taglib>\t\t<taglib-uri>Self<\/taglib-uri>\t\t<taglib-location>/WEB-INF/tlds/self.tld<\/taglib-location>\t<\/taglib><\/web-app> 注意过滤器<filter-mapping>中不能用<url-pattern>/.*<\/url-pattern>，这点一定要注意。   地址栏输入：http://localhost:8080/C05.7/jsp/SelfDefinationTag.jsp 输出结果为：","title":"Struts2 自定义标签(JSP视图)实现图形验证功能"},{"content":"技术只有落实到工程当中才显得那么有血有肉，之前学J2SE的时候运算符这块没有多在意，前一段时间实现权限管理模块的时候才发觉位运算符内有乾坤。笔者在这里进行简单总结，希望对读者有用。 Java支持的位运算符： &：按位与。 |：按位或。 ~：按位非。 ^：按位异或。 <<：左位移运算符。 >>：右位移运算符。 <<<：无符号右移运算符。 这四个运算符比较常见，也比较简单总结如下表所示： 第一个运算符 第二个运算符 按位与 按位或 按位异或 0 0 0 0 0 0 1 0 1 1 1 0 0 1 1 1 1 1 1 0 PS：对于异或运算符大家可能觉得不太容易记忆（记是永远记不住的），其实前人早就总结了异或的规律，如下所述。 异或：又称半加法运算，例如1异或1可以当成二进制下的1+1=10然后取最后一位，正好是异或的结果，0+0、1+1、0+1同理。 运算原理： 前四种位运算符是比较简单的，只需要按位进行逻辑运算即可例如5&9（结果为1）的执行过程如下： 再比如~-5（结果为4）的执行过程如下： 其他运算（|、~、^）同理。 后面的移位运算相对前面的有些复杂，但是细细研究还是很好理解的。 -5<<2（结果为-20）的执行过程如下: -5>>2执行过程如下： -5>>>2的运算过程 通过上面的过程可以看出，只要被移位的二进制码没有发生有效位的数字丢失（对于正数而言，通常指被移出的位全部都是0），不难发现左移n位就相当于乘以2的n次方，右移则是处以2的n次方。还有一点就是进行移位运算不会改变操作数本身，它只是得到了一个新的运算结果，而原来的操作数本身是不会发生改变的。 学而有感： 很多时候学习一些基础的东西总觉得没有意思，甚至感觉有些东西是没有用的。 比如刚接触电脑学习键盘的时候认为end和home键是没什么用的，后来代码敲的多了才发现前人发明这两个键是多么的伟大，这两个键不知为整个人类提高了多少效率。还有这次学习Java的位运算符也是一个典型的例子，当年没觉得这个位运算符有什么用（有点儿鸡肋的感觉），做完了权限模块才发觉它的妙处（具体如何妙用参见我的另一篇博客）。类似的情况还有很多，比如学操作系统、计算机组成、数据结构等等这些基础课程的时候总觉得它们与自己写代码没有多大关系，但是一旦遇到了问题（大数据量，高并发）的时候利用这些“没用”的课程分析代码效率，分析系统资源总能让问题迎刃而解。 不要怀疑现有知识（课程、技术）或者事物的有用性，“存在即合理”如果没用早就被前人淘汰了。用不到某个知识和知识本身无关，不要觉得现在自己用不到就是无用的，现在用不到只能说明自己的水平还不够，要做的就是建立一个“索引”随用随学随研究，如此足矣。","title":"Java中的位运算符"},{"content":"注：本程序为原创，若发现bug，万望指出，若有问题，欢迎交流，转载请指明出处。若能有助于一二访客，幸甚。 以下为结果截图，显示的LOGO为小篆字体的欢迎 baby os 加载完成...几个字。 保护模式 参考资料： 《Intel 64 and IA-32 Architectures Software Developer's Manual》 《Orange's 一个操作系统的实现'》 《X86/X64 体系探测及编程》 《30天自制操作系统》 《Linux 内核完全剖析》 0.概述 Intel IA 32下，CUP有两种工作模式：实模式和保护模式。打开PC，开始时CPU工作在实模式下，即此前几篇东西写的代码都是在实模式下的。 实模式下有16位的寄存器、16位的数据总线、及20位的地址总线，1MB的寻址能力。物理地址的计算方法： 物理地址（Physical Address） = 段值（Segment）* 16 + 偏移值(Offset) 其中段和偏移都是16位的。 从80386开始，Intel的CPU 进入32位时代，80386有32位地址总线，寻址能力达到4GB. 保护模式保护处理器的某些资源不能被随意访问，如处理器的硬件资源和系统的软件资源，如CR0等控制寄存器，GDT、IDT等系统级的数据结构，OS kernel的代码和数据等。 x86的segmentation和paging即分段和分页机制是实施保护措施的手段。分段和分页实行了不同的内存管理模式和访问控制。 1.权限和环境 4个权限级别：0～3，0为最高级别。 3种权限类型：CPL、DPL、RPL： 1）CPL（current privilege level）：当前的权限级别，指示当前代码在哪个权限级别，CPL的值存放在CS寄存器Selector域的RPL。（另外，SS寄存器的Selector的RPL总等于CPL）。 2）DPL（Descriptor Privilege Level）：DPL存放在描述符Descriptor（包括段描述符Segment Descriptor和门描述符Gate Descriptor）里的DPL域，它指示访问这些segment所需要的权限级别 3）RPL（Requested Privilege Level）：存放在访问者所使用的选择子Selector的Bit0和Bit1，指示发起访问的访问者使用什么样的权限对目标进行访问。 若CPL > DPL表示当前运行的代码的权限级别不足，不能对segment或gate进行访问。 从实模式进入保护模式，段式管理机制必须建立，分页机制是可选的，当分页机制关闭时，从段式内存管理中得到的线性地址（linear address）就是物理地址。 2.段式管理所使用的资源 硬件资源： 1）CR0、CR4 2）GDTR、LDTR（可选）、IDTR、TR 3）段选择子寄存器：ES、CS、SS、DS、FS、GS寄存器 数据结构： 1）GDT、LDT（可选）、IDT 2）TSS 3）段描述符（Segment Descriptor）：系统(System)段描述符、代码(Code)/数据(Data)段描述符 4）门描述符（Gate Descriptor）：包括调用门（Call-gate），中断/陷阱门（Interrupt/Trap-gate）和任务门（Task-gate） 5）选择子（Selector）：存放在段寄存器里。 分段机制的内存管理职责：从逻辑地址（Logic address）转换为处理器的线性地址(Linear address). 3.分页机制使用的资源： 1）控制寄存器：CR0、CR2、CR3、CR4 2）IA32_EFER 页转换表： 1）PDPT（Page Directory Pointer Table） 2）PDT（Page Directory Table） 3）PT（Page Table） 分页机制内存管理职责：从处理器的线性地址（即virtual address）映射到物理地址。 read/write的内存设备RAM（DRAM）、read-only的内存设备ROM（EPROM），及memory mapped I/O设备都可以映射到物理地址空间上。 典型的ROM设备映射到物理地址空间的高端和低端，Video和IGD设备的buffer映射到A0000H到BFFFFH的物理地址空间，PCIe等设备映射到物理地址空间的E0000000位置上，I/O APIC 设备映射到FEC00000以上的位置，等等。 经过页式转换形成的物理地址，可以映射到DRAM或外部存储设备Disk上。 4.段式内存管理 两方面的管理： 1）内存管理：为地址的转换提供基础 Linear Address = base + offset 与实模式下的原理是一致的，实模式下段的base = selector << 4; 保护模式下，base从segment descriptor里加载而来。 2）保护措施：对访问行为的控制 对段的limit、type、privilege检查 5.段式管理的数据结构 1）段选择子（Segment Selector） RPL：bit0～bit1，请求访问者所使用的权限级别 TI：Table Indicator，描述符表索引位,bit2, TI=0表示GDT，TI=1表示LDT。 Index：Descriptor Index，它是Descriptor在GDT/LDT中的序号。bit3~bit15,13位，范围0～8191，即可寻址8192个descriptor。 2）描述符表（Descriptor Table） Segment Selector用于在Descriptor Table中查找descriptor。 描述符表由描述符表寄存器进行定位，对应GDT，LDT，IDT有GDTR，LDTR，IDTR。在IA32中，这三个寄存器都是48位，包括低16位为Limit和髙32位为Base，加载描述符表方法为lgdt, lldt, lidt。 其中Limit用于检查Selector是否超出GDT的limit，如同数组的长度一样，判断数组是否越界。 3）段描述符（Segment Descriptor） 段描述符要么存放在描述符表里，要么被加载到段寄存器里。被加载到段寄存器后，它所描述的段变成了active状态。 描述符有两大类：段描述符和门描述符。 6.切换到保护模式 Intel推荐的步骤： 1）关中断，包括可屏蔽中断和不可屏蔽中断 2）使用lgdt加载GDTR 3）置cr0 的PE位，切换到保护模式 4）使用far jmp/call，提供一个同级权限的CS Selector更新CS寄存器 5）若需要使用LDT，用lldt加载LDTR 6）使用ltr加载TR 7）更新SS、DS寄存器 8）使用lidt加载IDTR 9）开中断 程序源码： boot.s: #--------------------------------------------------------------# 文件：boot.s# 描述：1.清屏#\t\t2.设置显示模式为0x103（800*600，256色）#\t\t3.读取软盘，将内核加载到内存#\t\t4.将内核第一个扇区(load.s)移动到内存0x0000位置#\t\t5.将引导扇区中的GDT及新显示模式的一些参数移动到指定位置#\t\t6.开启A20总线，置位cr0寄存器的PE位，进入保护模式# 时间：2012-12-29 21:47:12# 作者：guzhoudiaoke@126.com#--------------------------------------------------------------.include \"include/kernel.inc\".section .text.global _start.code16_start:\tjmp\t\tmain#---------------------------------------------------------------# 清屏：#\t设置屏幕背景色，调色板的索引0指代的颜色为背景色#\t先不考虑效率，只考虑可读性，故ah，al分开赋值#---------------------------------------------------------------clear_screen:\t\t\t\t# 清屏函数\tmovb\t$0x06,\t%ah\t\t# 功能号0x06\tmovb\t$0,\t\t%al\t\t# 上卷全部行，即清屏\tmovb\t$0,\t\t%ch\t\t# 左上角行\tmovb\t$0,\t\t%ch\t\t# 左上角列\t\tmovb\t$24,\t%dh\t\t# 右下角行\tmovb\t$79,\t%dl\t\t# 右下角列\tmovb\t$0x07,\t%bh\t\t# 空白区域属性\tint\t\t$0x10\t\tret#--------------------------------------------------------------------# 设置显示模式：#\t1.检查VBE是否存在，即显卡是否支持VESA BIOS EXTENSION#\t2.检查VBE版本，是否为2.0以上#\t3.检查要设置的mode的一些参数，看是否符合要求#\t4.设置显示模式为VBE 0x103（800*600，256色）#\t5.记录新显示模式的一些参数#\t6.若上面检查或设置失败，则设置显示模式为VGA 0x13（320*200，256色）#--------------------------------------------------------------------set_video_mode:\tmovw\t$0x800,\t\t\t\t%ax\tmovw\t%ax,\t\t\t\t%es\tmovw\t%ax,\t\t\t\t%ds\txorw\t%di,\t\t\t\t%dicheck_vbe:\tmovb\t$0x4f,\t\t\t\t%ah\t\t\t# 表示使用VBE标准\tmovb\t$0x00,\t\t\t\t%al\t\t\t# 功能号\tint\t\t$0x10\tcmp\t\t$0x004f,\t\t\t%ax\t\t\t# 若有VBE，AX应该为0x004f\tjne\t\t1f\tmovw\t0x04(%di),\t\t\t%ax\tcmp\t\t$0x0200,\t\t\t%ax\t\t\t# 若VBE版本不是2.0以上\tjb\t\t1fcheck_vbe_mode:\t\t\t\t\t\t\t\t# 检查MODE_VBE_0x13的参数\tmovw\t$VIDEO_MODE_0x103,\t%cx\tmovb\t$0x4f,\t\t\t\t%ah\t\t\t# 表明VBE标准\tmovb\t$0x01,\t\t\t\t%al\t\t\t# 子功能号\tint\t\t$0x10\tcmpb\t$0x00,\t\t\t\t%ah\t\t\t# 是否调用成功\tjne\t\tset_mode_vga_0x13\tcmpb\t$0x4f,\t\t\t\t%al\t\t\t# 是否支持该模式\tjne\t\tset_mode_vga_0x13\tcmpb\t$8,\t\t\t\t\t0x19(%di)\t# 颜色是否占8bit\tjne\t\tset_mode_vga_0x13\tcmpb\t$4,\t\t\t\t\t0x1b(%di)\t# 颜色的指定方法为4(调色板方式)\tjne\t\tset_mode_vga_0x13\tmovw\t(%di),\t\t\t\t%ax\tandw\t$0x0080,\t\t\t%ax\tjz\t\tset_mode_vga_0x13\t\t\t\t# AX第bit7是否为1(线性帧缓存是否有效)set_mode_vbe:\t\t\t\t\t\t\t\t# 下面设置模式\tmovw\t$VIDEO_MODE_0x103,\t%bx\taddw\t$0x4000,\t\t\t%bx\t\t\t# BX第14个比特表示是否使用大的线性缓存区\tmovb\t$0x4f,\t\t\t\t%ah\t\t\t# 表示使用VBE标准\tmovb\t$0x02,\t\t\t\t%al\t\t\t# 功能号，表示设置模式\tint\t\t$0x10save_video_mode_info:\t\t\t\t\t\t# 记录切换到的模式的一些参数信息\tmovw\t$VIDEO_MODE_0x103,\tvideo_mode\tmovw\t0x12(%di),\t\t\t%ax\tmovw\t%ax,\t\t\t\tscreen_x\tmovw\t0x14(%di),\t\t\t%ax\tmovw\t%ax,\t\t\t\tscreen_y\tmovl\t0x28(%di),\t\t\t%eax\tmovl\t%eax,\t\t\t\tvideo_ram\tmovw\t$1,\t\t\t\t\t%ax\tretset_mode_vga_0x13:\t\t\t\t\t\t\t# 若不支持VBE则设置为VGA 0x13 mode\tmovb\t$0,\t\t\t\t\t%ah\t\t\t# 功能号0x0\tmovb\t$VIDEO_MODE_0x13,\t%al\t\t\t# 显示模式\tint\t\t$0x10\tmovw\t$0x13,\t\t\t\tvideo_mode\tmovw\t$320,\t\t\t\tscreen_x\tmovw\t$200,\t\t\t\tscreen_y\tmovl\t$0xb8000,\t\t\tvideo_ram\t\tret#----------------------------------------------------------------# 读取软盘一个扇区：#\t使用BIOS INT 0x13中断读软盘，使用前需要设置ES：BX作为缓冲区#\tAX为相对扇区号，基于相对扇区号，为学习软盘的知识，使用了由#\t相对扇区号来读软盘的方式，也可以直接设置读取扇区数而读连续的#\t多个扇区。但好像有不能跨越磁道、不能超过64KB等限制，要小心。#\t柱面号、磁头号、扇区号计算公式如下：#\t柱面号CH = N / 36，令x = N % 36#\t磁头号DH = x / 18，扇区号CL = x % 18 + 1（因为从1开始，故加1）#-----------------------------------------------------------------read_a_sect:\tmovb\t$36,\t%dl\tdivb\t%dl\tmovb\t%al,\t%ch\t\t# 柱面号=N / 36, 假设x = N % 36\tmovb\t%ah,\t%al\t\t# AL = N % 36\txorb\t%ah,\t%ah\t\t# AH = 0, 则AX = AL = N % 36\tmovb\t$18,\t%dl\tdivb\t%dl\tmovb\t%al,\t%dh\t\t# 磁头号DH = x / 18\tmovb\t%ah,\t%cl\t\t# CL = x % 18\tincb\t%cl\t\t\t\t# 扇区号CL = x % 18 + 1\tmovb\t$0x00,\t%dl\t\t# 驱动器号DL = 0，表示第一个软盘即floppya\tmovb\t$0x02,\t%ah\t\t# 功能号0x02表示读软盘\tmovb\t$0x01,\t%al\t\t# 读取一个扇区数re_read:\t\t\t\t\t# 若调用失败（可能是软盘忙损坏等）则重新调用\tint\t\t$0x13\tjc\t\tre_read\t\t\t# 若进位位（CF）被置位，表示调用失败\t\tret#-------------------------------------------------------------------# 读取内核到内存#\t该函数读取baby OS 的内核到内存，第一个扇区为引导扇区，需要读取#\t的是从第二个扇区（相对扇区号1）开始的KERNEL_SECT_NUM个扇区#\tES：BX为缓冲区，为读取内核的临时位置0x10000#-------------------------------------------------------------------read_kernel:\tmovw\t$0x1000,\t\t\t%ax\t\t\tmovw\t%ax,\t\t\t\t%es\t\t# ES:BX 为缓冲区地址\txorw\t%bx,\t\t\t\t%bx\tmovw\t$0x00,\t\t\t\t%si\t\t# 已经读取的扇区数\tmovw\t$0x01,\t\t\t\t%di\t\t# 相对扇区号1:\t\tmovw\t%di,\t\t\t\t%ax\t\t# 将相对扇区号传给AX作为参数\tcall\tread_a_sect\tincw\t%si\tincw\t%di\taddw\t$512,\t\t\t\t%bx\tcmpw\t$KERNEL_SECT_NUM,\t%si\tjne\t\t1b\tret#--------------------------------------------------------------------# 移动内核第一个扇区：#\t内核从软盘读取到内存的一个临时位置，现在将第一个扇区移动到内存#\t0x0000处，第一个扇区即load.s，它将会把内核剩余部分移动到它的后面，#\t之所以分两次移动，是因为若内核较大，一次移动会覆盖0x7c00处的代码，#\t即引导扇区的代码，导致运行出错。#--------------------------------------------------------------------move_first_sect_of_kernel:\tcli\t\t\t\t\t\t\t\t\t# 指明SI，DI递增\tmovw\t$0x1000,\t\t\t%ax\tmovw\t%ax,\t\t\t\t%ds\t\t# DS:SI 为源地址\txorw\t%si,\t\t\t\t%si\tmovw\t$0x00,\t\t\t\t%ax\tmovw\t%ax,\t\t\t\t%es\t\t# ES:DI 为目标地址\txorw\t%di,\t\t\t\t%di\tmovw\t$512 >> 2,\t\t\t%cx\t\t# 移动512/4 次\trep\t\tmovsl\t\t\t\t\t\t# 每次移动4个byte\tret#--------------------------------------------------------------------# 移动GDT及新显示模式的参数信息到指定位置#\t该函数把GDT及参数信息移动到指定的位置，以便于以后使用#--------------------------------------------------------------------move_gdt_and_video_info:\txorw\t%ax,\t\t\t\t\t\t%ax\tmovw\t%ax,\t\t\t\t\t\t%ds\t\t# DS:SI 为源地址\tleaw\tgdt,\t\t\t\t\t\t%si\tmovw\t$GDT_ADDR >> 4,\t\t\t\t%ax\t\t# 由要保存的地址来计算段基址\tmovw\t%ax,\t\t\t\t\t\t%es\t\t# ES:DI 为目的地址\txorw\t%di,\t\t\t\t\t\t%di\tmovw\t$GDT_SIZE+VIDEO_INFO_SIZE,\t%cx\t\t# 移动的双字个数\trep\t\tmovsb\tret#--------------------------------------------------------------------# 开启保护模式：\t#\t1.关中断#\t2.加载GDT#\t3.开启A20总线，置cr0的PE位，切换到保护模式#\t4.far jmp/call，用一个CS Selector 更新CS 寄存器，开始执行新代码#--------------------------------------------------------------------enter_protected_mode:\tcli\t\t\t\t\t\t\t\t\t# 关中断\tlgdt\tgdt_ptr\t\t\t\t\t\t# 加载GDTenable_a20:\t\tinb\t\t$0x64,\t\t\t%al\t\t\t# 从端口0x64读取数据\ttestb\t$0x02,\t\t\t%al\t\t\t# 测试读取数据第二个bit\tjnz\t\tenable_a20\t\t\t\t\t# 忙等待\tmovb\t$0xdf,\t\t\t%al\toutb\t%al,\t\t\t$0x64\t\t# 将0xdf写入端口0x60\tmovl\t%cr0,\t\t\t%eax\t\t# 读取cr0寄存器\torl\t\t$0x01,\t\t\t%eax\t\t# 置位最后以为即PE位\tmovl\t%eax,\t\t\t%cr0\t\t# 写cr0寄存器\tljmp\t$CODE_SELECTOR,\t$0x00\t\t# 跳转到代码段，即load.s处开始执行\t\tret #--------------------------------------------------------------------# 开始执行后，会跳转到此处开始执行#--------------------------------------------------------------------\tmain:\tmovw\t%cx,\t\t%ax\tmovw\t%ax,\t\t%ds\tmovw\t%ax,\t\t%es\tmovw\t%ax,\t\t%ss\tmovw\t$0x1000,\t%sp\tcall\tclear_screen\t\t\t\t# 清屏\tcall\tset_video_mode\t\t\t\t# 设置显示模式\tcall\tread_kernel\t\t\t\t\t# 从软盘读取内核\tcall\tmove_first_sect_of_kernel\t# 将内核第一个扇区load.s移动到0x0000\tcall\tmove_gdt_and_video_info\t\t# 将GDT和显示模式信息保存起来\tcall\tenter_protected_mode\t\t# 进入包含模式1:\tjmp\t\t1bgdt:\t.quad\t0x0000000000000000\t\t\t# 空描述符\t.quad\t0x00cf9a000000ffff\t\t\t# 代码段描述符\t.quad\t0x00cf92000000ffff\t\t\t# 数据段描述符\t.quad\t000000000000000000\t\t\t# 留待以后使用\t.quad\t000000000000000000\t\t\t# 留待以后使用video_mode:\t\t\t\t\t\t\t\t# 显示模式\t.short\t0screen_x:\t\t\t\t\t\t\t\t# 水平分辨率\t.short\t0 screen_y:\t\t\t\t\t\t\t\t# 垂直分辨率\t.short\t0\tvideo_ram:\t\t\t\t\t\t\t\t# video_ram地址\t.long\t0gdt_ptr:\t\t\t\t\t\t\t\t# 用与lgdt 加载GDT\t.word\tscreen_x - gdt - 1\t\t\t# GDT段限长\t.long\tGDT_ADDR\t\t\t\t\t# GDT基地址\t.org\t0x1fe,\t0x90\t\t\t\t# 用nop 指令填充\t.word\t0xaa55\t\t\t\t\t\t# 引导扇区标志 load.s: #*************************************************************************#\t> File:\t\tload.s#\t> Desc:\t\t1.设置新的数据段等#\t\t\t\t2.将内核剩余部分移动到load.s后面#\t\t\t\t3.显示babyos 加载成功的Logo#\t> Author:\t孤舟钓客#\t> Mail:\t\tguzhoudiaoke@126.com #\t> Time:\t\t2012年12月30日 星期日 22时23分55秒#*************************************************************************.include \"include/kernel.inc\".section .text.global\t_start.org\t0_start:\tmovl\t$DATA_SELECTOR,\t\t\t%eax\tmovw\t%ax,\t\t\t\t\t%ds\tmovw\t%ax,\t\t\t\t\t%es\tmovw\t%ax,\t\t\t\t\t%fs\tmovw\t%ax,\t\t\t\t\t%gs\tmovw\t%ax,\t\t\t\t\t%ss\tmovl\t$STACK_BOTTOM,\t\t\t%espload_lefted_kernel:\tcld\tmovl\t$0x10200,\t\t\t\t%esi\tmovl\t$0x200,\t\t\t\t\t%edi\tmovl\t$(KERNEL_SECT_NUM-1)<<7,%ecx\trep\t\tmovslshow_logo:\tmovl\t$0xe0000000,\t\t\t%edi\taddl\t$272 + 800*10,\t\t\t%edi\tmovl\t$0x400,\t\t\t\t\t%esi\tmovl\t$128,\t\t\t\t\t%ebx\tmovl\t$1,\t\t\t\t\t\t%eax1:\t\tmovl\t$256,\t\t\t\t\t%ecxset_line_mem:\t\tcmpb\t$255,\t\t\t\t\t(%esi)\tje\t\t2f\tmovb\t%al,\t\t\t\t\t(%edi)2:\tinc\t\t%esi\tinc\t\t%edi\tloop\tset_line_mem\t\taddl\t$800-256,\t\t\t\t%edi\tdecl\t%ebx\tjnz\t\t1b3:\t\tjmp\t\t3b\t.org\t512,\t0x90\t baby os 暂时使用下面的简单logo： o(∩∩)o...哈哈，这个logo 使用小篆字体，还是很有中国特色的呦～","title":"babyos （五）—— 跳转到保护模式并显示一个LOGO"},{"content":"       在D3D11中，“混合”发生在像素着色器阶段的下一阶段，即Output Merger Stage。整个场景在全部经历过像素着色器阶段后，对应于屏幕上每一点像素，可能有多个片段（Fragment）。如下图所示：         该图中，场景中有三个点P1,P2,P3投影在屏幕上同一个点P。这样在像素着色器阶段后，针对P1,P2,P3将有三个片段与像素P对应。默认情况下，在渲染管线中，混合是被关闭的。这时为了确定像素P的最终显示颜色，主要依据是深度测试（这时暂不考虑模板测试等其他因素）。通过深度测试的片段将自身颜色替代后缓冲区中P点的当前颜色，未通过的片段被抛弃。        当混合功能被打开时，决定最终颜色的方法有所不同。当一个片段通过深度测试后，并不是直接取代后缓冲区中P点的当前颜色，而是通过一定的比例因子与之进行插值（混合），并将结果作为P点的当前值。当然，未通过深度测试的片段依然被抛弃。这个是“混合”的一种最简单例子。除此之外，D3D11针对混合阶段有非常多的配置，从而实现各种特殊效果。          1. 混合方程        学习混合的第一步，就是要了解混合方程，方程如下：               该方程针对每个像素逐一进行。方程左边的C为混合结果，右边Csrc（我们称为源颜色）和Cdst（我们称为目标颜色）分别为即将要处理的片段的颜色和后缓冲区中该像素当前的颜色；Fsrc和Fdst分别是两个颜色对应的混合因子。注意方程中的在这里为“分量相乘”（Componentwise multiplication），即针对颜色值中的R、G、B三种分量分别进行相乘。源颜色和目标颜色分别与相应的混合因子分量相乘后，将结果进行“op\"（混合操作）操作，作为当前片段处理的最终颜色，并替换后缓冲区中该像素处的颜色。        以上计算公式只适合于颜色值中RGB三个分量。此外，Alpha分量的计算公式完全一致：                 2. 混合操作 针对上述公式中的混合操作”op\"，在D3D11中定义在如下枚举类型中： typedef enum D3D11_BLEND_OP {  D3D11_BLEND_OP_ADD            = 1,  D3D11_BLEND_OP_SUBTRACT       = 2,  D3D11_BLEND_OP_REV_SUBTRACT   = 3,  D3D11_BLEND_OP_MIN            = 4,  D3D11_BLEND_OP_MAX            = 5 } D3D11_BLEND_OP; 我们省略各个变量的前缀D3D11_BLEND_OP_。 ADD表示相加操作，即； SUBTRACT表示相关（目标-源），即； REV_SUBTRACT表示反射的相关（源-目标），即； MIN表示取源、目标颜色中较小值，即； MAX表示取源、目标颜色中较大值，即。 注意：MIN和MAX操作与混合因子无关。 同样，所有这些操作也适合于计算Alpha值。 3. 混合因子 针对方程中的混合因子F，在D3D11中有如下几种： D3D11_BLEND_ZERO：此外针对颜色混合，F为（0，0，0），针对alpha值，F为0。 D3D11_BLEND_ONE：针对颜色混合为（1，1，1），针对alpha值为1； D3D11_BLEND_SRC_COLOR：针对颜色混合为（Rs，Gs, Bs），针对alpha值为As； D3D11_BLEND_INV_SRC_COLOR：针对颜色混合为（1-Rs，1-Gs，1-Bs），针对alpha值为1-As； D3D11_BLEND_SRC_ALPHA：针对颜色混合为（As,As,As），针对alpha值为As； D3D11_BLEND_INV_SRC_ALPHA：针对颜色混合为（1-As,1-As,1-As），针对alpha值为1-As； D3D11_BLEND_DEST_COLOR：针对颜色混合为（Rd,Gd,Bd），针对alpha值为Ad； D3D11_BLEND_INV_DESC_COLOR：针对颜色混合为（1-Rd,1-Gd,1-Bd），针对alpha值为1-Ad； D3D11_BLEND_DEST_ALPHA：针对颜色混合为（Ad,Ad,Ad），针对alpha值为Ad； D3D11_BLEND_INV_DEST_ALPHA：针对颜色混合为(1-Rd,1-Rd,1-Rd），针对alpha值为1-Ad； D3D11_BLEND_BLEND_FACTOR：此时的混合因子为程序员指定的颜色值（R,G,B,A)，针对颜色混合为(R,G,B)，针对alpha值为A。该颜色值通过函数ID3D11DeviceContext::OMSetBlendState来指定； D3D11_BLEND_INV_BLEND_FACTOR：同上，为程序员指定颜色值，针对颜色混合为(1-R,1-G,1-B)，针对alpha值为1-A。   4. 混合状态 D3D11中，设置混合状态前要先创建相应的混合状态接口ID3D11BlendState，创建函数如下： HRESULT CreateBlendState(  [in]   const D3D11_BLEND_DESC *pBlendStateDesc,  [out]  ID3D11BlendState **ppBlendState); 第二个参数为要创建的接口的地址，第一个参数为一个用来描述混合状态参数的结构，定义如下： typedef struct D3D11_BLEND_DESC {  BOOL                           AlphaToCoverageEnable;  BOOL                           IndependentBlendEnable;  D3D11_RENDER_TARGET_BLEND_DESC RenderTarget[8];} D3D11_BLEND_DESC; 第一个参数设置是否打开AlphaToCoverage，AlphaToCoverage在后面会详细介绍，暂时先不用，设置为false； 第二个参数设置是否针对不同的RenderTarget使用不同的混合状态。在D3D11中，一共可以支持多达8个的渲染对象（RenderTarget），如果针对不同的对象想使用不同的混合方式，则设置为true。由于我们暂时用不到，因此设置为false； 第三个参数为针对8个RenderTarget分别指定的混合状态参数，当第二个参数为false时，这里我们只需要设置数组中第一个元素即可。 D3D11_RENDER_TARGET_BLEND_DESC结构定义如下： typedef struct D3D11_RENDER_TARGET_BLEND_DESC {  BOOL           BlendEnable;  D3D11_BLEND    SrcBlend;  D3D11_BLEND    DestBlend;  D3D11_BLEND_OP BlendOp;  D3D11_BLEND    SrcBlendAlpha;  D3D11_BLEND    DestBlendAlpha;  D3D11_BLEND_OP BlendOpAlpha;  UINT8          RenderTargetWriteMask;} D3D11_RENDER_TARGET_BLEND_DESC; 第一个需要设置为true，以开启混合状态； 后面的参数即我们的混合方程中的参数： SrcBlend、DestBlend分别为源、目标颜色混合因子； BlendOp为源、目标颜色的混合操作； SrcBlendAlpha、DestBlendAlpha为源、目标alpha值的混合因子； BlendOpAlpha为源、目标alpha值的混合操作； RenderTargetWriteMask为最终混合结果在写到缓冲区时的掩码，即用来指定哪些位写进去，哪些们不能写。针对该参数有如下枚举类型： typedef enum D3D11_COLOR_WRITE_ENABLE {  D3D11_COLOR_WRITE_ENABLE_RED     = 1,  D3D11_COLOR_WRITE_ENABLE_GREEN   = 2,  D3D11_COLOR_WRITE_ENABLE_BLUE    = 4,  D3D11_COLOR_WRITE_ENABLE_ALPHA   = 8,  D3D11_COLOR_WRITE_ENABLE_ALL     =       ( D3D11_COLOR_WRITE_ENABLE_RED | D3D11_COLOR_WRITE_ENABLE_GREEN |          D3D11_COLOR_WRITE_ENABLE_BLUE | D3D11_COLOR_WRITE_ENABLE_ALPHA ) } D3D11_COLOR_WRITE_ENABLE; 其中，RED、GREEN、BLUE和ALPHA分别表示只允许写入R、G、B、A部分的值。默认情况下，我们把带个颜色值替换缓冲区中的值，因此该参数我们指定为D3D11_COLOR_WRITE_ENABLE_ALL。   创建好ID3D11BlendState接口后，通过以下函数来设置为指定的状态： void OMSetBlendState(  [in]  ID3D11BlendState *pBlendState,  [in]  const FLOAT* BlendFactor,  [in]  UINT SampleMask); 第一个参数即创建的接口； 第二个参数为程序员手动指定的混合因子，即刚介绍混合因子时，如果指定参数为D3D11_BLEND_BLEND_FACTOR或D3D11_BLEND_INV_BLEND_FACTOR，则使用第二个参数指定的颜色值为了混合因子； 第三个参数为采样点掩码。D3D11中的多重采样可以支持32个采样点，该参数用来决定”使用/丢弃\"哪些采样点。该参数类型为UINT，32位，其中从最低位到最高位分别代表一个采样点。比如，如果第5位指定为0，则第5个采样点将被丢弃。当然，只有当开启至少5重采样时该设定才有效。如果当前设置为单个采样点，则只有最低位才对我们有用。默认情况下，该参数值为0xFFFFFFFF，即对所有采样点有效。   Voila，使用混合的所有步骤就这些~ 初次接触是不是觉得有点头晕？有太多的结构要填，参数名又非常长！ 其实一点也不难，参数名长有一个很大的好处，就是“自解释”，看到名字一下子就能明白其用意，而且还很容易记住。只要理解了混合的基本原理，这些过程其实是一气呵成的事。以下是一个开启混合的例子： //开启透明D3D11_BLEND_DESC transDesc;//先创建一个混合状态的描述transDesc.AlphaToCoverageEnable = false;\t\t//关闭AlphaToCoveragetransDesc.IndependentBlendEnable = false;\t\t//不针对多个RenderTarget使用不同的混合状态//因此只设置第一个数组元素即可transDesc.RenderTarget[0].BlendEnable = true;transDesc.RenderTarget[0].SrcBlend = D3D11_BLEND_SRC_ALPHA;transDesc.RenderTarget[0].DestBlend = D3D11_BLEND_INV_SRC_ALPHA;transDesc.RenderTarget[0].BlendOp = D3D11_BLEND_OP_ADD;transDesc.RenderTarget[0].SrcBlendAlpha = D3D11_BLEND_ONE;transDesc.RenderTarget[0].DestBlendAlpha = D3D11_BLEND_ZERO;transDesc.RenderTarget[0].BlendOpAlpha = D3D11_BLEND_OP_ADD;transDesc.RenderTarget[0].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;//创建ID3D11BlendState接口device->CreateBlendState(&transDesc,&TransparentBS);//现在可以设置混合状态了//先指定混合因子，一般不用它，除非在上面混合因子指定为使用blend factorfloat factor[4] = {1.f,1.f,1.f,1.f};//使用该状态deviceContext->OMSetBlendState(TransparentBS,factor,0xffffffff);\t//32个采样点都有效 渲染完后，一般要恢复默认状态，这时使用NULL参数即可，如下： deviceContext->OMSetBlendState(0,factor,0xffffffff); 5. 几种混合的例子 在D3D中通过合理地设置不同的混合状态，可以实现各种各样的效果。以下是几个常见的例子： 5.1 禁止颜色写入 有时候，在渲染过程中，我们只希望修改深度/模板缓冲区部分，而且希望保持后缓冲区中的原有颜色值，这时修，我们需要“禁止颜色写入”。 一种方法是把目标混合因子设为D3D11_BLEND_ONE，把源混合因子设为D3D11_BLEND_ZERO，这样混合方程中源部分相乘后结果为0，目标部分相乘后保持原样，相加结果仍为原来的颜色，这样即禁止了颜色的写入；还有另一种更为直观的方法是，直接把描述中D3D11_RENDER_TARGET_BLEND_DESC::RenderTargetWriteMask成员设为0，即任何一位都无法写入。 5.2 把颜色相加、相减 在处理片段时，如果我们希望把片段颜色与后缓冲区中当前颜色值相加。这时，可以通过把源、目标混合因子全部设为D3D11_BLEND_ONE。这样，在乘以相应的混合因子后，源、目标颜色保持不变。对于混合操作，如果是实现相加，可以设置为D3D11_BLEND_OP_ADD，如果为相减，可以设置为D3D11_BLEND_OP_SUBTRACT或D3D11_BLEND_OP_REV_SUBTRACT（取决于源颜色值减目标颜色值，还是相反）。 5.3 把颜色相乘 如果希望把片段颜色值与后缓冲区中对应的当前值相乘，可以设置目标混合因子为D3D11_BLEND_SRC_COLOR，而把源混合因为设为D3D11_BLEND_ZERO。这样，混合方程中源部分变为0，对于目标部分，由于混合因子是片段的颜色值，因为目标颜色乘以混合因子，实际上就是目标颜色与源颜色相乘了。至于混合操作，设置为相加即可，即D3D11_BLEND_OP_ADD。 5.4 透明效果 有时候，我们需要渲染透明的物体，比如玻璃。透过玻璃，我们可以看见其后面的物体。一般情况下，实现透明效果时，我们需要用到该物体的alpha值。比如对于alpha为0.4，意思是该物体60%透明，即最终我们观察到的颜色40%来自该物体，60%来自其后面的物体。要实现这种效果，我们可以为源颜色指明混合因子为D3D11_BLEND_SRC_ALPHA，即该片段对应的alpha值，目标因子设为D3D11_BLEND_INV_ALPHA。混合操作设置相加：D3D11_BLEND_OP_ADD。这时，比如透明物体的alpha值为0.25，即源混合因子为0.25，目标混合因子为0.75。   6. 使用“透明”效果时的注意事项 在场景中包含透明物体时需要额外注意的是，要先渲染不透明物体，然后把透明物体由远到近逐个渲染。 原因很简单，如果很渲染了透明物体，这样当渲染该透明物体后面的物体时，将无法通过深度测试而被丢弃，从而导致无法再看到透明物体后面的物体。   7. 示例程序 在本节的示例程序中，演示的是水面的透明效果。场景为一个很大的水池，透过水面，可以看到水池底部以及水中的物体。当然，这里的水面仅仅是静态的水面，没有任何波动效果。以下是程序截图： 操作说明：鼠标左键按下旋转屏幕，右键按下调整镜头远近。 以下是示例程序源代码： D3D11“透明\"效果示例程序    ","title":"【D3D11游戏编程】学习笔记十五：混合（Blending）"},{"content":"  其实这个是我自己对NIO做服务器时的一点见解，要是不太对，望赐教，这个图和数据通信的时分复用图差不多吧！     package org.com.mayi;import java.io.IOException;import java.net.InetSocketAddress;import java.net.ServerSocket;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.util.Iterator;import java.util.LinkedList;import java.util.Set;public class SelectorServer {    private static int DEFAULT_SERVERPORT = 6018;//默认端口    private static int DEFAULT_BUFFERSIZE = 1024;//默认缓冲区大小为1024字节    private ServerSocketChannel channel;    private LinkedList<SocketChannel> clients;    private Selector readSelector;    private ByteBuffer buffer;//字节缓冲区    private int port;        //构造函数，初始化数据    public SelectorServer(int port) throws IOException    {        this.port = port;        this.clients = new LinkedList<SocketChannel>();        this.channel = null;        this.readSelector = Selector.open();//打开选择器        this.buffer = ByteBuffer.allocate(DEFAULT_BUFFERSIZE);    }             // 服务器程序在服务循环中调用sericeClients()方法为已接受的客户服务    public void serviceClients()throws IOException    {        Set<?> keys;        Iterator<?> it;        SelectionKey key;        SocketChannel client;        // 在readSelector上调用select(long timeout)方法，        //timeout - 如果为正，则在等待某个通道准备就绪时最多阻塞 timeout 毫秒；        //如果为零，则无限期地阻塞；必须为非负数         if(readSelector.select(1) > 0)        {            keys = readSelector.selectedKeys(); //返回此选择器的已选择键集            it = keys.iterator();           // 遍历，为每一个客户服务             while(it.hasNext())             {               key = (SelectionKey)it.next();               if(key.isReadable())               { // 测试此键的通道是否已准备好进行读取。                  int bytes;                  client = (SocketChannel)key.channel();//返回为之创建此键的通道。                  buffer.clear(); // 清空缓冲区中的内容，设置好position,limit，准备接受数据                  bytes = client.read(buffer); // 从通道中读数据到缓冲中，返回读取得字节数                  if(bytes >= 0)                   {                     buffer.flip(); // 准备将缓冲中的数据写回到通道中                     client.write(buffer);  // 数据写回到通道中                  }                   else if(bytes < 0)                   { // 如果返回小于零的值代表读到了流的末尾                     clients.remove(client);                  // 通道关闭时，选择键也被取消                     client.close();                  }               }            }         }    }           // 配置和注册代表客户连接的通道对象    public void registerClient(SocketChannel client) throws IOException    {        client.configureBlocking(false);  // 设置非阻塞模式            client.register(readSelector, SelectionKey.OP_READ); //注册到选择器上        clients.add(client); //保存这个通道对象----->为了写完数据时，删掉这个通道。    }           //服务器开始监听端口，提供服务    public void listen() throws IOException    {         ServerSocket socket;        SocketChannel client;        channel = ServerSocketChannel.open(); // 打开通道        socket = channel.socket();   //得到与通道相关的ServerSocket对象        socket.bind(new InetSocketAddress(port), 10);//将ServerSocket绑定在制定的端口上        channel.configureBlocking(false); //配置通道使用非阻塞模式。                try         {            while(true)             {            //与通常的程序不同，这里使用ServerSocketChannel.accpet()接受客户端连接请求，            //而不是在ServerSocket对象上调用accept()。                client = channel.accept();  //接受到此通道套接字的连接。                  if(client != null)                {                    registerClient(client); // 注册客户信息                }                serviceClients();  // 为以连接的客户服务            }        }         finally         {            socket.close(); // 关闭socket，关闭socket会同时关闭与此socket关联的通道        }    }                    public static void main(String[] args) throws IOException     {        System.out.println(\"服务器启动\");        SelectorServer server = new SelectorServer(SelectorServer.DEFAULT_SERVERPORT);        server.listen(); //服务器开始监听端口，提供服务       }} 基本过程：  服务器启动并初始化（new SelectorServer），服务器开始监听，serversocketchannel接收socket连接，并注册到selector，然后提供serversocket服务。     其中selector 是 SelectableChannel 对象的多路复用器。很有必要了解selector。 serversocketchannel   和socketchannel是实现使用通道传输数据的基础条件 非阻塞模式的优势：                             通道channel要么处于阻塞 模式，要么处于非阻塞模式。                             在阻塞模式中，每一个 I/O 操作完成之前都会阻塞在这个通道上调用的其他 I/O 操作。                             在非阻塞模式中，永远不会阻塞 I/O 操作，并且传输的字节可能少于请求的数量，或者可能根本不传输字节。                             新创建的通道总是处于阻塞模式。在结合使用基于选择器selector的多路复用时，非阻塞模式是最有用的。向选择器                             注册某个通道前，必须将该通道置于非阻塞模式，并且在注销之前可能无法返回到阻塞模式。             ","title":"NIO服务器"},{"content":"场景: 1.在没有HTML库时(谁有好的html库介绍下,C/C++的？tinyXML?),以SAX方式解析HTML时,会读入特殊字符,这时候需要转义成正常字符才能使用。 2.耗时，4-6小时(被打扰)。 3.replace虽然挺好,但是会循环整个字符串执行替换,效率应该没有一次过替换高.   #include <algorithm>  void replace( iterator start, iterator end, const TYPE& old_value, const TYPE& new_value ); 文件1：test_htmlescape.cpp #include <stdio.h>#include <stdlib.h>#include <string.h>#include <iostream>#include <assert.h>using namespace std;int IsLittleEndian(){    int x = 1;    if (*(char*) &x == 1)    {        return 1;    }    else    {        return 0;    }}void HtmEscapeEntityCodeToUnicode(const char* entity_code,char* html_char){    int decimal_value = atoi(entity_code);    char* uchari = (char*)&decimal_value;    if(IsLittleEndian())    {        html_char[0] = uchari[0] & 0xFF;        html_char[1] = uchari[1] & 0xFF;    }else    {        html_char[0] = uchari[1] & 0xFF;        html_char[1] = uchari[0] & 0xFF;    }}void OneUnicode2UTF8(const char* unicode_char,size_t unicode_char_length,            char* utf_char){    //unicode: 0x192->110010010 ,utf8:0xC692->1100011010010010    int value = 0;    memcpy(&value,unicode_char,unicode_char_length);        if (value >= 0x0000 && value <= 0x007F)      {          utf_char[0] = unicode_char[0];    }      else if (value >= 0x0080 && value <= 0x07FF)      {          utf_char[0] = ((value >> 6) | 0xC0);        utf_char[1] = ((value & 0x3F) | 0x80);    }      else if (value >= 0x0800 && value <= 0xFFFF)      {          utf_char[0] = ((value >> 12) | 0xE0);        utf_char[1] = ((value >> 6 & 0x3F) | 0x80);        utf_char[2] = ((value & 0x3F) | 0x80);    }    else if (value >= 0x10000 && value <= 0x10FFFF)      {          utf_char[0] = (value >> 18 | 0xF0);        utf_char[1] = ((value >> 12 & 0x3F) | 0x80);        utf_char[2] = ((value >> 6 & 0x3F) | 0x80);        utf_char[3] = ((value & 0x3F) | 0x80);    }    else    {        cerr << \"value too big.\" << endl;         assert(0);    }}static const char* kEntityNameToEntityCodeMap[] = {    \"oelig\",\"339\",\"amp\",\"38\",\"rArr\",\"8658\",\"fnof\",\"402\"};//1.这里可以优化的余地很大.const char* HtmEscapeEntityNameToEntityCode(const char* entity_name){    static size_t length = sizeof(kEntityNameToEntityCodeMap)/sizeof(char*);    for(size_t i = 0; i < length; i+=2)    {        if(!strcmp(entity_name,kEntityNameToEntityCodeMap[i]))        {            return kEntityNameToEntityCodeMap[i+1];        }    }    return NULL;}string UnescapeUTFHTMLContent(const char* str){    string temp;        char* pos_amp = NULL;    char* pos_semicolon = (char*)str;    const char* start_amp = str;    int entity_length = 0;    char entity_code[5];    const int kMaxEntityLength = 4;    char entity_name[20];    const int kMaxEntityNameLength = 18;        char unicode[3];    char utf8[4];    while(true)    {        if(!start_amp || !(*start_amp))        {            break;        }        pos_amp = strchr(start_amp,'&');        if(!pos_amp)        {            temp.append(start_amp);            break;        }        int pos_no = pos_amp - pos_semicolon;        if(pos_no > 0)        {            temp.append(start_amp,pos_no);            start_amp = pos_amp;        }        char* pos_amp1 = pos_amp+1;        if(!pos_amp1 || !(*pos_amp1))        {            string t2(start_amp);            temp.append(start_amp);            break;        }        if(isalpha(*pos_amp1))        {            pos_semicolon = strchr(pos_amp1,';');            if(pos_semicolon)            {                //调用 HtmEscapeEntityNameToEntityCode                memset(entity_name,0,sizeof(entity_name));                entity_length = ((pos_semicolon - pos_amp1) >                     kMaxEntityNameLength)?kMaxEntityNameLength:                    (pos_semicolon - pos_amp1);                strncpy(entity_name,pos_amp1,entity_length);                const char* entity_code_c =                     HtmEscapeEntityNameToEntityCode(entity_name);                if(entity_code_c)                {                    memset(unicode,0,sizeof(unicode));                    memset(utf8,0,sizeof(utf8));                    HtmEscapeEntityCodeToUnicode(entity_code_c,unicode);                    OneUnicode2UTF8(unicode,2,utf8);                    temp.append(utf8);                }else                {                    temp.append(entity_name);                }                //1.entity_name转换为entity_code之后再转换为utf8字符.                start_amp = pos_semicolon + 1;                pos_semicolon+=1;            }else            {                start_amp = pos_amp1;            }        }else if(*pos_amp1 =='#')        {            char* pos_digit = (pos_amp1+1);            if(!pos_digit)            {                break;            }                        if(isdigit(*pos_digit))            {                //1.需要判断数值小于10000.                pos_semicolon = strchr(start_amp,';');                if(pos_semicolon)                {                    memset(entity_code,0,sizeof(entity_code));                    entity_length = ((pos_semicolon - pos_digit) >                         kMaxEntityLength)?kMaxEntityLength:                        (pos_semicolon - pos_digit);                    strncpy(entity_code,pos_digit,entity_length);                    memset(unicode,0,sizeof(unicode));                    memset(utf8,0,sizeof(utf8));                    HtmEscapeEntityCodeToUnicode(entity_code,unicode);                    OneUnicode2UTF8(unicode,2,utf8);                    temp.append(utf8);                    start_amp = pos_semicolon + 1;                    pos_semicolon+=1;                }else                {                    start_amp = pos_digit;                }            }        }else        {            string sa(start_amp,pos_amp1 - start_amp);            temp.append(sa);            start_amp = pos_amp1;        }    }    return temp;}int main(int argc, char *argv[]){    printf(\"Hello, world\\n\");        string str;    const char *html_str = \"&#918;abcd&#917;hello&#169;<a>&#8658;&rArr;\"    \"&fnof;&#8230;<\/a>\"    \"asfas&#8225;dfe&#933;&Psi;&#937;<img>n&#8595;n&sdot;n&#969;mmm<\/img>1jh\";    str = UnescapeUTFHTMLContent(html_str);    cout << \"str: \" << str << endl;    html_str = \"<td>&amp;#8736;<\/td>\";    str = UnescapeUTFHTMLContent(html_str);    cout << \"str: \" << str << endl;    html_str = \"<td>&amp;#8736;<\/td>;;#8736;\";    str = UnescapeUTFHTMLContent(html_str);    cout << \"str: \" << str << endl;    html_str = \"<td>&amp;#8736;<\/td>;&amp;\";    str = UnescapeUTFHTMLContent(html_str);    cout << \"str: \" << str << endl;    html_str = \"<td>&amp;#8736;<\/td>;&amp\";    str = UnescapeUTFHTMLContent(html_str);    cout << \"str: \" << str << endl;    html_str = \"<td>&amp;#8736;<\/td>;&\";    str = UnescapeUTFHTMLContent(html_str);    cout << \"str1: \" << str << endl;    html_str = \"ab\";    str = UnescapeUTFHTMLContent(html_str);    cout << \"ab: \" << str << endl;    return 0;} str: ΖabcdΕhello©<a>⇒⇒ƒ…<\/a>asfas‡dfeΥPsiΩ<img>n↓nsdotnωmmm<\/img>1jhstr: <td>&#8736;<\/td>str: <td>&#8736;<\/td>;;#8736;str: <td>&#8736;<\/td>;&str: <td>&#8736;<\/td>;ampstr1: <td>&#8736;<\/td>;&ab: ab","title":"[C/C++]_[HTML特殊字符转义成正常字符]"},{"content":"  通常来说，决定采用何种方式来检索数据是非常重要的，这样便于以后对数据检索时，数据会按照何种的方式顺序输出。栈是用于检索数据的一种常用方式。 栈的一种显著的特征就是它按照后进先出（LIFO）的方式存储和删除数据元素。这就是说，最后一个存入栈中的元素将会被第一个删除。我们可以看下图的表示； 栈的实现方法有2种，一种是顺序栈，一种是链式栈； 下面先介绍下顺序栈的定义和实现（以前写过的代码）： #define N 8typedef int datatype;typedef struct{\tdatatype data[N];\tint top;} seqstack;seqstack *CreateSeqstack(){\tseqstack *s;\t\ts = (seqstack *)malloc(sizeof(seqstack));\ts->top = -1;\treturn s;}int EmptySeqstack(seqstack *s){\treturn (-1 == s->top);}int FullSeqstack(seqstack *s){\treturn (N-1 == s->top);}void ClearSeqstack(seqstack *s){\ts->top = -1;}void PushSeqstack(seqstack *s, datatype x){\ts->data[++s->top] = x;\treturn;}datatype PopSeqstack(seqstack *s){\treturn s->data[s->top--];}datatype GetTop(seqstack *s){\treturn s->data[s->top];}int main(){\tint i;\tseqstack *s;\ts = CreateSeqstack();\tfor (i=1; i<=10; i++)\t{\t\tif ( ! FullSeqstack(s) ) \t\t\tPushSeqstack(s, i);\t\telse \t\t\tprintf(\"stack is full\\n\");\t}\twhile ( ! EmptySeqstack(s) )\t{\t\tprintf(\"%d \", PopSeqstack(s));\t}\tprintf(\"\\n\");\treturn 0;} 链式栈的定义和实现：     前面已经对单链表的实现进行分析过程可以参照博客中单链表部分，栈的结构体的定义和链表是一样的，在初始化和销毁可以直接调用单链表的实现方法。这种方法是栈具有多态性。多态是面向对象的一种特性，她允许某种类型的对象或者变量在使用时用其他的类型的对象进行代理。这就说，除了使用栈本身的操作完，还可以使用链表的操作。这是因为栈本身就是一种链表，它和链表有相同的特性，很多时候可以像链表一样使用它。     下面是链式栈的定义和实现的过程， /*stack.h*/#ifndef STACK_H#define STACK_H#include <stdlib.h>#include \"list.h\"typedef List Stack;#define stack_init list_init#define stack_destroy list_destoryint stack_push(Stack *stack, const void *data);int stack_pop(Stack *stack,void *data);#define stack_peek(stack)    ((stack)->head == NULL ? NULL:(stack)->head->data)#define stack_size   list_size#endif /*stack.c*/#include <stblib.h>#include \"../include/list.h\"#include \"../include/stack.h\"/*stack_push */int stack_push(Stack * stack, const void * data){    return list_ins_next(stack, NULL, const void * data)}/*stack_pop*/int stack_pop(Stack * stack, void * data){     return list_rem_next(stack, NULL, void * data)}","title":"数据结构----栈的实现和个人分析"},{"content":"求最大的和最小的原理是一样的，只不过是求最大的在应用中用的比较多。举个比较常见的例子，大家都会购物吧，购物的时候如果去京东商城，当搜索某件商品的时候，搜索后的页面会呈现很多该类型的商品，但是京东总会给我们一些推荐，那么这个推荐是依据什么呢？其实道理很简单，京东的后台会记录客户浏览或者购买的某件商品的次数，然后进行统计，把用户浏览次数或者购买次数排名靠前的几件商品放在前几的位置。还有很多其他的应用。。。例如搜索引擎。 之前零零散散的接触过一些求最小k个数，或者求第k个最小的数字，今天把这些都总结起来。在总结之前，先叙述一句比较有道理的话：我们想要得到的是最小的k个数字，没有要求这k个数字有序，同时更没有要求选取k个数字之后的其他剩余数字有序。理解这一点很重要，简而言之，就是不要去做无用功。 一，选择第k小的数字： 1，采用交换排序或者插入排序，因为我们是求第k小的，所以没必要对整个数组排序。只需要求得第k小的时候结束就好。时间复杂度为O（n*k）. 2，采用堆排序或者快速排序，这次就不能像选择排序或者交换排序那样选择到第k小的时候就结束，因为我们不知道那次的选择是第k小的，只有等到整个数组有序之后。时间复杂度为O(n*logn). 3，采用randomized-select，这种方法可以在期望的线性时间内完成。这种方法主要是基于快速排序改进的。因为快速排序对pivot-key的选取依赖性很强，如果能选到好的pivot-key，那么运行时间就会很快。期望时间复杂度为O(n)。 4，采用中位数的中位数，在randomized-select过程中，中位数的选取由medianofmedians算法实现。但是因为这个算法的常数项太大，同时也过于抽象，没有在实际医用中得到广泛的发展。时间复杂度为O（n）。 二，选择最小的k个数字： 1，采用交换排序或者插入排序。时间复杂度为O(n*k)。 2，采用堆排序或者快速排序，时间复杂度为O(n*logn)。 3，采用randomized-select，期望的时间复杂度为O（n）。可能到这里需要进行解释一下，为什么找第k小的时候期望的时间复杂度为O(n),那找最小的k个的期望的时间复杂度不应该是O（n*k）吗，不要着急，很快就会解释这个问题。 4，应对大数据的情况，首先取数组中前k个数字建立大根堆，想一想为什么建立大根堆？------建立堆之后，从第k+1个元素开始，和堆顶元素进行比较，如果小于堆顶的元素，那么就替换堆顶的元素，这时候堆有可能被破坏了，所以要进行调整，假设数组中原有n个元素，那么要进行n-k躺相同的操作。总得时间复杂度为：O(k)+O((n-k)*logk). 5，同样是应对大数据的情况，如果有足够的内存，那么建立一个大小为n的小跟堆，堆顶肯定是当前最小的值，连续进k次如下操作：取堆顶，调整堆。总得时间复杂度为： O(n)+O(k*logn)。看到网上的博客有人说，取完堆顶元素，进行调整的时候没必要进行logn次的调整，只要进行有限次就可以了，稍后也会给出这个思路的分析，同时也会求证这个思路的正确性。  三，说明一下，为什么要区分选择第k小和最小的k个这两种情况，因为在看有些博客的时候，讲着讲着，自己都搞不懂是找哪个了，对读者的误导很大。其实也可以从上面的分析中看出，这两种情况的时间复杂度是差不多的。但是为了清晰，还是有必要区分一下，之后所有的研究情况都是基于选择最小的k个，而不是第k小。 四，在第二部分中，可以看到，求最小的k个有很多种方法，包括之后要补充的两种方法，那么什么时候选择什么样的方法是很关键的。对于应用1还是2，有必要进行区分一下，假使n*k = n*logn ,得到的结果是k=logn，根据这个n和k的关系就可以选择应用哪个方法了。对于第3种方法，我想如果给定的数组不是极端的情况，比1,2都更快。至于4,5是应对大数据的情况的。同时还要注意这几种情况的区别:1,2对数组进行了排序，而3,4,5都没有对数组进行排序。 五，每种方法的分析： 1，交换排序，引自wikipedia： function select(list[1..n], k)     for i from 1 to k         minIndex = i         minValue = list[i]         for j from i+1 to n             if list[j] < minValue                 minIndex = j                 minValue = list[j]         swap list[i] and list[minIndex]     return list[k] 2，快速排序或者堆排序：这个学过数据结构的都能给出很清晰的答案。但是为了清晰起见，个人认为算法导论上的堆排序中的堆调整算法比较好理解，故给出伪代码： void adjust_heap(int *a, int i, int len) {\tint left = i * 2;\tint right = i * 2 + 1;\tint min_index = 0;\tif(left <= len && a[left] < a[i]) {\t\tmin_index = left;\t} else {\t\tmin_index = i;\t}\tif(right <= len && a[right] < a[min_index]) {\t\tmin_index = right;\t}\tif(min_index != i) {\t\tswap(a[i] , a[min_index]);\t\tadjust_heap(a, min_index, len);\t}}3，应用randomized-select，这种方法来源于算法导论的第九章，它是根据随机快速排序改装而来。假设我们给定的一组数据为：1,11,23,5,6,7,20,13,22,9,34,18这12个数据，找出这12个数据总最小的7个数字：随机快排运行后的结果是：1 5 6 7 9 11 13 23 22 20 34 18，第7小的数据是13，从结果中可以看出什么特点呢，13之前的数字都比它小，而13之后的数字都比它大。这个结果是选择第k小数字的算法得来的，这也就验证了，为什么选择最k小和选择第k小的时间复杂度是一样的，这就是这个算法的神奇之处。下面给出算法的核心代码： #include<stdio.h>#include<stdlib.h>int random(int low, int high) {\tint size = high - low + 1;\treturn low + rand() % size;}void swap(int *a, int *b) {\tint temp;\ttemp = *a;\t*a = *b;\t*b = temp;}int partition(int *a, int left, int right) {\tint key = a[left];\tint i = left;\tint j;\tfor(j = i + 1; j <= right; j++) {\t\tif(a[j] <= key) {\t\t\tif(i != j) {\t\t\t\ti++;\t\t\t\tswap(&a[i], &a[j]);\t\t\t}\t\t}\t}\tswap(&a[i], &a[left]);\treturn i;}int random_partition(int *a, int left, int right) {\tint index = random(left, right);\tswap(&a[index], &a[left]);\treturn partition(a, left, right);}int randomized_select(int *a, int left, int right, int k) {\tif(left < 0 || (right - left + 1) < k)\t\treturn -1;\tint pos = random_partition(a, left, right);\tint m = pos - left + 1;\tif(k == m) {\t\treturn pos;\t} else if(k < m) {\t\treturn randomized_select(a, left, pos - 1, k);\t} else {\t\treturn randomized_select(a, pos + 1, right, k - m);\t}}void main() {\tint a[] = {1, 11, 23, 5, 6, 7, 20, 13, 22, 9, 34, 18};\tint len = sizeof(a) / sizeof(int);\tint k = 7;\trandomized_select(a, 0, len - 1, k);\tfor(int i = 0; i < len; i++) {\t\tprintf(\"%d \", a[i]);\t}\tprintf(\"\\n\");}4，建立大小为k的堆，要想做验证，可以应用这个链接中的代码：http://blog.csdn.net/zzran/article/details/8439367。 5，建立大小为n的堆，这需要有足够的内存，假设我们要找到1000,0000数字中（有重复出现的数字），出现频数排名前10个的数字。1000，0000中假设出去重复的后有100,0000个数字，那么这些数字所需要的内存空间为：4*10^6B~4MB的内存。建立堆可以很快的建立起来，因为算法导论中曾经证明过，可以在O（n）的时间内建立堆。建立好堆之后就是对堆取堆顶，然后调整，如果n=4MB，那么logn=22，如果所需要取的k值不算大的话，即使是全堆进行调整也不会浪费很多的时间。但是如果k很大的话，那么就有人提议，对于k，每次取完堆顶元素后，只需要调整k次就足够了。先假设这个结论是正确的，这个界限是多少呢。应用等式：(k^2) = k * logn。k=logn。n=4MB，k<22的时候就有必要应用这个方法了。当k>22的时候，很多的调整都是多余的了。对于4GB的数据k的界限也只不过是32。当k小于界限值的时候，k^2，k*logn这些对于2GHZ主频的计算机来说，没有多大影响的，所以先不从、这个想法的正确性来说，但从效率上讲就没有必要进行这样的改动。这个算法的总的时间复杂度为O（n + k*logn）。但是这个方法占用了很大的内存空间，但从时间上来讲，没有比第4中方法节省多少时间。故对于大量数据的情况来说方法4是最优的。如果有人想做进一步的研究，可以看下这个链接里面的内容：http://blog.csdn.net/zzran/article/details/8443655。 六，近期会给出另外两种方法。 七，总结：对于上述的几种方法，如果都能够掌握了，或者正确的编写出程序，我想就已经很厉害了。其实无论怎么变种，都逃不掉这几种方法。由于本人能力的限制，对于中位数的中位数的方法没有做出分析。原因有下面几点：第一，这个算法很复杂，第二，没有什么应用范围，如果不是科研，或者一些研究是不会涉及到此算法的。如果有人对这个有兴趣，可以看看算法导论或者MIT的算法导论公开课。 八，思路扩展，如果要是找第k小到第m小之间的数字呢?(k < m).考虑一下上述的第三个算法，运行完之后k左边都是比它小或者等于它的数字，它的右边都是比它大或者和它相等的数字，那么我们对于m再进行一下这样的操作，结果呢，第m位的左边都小于等于它，右边都大于等于它。除去所有等于关键字的情况，程序运行完之后就是介于第k小和第m小之间的数字。时间复杂度呢，我想不是简单的O（n） + O（n），这个值具体是多少要是分析的话没有任何现实意义，故略去 。但是总体值还是要接近期望O（n）.","title":"求最小的k个数字和求第k小的数字"},{"content":"【问题描述】     我有一个VisualStudio 2008的工程，它引用了Assembly nunit.framework.dll，以便进行单元测试。当我用一个帐号登录机器，用VS20008打开这个工程，在工程的References下面能够找到，VS能够找到对nunit.framework.dll的引用。但是，当我用另外一个帐号登录机器是，再用VS20008打开这个工程，在工程的References下面的nunit.framework前面出现了一个黄色的惊叹号，它表示VS没有找到对nunit.framework.dll的引用。这是为什么呢？ 【问题解决】 1. 首先要弄清楚VS是如何去查找应用的Assembly的。     VS在build工程的时候，是调用msbuild来完成的。所以，VS查找Assembly的方法与msbuild查找的方法是一样的。这样，我们通过直接调用msbuild来build这个工程，然后分析日志文件就能找到原因。在这里，我们需要使用到msbuild的一个参数：/verbosity:level（见参考1）。level包含这几种：q[uiet], m[inimal], n[ormal], d[etailed], and diag[nostic]。这里我们需要使用到最后一种，也是给出信息最多的一种，它是 diag[nostic]。例如：                                c:\\temp> msbuild /verbosity:diag test.csproj >output.log 运行完这条命令，会在c:\\temp下生成output.log。分析这个文件，我们就能够知道VS到底会在哪些目录下查找nunit.framework.dll。      以下是我给出的两份output.log文件中有关查找nunit.framework.dll的部分：      1）build成功的output.log       Primary reference \"nunit.framework, Version=2.6.1.12217, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77\". (TaskId:89)       Resolved file path is \"C:\\Program Files (x86)\\NUnit 2.6.1\\bin\\framework\\nunit.framework.dll\". (TaskId:89)       Reference found at search path location \"{Registry:Software\\Microsoft\\.NetFramework,v3.5,AssemblyFoldersEx}\". (TaskId:89)           For SearchPath \"{CandidateAssemblyFiles}\". (TaskId:89)           ......           For SearchPath \"{TargetFrameworkDirectory}\". (TaskId:89)           Considered \"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\v3.5\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\v3.5\\nunit.framework.dll\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\v3.0\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\v3.0\\nunit.framework.dll\", but it didn't exist. (TaskId:89)           Considered \"C:\\Windows\\Microsoft.NET\\Framework\\v3.5\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"C:\\Windows\\Microsoft.NET\\Framework\\v3.5\\nunit.framework.dll\", but it didn't exist. (TaskId:89)           Considered \"C:\\Windows\\Microsoft.NET\\Framework\\v3.0\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"C:\\Windows\\Microsoft.NET\\Framework\\v3.0\\nunit.framework.dll\", but it didn't exist. (TaskId:89)           Considered \"C:\\Windows\\Microsoft.NET\\Framework\\v2.0.50727\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"C:\\Windows\\Microsoft.NET\\Framework\\v2.0.50727\\nunit.framework.dll\", but it didn't exist. (TaskId:89)           For SearchPath \"{Registry:Software\\Microsoft\\.NetFramework,v3.5,AssemblyFoldersEx}\". (TaskId:89)           Considered \"C:\\Program Files (x86)\\NUnit 2.6.1\\bin\\framework\\nunit.framework.exe\", but it didn't exist. (TaskId:89)       Found related file \"C:\\Program Files (x86)\\NUnit 2.6.1\\bin\\framework\\nunit.framework.xml\". (TaskId:89)      2）build失败的output.log  Primary reference \"nunit.framework, Version=2.6.1.12217, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL\". (TaskId:89) C:\\Windows\\Microsoft.NET\\Framework\\v3.5\\Microsoft.Common.targets : warning MSB3245: Could not resolve this reference. Could not locate the assembly \"nunit.framework, Version=2.6.1.12217, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL\". Check to make sure the assembly exists on disk. If this reference is required by your code, you may get compilation errors.           For SearchPath \"{CandidateAssemblyFiles}\". (TaskId:89)           ......           For SearchPath \"{TargetFrameworkDirectory}\". (TaskId:89)           Considered \"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\v3.5\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\v3.5\\nunit.framework.dll\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\v3.0\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\v3.0\\nunit.framework.dll\", but it didn't exist. (TaskId:89)           Considered \"C:\\Windows\\Microsoft.NET\\Framework\\v3.5\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"C:\\Windows\\Microsoft.NET\\Framework\\v3.5\\nunit.framework.dll\", but it didn't exist. (TaskId:89)           Considered \"C:\\Windows\\Microsoft.NET\\Framework\\v3.0\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"C:\\Windows\\Microsoft.NET\\Framework\\v3.0\\nunit.framework.dll\", but it didn't exist. (TaskId:89)           Considered \"C:\\Windows\\Microsoft.NET\\Framework\\v2.0.50727\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"C:\\Windows\\Microsoft.NET\\Framework\\v2.0.50727\\nunit.framework.dll\", but it didn't exist. (TaskId:89)           For SearchPath \"{Registry:Software\\Microsoft\\.NetFramework,v3.5,AssemblyFoldersEx}\". (TaskId:89)           Considered \"C:\\Program Files (x86)\\Business Objects\\Common\\2.8\\managed\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Business Objects\\Common\\2.8\\managed\\nunit.framework.dll\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\Visual Studio Tools for Office\\PIA\\Office11\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\Visual Studio Tools for Office\\PIA\\Office11\\nunit.framework.dll\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\Visual Studio Tools for Office\\PIA\\Office12\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\Visual Studio Tools for Office\\PIA\\Office12\\nunit.framework.dll\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Microsoft.NET\\Primary Interop Assemblies\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Microsoft.NET\\Primary Interop Assemblies\\nunit.framework.dll\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Common Files\\Microsoft Shared\\MSEnv\\PublicAssemblies\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Common Files\\Microsoft Shared\\MSEnv\\PublicAssemblies\\nunit.framework.dll\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\Common7\\IDE\\PublicAssemblies\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\Common7\\IDE\\PublicAssemblies\\nunit.framework.dll\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\ReportViewer\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\ReportViewer\\nunit.framework.dll\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Common Files\\Microsoft Shared\\Visual Basic Power Packs\\1.1\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Common Files\\Microsoft Shared\\Visual Basic Power Packs\\1.1\\nunit.framework.dll\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\VSTA\\v9.0\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\VSTA\\v9.0\\nunit.framework.dll\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\VSTO\\v8.0\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\VSTO\\v8.0\\nunit.framework.dll\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\VSTO\\v9.0\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\VSTO\\v9.0\\nunit.framework.dll\", but it didn't exist. (TaskId:89)           For SearchPath \"{AssemblyFolders}\". (TaskId:89)           Considered \"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\v3.0\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\v3.0\\nunit.framework.dll\", but it didn't exist. (TaskId:89)           Considered \"c:\\Program Files (x86)\\Microsoft SQL Server\\90\\SDK\\Assemblies\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"c:\\Program Files (x86)\\Microsoft SQL Server\\90\\SDK\\Assemblies\\nunit.framework.dll\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Microsoft SQL Server Compact Edition\\v3.5\\Desktop\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Microsoft SQL Server Compact Edition\\v3.5\\Desktop\\nunit.framework.dll\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\v3.5\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\v3.5\\nunit.framework.dll\", but it didn't exist. (TaskId:89)           Considered \"c:\\Program Files (x86)\\Microsoft.NET\\ADOMD.NET\\90\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"c:\\Program Files (x86)\\Microsoft.NET\\ADOMD.NET\\90\\nunit.framework.dll\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Microsoft Synchronization Services\\ADO.NET\\v1.0\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"C:\\Program Files (x86)\\Microsoft Synchronization Services\\ADO.NET\\v1.0\\nunit.framework.dll\", but it didn't exist. (TaskId:89)           For SearchPath \"{GAC}\". (TaskId:89)           Considered \"nunit.framework, Version=2.6.1.12217, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL\", which was not found in the GAC. (TaskId:89)           For SearchPath \"{RawFileName}\". (TaskId:89)           Considered treating \"nunit.framework, Version=2.6.1.12217, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL\" as a file name, but it didn't exist. (TaskId:89)           For SearchPath \"bin\\Debug\\\". (TaskId:89)           Considered \"bin\\Debug\\nunit.framework.exe\", but it didn't exist. (TaskId:89)           Considered \"bin\\Debug\\nunit.framework.dll\", but it didn't exist. (TaskId:89)       对比这两份日志文件，我们可以发现，VS会去注册表Software\\Microsoft\\.NetFramework,v3.5,AssemblyFoldersEx下面查找nunit.framework。一种登录情况能找到，另外一种登录情况下找不到，由此可以断定这应该是与HKEY_CURRENT_USER有关。因此我们可以推断出的完整注册表项是：HKEY_CURRENT_USER\\Software\\Microsoft\\.NetFramework\\3.5\\AssemblyFoldersEx。果然，我发现，在能成功build的登录方式下，可以看到这个注册表项有默认值C:\\Program Files (x86)\\NUnit 2.6.1\\bin\\framework\\；而在另一种登录方式下去找不到这个注册表项。 2. 解决办法     通过上述的分析，解决办法就很简单了，只要把这个缺失的注册表项填上就可以了。具体步骤如下：     1）用能够build成功的帐号登录，打开注册表编辑器regedit.exe，找到注册表项HKEY_CURRENT_USER\\Software\\Microsoft\\.NetFramework\\3.5\\AssemblyFoldersEx，右键该项，在弹出菜单中选择export命令。     2）然后在用build失败的帐号登录，找到第一步中export出来的文件，右键它，在弹出菜单中选择merge命令就可以了。 【总结】     这里给出的使用msbuild /verbosity:diag来查找问题的方法很有用，它不仅解决有关references的问题，还可以用来查找很多其它的有关build的问题。      参考资料： 1. http://msdn.microsoft.com/en-us/library/ms164311.aspx","title":"解决VisualStudio找不到对nunit.framework.dll的引用"},{"content":"ExecutorService建立多线程的步骤： 1。定义线程类 class Handler implements Runnable{ } 2。建立ExecutorService线程池 ExecutorService executorService =Executors.newCachedThreadPool(); 或者 int cpuNums = Runtime.getRuntime().availableProcessors();                //获取当前系统的CPU 数目 ExecutorService executorService=Executors.newFixedThreadPool(cpuNums * POOL_SIZE);                //ExecutorService通常根据系统资源情况灵活定义线程池大小 3。调用线程池操作 循环操作，成为daemon,把新实例放入Executor池中      while(true){        executorService.execute(newHandler(socket));            // class Handler implements Runnable{        或者        executorService.execute(createTask(i));            //private static Runnable createTask(final int taskID)      } execute(Runnable对象)方法 其实就是对Runnable对象调用start()方法 （当然还有一些其他后台动作，比如队列，优先级，IDLE timeout，active激活等） 几种不同的ExecutorService线程池对象 1.newCachedThreadPool()  -缓存型池子，先查看池中有没有以前建立的线程，如果有，就reuse.如果没有，就建一个新的线程加入池中 -缓存型池子通常用于执行一些生存期很短的异步型任务  因此在一些面向连接的daemon型SERVER中用得不多。 -能reuse的线程，必须是timeout IDLE内的池中线程，缺省timeout是60s,超过这个IDLE时长，线程实例将被终止及移出池。   注意，放入CachedThreadPool的线程不必担心其结束，超过TIMEOUT不活动，其会自动被终止。 2. newFixedThreadPool -newFixedThreadPool与cacheThreadPool差不多，也是能reuse就用，但不能随时建新的线程 -其独特之处:任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子 -和cacheThreadPool不同，FixedThreadPool没有IDLE机制（可能也有，但既然文档没提，肯定非常长，类似依赖上层的TCP或UDPIDLE机制之类的），所以FixedThreadPool多数针对一些很稳定很固定的正规并发线程，多用于服务器 -从方法的源代码看，cache池和fixed池调用的是同一个底层池，只不过参数不同: fixed池线程数固定，并且是0秒IDLE（无IDLE） cache池线程数支持0-Integer.MAX_VALUE(显然完全没考虑主机的资源承受能力），60秒IDLE   3.ScheduledThreadPool -调度型线程池 -这个池子里的线程可以按schedule依次delay执行，或周期执行 4.SingleThreadExecutor -单例线程，任意时间池中只能有一个线程 -用的是和cache池和fixed池相同的底层池，但线程数目是1-1,0秒IDLE（无IDLE） 上面四种线程池，都使用Executor的缺省线程工厂建立线程，也可单独定义自己的线程工厂 下面是缺省线程工厂代码:     staticclass DefaultThreadFactory implements ThreadFactory {        static final AtomicInteger poolNumber = new AtomicInteger(1);        final ThreadGroup group;        final AtomicInteger threadNumber = new AtomicInteger(1);        final String namePrefix;        DefaultThreadFactory() {            SecurityManager s = System.getSecurityManager();            group = (s != null)? s.getThreadGroup():Thread.currentThread().getThreadGroup();                       namePrefix = \"pool-\" + poolNumber.getAndIncrement() +\"-thread-\";        }        public Thread newThread(Runnable r) {            Thread t = new Thread(group, r,namePrefix +threadNumber.getAndIncrement(),0);            if (t.isDaemon())                t.setDaemon(false);            if (t.getPriority() != Thread.NORM_PRIORITY)                t.setPriority(Thread.NORM_PRIORITY);            return t;        }     } 也可自己定义ThreadFactory，加入建立池的参数中  public static ExecutorServicenewCachedThreadPool(ThreadFactorythreadFactory) { Executor的execute()方法 execute() 方法将Runnable实例加入pool中,并进行一些pool size计算和优先级处理 execute() 方法本身在Executor接口中定义,有多个实现类都定义了不同的execute()方法 如ThreadPoolExecutor类（cache,fiexed,single三种池子都是调用它）的execute方法如下：      publicvoid execute(Runnable command) {        if (command == null)            throw new NullPointerException();        if (poolSize >= corePoolSize ||!addIfUnderCorePoolSize(command)) {            if (runState == RUNNING &&workQueue.offer(command)) {                if (runState != RUNNING || poolSize == 0)                    ensureQueuedTaskHandled(command);            }            else if (!addIfUnderMaximumPoolSize(command))                reject(command); // is shutdown or saturated        }     }","title":"ExecutorService线程池"},{"content":"  Partial Template Specialization能够让你在模板(Template)的所有可能的实体中特化出一组子集.   1.模板的特化(template specialization):     例如,定义如下的一个模板:     template<class Window, class Controller>     class Widget     {       ... 泛化实现代码 ...     };     然后你可以像下面那样明确地加以特化:     template<>    //注意:template后面的尖括号中不带任何内容;     class Widget<ModalDialog, MyController>     {       ... 特化实现代码 ...     };     其中ModalDialog和MyController是你自己另外定义的类;有了这个Widget的特化定义之后,如果你以后定义了Widget<ModalDialog, MyController>对象时,编译器就会使用上述的特化定义,如果定义了其它泛型对象,那么编译器就是用原本的泛化定义;这就是模板的特化.   2.Partial Template Specialization(模板偏特化)     模板特化是通过\"给模板中的所有模板参数一个具体的类\"的方式来实现的.而模板偏特化则是通过\"给模板中的部分模板参数以具体的类,而留下剩余的模板参数仍然使用原来的泛化定义\"的方式来实现的;     比如,就上面的Widget类模板的定义来说,有时候想针对任意的Window来搭配一个特定的MyController类特化Widget,这个时候就需要使用模板偏特化机制了.下面的Widget类模板就是Widget的偏特化定义:     template<class Window>                        //仍然使用原来的泛化定义;     class Widget<Window, MyController>            //MyController是具体的类,是特化定义;     {       ... 偏特化实现代码 ...     };     这就是一个偏特化定义;一个MyController类可以搭配任意一种Window.     通常在一个类模板的偏特化定义中,你只会特化某些模板参数而留下其它泛化参数.当你在程序中具体实现上述类模板的时,编译器会试着找出最匹配的模板定义.这个寻找过程十分复杂精细,允许你以富有创意的方式来进行偏特化.例如,假设你有一个Button类模板,它有一个模板参数,那么,你不但可以拿任意的Window搭配特定的MyController来特化Widget,还可以拿任意Button搭配特定的MyController来偏特化Widget:     template<class ButtonArg>     class Widget<Button<ButtonArg>, MyController>    //使用任意Button搭配具体的类MyContorller     {       ... 偏特化实现代码 ...     };     模板的偏特化能力很强大.当你实例化一个模板时,编译器会把目前存在的偏特化模板和全特化模板做比较,并找出其中最合适、最匹配的实现.这样,灵活性就很大.但是不幸的是,模板的偏特化机制不能用在函数身上,不论成员函数还是非成员函数.   注意:   1.虽然你可以全特化类模板中的成员函数,但是你不能偏特化他们;   2.你不能偏特化命名空间级别(namespace-level)的函数(non-member).最接近\"命名空间级别模板函数\"的偏特化机制就是函数重载,那就意味着你对\"函数参数\"(而非返回值类型或内部所用类型)有很精致的特化能力;   3.特化或全特化时,template后面的尖括号中不带任何内容;   总结:   模板特化/全特化是指给每一个模板参数一个具体的类型,以具体实现这个模板,而且template后面的尖括号中不带任何内容;   模板偏特化是指只给部分模板参数一个具体的类型,来实现这个模板;","title":"模版的特化与偏特化"},{"content":"0. Java支持元数据(MetaData), 也就是Annotation(注释), 这种Annotation其实就是代码里的特殊标记, 这些标记可以在编译、类加载、运行时被读取, 并执行相应的处理.  - 元数据 是\"描述数据的数据(data about data)\".  - Annotation能被用来为程序元素(类、方法、成员变量等)设置元数据.  1. Annotation(既是注释)也是一个接口, 程序可以通过反射来获取指定程序元素的Annotation对象, 然后通过Annotation对象来取得注释里的元数据.  2. 访问和处理Annotation的工具统称APT(Annotation Processing Tool).  3. 使用Annotation时要在其前面增加@符号, 并把该Annotation当成一个修饰符使用, 用于修饰它支持的程序元素. 四个基本Annotation: @Override: 强制一个方法必须覆盖父类的方法. (告诉编译器检查这个方法, 确保父类包含一个能被该方法重写的方法, 否则报错. @Override只能用于方法. ) @Deprecated: 表示某个程序元素(类、方法等)已过时, 使用已过时的程序元素时, 便以其给出警告.  @SuppressWarnings: 使被修饰的程序元素(以及该程序元素中所有的子元素)取消显示指定的编译器警告. 使用时要在括号里使用name=value形式为该Annotation的成员变量设置值.  import java.util.*;@SuppressWarnings(value=\"unchecked\")public class SuppressWarningsTest{\tpublic static void main(String[] args)\t{\t\tList<String> myList = new ArrayList();\t}} @SafeVarargs: Java7专门为抑制\"堆污染(heap pollution)\"警告提供的.  4. jDK除了在java.lang下提供了4个基本的Annotation之外, 还在java.lang.annotation包下提供了4个Meta Annotation(元 Annotation), 这四个元Annotation都用于修饰其他的Annotation定义.  @Retention只能用于修饰一个Annotation定义, 用于指定被修饰的Annotation可以保留多长时间, @Retention包含一个RetentionPolicy类型的value成员变量, 所以使用@Retention时必须为该value成员变量指定值.  value成员变量的值只能是如下三种: - RetentionPolicy.CLASS: 编译器把Annotation记录在class文件中. 当运行Java程序时, JVM不再保留Annotation. 这是默认值.  - RetentionPolicy.RUNTIME: 编译器把Annotation记录在class文件中. 当运行Java程序时, JVM也会保留Annotation, 程序可以通过反射获取该Annotation信息.  - RetentionPolicy.SOURCE: Annotation只保留在源代码中, 编译器直接丢弃这种Annotation.  //定义Testable Annotation保留到运行时@Retention(value = RetentionPolicy.RUNTIME)public @interface Testable{}//等同于下面这样:@Retention(RetentionPolicy.RUNTIME)  //使用Annotation里名为value的成员变量时, 直接在括号里指定value值就行, 不必使用name=value形式. public @interface Testable{} @Target也只能修饰一个Annotation定义, 它用于指定被修饰的Annotation能用于修饰哪些程序单元. @Target元Annotation也包含一个名为value的成员变量, 其值可能是如下几种: - ElementType.ANNOTATION_TYPE: 指定该策略的Annotation只能修饰Annotation. - ElementType.CONSTRUCTOR: 指定该策略的Annotation只能修饰构造器.  - ElementType.FIELD: 成员变量.  - ElementType.LOCAL_VARIABLE: 局部变量.  - ElementTpye.METHOD: 方法定义.  - ElementType.PACKAGE: 包定义.  - ElementType.PARAMETER: 参数.  - ElementType.TYPE: 指定该策略的Annotation可以修饰类、接口(包括注释类型)或枚举定义.  @Documented用于指定被该元Annotation修饰的Annotation类将被javadoc工具提取成文档, 如果定义Annotation类时使用了@Documented修饰, 则所有使用该Annotation修饰的程序元素的API文档中将或包含该Annotation说明.  @Inherited 元Annotation指定被他修饰的Annotation将具有继承性(如果某个类使用了@A  Annotation(定义该Annotation时使用了@Inherited修饰)修饰, 则其子类将自动被@A 修饰.).  5. 定义新的Annotation类型 使用@interface关键字, 定义一个新的Annotation类型与定义一个接口很像, 如下代码可以定义一个简单的Annotation类型: public @interface Test{}  或者带成员变量的Annotation(成员变量在Annotation中以无形参的方法的形式, 方法名和其返回值定义了该成员变量的名字和类型.): public @interface MyTag{\tString name();\tint age() default 32;  // 用default关键字为Annotation的成员变量指定初始值. }  6. 根据Annotation是否包含成员变量, 将其分两类. 标记Annotation: 没有成员变量的Annotation. 这种Annotation利用自身存在与否来提供信息. 元数据Annotation: 包含成员变量的Annotation. 因为它们能接受更多的元数据, 所以也被称为元数据Annotation.  7. 使用Annotation的语法类似于修饰符, 可用于类、接口、方法、变量等, 通常放在修饰符之前单独一行. 带有成员变量的Annotation使用时必须制定成员变量的值(或定义时指定初始值(默认值).).  8. 提取Annotation信息. .  ..  .这章写的真乱. 当一个Annotation类型被定义为运行时Annotation后, 该Annotation才会在运行时可见, JVM才会在装在*.class文件时读取保存在class文件中的Annotation.  java.lang.reflect包下的AnnotatedElement接口代表程序中可以接受注释的程序元素. 其主要实现类: - Class: 类定义.  - Constructor: 构造器定义.  - Field: 类成员定义.  - Method: 类的方法定义.  - Package: 类的包定义.  程序通过反射获取某个类的AnnotatedElement对象(如Class、Method等)之后, 就可以通过调用该对象的如下三个方法来访问Annotation信息.  - getAnnotation(Class<T> annotationClass): 返回该程序元素上存在的指定类型的注释, 若不存在, 返回null.  - Annotation[] getAnnotations(): 返回该程序元素上存在的所有注释.  - boolean isAnnotationPresent(Class<? extends Annotation> annotationClass): 判断该程序元素上是否存在指定类型的注释, 存在返true, 木有返false.  9. APT(Annotation Processing Tool, 注释处理工具) 可以找出源码中的Annotation, 并对其进行额外的处理. Annotation处理器在处理Annotation时会生成额外的源文件和其他的文件(文件具体内容由Annotation处理器的编写者决定), APT还会用编译生成的源代码文件和原来的源文件一起生成class文件. (APT可以在编译是生成一些附属文件, 如源文件、类文件、程序发布描述文件等.)  10. javac.exe工具可以使用-processor选项指定一个Annotation处理器, 指定的处理器将在编译过程中处理源文件中的Annotation.  11. 每个Annotation处理器都必须实现javax.annotation.processing包下的Processor接口. 不过, 通常采用集成AbstractProcessor的方式避免实现Processor过多的方法. (核心类位于java包及其子包下, 扩展类位于javax包及其子包下.) ","title":"[疯狂Java讲义精粹] 第九章|Annotation(注释)"},{"content":"编译优化 　　C语言没有汇编快，因为C语言要由编译器翻译为汇编，编译器毕竟是人造的，翻译出来的汇编源代码总有那么N条指令在更智能、更有创造性的我们看来是多余的。 　　C语言翻译后的汇编有如下恶劣行径： C语言偏爱内存。我们写的汇编一般偏爱寄存器，寄存器比内存要快很多倍。当然，寄存器的数量屈指可数，数据多了的话也必须用内存。 内存多余读。假如在一个 for 循环中经常要执行 ++i 操作，编译后的汇编可能是这样的情形： movl i, %eaxaddl $1, %eaxmovl %eax, i 即使 eax 寄存器一直存着 i 的值， C语言也喜欢操作它前先读一下，以上3条指令浓缩为一条 incl %eax 速度就快上好几倍了。 　　尽管C语言\"如此不堪\"，但是考虑到高级语言带来的源码可读性和开发效率在数量级上的提高，我们还是原谅了它。而且很多编译器都有提供优化的选项，开启优化选项后C语言翻译出来的汇编代码几近无可挑剔。 　　VC、VS有 Debug、Release 编译模式， Release 下编译后，程序的大小、执行效率都有显著的改善。 gcc 也有优化选项，我们来看看 gcc 优化的神奇效果： 　　我故意写了一个垃圾程序（math.c）： #include <stdio.h>int main(){    int a=1, b=2;    int c;    c = a + a*b + b;    printf(\"%d\\n\", c);    return 0;} 且看看不优化的情况下，汇编代码有多么糟糕： 编译命令：gcc -S math.c main部分的汇编代码： main:    pushl   %ebp    movl    %esp, %ebp    andl    $-16, %esp    subl    $32, %esp    movl    $1, 28(%esp)    # 28(%esp) 是 a    movl    $2, 24(%esp)    # 24(%esp) 是 b    movl    24(%esp), %eax  #\\    addl    $1, %eax        #-\\    imull   28(%esp), %eax  #-eax=(b+1)*a    addl    24(%esp), %eax  #\\    movl    %eax, 20(%esp)  #-c=(b+1)*a+b    movl    $.LC0, %eax    movl    20(%esp), %edx    movl    %edx, 4(%esp)    movl    %eax, (%esp)    call    printf    movl    $0, %eax    leave    ret 汇编代码规模庞大，翻译水平中规中矩。现在开启优化选项： 编译命令：gcc -O2 -S math.c main:    pushl   %ebp    movl    %esp, %ebp    andl    $-16, %esp    subl    $16, %esp    movl    $5, 4(%esp)    movl    $.LC0, (%esp)    call    printf    xorl    %eax, %eax    leave    ret 　　规模变为原来的一半，而且 gcc 发现了 a、b、c 变量是多余的，直接将结果 5 传给 printf 打印了出来 ——计算器是编译器必备的一大技能。初中那时候苦逼地做计算题，怎么就不学学C语言呢O(∩_∩)O~","title":"编译优化"},{"content":"习惯的思维 用习惯了C的人要看一个程序时首先会想到找到那个main函数在哪,然后再顺着往下看.因为main函数作为程序的入门点,整个程序都是从那开始执行的.当在C++中SDK(win32 API project)开发时也继承沿用C的思维,是有个main函数,不过现在的main函数改名字了,叫WinMain,当然有时还有变体,比如叫_tWinMain,反正名字中总会带个Main,让我们一看就知道.而在QT中就跟C一样,就老实的来个标准的main函数. 我们会发现C++中可以有一个单独的main函数,不用包含在哪个类中,另外还有不属于任何类的全局变量或全局函数这自然就不是纯粹的面向对象语言了.所以说C++支持多种编程范式嘛,可以是跟C完全一样的面向过程范式,或者再加些普通的类就是基于对象的范式了,如果再用到继承和多态就是面向对象了,而要是用到模板就是泛型范式了.而且这些范式可以互相混合用.而C#就是纯的面向对象,所以它里面虽然也有main函数,但也是要放在一个类里面去,至于具体放哪个类无所谓,你随便放.一般默认是放Program这个类里.当然并不是说纯的面向对象就比混合的范式好,应该各有优缺点. 哎扯得有点远了,言归正传.   SDK中的流程 开发一个带界面的SDK程序大致流程是这样的.首先自然是要有个main函数做入口点.然后按下面的步骤来(为了讨论方便,只说大概流程,代码也是不完整的) int _tWinain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow) {    MSG msg;    InitApplicatio(HINSTANCE hInstance)   //第1步,注册窗体类,并在这里指定了窗体过程WndProc    InitInstance(HINSTANCE hInstance, int nCmdShow)   //第2步,创建窗体 while (GetMessage(&msg, NULL, 0, 0))    //第3步消息循环,分派消息 { TranslateMessage(&msg); DispatchMessage(&msg); } return (int) msg.wParam;  //第4步,退出程序 } BOOL InitApplicatio(HINSTANCE hInstance) {   return RegisterClass(...); } BOOL InitInstance(HINSTANCE hInstance, int nCmdShow) { CreateWindow(...); //创建窗体 ShowWindow(...); //显示窗体 UpdateWindow(...); //送出WM_PAINT return TRUE; } LRESULT CALLBACK WndProc(...){ }   在MFC中生成一个有界面的程序大体过程也一样,只不过封装起来了.那我们感兴趣的就是两个问题. 1.MFC中有没有main函数了,如果有它跑哪去了?  2.如果有main函数,它里面的那4步涉及到的具体推行是否也跟win32 API一样? 下面我们就来一一解答下   MFC封装背后流程   实际上候捷那本深入浅出MFC里面有讲的很清楚了.不过由于讲的太详细了,有几十页,看的容易晕,而且他举的例都是老版本的MFC类,在新版本中一些类的函数会有一点点变化. 我这里就只概括的讲下最简洁的流程.先假如有类CMyApp继承自CWinApp吧   1.针对第一个问题,MFC里是有用到main函数的 // export WinMain to force linkage to this module extern int AFXAPI AfxWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, _In_ LPTSTR lpCmdLine, int nCmdShow); 就是这一个函数,在MFC的源文件appmodul.cpp中能看到这些代码,那这个main怎么被MFC调用的呢,你看那注释,是linkage to this module,也就是被链接器去调用的.准确说是被C-Runtime DLL,C运行时动态链接库调用的. 调用main的顺序 我们知道在MFC中能从代码里看到的入口点是定义一个全局的继承于CWinApp的类.比如CMyApp theApp;这样定义下.在C++中全局变量是先于main被执行的,所以先初始化theApp后才接着调用main   2.针对第2个问题,main函数里具体的操作. 知道了有main函数,你心里可能有一丝安慰了.但还是有些觉得不安的是这main函数里的具体操作是否跟SDK中的一样,是不是也来那么几步,先注册窗口再创建窗口之类的. 答案是MFC调用的main函数大概流程差不多是那样,但实现细节很不一样.我们看下上面说的AfxWinMain里面的内容是啥吧.你可以在winmain.cpp中看到详细代码. 把这个main函数简化一下,做的操作大概是这样, AfxWinMain(...) {   //先通过一个全局函数获得CWinApp和CWinThread的指针,因为调用main之前已经初始化了这两个类.CMyApp初始化时也会初始化他的父类CWinApp,及父类的父类CWinThread    CWinThread* pThread = AfxGetThread();     CWinApp* pApp = AfxGetApp();       //这下面几个函数就差不多是完成前面讲的SDK中的所有步骤     pApp->InitApplication();     pThread->InitInstance();     pThread->Run();       AfxWinTerm(); //结束程序    } 反正结束程序我们就不用管了,重点关心前面的三步,注册窗口,创建窗口,还是消息分派. 前面的SDK程序中也恰好有函数InitApplication 注册窗口, InitInstance创建并显示窗口.而Run函数你猜想可能是分派消息的..其实大体思路还是没错,但实现细节还是有蛮多区别. pp->InitApplication();这函数实际上并没有注册窗口.注册窗口,创建显示窗口全是在pThread->InitInstance();这函数中完成,InitInstance是个虚函数,而且我们在自己的代码中会重写它.所以最后调用的是我们自己写的那个InitInstance函数,这就是面向对象里多态的功能了啊.你指针最终指向对应的子类定义的函数. BOOL CMyApp::InitInstance() {  m_pMainWnd = new CMyFrameWnd; //这张操作会注册并创建窗口,m_pMainWnd就是返回的窗口句柄 m_pMainWnd->ShowWindow(m_nCmdShow); //显示窗口 m_pMainWnd->UpdateWindow(); }   pThread->Run();是分派消息,你可以在thrdcore.cpp中查看CWinThreed的run函数的源码,下面摘了一点点. // acquire and dispatch messages until a WM_QUIT message is received. for (;;) {} 不过关于消息的处理MFC用到了消息映射机制,比如复杂.这里不讨论了,反正大概就把CMyFrameWnd当成是窗口过程就行了.   总结起来可以这样简单的说,MFC中有main函数,但是由系统去调用.然后main函数里面执行的操作差不多,只不过它是通过CWinApp和CWinThread的指针去调用一些相关的函数.而指针嘛由于调用了虚函数,所以用到了面向对象中的多态,于是转来转去的.然后最难的地方可能就是消息机制在这里更复杂一点了.不能简单的与SDK中做一对一的对比.  ","title":"MFC的Main函数跑哪去了"},{"content":"         最近一直在学习Perl，感觉很是强大，有好多有趣的函数，作用也是非常的灵活高效，下面是一些常用的函数，我已经处理成成对的，便于大家学习和使用。:-)   Perl 函数总结： 1.join/split      join 作用：把数组元素或者几个字符串通过分隔符连接成单个字符串.         格式：join(DELIMITER，ARRAY或string[1,2,3...])         实例：join(\":\",\"Time\",\"12\",\"30\");   ----> Time:12:30                   @strings= (\"Qin\", \"Zhi\", \"Guo\");                         （多个字符串）                   join(\":\",@strings);              -----> Qin:Zhi:Guo     （一个字符串）  split 作用：通过指定的分隔符把字符串分割成若干个字段，形成一个数组返回。         格式：split(DELIMITER,STRING);                   split(DELIMITER,STRING,LIMIT);                        split(DELIMITER);         实例： $char=\"a/b/c/d/e/f\";    （一个字符串）                   @letters=split(\"/\",$char);                   print \"1.@letters\\n\";                   输出结果：a b c d e f   （多个字符串） 2.Pop/Push Pop  作用：将数组的最后一个元素取出并返回。                  格式   @array=5..9;                     $fred=pop(@array);#$fred得到9，@array现在为（5，6，7，8）                     $barney=pop@array;#$barneygets8,@array现在为（5,6,7）                     pop@array;#@array现在为（5，6）(7被丢弃了)  -----允许弹出的元素不被变量接受这种情况。                           if 数组为空，则pop do nothing, return undef  Push 作用：将一个元素（或者一列元素）加在数组的末尾。           格式：                         push(@array,0);          #@array现在为(5,6,0)                              push@array,8;             #@array现在为（5，6，0，8）                              push@array,1．．10; #@array现在多了10个元素                              @others=qw/90210/;                              push@array,@others; #@array现在又多了5个元素（共有19个）                              push的第一个参数或者pop的唯一参数必须是数组变量。 3.shift/unshift shift和unshift不同于pop/push是对数组的开头进行操作。 #################################################################### # unshift 和shift 对一个数组的开头进行操作（数组的左端有最小下标的元素）。 # unshift 和shift，如果其数组变量为空，则返回undef。 #################################################################### #!/usr/bin/perl -w @array = qw#one two three#; $m = shift (@array); #$m 得到“one”, @array 现在为(“two”, “three”) shift @array;    #@array 现在为（“three”） shift @array;    #@array 现在为空 $n = shift @array;    #$n 得到undef, @arry 仍为空 unshift(@array,5);    #@array 现在为（5） unshift @array,4;     #@array 现在为(4,5) @others = 1..3; unshift @array, @others; #array 现在为（1,2,3,4,5）","title":"Perl 中有趣的函数"},{"content":"在分析天嵌逻辑程序时，遇到条件，突然脑子有点转不过弯来，现在对“条件编译”进行复习： 条件编译常用以下几种格式 1、 #ifdef  标识符 程序段1 #else 程序段2 #endif 作用：若指定的标识符已经被#define定义，则在程序编译阶段编译程序段1；否则编译程序段2。 2、 #ifndef  标识符 程序段1 #else 程序段2 #endif 作用：（巧好和ifdef相反）若指定的标识符没有被#define定义，则在程序编译阶段编译程序段1；否则编译程序段2。 3、  #if  表达式 程序段1 #else 程序段2 #endif 作用：当指定的表达式值为真(非0）时，就编译程序段1；否则编译程序段2 。 下面就是程序中应用条件编译的部分： #if((LCD_Type == LCDW35) || (LCD_Type == LCDS35))\t// 3.5寸屏\textern unsigned char TQ_LOGO_320240[];//自定义的图片#elif(LCD_Type == LCDT35)\t\t\t\t// 3.5寸屏\textern unsigned char TQ_LOGO_240320[];//自定义的图片#elif(LCD_Type == LCDW43)\t\t\t\t// 3.5寸屏\textern unsigned char TQ_LOGO_480272[];//自定义的图片#elif(LCD_Type == VGA)\t\t\t\t\t//VGA\textern unsigned char TQ_LOGO_640480[];//自定义的图片#elif(LCD_Type == LCDA70)\t\t\t\t// 7寸屏\textern unsigned char TQ_LOGO_800480[];//自定义的图片#endif","title":"条件编译--几种常用的格式"},{"content":"未初始化全局变量 　　为下一篇介绍进程内存分布做准备，这一篇先来介绍一下未初始化全局变量： 　　未初始化全局变量，这名字就很直白，就是 C 程序中定义成全局作用域而又没有初始化的变量，我们知道这种变量在程序运行后是被自动初始化为 全0 的。编译器编译的时候会将这类变量收集起来集中放置到 .bss 段中，这个段只记录了段长，没有实际上的内容（全是0，没必要存储），在程序被装载时操作系统会为它分配等于段长的内存，并全部初始化为0。 　　这有两个 C程序，都定义了全局数组 data（长度为1M，占用内存4MB），一个部分初始化（bss_init1.c），一个未初始化（bss_uninit1.c）： bss_init1.c： #include <stdio.h>#include <windows.h>#define MAXLEN 1024*1024int data[MAXLEN]={1,};int main(){    Sleep(-1);    return 0;} bss_uninit1.c： #include <stdio.h>#include <windows.h>#define MAXLEN 1024*1024int data[MAXLEN];int main(){    Sleep(-1);    return 0;} 　　编译以上两个程序后： 　　可以看到有初始化的可执行文件的大小差不多是4MB，而未初始化的只有47KB！这就是 .bss 段有段长，而没有实际内容的表现。用 UltraEdit 打开 bss_init1.exe 可看到文件中大部分是全0（data数组的内容）： 　　但是接下来运行（return 0 之前的 Sleep(-1) 保证了程序暂时不会退出）的时候，却发现 bss_init1.exe 占用的空间明显少于 4MB，这是怎么回事呢？ 　　这就涉及程序装载的策略了。早期的操作系统（如：linux 0.01）采用的是一次装载：将可执行文件一次性完整装入内存后再执行程序。不管程序是 1KB 还是 60MB，都要等全部装入内存后才能执行，这显然是不太合理的。 　　而现在的操作系统都是采用延迟装载： 将进程空间映射到可执行文件之后就开始执行了，执行的时候如果发现要读/写的页不在内存中，就根据映射关系去读取进来，然后继续执行应用程序（应该是在页保护异常的处理中实现的）。 　　bss_init1.exe 肯定是被映射了，而程序中又没有对 data 数组进行读/写操作，所以操作系统也就懒得去装入这片内存了。下面修改一下这两个程序：在 Sleep(-1) 前将 data 数组的每个元素赋值为 -1： int i;for(i=0; i<MAXLEN; ++i)    data[i] = -1; 　　再运行，它们占用的内存都是 4M 了：","title":"未初始化全局变量"},{"content":"       在《WMI技术介绍和应用——使用VC编写一个半同步查询WMI服务的类》一文中，我们介绍到了一个半同步查询WMI类的框架。本文将是该技术的一个应用，介绍如何使用WMI技术查询正在运行的进程信息。（转载请指明出于breaksoftware的csdn博客）         如何使用WMI枚举正在运行的进程的进程名？ CSynQueryData recvnotify(L\"root\\\\CIMV2\",L\"SELECT Caption FROM Win32_Process\" );recvnotify.ExcuteFun();                 如何使用WMI枚举正在运行的进程的进程ID？     CSynQueryData recvnotify(L\"root\\\\CIMV2\",L\"SELECT ProcessId FROM Win32_Process\" );    recvnotify.ExcuteFun();         如何使用WMI枚举正在运行的进程的父进程ID？     CSynQueryData recvnotify(L\"root\\\\CIMV2\",L\"SELECT ParentProcessId FROM Win32_Process\" );    recvnotify.ExcuteFun();         如何使用WMI枚举正在运行的进程在启动时的命令？     CSynQueryData recvnotify(L\"root\\\\CIMV2\",L\"SELECT CommandLine FROM Win32_Process\" );    recvnotify.ExcuteFun();         如何使用WMI枚举正在运行的进程是何时启动的？     CSynQueryData recvnotify(L\"root\\\\CIMV2\",L\"SELECT CreationDate FROM Win32_Process\" );    recvnotify.ExcuteFun();         如何使用WMI枚举正在运行的进程的文件路径？     CSynQueryData recvnotify(L\"root\\\\CIMV2\",L\"SELECT ExecutablePath FROM Win32_Process\" );    recvnotify.ExcuteFun();         如何使用WMI枚举正在运行的进程的用户时间和内核时间？     CSynQueryData recvnotify(L\"root\\\\CIMV2\",L\"SELECT UserModeTime,KernelModeTime FROM Win32_Process\" );    recvnotify.ExcuteFun();         如何使用WMI枚举正在运行的进程的线程数？     CSynQueryData recvnotify(L\"root\\\\CIMV2\",L\"SELECT ThreadCount FROM Win32_Process\" );    recvnotify.ExcuteFun();         如何使用WMI获取指定进程ID的进程的优先级？     CSynQueryData recvnotify(L\"root\\\\CIMV2\",L\"SELECT Name,Priority FROM Win32_Process Where ProcessId = 0 or ProcessID = 4\" );    recvnotify.ExcuteFun();         本文主要通过介绍WMI类Win32_Process来介绍查询进程信息，只是抛砖引玉。如果想查询该类的更多信息，可以上MSDN检索。这个类是个非常重要的类，我会在之后的章节中介绍该类的一些方法。","title":"WMI技术介绍和应用——查询正在运行的进程信息"},{"content":"前不久开发板需要显示时钟，但是默认的是UTC时间，所以增加时区文件。 //复制上海时区/usr/share/zoneinfo/Asia/Shanghai文件为localtime到/etc下cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 但是调试时钟时发现，设置时间并写入硬件后，开机总是快8小时。 调查发现写入硬件使用的是hwclock -w，默认写出的是本地时间，而开机时内核是按照UTC写入时间的，刚好增加8小时。 所以讲hwclock -w 换成hwclock -uw即可正常工作了。 hwclock: invalid option -- yBusyBox v1.15.2 (2009-10-26 18:24:41 CST) multi-call binaryUsage: hwclock [-r|--show] [-s|--hctosys] [-w|--systohc] [-l|--localtime] [-u|--utc] [-f FILE]Query and set hardware clock (RTC)Options:        -r      Show hardware clock time        -s      Set system time from hardware clock        -w      Set hardware clock to system time        -u      Hardware clock is in UTC        -l      Hardware clock is in local time        -f FILE Use specified device (e.g. /dev/rtc2) //~End~","title":"硬件时钟和时区的问题"},{"content":"profile 主要是得到每个函数的使用时间，从而为优化提供一个数据支持 我的pc 环境 ubuntu 11.04 python2.7 如果按照 参考2 中 直接使用报错，官方文档建议使用cProfile import cProfilecProfile.run('foo()', 'fooprof') 但是还是会报错 ，说 pstats 找不到，但是直接import pstats 也失败 。 解决方案： sudo apt-get install python-profiler import cProfilecProfile.run(\"testDict()\")import pstatsp = pstats.Stats(\"prof.txt\")p.sort_stats(\"time\").print_stats() 参考： 1：http://docs.python.org/2/library/profile.html 2：http://blog.csdn.net/lanphaday/article/details/1483728  原始博客地址：http://www.fuxiang90.com/2012/12/python-profile-%E4%BD%BF%E7%94%A8/","title":"python profile 使用"},{"content":"static变量 及 作用域控制 一、static变量 　　static变量放在函数中，就只有这个函数能访问它；放在函数外就只有这个文件能访问它。 下面我们看看两个函数中重名的static变量是怎么区别开来的（static.c）： #include <stdio.h>void func1(){    static int n = 1;    n++;}void func2(){    static int n = 2;    n++;}int main(){    return 0;} 　　下面是编译后的部分汇编： func1:    pushl   %ebp    movl    %esp, %ebp    movl    n.1671, %eax    addl    $1, %eax    movl    %eax, n.1671    popl    %ebp    retfunc2:    pushl   %ebp    movl    %esp, %ebp    movl    n.1674, %eax    addl    $1, %eax    movl    %eax, n.1674    popl    %ebp    ret 　　好家伙！编译器居然\"偷偷\"地改了变量名，这样两个static变量就容易区分了。 　　其实static变量跟全局变量一样被放置在 .data段 或 .bss段 中，所以它们也是程序运行期间一直存在的，最终也是通过绝对地址来访问。但是它们的作用域还是比全局变量低了一级： static变量被标识为LOCAL符号，全局变量被标识为GLOBAL符号，在链接过程中，目标文件寻找外部变量时只在GLOBAL符号中找，所以static变量别的源文件是\"看不见\"的。 二、作用域控制 　　作用域控制为的是提高源代码的可读性，一个变量的作用域越小，它可能出没的范围就越小。 　　C语言中的变量按作用域从大到小可分为四种：全局变量、函数外static变量、函数内static变量、局部变量： 全局变量是杀伤半径最大的：不仅在定义该变量的源文件中可用，而且在任一别的源文件中只要用 extern 声明它后也可以使用，因此，当你看到一个全局变量的时候应该心生敬畏！ 函数外的static变量处于文件域中，只有定义它的源文件中可以使用。如果你看到一个static变量，那是作者在安慰你：哥们（妹子），这个变量不会在别的文件中出现。 函数内static变量在函数的每次调用中可用（只初始化一次）， 它同以上两种变量一样在程序运行期间一直存在，所以它的功能是局部变量无法实现的。 局部变量在函数的一次调用中使用，调用结束后就消失了。 　　显然，作用域越小越省心，该是局部变量的就不要定义成全局变量，如果\"全局变量\"只在本源文件中使用那就加个static。 　　即便是局部变量也还可以压缩其作用域： 　　有的同学写的函数一开头就声明了函数中要用到的所有局部变量，一开始我也这么做，因为我担心：如果把变量定义在循环体内，是不是每一次循环都会给它们分配空间、回收空间，从而降低效率？ 但事实是它们的空间在函数的开头就一次性分配好了（scope.c）： #include <stdio.h>int main(){    int a = 1;    {        int a = 2;        {            int a = 3;        }        {            int a = 4;        }    }    return 0;} 编译后的汇编代码如下： main:    pushl   %ebp    movl    %esp, %ebp    subl    $16, %esp    movl    $1, -4(%ebp)    movl    $2, -8(%ebp)    movl    $3, -12(%ebp)    movl    $4, -16(%ebp)    movl    $0, %eax    leave    ret 　　各层局部环境中的变量a是subl $16, %esp一次性分配好的。由此可见不是每个{}都要分配回收局部变量，一个函数只分配回收一次。因此，如果某个变量只在某个条件、循环中用到的话，还是在条件、循环中定义吧，这样，规模比较大的函数的可读性将提高不少，而效率丝毫没有下降，可谓是百利而无一害！","title":"static变量 及 作用域控制"},{"content":"1. chop和chomp函数 　　两个函数都以字符串作为参数，并去除其末尾最后一个字符。区别是，无论最后一个字符是什么，chop都会去除，并在返回值中返回；而仅当字符串最后一个字符与特殊变量$/保存的字符一样时，chomp才会将其去除。默认情况下$/保存换行字符，当然可以重设。 　　1）如果函数参数是一个字符串数组，那么函数会分别对数组中的每个元素调用。 　　2）如果函数参数是一个符合列表（即列表中还有其他列表或HASH表），则可以认为保存在参数列表中的是每个复合容器的地址（指针），而此时chop会将地址作为一个字符串处理，从而破坏整个复合列表。 　　顺带一提，如果一个变量是保存数值类型，而非字符串，该函数会把变量保存的数值解释成字符串。 2. getc函数 　　getc函数的参数只有一个，就是文件句柄，如果要从标准输入流读入，就使用STDIN。该函数返回读取的字节，要注意的是，如果读取的是文件流，则在EOF处函数返回空字符串，即''；如果读取标准输入流，则会一直阻塞。 3.拼接字符串 　　使用join函数可以拼接各个字符串，签名为join(delmiter, list)。其中delimiter是一个分隔字符串，在拼接结果中各个分离字符串以该delimiter分隔；list则是各个分离的字符串，也可以是一个保存着若干字符串的数组。 　　$str1 = \"stringA\" ;  $str2 = \"stringB\"; 　　$combine = join '::' , $str1 , $str2 ;  #$combine值为::stringA::stringB 　　@list1 = ( $str1 , $str2 );  @list2 = qw ( stringC  stringD ); 　　$combine = join '_' , @list1 , @list2 , $str1 ;  #$combine值为_stringA_stringB_stringC_stringD_stringA 　　分隔符使用\"\\n\"时，就可以拼接成垂直列表了。 4.分割字符串 　　使用split函数进行字符串分割。 　　split(delimiter , string , count) 　　delimiter是分隔符，默认是空格（以tab，空格等进行分割） 　　string是被分割的字符串，不指定该参数时，对$_进行分割 　　count允许分割的最大份数，当实际可以分割的份数超过该值时，第count份子串将保存剩余的字符串 　　函数返回一个数组，里面保存分割的所有字串 5.重复拼接字符串 　　Perl中的 x 操作符，注意操作数必须左边可解析成字符串，右边可解析成数值。 　　　　$str1 = \"abc\"; 　　　　$str2 = $str1 x 5;   # $str2的值为 \"abcabcabcabcabc\" 6.字串替换 　　substr(string, offset, length)： 　　string：原字符串 ， offset：字串所在原字符串中的起始位置 ， length：字串长度 　　该函数有两种用法： 　　　　1）获取子串 　　　　　   $str = \"abcdefghijk\"; 　　　　　   $sstr = substr( $str , 5 , 3 );   # $sstr的值为\"efg\" 　　　　2）替换子串 　　　　　　$str = \"1234567890\"; 　　　　　　substr( $str , 4 ,  3) = \"xxxxx\" ; # $str的值为\"123xxxxx7890\" 　　　　　　函数的第三个参数指定的是被替换子串的长度，因此不影响新替换的字串的长度.          3)  截取字符串末尾字符。              假如我们想截取掉一个字符串的末尾若干个字符。比如，\"aaa_1111_SC\",\"b_22_SC\",\"ccccc_3333333_SC\".这种情况下，字符长度都不同，假如我们想去掉字符串的末尾\"_SC“，那我们怎么办呢？              在Perl中允许我们从末尾开始计数，比如截取\"aaa_111_SC\"的末尾后三位字符\"_SC\",我们可以用：  substr(\"aaa_111_SC\",-3,3)=\"\";     得到的结果将是\"aaa_111\".很成功的去掉了末尾的\"_SC\".             这对于不定字符串长度的公共项约除有很大的帮助。","title":"Perl 字符串处理"},{"content":" 队列的一个显著的特征正好的和栈是相反的，它是按照先进先出（FIFO）的方式存储和检索元素，这就是说，对线插入队列的要先删除。还有就是队列是限制在两端进行插入和删除操作的线性表，允许进行存入操作的一端就叫“队尾”，允许进行删除操作的就是“对头”。当线性表中没有元素时，称为“空队“。那么，我们可以吧队列想象地理解成银行办理业务的一队人。   下面介绍顺序队列的定义和实现（以前写的代码） /*sequeue.h*/#define N 8typedef int datatyde;typedef struct {\tdatatyde data[N];\tint front,rear; }sequeue;sequeue *Createsequeue();int Emptysequeue(sequeue *sq);int Fullsequeue(sequeue *sq);void Clearsequeue(sequeue *sq);void Ensequeue(sequeue *sq,datatyde x);datatyde Desequeue(sequeue *sq); /*sequeue.c#include \"sequeue.h\"#include <stdio.h>#include <stdlib.h>sequeue *Createsequeue(){\tsequeue *sq;\tsq=(sequeue *)malloc(sizeof(sequeue));  sq ->\tfront = sq -> rear=0;\treturn sq;}int Emptysequeue(sequeue *sq){\treturn (sq -> front == sq -> rear);}int Fullsequeue(sequeue *sq){\treturn ((sq -> rear+1)%N == sq -> front);}void Clearsequeue(sequeue *sq){   sq -> front = sq -> rear;\treturn;}void Ensequeue(sequeue *sq,datatyde x){\tsq -> rear = (sq -> rear+1) % N;\tsq -> data[sq -> rear]=x;}datatyde Desequeue(sequeue *sq){  sq -> front = (sq -> front + 1) % N; return (sq ->data[sq -> front]);} 下面是链式队的定义和实现  队列的定义的和实现和栈的定义和实现差不多。好多函数接口在单链表定义的时候已经实现，具体可以参照单链表的实现和定义。单链表博客链接：点击打开链接。      /*queue.h*/#ifndef QUEUE_H#define QUEUE_H#include <stdlib.h>#include \"list.h\"/*inplement as linked lists */typedef List Queue;/*Public inerface */#define queue_init list_init #define queue_destroy list_destory int queue_enqueue(Queue *queue,const void *data);int queue_dequeue(Queue *queue,void *data);#define queue_peek(queue)  ((queue) ->head == NULL? NULL:(queue)->head->data)#define queue_size list_size#endif   /*queue.c*/#include <stdlib.h>#include \"../include/list.h\"#include \"../include/queue.h\"/*queue_enqueue */int queue_enqueue(Queue * queue, const void * data){    return list_ins_next(queue, list_tail(queue),  data);}/*queue_dequeue*/int queue_dequeue(Queue * queue, void * data){    return list_rem_next(queue, NULL, data);}    ","title":"数据结构---队列的实现和个人分析"},{"content":"        C#与Java的区别总结如下：     C#和Java都是比较规范的面相对象的编程语言，vb是基于对象的一种程序设计语言，所以C#语言，与Java语言相似，不同点少，C#和Java与Vb之间的差别多点，但是无论哪种语言，基本的数据类型和运算之间不会有冲突。       下面是对这三种语言关系的总结。     一：语法基础      1，运算符      在C#中有sizeof 运算，在Java和Vb中没有（Java中有instanceof >>>，vb中有>>）。      sizeof运算符用来返回某种数据类型（值类型）所占用的字节数，用法如下：     class Program    {        static void Main(string[] args)        {            Console.WriteLine(sizeof(Int32));    //显示int32 类型所占字符数            Console.WriteLine(sizeof(double));   //显示double类型所占字符数        }    }     运行结果：           2，数据类型       C#中有枚举类型，用enum关键字，Java中没有枚举类型，vb中有。 enum Ages{ZhangSan,LiSi,WangWu,aLiu}     3，语句       C#中特有语句foreach。foreach语句的作用是遍历数组。用法如下：     class Program    {        static void Main(string[] args)        {                        int[] arr = new int[]{0,1,2,3}; //定义arr数组，并赋值            int even=0,odd=0;              //定义两个变量，并将初值赋为0            foreach (int i in arr)  //遍历arr数组中每一个数            {                if (i % 2 == 0)    //如果数组arr中的元素为偶数                    even++;        //even 变量加1                else               //如果不为偶数                    odd++;         //odd变量加1            }            Console.WriteLine(even);            Console.WriteLine(odd);        }    }       运行结果：            4，方法     在C#中，一个参数在默认情况下是按值传递的，按引用传递的时候，要有关键字ref，Java中也是按值传递和按引用传递，在Vb中则是按值传递和按地址传递，名称不一样，性质一样。     Vb中的关键字传值为ByVal,传地址为byref。传地址（引用），传递的是值得引用，传递后，指向的还是那个空间；传值，传递的是具体的值，传递后就不再有任何关系啦。     5，C#和Java中个都有包，vb中没有；     C#中方法以大写字母开头，变量以小写字母开头，Java中方法类似变量，以小写字母开头，类名以大写字母开头，vb中变量名称命名，或者是窗体名称命名的时候，都采用大写字母开头（驼峰式）；     C# Java注释语句一样（/*  */），vb用“’”；     C#和Java都要有一个标准库来提供输入输出，C#中用Console.ReadLine ()，Java中用BufferedReader keyin=new BufferedReadReader(new InputStreamReader(System.in);   System.out.printIn();       6，循环     C#中switch语句后必须用break；java和Vb中可以不用，在Java和vb中都允许为case语句使用“自然下移”语义，即如果当前case 的结果不对应，自动跳转到下一个case。     二：类   1， C#和Java中都有class关键字标志的类，为应用类型，且每个类都有访问修饰符（public）。vb中也有类，创建的时候是在模块中，利用类生成器，而在C#和Java中直接定义在一个空间中即可。     2，构造函数   C#中有构造函数和析构函数，构造函数名称和类名一致，且没有返回值，用来初始化一些值，析构函数用来终止操作，Java中也有构造函数，不同的是在Java中不用定义析构函数，因为Java中存在自动垃圾回收机制。     3，继承   C#和Java中都有继承，C#中是单一继承，多个继承用接口实现，Java中存在多继承，父类名称间用“,”隔开；   C#中继承用“：” 如Dog类继承Animal类 class Dog：Animal ,Java中用extends关键字，如A继承B class A extends B   意义一样，不同的只有关键字。     4，关系    C#和Java中类间的关系有依赖，关联，组合，聚合。    依赖关系在类中就是一种实用，A类依赖B类，就是A中使用B类，B类修改直接影响到A类，关系弱    关联关系在类中就是一种引用，A类关联B类，就是A中引用了B类中的方法，在A类中以属性的形式表示，强依赖    组合聚合都是整体和部分之间的关系，不同的是组合关系为contain-a (不可分割)聚合关系为has-a(可分割)      在vb中我们经常讨论的是模块，窗体，类模块之间的关系。     窗体是可视化的窗体，运行的时候展示，模块呢则是代码展示，类模块主要是为了与面向对象挂钩，在类模块中定义的东西，达到了封装的目的，就类似于第三方控件。     还有在这里也体现了作用域，在模块中定义的变量为局部变量，在类模块中定义的变量是全局变量。      三：异常处理   C#中，一个方法检测到一个错误条件时，引发异常，如除数为0。实例如下：     class Program    {        static void Main(string[] args)        {            int result=0;                                   //定义result变量，并赋初值为0            Console.WriteLine(\"请输入X的值：\");            int x = Convert.ToInt32(Console.ReadLine());   //用x 获取键盘输入的值            Console.WriteLine(\"请输入Y的值：\");                        int y = Convert.ToInt32(Console.ReadLine());   //用y 获取键盘输入的值            try            {                result = 24 / (x-1) / (y - 1);             }            catch (Exception e)                           //捕获异常            {                Console.WriteLine(e.Message);             //输出原因            }            Console.WriteLine(\"结果为{0}\", result);       //输出result结果        }    }   运行结果：         Java中也有异常处理语句，跟C#语言一样，但vb中如果有异常了，需要我们手动添加异常处理语句。形如：on error goto xx    xx:      四：语言和运行过程   1，解释型语言     把做好的源程序翻译一句,然后执行一句,直到结束…….执行速度慢,效率低,依赖解释器,跨平台好.     2，编译型语言   把做好的源程序全部编译成二进制代码的可运行程序…...执行速度快,效率高,依赖编译器,跨平台差   编译型语言写的程序执行之前,需要一个专门的编译过程,把程序编译成为机器语言的文件,以后要运行的话就不用重复翻译啦,直接使用编译的结果就行啦。     C# Java是解释型语言是编译型语言，Java，C#等的源码先编译成字节码，再由虚拟机“解释”执行字节码。其中Java运行过程为源程序.java --编译器.class--操作系统平台       Vb（C C++） 则是编译型语言，它产生的最终代码是可执行的，vb6.0版本之前的则是伪编译型语言，最终最终编码不能执行，需要动态链接库去解释执行，vb6.0和vb6.0之后的版本则是直接产生可执行的代码。     附：程序的执行过程      1，load到内存区      2，找到main方法开始执行      3，执行过程中内存管理            code segment(代码段) 存放代码的方法和函数            data segment(数据段)静态变量字符串常量            stack(栈)   局部变量            heap(堆)    new出来的东西","title":"C#与Vb Java的区别"},{"content":"看着MFC向导生成的程序,总归是一头的雾水,看不清,搞不懂. 还是老老实实的学下C语言吧. 但是只学C语言的的内容是很单调的,于是要结合window的基础编程一起学习. 这样才能学以致用.   以前看书都是坚持不到最后,最多看到一半就没有耐心了.学到的知识也不能完整的消息吸收. 现在回过头来,还是认清自己的真实基础,那是真心只能一点皮毛,还是要脚踏实地的好好学习.   学习window的基础,还是先学一个CreateWindow函数吧.这个函数是基础中的基础.   现在重新用C语言进行学习.整理一下,记录在这里.总是一个学习日记吧.   1.关于消息映射 用C语言进行编程时,要对很多的window消息进行处理.这是必须的. 没有办法. 书上的写法都是使用 switch case来进行判断处理.这个很麻烦.总觉得这样写出来的东西,不方便,也不顺手. 虽然有一个windowx.h中的HANDLE_MSG宏,可以方便一点使用.这也有一个麻烦的事情要处理. 就是要记住函数的定义格式.对于学习来说,这样又点不顺心了. 我的想法是,在学习的时候,不需要什么代码的优秀和高质量. 关键在于,学习的时候,对照书本的知识点,可以迅速的进行代码验证,并行到运行结果. 所以.写代码的时候,要有针对性,只要快点,方便点就发了.   以前学C语言的时候,不会用.这次看书后,照着MFC中的消息处理样子,自己弄了一个宏来处理. 代码如下: BEGIN_MESSAGE_MAP(WIN)    ON_MESSAGE(WIN,WM_CREATE,OnCreate)    ON_MESSAGE(WIN,WM_CLOSE,OnClose)    ON_MESSAGE(WIN,WM_LBUTTONDOWN,OnLButtonDown)    ON_MESSAGE(WIN,WM_PAINT,OnPaint)END_MESSAGE_MAP() 用于处理一些常用的消息函数,对应的 OnPaint,OnClose,OnCreate函数,则统一定义成以下格式 LRESULT Fnnction(HWND hwnd) 这样就不用去记忆那些wpapa和lparam的意义了. 直接把这两个值保存到window的prop属性中,如果函数需要使用的话,可以重新读取,这个一头一尾宏定义,可以方便我自己写代码的更方便一点. #define     DECLARE_MESSAGE_MAP(T) LRESULT CALLBACK T##_WndProc(HWND hwnd,UINT msg,WPARAM wp,LPARAM lp);#define     BEGIN_MESSAGE_MAP(T)  LRESULT CALLBACK T##_WndProc(HWND hwnd,UINT msg,WPARAM wp,LPARAM lp){ \\    SetProp(hwnd,L\"WP\",(HANDLE)wp);SetProp(hwnd,L\"LP\",(HANDLE)lp); \\    if(!msg)  \\return 0 ;   再定义一个ON_MESSAGE宏,可以处理各个消息了. #define ON_MESSAGE(ID,message,fn)  else if(msg==message) return ID##_##fn(hwnd); 为了取出保存后的wparam和lparam参数,于是,又要写2个宏. #define Getlparam(H)   (LPARAM)GetProp(##H,L\"LP\")#define Getwparam(H)   (WPARAM)GetProp(##H,L\"WP\") 2.SetwindowText函数的处理  C语言中处理字符串不太方便,SetWindowText只能设置字符串,了为方便点设置窗口文件,重新写一个函数,类似于Printf,什么格式,自己定义就好了,不用转换了. int SetWindowString(HWND hwnd,LPCWSTR pszFormat,...){    va_list args;    va_start(args, pszFormat);  \tLPWSTR pstrText=FormatString(pszFormat,args);      va_end(args);      ::SetWindowText(hwnd,pstrText);    delete  pstrText;     return 0;} 有这2个东东,学C语言省了一点力气. 源代码链接地址        ","title":"C语言初学者:使用CreateWindow创建一个窗口"},{"content":"Rookie零基础学java博客目录（不断更新） 1.Java数据类型基本概念： 数据类型在计算机语言里面，是对内存位置的一个抽象表达方式，可以理解为针对内存的一种抽象的表达方式。接触每种语言的时候，都会存在数据类型的认识，有复杂的、简单的，各种数据类型都需要在学习初期去了解，Java是强类型语言，所以Java对于数据类型的规范会相对严格。数据类型是语言的抽象原子概念，可以说是语言中最基本的单元定义，在Java里面，本质上讲将数据类型分为两种：简单类型和复杂类型。 简单类型：简单数据类型是不能简化的、内置的数据类型、由编程语言本身定义，它表示了真实的数字、字符和整数。 复杂类型：Java语言本身不支持C++中的结构（struct）或联合（union）数据类型，它的复合数据类型一般都是通过类或接口进行构造，类提供了捆绑数据和方法的方式，同时可以针对程序外部进行信息隐藏。 2.Java中的基本类型： 1)概念： Java中的简单类型从概念上分为四种：实数、整数、字符、布尔值。但是有一点需要说明的是，Java里面只有八种原始类型，其列表如下： 实数：double、float 整数：byte、short、int、long 字符：char 布尔值：boolean 复杂类型和基本类型的内存模型本质上是不一样的，简单数据类型的存储原理是这样的：所有的简单数据类型不存在“引用”的概念，简单数据类型都是直接存储在内存中的内存栈上的，数据本身的值就是存储在栈空间里面，而Java语言里面只有这八种数据类型是这种存储模型；而其他的只要是继承于Object类的复杂数据类型都是按照Java里面存储对象的内存模型来进行数据存储的，使用Java内存堆和内存栈来进行这种类型的数据存储，简单地讲，“引用”是存储在有序的内存栈上的，而对象本身的值存储在内存堆上的。 2)详细介绍： Java的简单数据讲解列表如下： int：int为整数类型，在存储的时候，用4个字节存储，范围为-2,147,483,648到2,147,483,647，在变量初始化的时候，int类型的默认值为0。 short：short也属于整数类型，在存储的时候，用2个字节存储，范围为-32,768到32,767，在变量初始化的时候，short类型的默认值为0，一般情况下，因为Java本身转型的原因，可以直接写为0。 long：long也属于整数类型，在存储的时候，用8个字节存储，范围为-9,223,372,036,854,775,808到9,223,372,036, 854,775,807，在变量初始化的时候，long类型的默认值为0L或0l，也可直接写为0。 byte：byte同样属于整数类型，在存储的时候，用1个字节来存储，范围为-128到127，在变量初始化的时候，byte类型的默认值也为0。 float：float属于实数类型，在存储的时候，用4个字节来存储，范围为32位IEEEE 754单精度范围，在变量初始化的时候，float的默认值为0.0f或0.0F，在初始化的时候可以写0.0。 double：double同样属于实数类型，在存储的时候，用8个字节来存储，范围为64位IEEE 754双精度范围，在变量初始化的时候，double的默认值为0.0。 char：char属于字符类型，在存储的时候用2个字节来存储，因为Java本身的字符集不是用ASCII码来进行存储，是使用的16位Unicode字符集，它的字符范围即是Unicode的字符范围，在变量初始化的时候，char类型的默认值为'u0000'。 boolean：boolean属于布尔类型，在存储的时候不使用字节，仅仅使用1位来存储，范围仅仅为0和1，其字面量为true和false，而boolean变量在初始化的时候变量的默认值为false。 　　3)相关介绍： 　　【1】当整数类型的数据使用字面量赋值的时候，默认值为int类型，就是直接使用0或者其他数字的时候，值的类型为int类型，所以当使用long a = 0这种赋值方式的时候，JVM内部存在数据转换。 　　【2】当实数类型的数据使用字面量赋值的时候，默认值为double类型，就是当字面两出现的时候，JVM会使用double类型的数据类型。 　　（*：以上两点在转型中进行详细说明。） a基本类型在使用字面量赋值的时候，有几个简单的特性如下： 　　 　　【3】从JDK 5.0开始，Java里面出现了自动拆箱解箱的操作，基于这点需要做一定的说明： 　　对应原始的数据类型，每种数据类型都存在一个复杂类型的封装类，分别为Boolean、Short、Float、Double、Byte、Int、Long、Character，这些类型都是内置的封装类，这些封装类（Wrapper）提供了很直观的方法，针对封装类需要说明的是，每种封装类都有一个xxxValue()的方法，通过这种方法可以把它引用的对象里面的值转化成为原始变量的值，不仅仅如此，每个封装类都还存在一个valueOf(String)的方法直接把字符串对象转换为相应的简单类型。 　　在JDK 5.0之前，没有存在自动拆解箱的操作，即Auto Box操作，所以在这之前是不能使用以下方式的赋值代码的： Integer a = 0; //这种赋值方式不能够在JDK 1.4以及以下的JDK编译器中通过 但是JDK 5.0出现了自动拆解箱的操作，所以在JDK 5.0以上的编译器中，以上的代码是可以通过的，关于自动拆箱解箱我会另外用一篇1.4到5.0的升级加以详细说明。 3.Java中简基本数据类型的转型： 　　Java中的简单数据类型的转换分为两种：自动转换和强制转换 　　1)自动转换： 　　当一个较“小”的数据和较“大”的数据一起运算的时候，系统将自动将较“小”的数据转换为较“大”的数据，再进行运算。 　　在方法调用过程，如果实际参数较“小”，而函数的形参比较“大”的时候，除非有匹配的方法，否则会直接使用较“大”的形参函数进行调用。 　　2)强制转换： 　　将“大”数据转换为“小”数据时，可以使用强制类型转换，在强制类型转换的时候必须使用下边这种语句： int a = (int)3.14; 　　只是在上边这种类型转换的时候，有可能会出现精度损失。 　　关于类型的自动提升，遵循下边的规则： 　　所有的byte、short、char类型的值将提升为int类型； 　　如果有一个操作数是long类型，计算结果是long类型； 　　如果有一个操作数是float类型，计算结果是float类型； 　　如果有一个操作数是double类型，计算结果是double类型； 　　自动类型转换图如下： 　　byte->short(char)->int->long->float->double 　　如果是强制转换的时候，就将上边的图反过来 　　3)转换附加： 　　当两个类型进行自动转换的时候，需要满足条件：【1】这两种类型是兼容的，【2】目的类型的数值范围应该比源转换值的范围要大。而拓展范围就遵循上边的自动类型转换树，当这两个条件都满足的时候，拓展转换才会发生，而对于几个原始类型转换过程，根据兼容性boolean和char应该是独立的，而其他六种类型是可以兼容的，在强制转换过程，唯独可能特殊的是char和int是可以转换的，不过会使用char的ASCII码值比如： int a = (int)'a'; 　　a的值在转换过后输出的话，值为97； 4.Java中的高精度数： 　　Java提供了两个专门的类进行高精度运算：BigInteger与BigDecimal，虽然Java原始变量都具有对应的封装类型，但是这两个变量没有对应的原始类型，而是通过方法来提供这两种类型的一些运算，其含义为普通类型能够做的操作，这两个类型对应都有，只是因为精度过大可能效率不够高。至于这两个类的具体操作可以参考JDK的相关API文档。 5.关于数据类型的一些技巧：（以下为参考一篇原文文档） 　　若要求精度的结果，尽量避免使用float和double： 　　float和double类型本身是为了做科学运算，即执行二进制浮点运算而设计，但是却不能提供完全精确的结果，所以在要求精度的数值中，避免使用float和double，float和double在货币运算中尤其不合适，要让float和double精确表达0.1也是不可能的事。测试一下下边这段代码就明白了： 　　System.out.println(2.02-0.42); 　　结果是不是出乎意料，这个结果并不是偶然，而是JVM本身设计的目的决定的。而要解决这个问题，最好的办法是使用BigDecimal、int或者long进行相关运算，特别是货币运算，使用BigDecimal代替double是一个很好的办法。 　　BigDecimal唯一的缺点在于：BigDecimal没有相对应的原始类型，所以在进行基本数值运算的时候，需要进行方法调用才能操作，这样会使得和我们的编程习惯不相符合，若使用int和long，就需要进行简单的封装运算。 　　所以在要求精度答案的计算任务里面，一般慎用float和double，如果在进行商务运算，并且要求四舍五入或者简单的舍入行为，使用BigDecimal可能更加方便。所以尽量避免在精度运算中使用float和double，特别是我们常用的货币运算。 5.程序验证： 　　 public class PrimitiveTypeTest {public static void main(String[] args) {// byteSystem.out.println(\"基本类型：byte 二进制位数：\" + Byte.SIZE);System.out.println(\"包装类：java.lang.Byte\");System.out.println(\"最小值：Byte.MIN_VALUE=\" + Byte.MIN_VALUE);System.out.println(\"最大值：Byte.MAX_VALUE=\" + Byte.MAX_VALUE);System.out.println();// shortSystem.out.println(\"基本类型：short 二进制位数：\" + Short.SIZE);System.out.println(\"包装类：java.lang.Short\");System.out.println(\"最小值：Short.MIN_VALUE=\" + Short.MIN_VALUE);System.out.println(\"最大值：Short.MAX_VALUE=\" + Short.MAX_VALUE);System.out.println();// intSystem.out.println(\"基本类型：int 二进制位数：\" + Integer.SIZE);System.out.println(\"包装类：java.lang.Integer\");System.out.println(\"最小值：Integer.MIN_VALUE=\" + Integer.MIN_VALUE);System.out.println(\"最大值：Integer.MAX_VALUE=\" + Integer.MAX_VALUE);System.out.println();// longSystem.out.println(\"基本类型：long 二进制位数：\" + Long.SIZE);System.out.println(\"包装类：java.lang.Long\");System.out.println(\"最小值：Long.MIN_VALUE=\" + Long.MIN_VALUE);System.out.println(\"最大值：Long.MAX_VALUE=\" + Long.MAX_VALUE);System.out.println();// floatSystem.out.println(\"基本类型：float 二进制位数：\" + Float.SIZE);System.out.println(\"包装类：java.lang.Float\");System.out.println(\"最小值：Float.MIN_VALUE=\" + Float.MIN_VALUE);System.out.println(\"最大值：Float.MAX_VALUE=\" + Float.MAX_VALUE);System.out.println();// doubleSystem.out.println(\"基本类型：double 二进制位数：\" + Double.SIZE);System.out.println(\"包装类：java.lang.Double\");System.out.println(\"最小值：Double.MIN_VALUE=\" + Double.MIN_VALUE);System.out.println(\"最大值：Double.MAX_VALUE=\" + Double.MAX_VALUE);System.out.println();// charSystem.out.println(\"基本类型：char 二进制位数：\" + Character.SIZE);System.out.println(\"包装类：java.lang.Character\");// 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台System.out.println(\"最小值：Character.MIN_VALUE=\"+ (int) Character.MIN_VALUE);// 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台System.out.println(\"最大值：Character.MAX_VALUE=\"+ (int) Character.MAX_VALUE);}}   运行结果： 1、基本类型：byte 二进制位数：8 2、包装类：java.lang.Byte 3、最小值：Byte.MIN_VALUE=-128 4、最大值：Byte.MAX_VALUE=127 5、 6、基本类型：short 二进制位数：16 7、包装类：java.lang.Short 8、最小值：Short.MIN_VALUE=-32768 9、最大值：Short.MAX_VALUE=32767 10、 11、基本类型：int 二进制位数：32 12、包装类：java.lang.Integer 13、最小值：Integer.MIN_VALUE=-2147483648 14、最大值：Integer.MAX_VALUE=2147483647 15、 16、基本类型：long 二进制位数：64 17、包装类：java.lang.Long 18、最小值：Long.MIN_VALUE=-9223372036854775808 19、最大值：Long.MAX_VALUE=9223372036854775807 20、 21、基本类型：float 二进制位数：32 22、包装类：java.lang.Float 23、最小值：Float.MIN_VALUE=1.4E-45 24、最大值：Float.MAX_VALUE=3.4028235E38 25、 26、基本类型：double 二进制位数：64 27、包装类：java.lang.Double 28、最小值：Double.MIN_VALUE=4.9E-324 29、最大值：Double.MAX_VALUE=1.7976931348623157E308 30、 31、基本类型：char 二进制位数：16 32、包装类：java.lang.Character 33、最小值：Character.MIN_VALUE=0 34、最大值：Character.MAX_VALUE=65535 Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的“E+数字”表示E之前的数字要乘以10的多少倍。比如3.14E3就是3.14×1000=3140，3.14E-3就是3.14/1000=0.00314。 大家将运行结果与上表信息仔细比较就会发现float、double两种类型的最小值与Float.MIN_VALUE、 Double.MIN_VALUE的值并不相同，这是为什么呢？实际上Float.MIN_VALUE和Double.MIN_VALUE分别指的是 float和double类型所能表示的最小正数。也就是说存在这样一种情况，0到±Float.MIN_VALUE之间的值float类型无法表示，0 到±Double.MIN_VALUE之间的值double类型无法表示。这并没有什么好奇怪的，因为这些范围内的数值超出了它们的精度范围。 基本类型存储在栈中，因此它们的存取速度要快于存储在堆中的对应包装类的实例对象。从Java5.0（1.5）开始，JAVA虚拟机（Java Virtual Machine）可以完成基本类型和它们对应包装类之间的自动转换。因此我们在赋值、参数传递以及数学运算的时候像使用基本类型一样使用它们的包装类，但这并不意味着你可以通过基本类型调用它们的包装类才具有的方法。另外，所有基本类型（包括void）的包装类都使用了final修饰，因此我们无法继承它们扩展新的类，也无法重写它们的任何方法。 各种数值类型之间的赋值与转换遵循什么规律呢？我们来看下面这个例子： 复制内容到剪贴板 代码: public class PrimitiveTypeTest { public static void main(String[] args) { // 给byte类型变量赋值时，数字后无需后缀标识 byte byte_a = 1; // 编译器会做范围检查，如果赋予的值超出了范围就会报错 // byte byte_b = 1000; // 把一个long型值赋值给byte型变量，编译时会报错，即使这个值没有超出byte类型的取值范围 // byte byte_c = 1L; // 给short类型变量赋值时，数字后无需后缀标识 short short_a = 1; // 编译器会做范围检查，如果赋予的值超出了范围就会报错 // short short_b = 70000; // 把一个long型值赋值给short型变量，编译时会报错，即使这个值没有超出short类型的取值范围 // byte short_c = 1L; // 给short类型变量赋值时，数字后无需后缀标识 int int_a = 1; // 编译器会做范围检查，如果赋予的值超出了范围就会报错 // int int_b = 2200000000; // 把一个long型值赋值给int型变量，编译时会报错，即使这个值没有超出int类型的取值范围 // int int_c = 1L; // 可以把一个int型值直接赋值给long型变量，数字后无需后缀标识 long long_a = 1; // 如果给long型变量赋予的值超出了int型值的范围，数字后必须加L（不区分大小写）标识 long long_b = 2200000000; // 编译器会做范围检查，如果赋予的值超出了范围就会报错 // long long_c = 9300000000000000000L; // 可以把一个int型值直接赋值给float型变量 float float_a = 1; // 可以把一个long型值直接赋值给float型变量 float float_b = 1; // 没有F（不区分大小写）后缀标识的浮点数默认为double型的，不能将它直接赋值给float型变量 // float float_c = 1.0; // float型数值需要有一个F（不区分大小写）后缀标识 float float_d = 1.0F; // 把一个double型值赋值给float型变量，编译时会报错，即使这个值没有超出float类型的取值范围 // float float_e = 1.0D; // 编译器会做范围检查，如果赋予的值超出了范围就会报错 // float float_f = 3.5000000E38F; // 可以把一个int型值直接赋值给double型变量 double double_a = 1; // 可以把一个long型值直接赋值给double型变量 double double_b = 1; // 可以把一个float型值直接赋值给double型变量 double double_c = 1F; // 不带后缀标识的浮点数默认为double类型的，可以直接赋值 double double_d = 1.0; // 也可以给数字增加一个D（不区分大小写）后缀标识，明确标出它是double类型的 double double_e = 1.0D; // 编译器会做范围检查，如果赋予的值超出了范围就会报错 // double double_f = 1.8000000000000000E308D; // 把一个double型值赋值给一个byte类型变量，编译时会报错，即使这个值没有超出byte类型的取值范围 // byte byte_d = 1.0D; // 把一个double型值赋值给一个short类型变量，编译时会报错，即使这个值没有超出short类型的取值范围 // short short_d = 1.0D; // 把一个double型值赋值给一个int类型变量，编译时会报错，即使这个值没有超出int类型的取值范围 // int int_d = 1.0D; // 把一个double型值赋值给一个long类型变量，编译时会报错，即使这个值没有超出long类型的取值范围 // long long_d = 1.0D; // 可以用字符初始化一个char型变量 char char_a = 'a'; // 也可以用一个int型数值初始化char型变量 char char_b = 1; // 把一个long型值赋值给一个char类型变量，编译时会报错，即使这个值没有超出char类型的取值范围 // char char_c = 1L; // 把一个float型值赋值给一个char类型变量，编译时会报错，即使这个值没有超出char类型的取值范围 // char char_d = 1.0F; // 把一个double型值赋值给一个char类型变量，编译时会报错，即使这个值没有超出char类型的取值范围 // char char_e = 1.0D; // 编译器会做范围检查，如果赋予的值超出了范围就会报错 // char char_f = 70000; } } 从上面的例子中我们可以得出如下几条结论： 1、未带有字符后缀标识的整数默认为int类型；未带有字符后缀标识的浮点数默认为double类型。 2、如果一个整数的值超出了int类型能够表示的范围，则必须增加后缀“L”（不区分大小写，建议用大写，因为小写的L与阿拉伯数字1很容易混淆），表示为long型。 3、带有“F”（不区分大小写）后缀的整数和浮点数都是float类型的；带有“D”（不区分大小写）后缀的整数和浮点数都是double类型的。 4、编译器会在编译期对byte、short、int、long、float、double、char型变量的值进行检查，如果超出了它们的取值范围就会报错。 5、int型值可以赋给所有数值类型的变量；long型值可以赋给long、float、double类型的变量；float型值可以赋给float、double类型的变量；double型值只能赋给double类型变量","title":"Rookie零基础学java（四）java的基本数据类型及注意事项"},{"content":"这里直接上工程文件源码： ValidateImage.java: package jpeg;import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.image.BufferedImage;import java.io.IOException;import java.io.OutputStream;import java.util.Random;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.sun.image.codec.jpeg.JPEGCodec;import com.sun.image.codec.jpeg.JPEGEncodeParam;import com.sun.image.codec.jpeg.JPEGImageEncoder;public class ValidateImage extends HttpServlet {\t\tprotected void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{\t    response.setContentType(\"image/jpeg\");\t    createImage(response.getOutputStream());\t    response.setHeader(\"Pragma\",\"No-cache\");\t    response.setHeader(\"Cache-Control\",\"no-cache\");\t    response.setDateHeader(\"Expires\", 0);\t}\t\tprivate void createImage(OutputStream out)throws IOException\t{\t\tint width=60, height=20;\t\tBufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\t\tGraphics g = image.getGraphics();\t\tRandom random = new Random();\t\tg.setColor(getRandColor(200,250));\t\tg.fillRect(0, 0, width, height);\t\tg.setFont(new Font(\"Times New Roman\",1,15));\t\t//g.setColor(new Color());\t\t//g.drawRect(0,0,width-1,height-1);\t\tg.setColor(getRandColor(160,200));\t\tfor (int i=0;i<155;i++){\t\t\tint x = random.nextInt(width);\t\t\tint y = random.nextInt(height);\t\t        int xl = random.nextInt(12);\t\t        int yl = random.nextInt(12);\t\t\tg.drawLine(x,y,x+xl,y+yl);\t\t}\t\t//String rand = request.getParameter(\"rand\");\t\t//rand = rand.substring(0,rand.indexOf(\".\"));\t\tString sRand=\"\";\t\tfor (int i=0;i<4;i++){\t\t    String rand=String.valueOf(random.nextInt(10));\t\t    sRand+=rand;\t\t    g.setColor(new Color(20+random.nextInt(110),20+random.nextInt(110),20+random.nextInt(110)));\t\t    g.drawString(rand,13*i+6,16);\t\t}              //session.setAttribute(\"rand\",sRand);\t\tg.dispose();\t\tJPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out);\t\tJPEGEncodeParam param \t= encoder.getDefaultJPEGEncodeParam(image);\t\tparam.setQuality(1.0f, false);\t\tencoder.setJPEGEncodeParam(param);\t\ttry{\t\t\tencoder.encode(image);\t\t}catch (IOException ioe){\t\t\tioe.printStackTrace();\t\t}\t}\t\tColor getRandColor(int fc,int bc){        Random random = new Random();        if(fc>255) fc=255;        if(bc>255) bc=255;        int r=fc+random.nextInt(bc-fc);        int g=fc+random.nextInt(bc-fc);        int b=fc+random.nextInt(bc-fc);        return new Color(r,g,b);        }\t\t} TestImage.jsp:   <body>    <img src=\"validate\"> <br>  <\/body> web.xml: <?xml version=\"1.0\" encoding=\"UTF-8\"?><web-app version=\"2.5\" \txmlns=\"http://java.sun.com/xml/ns/javaee\" \txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \txsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee \thttp://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\">  <servlet>    <description>This is the description of my J2EE component<\/description>    <display-name>This is the display name of my J2EE component<\/display-name>    <servlet-name>ValidateImage<\/servlet-name>    <servlet-class>jpeg.ValidateImage<\/servlet-class>  <\/servlet>  <servlet-mapping>    <servlet-name>ValidateImage<\/servlet-name>    <url-pattern>/validate<\/url-pattern>  <\/servlet-mapping>  <welcome-file-list>    <welcome-file>index.jsp<\/welcome-file>  <\/welcome-file-list><\/web-app>   地址栏：http://localhost:8080/JPEG/jsp/TestImage.jsp 结果：  ","title":"web实现图形验证功能"},{"content":"两路归并排序所需时间主要包括划分子序列的时间。以及两个子序列分别排序的时间和归并的时间。划分子序列的时间是一个常数，可以不考虑，最后的归并时间与元素的个数 n　线性相关，　因此，对于一个长度为ｎ的元素序列进行归并排序的时间代价为：Ｔ（ｎ）＝ｃｎ＋２Ｔ（ｎ／２）。 当元素的个数为１　时，函数直接返回，因此Ｔ（１）＝１.与快速排序的时间复杂度相识，两路归并排序的时间复杂度也为Ｏ（ｎｌｏｇｎ）。由于归并排序不依赖与待排序元素序列的初始输入排列，每次划分时，两个子序列的长度基本是一样的，所以归并排序的最好和最坏的时间复杂度都是Ｏ（ｎｌｏｇｎ）。 归并排序的主要问题在于他需要一个与原待排序数组一样大小的辅助数组空间。归并排序时一种稳定的排序算法。 Ｒ。ＳｅｄｇｅＷｉｃｋ提出了一种改进的两路归并算法。在把元素序列复制到辅助数组的过程中，把第二个有序表的元素逆序，这样两个待归并的表从两端开始处理，向中间开始处理，向中间归并。两个表的尾端互成“监视哨”，在归并的过程中可以省略检测子序列是否结束的判断，提高程序的执行效率。 归并排序 知识点小结：点击打开链接 改进后的归并排序算法代码示例如下： #define  M 16#include<iostream>#include <time.h>#include<iomanip>using namespace std;void insertSort(int *a,int left,int right){\tint tmp;\tint i,j;\tfor(i = left+1 ; i<=right;i++){//外层循环是从第二个元素开始的\t\tif(a[i]<a[i-1]){\t\t\ttmp = a[i];\t\t\tj = i-1;\t\t\tdo{\t\t\t\ta[j+1]= a[j--];\t\t\t}while( j>= left && tmp < a[j]);\t\t\ta[j+1] = tmp;\t\t}\t}}void improvedMerge(int *a,int left,int mid,int right){\tint s1=left;//s1,s2 是检测指针，t是存放指针\tint s2=right;\tint t=left,k;\tint *b=new int[right];\tfor(k= left ; k<=mid; k++)//正向复制\t\tb[k]=a[k];\tfor(k=mid+1;k<=right;k++)//反向复制\t\tb[right+mid+1-k] = a[k];\twhile( t <= right){//归并过程\t\tif(b[s1] <= b[s2]) a[t++]=b[s1++];\t\telse\ta[t++]=b[s2--];\t}}void doSort(int *a,int left,int right){\tif( left >=right ) return ;\tif(right - left +1 < M)return;//序列长度小于M时候，跳出循环\tint mid = (left + right )/2;//从中间划分两个子序列\tdoSort(a,left,mid);//从左侧子序列进行递归排序\tdoSort(a,mid+1 ,right);//从右侧子序列进行递归排序\timprovedMerge(a,left,mid,right);//合并}void mergeSort(int *a,int left,int right){\tdoSort(a,left,right);//对序列进行归并排序\tinsertSort(a,left,right);//对排序结果在做插入排序}void main(){\tint a[100];\tsrand((unsigned int)time(NULL));\tfor(int i=0;i<100;i++)\t\ta[i]=rand();\tmergeSort(a,0,99);\tfor(int i=0;i<100;i++){\t\tif(i%7 == 0 && i!=0)\t\t\tcout<<endl;\t\tcout<<setw(10)<<a[i]<<\" \";\t}\tcout<<endl;} 实验证明，改进后的算法的确会比原先算法快一些，但这种改进在数量级上没有根本的提升，运行的时间复杂度仍然为Ｏ（ｎｌｏｇｎ），空间代价仍然为Ｏ（ｎ）．","title":"[置顶] 改进的两路归并排序算法"},{"content":"CDetailView为某个Model显示详细内容。这个要显示的Model可以为CModel或是关联数组。 CDetailView通过配置 attributes来决定Model的那些属性需要显示已经以何种格式显示。 每个属性可以使用Name:Type:Label来配置。其中Type和Label都是可选的。 “Name” 属性名称. “Label” 可以选，属性的标签名，如果没有配置，则使用属性名称做为标签名称. “Type” 属性的类型，通过类型来决定显示的格式 formatter.可以使用的类型有 raw, text, ntext, html, date, time, datetime, boolean, number, email, image, url. 等，缺省使用text. 本例修改上例Yii Framework 开发教程(30) Zii组件-ListView 示例 ，修改显示列表的列表项模版_view.php ，使客户名称由普通文字变为Link。 <h3><?php echo CHtml::link($data->FirstName . ' ' . $data->LastName,$this->createUrl('view',array('CustomerId'=>$data->CustomerId)));?><\/h3> 当点击客户姓名时，转到链接view.php, 传入参数CustomerId设为Customer 的ID。 创建View.php，使用CDetailView组件 <h2><?php echo 'View Customer'; ?><\/h2><?php $this->widget('zii.widgets.CDetailView', array(\t'data'=>$model,\t'attributes'=>array(\t\t\t\t'FirstName',\t\t\t\t'LastName',\t\t\t\t'Company',\t\t\t\t'Address',\t\t\t\t'City',\t\t\t\t'State',\t\t\t\t'Country',\t\t\t\t'PostalCode',\t\t\t\t'Phone',\t\t\t\t'Fax',\t\t\t\t'Email',\t\t\t\tarray(\t\t\t\t\t'name'=>'Employee',\t\t\t\t\t'value'=>$model->employee->FirstName,\t\t\t\t\t),\t\t\t\t),\t\t\t));?> 使用缺省的格式显示Customer的每个字段，主要的Employee字段，表Customer定义的是SupportRepId做为外键参考Employee，因此修改类Customer定义Relations，参考Yii Framework 开发教程(27) 数据库-关联Active Record示例 public function relations(){\treturn array(\t\t'employee'=>array(self::BELONGS_TO,\t\t'Employee', 'SupportRepId'),\t\t);} 显示结果如下： 本例下载","title":"Yii Framework 开发教程(31) Zii组件-DetailView 示例"},{"content":"CListView可以用来显示列表，CListView支持使用自定义的View模板显示列表的的记录，因此可以非常灵活的显示数据的表，这点有点像Android的ListView：-）。 CListView 支持分页和排序，分页和排序支持使用AJAX实现从而可以提高页面的响应性能。CListView的使用需要通过DataProvider，通常是使用CActiveDataProvider。 本例修改Yii Framework 开发教程(26) 数据库-Active Record示例，不过为了显示分页，我们使用Customer数据库表，每页显示10条记录。 修改缺省的视图protected/views/site/index.php,使用ListView组件。 <?php $this->widget('zii.widgets.CListView', array(\t'dataProvider'=>$dataProvider,\t'ajaxUpdate'=>false,\t'template'=>'{sorter}{pager}{summary}{items}{pager}',\t'itemView'=>'_view',\t'pager'=>array(\t\t\t\t'maxButtonCount'=>'7',\t\t\t\t),\t\t\t'sortableAttributes'=>array(\t\t\t\t'FirstName',\t\t\t\t'LastName',\t\t\t\t'Country',\t\t\t\t),)); ?> 参数template 配置页面显示的模板，支持的参数有 {summary}, {sorter}, {items} 和{pager}，分别对应于ListView的汇总，排序，列表项，分页控制。 参数itemView 指明每个列表项对应的View显示。本例使用site/_view.php ，定义如下： <div class=\"item\"><h3><?php echo CHtml::encode($data->FirstName . ' ' . $data->LastName);?><\/h3><b><?php echo CHtml::encode($data->getAttributeLabel('Company')); ?>:<\/b><?php echo CHtml::encode($data->Company); ?><br /><b><?php echo CHtml::encode($data->getAttributeLabel('Address')); ?>:<\/b><?php echo Yii::app()->format->formatUrl($data->Address); ?><br /><b><?php echo CHtml::encode($data->getAttributeLabel('Country')); ?>:<\/b><?php echo CHtml::encode($data->Country); ?><br /><b><?php echo CHtml::encode($data->getAttributeLabel('Email')); ?>:<\/b><?php echo Yii::app()->format->formatEmail($data->Email); ?><br /><\/div> 然后修改SiteController的indexAction方法： public function actionIndex(){\t$dataProvider=new CActiveDataProvider('Customer', array(\t\t'pagination'=>array(\t\t\t'pageSize'=>10,\t\t\t'pageVar'=>'page',\t\t),\t\t\t\t'sort'=>array(\t\t\t\t\t'defaultOrder'=>'Lastname',\t\t\t\t\t),\t\t\t\t));\t$this->render('index',array(\t\t'dataProvider'=>$dataProvider,\t\t));} 显示结果如下： 本例下载","title":"Yii Framework 开发教程(30) Zii组件-ListView 示例"},{"content":"            根据出生日期，计算年龄（距当前时间），调用：Age(20121202);    方法如下：      private void Age(string Date)         {             string RValue = string.Empty;             string NowDate = DateTime.Now.ToString(\"yyyyMMdd\");             DateTime BrithDate = DateTime.Parse(Date.Insert(6, \"-\").Insert(4, \"-\"));             if (DateTime.Now.Year == BrithDate.Year) //年份相等             {                 #region                 if (DateTime.Now.Month == BrithDate.Month)  //月份相等                 {                     RValue = (DateTime.Now.Day - BrithDate.Day).ToString() + \"天\";                 }                 else  //月份不相等                 {                     if (DateTime.Now.Day >= BrithDate.Day)                     {                         RValue = (DateTime.Now.Month - BrithDate.Month).ToString() + \"月\";                     }                     else                     {                         RValue = (DateTime.Now.Month - BrithDate.Month - 1).ToString() + \"月\";                     }                 }                 #endregion             }             else  //年份不相等             {                 #region                 if (DateTime.Now.Month > BrithDate.Month)                 {                     if (DateTime.Now.Day >= BrithDate.Day)                           RValue = (DateTime.Now.Year - BrithDate.Year).ToString() + \"年\"+(DateTime.Now.Month-BrithDate.Month).ToString()+\"月\";                     else                         RValue = (DateTime.Now.Year - BrithDate.Year).ToString() + \"年\" + (DateTime.Now.Month - BrithDate.Month-1).ToString() + \"月\";                 }                 else if (DateTime.Now.Month < BrithDate.Month)                 {                     if (DateTime.Now.Year - BrithDate.Year - 1 == 0)                     { //eg:出生日期:20111020,当前日期:20120820                         if (DateTime.Now.Day >= BrithDate.Day)                         {                             RValue = (12 - BrithDate.Month + DateTime.Now.Month ).ToString() + \"月\";                         }                         else                         {                             RValue = (12 - BrithDate.Month + DateTime.Now.Month - 1).ToString() + \"月\";                         }                     }                     else                     {                         RValue = (DateTime.Now.Year - BrithDate.Year - 1).ToString() + \"年\" + (12- BrithDate.Month +DateTime.Now.Month - 1).ToString() + \"月\";                     }                 }                 else  //年份不一样,月份相等                 {                     if (DateTime.Now.Day >= BrithDate.Day)                     {                         RValue = (DateTime.Now.Year - BrithDate.Year).ToString() + \"年\";                     }                     else                     {                         if (DateTime.Now.Year - BrithDate.Year - 1 == 0)                         { //eg:出生日期:20111020,当前日期:20120820                             if (DateTime.Now.Day >= BrithDate.Day)                             {                                 RValue = (DateTime.Now.Year - BrithDate.Year).ToString() + \"年\";                             }                             else                             {                                 RValue = (12 - BrithDate.Month + DateTime.Now.Month - 1).ToString() + \"月\";                             }                         }                         else                         {                             RValue = (DateTime.Now.Year - BrithDate.Year - 1).ToString() + \"年\";                         }                     }                 }                 #endregion             }             MessageBox.Show(RValue.ToString());         }  ","title":"计算年龄"},{"content":"根据中序遍历和前序遍历重建二叉树，同时验证是否合法。 #include <iostream>#include <string>using namespace std;#define TREELEN 6struct Node{\tNode* pLeft;\tNode* pRight;\tchar value;};Node* rebuild(char *preOrder, char *inOrder, int nTreeLen){\tNode *pTemp = new Node;\tpTemp->value = *preOrder;\t\tpTemp->pLeft = NULL;\tpTemp->pRight = NULL;\tcout<<pTemp->value<<endl;\tint letter[26];\tfor(int i=0; i<26; ++i)\t{\t\tletter[i] = 0;\t}\t// 验证前序遍历和中序遍历字符种类个数是否一致\tfor(int i=0; i<nTreeLen; ++i)\t{\t\tchar temp = *(preOrder+i);\t\tif(islower(temp))\t\t{\t\t\tletter[temp-'a']++;\t\t}\t\telse if(isupper(temp))\t\t{\t\t\tletter[temp-'A']++;\t\t}\t\ttemp = *(inOrder+i);\t\tif(islower(temp))\t\t{\t\t\tletter[temp-'a']--;\t\t}\t\telse if(isupper(temp))\t\t{\t\t\tletter[temp-'A']--;\t\t}\t}\tfor(int i=0; i<26; ++i)\t{\t\tif(letter[i] != 0)\t\t{\t\t\tcout<<\"error string!\"<<endl;\t\t\tthrow runtime_error(\"error string!\");\t\t}\t}\tif(nTreeLen == 1)\t{\t\treturn pTemp;\t}\t// 求左右子树长度\tint leftTreeLen = 0;\tint rightTreeLen = 0;\tfor(int i=0; i<nTreeLen; ++i)\t{\t\tif( *preOrder == *(inOrder+i) )\t\t{\t\t\tleftTreeLen = i;\t\t\trightTreeLen = nTreeLen - i - 1;\t\t\tbreak;\t\t}\t}\tif(leftTreeLen > 0)\t{\t\tpTemp->pLeft = rebuild(preOrder+1, inOrder, leftTreeLen);\t}\tif(rightTreeLen > 0)\t{\t\tpTemp->pRight = rebuild(preOrder+leftTreeLen+1, inOrder+leftTreeLen+1, rightTreeLen);\t}\treturn pTemp;}void traversal(Node* root, int flag){\tif(root == NULL)\t\treturn;\tif(flag == 0)\t{\t\tcout<<root->value<<\"\\t\";\t\ttraversal(root->pLeft, flag);\t\ttraversal(root->pRight, flag);\t}\telse if(flag == 1)\t{\t\t\t\ttraversal(root->pLeft, flag);\t\tcout<<root->value<<\"\\t\";\t\ttraversal(root->pRight, flag);\t}}int main(){\tchar preOrder[TREELEN] = {'a','b','d','c','e','f'};\tchar inorder[TREELEN] = {'d','b','a','e','c','f'};\tNode* root = NULL;\troot = rebuild(preOrder, inorder, TREELEN);\tcout<<\"\\n前序遍历：\"<<endl;\ttraversal(root, 0);\tcout<<\"\\n中序遍历：\"<<endl;\ttraversal(root, 1);}","title":"重建二叉树"},{"content":"进程内存分布 　　之前一直在分析栈，栈这个东西的作用也介绍得差不多了，但是栈在哪儿还没有搞清楚，以及堆、代码、全局变量它们在哪儿，这都牵涉到进程的内存分布。 linux 0.01 的进程内存分布 　　内存分布随着操作系统的更新换代，越来越科学合理，也越来越复杂，所以我们还是先了解一下早期操作系统的典型 linux 0.01 的进程的内存分布： 　　linux 0.01 的一个进程固定拥有64MB的线性内存空间（ACM竞赛中单个程序的最大内存占用限制为64MB，这肯定有猫腻O(∩_∩)O~），各个进程挨个放置在一张页目录表中，一个页目录表可管理4G的线性空间，因此 linux0.01 最多有 64个进程。每个进程的内存分布如下： .text 里存的是机器码序列 .rodata 里存的是源字符串等只读内容 .data 里存的是初始化的全局变量 .bss 上一篇介绍过了，存的是未初始化的全局变量 堆、栈就不用介绍了吧！ 　　.text .rodata .data .bss 是常驻内存的，也就是说进程从开始运行到进程僵死它们一直蹲在那里，所以访问它们用的是常量地址；而栈是不断的加帧（函数调用）、减帧（函数返回）的，帧内的局部变量只能用相对于当前 esp（指向栈顶）或 ebp（指向当前帧）的相对地址来访问。 　　栈被放置在高地址也是有原因的： 调用函数（加帧）是减 esp 的，函数返回（减帧）是加 esp 的，调用在前，所以栈是向低地址扩展的，放在高地址再合适不过了。 现代操作系统的进程内存分布 　　认识了 linux 0.01 的内存分布后，再看看现代操作系统的内存分布发生了什么变化： 　　首先，linux 0.01 进程的64MB内存限制太过时了，现在的程序都有潜力使用到 2GB、3GB 的内存空间（每个进程一张页目录表），当然，机器有硬伤的话也没办法，我的电脑就只有 2GB 的内存，想用 3GB 的内存是没指望了。但也不是有4GB内存就可以用4GB（32位），因为操作系统还要占个坑呢！现代 linux 中 0xC0000000 以上的 1GB 空间是操作系统专用的，而 linux 0.01 中第1个 64MB 是操作系统的坑，所以别的进程完全占有它们的 64MB，也不用跟操作系统客气。 　　其次，linux 0.01只有进程没有线程，但是现代 linux 有多线程了（linux 的线程其实是个轻量级的进程），一个进程的多个线程之间共享全局变量、堆、打开的文件…… 但栈是不能共享的：栈中各层函数帧代表着一条执行线索，一个线程是一条执行线索，所以每个线程独占一个栈，而这些栈又都必须在所属进程的内存空间中。 　　根据以上两点，进程的内存分布就变成了下面这个样子： 　　再者，如果把动态装载的动态链接库也考虑进去的话，上面的分布图将会更加\"破碎\"。 　　如果我们的程序没有采用多线程的话，一般可以简单地认为它的内存分布模型是 linux 0.01 的那种。","title":"进程内存分布"},{"content":"来到熊掌，发现这里开发全部是vim，我当时直接被汗到了....很惊讶为什么不用IDE...没办法入乡随俗吧~ 关于tab键不同环境下被解释的长度是不一样的，所以在开发时大家都避免使用tab，而是用空格代替，但是在vim下每次分段都敲好几个空格岂不是很麻烦，于是请教旁边的达人，他告诉我可以将tab在vim中的解释变成四个空格，爽哉！ 方法如下： 两条命令即可： set tabstop=4 set expandtab 也可以将这两条命令放入.vimrc，这个文件在你使用vi打开任何东西是都会被加载，所以以后不用每次都重新输入。 很牛吧~~~~打算有空研究下vim~~~","title":"改变vim中tab键的特性"},{"content":"      这是一道替换字符串中关键字的题。就像word中用一字符串替换另外一个文本中包含的字符串。 下面代码中，找到被替换串位置后用了4步进行替换： 1、被替换串起始位置之前的字符串复制到临时字符串中； 2、将新字符串复制到临时字符串中； 3、将被替换串结束位置后的字符串复制到临时字符串中； 4、将临时字符串复制到原字符串 #include <stdio.h>#include <string.h>// 该函数实现将字符串str1中的str2字符串替换为str3bool replace(char str1[], char str2[], char str3[]) {    bool flag = true;    char *x1 = strstr(str1, str2);    if (x1 == NULL) {        return false;    }    int len1 = strlen(str1);    int len2 = strlen(str2);    int len3 = strlen(str3);    int j = 0, i;    char tmp[1050];    for (i=0; i<(x1-str1); i++)        tmp[j++] = str1[i];    for (i=0; i<len3; i++)        tmp[j++] = str3[i];    for (i=(x1-str1+len2); i<len1; i++)        tmp[j++] = str1[i];    tmp[j] = '\\0';    strcpy(str1, tmp);    return true;}int main() {    char str[1050];    char a[15][1050], b[15][1050];    int n;    while (scanf(\"%d\", &n) && n) {        getchar();        for (int i=0; i<n; i++) {            gets(a[i]);            gets(b[i]);        }        gets(str);        for (int i=0; i<n; i++) {            while (replace(str, a[i], b[i]));        }        printf(\"%s\\n\", str);    }    return 0;}  ","title":"UVA 10115 - Automatic Editing 字符串替换问题"},{"content":"我们用的很多软件系统都是图形界面的,而且都是二维的.那五颜六色,丰富多彩的现实世界呈现给我们的是三维的,立体的图象界面. 实际上我们也可以把我们的现实世界当作一台超级电脑.操作界面就是三维图象.当然了只能是类似,不可能完全跟我们用的电脑概念一样的. 晶体管与基本粒子 首先电脑上的主要零件是晶体管(CPU,内存都用的它),晶体管比较简单,组合来组合去不过一串串的0101吧了,而现实世界的主要零件是那些个最小粒子,一般我们熟悉的是啥原子,质子,电子之类的,实际上它们还可以细分为一些啥东东,反正就简称为基本粒子.简单的基本粒子组合起来后就复杂的吓人了啊,变成这个复杂的物理世界.不同的粒子组合起来后表示的信息不一样,具有的功能也不一样,比如有不同的物理,化学,生物性质.而计算里的数据组合起来也不会太复杂,无非是那么有限的一些数据结构. 电源与太阳,进程与生物 计算机的能力能源自然是电,而现实世界运转所需要的能量最终是来自太阳的热能.实际上这样说也不太准确,虽然绝大部分能量都是间接由太阳能转化来的,但物质本身不也有能量嘛,爱因斯坦有所谓的质能方程,质量可以转换成能量的嘛.只不过这样的能量我们不容易利用的了.如果啥时太阳突然没了,虽然我们可能还能利用现在已经间接得来的能量维持很长时间,但最多维持多久就要视科学技术手段而定了.反正最后变得像其他星球一样,一片死寂没有生物一样的可能性很大. 电脑一断电关机就是废物一堆了,只有开着机,程序在内存中运转才是活的.现实世界一断电也一样,万物寂灭.那些能活动的生物就像在内存中跑的进程一样.   变量与名字 编程时我们往往会取各种各样的名字,各种类型的变量会有变量名,函数和类也一样有名字,实例化一个对象时还得有个名字.我们就是靠着名字来使用那些东东.我们人也有名字,变量不还是别名之类的.人还可以不止一个名,比如我中文名叫刘伟文,英文名叫Arwen. 然后世界万物我们也都会起各种各样的名字,你能找出个东东来是没有名字的吗? 很少出现吧.即使某个生物学家在哪欣喜的发现一个新物种后也会立马想着给取个名字.另外名字一多肯定容易有重名的,命名变量时一般有作用域,或者干脆还整个命名空间出来.这样相同的名字只要处于不同区域就不会带来歧义.同名的人一般是处于不同的地方,或者总有啥可以区分他们的标志,所以也不用太担心.     事件驱动与自然规律 图形界面的计算机系统一般是事件驱动,也就是你得点一下啥图标它才动一下,不点它就像个死家伙在那不动了.而现实世界生物才有主动性,它自己会在内在驱动下采取一些行动.另外电脑上我们点下哪个按钮,系统一般就去调用一个函数来进行一些操作,而现实世界中你触动一些啥图象界面,比如一脚踩到一只蚂蚁身上,它就挂了.要一脚踩一堆狗屎上,它只是变形.这里你操作下这个奇怪的世界实际上是调用一些科学规律法则,比如调用物理规律,生物规律.蚂蚁死了是符合生物规律和物理规律,狗屎变形只是物理规律起下作用.那这些自然规律谁制定的? 比如什么万有引力,进化论之类的啊.有人说是上帝制定的规律.不过到底咋会事鬼才知道啊.   对象的构建与生物的形成 我们知道在面向对象中,实例化一个类后会分配一块内存,并调用构造函数,这块内存就代表一个对象就此产生了.而用完了后就调用析构函数,释放掉内存.而那些内存又可以去用来构建其他对象了.而现实世界中,本来是一堆堆的没有生命的基本粒子.被组合起来后就形成各种物体,有生命的也有没生命的.比如按道理讲你身上的组合物质跟那些伟人牛逼的人,或者跟一头蠢猪,一个王八没啥太多不一样嘛.所以佛教里不常说人的肉体只是一副臭皮囊嘛,没啥了不起的,美也好丑也罢,最后终化为尘土.你挂了后就像对象被析构了一样,你又被分解成基本粒子.又可以把你肉体中的物质来组合一棵树,或者用来修房子,铺马路啥的.   被控制的世界,受约束的人 不过人内心都比较向往自由,不喜欢受到控件,制约.如果说世间万物包括人都被某个神控制,或者被某种更高等的智慧生物控制,会作何感想? 如果要说是神可能大家还比较容易接受点,特别是有宗教信仰的人.觉得神是怜悯我们的,比如要按照上帝或真主的指引去做,就会受到保佑和恩赐.但如果真有神的话,我们又如何能知道他们的想法? 或者我们在神的眼里只是一个玩偶,生死与他无关.或者老子那句,天地不仁以万物为刍狗就可以这样来解释.当然有人也有其他的解释.那如果这样的神跟一个更高等的外星智慧生物貌似也没太大区别,只是称呼不一样嘛.当然了还有个比较普遍的观点是认为有可能有个万能的神,他甚至可能是个数学家,他制定了一些物理,化学,生物规律来支配这个世界.然后呢他就撒手不管了,任我们自生自灭. 有时一些科幻电影都会出现这类题材,我们生活的世界背后是被某种力量控制.比如<<黑客帝国>>,<<命运规划局>>. 当然了这是一种强势的明显的控制. 实际上现实中我们何尝不是被各种思想观念,生物本能,被一些大人物操纵的经济市场,文化市场所隐式的控制呢?","title":"现实世界是个图象界面系统"},{"content":"import urllib, httplibimport utilsimport json class User:    def __init__(self):        print 'a'        def login(self, imsi, ua):        print \"==============user start login==================\"        input = {            \"method\"       : \"user.login\",            \"userName\"     : \"\",            \"userPass\"     : \"\",        }                input[\"sig\"] = utils.getSignature(input)        params = urllib.urlencode(input)        headers = {            \"user-agent\"  : ua,            \"Appstore-clientType\" : \"android\",            \"Appstore-IMEI\" : \"123456789000000\",            \"Appstore-IMSI\" : imsi        }            try:            connection = httplib.HTTPConnection(utils.API_HOST)            connection.request(\"POST\", \"/api\", params, headers)            response = connection.getresponse().read()            #print \"=========\" + response            connection.close()        except Exception, e :            print \"========\" + str(e)                    if \"errorcode\" in response or response is None:            return                results = json.loads(response)                    return results[\"results\"].encode(\"utf-8\")","title":"python client使用 http post 到server端"},{"content":"直接选择排序(Straight Select Sorting) 也是一种简单的排序方法，它的基本思想是：第一次从R[0]~R[n-1]中选取最小值，与R[0]交换，第二次从R{1}~R[n-1]中选取最小值，与R[1]交换，....， 　　第i次从R[i-1]~R[n-1]中选取最小值，与R[i-1]交换，.....，第n-1次从R[n-2]~R[n-1]中选取最小值，与R[n-2]交换,总共通过n-1次,得到一个按排序码从小到大排列的有序序列. 直接选择排序算法 代码示例： //注：关键字值类型为int，数组的索引是从0开始//\t1. 初始状态无序区为array【0， n - 1】，有序区为空。//\t2. 第1趟排序从array【0， n - 1】中找到下标为k的关键字最小值，把array【k】和//\tarray【0】交换。现在无序区为array【1， n - 1】， 有序区为array【0， 0】。//\t第2趟排序...//\t第3趟排序...//\t...//\t3. 第i趟排序（1 <= i <= n - 1）,从array【i， n - 1】中找到下标为j的关键字最小值，把//\tarray【j】和array【i - 1】交换，如果i == n - 1，则排序结束，否则继续3步骤。 // 算法分析 //1. 关键字比较次数。 // 无论记录的初始状态，比较次数都是1 + 2 + 3 + 4 + ... + (n - 1) = n * (n -1) / 2; //2.  记录移动次数。 // 最好情况下0次， 正序， 最坏情况下3 * （n - 1）次, 反序。 // 那么直接选择排序的时间复杂度就是：O（n * n)。 //3. 直接选择排序是一个就地排序。辅助空间O（1）。 // 非就地排序一般要求的辅助空间为O（n）。 //4.  直接选择排序不稳定的。 // 反例  // 下标：【1 2 3】 // 关键字值：2 2 1 // 进过直接选择排序第一个2和第二个2相对位置发生了改变。 //#include<iostream>using namespace std;void selectSort(int *a,int left,int right){\tfor(int i=left;i<right;i++){\t\tint k=i;\t\t//在a[i]到a[n-1]之间找到最小排序码的元素\t\tfor(int j=i+1;j<=right;j++)\t\t\tif(a[j] < a[k])\t\t\t\tk=j;//保存具有当前最小排序码的元素的排序码\t\tif( k != i)\t\t\tswap(a[i],a[k]);//交换\t}}void main(){\tint a[]={23,45,23,434,34,213,454,3421,45,6};\tint ARR_LENGTH = (sizeof(a)/sizeof(a[0]));\tselectSort(a,0,ARR_LENGTH-1);\tfor(int i=0;i<ARR_LENGTH;i++)\t\tcout<<a[i]<<\" \";\tcout<<endl;} 运行结果： 直接排序的排序码比较次数KCN与元素的初始排列无关。第 i 趟选择具有最小排序码的元素所需要的比较次数总是 n - i - 1 次，此处假定整个待排序元素有 n 个元素，因此，总的排序码的比较次数为： KCN =n ( n - 1) / 2  元素的移动次数与元素序列的初始排列有关。当这组元素的初始状态是按照其排序码从小到大有序的时候，元素的移动此时 RMN= 0 ；最坏情况是每一趟都要进行交换，总的移动次数为 RMN = 3 （n-1）。尽管如此，相比其他的排序算法，待排序元素的有序性对于选择排序的运行时间影响不大。因为从未排序部分选择最小元素的每一步操作过程，没有对下一步要找的最小项的位置给出相关信息。因此，对于已经排序好序列的序列 或者 各元素排序码值完全相同的序列，直接选择排序所花费的时间与对随机排列的元素序列所花时间是基本相同。因此选择排序比较简单 并且执行时间比较固定。而对于它对一类重要的元素序列具有较好的效率，这就是元素规模很大，而排序码却比较小的序列。因为它对于这种序列进行排序，移动所花费的时间比比较操作的时间大的多，而其他算法移动操作的次数都要比选择排序来的多。 另外，直接选择排序是一种不稳定的排序算法。","title":"[置顶] 直接选择排序 知识点小结"},{"content":"最近在用jasperreport做报表时，出现一个问题，项目发布在内网时，打印一切正常，但是发布到外网，而且使用域名访问时，总是报拒绝访问的错误： java.security.AccessControlException:access denied (java.net.SocketPermission 125.64.60.11:8000 connect,resolve) at java.security.AccessControlContext.checkPermission(Unknown Source) at java.security.AccessController.checkPermission(Unknown Source) at java.lang.SecurityManager.checkPermission(Unknown Source) at java.lang.SecurityManager.checkConnect(Unknown Source) at sun.plugin2.applet.Applet2SecurityManager.checkConnect(Unknown Source) at java.net.Socket.connect(Unknown Source) at sun.net.NetworkClient.doConnect(Unknown Source) at sun.net.www.http.HttpClient.openServer(Unknown Source) .... 发布在外网，如果直接使用IP访问，也没有问题，但只要是域名访问就会出现这个问题。 查找了一下原因，原来是当使用域名访问时，applet跨域访问造成的安全性问题。解决方法有以下几种： 1、在JRE的策略文件java.policy中添加授权 在安装目录下的lib/security目录下的java.policy文件中的grant {}中添加下面授权： permission java.net.SocketPermission \"*:*\", \"accept,connect,resolve\"; 其中*:*中第一个*表示允许的IP，如果是*表示所有；第二个*表示端口或端口范围，*表示所有端口，还可以是8080或8080-，如果是8080-则表示大于等于8080端口都允许。 \"accept,connect,resolve\"表示允许的操作：接受、连接、解析。 2、建立自己的策略文件 也可以建立自己的策略文件，如myPolicy.policy，在其中添加上面描述的授权，再在lib/security目录下的java.security文件中添加我们建立的策略文件： policy.url.x=file:${java.home}/lib/security/myPolicy.policy 或者不用在java.security添加包含的策略文件，而是在启动时带一个参数 java -Djava.security.policy=myPolicy.policy 也是可以的。 3、对applet进行数字签名 首先使用JDK自带的keytool工具生成证书，再使用jarsigner来对applet的jar进行签名。","title":"applet跨域访问的安全性问题"},{"content":"在A5里的一般都是老前辈了，我不知道有没有一个像我一样刚刚17岁的孩子，下面给大家说一下我的网络之路，也许我写的不太好，也许我还很幼稚，很天真，不过我真心希望你将这篇文章看完。     11年我从初中毕业，离开校园的那一刻，我感觉很迷茫，我以后要干什么，我的梦想是什么。我家是农村的 爸妈也都是普普通通做生意的，家里也不可能养我一辈子，后来我跟着我朋友一起找了一个小饭店当着服务员，一个月800的工资。做了一个月以后我想我不能就这么干下去，于是在我爸的劝说下，我去了一个修车厂当起了学徒工，可是我对汽车根本没有一点兴趣，做了大概一个月，我不顾老爸的阻拦离开了那个修车厂。我爸当时对我已经不报什么希望了，因为我什么也干不了。回到家我整天对着电脑生活，玩点网络游戏，玩了几天也没什么意思，我就整天在网上瞎晃悠，后来我想着开一个淘宝店，挣点小钱，可是因为年龄不够18岁，没有资金 也就没有开，当时跟我爸商量让他给我投资点钱，用他的身份证开一个，但是我爸始终认为这是不务正业、网上不可能挣到钱。   我也不能整天在家呆着啊，于是我再网上找了个电脑培训学校，跟我爸商量了几天，他才同意让我学习这一方面的知识。起初我是不知道这学校是学什么的，我只知道是跟电脑有关的。来了之后才知道，主要是学编程的，java，jsp之类的，学了一学期，感觉学校还不错，最起码没有一些学校那么坑爹，还能学到一些东西。   一学期以后，我把家里的电脑拿到了学校宿舍，我们只在一 、三、五 下午上课 ，其他时间没事干，就在宿舍玩游戏，一玩就是一天（到晚上11点，因为宿舍11点停电），就这样玩了大概有一个多月，觉得每天这样过，心里会有一种，说不出来的感觉，玩游戏也没意思了。   后来我就在网上找一些关于网上赚钱的论坛，学习怎么在网上赚钱，后来我接触了CPA 做了一段时间 挣了几十块钱，但是我觉得这不是我要走的路，还有一些个人原因，就不做了。当时，在学校学习了一些简单的HTML代码，做过一些简单的静态网站，我就想网上的这些网站是怎么挣钱的呢，我能不能做一个。于是我开始在网上寻找着方面的东西，后来我找了一个笑话站的源码，买了域名，空间，就搭建了我的第一个网站，我当时也不懂什么seo，外链什么的。 就是每天在网上找点东西 复制粘贴上去 然后在QQ好友、QQ群里一个一个的发我的网址。做了大概20天，没什么动静，当时就觉得做网站也赚不到钱，就想着把这个笑话站卖了，于是有一个人加了我QQ 100块钱将我心爱的站买走了，我在跟他交流的时候，他大致给我讲了怎么做网站，怎么做赚钱，可能是在交流中觉得我人还不错，送了我一个域名，空间指导我又做了一个电影网站，还时不时让我帮他做一些简单的事情，当然他是给我钱的。在这期间我学会了不少。电影网站做了一个月 大概每天有50个IP，后来很不幸 被K了。他告诉我每天坚持做外链，更新网站,直到现在网站恢复了，但也没有什么大的起色。可能是我学习的还不够多吧，不过我相信每天到A5来学习，我肯定是会成为一个高手的！   顺便说一句，18岁成年是谁规定的，我要恨死你了，因为我不到18岁，淘宝不让我开店，支付宝我不能实名认证，谷歌联盟不让我申请 。。。。真希望可以快点18岁！ 原文来自站长中心www.software8.co/转载请注明","title":"一个未成年的站长之路"},{"content":"这里介绍最简单的方法，也是我目前在用的。   在window下安装QT和QT_creator需要有mingw模拟linux环境，所以需要三件套：QT，QT_creator，mingw；   但是其实QT已经帮我们打包好一个SDK了，里面包含了一整套开发库和IDE，安装完后再设置一下环境变量就可以使用了。 点击下载一个QT_SDK；   我的QT安装盘：C:\\Qt\\2010.05 我的QT环境变量：C:\\Qt\\2010.05\\mingw\\bin;C:\\Qt\\2010.05\\bin;C:\\Qt\\2010.05\\qt\\bin;    然后看了一本60多页的QT入门教程，大概的学习了QT，看了一下api，当然，如果你有C或C++基础，你会学的更快。   最后，在网上找了一个QT记事本的简单源代码，自己修改了一下，也和大家分享了：QT记事本         温馨提示：使用qt4.84和qt-creator2.6.1搭配的环境变量，貌似不稳定，我就是被折腾致死了，在QT群了讨教后，有人说新版的QT不稳定，会出莫名其妙的问题。  ","title":"window下轻松配置QT环境 和 分享一个QT记事本"},{"content":"        翻开刘汝佳的算法竞赛入门经典，看到了很久以前做过的一道题目。用栈模拟火车进站出站。该题在POJ题号为1363,；ZOJ为1259；UVA为514。我没有用栈去做，已经在UVA和ZOJ均AC，但是不晓得POJ为啥过不了。现在把代码贴到下面，等明天清醒了再找漏洞。 #include <stdio.h>int main(){    int n;    while (scanf(\"%d\", &n) && n) {        int tmp, ma, mi;        while (scanf(\"%d\", &tmp) && tmp) {            ma = mi = tmp;            int flag = 1;            for (int i=1; i<n; i++) {                scanf(\"%d\", &tmp);                if (tmp>mi && tmp<ma) {                    flag = 0;                }                if (tmp > ma) {                    ma = tmp;                    mi = ma;                }                else                    mi = mi <= tmp ? mi : tmp;            }            if (flag)                printf(\"Yes\\n\");            else                printf(\"No\\n\");        }        printf(\"\\n\");    }    return 0;}          上面代码有很大的漏洞。首先 3 1 4 2这个数据就过不了。对于这道题，最后我得到的结论是：一列数中，对于每个数，后面比它小的数都应该是降序排列，这样才能满足题目的条件。下面是我经过修改的低效率做法，终于在POJ AC了，依然按照我的那个结论。 #include <stdio.h>int main(){    int n;    while (scanf(\"%d\", &n) && n) {        int tmp[1005], ma, mi;        while (scanf(\"%d\", &tmp[0]) && tmp[0]) {            int flag = 1;            for (int i=1; i<n; i++) {                scanf(\"%d\", &tmp[i]);            }            for (int i=0; i<n; i++) {                ma = mi = tmp[i];                for (int j=i+1; j<n; j++) {                    if (tmp[j]>mi && tmp[j]<ma) {                        flag = 0;                    }                    else                        mi = mi <= tmp[j] ? mi : tmp[j];                }                if (!flag) break;            }            if (flag)                printf(\"Yes\\n\");            else                printf(\"No\\n\");        }        printf(\"\\n\");    }    return 0;}    ","title":"粘一个在UVA和ZOJ都能AC但POJ WR的代码"},{"content":"文件和目录操作API，跟原来FILE IO做了很多改进，我们看看新的API，这个也是NIO操作的基础。 package com.mime;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.OutputStreamWriter;import java.nio.charset.Charset;import java.nio.file.DirectoryStream;import java.nio.file.FileSystems;import java.nio.file.Files;import java.nio.file.LinkOption;import java.nio.file.Path;import java.nio.file.Paths;import java.nio.file.StandardCopyOption;import java.nio.file.StandardOpenOption;import java.nio.file.attribute.FileAttribute;import java.nio.file.attribute.PosixFilePermission;import java.nio.file.attribute.PosixFilePermissions;import java.util.List;import java.util.Set;public class NIO2FileAndDir {\t/**\t * @param args\t */\tpublic static void main(String[] args) {\t\tPath path = FileSystems.getDefault().getPath(\t\t\t\tSystem.getProperty(\"user.home\"), \"www\", \"pyweb.settings\");\t\t// 检查文件是否存在 exist, not exist, or unknown.\t\t// !Files.exists(...) is not equivalent to Files.notExists(...) and the\t\t// notExists() method is not a complement of the exists() method\t\t// 如果应用没有权限访问这个文件，则两者都返回false\t\tboolean path_exists = Files.exists(path,\t\t\t\tnew LinkOption[] { LinkOption.NOFOLLOW_LINKS });\t\tboolean path_notexists = Files.notExists(path,\t\t\t\tnew LinkOption[] { LinkOption.NOFOLLOW_LINKS });\t\tSystem.out.println(path_exists);\t\tSystem.out.println(path_notexists);\t\t// 检测文件访问权限\t\tboolean is_readable = Files.isReadable(path);\t\tboolean is_writable = Files.isWritable(path);\t\tboolean is_executable = Files.isExecutable(path);\t\tboolean is_regular = Files.isRegularFile(path,\t\t\t\tLinkOption.NOFOLLOW_LINKS);\t\tif ((is_readable) && (is_writable) && (is_executable) && (is_regular)) {\t\t\tSystem.out.println(\"The checked file is accessible!\");\t\t} else {\t\t\tSystem.out.println(\"The checked file is not accessible!\");\t\t}\t\t// 检测文件是否指定同一个文件\t\tPath path_1 = FileSystems.getDefault().getPath(\t\t\t\tSystem.getProperty(\"user.home\"), \"www\", \"pyweb.settings\");\t\tPath path_2 = FileSystems.getDefault().getPath(\t\t\t\tSystem.getProperty(\"user.home\"), \"www\", \"django.wsgi\");\t\tPath path_3 = FileSystems.getDefault().getPath(\t\t\t\tSystem.getProperty(\"user.home\"), \"software/../www\",\t\t\t\t\"pyweb.settings\");\t\ttry {\t\t\tboolean is_same_file_12 = Files.isSameFile(path_1, path_2);\t\t\tboolean is_same_file_13 = Files.isSameFile(path_1, path_3);\t\t\tboolean is_same_file_23 = Files.isSameFile(path_2, path_3);\t\t\tSystem.out.println(\"is same file 1&2 ? \" + is_same_file_12);\t\t\tSystem.out.println(\"is same file 1&3 ? \" + is_same_file_13);\t\t\tSystem.out.println(\"is same file 2&3 ? \" + is_same_file_23);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\t// 检测文件可见行\t\ttry {\t\t\tboolean is_hidden = Files.isHidden(path);\t\t\tSystem.out.println(\"Is hidden ? \" + is_hidden);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\t// 获取文件系统根目录\t\tIterable<Path> dirs = FileSystems.getDefault().getRootDirectories();\t\tfor (Path name : dirs) {\t\t\tSystem.out.println(name);\t\t}\t\t// jdk6的API\t\t// File[] roots = File.listRoots();\t\t// for (File root : roots) {\t\t// System.out.println(root);\t\t// }\t\t// 创建新目录\t\tPath newdir = FileSystems.getDefault().getPath(\"/tmp/aaa\");\t\t// try {\t\t// Files.createDirectory(newdir);\t\t// } catch (IOException e) {\t\t// System.err.println(e);\t\t// }\t\tSet<PosixFilePermission> perms = PosixFilePermissions\t\t\t\t.fromString(\"rwxr-x---\");\t\tFileAttribute<Set<PosixFilePermission>> attr = PosixFilePermissions\t\t\t\t.asFileAttribute(perms);\t\ttry {\t\t\tFiles.createDirectory(newdir, attr);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\t// 创建多级目录,创建bbb目录，在bbb目录下再创建ccc目录等等\t\tPath newdir2 = FileSystems.getDefault().getPath(\"/tmp/aaa\",\t\t\t\t\"/bbb/ccc/ddd\");\t\ttry {\t\t\tFiles.createDirectories(newdir2);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\t// 列举目录信息\t\tPath newdir3 = FileSystems.getDefault().getPath(\"/tmp\");\t\ttry (DirectoryStream<Path> ds = Files.newDirectoryStream(newdir3)) {\t\t\tfor (Path file : ds) {\t\t\t\tSystem.out.println(file.getFileName());\t\t\t}\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\t// 通过正则表达式过滤\t\tSystem.out.println(\"\\nGlob pattern applied:\");\t\ttry (DirectoryStream<Path> ds = Files.newDirectoryStream(newdir3,\t\t\t\t\"*.{png,jpg,bmp，ini}\")) {\t\t\tfor (Path file : ds) {\t\t\t\tSystem.out.println(file.getFileName());\t\t\t}\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\t// 创建新文件\t\tPath newfile = FileSystems.getDefault().getPath(\t\t\t\t\"/tmp/SonyEricssonOpen.txt\");\t\tSet<PosixFilePermission> perms1 = PosixFilePermissions\t\t\t\t.fromString(\"rw-------\");\t\tFileAttribute<Set<PosixFilePermission>> attr2 = PosixFilePermissions\t\t\t\t.asFileAttribute(perms1);\t\ttry {\t\t\tFiles.createFile(newfile, attr2);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\t// 写小文件\t\ttry {\t\t\tbyte[] rf_wiki_byte = \"test\".getBytes(\"UTF-8\");\t\t\tFiles.write(newfile, rf_wiki_byte);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\t// 读小文件\t\ttry {\t\t\tbyte[] ballArray = Files.readAllBytes(newfile);\t\t\tSystem.out.println(ballArray.toString());\t\t} catch (IOException e) {\t\t\tSystem.out.println(e);\t\t}\t\tCharset charset = Charset.forName(\"ISO-8859-1\");\t\ttry {\t\t\tList<String> lines = Files.readAllLines(newfile, charset);\t\t\tfor (String line : lines) {\t\t\t\tSystem.out.println(line);\t\t\t}\t\t} catch (IOException e) {\t\t\tSystem.out.println(e);\t\t}\t\t// 读写文件缓存流操作\t\tString text = \"\\nVamos Rafa!\";\t\ttry (BufferedWriter writer = Files.newBufferedWriter(newfile, charset,\t\t\t\tStandardOpenOption.APPEND)) {\t\t\twriter.write(text);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\ttry (BufferedReader reader = Files.newBufferedReader(newfile, charset)) {\t\t\tString line = null;\t\t\twhile ((line = reader.readLine()) != null) {\t\t\t\tSystem.out.println(line);\t\t\t}\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\t// 不用缓存的输入输出流\t\tString racquet = \"Racquet: Babolat AeroPro Drive GT\";\t\tbyte data[] = racquet.getBytes();\t\ttry (OutputStream outputStream = Files.newOutputStream(newfile)) {\t\t\toutputStream.write(data);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\tString string = \"\\nString: Babolat RPM Blast 16\";\t\ttry (OutputStream outputStream = Files.newOutputStream(newfile,\t\t\t\tStandardOpenOption.APPEND);\t\t\t\tBufferedWriter writer = new BufferedWriter(\t\t\t\t\t\tnew OutputStreamWriter(outputStream))) {\t\t\twriter.write(string);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\tint n;\t\ttry (InputStream in = Files.newInputStream(newfile)) {\t\t\twhile ((n = in.read()) != -1) {\t\t\t\tSystem.out.print((char) n);\t\t\t}\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\t// 临时目录操作\t\tString tmp_dir_prefix = \"nio_\";\t\ttry {\t\t\t// passing null prefix\t\t\tPath tmp_1 = Files.createTempDirectory(null);\t\t\tSystem.out.println(\"TMP: \" + tmp_1.toString());\t\t\t// set a prefix\t\t\tPath tmp_2 = Files.createTempDirectory(tmp_dir_prefix);\t\t\tSystem.out.println(\"TMP: \" + tmp_2.toString());\t\t\t// 删除临时目录\t\t\tPath basedir = FileSystems.getDefault().getPath(\"/tmp/aaa\");\t\t\tPath tmp_dir = Files.createTempDirectory(basedir, tmp_dir_prefix);\t\t\tFile asFile = tmp_dir.toFile();\t\t\tasFile.deleteOnExit();\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\tString tmp_file_prefix = \"rafa_\";\t\tString tmp_file_sufix = \".txt\";\t\ttry {\t\t\t// passing null prefix/suffix\t\t\tPath tmp_1 = Files.createTempFile(null, null);\t\t\tSystem.out.println(\"TMP: \" + tmp_1.toString());\t\t\t// set a prefix and a suffix\t\t\tPath tmp_2 = Files.createTempFile(tmp_file_prefix, tmp_file_sufix);\t\t\tSystem.out.println(\"TMP: \" + tmp_2.toString());\t\t\tFile asFile = tmp_2.toFile();\t\t\tasFile.deleteOnExit();\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\t// 删除文件\t\ttry {\t\t\tboolean success = Files.deleteIfExists(newdir2);\t\t\tSystem.out.println(\"Delete status: \" + success);\t\t} catch (IOException | SecurityException e) {\t\t\tSystem.err.println(e);\t\t}\t\t// 拷贝文件\t\tPath copy_from = Paths.get(\"/tmp\", \"draw_template.txt\");\t\tPath copy_to = Paths\t\t\t\t.get(\"/tmp/bbb\", copy_from.getFileName().toString());\t\ttry {\t\t\tFiles.copy(copy_from, copy_to);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\ttry (InputStream is = new FileInputStream(copy_from.toFile())) {\t\t\tFiles.copy(is, copy_to);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\t//移动文件\t\tPath movefrom = FileSystems.getDefault().getPath(\t\t\t\t\"C:/rafaelnadal/rafa_2.jpg\");\t\tPath moveto = FileSystems.getDefault().getPath(\t\t\t\t\"C:/rafaelnadal/photos/rafa_2.jpg\");\t\ttry {\t\t\tFiles.move(movefrom, moveto, StandardCopyOption.REPLACE_EXISTING);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t}} 输出： truefalseThe checked file is not accessible!is same file 1&2 ? falseis same file 1&3 ? trueis same file 2&3 ? falseIs hidden ? false/java.nio.file.FileAlreadyExistsException: /tmp/aaa.ICE-unixgpg-LOz0cL.org.chromium.Chromium.YKWsQJhsperfdata_weijianzhongwjkde-weijianzhongwjpulse-qKcxuRTsGUobscim-im-agent-0.3.0.socket-1000@localhost:0.0scim-helper-manager-socket-weijianzhongwjksocket-weijianzhongwjvirtuoso_Lh2135.iniscim-socket-frontend-weijianzhongwjscim-panel-socket:0-weijianzhongwj.X0-lockpulse-j0jluTvI3Pe6sni-qt_kaccessibleapp_2026-mEz8Dy.X11-unixakonadi-weijianzhongwj.mjmToIssh-mfuayNh73d7Qvirt_1111aaapulse-PKdhtXMmr18nfcitx-socket-:0Glob pattern applied:[B@cd32e5testtestVamos Rafa!Racquet: Babolat AeroPro Drive GTString: Babolat RPM Blast 16TMP: /tmp/3892364837850046417TMP: /tmp/nio_5078970948266789689TMP: /tmp/7342813580436243519.tmpTMP: /tmp/rafa_47993266069276248.txtDelete status: truejava.nio.file.NoSuchFileException: /tmp/draw_template.txtjava.io.FileNotFoundException: /tmp/draw_template.txt (没有那个文件或目录)java.nio.file.NoSuchFileException: C:/rafaelnadal/rafa_2.jpg","title":"java7 NIO2(4) 文件和目录操作API"},{"content":"数据报（UDP）信道  Java的NIO包通过DatagramChannel类实现了数据报（UDP）信道。与我们之前看到的其他形式的SelectableChannel一样，DatagramChannel在DatagramSocket上添加了选择和非阻塞行为，以及基于缓冲区的I/O操作能力。  DatagramChannel: 创建，连接和关闭  static DatagramChannel open() boolean isOpen() DatagramSocket socket() void close() 需要调用DatagramChannel的open()工厂方法来创建一个DatagramChannel实例，该实例是未绑定的。DatagramChannel只是对基本DatagramSocket的一个包装器（wrapper）。使用其socket()方法可以直接访问内部的DatagramSocket实例。这就允许通过调用基本的DatagramSocket方法进行绑定、设置套接字选项等操作。用完DatagramChannel后，要调用它的close()方法将其关闭。  只要创建了一个DatagramChannel实例，就可以非常直接地发送和接收数据。 DatagramChannel: 发送和接收 int send(ByteBuffer src, SocketAddress target) SocketAddress receive(ByteBuffer dst) send()方法用于创建一个包含了给定ByteBuffer中的数据的数据报文，并将其发送到目的地址指定的SocketAddress上。receive()方法用于将接收到的数据报文存入指定缓冲区并返回发送者的地址。重要提示：如果缓冲区的剩余空间小于数据报文中的数据大小，多余的数据将毫无提示地丢弃。  以下代码段用于创建一个DatagramChannel实例，并将UTF-16编码的字符串\"Hello\"发送到运行在同一主机的5000端口上的UDP服务器上。 DatagramChannel channel = DatagramChannel.open(); ByteBuffer buffer = ByteBuffer.wrap(\"Hello\".getBytes(\"UTF-16\")); channel.send(buffer, new InetSocketAddress(\"localhost\", 5000)); 以下代码段用于创建一个DatagramChannel实例，将底层的套接字绑定到5000端口，接收最长为20字节的数据报文，并将字节转换成使用UTF-16编码的字符串。 DatagramChannel channel = DatagramChannel.open(); channel.socket().bind(new InetSocketAddress(5000)); ByteBuffer buffer = ByteBuffer.allocateDirect(20); SocketAddress address = channel.receive(buffer); buffer.flip(); String received = Charset.forName(\"UTF-16\"). newDecoder().decode(buffer).toString(); 在上面的send()实例中，调用send()方法时并没有显式地绑定本地端口，因此将随机选择一个可用端口。相应的receive()方法用于返回一个SocketAddress，其中包含了端口号。 如果总是向同一个远程终端发送或接收数据，我们可以选择调用connect()方法，并使用SocketAddress指定远程终端的地址。 DatagramChannel: 连接DatagramChannel DatagramChannel connect(SocketAddress remote) DatagramChannel disconnect() boolean isConnected() int read(ByteBuffer dst) long read(ByteBuffer[] dsts) long read(ByteBuffer[] dsts, int offset, int length) int write(ByteBuffer src) long write(ByteBuffer[] srcs) long write(ByteBuffer[] srcs, int offset, int length) 这些方法限制我们只能通过指定的地址发送和接收数据。为什么要这样做呢？原因之一是调用connect()方法后，可以使用read()和write()方法来代替receive()和send()方法，并且不需要处理远程地址。read()和write()方法分别用于接收和发送一个数据报文。分散式读操作以一个ByteBuffer数组为参数，只接收一个数据报文，并按顺序将其填入缓冲区中。聚集式写操作将缓冲区数组中的所有字节连接起来创建一个要传输的数据报文。重要提示：现在能够发送的最大数据报文可以包含65507个字节，试图发送更多的数据将被无提示地截断。  使用connect()方法的另一个好处是，已建立连接的数据报文信道可能只接收从指定终端发送来的数据，因此我们不需要测试接收端的有效性。注意，DatagramChannel的connect()方法只起到限制发送和接收终端的作用，连接时并没有数据包在SocketChannel上进行交换，而且也不需要像SocketChannel那样等待或测试连接是否完成。（见第6章） 到目前为止DatagramChannel看起来与DatagramSocket非常相似。数据报文信道和套接字的主要区别是，信道可以进行非阻塞I/O操作和使用选择器。DatagramChannel中选择器的创建，信道的注册、选择等，与SocketChannel几乎一模一样。有一个区别是DatagramChannel不能注册连接I/O操作，不过也不需要这样做，因为DatagramChannel的connect()方法永远不会阻塞。  DatagramChannel: 设置阻塞行为和使用选择器 SelectableChannel configureBlocking(boolean block) boolean isBlocking() SelectionKey register(Selector sel, int ops) SelectionKey register(Selector sel, int ops, Object attachment)  boolean isRegistered() int validOps() SelectionKey keyFor(Selector sel) 这些方法的功能与SocketChannel和ServerSocketChannel中的相应方法一样。 下面使用DatagramChannel对第4章中的DatagramSocket UDP回显服务器进行重写。 服务器侦听指定的端口，并将接收到的数据报文简单地回发给客户端。重写后的服务器与原 来版本的主要区别是它不会在send()和receive()方法上阻塞等待。 UDPEchoServerSelector.java 0 import java.io.IOException; 1 import java.net.InetSocketAddress; 2 import java.net.SocketAddress; 3 import java.nio.ByteBuffer; 4 import java.nio.channels.DatagramChannel; 5 import java.nio.channels.SelectionKey; 6 import java.nio.channels.Selector; 7 import java.util.Iterator; 8 9 public class UDPEchoServerSelector { 10 11 private static final int TIMEOUT = 3000; // Wait timeout (milliseconds) 12 13 private static final int ECHOMAX = 255; // Maximum size of echo datagram 14 15 public static void main(String[] args) throws IOException { 16 17 if (args.length != 1) // Test for correct argument list 18 throw new IllegalArgumentException(\"Parameter(s): <Port>\"); 19 20 int servPort = Integer.parseInt(args[0]); 21 22 // Create a selector to multiplex client connections. 23 Selector selector = Selector.open(); 24 25 DatagramChannel channel = DatagramChannel.open(); 26 channel.configureBlocking(false); 27 channel.socket().bind(new InetSocketAddress(servPort)); 28 channel.register(selector, SelectionKey.OP_READ, new ClientRecord()); 29 30 while (true) { // Run forever, receiving and echoing datagrams 31 // Wait for task or until timeout expires 32 if (selector.select(TIMEOUT) == 0) { 33 System.out.print(\".\"); 34 continue; 35 } 36 37 // Get iterator on set of keys with I/O to process 38 Iterator<SelectionKey> keyIter = selector.selectedKeys().iterator(); 39 while (keyIter.hasNext()) { 40 SelectionKey key = keyIter.next(); // Key is bit mask 41 42 // Client socket channel has pending data? 43 if (key.isReadable()) 44 handleRead(key); 45 46 // Client socket channel is available for writing and 47 // key is valid (i.e., channel not closed). 48 if (key.isValid() && key.isWritable()) 49 handleWrite(key); 50 51 keyIter.remove(); 52 } 53 } 54 } 55 56 public static void handleRead(SelectionKey key) throws IOException { 57 DatagramChannel channel = (DatagramChannel) key.channel(); 58 ClientRecord clntRec = (ClientRecord) key.attachment(); 59 clntRec.buffer.clear(); // Prepare buffer for receiving 60 clntRec.clientAddress = channel.receive(clntRec.buffer); 61 if (clntRec.clientAddress != null) { // Did we receive something? 62 // Register write with the selector 63 key.interestOps(SelectionKey.OP_WRITE); 64 } 65 } 66 67 public static void handleWrite(SelectionKey key) throws IOException { 68 DatagramChannel channel = (DatagramChannel) key.channel(); 69 ClientRecord clntRec = (ClientRecord) key.attachment(); 70 clntRec.buffer.flip(); // Prepare buffer for sending 71 int bytesSent = channel.send(clntRec.buffer, clntRec.clientAddress); 72 if (bytesSent != 0) { // Buffer completely written? 73 // No longer interested in writes 74 key.interestOps(SelectionKey.OP_READ); 75 } 76 } 77 78 static class ClientRecord { 79 public SocketAddress clientAddress; 80 public ByteBuffer buffer = ByteBuffer.allocate(ECHOMAX); 81 } 82 } UDPEchoServerSelector.java   相关下载： Java_TCPIP_Socket编程(doc) http://download.csdn.net/detail/undoner/4940239   文献来源： LSOFT.CN(琅软中国)","title":"NIO：数据报（UDP）信道"},{"content":"这一节讲述如何定位一个malloc时coredump的例子。","title":"《coredump问题原理探究》windows版8.8节堆布局heap corruption第三个例子"},{"content":"Language: Default Intersecting Lines Time Limit: 1000MS   Memory Limit: 10000K Total Submissions: 7657   Accepted: 3510 Description 求两条直线相交部分，给出的坐标的范围在 -1000 到 1000 之间且为整数.  Input 第一行为数据组数 N≤10  接下来N行，每行为x1y1x2y2x3y3x4y4.表示第一条直线过 (x1,y1) 和 (x2,y2) ，第二条过 (x3,y3) 和 (x4,y4). 保证直线能被确定. Output 输出 N+2 第一行输出INTERSECTING LINES OUTPUT. 接下来每行输出相交部分 none, line, 或 point x y(保留2位小数). 最后1行输出 \"END OF OUTPUT\". Sample Input 50 0 4 4 0 4 4 05 0 7 6 1 0 2 35 0 7 6 3 -6 4 -32 0 2 27 1 5 18 50 3 4 0 1 2 2 5 Sample Output INTERSECTING LINES OUTPUTPOINT 2.00 2.00NONELINEPOINT 2.00 5.00POINT 1.07 2.20END OF OUTPUT Source Mid-Atlantic 1996 模板如下： 注意* 表示叉积 这题涉及已知相交，线段跨立求交点 异侧情况： 同侧情况： #include<cstdio>#include<cstring>#include<cmath>#include<cstdlib>#include<iostream>#include<algorithm>#include<functional>using namespace std;#define eps 1e-8double sqr(double x) {return x*x;}struct P{\tdouble x,y;\tP(double _x,double _y):x(_x),y(_y){}\tP(){}\tdouble dis()\t{\t\treturn sqrt(sqr(x)+sqr(y));\t}};struct V{\tdouble x,y;\tV(double _x,double _y):x(_x),y(_y){}\tV(P a,P b):x(b.x-a.x),y(b.y-a.y){}\tV(){}\tconst double dis()\t{\t\treturn sqrt(sqr(x)+sqr(y));\t}};P operator+(const P a,const V b){\treturn P(a.x+b.x,a.y+b.y);\t}V operator*(const double a,const V b){\treturn V(a*b.x,a*b.y);\t}double operator*(const V a,const V b){\treturn a.x*b.y-b.x*a.y;\t}P jiao_dian(const V a,V b,const V c,const V CD,const P C){\tdouble d;\td=b.dis();\tdouble s1=a*b,s2=b*c; \t\tdouble k=s1/(s1+s2);\treturn C+k*CD;}bool equal(const double a,const double b){\tif (abs(a-b)<eps) return 1;return 0;}int n;int main(){//s\tfreopen(\"poj1269.in\",\"r\",stdin);\tcout<<\"INTERSECTING LINES OUTPUT\"<<endl;\tscanf(\"%d\",&n);\tfor (int i=1;i<=n;i++)\t{\t\tdouble x1,y1,x2,y2,x3,y3,x4,y4;\t\tscanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\",&x1,&y1,&x2,&y2,&x3,&y3,&x4,&y4);\t\tP A=P(x1,y1),B=P(x2,y2),C=P(x3,y3),D=P(x4,y4);\t\tV AB=V(A,B),AC=V(A,C),AD=V(A,D),CD=V(C,D);\t\tif (equal((AB*CD),0))\t\t{\t\t\tif (equal((AC*AD),0)) cout<<\"LINE\\n\";\t\t\telse cout<<\"NONE\\n\";\t\t} \t\telse\t\t{\t\t\tP p=jiao_dian(AC,AB,AD,CD,C);\t\t\tcout.setf(ios::fixed);\t\t\tcout.precision(2);\t\t\tcout<<\"POINT \"<<p.x<<' '<<p.y<<endl;\t\t}\t}\tcout<<\"END OF OUTPUT\"<<endl;\treturn 0;}","title":"POJ 1269(直线的交点)"},{"content":"内存对齐 为什么要进行内存对齐 　　在计算机组成原理中我们学到：一块内存芯片一般只提供 8 位数据线，要进行 16 位数据的读写可采用奇偶分体来组织管理多个芯片， 32 位也类似： 　　这样，连续的四个字节会分布在不同的芯片上，送入地址 0，我们可将第 0、1、2、3 四个字节一次性读出组成一个 32 位数，送入地址 4（每个芯片接收到的地址是1），可一次性读出 4、5、6、7 四个字节。 　　但是如果要读 1、2、3、4 四个字节，就麻烦了，有的 CPU 直接歇菜了：我处理不了！但 Intel 的 CPU 走的是复杂指令集路线，岂能就此认输，它通过两次内存读，然后进行拼接合成我们想要的那个 32 位数，而这一切是在比机器码更低级的微指令执行阶段完成的，所以 movl 1, %eax 会不出意外地读出 1、2、3、4 四个字节到 eax，证据如下（mem.c）： #include <stdio.h>char a[]={0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88};int main(){    int *p = (int*)(a + 1);    int ans = *p;    printf(\"*p:\\t%p\\n\", ans);    printf(\"a:\\t%p\\n\", a);    printf(\"p:\\t%p\\n\", p);    return 0;} 　　该程序的运行结果如下： [lqy@localhost temp]$ gcc -o mem mem.c[lqy@localhost temp]$ ./mem*p: 0x55443322a:  0x80496a8p:  0x80496a9[lqy@localhost temp]$ 　　可看出程序确实从一个未对齐到 4 字节的地址（0x80496a9）后读出了 4 个字节，从汇编可看出确实是 1 条 mov 指令读出来的： movl    $a, %eaxaddl    $1, %eaxmovl    %eax, 28(%esp)  # 初始化指针 pmovl    28(%esp), %eaxmovl    (%eax), %eax    # 这里读出了 0x55443322movl    %eax, 24(%esp)  # 初始化 ans 　　虽然 Intel 的 CPU 能这样处理，但还是要浪费点时间不是，所以 C 程序还是要采取措施避免这种情况的发生，那就是内存对齐。 内存对齐的结果 　　内存对齐的完整描述你还是去百度吧，这里我只是含糊地介绍一下： 保证最大类型对齐到它的 size 尽量不浪费空间 比如： struct A{    char a;    int c;}; 它的大小为 8，c 的内部偏移为 4，这样就可以一次性读出 c 了。 再如： struct B{    char a;    char b;    int c;}; 它的大小还是 8，第 2 条起作用了！ 关闭内存对齐 　　讲到内存对齐，估计大家最期待的一大快事就是怎么关闭它（默认是开启的），毕竟 Intel CPU 如此强大，关闭了也没事。 　　关闭它也甚是简单，添加预处理指令 #pragma pack(1) 就行，windows linux 都管用： #include <stdio.h>#pragma pack(1)struct _A{    char c;    int i;};//__attribute__((packed));typedef struct _A A;int main(){    printf(\"%d\\n\", sizeof(A));    return 0;} 　　linux gcc 中更常见的是使用__attribute__((packed))，这个属性只解除对一个结构体的内存对齐，而 #pragma pack(1) 解除了整个 C源文件 的内存对齐，所以有时候__attribute__((packed)) 显得更为合理。 　　什么时候可能需要注意或者关闭内存对齐呢？我想大概是这两种情况： 结构化文件的读写 网络数据传输 另一个浪费内存的家伙 　　说到内存对齐，我想起了另一个喜欢浪费内存的家伙：参数对齐（我瞎编的名字，C 标准中或许有明确规定）。看下面这个程序： #include <stdio.h>typedef unsigned char u_char;u_char add(u_char a, u_char b){    return (u_char)(a+b);}int main(){    u_char a=1, b=2;    printf(\"ans:%d\\n\", add(a, b));    return 0;} 　　你说 add 函数的参数会占几个字节呢？2个？4个？结果是 8 个…… 　　“可恨”的是，这个家伙浪费内存的行为却被所有编译器纵容，我们无法追究它的责任。（应该是为了方便计算参数位置而规定的）","title":"内存对齐"},{"content":"函数帧 　　这标题一念出来我立刻想到了一个名人：白素贞……当然，此女与本文无关，下面进入正题： 其实程序运行就好比一帧一帧地放电影，每一帧是一次函数调用，电影放完了，我们就看到结局了。 　　我们用一个递归求解阶乘的程序来看看这个放映过程（fac.c）： #include <stdio.h>int fac(int n){    if(n <= 1)        return 1;    return n * fac(n-1);}int main(){    int n = 3;    int ans = fac(n);    printf(\"%d! = %d\\n\", n, ans);    return 0;} main 帧 　　首先 main 函数被调用（程序可不是从 main 开始执行的）： main:    pushl   %ebp    movl    %esp, %ebp    andl    $-16, %esp    subl    $32, %esp    movl    $3, 28(%esp)    # n = 3    movl    28(%esp), %eax    movl    %eax, (%esp)    call    fac    movl    %eax, 24(%esp)  # 返回值存入 ans    movl    $.LC0, %eax    movl    24(%esp), %edx    movl    %edx, 8(%esp)    movl    28(%esp), %edx    movl    %edx, 4(%esp)    movl    %eax, (%esp)    call    printf    movl    $0, %eax    leave    ret 　　main 函数创建了一帧： 从 esp 到 ebp + 4 上边是本次调用的返回地址、旧的 ebp 指针 然后是 main 的局部变量 n、ans 最下边是参数的空间，右上图显示的是 main 中调用 printf 前的栈的使用情况 　　进入 main 函数，前 4 条指令开辟了这片空间，在退出 main 函数之前的 leave ret 回收了这片空间（C++ 在回收这片空间之前要析构此函数中的所有局部对象）。在 main 函数执行期间 ebp 一直指向 帧顶 - 4 的位置， ebp 被称为帧指针也就是这个原因。 调用惯例 　　调用函数的时候，先传参数，然后 call，具体这个过程怎么实现有相关规定，这样的规定被称为调用惯例， C语言中有多种调用惯例，它们的不同之处在于： 参数是压栈还是存入寄存器 参数压栈的次序（从右至左 | 从左至右） 调用完成后是调用者还是被调用者来恢复栈 　　各种调用惯例《程序员的自我修养》——链接、装载与库 这本书中有简要介绍，我照抄后在本文后面列出。C语言默认的调用惯例是 cdecl： 参数从右至左压栈 调用完成后调用者负责恢复栈 　　可以从 printf(\"%d! = %d\\n\", n, ans); 的调用过程中看出。 　　虽然 VC、gcc 都默认使用 cdecl 调用惯例，但它们的实现却各有风格： VC 一般是从右至左 push 参数，call，add esp, XXX 而 gcc 在给局部变量分配空间的时候也给参数分配了足够的空间，所以只要从右至左 mov 参数, XXX(%esp)，call 就可以了，调用者根本不用去恢复栈，因为传参数的时候并没有修改栈指针 esp。 fac 帧 　　说完调用惯例我们接着来看第一次调用 fac： fac:    pushl   %ebp    movl    %esp, %ebp    subl    $24, %esp    cmpl    $1, 8(%ebp)    jg  .L2         # n > 1 就跳到 .L2    movl    $1, %eax    jmp .L3         # 无条件跳到 .L3.L2:    movl    8(%ebp), %eax    subl    $1, %eax    movl    %eax, (%esp)    call    fac     #  fac(n-1)    imull   8(%ebp), %eax   # eax = n * eax.L3:    leave    ret 　　fac(3) 开辟了第一个 fac 帧： 从 esp 到 ebp + 4（fac 还能\"越界\"地读到参数 n） 上边是 返回地址、旧的 ebp 指针（指向 main 帧） fac 没有局部变量，又浪费了很多字节 参数占了最下边的 4 字节（需要递归时使用） 　　这时还不满足递归终止条件，于是fac(3)又递归地调用了fac(2)， fac(2)又递归的调用了fac(1)，到这个时候栈变成了如下情况： 　　上图的箭头的含义很明显： 从 ebp 可回溯到所有的函数帧，这是由于每个函数开头都来两条 pushl %ebp、movl %esp, %ebp造成的。 　　参数总是调用者写入，被调用者来读取（被调用者修改参数毫无意义），这是一种默契^_^。 程序继续运行： fac(1) 满足了递归终止条件，fac(1) 返回 1，fac(1)#3 帧消亡 继续执行 fac(2)，fac(2) 返回 1*2，fac(2)#2 帧消亡 继续执行 fac(3)，fac(3) 返回 2*3，fac(1)#1 帧消亡 继续执行 main，printf 结果，返回 0，main 帧消亡 继续执行 ？？？（且听下回分解） 最终程序结束（进程僵死，一会儿后操作系统会来收尸（回收内存及其他资源））。 小结 　　函数帧保存的是函数的一个完整的局部环境，保证了函数调用的正确返回（函数帧中有返回地址）、返回后继续正确地执行，因此函数帧是 C语言 能调来调去的保障。 主要的调用惯例 调用惯例 出栈方 参数传递 名字修饰 cdecl 函数调用方 从右至左的顺序压参数入栈 下划线+函数名 stdcall 函数本身 从右至左的顺序压参数入栈 下划线+函数名+@+参数的字节数， 如函数 int func(int a, double b)的修饰名是 _func@12 fastcall 函数本身 头两个 DWORD(4字节)类型或者更少字节的参数 被放入寄存器，其他剩下的参数按从右至左的顺序入栈 @+函数名+@+参数的字节数 pascal 函数本身 从左至右的顺序入栈 较为复杂，参见pascal文档  ","title":"函数帧"},{"content":"怎么去提高与学习linux学习，不可否认练习是一个比较好，也比较有效果的一个方法，但有很多人在练习操作时，很多题都会带来困扰，下面我就把一些简单的操作实例分享给大家，大家一起来学习linux： Linux课后习题，linux练习题,linux进步练习题,linux操作练习题 一、命令部分 1.新建一个用户yangang，密码设为123456,并将其加到root组。写出所用命令。  # useradd yangang  # passwd yangang  123456  123456  # groupadd root  # usermod –g root yangang 2.将当前计算机的IP地址设为192.168.1.1,子网掩码为255.255.255.0。写出所用命令。  # ifconfig eth0 192.168.1.1 netmask  255.255.255.0 3.你是公司的Linux服务的管理员。你使用vi编缉/etc/inittab文件时，在命令模式下查询shutdown字符串，使用的命令。 vi /etc/initab /shutdown 4.显示当前系统的日期和时间命令。  # date  –d  –y 5.查看命令sort的帮助文件，写出所用命令。  # man  sort 6.统计/etc/passwd文件的字节数和行数，写出所用命令。  # wc –cl  /etc/passwd 7.分屏显示/etc/httpd/conf/httpd.conf文件的命令。  # less  /etc/httpd/conf/httpd.conf 按“Q”退出该命令 8.将hello！写入 /home/yangang/test.txt的命令（vi及vim编辑器除外）。  # echo ‘hello!’> /home/yangang/test.txt 9.让named守护进程运行在级别3，5的命令。 # telinit 3 # telinit 5 10.更改用户yangang的登录shell为/sbin/nologin的命令。  # usermod –s /sbin/nologin  yangang 11.查看当前linux服务器的主机名的命令。 # cat /proc/sys/kernel/hostname 或   # sysctl kernel.hostname 或   # hostname 12.查看当前主机的路由的命令。   # route 13.配置当前主机的默认网关为192.168.2.254的命令。   # route add default gw 192.168.2.254 14.连续ping目的IP为192.168.2.245为3次的的命令。   # ping –C  3 192.168.2.245 15.查看当前主机TCP协议连接情况的命令。   # netstat -t 16.打包并压缩/etc目录的命令。     # tar –zcvf yangang_etc.tar.gz /etc/ 或  # tar -jcvf yangang_etc.tar.bz2 /etc/ 17.测试httpd是否安装的命令。   # rpm  -q  httpd 18.卸载named软件包的命令。   # rpm –e named  19.查看月历并将内容追加到文件/dd中的命令。 cal –j >>/dd 20.查看当前目录的命令。 Pwd或ls 21.显示历史命令表的所有内容的命令。 history 22.将/etc/passwd的内容追加到文件aaa中的命令。 cat /etc/passwd >>/aaa 23.查看/etc/passwd文件的前10行的命令。 head -10 /etc/passwd 24.查看/etc/vsftpd/vsftpd.conf的后10行的命令。 tail -10 /etc/vsftpd/vsftpd.conf 25.重启samba服务的命令。 service smb restart 26.查看进程状态的命令。 ps -aux 或top 27.列出后台作业的命令。 jobs -l 28.将作业ID为3的后台作业放到前台的命令。 fg 3 29.停止ssh服务的命令。 service sshd stop 30.将name=wxstc配置为全局变量的命令。 export name=wxstc 31.重启linux服务器的命令。 shutdown -r now 32.要给文件ylinuxs加上其他人可执行属性的命令。 chmod o+x ylinuxs 33.为了达到使文件sudent.txt的所有者有读(r)和写(w)的许可，而其他用户只能进行只读访问的命令。 chmod u=rw,o=r student.txt 34.把大写字母转换为小写字母的命令。 tr  'A-Z' 'a-z' 35.显示操作系统核心版本详细信息的命令。 uname -a 36.将新建文件权限设置为600的命令。 umask 600 filename 37.从IP地址查找域名或从域名来查找IP地址应使用什么命令。 host 38.如何查看用户yangang属于哪个组。 cat /etc/group 39.假如当前系统是在 level 3 运行，不重启系统就可转换到 level 5 运行的命令。 telinit 5 40.查看Linux的启动信息的命令。 dmesg 41.创建一个以自己姓的拼音缩写为名的用户。 useradd yangang1 42.进入用户主目录，显示当前的路径。 cd /home/yangang1 pwd 43.复制文件/etc/group到用户主目录，文件名不变。 cp /etc/group /home/yangang1 44.统计文件/etc/fstab的行数、单词数、字符数。 wc –lwc /etc/fstab 45.查看/etc/passwd文件的后5行。 tail -5 /etc/passwd 46.创建普通文件/home/abc。 touch /home/abc 47.修改/home/abc的属性为：属主具有一切权限，同组用户和其他用户具有可读可写的权限。 chmod u=rwx,go=rw /home/abc 48. 显示当前的时间。 date 49. 写出系统1分钟后关机的命令。 shutdown –s –t 60 50. 启动ssh服务器。 service sshd start 51.新建一个以你的学号为账号的用户。 useradd 282325600 52.复制文件/etc/passwd到用户主目录，文件名不变。 cp /etc/group /home/ 53.进入用户主目录，显示当前的路径。 cd /home |pwd 54.统计文件/etc/passwd的行数。 wc -l /etc/passwd 55.查看/etc/passwd的前8行。 head -8 /etc/passwd 56.显示2011年12月的日历。 cal 12 2011 57.建立文件/etc/group的符号链接文件/root/abc。 ln –s /etc/group /root/abc 58.后台启动程序gedit。 Gedit & 59.配置网卡eth0的IP地址为192.168.0.1，子网掩码为255.255.255.0 ifconfig eth0:192.168.0.1 netmask 255.255.255.0 60.查看dns服务器的状态。 pstree |grep named 61.创建一个以自己的姓的拼音命名的用户。 useradd yangang1 62.添加一个用户组，名称为zugang。 groupadd zugang 63.修改新建的用户属于zugang组。 usermod –g zugang yangang1 64.复制文件/etc/passwd到用户主目录，文件名称不变。 cp /etc/passwd /home/yangang1 65.修改该文件的属性为：属主具有一切权限，同组用户和其他用户具有可读权限。 Cd /home/yangang1 chmod u=wrx,go=r passwd 66.显示当前系统时间。 date 67.写出30分钟后系统重启的命令。 shutdown –s –t 1800 68.显示历史命令表的所有内容。 history 69.显示Linux系统运行所有进程。 ps –a或者可能是ps –ef；-e 显示所有进程、-f 全格式、a 显示终端上的所有进程，包括其他用户的进程 70.重新启动ssh服务器。 service sshd restart 71.创建一个以自己的名的拼音命名的用户。 useradd chengwen 72.添加一个用户组，名称为js。 groupadd js 73.修改新建的用户属于js组。 usermod –g js newuser 74.进入该用户主目录，显示当前的路径。 cd /home |pwd 75.复制文件/etc/fstab到此文件夹，文件名称不变。 Cp –r /etc/fstab/ 76.统计文件/etc/fstab的字符数。 wc –c /etc/fstab 77.设置当前时间设为15：00，显示当前系统时间。 date –s “15:00” date 78.写出系统5分钟后重启的命令。 shutdown -r +5 79.配置网卡eth0的IP地址为192.168.10.1，子网掩码为255.255.255.0 ifconfig eth0 192.168.10.1      netmask 255.255.255.0 80.查看DHCP服务器的状态。 service dhcpd status 二、操作题 1. 某系统管理员需每天做一定的重复工作，请按照下列要求，编制一个解决方案： （1）在下午4 :50删除/abc目录下的全部子目录和全部文件； （2）从早8:00～下午6:00每小时读取/xyz目录下x1文件中每行第一个域的全部数据加入到/backup目录下的bak01.txt文件内。 (1) at 18:50 rm –rf /abc/* (2)用vi创建编辑一个名为test的crontab文件； test文件的内容： 0 8-18/1 * * * cut -f1 /xyz/x1 >;>; /backup/bak01.txt 或(1)crontab -e 打开命令然后输入 50 16 * * * rm -rf /abc (2)0 8-18 * * * cut -f 1 >> /backup/bak01.txt 5.编写一个名为mul的脚本程序，参数为一个大于20的正整数。先检查参数是否符合要求。如果不符合要求，请给出提示；如果符合要求，分别输出其与1到10的乘积。 #gedit mul.sh #!/bin/bash if [ $1 -gt 20 ] then     n=1     m=1     while [ $n -le 10 ]     do  m=$(expr $1 \\* $n)  echo \"$n    $m\"  n=$(expr $n + 1)     done else     echo \"number is wrong\" fi #bash mul.sh 34 6.编写一个名为move的脚本程序，格式move  <ylinuxs>  <file2>。如果ylinuxs不存在，给出提示；否则移动ylinuxs至file2。 #gedit  move.sh #! /bin/bash if  test -f ylinuxs then mv ylinuxs  file2 else     echo \"ylinuxs is not exists\" fi # bash  move.sh  ylinuxs  file2 7.编写一个shell脚本，能够显示下面序列的前25个数字。0,1,1,2,3,5,8,13…，前二个数字之和为第三个数字，即著名的Fibonacci序列。 #gedit shell.sh #!/bin/bash n=0 echo \"$n    \" m=1 echo \"$m    \" t=1 a=2 while [ $a -lt 25 ] do     t=$(expr $n + $m)     echo \"$t    \"     a=$(expr $a + 1)     n=$m     m=$t done # bash shell.sh 8.编写一个名为square的脚本程序，参数为一大于10的正整数。先检查参数是否符合要求。如果不符合要求，请给出提示；如果符合要求，输出从1到该正整数的平方值。 #gedit  square.sh #!/bin/bash if [ $1 -gt 10 ] then  n=1  m=1  while [ $n -le $1 ]  do   m=$(expr $n \\* $n )   echo \"$n    $m    \"   n=$(expr $n + 1)  done     else     echo \"number is wrong\" fi #bash square.sh  45 ","title":"liunx试题（对于初学者）"},{"content":"package Karl.Doenitz;import java.awt.*;import java.awt.event.*;import javax.swing.*;@SuppressWarnings(\"serial\")public class Tetris extends JFrame implements KeyListener {\tint pos[] = {0,1};\tboolean bottom = false;int n = 20;int m = 10;JButton b[][];Color tmp[][] = new Color[m][n];int rand = 0;int centralx = 0;int centraly = 0;int deltax = 0;int perim[][] = new int[m+4][n+4];or[][][] prof = new or[4][4][7];Color rnd[] = {Color.red, Color.yellow, Color.cyan, Color.green, Color.white, Color.blue, Color.orange};int rowsclrd = 0;public Tetris(){\tthis.setTitle(\"俄罗斯方块KarlDoenitz制作\");\tfor(int a = 0;a<4;a++){\t\tfor(int b = 0;b<4;b++){\t\t\tfor(int c = 0;c<7;c++){\t\t\t\tprof[a][b][c] = new or();\t\t\t}\t\t}\t}\tthis.setDefaultCloseOperation(EXIT_ON_CLOSE);\tprof[0][0][0].x = -1;\tprof[0][1][0].x = 0;\tprof[0][2][0].x = 0;\tprof[0][3][0].x = 1;\tprof[1][0][0].x = 0;\tprof[1][1][0].x = 0;\tprof[1][2][0].x = -1;\tprof[1][3][0].x = -1;\tprof[2][0][0].x = 1;\tprof[2][1][0].x = 0;\tprof[2][2][0].x = 0;\tprof[2][3][0].x = -1;\tprof[3][0][0].x = 0;\tprof[3][1][0].x = 0;\tprof[3][2][0].x = 1;\tprof[3][3][0].x = 1;\tprof[0][0][1].x = -1;\tprof[0][1][1].x = -1;\tprof[0][2][1].x = 0;\tprof[0][3][1].x = 1;\tprof[1][0][1].x = -1;\tprof[1][1][1].x = 0;\tprof[1][2][1].x = 0;\tprof[1][3][1].x = 0;\tprof[2][0][1].x = 1;\tprof[2][1][1].x = 1;\tprof[2][2][1].x = 0;\tprof[2][3][1].x = -1;\tprof[3][0][1].x = 1;\tprof[3][1][1].x = 0;\tprof[3][2][1].x = 0;\tprof[3][3][1].x = 0;\tprof[0][0][2].x = -1;\tprof[0][1][2].x = 0;\tprof[0][2][2].x = 1;\tprof[0][3][2].x = 1;\tprof[1][0][2].x = 0;\tprof[1][1][2].x = 0;\tprof[1][2][2].x = 0;\tprof[1][3][2].x = -1;\tprof[2][0][2].x = 1;\tprof[2][1][2].x = 0;\tprof[2][2][2].x = -1;\tprof[2][3][2].x = -1;\tprof[3][0][2].x = 0;\tprof[3][1][2].x = 0;\tprof[3][2][2].x = 0;\tprof[3][3][2].x = 1;\tprof[0][0][3].x = -1;\tprof[0][1][3].x = 0;\tprof[0][2][3].x = 0;\tprof[0][3][3].x = 1;\tprof[1][0][3].x = -1;\tprof[1][1][3].x = -1;\tprof[1][2][3].x = 0;\tprof[1][3][3].x = 0;\tprof[2][0][3].x = 1;\tprof[2][1][3].x = 0;\tprof[2][2][3].x = 0;\tprof[2][3][3].x = -1;\tprof[3][0][3].x = 1;\tprof[3][1][3].x = 1;\tprof[3][2][3].x = 0;\tprof[3][3][3].x = 0;\tprof[0][0][4].x = -1;\tprof[0][1][4].x = 0;\tprof[0][2][4].x = 0;\tprof[0][3][4].x = 1;\tprof[1][0][4].x = 0;\tprof[1][1][4].x = 0;\tprof[1][2][4].x = -1;\tprof[1][3][4].x = 0;\tprof[2][0][4].x = 1;\tprof[2][1][4].x = 0;\tprof[2][2][4].x = 0;\tprof[2][3][4].x = -1;\tprof[3][0][4].x = 0;\tprof[3][1][4].x = 0;\tprof[3][2][4].x = 1;\tprof[3][3][4].x = 0;\tprof[0][0][5].x = 0;\tprof[0][1][5].x = 0;\tprof[0][2][5].x = 1;\tprof[0][3][5].x = 1;\tprof[1][0][5].x = 0;\tprof[1][1][5].x = 0;\tprof[1][2][5].x = 1;\tprof[1][3][5].x = 1;\tprof[2][0][5].x = 0;\tprof[2][1][5].x = 0;\tprof[2][2][5].x = 1;\tprof[2][3][5].x = 1;\tprof[3][0][5].x = 0;\tprof[3][1][5].x = 0;\tprof[3][2][5].x = 1;\tprof[3][3][5].x = 1;\tprof[0][0][6].x = -1;\tprof[0][1][6].x = 0;\tprof[0][2][6].x = 1;\tprof[0][3][6].x = 2;\tprof[1][0][6].x = 0;\tprof[1][1][6].x = 0;\tprof[1][2][6].x = 0;\tprof[1][3][6].x = 0;\tprof[2][0][6].x = 1;\tprof[2][1][6].x = 0;\tprof[2][2][6].x = -1;\tprof[2][3][6].x = -2;\tprof[3][0][6].x = 0;\tprof[3][1][6].x = 0;\tprof[3][2][6].x = 0;\tprof[3][3][6].x = 0;\tprof[0][0][0].y = 0;\tprof[0][1][0].y = 0;\tprof[0][2][0].y = 1;\tprof[0][3][0].y = 1;\tprof[1][0][0].y = -1;\tprof[1][1][0].y = 0;\tprof[1][2][0].y = 0;\tprof[1][3][0].y = 1;\tprof[2][0][0].y = 0;\tprof[2][1][0].y = 0;\tprof[2][2][0].y = -1;\tprof[2][3][0].y = -1;\tprof[3][0][0].y = 1;\tprof[3][1][0].y = 0;\tprof[3][2][0].y = 0;\tprof[3][3][0].y = -1;\tprof[0][0][1].y = 0;\tprof[0][1][1].y = 1;\tprof[0][2][1].y = 0;\tprof[0][3][1].y = 0;\tprof[1][0][1].y = -1;\tprof[1][1][1].y = -1;\tprof[1][2][1].y = 0;\tprof[1][3][1].y = 1;\tprof[2][0][1].y = -1;\tprof[2][1][1].y = 0;\tprof[2][2][1].y = 0;\tprof[2][3][1].y = 0;\tprof[3][0][1].y = 1;\tprof[3][1][1].y = 1;\tprof[3][2][1].y = 0;\tprof[3][3][1].y = -1;\tprof[0][0][2].y = 0;\tprof[0][1][2].y = 0;\tprof[0][2][2].y = 0;\tprof[0][3][2].y = 1;\tprof[1][0][2].y = -1;\tprof[1][1][2].y = 0;\tprof[1][2][2].y = 1;\tprof[1][3][2].y = 1;\tprof[2][0][2].y = 0;\tprof[2][1][2].y = 0;\tprof[2][2][2].y = 0;\tprof[2][3][2].y = -1;\tprof[3][0][2].y = 1;\tprof[3][1][2].y = 0;\tprof[3][2][2].y = -1;\tprof[3][3][2].y = -1;\tprof[0][0][3].y = 1;\tprof[0][1][3].y = 1;\tprof[0][2][3].y = 0;\tprof[0][3][3].y = 0;\tprof[1][0][3].y = -1;\tprof[1][1][3].y = 0;\tprof[1][2][3].y = 0;\tprof[1][3][3].y = 1;\tprof[2][0][3].y = -1;\tprof[2][1][3].y = -1;\tprof[2][2][3].y = 0;\tprof[2][3][3].y = 0;\tprof[3][0][3].y = 1;\tprof[3][1][3].y = 0;\tprof[3][2][3].y = 0;\tprof[3][3][3].y = -1;\tprof[0][0][4].y = 0;\tprof[0][1][4].y = 0;\tprof[0][2][4].y = 1;\tprof[0][3][4].y = 0;\tprof[1][0][4].y = -1;\tprof[1][1][4].y = 0;\tprof[1][2][4].y = 0;\tprof[1][3][4].y = 1;\tprof[2][0][4].y = 0;\tprof[2][1][4].y = 0;\tprof[2][2][4].y = -1;\tprof[2][3][4].y = 0;\tprof[3][0][4].y = 1;\tprof[3][1][4].y = 0;\tprof[3][2][4].y = 0;\tprof[3][3][4].y = -1;\tprof[0][0][5].y = 0;\tprof[0][1][5].y = 1;\tprof[0][2][5].y = 0;\tprof[0][3][5].y = 1;\tprof[1][0][5].y = 0;\tprof[1][1][5].y = 1;\tprof[1][2][5].y = 0;\tprof[1][3][5].y = 1;\tprof[2][0][5].y = 0;\tprof[2][1][5].y = 1;\tprof[2][2][5].y = 0;\tprof[2][3][5].y = 1;\tprof[3][0][5].y = 0;\tprof[3][1][5].y = 1;\tprof[3][2][5].y = 0;\tprof[3][3][5].y = 1;\tprof[0][0][6].y = 0;\tprof[0][1][6].y = 0;\tprof[0][2][6].y = 0;\tprof[0][3][6].y = 0;\tprof[1][0][6].y = -1;\tprof[1][1][6].y = 0;\tprof[1][2][6].y = 1;\tprof[1][3][6].y = 2;\tprof[2][0][6].y = 0;\tprof[2][1][6].y = 0;\tprof[2][2][6].y = 0;\tprof[2][3][6].y = 0;\tprof[3][0][6].y = -1;\tprof[3][1][6].y = 0;\tprof[3][2][6].y = 1;\tprof[3][3][6].y = 2;\tfor (int y = 0;y<2;y++){\tfor (int x = 0;x<m+4;x++){\tperim[x][y]= 1;\t}}\tfor (int y = n+2;y<n+4;y++){\t\tfor (int x = 0;x<m+4;x++){\t\tperim[x][y]= 4;\t\t}}\tfor (int y = 2;y<n+2;y++){\t\tfor (int x = 0;x<2;x++){\t\tperim[x][y]= 2;\t\t}}\tfor (int y = 2;y<n+2;y++){\t\tfor (int x = m+2;x<m+4;x++){\t\tperim[x][y]= 2;\t\t}}\tfor(int y = 0;y<n+4;y++){\t\tfor (int x = 0;x<m+4;x++){\t\t\tSystem.out.print(perim[x][y]);\t\t}\t\tSystem.out.println(\"\");\t}            b = new JButton [m][n];            setLayout(new GridLayout(n,m));//Grid layouts x and y are SWAPPED!            for (int y = 0;y<n;y++){                for (int x = 0;x<m;x++){                        b[x][y] = new JButton(\" \");                        tmp[x][y] = Color.DARK_GRAY;                        b[x][y].setBackground(Color.DARK_GRAY);                        add(b[x][y]);                        b[x][y].setEnabled(true);                }//end inner for        }            setFocusable(true);            addKeyListener(this);            pack();            setVisible(true);            blockgen();                           }//end constructor Mine()\tclass or {\t\tint x;\t\tint y;\t}\tpublic void blockgen(){\t\tComponent temporaryLostComponent = null;\t\tpos[0] = 0;\t\tpos[1] = 1;\t\trand = (int) (Math.floor(Math.random()*7+1));      \tcentralx = 4;        centraly = 0;         System.out.print(rand);\t\tif ((b[4+prof[pos[0]][0][rand-1].x][prof[pos[0]][0][rand-1].y].getBackground() == Color.DARK_GRAY) && \t\t(b[4+prof[pos[0]][1][rand-1].x][prof[pos[0]][1][rand-1].y].getBackground() == Color.DARK_GRAY) && \t\t(b[4+prof[pos[0]][2][rand-1].x][prof[pos[0]][2][rand-1].y].getBackground() == Color.DARK_GRAY) && \t\t(b[4+prof[pos[0]][3][rand-1].x][prof[pos[0]][3][rand-1].y].getBackground() == Color.DARK_GRAY)){ \t\tb[4+prof[pos[0]][0][rand-1].x][prof[pos[0]][0][rand-1].y].setBackground(rnd[rand-1]); \t\tb[4+prof[pos[0]][1][rand-1].x][prof[pos[0]][1][rand-1].y].setBackground(rnd[rand-1]); \t\tb[4+prof[pos[0]][2][rand-1].x][prof[pos[0]][2][rand-1].y].setBackground(rnd[rand-1]); \t\tb[4+prof[pos[0]][3][rand-1].x][prof[pos[0]][3][rand-1].y].setBackground(rnd[rand-1]);      \tgo();\t\t} else {\t\t\tJOptionPane.showMessageDialog(temporaryLostComponent, \"游戏结束！ 你一共得了\"+rowsclrd+\" 分，干得好，继续努力！\");            System.exit(0);\t\t}\t}\t\tpublic void rotate(){\t\tif (pos[0] < 3){\t\t\tpos[1] = pos[0];\t\tpos[0]++;\t\t} else if (pos[0] == 3){\t\t\tpos[0] = 0;\t\t\tpos[1] = 3;\t\t} else {\t\t\tSystem.out.println(\"error\");\t\t}\t\tif ((perim[2+centralx+prof[pos[0]][0][rand-1].x][centraly+prof[pos[0]][0][rand-1].y+2] != 4) && (perim[2+centralx+prof[pos[0]][0][rand-1].x][centraly+prof[pos[0]][0][rand-1].y+2] != 1) && (perim[2+centralx+prof[pos[0]][0][rand-1].x][centraly+prof[pos[0]][0][rand-1].y+2] != 2) && (perim[2+centralx+prof[pos[0]][0][rand-1].x][centraly+prof[pos[0]][0][rand-1].y+2] != 3)\t    \t\t && (perim[centralx+2+prof[pos[0]][1][rand-1].x][centraly+prof[pos[0]][1][rand-1].y+2] != 4) && (perim[centralx+2+prof[pos[0]][1][rand-1].x][centraly+prof[pos[0]][1][rand-1].y+2] != 1) && (perim[centralx+2+prof[pos[0]][1][rand-1].x][centraly+prof[pos[0]][1][rand-1].y+2] != 2) && (perim[centralx+2+prof[pos[0]][1][rand-1].x][centraly+prof[pos[0]][1][rand-1].y+2] != 3)\t    \t\t && (perim[centralx+2+prof[pos[0]][2][rand-1].x][centraly+prof[pos[0]][2][rand-1].y+2] != 4) && (perim[centralx+2+prof[pos[0]][2][rand-1].x][centraly+prof[pos[0]][2][rand-1].y+2] != 1) && (perim[centralx+2+prof[pos[0]][2][rand-1].x][centraly+prof[pos[0]][2][rand-1].y+2] != 2) && (perim[centralx+2+prof[pos[0]][2][rand-1].x][centraly+prof[pos[0]][2][rand-1].y+2] != 3)\t    \t\t && (perim[centralx+prof[pos[0]][3][rand-1].x+2][centraly+prof[pos[0]][3][rand-1].y+2] != 4) && (perim[centralx+prof[pos[0]][3][rand-1].x+2][centraly+prof[pos[0]][3][rand-1].y+2] != 1) && (perim[centralx+prof[pos[0]][3][rand-1].x+2][centraly+prof[pos[0]][3][rand-1].y+2] != 2) && (perim[centralx+prof[pos[0]][3][rand-1].x+2][centraly+prof[pos[0]][3][rand-1].y+2] != 3)){        \t b[centralx+prof[pos[1]][0][rand-1].x][centraly+prof[pos[1]][0][rand-1].y].setBackground(Color.DARK_GRAY);\t    \t    b[centralx+prof[pos[1]][1][rand-1].x][centraly+prof[pos[1]][1][rand-1].y].setBackground(Color.DARK_GRAY);\t    \t    b[centralx+prof[pos[1]][2][rand-1].x][centraly+prof[pos[1]][2][rand-1].y].setBackground(Color.DARK_GRAY);\t    \t    b[centralx+prof[pos[1]][3][rand-1].x][centraly+prof[pos[1]][3][rand-1].y].setBackground(Color.DARK_GRAY);\t    \t    b[centralx+(prof[pos[0]][0][rand-1].x)][centraly+(prof[pos[0]][0][rand-1].y)].setBackground(rnd[rand-1]);\t    \t    b[centralx+(prof[pos[0]][1][rand-1].x)][centraly+(prof[pos[0]][1][rand-1].y)].setBackground(rnd[rand-1]);\t    \t    b[centralx+(prof[pos[0]][2][rand-1].x)][centraly+(prof[pos[0]][2][rand-1].y)].setBackground(rnd[rand-1]);\t    \t    b[centralx+(prof[pos[0]][3][rand-1].x)][centraly+(prof[pos[0]][3][rand-1].y)].setBackground(rnd[rand-1]);\t\t} else {\t\t\tif (pos[1] > 0){\t\t\t\tpos[0] = pos[1];\t\t\t\tpos[1]--;\t\t\t} else if (pos[1] == 0){\t\t\t\tpos[0] = 0;\t\t\t\tpos[1] = 3;\t\t\t\t}\t\t\t}\t}\t\t\tpublic int getxs(){\t\t   int xs = 0;\t\t   int[] xf = {-1, -1, -1, -1};\t\t   for (int d = 0;d<4;d++){\t\t\t   if ((xf[0] != prof[pos[0]][d][rand-1].x) || (xf[1] != prof[pos[0]][d][rand-1].x) || (xf[2] != prof[pos[0]][d][rand-1].x) || (xf[3] != prof[pos[0]][d][rand-1].x)){\t\t\t\t   xf[d] = prof[pos[0]][d][rand-1].x;\t\t\t   }\t\t   }\t\t   for (int d = 0;d<4;d++){\t\t\t   if (xf[d] != -1){\t\t\t\t   xs++;\t\t\t   }\t\t   }\t\t   return xs;\t}\t\t   public void movedown(){\t   int[] m2 = {-1, -1, -1, -1};\t   int[] m1 = {-1, -1, -1, -1};\t   int[] zero = {-1, -1, -1, -1};\t   int[] one = {-1, -1, -1, -1};\t   int[] two = {-1, -1, -1, -1};\t   \tfor (int d = 0;d<4;d++){\t   \t\tif (prof[pos[0]][d][rand-1].x == -2){\t   \t\t\tm2[d] = d;\t   \t\t} else if (prof[pos[0]][d][rand-1].x == -1){\t   \t\t\tm1[d] = d;\t   \t\t} else if (prof[pos[0]][d][rand-1].x == 0){\t   \t\t\tzero[d] = d;\t   \t\t} else if (prof[pos[0]][d][rand-1].x == 1){\t   \t\t\tone[d] = d;\t   \t\t} else if (prof[pos[0]][d][rand-1].x == 2){\t   \t\t\ttwo[d] = d;\t   \t\t}\t   \t}\t   \tint tmpm2 = -5;\t   \tint tmpm1 = -5;\t   \tint tmpzero = -5;\t   \tint tmpone = -5;\t   \tint tmptwo = -5;\t   \tfor (int d = 0;d<4;d++){\t   \t\tif (m2[d] != -1){\t   \t\t\tif (tmpm2<prof[pos[0]][m2[d]][rand-1].y){\t   \t\t\ttmpm2 = prof[pos[0]][m2[d]][rand-1].y;\t   \t\t\t}\t   \t\t}\t   \t\tif (m1[d] != -1){\t   \t\t\tif (tmpm1<prof[pos[0]][m1[d]][rand-1].y){\t   \t\t\ttmpm1 = prof[pos[0]][m1[d]][rand-1].y;\t   \t\t}\t   \t\t}\t   \t\tif (zero[d] != -1){\t   \t\t\tif (tmpzero<prof[pos[0]][zero[d]][rand-1].y){\t   \t\t\ttmpzero = prof[pos[0]][zero[d]][rand-1].y;\t   \t\t}\t   \t\t}\t   \t\tif (one[d] != -1){\t   \t\t\tif (tmpone<prof[pos[0]][one[d]][rand-1].y){\t   \t\t\ttmpone = prof[pos[0]][one[d]][rand-1].y;\t   \t\t}\t   \t\t}\t   \t\tif (two[d] != -1){\t   \t\t\tif (tmptwo<prof[pos[0]][two[d]][rand-1].y){\t   \t\t\ttmptwo = prof[pos[0]][two[d]][rand-1].y;\t   \t\t}\t   \t\t}\t   \t}\t   \tint total = 0;\t   \tfor (int d = 0;d<4;d++){\t   \t\tif (prof[pos[0]][d][rand-1].x == -2){\t   \t\t\tif (perim[2+centralx+-2][2+centraly+tmpm2+1] != 4){ \t   \t\t\t\tif(b[centralx+-2][centraly+tmpm2+1].getBackground() == Color.DARK_GRAY){\t   \t\t\t\ttotal++;\t   \t\t\t}}\t   \t\t} else if (prof[pos[0]][d][rand-1].x == -1){\t   \t\t\tif (perim[2+centralx+-1][2+centraly+tmpm1+1] != 4){\t   \t\t\t\t\tif (b[centralx+-1][centraly+tmpm1+1].getBackground() == Color.DARK_GRAY){\t   \t\t\t\ttotal++;\t   \t\t\t}}\t   \t\t} else if (prof[pos[0]][d][rand-1].x == 0){\t   \t\t\tif (perim[2+centralx][2+centraly+tmpzero+1] != 4){\t   \t\t\t\t\tif (b[centralx][centraly+tmpzero+1].getBackground() == Color.DARK_GRAY){\t   \t\t\t\ttotal++;\t   \t\t\t}}\t   \t\t} else if (prof[pos[0]][d][rand-1].x == 1){\t   \t\t\tif (perim[2+centralx+1][2+centraly+tmpone+1] != 4){\t   \t\t\t\t\tif (b[centralx+1][centraly+tmpone+1].getBackground() == Color.DARK_GRAY){\t   \t\t\t\ttotal++;\t   \t\t\t}}\t   \t\t} else if (prof[pos[0]][d][rand-1].x == 2){\t   \t\t\tif (perim[2+centralx+2][2+centraly+tmptwo+1] != 4){\t   \t\t\t\tif (b[centralx+2][centraly+tmptwo+1].getBackground() == Color.DARK_GRAY){\t   \t\t\t\ttotal++;\t   \t\t\t}}\t   \t\t}\t   \t}\t    \t if (total == 4){\t    \t\t  b[centralx+prof[pos[0]][0][rand-1].x][centraly+prof[pos[0]][0][rand-1].y].setBackground(Color.DARK_GRAY);\t    \t    b[centralx+prof[pos[0]][1][rand-1].x][centraly+prof[pos[0]][1][rand-1].y].setBackground(Color.DARK_GRAY);\t    \t    b[centralx+prof[pos[0]][2][rand-1].x][centraly+prof[pos[0]][2][rand-1].y].setBackground(Color.DARK_GRAY);\t    \t    b[centralx+prof[pos[0]][3][rand-1].x][centraly+prof[pos[0]][3][rand-1].y].setBackground(Color.DARK_GRAY);\t         \tcentraly++;\t         \tb[centralx+prof[pos[0]][0][rand-1].x][centraly+prof[pos[0]][0][rand-1].y].setBackground(rnd[rand-1]);\t    \t    b[centralx+prof[pos[0]][1][rand-1].x][centraly+prof[pos[0]][1][rand-1].y].setBackground(rnd[rand-1]);\t    \t    b[centralx+prof[pos[0]][2][rand-1].x][centraly+prof[pos[0]][2][rand-1].y].setBackground(rnd[rand-1]);\t    \t    b[centralx+prof[pos[0]][3][rand-1].x][centraly+prof[pos[0]][3][rand-1].y].setBackground(rnd[rand-1]);\t    \t  } else {\t    \tbottom = true;\t        \t }\t         }\t         public void go(){\t   do{\t   try {\t\tThread.sleep(1000L);\t} catch (InterruptedException e) {\t\t// TODO Auto-generated catch block\t\te.printStackTrace();\t}\t   movedown();\t   rowcheck();   }   while(bottom == false);\t   bottom = false;\t   blockgen();\t   }      public void rowcheck(){\t   int row = 0;\t   for (int y = 0;y<20;y++){\t\t   for (int x = 0;x<10;x++){\t\t\t   if (b[x][y].getBackground() != Color.DARK_GRAY){\t\t\t\t   row++;\t\t\t   }\t\t\t   if (row == 10){\t\t\t\t   rowsclrd++;\t\t\t\t   rowclear(y);\t\t\t\t   \t\t\t   }\t\t   }\t\t   row = 0;\t   }   }      public void rowclear(int y){\t   int inc = 0;\t   for (int x = 0;x<10;x++){\t\t   b[x][y].setBackground(Color.DARK_GRAY);\t   }\t   for (int c = y-1;c>-1;c--){       for (int x = 0;x<10;x++){\t   tmp[x][y-inc] = b[x][c].getBackground();       }inc++;}\t   for (int c = y;c>-1;c--){\t\t   for (int x = 0;x<10;x++){\t\t\t   b[x][c].setBackground(tmp[x][c]);\t\t   }\t   }   }      public void movelr(){    \t\t  \t   int[] m2 = {-1, -1, -1, -1};\t   int[] m1 = {-1, -1, -1, -1};\t   int[] zero = {-1, -1, -1, -1};\t   int[] one = {-1, -1, -1, -1};\t   int[] two = {-1, -1, -1, -1};\t   \tfor (int d = 0;d<4;d++){\t   \t\tif (prof[pos[0]][d][rand-1].y == -2){\t   \t\t\tm2[d] = d;\t   \t\t} else if (prof[pos[0]][d][rand-1].y == -1){\t   \t\t\tm1[d] = d;\t   \t\t} else if (prof[pos[0]][d][rand-1].y == 0){\t   \t\t\tzero[d] = d;\t   \t\t} else if (prof[pos[0]][d][rand-1].y == 1){\t   \t\t\tone[d] = d;\t   \t\t} else if (prof[pos[0]][d][rand-1].y == 2){\t   \t\t\ttwo[d] = d;\t   \t\t}\t   \t}\t   \t\tint tmpm2 = -5;\t\t   \tint tmpm1 = -5;\t\t   \tint tmpzero = -5;\t\t   \tint tmpone = -5;\t\t   \tint tmptwo = -5;\t   \tif (deltax == 1){\t   \tfor (int d = 0;d<4;d++){\t   \t\tif (m2[d] != -1){\t   \t\t\tif (tmpm2<prof[pos[0]][m2[d]][rand-1].x){\t   \t\t\ttmpm2 = prof[pos[0]][m2[d]][rand-1].x;\t   \t\t\t}\t   \t\t}\t   \t\tif (m1[d] != -1){\t   \t\t\tif (tmpm1<prof[pos[0]][m1[d]][rand-1].x){\t   \t\t\ttmpm1 = prof[pos[0]][m1[d]][rand-1].x;\t   \t\t}\t   \t\t}\t   \t\tif (zero[d] != -1){\t   \t\t\tif (tmpzero<prof[pos[0]][zero[d]][rand-1].x){\t   \t\t\ttmpzero = prof[pos[0]][zero[d]][rand-1].x;\t   \t\t}\t   \t\t}\t   \t\tif (one[d] != -1){\t   \t\t\tif (tmpone<prof[pos[0]][one[d]][rand-1].x){\t   \t\t\ttmpone = prof[pos[0]][one[d]][rand-1].x;\t   \t\t}\t   \t\t}\t   \t\tif (two[d] != -1){\t   \t\t\tif (tmptwo<prof[pos[0]][two[d]][rand-1].x){\t   \t\t\ttmptwo = prof[pos[0]][two[d]][rand-1].x;\t   \t\t}\t   \t\t}\t   \t}\t   \t} else if (deltax == -1){\t   \t\ttmpm2 = 5;\t\t   \ttmpm1 = 5;\t\t   \ttmpzero = 5;\t\t   \ttmpone = 5;\t\t   \ttmptwo = 5;\t   \t\tfor (int d = 0;d<4;d++){\t\t   \t\tif (m2[d] != -1){\t\t   \t\t\tif (tmpm2>prof[pos[0]][m2[d]][rand-1].x){\t\t   \t\t\ttmpm2 = prof[pos[0]][m2[d]][rand-1].x;\t\t   \t\t\t}\t\t   \t\t}\t\t   \t\tif (m1[d] != -1){\t\t   \t\t\tif (tmpm1>prof[pos[0]][m1[d]][rand-1].x){\t\t   \t\t\ttmpm1 = prof[pos[0]][m1[d]][rand-1].x;\t\t   \t\t}\t\t   \t\t}\t\t   \t\tif (zero[d] != -1){\t\t   \t\t\tif (tmpzero>prof[pos[0]][zero[d]][rand-1].x){\t\t   \t\t\ttmpzero = prof[pos[0]][zero[d]][rand-1].x;\t\t   \t\t}\t\t   \t\t}\t\t   \t\tif (one[d] != -1){\t\t   \t\t\tif (tmpone>prof[pos[0]][one[d]][rand-1].x){\t\t   \t\t\ttmpone = prof[pos[0]][one[d]][rand-1].x;\t\t   \t\t}\t\t   \t\t}\t\t   \t\tif (two[d] != -1){\t\t   \t\t\tif (tmptwo>prof[pos[0]][two[d]][rand-1].x){\t\t   \t\t\ttmptwo = prof[pos[0]][two[d]][rand-1].x;\t\t   \t\t}\t\t   \t\t}\t\t   \t}\t   \t}\t   \tint total = 0;\t   \tfor (int d = 0;d<4;d++){\t   \t\tif (prof[pos[0]][d][rand-1].y == -2){\t   \t\t\tif (perim[2+centralx+deltax+tmpm2][2+centraly-2] != 2){ \t   \t\t\t\tif(b[centralx+deltax+tmpm2][centraly-2].getBackground() == Color.DARK_GRAY){\t   \t\t\t\ttotal++;\t   \t\t\t}}\t   \t\t} else if (prof[pos[0]][d][rand-1].y == -1){\t   \t\t\tif (perim[2+centralx+deltax+tmpm1][2+centraly-1] != 2){\t   \t\t\t\t\tif (b[centralx+deltax+tmpm1][centraly-1].getBackground() == Color.DARK_GRAY){\t   \t\t\t\ttotal++;\t   \t\t\t}}\t   \t\t} else if (prof[pos[0]][d][rand-1].y == 0){\t   \t\t\tif (perim[2+centralx+deltax+tmpzero][2+centraly] != 2){\t   \t\t\t\t\tif (b[centralx+deltax+tmpzero][centraly].getBackground() == Color.DARK_GRAY){\t   \t\t\t\ttotal++;\t   \t\t\t}}\t   \t\t} else if (prof[pos[0]][d][rand-1].y == 1){\t   \t\t\tif (perim[2+centralx+deltax+tmpone][2+centraly+1] != 2){\t   \t\t\t\t\tif (b[centralx+deltax+tmpone][centraly+1].getBackground() == Color.DARK_GRAY){\t   \t\t\t\ttotal++;\t   \t\t\t}}\t   \t\t} else if (prof[pos[0]][d][rand-1].y == 2){\t   \t\t\tif (perim[2+centralx+deltax+tmptwo][2+centraly+2] != 2){\t   \t\t\t\tif (b[centralx+deltax+tmptwo][centraly+2].getBackground() == Color.DARK_GRAY){\t   \t\t\t\ttotal++;\t   \t\t\t}}\t   \t\t}\t   \t} if (total == 4){\t   \t\t\t\tb[centralx+prof[pos[0]][0][rand-1].x][centraly+prof[pos[0]][0][rand-1].y].setBackground(Color.DARK_GRAY);\t   \t\t\t\tb[centralx+prof[pos[0]][1][rand-1].x][centraly+prof[pos[0]][1][rand-1].y].setBackground(Color.DARK_GRAY);\t  \t    \t    b[centralx+prof[pos[0]][2][rand-1].x][centraly+prof[pos[0]][2][rand-1].y].setBackground(Color.DARK_GRAY);\t  \t    \t    b[centralx+prof[pos[0]][3][rand-1].x][centraly+prof[pos[0]][3][rand-1].y].setBackground(Color.DARK_GRAY);\t  \t         \tcentralx = centralx+deltax;\t  \t         \tb[centralx+prof[pos[0]][0][rand-1].x][centraly+prof[pos[0]][0][rand-1].y].setBackground(rnd[rand-1]);\t  \t    \t    b[centralx+prof[pos[0]][1][rand-1].x][centraly+prof[pos[0]][1][rand-1].y].setBackground(rnd[rand-1]);\t  \t    \t    b[centralx+prof[pos[0]][2][rand-1].x][centraly+prof[pos[0]][2][rand-1].y].setBackground(rnd[rand-1]);\t  \t    \t    b[centralx+prof[pos[0]][3][rand-1].x][centraly+prof[pos[0]][3][rand-1].y].setBackground(rnd[rand-1]);\t   \t}\t    \t\t  \t    \t     }public static void main (String[] args){\tnew Tetris();}@Overridepublic void keyPressed(KeyEvent e) {\tif (e.getKeyCode() == KeyEvent.VK_RIGHT){\t\tdeltax = 1;\t\tmovelr();\t\t}\tif (e.getKeyCode() == KeyEvent.VK_LEFT){\t\tdeltax = -1;\t\tmovelr();\t\t}\tif (e.getKeyCode() == KeyEvent.VK_UP){\t\trotate();\t\t}\tif (e.getKeyCode() == KeyEvent.VK_DOWN){\t\tmovedown();\t\t}}@Overridepublic void keyReleased(KeyEvent e) {\t// TODO Auto-generated method stub\t}@Overridepublic void keyTyped(KeyEvent e) {\t// TODO Auto-generated method stub\t}}","title":"俄罗斯方块——Java版"},{"content":"学了一个学期的汇编了，该复习复习了。大后天就要开始开微机原理了。先那把些上机做过的题再拿出来写写～ 在DOS窗口上面输出“Hello world” 程序如下：  DATA   SEGMENT   ;定义数据段 STRING   DB   ‘Hello World’， $; 定义一个字符串，记得要以$为结束标志DATA    ENDS         ;数据段结束STACK  SEGMENT PARA  STACK   ;堆栈段定义开始     DW   20H    DUP     (0)  ;为堆栈段分配空间STACK  ENDSCODES  SEGMENT    ;代码段定义开始ASSUME  CS:CODES.DS:DATAS  ;通知汇编程序，源程序中定义的组由对应的段寄存器进行段的寻址START           MOV     AX , DATAS ；实现段地址DATAS加载到DS           MOV   DS ,  AX          LEA     DX,  STRING  ：取STRING的偏移地址到DX中         MOV    AH , 09H          ；调用9号功能调用输出字符串         INT   21H         MOV AH   4CH            ;实现返回MOS-DOS窗口         INT 21H CODES  ENDS    ；代码段结束    END  START     ；整个程序结束","title":"汇编程序输出“Hello world”"},{"content":"void test_mt19937(){\t// 以时间为种子创建一个随机数发生器\tboost::mt19937 rng(time(0));\tfor (int i = 0; i < 100; ++i)\t{\t\tstd::cout << rng() << std::endl;\t}}void test_rand48(){\tboost::rand48 rng;\tfor (int i = 0; i < 10; ++i)\t{\t\tstd::cout << rng() * 1.0 / std::numeric_limits<boost::rand48::result_type>::max() << std::endl;\t}}// uniform_smallint：在小整数域内的均匀分布// uniform_int：在整数域上的均匀分布// uniform_01：在区间[0,1]上的实数连续均匀分布// uniform_real：在区间[min,max]上的实数连续均匀分布// bernoulli_distribution：伯努利分布// binomial_distribution：二项分布// cauchy_distribution：柯西（洛伦兹）分布// gamma_distribution：伽马分布// poisson_distribution：泊松分布// geometric_distribution：几何分布// triangle_distribution：三角分布// exponential_distribution：指数分布// normal_distribution：正态分布// lognormal_distribution：对数正态分布// uniform_on_sphere：球面均匀分布void test_random_distribute(){\tboost::mt19937 rng(time(0));\t\t// 1. uniform_int\tboost::uniform_int<> ui(0, 255);\tfor (int i = 0; i < 10; ++i)\t{ \t\tstd::cout<< ui(rng) << std::endl;\t}\t// 2. uniform_01\tboost::uniform_01<boost::mt19937&> u01(rng);\tfor (int i = 0; i < 10; ++i)\t{ \t\tstd::cout<< u01() << std::endl;\t}}","title":"【Boost】boost库的随机数的例子"},{"content":" 0.序 1）本文是我为了充分理解Nginx的信号处理方面的内容，我阅读了APUE chap10 信号的内容。 2）主要学习了以下章节， 详细学习了以下这几个章节 10.3signal函数 10.4 不可靠信号 10.5 中断系统调用 10.6 可重入函数 10.8 可靠信号术语与语义 10.11 信号集 10.12 sigpromask函数    10.13 sigpending函数 10.14 sigaction函数 10.16 sigsuspend函数 3）最后通过一个程序来详细说明了这几点。 简要一点说明这部分的学习方法：如果能够将本文的10.16处的程序弄清楚，也就明白了信号的处理机制。当然为了能够读懂该程序，你必须明白以下几点：      1）信号是异步的        2）信号集中包括要阻塞的信号，通过sigprocmask设置到信号屏蔽字中。      3)  当信号到来时，我们不立即向进程递送该信号，而是阻塞住。      4）当信号被解除阻塞时，之前被阻塞住的信号才会被递送到进程中，被信号处理函数处理并返回到进程中或者终止进程。 4）既然学习信号机制是为了学习Nginx的信号处理方面的内容，当然不能少了Nginx中代码。详见文章0：Nginx中与信号有关的内容 10.1 引言 10.2 信号概念      1）每个信号都有一个名字 ，每个名字都以三个字符SIG开头      2）不存在编号为0的信号，kill函数对信号编号0有特殊的应用      3）产生信号的条件                 4）信号是异步事件的经典实例。产生信号的事件对进程而言是随机出现的。举例说明：去银行办理业务，普通青年排成一列等待办理业务，每隔几分钟瞅瞅前面的人是否办理完毕；文艺青年则去前台取票，等待机器到了的时候喊你去办理业务；2B青年直接打道回府，不办理了。对于信号而言，就是文艺青年；告诉进程在此信号到来时，去执行某些操作。不然的话，就只能是普通青年的做法，进程会简单的去测试一个变量（例如errno）来判别是否出现了一个信号。      当信号到来时，内核会去执行哪些操作呢？我们将之称为信号的处理或者与信号相关的动作。      （1）忽略此信号。大多数信号可以使用这种方式进行处理。但有两种信号却决不能忽略。两种信号是SIGKILL和SIGSTOP。      （2）执行系统默认操作：表10.1给出了信号的默认操作。      （3）捕捉信号：通知内核在某种信号发生时调用一个用户函数。 10.3 signal 函数 // man signal NAME        signal - ANSI C signal handling SYNOPSIS        #include <signal.h>        typedef void (*sighandler_t)(int);        sighandler_t signal(int signum, sighandler_t handler);  The  behavior of signal() varies across Unix versions, and has also varied historically across different versions of Linux.  Avoid its use: use sigaction(2) instead. 参数：signum：表示表10.1中信号名          handler：常量SIG_IGN、常量SIG_DFL或当接到此信号后要调用的函数的地址。                         SIG_IGN:内核忽略此信号。                         SIG_DFL：内核采用默认操作。                         要调用的函数地址：当信号发生时，调用该函数，我们称这种处理为“捕捉”该信号。称此函数为信号处理函数（signal handler）或信号捕捉函数（signal catching function）。 注意：The signals SIGKILL and SIGSTOP cannot be caught or ignored. 返回值：signal() returns the previous value of the signal handler, or SIG_ERR on error. //example：filename signal1.c #include <unistd.h> #include <signal.h> #include <stdio.h> void sig_func(int signo) {    if(signo == SIGUSR1)        printf(\"received SIGUSR1\\n\");    else if (signo == SIGUSR2)        printf(\"received SIGUSR2\\n\");    else        printf(\"other signal\\n\"); } int main(void) {    printf(\"before signal\\n\");   if(  SIG_ERR ==( signal(SIGUSR1,sig_func) ))             printf(\"signal error\\n\"); for(;;)    sleep(5);    printf(\"after signal\");    return 0; } compile:$ gcc -Wall signal1.c  -o signal1 run:$./signal1 & reuslt :./signal1 & [2] 7559 root@hpnl-desktop:/home/hpnl/Downloads/test# before signal kill -USR1 7559 root@hpnl-desktop:/home/hpnl/Downloads/test# received SIGUSR1 kill 7559 注意： 1）当执行一个程序时，所有信号的状态都是系统默认或忽略。不改变信号的处理方式就不能确定信号的当前处理方式。我们可以使用sigaction函数确定一个信号的处理方式，而无需改变它。 2）当一个进程调用fork时，其子进程继承父进程的信号处理方式。这是因为子进程在开始时复制了父进程的存储映像，所以信号捕捉函数的地址在子进程中是有意义的。 10.4 不可靠信号      在早期的UNIX版本中信号是不可靠的。      不可靠的意思是：1)信号可能丢失 2）用户希望内核阻塞一个信号：不要忽略这个信号，而是在其发生时记住它，然后等进程准备好了再去执行。      阻塞信号的目的：不要忽略该信号，在其发生时记住它。然后在进程做好准备时再去执行它。 10.5 中断系统调用     1） 早期的UNIX系统的一个特性:如果一个进程在执行一个低速系统调用而被阻塞期间，内核捕捉到一个信号，则该系统调用被中断而不再继续执行。 该系统调用返回出错，其errno被设置为EINTR。 这样做的理由是：因为一个信号发生了，进程捕捉到了她，这意味着已经发生了某种事件，所以这是唤醒被阻塞的系统调用的好机会。      2）低速系统调用：是一类可能会使进程永远阻塞的一类系统调用。低速系统调用种类：详见APUEp244 10.5 中断的系统调用            3）如果想要唤醒被阻塞的系统调用，那么就需要检测errno的取值，然后再次调用低速系统调用 一段典型代码： again:     if((n = read(fd,buf,BUFFSEIZE)) < 0){           if(errno == EINTR)               goto again;     }      4）为了帮助应用程序使其不必处理被中断的系统调用，4.2BSD引入了某些被中断系统调用的自动重启动。      关于自动重启动有些疑惑，所谓的自动重启动，是不是不用像上面典型代码那般显式的去再次调用低速系统调用比如read，而是自动会再次调用低速系统调用。 10.6 可重入函数   很重要的一个概念：参考文章  可重入函数   可重入函数与不可重入函数  使用可重入函数进行更安全的信号处理  对于可重入、线程安全、异步信号安全几个概念的理解 可重入函数：1）当被多个线程调用时，不会引起任何共享的数据                     2）意味着这个函数可以被中断，其次意味着它除了使用自己栈上的变量以外，不依赖与任何环境（包括static），这样的函数就是purecode（纯代码）可重入。可以允许有该函数的多个副本在运行，由于他们使用的是分离的栈，所以不会相互干扰。      实际上，可重入函数很少，APUE 10.6节中描述了Single UNIX Specification说明的可重入的函数，只有115个；APUE 12.5节中描述了POSIX.1中不能保证线程安全的函数，只有89个。 不可重入函数：1）已知他们使用静态数据结构                          2）他们调用malloc和free。因为malloc通常会为所分配的存储区维护一个链接表，而插入执行信号处理函数的时候，进程可能正在修改此链接表。                          3）使用标准I/O函数，因为标准IO库的很多实现都使用了全局数据结构。 不可重入函数不能由超过一个任务所共享，除非能确保函数的互斥（或者使用信号量，或者在代码的关键部分禁用中断）      信号和不可重入函数 信号（signal） 是软件中断。它使得程序员可以处理异步事件。为了向进程发送一个信号， 内核在进程表条目的信号域中设置一个位，对应于收到的信号的类型。信号函数的 ANSI C 原型是： void (*signal (int sigNum, void (*sigHandler)(int))) (int); 或者，另一种描述形式： typedef void sigHandler(int);SigHandler *signal(int, sigHandler *); 当进程处理所捕获的信号时，正在执行的正常指令序列就会被信号处理器临时中断。然后进程继续执行， 但现在执行的是信号处理器中的指令。如果信号处理器返回，则进程继续执行信号被捕获时正在执行的 正常的指令序列。 现在，在信号处理器中您并不知道信号被捕获时进程正在执行什么内容。如果当进程正在使用 malloc 在它的堆上分配额外的内存时，您通过信号处理器调用 malloc，那会怎样？或者，调用了正在处理全局数据结构的某个函数，而 在信号处理器中又调用了同一个函数。如果是调用 malloc，则进程会 被严重破坏，因为 malloc 通常会为所有它所分配的区域维持一个链表，而它又 可能正在修改那个链表。 甚至可以在需要多个指令的 C 操作符开始和结束之间发送中断。在程序员看来，指令可能似乎是原子的 （也就是说，不能被分割为更小的操作），但它可能实际上需要不止一个处理器指令才能完成操作。 例如，看这段 C 代码： temp += 1; 在 x86 处理器上，那个语句可能会被编译为： mov ax,[temp]inc axmov [temp],ax 这显然不是一个原子操作。 这个例子展示了在修改某个变量的过程中运行信号处理器可能会发生什么事情： 清单 1. 在修改某个变量的同时运行信号处理器                                #include <signal.h>#include <stdio.h>struct two_int { int a, b; } data;void signal_handler(int signum){   printf (\"%d, %d\\n\", data.a, data.b);   alarm (1);}int main (void){ static struct two_int zeros = { 0, 0 }, ones = { 1, 1 }; signal (SIGALRM, signal_handler); data = zeros; alarm (1);while (1)  {data = zeros; data = ones;}} 这个程序向 data 填充 0，1，0，1，一直交替进行。同时，alarm 信号 处理器每一秒打印一次当前内容（在处理器中调用printf 是安全的，当信号发生时 它确实没有在处理器外部被调用）。您预期这个程序会有怎样的输出？它应该打印 0,0 或者 1,1。但是实际的输出 如下所示： 0, 01, 1(Skipping some output...)0, 11, 11, 01, 0... 在大部分机器上，在 data 中存储一个新值都需要若干个指令，每次存储一个字。 如果在这些指令期间发出信号，则处理器可能发现 data.a 为 0 而 data.b 为 1，或者反之。另一方面，如果我们运行代码的机器能够在一个 不可中断的指令中存储一个对象的值，那么处理器将永远打印 0,0 或 1,1。 使用信号的另一个新增的困难是，只通过运行测试用例不能够确保代码没有信号 bug。这一困难的原因在于 信号生成本质上异步的。 10.7 SIGCLD语义       10.8 可靠信号术语与语义           当有事件引发信号时，该事件产生一个信号。在产生了信号时，内核通常在进程表中设置一个某种形式的标识。当内核在进程表中设置一个某种形式的标识时，我们称向进程递送了一个信号。      在信号产生（generation）和递送（delivery）之间的时间间隔内，称信号是未决的（pending）。      原文中的解释如上所示：           一个进程可以阻塞一个信号的递送。对于进程，产生一个被阻塞的信号并且信号的处理方式是默认或者捕捉信号，那么信号就会保持未决状态，知道进程解除阻塞或者信号的处理方式变为忽略。 在递送之前，我们可以让进程改变信号的处理方式。sigpending函数可以用来判断哪个信号是被阻塞和未决的。            这儿通俗的解释就是：递送就是当信号产生后，进程接收到了信号。但有时候，在信号产生后我们并不会立马让进程接收到信号，因此阻塞该信号的递送。     信号屏蔽字（signal mask）：规定了当前要阻塞递送到该进程的信号集。稍后在10.11信号集中介绍 10.9 kill 和raise函数 10.10 alarm和pause函数 10.11 信号集            信号集（signal-set）：一个可以用来表示多个信号的数据类型。      POSIX.1定义了数据类型sigset_t以包含一个信号集，并且定义了下列五个处理信号集的函数       NAME        sigemptyset, sigfillset, sigaddset, sigdelset, sigismember - POSIX signal set operations. SYNOPSIS        #include <signal.h>        int sigemptyset(sigset_t *set);        int sigfillset(sigset_t *set);        int sigaddset(sigset_t *set, int signum);        int sigdelset(sigset_t *set, int signum);        int sigismember(const sigset_t *set, int signum); Feature Test Macro Requirements for glibc (see feature_test_macros(7)):        sigemptyset(), sigfillset(), sigaddset(), sigdelset(), sigismember(): _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _POSIX_SOURCE DESCRIPTION        These functions allow the manipulation of POSIX signal sets.        sigemptyset() initializes the signal set given by set to empty, with all signals excluded from the set.        sigfillset() initializes set to full, including all signals.        sigaddset() and sigdelset() add and delete respectively signal signum from set.        sigismember() tests whether signum is a member of set. Objects of type sigset_t must be initialized by a call to either sigemptyset() or sigfillset() before being passed to the functions sigaddset(), sigdelset()        and sigismember() or the additional glibc functions described below (sigisemptyset(), sigandset(), and sigorset()).  The results are undefined  if  this  is        not done. RETURN VALUE        sigemptyset(), sigfillset(), sigaddset(), and sigdelset() return 0 on success and -1 on error.        sigismember() returns 1 if signum is a member of set, 0 if signum is not a member, and -1 on error.            10.12 sigpromask函数       信号屏蔽字（signal mask）：规定了当前阻塞而不能递送给该进程的信号集。 调用函数sigpromask可以检测或更改器信号屏蔽字，或者在一个步骤中同时执行这两个操作。 NAME        sigprocmask - examine and change blocked signals 检测或者改变阻塞信号。 SYNOPSIS        #include <signal.h>        int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);    Feature Test Macro Requirements for glibc (see feature_test_macros(7)):        sigprocmask(): _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _POSIX_SOURCE DESCRIPTION        sigprocmask()  is  used  to  fetch  and/or  change the signal mask of the calling thread.  The signal mask is the set of signals whose delivery is currently  blocked for the caller (see also signal(7) for more details). 信号屏蔽字是一组信号递送被阻塞的信号集合。就是信号屏蔽字里面的信号都被阻塞递送了。        The behavior of the call is dependent on the value of how, as follows.        SIG_BLOCK               The set of blocked signals is the union of the current set and the set argument. 被阻塞的信号集是参数set的信号集合        SIG_UNBLOCK               The signals in set are removed from the current set of blocked signals.  It is permissible to attempt to unblock a signal which is not blocked. 被设置的信号集合从当前阻塞信号集合中移除。        SIG_SETMASK               The set of blocked signals is set to the argument set 阻塞的信号集合被赋值为参数set。 对于SIG_UNBLOCK与SIG_SETMASK，我们尽量选择在SIGBLOCK时，保存当前的信号集，然后在恢复时采用SIG_SETMASK，恢复之前的信号集。之所以不采用SIG_UNBLOCK，是因为可能在这之前，已经阻塞过该信号。  If oldset is non-null, the previous value of the signal mask is stored in oldset.        If set is NULL, then the signal mask is unchanged (i.e., how is ignored), but the current value of the signal mask is nevertheless returned in oldset (if it        is not NULL).        The use of sigprocmask() is unspecified in a multithreaded process; see pthread_sigmask(3). RETURN VALUE        sigprocmask() returns 0 on success and -1 on error.      10.13 sigpending函数 NAME        sigpending - examine pending signals 检测被阻塞的未决的信号。 SYNOPSIS        #include <signal.h>        int sigpending(sigset_t *set);    Feature Test Macro Requirements for glibc (see feature_test_macros(7)):        sigpending(): _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _POSIX_SOURCE DESCRIPTION        sigpending()  returns  the set of signals that are pending for delivery to the calling thread (i.e., the signals which have been raised while blocked).  The  mask of pending signals is returned in set.        sigpending函数返回一个信号集，该信号集内包含调用线程中处于未决状态的信号。也就是当前处于未决状态的信号的集合。 RETURN VALUE        sigpending() returns 0 on success and -1 on error. 10.14 sigaction函数 NAME        sigaction - examine and change a signal action 作用：检测和改变信号的动作。 SYNOPSIS        #include <signal.h>        int sigaction(int signum, const struct sigaction *act,                      struct sigaction *oldact);    Feature Test Macro Requirements for glibc (see feature_test_macros(7)):        sigaction(): _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _POSIX_SOURCE DESCRIPTION        The sigaction() system call is used to change the action taken by a process on receipt of a specific signal.  (See signal(7) for an overview of signals.)         sigaction系统调用用于改变进程在接收到一个特定信号时的行为。        signum specifies the signal and can be any valid signal except SIGKILL and SIGSTOP.        参数signum指定信号的类型，可以是除了SIGKILL和SIGSTOP以外的任何信号类型。这点和signal类似。        If act is non-null, the new action for signal signum is installed from act.  If oldact is non-null, the previous action is saved in oldact.       如果参数act非空，那么signum信号的新的动作由参数act决定。如果oldact非空，那么oldact保存之前的行为。        The sigaction structure is defined as something like:            struct sigaction {                void     (*sa_handler)(int);//指定SIG_DFL,SIG_IGN,orsignal handling function。类似siganl函数的第二个参数。                void     (*sa_sigaction)(int, siginfo_t *, void *);                sigset_t   sa_mask;                int        sa_flags;                void     (*sa_restorer)(void);//不会被指定            }; On some architectures a union is involved: do not assign to both sa_handler and sa_sigaction.        The sa_restorer element is obsolete and should not be used.  POSIX does not specify a sa_restorer element.        sa_handler  specifies  the  action  to be associated with signum and may be SIG_DFL for the default action, SIG_IGN to ignore this signal, or a pointer to a        signal handling function.  This function receives the signal number as its only argument.       sa_handler指定与signum相关的action。        If SA_SIGINFO is specified in sa_flags, then sa_sigaction (instead of sa_handler) specifies the signal-handling function for signum.  This function receives        the  signal  number as its first argument, a pointer to a siginfo_t as its second argument and a pointer to a ucontext_t (cast to void *) as its third argu‐ ment.       如果sa_flags中指定了SA_SIGINFO字段，那么sa_sigaction而不是sa_handler为signum指定信号处理函数。这个函数接收signal number作为第一个参数，指向siginfo_t的指针作为第二个参数，一个执行void*作为第三个参数。       注意：sa_sigaction和sa_handler这两个字段，这两个实现可能使用同一个存储区，所以应用程序只能一次使用这两个字段中的一个，也就是说，sa_handler与sa_sigaction只能二选一。        sa_mask specifies a mask of signals which should be blocked (i.e., added to the signal mask of the thread in which the signal  handler  is  invoked)  during execution of the signal handler.  In addition, the signal which triggered the handler will be blocked, unless the SA_NODEFER flag is used.      sa_mask字段说明了一个信号集，在调用该信号捕捉函数之前，这一信号集要加到进程的信号屏蔽字中。sa_mask指定了在信号执行函数执行期间，哪些信号将会被阻塞。        sa_flags specifies a set of flags which modify the behavior of the signal.  It is formed by the bitwise OR of zero or more of the following：详见man sigaction。指定了一组调整信号行为的标识。       siginfo_t结构包含了信号产生原因的有关信息。 The siginfo_t argument to sa_sigaction is a struct with the following elements:详见man sigaction         RETURN VALUE        sigaction() returns 0 on success and -1 on error.      10.15 sigsetjmp和siglongjmp函数 10.16 sigsuspend函数 NAME        sigsuspend - wait for a signal 作用：等待信号 SYNOPSIS        #include <signal.h>        int sigsuspend(const sigset_t *mask);    Feature Test Macro Requirements for glibc (see feature_test_macros(7)):        sigsuspend(): _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _POSIX_SOURCE DESCRIPTION        sigsuspend()  temporarily replaces the signal mask of the calling process with the mask given by mask and then suspends the process until delivery of a signal whose action is to invoke a signal handler or to terminate a process.       sigsuspend暂时用参数mask的信号集代替当前进程的信号集，然后暂停进程知道信号的处理程序被触发或者进程中止。        If the signal terminates the process, then sigsuspend() does not return.  If the signal is caught,  then  sigsuspend()  returns  after  the  signal  handler    returns, and the signal mask is restored to the state before the call to sigsuspend().        如果信号中止进程，那么不会返回sigsuspend。如果信号被捕获，那么在信号处理程序执行完毕后，返回sigsuspend，并且signal mask会恢复到调用sigsuspend之前的信号集。        It is not possible to block SIGKILL or SIGSTOP; specifying these signals in mask, has no effect on the process's signal mask. RETURN VALUE        sigsuspend() always returns -1, normally with the error EINTR sigsuspend函数在一个原子操作中，先恢复信号屏蔽字，然后再使进程暂停。 注意：我个人理解，sigsuspend就是为了解除信号集的阻塞，并且进行一系列的处理，从而方便进程的进一步操作。 // signal2.c /*该程序为了说明sigaction、sigemptyset、sigaddset、sigprocmask、sigsuspend、sigpending函数    */ #include <stdlib.h> #include <stdio.h> #include <unistd.h> #include <signal.h> #include <stdlib.h> #include <string.h> int test_quit; static void sig_quit(int signo) { printf(\"caught SIGQUIT\\n\"); test_quit = 1; } int main() { sigset_t oldmask; sigset_t pendmask; sigset_t waitmask; struct sigaction act,oact; memset(&act,0,sizeof(struct sigaction)); act.sa_handler = sig_quit; sigemptyset(&act.sa_mask); act.sa_flags = 0; sigaction(SIGQUIT,&act,&oact); //signal(SIGQUIT, sig_quit); sigemptyset(&act.sa_mask); sigaddset(&act.sa_mask, SIGQUIT); sigprocmask(SIG_BLOCK, &act.sa_mask, &oldmask); printf(\"Please entrl CTRL+\\\\ before sleep\\n\"); sleep (5);//休眠5秒钟 printf(\"after sleep\\n\"); sigpending(&pendmask);/*这儿是为了说明SIGQUIT信号的确是悬而未决的*/ if (sigismember(&pendmask, SIGQUIT)) { printf(\"\\nSIGQUIT pending\\n\"); } //sigprocmask(SIG_SETMASK, &oldmask, NULL);/*恢复默认的信号集，此时解除了SIGQUIT信号的阻塞，SIGQUIT信号被送到进程。*/ sigemptyset(&waitmask); sigsuspend(&waitmask); printf(\"hello,world\\n\"); if(test_quit == 1)     printf(\"test_quit == 1\\n\"); else    printf(\"test_quit is not 1\\n\"); printf(\"before sleep\\n\"); sleep(5); printf(\"after sleep\\n\"); return (0); } 说明：^\\是ctrl+\\在中断上的显示。 有两种运行方式，分别说明了sigpending和sigsuspend函数的作用。运行方式run1 and run2如下所示： compile :$ gcc -Wall signal2.c -o signal2  这个程序比较好的说明了sigpending的作用，在提示“Please entrl CTRL+\\ before sleep”时输入CTRL+\\,则出现了阻塞未决的SIGQUIT信号，因此sigpending的信号集中有SIGQUIT信号。 run1:$./signal2 Please entrl CTRL+\\ before sleep/*出现这句话时，输入CTRL+\\*/ ^\\after sleep SIGQUIT pending caught SIGQUIT hello,world test_quit == 1 before sleep ^\\after sleep run2:$./siganl2 Please entrl CTRL+\\ before sleep /*出现这句话时，没有输入CTRL+\\*/ after sleep ^\\caught SIGQUIT/*在sigsuspend等待时，输入CTRL+\\*/ hello,world test_quit == 1 before sleep after sleep 10.17 abort函数 10.18system函数 10.19sleep函数 10.20 作业控制信号 10.21其他特征 10.22小结","title":"基础文章1：APUE chap10 信号"},{"content":"1、概述        虚基类是用关键字virtual声明继承的父类，即便该基类在多条链路上被一个子类继承，但是该子类中只包含一个该虚基类的备份，这也是虚基类的作用所在。        正是由于虚基类的这个作用，所以在每个子类的构造函数中必须显示的调用该虚基类的构造函数，不管该虚基类是不是直接的父类。        其次，虚基类的构造函数的调用早于其他非虚基类的构造函数的调用。        上面两点就是虚基类的特性。 2、代码示例        我们来看一段简单的代码，体现虚基类的这两个特性。 #include <iostream>#include <cstdio>using namespace std;class Base{public :    int base;    Base(int a = 0)    {        this->base = a;        cout<<\"Base Constructer \"<<a<<endl;    }};class A : public virtual Base{public :    int a;    A(int a, int b):a(a), Base(b)    {        cout<<\"A Constructer\"<<endl;    }};class B : public virtual Base{public :    int b;    B(int a, int b) : b(a), Base(b)    {        cout<<\"B Constructer\"<<endl;    }};class C : public B, public A, public virtual Base{public :    int c;    C(int a, int b, int c, int d, int e) : A(a, b), B(c, d), Base(e)    {        cout<<\"C Constructer\"<<endl;    }};int main(){    C c(1, 2, 3, 4, 5);    return 0;}  程序运行结果：        我们看到最后一个子类C显式的调用了虚基类的构造函数，这个是必须的。        然后就是虽然虚基类在最后一个声明，但是Base的构造函数最先被调用，而且只被调用了一次，说明子类中只包含了一个该基类的复本。        虚基类的特性就从这段代码的运行结果中一目了然了。","title":"C++ 虚基类简单使用"},{"content":"发现要到2013了，这两个月，离职入职，忙七忙八的，博文少了好多，笔记到是一大堆。 最近开始整理书签，微博收藏以及笔记梳理 采用删的方式，就是在evernote中新建一片，然后捞对应的笔记，一点点总结梳理，删除原有的笔记，发现这样效率高些（原来是在原有笔记之上直接修改总结，发现有用的信息其实并不多，效率有点低） 相对而言比较全和有用，会持续优化。 2013，发完这个系列的博客之后，将会整个博客迁移到自己的博客（刚开始写...），后续将同步吧，不过csdn可能会慢一些，自己blog会更自由些。后续将会是python&框架,linux后台开发，Go等等其他。 不扯了，看正题 以下是对列表笔记梳理的第一个版本，仅供参考 资料来源于书籍，网络，个人练习等等 --------------------------------------------------------------------------------------- #author:wklken #version: 1.0 #date: 2012-12-30 #history:   2012-12-30  created 一.定义： 列表是Python中使用最频繁的数据类型【可以说没有之一】 关键词：有序，可变 >一组有序项目的集合 >可变的数据类型【可进行增删改查】 >列表中可以包含任何数据类型，也可包含另一个列表【可任意组合嵌套】 >列表是以方括号“ []”包围的数据集合，不同成员以“ ,”分隔 >列表可通过序号访问其中成员 查看帮助 : help(list) 二.常见的列表操作 1.声明&创建 l = []    #空列表 l = [1, 2, 3, 4] l = [1, 'a', [2,3] ] l = list('hello')     #得到 ['h', 'e', 'l', 'l', 'o']   l = list(range(4))   #[0, 1, 2, 3] l = '1,2,3,4,5'.split(',')  #['1', '2', '3', '4', '5'] 内建函数list(a_sequence) 可以将一个序列转为列表 通过下标访问 >>>l = [1, 2, 3, 4] >>>l[0]  #1 2.增加元素 A.新加入一个元素append append方法添加。它在原列表末尾添加一个 item， item类型可以是任意的 l = [1, 2, 3] l.append('hello')   #得到 [1, 2, 3, 'hello'] l.append(['hello'])   #得到 [1, 2, 3, 'hello', ['hello']] B.插入一个元素insert l1 = [1, 2, 3] l1.insert(1,9)    #[1, 9, 2, 3]    C.两个列表相加 两种方式 第一种 l1 = [1, 2, 3] l3 = l1 + [4, 5, 6]  #这种方式,l1不变，二者返回新的列表，当列表很长时，会消耗大量内存 第二种(必须接收一个参数，且是另一个列表) l1.extend([4, 5, 6])  #直接扩增l1 等价的做法 l1 += [4,5,6] 梳理： s.append(x) same as s[len(s):len(s)] = [x] 在列表尾部追加单个对象x。使用多个参数会引起异常。 s.extend(x) same as s[len(s):len(s)] = x将列表L中的表项添加到列表中。返回None。 s.insert(i, x) same as s[i:i] = [x] 在索引为i的元素前插入对象x。如list.insert(0,x)在第一项前插入对象。返回None。 3.删除元素 A.按item的索引或切片删除 l1 = [1, 2, 3, 4, 5, 6] del l1[0]   #得到[2, 3, 4, 5, 6] del l1[0:2]  #得到[4, 5, 6] B.按item的值进行删除 l1 = [1,2,3,1,2] l1.remove(1)  #得到[2,3,1,2] 若是remove对应值查无，将跑ValueError C.删除某个位置并返回该位置值 pop若是不传位置参数，默认删除列表最后一个元素 l1 = [1, 2, 3, 4, 5] a = l1.pop(1)   #a=2 b = l1.pop()   #a=5 梳理: s.pop([i]) same as x = s[i]; del s[i]; return x删除列表中索引为x的表项，并返回该表项的值。若未指定索引，pop返回列表最后一项。 s.remove(x) same as del s[s.index(x)] 删除列表中匹配对象x的第一个元素。匹配元素时产生异常。返回None。 del s[i:j] same as s[i:j] = [] 4.修改元素 对指定索引进行赋值操作 A.某个元素 l1 = [1, 2, 3, 4] l1[0] = 0   #[0,2,3,4] B.某一段元素 l1= [1,2,3,4] l1[0:2] = [7,8,9]  #[7,8,9,3,4] l1[:] = []   #清空了 梳理： s[i] = x item i of s is replaced by x s[i:j] = t slice of s from i to j is replaced by the contents of the iterable t 5.切片和索引 A.索引l[i] l1 = [1,2,3,4,5] l1[0]  #1 l1[-1]  #5，负数的索引从尾部开始计数,最后一个元素为-1 B.切片l[i:j:k]   i,j,k可选，冒号必须的 i不指定默认0，j不指定默认序列尾，k不指定默认1 l1 =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] l1[0:2]   #[1, 2],   取区间[i,j) ，左闭右开 l1[:2]     #同上，可省略第一位 l1[2:]     #[3, 4, 5, 6, 7, 8, 9, 10, 11] l1[2:-1]   #[3, 4, 5, 6, 7, 8, 9, 10] l1[:]       #同l1，相当于复制一份 l1[::2]   #步长2，[1, 3, 5, 7, 9, 11] l1[0:7:2]  #[1, 3, 5, 7] l1[7:0:-2]  #[8, 6, 4, 2]   注意步长为负、理解起来相当于从7到1，倒序步长2 6.排序 A.原地排list.sort() l1 = [5,3,2,1,4,6] l1.sort()   #得到[1,2,3,4,5,6]   默认升序 sort可接受参数 cmp，比较函数，接受两个参数,小于时返回负，大于返回正，相等返回0 key，指定排序键 reverse，指定是否反序 列表的比较操作 , 隐式调用cmp 方法 , 比较规则是逐个扫描元素 , 进行比较, 如果可以比较 , 比较, 如果相等扫描下一个元素 , 如果不相等返回结果 , 如果两个元素类型不可以比较 , 就比较两个对象的 id()值 .. 如果一直相等 ,直到一个列表扫描结束 , 那么返回较长的列表较大 >>> l1 = [(1,99),(3,97),(2,98),(4,96)] >>> l1.sort(key=lambda x: x[1]) >>> l1 [(4, 96), (3, 97), (2, 98), (1, 99)] >>> l1.sort(key=lambda x: x[1], reverse=True) >>> l1 [(1, 99), (2, 98), (3, 97), (4, 96)] B.sorted函数 sorted(l1)   #返回l1的有序序列，l1不变 sorted(l,key=str.lower,reverse=True) C.反序 l1.reverse()  #l1反序 同样 reversed(l1)   #返回一个iterator l[::-1]可以达到一样的效果，但是这个是返回一个新的列表 梳理： sort  sorted 区别 sort:     在原 list 上排序，不返回排序后的 list sorted: 不改变原 list ，返回排序后的 list s.reverse() reverses the items of s in place颠倒列表元素的顺序。 s.sort([cmp[, key[, reverse]]]) sort the items of s in place对列表排序，返回none。bisect模块可用于排序列表项的添加和删除。 7.查找和统计 A.包含判断in ,not in l1  = [1, 2, 3, 4] 1 in l1  #True 1 not in l1 #False B.查询位置索引index l1 = [1, 2, 3, 4] l1.index(1)    #0 >>> l1.index(5)    #特别注意，当值不存在于列表，用index将抛ValueError Traceback (most recent call last):   File \"<pyshell#44>\", line 1, in <module>     l1.index(5) ValueError: 5 is not in list C.统计一个元素的出现次数 l1 = [1, 2, 3, 4, 1] l1.count(1)    #2 梳理： s.count(x) return number of i's for which s[i] == x返回对象x在列表中出现的次数。 s.index(x[, i[, j]]) return smallest k such that s[k] == x and i <= k < j返回列表中匹配对象x的第一个列表项的索引。无匹配元素时产生异常。 8.遍历列表 A.直接 l1 = [1, 2, 3, 4, 5] for i in l1:      print i B.需要索引位置 l1 = [1, 2, 3, 4, 5] for index,value in enumerate(l1):      print index,value 9.其他操作 列表长度 len(l)   l*3 重复 l1 = [1, 2] l1*3   #[1,2,1,2,1,2] 清空列表 l1 = [] l1[:] = [] del l1[:] 复制列表 l2 = l1[:] 注意：在操作list时，如果是涉及原地修改的操作，例如append,insert等，返回值是None 要防止出现这种语法   l1 = l1.append('a')  ，如果这样，你将得到None....... 三、列表解析 1.定义和说明 >Python 的强大特性之一是其对 list 的解析，它提供一种紧凑的方法，可以通过对 list 中的每个元素应用一个函数，从而将一个 list 映射为另一个 list。 >列表解析，又叫列表推导式( list comprehension) >列表解析比 for 更精简，运行更快，特别是对于较大的数据集合 >列表解析可以替代绝大多数需要用到 map和 filter的场合   列表推导式提供了一个创建链表的简单途径，无需使用 map() ， filter() 以及 lambda 。以定义方式得到列表通常要比使用构造函数创建这些列表更清晰。每一个列表推导式包括在一个 for 语句之后的表达式，零或多个 for 或 if 语句。返回值是由 for 或 if 子句之后的表达式得到的元素组成的列表。如果想要得到一个元组，必须要加上括号。 2.基本列表解析 基本 >>> [x for x in range(5)]   # [0, 1, 2, 3, 4] l1 = [1,2,3,4] [ x*2 for x in l1]   #[2,4,6,8] 多个值的 [ '%s = %s' for (k, v) in a_map.items()] 两次循环 >>> l1 = [1,2,3,4] >>> l2 = [1,2,3,4] >>> [x+y for x in l1 for y in l2] [2, 3, 4, 5, 3, 4, 5, 6, 4, 5, 6, 7, 5, 6, 7, 8] 可以调用函数 [ func(x) for x in l1]  #等价于map 注意，列表解析不会改变原有列表的值，会创建新的list 3.条件列表解析 [ x for x in range(100) if x%2 ==0 ] 4.、嵌套列表解析 mat = [ [1, 2, 3],[4, 5, 6], [7, 8, 9]] 交换行列 [ [row[i] for row in mat] for i in (0,1,2)] #[[1, 4, 7], [2, 5, 8], [3, 6, 9]] 四、其他： 1.根据索引取元素时，需要进行边界检查  IndexError    切片取，不需要，超过边界不会异常 2.在迭代中修改列表    注意，不安全，不建议这么干 但是可以    for i in l1[:]:           l1.insert()...... 3.多个list合成一个 就是 ['a','b',.....],['a','b'.....]['a','b'.....] 变为 ['a','b',.....,'a','b'.....'a','b'.....] >>> sum ([[ 'a', 'b' ],['a' , 'b'],[ 'a' ,'b' ]], []) ['a' , 'b' , 'a', 'b' , 'a' , 'b'] >>> list (itertools .chain([ 'a' ,'b' ],[ 'a', 'b' ],['a' , 'b'])) ['a' , 'b' , 'a', 'b' , 'a' , 'b'] 4.关于堆栈和队列 通过上面的操作，可以发现，很轻易可以拿列表当做堆栈或者队列使用 当然，他们有自己的模块，可以查相关库 5.序列相关模块 array 一种受限制可变序列类型，要求所有元素必须是相同类型 copy 提供浅拷贝和深拷贝的能力 operator 包含函数调用形式的序列操作符，如 operator.concat(m,n) 相当于m+n re 正则表达式 types 包含Python 支持的所有类型 collections 高性能容器数据类型 The end! to be continue.... wklken 2012-12-30 转载请注明出处[http://blog.csdn.net/wklken]，谢谢","title":"[置顶] [Python入门及进阶笔记]Python-基础-列表及列表解析小结"},{"content":"示例程序TCPEchoServerSelector中展示了Selector的基本用法。在此，我们将对其进行更加详细的介绍。 Selector: 创建和关闭 static Selector open() boolean isOpen() void close() 调用Selector的open()工厂方法可以创建一个选择器实例。选择器的状态是\"打开\"或\"关闭\"的。创建时选择器的状态是打开的，并保持该状态，直到调用close()方法通知系统其务已经完成。可以调用isOpen()方法来检查选择器是否已经关闭。 5.6.1在信道中注册 我们已经知道，每个选择器都有一组与之关联的信道，选择器对这些信道上\"感兴趣的\"I/O操作进行监听。Selector与Channel之间的关联由一个SelectionKey实例表示。（注意一个信道可以注册多个Selector实例，因此可以有多个关联的SelectionKey实例）SelectionKey维护了一个信道上感兴趣的操作类型信息，并将这些信息存放在一个int型的位（bitmap）中，该int型数据的每一位都有相应的含义。  SelectionKey类中的常量定义了信道上可能感兴趣的操作类型，每个这种常量都是只有一位设置为1的位掩码（bitmask）（见第3.1.3节）  SelectionKey: 兴趣操作集 static int OP_ACCEPT static int OP_CONNECT static int OP_READ static int OP_WRITE int interestOps() SelectionKey interestOps(int ops) 通过对OP_ ACCEPT，OP_CONNECT，OP_READ以及OP_WRITE中适当的常量进行按位OR，我们可以构造一个位向量来指定一组操作。例如，一个包含读和写的操作集由表达式（OP_READ | OP_WRITE）来指定。不带参数的interestOps()方法将返回一个int型位图，该位图中设置为1的每一位都指示了信道上需要监听的一种操作。另一个方法以一个位图为参数，指示了应该监听信道上的哪些操作。重点提示：任何对key（信道）所关联的兴趣操作集的改变，都只在下次调用了select()方法后才会生效。 SocketChannel, Server SocketChannel:注册Selector SelectionKey register(Selector sel, int ops) SelectionKey register(Selector sel, int ops, Object attachment) int validOps() boolean isRegistered() SelectionKey keyFor(Selector sel) 调用信道的register()方法可以将一个选择器注册到该信道。在注册过程中，通过存储在int型数据中的位图来指定该信道上的初始兴趣操作集（见上文的\"SelectionKey：兴趣操作集\"）。register()方法将返回一个代表了信道和给定选择器之间的关联的SelectionKey实例。validOps()方法用于返回一个指示了该信道上的有效I/O操作集的位图。对于ServerSocketChannel来说，accept是惟一的有效操作，而对于SocketChannel来说，有效操作包括读、写和连接。对于DatagramChannel，只有读写操作是有效的。一个信道可能只与一个选择器注册一次，因此后续对register()方法的调用只是简单地更新该key所关联的兴趣操作集。使用isRegistered()方法可以检查信道是否已经注册了选择器。keyFor()方法与第一次调用register()方法返回的是同一个SelectionKey实例，除非该信道没有注册给定的选择器。 以下代码注册了一个信道，支持读和写操作： SelectionKey key = clientChannel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE); 图5.1展示了一个选择器，其键集中包含了7个代表注册信道的键：两个在端口4000和4001上的服务器信道，以及从服务器信道创建的5个客户端信道： SelectionKey: 获取和取消 Selector selector() SelectableChannel channel() void cancel() 键关联的Selector实例和Channel实例可以分别使用该键的selector()和channel()方法获得。cancel()方法用于（永久性地）注销该键，并将其放入选择器的注销集（canceled set）中（图5.1）。在下一次调用select()方法时，这些键将从该选择器的所有键集中移除，其关联的信道也将不再被监听（除非它又重新注册）。   （点击查看大图）图5.1：Selector与其关联的键集 Selected Key Set:   选择键集； Cancelled Key Set：注销键集； Key Set：键集；Interest Sets： 兴趣操作集  5.6.2选取和识别准备就绪的信道  在信道上注册了选择器，并由关联的键指定了感兴趣的I/O操作集后，我们就只需要坐下来等待I/O了。这要使用选择器来完成。 Selector: 等待信道准备就绪 int select() int select(long timeout) int selectNow() Selector wakeup() select()方法用于从已经注册的信道中返回在感兴趣的I/O操作集上准备就绪的信道总数。（例如，兴趣操作集中包含OP_READ的信道有数据可读，或包含OP_ACCEPT的信道有连接请求待接受。）以上三个select方法的惟一区别在于它们的阻塞行为。无参数的select方法会阻塞等待，直到至少有一个注册信道中有感兴趣的操作准备就绪，或有别的线程调用了该选择器的wakeup()方法（这种情况下select方法将返回0）。以超时时长作为参数的select方法也会阻塞等待，直到至少有一个信道准备就绪，或等待时间超过了指定的毫秒数（正数），或者有另一个线程调用其wakeup()方法。selectNow()方法是一个非阻塞版本：它总是立即返回，如果没有信道准备就绪，则返回0。wakeup()方法可以使当前阻塞（也就是说在另一个线程中阻塞）的任何一种select方法立即返回；如果当前没有select方法阻塞，下一次调用这三种方法的任何一个都将立即返回。  选择之后，我们需要知道哪些信道准备好了特定的I/O操作。每个选择器都维护了一个已选键集（selected-key set），与这些键关联的信道都有即将发生的特定I/O操作。通过调用selectedKeys()方法可以访问已选键集，该方法返回一组SelectionKey。我们可以在这组键上进行迭代，分别处理等待在每个键关联的信道上的I/O操作。 Iterator<SelectionKey> keyIter = selector.selectedKeys().iterator(); while (keyIter.hasNext()) { SelectionKey key = keyIter.next(); // ...Handle I/O for key's channel... keyIter.remove(); }  图5.1中的选择器的已选键集中有两个键：K2和K5。 Selector: 获取键集 Set<SelectionKey> keys() Set<SelectionKey> selectedKeys()  以上方法返回选择器的不同键集。keys()方法返回当前已注册的所有键。返回的键集是不可修改的：任何对其进行直接修改的尝试（如，调用其remove()方法）都将抛出UnsupportedOperationException异常。selectedKeys()方法用于返回上次调用select()方法时，被\"选中\"的已准备好进行I/O操作的键。重要提示：selectedKeys()方法返回的键集是可修改的，实际上在两次调用select()方法之间，都必须\"手工\"将其清空。换句话说，select方法只会在已有的所选键集上添加键，它们不会创建新的键集。 所选键集指示了哪些信道当前可以进行I/O操作。对于选中的每个信道，我们需要知道它们各自准备好的特定I/O操作。除了兴趣操作集外，每个键还维护了一个即将进行的I/O操作集，称为就绪操作集（ready set）。  SelectionKey: 查找就绪的I/O操作 int readyOps() boolean isAcceptable() boolean isConnectable() boolean isReadable() boolean isValid() boolean isWritable() 对于给定的键，可以使用readyOps()方法或其他指示方法来确定兴趣集中的哪些I/O操作可以执行。readyOps()方法以位图的形式返回所有准备就绪的操作集。其他方法用于分别检查各种操作是否可用。  例如，查看键关联的信道上是否有正在等待的读操作，可以使用以下代码： (key.readyOps() & SelectionKey.OP_READ) != 0或key.isReadable() 选择器的已选键集中的键，以及每个键中准备就绪的操作，都是由    select()方法来确定的。随着时间的推进，这些信息可能会过时。其他线程可能会处理准备就绪的I/O操作。同时，键也不是永远存在的。当其关联的信道或选择器关闭时，键也将失效。通过调用其cancel()方法可以显示地将键设置为无效。调用其isValid()方法可以检测一个键的有效性。无效的键将添加到选择器的注销键集中，并在下次调用任一种形式的                select()方法或    close()方法时从键集中移除。（当然，从键集中移除键意味着与它关联的信道也不再受监听。） 5.6.3信道附件 当一个信道准备好进行I/O操作时，通常还需要额外的信息来处理请求。例如，在前面的回显协议中，当客户端信道准备好写操作时，就需要有数据可写。当然，我们所需要的可写数据是由之前同一信道上的读操作收集的，但是在其可写之前，这些数据存放在什么地方呢？另一个例子是第3章中的成帧过程。如果一个消息一次传来了多个字节，我们需要保存已接收的部分消息，直到完整个消息接收完成。这两种情况都需要维护每个信道的状态信息。然而，我们非常幸运！SelectionKey通过使用附件使保存每个信道的状态变得容易。 SelectionKey: 查找准备就绪的I/O操作 Object attach(Object ob) Object attachment() 每个键可以有一个附件，数据类型只能是Object类。附件可以在信道第一次调用register()方法时与之关联，或者后来再使用          attach()方法直接添加到键上。通过         SelectionKey   的attachment()方法可以访问键的附件。  5.6.4 Selector小结 总的来说，使用Selector的步骤如下： I.创建一个Selector实例。 II.将其注册到各种信道，指定每个信道上感兴趣的I/O操作。 III.重复执行： 1.调用一种select方法。 2.获取选取的键列表。 3.对于已选键集中的每个键， a.获取信道，并从键中获取附件（如果合适的话） b.确定准备就绪的操作并执行。如果是accept操作，将接受的信道设置为非阻塞模式， 并将其与选择器注册。 c.如果需要，修改键的兴趣操作集 d.从已选键集中移除键 如果选择器告诉了你什么时候I/O操作准备就绪，你还需要非阻塞I/O吗？答案是肯定的。信道在已选键集中的键并不能确保非阻塞I/O，因为调用了select()方法后，键集信息可能会过时。另外，阻塞式写操作会阻塞等待直到写完所有的字节，而就绪集中的OP_WRITE仅表示至少有一个字节可写。实际上，只有非阻塞模式的信道才能与选择器进行注册：如果信道在阻塞模式，SelectableChannel类的register()方法将抛出IllegalBlockingModeException异常。   相关下载： Java_TCPIP_Socket编程(doc) http://download.csdn.net/detail/undoner/4940239   文献来源： LSOFT.CN(琅软中国)  ","title":"NIO：Selector 详解"},{"content":"作者：朱金灿 来源：http://blog.csdn.net/clever101          为了使得批处理命令获取更大的通用性，有时需要获取操作系统版本。今天为此搜了一些资料，网上的说法是Ver、注册表、WMI都可以。我研究了一下，发现还是Ver命令最为成熟，为此综合各家做法写下了下面一个批处理文件：   @echo offclsver | find \"4.0.\" > NUL &&  goto win95  ver | find \"4.10.\" > NUL &&  goto win98 ver | find \"4.90.\" > NUL &&  goto win_me ver | find \"3.51.\" > NUL &&  goto win_Nt_3_5 ver | find \"5.0.\" > NUL &&  goto win2000  ver | find \"5.1.\" > NUL &&  goto win_xp  ver | find \"5.2.\" > NUL &&  goto win2003  ver | find \"6.0.\" > NUL &&  goto vista ver | find \"6.1.\" > NUL &&  goto win7  ver | find \"6.2.\" > NUL &&  goto win8  :win95@echo           当前系统是：win95@echo ----------------------------------------goto end:win98@echo           当前系统是：win98@echo ----------------------------------------goto end:win_me@echo           当前系统是：win_me@echo ----------------------------------------goto end:win_Nt_3_5@echo           当前系统是：win NT 3.51@echo ----------------------------------------goto end:win2000@echo           当前系统是：win2000@echo ----------------------------------------goto end:win_xp@echo           当前系统是：WinXP@echo ----------------------------------------goto end:win2003@echo           当前系统是：win200@echo ----------------------------------------goto end:vista@echo           当前系统是：vista@echo ----------------------------------------goto end:win7@echo           当前系统是：win7@echo ----------------------------------------goto end:win8@echo           当前系统是：win8@echo ----------------------------------------goto end@echo           不能获取当前操作系统版本@echo ----------------------------------------:endpause          下面是Windws 的主要版本列表：                                                需要指出的是上面的批处理命令获取的操作系统版本的取自版本的前两位，获取的操作系统信息依然不够准确的，如上表所示，如Windows 8和Windows Server 2012的版本号都是6.2。所以在使用该批处理文件时需要注意这一点。   参考文献：   DOS 批处理命令判断操作系统版本执行各版本对应语句   批处理怎样判断操作系统的类型？   OSVERSIONINFOEX structure (Windows)           如果你觉得我的博客对你有帮助，请在下面网址中博客之星评选活动中投我一票： http://vote.blog.csdn.net/item/blogstar/clever101（单击候选人介绍下面的投他一票那个按钮） 参与投票有机会获奖：         最佳贡献奖：通过微博分享活动就有机会获得30元充值卡一张（每周抽选5名）         幸运奖：凡参与投票用户就有机会获得精美小礼品一份。（每周抽选5名）         积极参与奖：所有参与投票并符合条件的用户均可获得20个下载积分。","title":"批处理命令之精确获取操作系统版本信息"},{"content":"填空题： 1、中序遍历二叉树，结果为ABCDEFGH，后序遍历结果为ABEDCHGF，逆序遍历结果为? 2、对字符串HELL0_HULU中的字符进行二进制编码，使得字符串的编码长度尽可能短，最短长度为？ 3、对长度12的有序数组进行二分查找，目标等概率出现在数组的每个位置上，则平均比较次数为？ 4、一副扑克（去王），每个人随机的摸两张，则至少需要多少人摸牌，才能保证有两个人抽到同样的花色。 5、x个小球中有唯一一个球较轻，用天平秤最少称量y次能找出这个较轻的球，写出y和x的函数表达式y=f(x) 6、3的方幂及不相等的3的方幂的和排列成递增序列1,3,4,9,10,12,13……，写出数列第300项 7、无向图G有20条边，有4个度为4的顶点，6个度为3的顶点，其余顶点度小于3，则G有多少个顶点 8、桶中有M个白球，小明每分钟从桶中随机取出一个球，涂成红色（无论白或红都涂红）再放回，问小明将桶中球全部涂红的期望时间是？ 9、煤矿有3000吨煤要拿到市场上卖，有一辆火车可以用来运煤，火车最多能装1000吨煤，且火车本身需要烧煤做动力，每走1公里消耗1吨煤，如何运煤才能使得运到市场的煤最多，最多是多少？ 10、1,2,3,4…..n，n个数进栈，有多少种出栈顺序，写出递推公式（写出通项公式不得分） 11、宇宙飞船有100,000位的存储空间，其中有一位有故障，现有一种Agent可以用来检测故障，每个Agent可以同时测试任意个位数，若都没有故障，则返回OK，若有一位有故障，则失去响应。如果有无限多个Agent可供使用，每个Agent进行一次检测需要耗费1小时，现在有2个小时时间去找出故障位，问最少使用多少个Agent就能找出故障。 大题： 1、n个数，找出其中最小的k个数，写出代码，要求最坏情况下的时间复杂度不能高于O(nlogk) 2、写程序输出8皇后问题的所有排列，要求使用非递归的深度优先遍历。 3、有n个作业，a1,a2…..an，作业aj的处理时间为tj，产生的效益为pj，最后完成期限为dj，作业一旦被调度则不能中断，如果作业aj在dj前完成，则获得效益pj，否则无效益。给出最大化效益的作业调度算法。","title":"Hulu 2013北京地区校招笔试题"},{"content":"int f(int a, int b){\treturn a + b;}int g(int a, int b, int c){\treturn a + b + c;}// 函数指针定义typedef int (*f_type) (int, int);typedef int (*g_type) (int, int, int);// 使用struct仅仅是为了方便, 不必写出publicstruct demo{\tint f(int a, int b)\t{\t\treturn a + b;\t}};// 函数对象struct sf {\tint operator()(int a, int b)\t{\t\treturn a + b;\t}};void test_bind_common(){\tstd::cout << boost::bind(f, 1, 2)() << std::endl;\tstd::cout << boost::bind(g, 1, 2, 3)() << std::endl;}// 1. 普通函数应用boost::bindvoid test_bind_fun1(){// \tbind(f, _1, 9)(x);\t           // f(x, 9), 相当于bind2nd(f, 9)// \tbind(f, _1, _2)(x, y);\t       // f(x, y)// \tbind(f, _2, _1)(x, y);         // f(y, x)// \tbind(f, _1, _1)(x, y);         // f(x, x), y参数被忽略// \tbind(g, _1, 8, _2)(x, y);      // g(x, 8, y)// \tbind(g, _3, _2, _2)(x, y, z);  // g(z, y, y), x参数被忽略\tint x = 1, y = 2, z = 3;\tstd::cout << boost::bind(f, _1, 9)(x) << std::endl;\tstd::cout << boost::bind(f, _1, _2)(x, y) << std::endl;\tstd::cout << boost::bind(f, _2, _1)(x, y) << std::endl;\tstd::cout << boost::bind(f, _1, _1)(x, y) << std::endl;\tstd::cout << boost::bind(g, _1, 8, _2)(x, y) << std::endl;\tstd::cout << boost::bind(g, _3, _2, _2)(x, y, z) << std::endl;}// 2. 成员函数应用boost::bindvoid test_bind_fun2(){\tdemo a, &ra = a;\tdemo *p = &a;\t// 必须在成员函数前加上取地址操作符&, 表明这是一个成员函数指针\t// 第二个参数用struct demo, struct demo * 两个类型都可以\tstd::cout << boost::bind(&demo::f, a, _1, 20)(10) << std::endl;\tstd::cout << boost::bind(&demo::f, ra, _2, _1)(10, 20) << std::endl;\tstd::cout << boost::bind(&demo::f, p, _1, _2)(10, 20) << std::endl;}// 3. 成员变量void test_bind_val(){\ttypedef std::pair<int, std::string> pair_t;\tpair_t p(123, \"string\");\tstd::cout << boost::bind(&pair_t::first, p)() << std::endl;\tstd::cout << boost::bind(&pair_t::second, p)() << std::endl;}// 4. 函数对象void test_bind_functor(){\tstd::cout << boost::bind(std::plus<int>(), _1, _2)(10, 20) << std::endl;\tstd::cout << boost::bind(std::modulus<int>(), _1, 3)(11) << std::endl;\tstd::cout << std::boolalpha << boost::bind(std::greater<int>(), _1, 10)(20) << std::endl;\tstd::cout << boost::bind<int>(sf(), _1, _2)(11, 22) << std::endl;}// 可以使用ref库包装了对象的引用，可以让bind 存储对象引用的拷贝，从而降低了拷贝的代价。void test_bind_ref(){    // 变量    int x = 10;    // 11 + 10 + 10    std::cout << boost::bind(g, _1, boost::cref(x), boost::ref(x))(11) << std::endl;        // 一个函数对象    sf af;    std::cout << boost::bind<int>(boost::ref(af), _1, _2)(11, 22) << std::endl;}","title":"【Boost】boost::bind四种应用场景的例子"},{"content":"在ACM中  一丁点错误就足以造成你的失败 关于 double float 的精确度问题     double比float 精绝度要高     精确到小数点6位左右 在在代码中对浮点数据类型直接使用== 、<= 、>=、 !=等运算符进行比较都是不正确的。 正确的方法应该是 将其差或和于小数进行比较   通常与10^6 比较 如 浮点数与零的比较： 等于0关系：  fabs(i)<=1e-6 大于0关系：  i>1e-6 小于0关系：  i<1e-6 在三角形中  任意2边大于第三边   a+b>c  如果直接这样写  会造成无法AC       如果这样写 a+b-c>1e-6   则是可以AC的 所以在做题过程中注意  对于浮点型千万不要直接比较","title":"ACM中关于浮点型的精确度问题"},{"content":"这里的两个排序的期望运行时间都是O(n)，应该是到目前为止时间复杂度最低的了。 计数排序 计数排序假设n个输入元素的每一个都是介于0到K之间的整数，此处K为某个整数，在具体实现中，我们可以取K为n 个元素中最大的那个。 计数排序的基本思想：对每个输入元素x，确定小于x的元素个数。再根据这个信息，把x放到它最终输出数组中的位置 上。例如，有20个元素小于x,则x就放到输出数组的第21个位置上。当有元素相同时，这个方法就要进行一定的修改， 具体的修改可以从下面给出的代码中看到。 #include<iostream>using namespace std;void display (int a[], int n);int max (int a[], int n);void counting_sort (int a[], int b[], int n, int k);int main(){\tint a[100];\tint b[100];\tint n;\twhile (cin >> n)\t{\t\tfor (int i = 0; i < n; i++)\t\t\tcin >> a[i];\t\tint k = max (a, n);\t\tcounting_sort (a, b, n, k);\t\tdisplay (b, n);\t}\treturn 0;}void display (int a[], int n){\tfor (int i = 0; i < n; i++)\t\tcout << a[i] << \" \";\tcout << endl;}int max (int a[], int n){\tint m = a[0];\tfor (int i = 1; i < n; i++)\t{\t\tif (m < a[i])\t\t\tm = a[i];\t}\treturn m;}/*这里数组a和b的下标都是从0开始的*/void counting_sort (int a[], int b[], int n, int k){\tint* c = new int[k + 1];\tfor (int i = 0; i <= k; i++)\t\tc[i] = 0;\tfor (int i = 0; i < n; i++)\t\tc[a[i]]++;\tfor (int i = 1; i <= k; i++)\t\tc[i] = c[i] + c[i - 1];\tfor (int i = n - 1; i >= 0; i--) //反过来遍历会失去计数排序的稳定性\t{\t\tb[c[a[i]] - 1] = a[i];\t\tc[a[i]]--;\t}\tdelete [] c;} 对于计数排序，我认为有一个最明显的缺点就是需要很大的额外的空间，尤其当待排序数组中的少数一些元素特别大 的时候，会造成很大的空间浪费。比如这样一个序列：1,2,6,8,3,0....100,65.........10000000,1000000000,那么这时我 们的K的取值为1000000000，这样数组C大小就开到1000000000了，但很多我们都不需要用到。 基数排序 基数排序是通过对各个元素每个位上的数来进行排序从而实现排序的。首先必须统一所有元素的数位长度，数位较短 的在前面补0.然后从最低位开始，依次对每个位进行排序，当从最低位到最高位都排序完以后，便可得到一个有序序 列了。至于这个方法正确性的证明可以看下算法导论。对每个位的排序可以采用计数排序实现，这时K直接取9即可。 基数排序实现代码如下： #include<iostream>using namespace std;void display (int a[], int n);int max (int a[], int n);int max_bit (int num);void radix_sort (int a[], int n);int main(){\tint a[100];\tint b[100];\tint n;\twhile (cin >> n)\t{\t\tfor (int i = 0; i < n; i++)\t\t\tcin >> a[i];\t\tradix_sort (a, n);\t\tdisplay (a, n);\t}\treturn 0;}void display (int a[], int n){\tfor (int i = 0; i < n; i++)\t\tcout << a[i] << \" \";\tcout << endl;}int max (int a[], int n){\tint m = a[0];\tfor (int i = 1; i < n; i++)\t{\t\tif (m < a[i])\t\t\tm = a[i];\t}\treturn m;}int max_bit (int num){\tint bits = 1;\twhile (num / 10)\t{\t\tbits++;\t\tnum /= 10;\t}\treturn bits;}void radix_sort (int a[], int n){\tint* b = new int[n];\tint c[10];\tint radix = 1;\tint t;\tint d;\td = max_bit (max (a, n));\tfor (int i = 0; i < d; i++, radix *= 10)\t{\t\t/* use counting_sort to sort the array by specific digit */\t\tfor (int j  = 0; j < 10; j++)\t\t\tc[j] = 0;\t\tfor (int j = 0; j < n; j++)\t\t{\t\t\tt = a[j] / radix % 10;\t\t\tc[t]++;\t\t}\t\tfor (int j = 1; j < 10; j++)\t\t\tc[j] += c[j - 1];\t\tfor (int j = n - 1; j >= 0; j--)\t\t{\t\t\tt = a[j] / radix % 10;\t\t\tb[c[t] - 1] = a[j];\t\t\tc[t]--;\t\t}\t\t/* copy the sorted array from b to a */\t\tfor (int j = 0; j < n; j++)\t\t\ta[j] = b[j];\t}\tdelete [] b;}","title":"计数排序与基数排序"},{"content":"java7 NIO2使用walk递归接口递归操作文件，可以使用这个接口进行文件搜索，文件内容搜索，递归拷贝，递归移动，递归删除等操作。 package com.mime;import java.io.IOException;import java.nio.file.FileVisitOption;import java.nio.file.FileVisitResult;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.nio.file.SimpleFileVisitor;import java.util.EnumSet;public class NIO2FileWalk {\t/**\t * @param args\t */\tpublic static void main(String[] args) {\t\tPath listDir = Paths.get(\"/tmp\"); // define the starting file\t\t//\t\tListTree walk = new ListTree();\t\ttry {\t\t\tFiles.walkFileTree(listDir, walk);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\t//遍历的时候跟踪链接\t\tEnumSet opts = EnumSet.of(FileVisitOption.FOLLOW_LINKS); \t\ttry {\t\t\tFiles.walkFileTree(listDir, opts, Integer.MAX_VALUE, walk); \t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\t\t\t//FileVisitor 提供perform a file search, a recursive copy, arecursive move, and a recursive delete.\t}}// NIO2 递归遍历文件目录的接口实现class ListTree extends SimpleFileVisitor<Path> {\t@Override\tpublic FileVisitResult postVisitDirectory(Path dir, IOException exc) {\t\tSystem.out.println(\"Visited directory: \" + dir.toString());\t\treturn FileVisitResult.CONTINUE;\t}\t@Override\tpublic FileVisitResult visitFileFailed(Path file, IOException exc) {\t\tSystem.out.println(exc);\t\treturn FileVisitResult.CONTINUE;\t}} 输出： Visited directory: /tmp/.ICE-unixVisited directory: /tmp/gpg-LOz0cLVisited directory: /tmp/.org.chromium.Chromium.YKWsQJVisited directory: /tmp/hsperfdata_weijianzhongwjVisited directory: /tmp/kde-weijianzhongwjjava.nio.file.AccessDeniedException: /tmp/pulse-qKcxuRTsGUobVisited directory: /tmp/ksocket-weijianzhongwjVisited directory: /tmp/nio_5078970948266789689Visited directory: /tmp/pulse-j0jluTvI3Pe6Visited directory: /tmp/3892364837850046417Visited directory: /tmp/sni-qt_kaccessibleapp_2026-mEz8Dy/icons/hicolor/22x22/appsVisited directory: /tmp/sni-qt_kaccessibleapp_2026-mEz8Dy/icons/hicolor/22x22Visited directory: /tmp/sni-qt_kaccessibleapp_2026-mEz8Dy/icons/hicolorVisited directory: /tmp/sni-qt_kaccessibleapp_2026-mEz8Dy/iconsVisited directory: /tmp/sni-qt_kaccessibleapp_2026-mEz8DyVisited directory: /tmp/.X11-unixVisited directory: /tmp/akonadi-weijianzhongwj.mjmToIVisited directory: /tmp/ssh-mfuayNh73d7QVisited directory: /tmp/aaa/bbb/cccVisited directory: /tmp/aaa/bbbVisited directory: /tmp/aaajava.nio.file.AccessDeniedException: /tmp/pulse-PKdhtXMmr18nVisited directory: /tmp","title":"java7 NIO2(5) 文件和目录操作API"},{"content":"// //  main.cpp //  AUTO_PRO // //  Created by yanzhengqing on 12-12-11. //  Copyright (c) 2012年 yanzhengqing. All rights reserved. // #include <iostream> using namespacestd; /***  *char *strncat(front, back, count) - append count chars of back onto front  *  *Purpose:  *       Appends at most count characters of the string back onto the  *       end of front, and ALWAYS terminates with a null character.  *       If count is greater than the length of back, the length of back  *       is used instead.  (Unlike strncpy, this routine does not pad out  *       to count characters).  *  *Entry:  *       char *front - string to append onto  *       char *back - string to append  *       unsigned count - count of max characters to append  *  *Exit:  *       returns a pointer to string appended onto (front).  *  *Uses:  *  *Exceptions:  *  *******************************************************************************/ ///////////////////////////////////////////////////////////////////////////////// /*说明：   1. __cdecl 是C Declaration的缩写（declaration，声明），表示C语言默认的函数调用方法：所有参数从右到左依次入栈，这些参数由调用者清除，称为手动清栈。被调用函数不会要求调用者传递多少参数，调用者传递过多或者过少的参数，甚至完全不同的参数都不会产生编译阶段的错误。   2.  在字符串dest之后连接上src，最多增加n个字符   3.  按照ANSI(American National Standards Institute)标准，不能对void指针进行算法操作，即不能对void指针进行如p++的操作,所以需要转换为具体的类型指针来操作,例如char *。（引用网友的结论）   4.  size_t 类型定义在cstddef头文件中，该文件是C标准库的头文件stddef.h的C++版。它是一个与机器相关的unsigned类型，其大小足以保证存储内存中对象的大小。 */ char * __cdecl strncat (                        char * front,                        const char * back,                        size_t count                         ) {    char *start = front;         while (*front++);     front--;         while (count--)        if (!(*front++ = *back++))            return(start);          *front ='\\0';    return(start); } int main() {     char brc[50] =\"blog.csdn.net/barry_yan\";     constchar src[50] =\"/you are a good boy!!\";    cout<<brc<<endl;    cout<<src<<endl;    strncat(brc,src,strlen(src));    cout<<brc<<endl;    return 0; }","title":"strncat源码"},{"content":"On any given machine, the fastest possible programs will  be writen in assembly language. Any algorithm you can implement in a HLL you can implement in assembly. On the other hand, there are many algorithms you can implement in assembly language which you cannot implement in a HLL. Assembly language is the uncontested speed champion among programming language. An expert assembly language programmer will almost always produces a faster program than expert C programmer.While certain programs may not benefit much from implementation in assembly, you can speed up many programs by a factor of five or ten over their HLL conuterparts by careful coding in assembly language; even greater improvement is possible if you're not using an optimzing compiler.If you spend the time to learn assembly language really well, you too can achieve these impressive performance gains.","title":"assembly introduction"},{"content":"// //  main.cpp //  AUTO_PRO // //  Created by yanzhengqing on 12-12-11. //  Copyright (c) 2012年 yanzhengqing. All rights reserved. // #include <iostream> using namespace std; /***  *char *strcpy(dst, src) - copy one string over another  *  *Purpose:  *       Copies the string src into the spot specified by  *       dest; assumes enough room.  *  *Entry:  *       char * dst - string over which \"src\" is to be copied  *       const char * src - string to be copied over \"dst\"  *  *Exit:  *       The address of \"dst\"  *  *Exceptions:  *******************************************************************************/ ///////////////////////////////////////////////////////////////////////////////// /*说明：   1. __cdecl 是C Declaration的缩写（declaration，声明），表示C语言默认的函数调用方法：所有参数从右到左依次入栈，这些参数由调用者清除，称为手动清栈。被调用函数不会要求调用者传递多少参数，调用者传递过多或者过少的参数，甚至完全不同的参数都不会产生编译阶段的错误。   2.  将一个字符串从一个位置复制到另一个位置   3.  按照ANSI(American National Standards Institute)标准，不能对void指针进行算法操作，即不能对void指针进行如p++的操作,所以需要转换为具体的类型指针来操作,例如char *。（引用网友的结论）   4.  size_t 类型定义在cstddef头文件中，该文件是C标准库的头文件stddef.h的C++版。它是一个与机器相关的unsigned类型，其大小足以保证存储内存中对象的大小。 */ char * __cdecl strcpy(char * dst, const char * src) {     char * cp = dst;     while( *cp++ = *src++ );/* Copy src over dst */          return( dst ); } int main() {     const char brc[50] = \"blog.csdn.net/barry_yan\";     char src[50] = \"\";     strcpy(src,brc);          cout<<src<<endl;     return 0; }","title":"strcpy源码"},{"content":"// //  main.cpp //  AUTO_PRO // //  Created by yanzhengqing on 12-12-11. //  Copyright (c) 2012年 yanzhengqing. All rights reserved. // #include <iostream> using namespace std; /***  *char *strcat(dst, src) - concatenate (append) one string to another  *  *Purpose:  *       Concatenates src onto the end of dest.  Assumes enough  *       space in dest.  *  *Entry:  *       char *dst - string to which \"src\" is to be appended  *       const char *src - string to be appended to the end of \"dst\"  *  *Exit:  *       The address of \"dst\"  *  *Exceptions:  *  *******************************************************************************/ ///////////////////////////////////////////////////////////////////////////////// /*说明：   1. __cdecl 是C Declaration的缩写（declaration，声明），表示C语言默认的函数调用方法：所有参数从右到左依次入栈，这些参数由调用者清除，称为手动清栈。被调用函数不会要求调用者传递多少参数，调用者传递过多或者过少的参数，甚至完全不同的参数都不会产生编译阶段的错误。   2.  在字符串dest之后连接上src   3.  按照ANSI(American National Standards Institute)标准，不能对void指针进行算法操作，即不能对void指针进行如p++的操作,所以需要转换为具体的类型指针来操作,例如char *。（引用网友的结论） */ char * __cdecl strcat (                        char * dst,                        const char * src                        ) {     char * cp = dst;          while( *cp )         cp++;                   /* find end of dst */          while( *cp++ = *src++ ) ;       /* Copy src to end of dst */     return( dst );                  /* return dst */      } int main() {     char brc[50] = \"blog.csdn.net/\";     const char src[50] = \"barry_yan\";     strcat(brc,src);          cout<<brc<<endl;     return 0; }","title":"strcat源码"},{"content":"关于etmvc+jQuery EasyUI使用教程距离上次更新已经有一个多月了，其实这项目早已经做完了，只是一直没时间更新，今天抽空把里面的一小部分作为例子抽出来讲讲。上篇教程讲到接下来我们会进入JQuery easyUI，但可能是我本人水平有限，关于JQuery easyUI的入门个人感觉还不如建议大家直接去看官方的开发文档来得快，所以在这里打算跳过jQuery EasyUI入门，直接就一个具体的使用例子来讲了一下jQuery EasyUI和etmvc的配合使用，不过关于JQuery easyUI具体控件使用还是建议大家去看一看JQuery easyUI官方的开发文档。下面我们开始。 1、首先你当然是要下载jQuery EasyUI，下载地址：http://www.jeasyui.com/download/index.php ，注意新旧版本有些用法是不大一样的，建议版本不要过旧，选个网上开发文档比较全的版本最好，我这用了一个1.3的版本。 2、在eclipse新建一个Dynamic Web Project项目，把下载回来的压缩包解压之后搁到项目的WebContent目录下，可以删掉里面的demo文件夹，按照我之间的教程配置好etmvc框架，包括数据库的配置。 3、在MySql数据库新建一个表并且追加几条记录： /*Navicat MySQL Data TransferSource Host     : localhost:3306Source Database : ciccpsmemberTarget Host     : localhost:3306Target Database : ciccpsmemberDate: 2012-12-10 02:17:51*/SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for contacts-- ----------------------------DROP TABLE IF EXISTS `contacts`;CREATE TABLE `contacts` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `name` varchar(50) NOT NULL,  `gender` varchar(10) NOT NULL,  `department` varchar(50) DEFAULT NULL,  `position` varchar(50) DEFAULT NULL,  `tel` varchar(20) DEFAULT NULL,  `email` varchar(50) DEFAULT NULL,  `phone` varchar(20) DEFAULT NULL,  `fax` varchar(20) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;-- ------------------------------ Records of contacts-- ----------------------------INSERT INTO `contacts` VALUES ('1', '张三', '男', '信息部', '高级专员', '84547718-8053', 'zhangsan@ciccps.org', '18812345678', '84547718');INSERT INTO `contacts` VALUES ('2', '李四', '女', '会员部', '秘书', '84547718-8052', 'lisi@ciccps.org', '18812345678', '84547718');INSERT INTO `contacts` VALUES ('3', '王五', '男', '信息部', '高级专员', '010-84547718-8052', 'wangwu@ciccps.org', '13812345231', '010-84547718');INSERT INTO `contacts` VALUES ('4', '刘六', '男', '信息部', '高级专员', '010-84547718-8052', 'liuliu@ciccps.org', '13488780443', '010-84547718'); 4、在项目src目录下的models包建立数据库contact表对应的域对象Contact.java： package models;import com.et.ar.*;import com.et.ar.annotations.*;@Table(name = \"contacts\")public class Contact extends ActiveRecordBase {\t@Id\tprivate Integer id;\t@Column\tprivate String name;\t@Column\tprivate String gender;\t@Column\tprivate String department;\t@Column\tprivate String position;\t@Column\tprivate String tel;\t@Column\tprivate String email;\t@Column\tprivate String phone;\t@Column\tprivate String fax;\t\t//设置 get,set...\t\tpublic Integer getId() {\t\treturn id;\t}\tpublic void setId(Integer id) {\t\tthis.id = id;\t}\tpublic String getName() {\t\treturn name;\t}\tpublic void setName(String name) {\t\tthis.name = name;\t}\tpublic String getGender() {\t\treturn gender;\t}\tpublic void setGender(String gender) {\t\tthis.gender = gender;\t}\tpublic String getDepartment() {\t\treturn department;\t}\tpublic void setDepartment(String department) {\t\tthis.department = department;\t}\tpublic String getPosition() {\t\treturn position;\t}\tpublic void setPosition(String position) {\t\tthis.position = position;\t}\tpublic String getTel() {\t\treturn tel;\t}\tpublic void setTel(String tel) {\t\tthis.tel = tel;\t}\tpublic String getEmail() {\t\treturn email;\t}\tpublic void setEmail(String email) {\t\tthis.email = email;\t}\tpublic String getPhone() {\t\treturn phone;\t}\tpublic void setPhone(String phone) {\t\tthis.phone = phone;\t}\tpublic String getFax() {\t\treturn fax;\t}\tpublic void setFax(String fax) {\t\tthis.fax = fax;\t}\t} 5、在项目src目录下的controllers包建立对应的控制器ContactController.java，主要用于对数据库contact表的增删改查： package controllers;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import models.Contact;import com.et.mvc.JsonView;public class ContactController extends ApplicationController{\t\t/**\t * 通讯录列表页面\t */\tpublic void index(){\t\t\t}\t\t/**\t * 查询通讯记录，分页查询\t * @param rows 分页大小\t * @param page\t页号\t * @param department\t查询参数-按部门名称查询\t * @param name\t查询参数-按人名称查询\t * @return 返回通讯录的分页数据资料\t * @throws Exception\t */\tpublic JsonView getContacts(int rows, int page,\t\t\tString department,\t\t\tString name\t\t\t) throws Exception {\t\t\t\tString cond = \"1=1\";\t\tList<Object> tmpArgs = new ArrayList<Object>();\t\tif (department != null && !department.equals(\"\")) {\t//部门名称参数非空时增加编码查询条件\t\t\tcond += \" and department like ?\";\t\t\ttmpArgs.add(\"%\" + department + \"%\");\t\t}\t\tif (name != null && !name.equals(\"\")) {\t//名称参数非空时增加名称查询条件\t\t\tcond += \" and name like ?\";\t\t\ttmpArgs.add(\"%\" + name + \"%\");\t\t}\t\tObject[] args = tmpArgs.toArray();\t\t\t\tlong total = Contact.count(Contact.class, cond, args);\t//查询通讯录总数量\t\tList<Contact> contacts = Contact.findAll(Contact.class, cond, args, \"id\", rows, (page-1)*rows);\t//查询通讯的一页资料\t\t\t\t//构造JSON用的数据结构并返回JSON视图\t\tMap<String, Object> result = new HashMap<String, Object>();\t\tresult.put(\"total\", total);\t\tresult.put(\"rows\", contacts);\t\treturn new JsonView(result);\t}\t\t/**\t * 取得指定的事件信息\t */\tpublic JsonView getContactById(Integer id) throws Exception{\t\tContact contact = Contact.find(Contact.class, id);\t\treturn new JsonView(contact);\t}\t\tpublic long getContactByName(String name) throws Exception{\t\tlong count = Contact.count(Contact.class, \"name = ?\", new Object[]{name}); \t\treturn count;\t}\t/**\t * 保存新建通讯记录\t */\tpublic JsonView save(Contact contact) throws Exception {\t\tMap<String,Object> result = new HashMap<String,Object>();\t\tif (getContactByName(contact.getName())>0){\t\t\tresult.put(\"failure\", true);\t\t\tresult.put(\"msg\", \"该用户已经存在。\");\t\t} else {\t\t\tresult.put(\"success\", true);\t\t\tcontact.save();\t\t}\t\tJsonView view = new JsonView(result);\t\tview.setContentType(\"text/html;charset=utf-8\");\t\treturn view;\t}\t\t/**\t * 保存修改的通讯记录\t */\tpublic JsonView update(Integer id) throws Exception{\t\t\t\tMap<String,Object> result = new HashMap<String,Object>();\t\tContact contact = Contact.find(Contact.class, id);\t\tupdateModel(contact);\t\tif(contact.save())\t\t{\t\t\tresult.put(\"success\", true);\t\t}\t\telse\t\t{\t\t\tresult.put(\"failure\", true);\t\t\tresult.put(\"msg\", \"服务器繁忙，请稍后再试！\");\t\t}\t\tJsonView view = new JsonView(result);\t\tview.setContentType(\"text/html;charset=utf-8\");\t\treturn view;\t}\t/**\t * 删除指定的通讯记录\t */\tpublic JsonView destroy(Integer id) throws Exception {\t\tContact contact = Contact.find(Contact.class, id);\t\tcontact.destroy();\t\treturn new JsonView(\"success:true\");\t}} 6、在WebContent下新建一个JS的目录，在里面新建一个contact.js的脚本文件，主要是用于对页面的数据进行操作，包括数据的显示，增加修改和删除（其中查找功能没有在这里实现）： $(function(){\tgrid = $('#tt').datagrid({\t\tpageSize:15,\t\tpageList:[15,30,60,90],\t\tfit: true,//自动大小          rownumbers:true,//行号 \t\turl:'/demo/contact/getContacts',\t\t//loadMsg:'数据装载中......',  \t\tsingleSelect:true,//单行选取\t\tpagination:true,//显示分页\t\ttoolbar:[{\t\t\ttext:'新增',\t\t\ticonCls:'icon-add',\t\t\thandler:newContact\t\t},'-',{\t\t\ttext:'修改',\t\t\ticonCls:'icon-edit',\t\t\thandler:editContact\t\t},'-',{\t\t\ttext:'删除',\t\t\ticonCls:'icon-remove',\t\t\thandler:delContact\t\t},'-',{\t\t\ttext:'查询',\t\t\ticonCls:'icon-search'\t\t}]\t});\t//设置分页控件     var p = grid.datagrid('getPager');     $(p).pagination({         pageSize: 15,//每页显示的记录条数，默认为10         pageList: [15,30,60,90],//可以设置每页记录条数的列表         //beforePageText: '第',//页数文本框前显示的汉字         //afterPageText: '页    共 {pages} 页',         //displayMsg: '当前显示 {from} - {to} 条记录   共 {total} 条记录',     }); \t$('#btn-save,#btn-cancel').linkbutton();\twin = $('#contact-window').window({\t\tclosed:true\t});\tform = win.find('form');});var grid;var win;var form;function newContact(){\twin.window('open');\tform.form('clear');\tform.url = '/demo/contact/save';}function editContact(){\tvar row = grid.datagrid('getSelected');\tif (row){\t\twin.window('open');\t\tform.form('load',row);\t\tform.url = '/demo/contact/update/'+row.id;\t} else {\t\t$.messager.show({\t\t\ttitle:'警告', \t\t\tmsg:'请先选择通讯记录。'\t\t});\t}}function saveContact(){\tform.form('submit', {\t\turl:form.url,\t\tsuccess:function(data){\t\t\teval('data='+data);\t\t\tif (data.success){\t\t\t\tgrid.datagrid('reload');\t\t\t\twin.window('close');\t\t\t} else {\t\t\t\t$.messager.alert('错误',data.msg,'error');\t\t\t}\t\t}\t});}function delContact(){\tvar row = grid.datagrid('getSelected');\tif (row){\t\t$.messager.confirm('Confirm', '您确定要删除该数据吗?', function(r) {            if (r){             $.post('/demo/contact/destroy', { id: row.id },                     function(result) {                      if (result.success) {                    \t  grid.datagrid('reload');                        } else {                            $.message.show({                                title: 'Error',                                msg: result.msg                            });                        }                    },                  'json');            }        });\t} else {\t\t$.messager.show({\t\t\ttitle:'警告', \t\t\tmsg:'请先选择通讯记录。'\t\t});\t}}function closeWindow(){\twin.window('close');} 7、在WebContent下的视图目录views下添加一个名为contact的目录，用于对应ContactController，然后在里面添加一个index.jsp作为contact的视图： <%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%><!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"><html><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><title>demo会员管理系统<\/title>    <link rel=\"stylesheet\" href=\"/demo/easyui/themes/default/easyui.css\" type=\"text/css\" media=\"screen\" />    <link rel=\"stylesheet\" href=\"/demo/easyui/themes/icon.css\" type=\"text/css\" media=\"screen\" />    <link rel=\"stylesheet\" href=\"/demo/css/main.css\" type=\"text/css\" media=\"screen\" />    <script src=\"/demo/easyui/jquery-1.7.2.min.js\"><\/script>    <script src=\"/demo/easyui/jquery.easyui.min.js\"><\/script>    <script src=\"/demo/easyui/locale/easyui-lang-zh_CN.js\"><\/script>\t<script type=\"text/javascript\" src=\"/demo/js/contact.js\"><\/script>\t<script type=\"text/javascript\" src=\"/demo/js/myValid.js\"><\/script>\t<style type=\"text/css\">\t\tinput,textarea{\t\t\twidth:200px;\t\t\tborder:1px solid #ccc;\t\t\tpadding:2px;\t\t}\t<\/style><\/head><body class=\"easyui-layout\"><div region=\"center\" style=\"padding:5px;\" border=\"false\">\t<table id=\"tt\" fit=\"true\">\t\t<thead>\t\t\t<tr>\t\t\t\t<th field=\"id\" width=\"50\">编号<\/th>\t\t\t\t<th field=\"name\" width=\"80\">姓名<\/th>\t\t\t\t<th field=\"gender\" width=\"50\">性别<\/th>\t\t\t\t<th field=\"department\" width=\"80\" >部门<\/th>\t\t\t\t<th field=\"position\" width=\"100\">职务<\/th>\t\t\t\t<th field=\"tel\" width=\"120\">办公电话<\/th>\t\t\t\t<th field=\"email\" width=\"150\">电子邮箱<\/th>\t\t\t\t<th field=\"phone\" width=\"80\">移动电话<\/th>\t\t\t\t<th field=\"fax\" width=\"100\">办公传真<\/th>\t\t\t<\/tr>\t\t<\/thead>\t<\/table>\t<div id=\"contact-window\" title=\"通讯信息\" iconCls=\"icon-edit\" modal=\"true\" maximizable=\"false\" minimizable=\"false\" style=\"background:#fafafa;width:400px;height:350px;\">\t\t<div style=\"padding:20px 20px 40px 60px;\">\t\t\t<form method=\"post\">\t\t\t<table>\t\t\t\t\t<tr>\t\t\t\t\t\t<td>姓名：\t\t\t\t\t\t<\/td>\t\t\t\t\t\t<td><input name=\"name\" class=\"easyui-validatebox\" data-options=\"required:true,validType:'length[2,10]'\"><\/input>  \t\t\t\t\t\t<\/td>\t\t\t\t\t<\/tr>\t\t\t\t\t<tr>\t\t\t\t\t\t<td>性别：\t\t\t\t\t\t<\/td>\t\t\t\t\t\t<td><select class=\"easyui-combobox\" name=\"gender\" style=\"width:200px;\" data-options=\"editable:false,required:true,validType:'length[1,1]'\">\t\t\t\t\t\t\t\t<option value=\"男\" selected>男<\/option>\t\t\t\t\t\t\t\t<option value=\"女\">女<\/option>\t\t\t\t\t\t\t<\/select> \t\t\t\t\t\t<\/td>\t\t\t\t\t<\/tr>\t\t\t\t\t<tr>\t\t\t\t\t\t<td>部门：\t\t\t\t\t\t<\/td>\t\t\t\t\t\t<td><input name=\"department\" class=\"easyui-validatebox\" data-options=\"required:true,validType:'length[2,15]'\"><\/input>\t\t\t\t\t\t<\/td>\t\t\t\t\t<\/tr>\t\t\t\t\t<tr>\t\t\t\t\t\t<td>职务：\t\t\t\t\t\t<\/td>\t\t\t\t\t\t<td><input name=\"position\" class=\"easyui-validatebox\" data-options=\"required:true,validType:'length[2,15]'\"><\/input>\t\t\t\t\t\t<\/td>\t\t\t\t\t<\/tr>\t\t\t\t\t<tr>\t\t\t\t\t\t<td>办公电话：\t\t\t\t\t\t<\/td>\t\t\t\t\t\t<td><input name=\"tel\" class=\"easyui-validatebox\" data-options=\"required:true,validType:'tel'\"><\/input>\t\t\t\t\t\t<\/td>\t\t\t\t\t<\/tr>\t\t\t\t\t<tr>\t\t\t\t\t\t<td>电子邮箱：\t\t\t\t\t\t<\/td>\t\t\t\t\t\t<td><input name=\"email\" class=\"easyui-validatebox\" data-options=\"validType:'email'\"><\/input>\t\t\t\t\t\t<\/td>\t\t\t\t\t<\/tr>\t\t\t\t\t<tr>\t\t\t\t\t\t<td>移动电话：\t\t\t\t\t\t<\/td>\t\t\t\t\t\t<td><input name=\"phone\" class=\"easyui-validatebox\" data-options=\"validType:'mobile'\" ><\/input>\t\t\t\t\t\t<\/td>\t\t\t\t\t<\/tr>\t\t\t\t\t<tr>\t\t\t\t\t\t<td>办公传真：\t\t\t\t\t\t<\/td>\t\t\t\t\t\t<td><input name=\"fax\" class=\"easyui-validatebox\" data-options=\"validType:'tel'\"><\/input>\t\t\t\t\t\t<\/td>\t\t\t\t\t<\/tr>\t\t\t\t\t<\/table>\t\t\t<\/form>\t\t<\/div>\t\t<div style=\"text-align:center;padding:5px;\">\t\t\t<a href=\"javascript:void(0)\" onclick=\"saveContact()\" id=\"btn-save\" icon=\"icon-save\">保存<\/a>\t\t\t<a href=\"javascript:void(0)\" onclick=\"closeWindow()\" id=\"btn-cancel\" icon=\"icon-cancel\">取消<\/a>\t\t<\/div>\t<\/div><\/div><\/body><\/html> 8、最后来看看效果图： 是不是很简单呢？其中那个contact.js脚本是精髓，是它负责与后端ContactController打交道，并把数据展示出来，它和后端所有的数据交互都是以json格式进行传送，而ContactController又依赖于Contact域模型对象对数据库进行存储访问。今天就写到这！","title":"etmvc+jQuery EasyUI使用教程（四）—数据的交互"},{"content":"1. 概述 线程就是，在同一程序同一时间内允许执行不同函数的离散处理队列。 这使得一个长时间去进行某种特殊运算的函数在执行时不阻碍其他的函数变得十分重要。 线程实际上允许同时执行两种函数，而这两个函数不必相互等待。 一旦一个应用程序启动，它仅包含一个默认线程。 此线程执行main() 函数。 在main()中被调用的函数则按这个线程的上下文顺序地执行。 这样的程序称为单线程程序。 反之，那些创建新的线程的程序就是多线程程序。 他们不仅可以在同一时间执行多个函数，而且这在如今多核盛行的时代显得尤为重要。 既然多核允许同时执行多个函数，这就使得对开发人员相应地使用这种处理能力提出了要求。 然而线程一直被用来当并发地执行多个函数，开发人员现在不得不仔细地构建应用来支持这种并发。 多线程编程知识也因此在多核系统时代变得越来越重要。 2. 线程管理 2.1 情景1(test_thread_wait1) 在这个库最重要的一个类就是boost::thread，它是在boost/thread.hpp里定义的，用来创建一个新线程。下面的示例来说明如何运用它。 新建线程里执行的那个函数的名称被传递到boost::thread的构造函数。 一旦上述示例中的变量t 被创建，该 thread() 函数就在其所在线程中被立即执行。 同时在test_thread_wait1()里也并发地执行该 threadfun1() 。 为了防止程序终止，就需要对新建线程调用join() 方法。join() 方法是一个阻塞调用：它可以暂停当前线程，直到调用 join() 的线程运行结束。这就使得test_thread_wait1()函数一直会等待到 threadfun1()运行结束。 正如在上面的例子中看到，一个特定的线程可以通过诸如t的变量访问，通过这个变量等待着它的使用 join() 方法终止。 但是，即使 t 越界或者析构了，该线程也将继续执行。 一个线程总是在一开始就绑定到一个类型为 boost::thread 的变量，但是一旦创建，就不在取决于它。 甚至还存在着一个叫detach()的方法，允许类型为boost::thread 的变量从它对应的线程里分离。 当然了，像join()的方法之后也就不能被调用，因为这个变量不再是一个有效的线程。 任何一个函数内可以做的事情也可以在一个线程内完成。 归根结底，一个线程只不过是一个函数，除了它是同时执行的。 在上述例子中，使用一个循环把5个数字写入标准输出流。 为了减缓输出，每一个循环中调用wait() 函数让执行延迟了一秒。 wait() 可以调用一个名为sleep() 的函数，这个函数也来自于 Boost.Thread，位于 boost::this_thread 名空间内。 sleep() 要么在预计的一段时间或一个特定的时间点后时才让线程继续执行。 通过传递一个类型为boost::posix_time::seconds 的对象，在这个例子里我们指定了一段时间。 boost::posix_time::seconds 来自于Boost.DateTime库，它被 Boost.Thread 用来管理和处理时间的数据。 虽然前面的例子说明了如何等待一个不同的线程，但下面的例子演示了如何通过所谓的中断点让一个线程中断。 2.2 情景2(test_thread_wait2()) 在一个线程对象上调用 interrupt() 会中断相应的线程。在这方面，中断意味着一个类型为boost::thread_interrupted的异常，它会在这个线程中抛出。然后这只有在线程达到中断点时才会发生。 如果给定的线程不包含任何中断点，简单调用interrupt() 就不会起作用。每当一个线程中断点，它就会检查interrupt() 是否被调用过。只有被调用过了， boost::thread_interrupted 异常才会相应地抛出。 Boost.Thread定义了一系列的中断点，例如sleep()函数。由于sleep()在这个例子里被调用了五次，该线程就检查了五次它是否应该被中断。然而sleep()之间的调用，却不能使线程中断。 一旦该程序被执行，它只会打印三个数字到标准输出流。这是由于在test_thread_wait2()里3秒后调用 interrupt()方法。因此，相应的线程被中断，并抛出一个boost::thread_interrupted 异常。 这个异常在线程内也被正确地捕获，catch处理虽然是空的。由于thread() 函数在处理程序后返回，线程也被终止。这反过来也将终止整个程序，因为test_thread_wait2()等待该线程使用join()终止该线程。 Boost.Thread定义包括上述 sleep()函数十个中断。有了这些中断点，线程可以很容易及时中断。然而，他们并不总是最佳的选择，因为中断点必须事前读入以检查boost::thread_interrupted异常。 3.示例 void wait(int seconds){\tboost::this_thread::sleep(boost::posix_time::seconds(seconds));}void threadfun1(){\tfor (int i = 0; i < 5; ++i)\t{\t\twait(1);\t\tPRINT_DEBUG(i);\t}}void threadfun2() {\ttry\t{\t\tfor (int i = 0; i < 5; ++i)\t\t{\t\t\twait(1);\t\t\tPRINT_DEBUG(i);\t\t}\t}\tcatch (boost::thread_interrupted&)\t{\t\tPRINT_DEBUG(\"thread_interrupted\");\t}}void test_thread_wait1(){\tboost::thread t(&threadfun1);\t// join()方法是一个阻塞调用：它可以暂停当前线程，直到调用join()的线程运行结束。\tt.join();}void test_thread_wait2(){\tboost::thread t(&threadfun2);\twait(3);\tt.interrupt();\tt.join();}void test_thread_wait3(){    boost::thread t(&threadfun2);    // timed_join()方法同样也是一个阻塞调用：它可以暂停当前线程，    // 直到调用join()的线程运行结束或者超时    t.timed_join(boost::posix_time::seconds(3));}","title":"【Boost】boost库中thread多线程详解1"},{"content":"一 问题描述： 一个单词单词字母交换，可得另一个单词，如army->mary，成为兄弟单词。提供一个单词，在字典中找到它的兄弟。描述数据结构和查询过程。 二 解题思路：    本题有两个关键点：第一，如何设计英语字典的数据结构？第二，如何查找兄弟单词？    1. 设计英语字典的数据结构     如图，可以采用哈希链表的形式组织字典，而每个结点有三个域组成，分别是单词，频度和后继指针，频度表示这个单词被访问的次数，当我们访问某个单词时，它的频度会加1，然后应用程序根据频度重新调整该单词在链表中的位置，使得频度高的里链表头近，这样可以提高查找的效率。 2. 设计查找兄弟单词的算法    比如army 和amry是兄弟单词，我们只要对两个单词按同一次序，比如升序进行排序，排序后两个单词相等，那么这两个单词是兄弟单词。 3. 代码 /*This is a free Program, You can modify or redistribute it under the terms of GNU*Description:百度面试题--给定一个单词，从字典查找该单词的所有兄弟单词*Language: C++*Development Environment: VC6.0*Author: Wangzhicheng*E-mail: 2363702560@qq.com*Date: 2012/12/30*/#include <iostream>#include <cstdlib>#include <vector>#include <list>#include <string>#include <algorithm>#include <cctype>using namespace std;/**单词结构体*/typedef struct Word {\tstring word;\tint freq;               // 单词被访问的频度\tstruct Word *next;}Word;const int N=26;             // 26个字母/**字典类*/class Dictionary {private:\tvector<Word *>d;\t/*\t*哈希函数,将ch映射为索引号\t*/\tint Hash(char ch) {\t\tch=tolower(ch);\t\treturn ch-'a';\t}\t/*\t*比较单词one和other是否相等\t*/\tbool cmp(string &one, string &other) {\t\treturn one == other;\t}\t/*\t*根据索引号index来将p所指向的结点插入该链表的合适位置\t*pre指向p的直接前驱\t*/\tvoid Adjust(int index, Word *pre,Word *p) {\t\tif(!pre) return;       //p指向链表的第一个结点    \t\tWord *cur=d[index];   //指向当前结点\t\tWord *q=NULL;        //指向cur的直接前驱\t\twhile(cur && cur->freq>p->freq) {\t\t\tq=cur;\t\t\tcur=cur->next;\t\t}\t\tpre->next=p->next;    //将p指向的结点删除\t\tif(!q) {\t\t\tp->next=d[index];\t\t\td[index]=q;\t\t}\t\telse {\t\t\tp->next=cur;\t\t\tq->next=p;        }\t}public:\tDictionary() {\t\tint i;\t\tfor(i=0;i<N;i++) d.push_back(NULL);\t}\tvoid Search(string word) {\t\tWord *p;\t\tint index=Hash(word[0]);\t\tif(index<0 || index>=N) {\t\t\tcout<<\"参数有误,程序退出!\"<<endl;\t\t\texit(1);\t\t}\t\tp=d[index];\t\tWord *pre=NULL;      //指向p的直接前驱\t\twhile(p) {\t\t\tif(cmp(p->word,word)) {      //找到要查找的单词\t\t\t\tp->freq++;\t\t\t\tAdjust(index,pre,p);\t\t\t\tbreak;\t\t\t}\t\t\tpre=p;\t\t\tp=p->next;\t\t}\t\tif(!p) {              //没有找到单词\t\t\tWord *q;\t\t\tq=new Word;\t\t\tq->freq=1;\t\t\tq->word=word;\t\t\tq->next=0;\t\t\tif(pre) pre->next=q;  //pre指向链表最后一个结点\t\t\telse d[index]=q;     //该链表为空\t\t}\t}\t/*\t*查找兄弟单词\t**/\tvoid SearchSibling(string word) {\t\tint i;\t\tint index;\t\tWord *p,*pre;\t\tfor(i=0;word[i];i++) {\t\t\tindex=Hash(word[i]);\t\t\t\tif(index<0 || index>=N) {\t\t\t\tcout<<\"参数有误,程序退出!\"<<endl;\t\t\t\texit(1);\t\t\t}\t\t\tpre=NULL;\t\t\tp=d[index];\t\t\twhile(p) {                string one=p->word;\t\t\t\tstring other=word;\t\t\t\tsort(one.begin(),one.end());\t\t\t\tsort(other.begin(),other.end());\t\t\t\tif(cmp(one,other)) {      //找到要查找的单词\t\t\t\t\tp->freq++;\t\t\t\t\tAdjust(index,pre,p);\t\t\t\t\tcout<<p->word<<endl;\t\t\t\t}\t\t\t\tpre=p;\t\t\t\tp=p->next;\t\t\t}\t\t}\t}\tvoid show() const {\t\tint i;\t\tWord *p;\t\tfor(i=0;i<N;i++) {\t\t\tp=d[i];\t\t\twhile(p) {\t\t\t\tcout<<p->word<<\":\"<<p->freq<<\" \";\t\t\t\tp=p->next;\t\t\t}\t\t\tcout<<endl;\t\t}\t}};void main() {\tDictionary dictionary;\tstring word;\tcout<<\"输入exit退出系统\"<<endl;\tcin>>word;\twhile(word!=\"exit\") {\t\tdictionary.Search(word);\t\tcin>>word;\t}\tdictionary.show();\tcout<<\"输入要查找的单词:\";\tcin>>word;\tcout<<word<<\"的兄弟单词是:\"<<endl;\tdictionary.SearchSibling(word);}   四： 测试","title":"[置顶] 百度面试题--给定一个单词，从字典查找该单词的所有兄弟单词"},{"content":"  java 7 NIO2中文件系统支持软链接，硬链接的API， import java.io.IOException;import java.nio.file.FileSystems;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.attribute.FileAttribute;import java.nio.file.attribute.PosixFileAttributes;import java.nio.file.attribute.PosixFilePermission;import java.nio.file.attribute.PosixFilePermissions;import java.util.Set;public class NIO2FileLink {\t/**\t * @param args\t */\tpublic static void main(String[] args) {\t\tPath link = FileSystems.getDefault().getPath(\t\t\t\tSystem.getProperty(\"user.home\"), \"www\",\t\t\t\t\"pyweb.settings\");\t\tPath target = FileSystems.getDefault().getPath(\"testlink\");\t\t// 创建软链接\t\ttry {\t\t\tFiles.createSymbolicLink(link, target);\t\t\t// 创建软链接时设置软链接的属性\t\t\tPosixFileAttributes attrs = Files.readAttributes(target,\t\t\t\t\tPosixFileAttributes.class);\t\t\tFileAttribute<Set<PosixFilePermission>> attr = PosixFilePermissions\t\t\t\t\t.asFileAttribute(attrs.permissions());\t\t\tFiles.createSymbolicLink(link, target, attr);\t\t} catch (IOException | UnsupportedOperationException\t\t\t\t| SecurityException e) {\t\t\tif (e instanceof SecurityException) {\t\t\t\tSystem.err.println(\"Permission denied!\");\t\t\t}\t\t\tif (e instanceof UnsupportedOperationException) {\t\t\t\tSystem.err.println(\"An unsupported operation was detected!\");\t\t\t}\t\t\tif (e instanceof IOException) {\t\t\t\tSystem.err.println(\"An I/O error occurred!\");\t\t\t}\t\t\tSystem.err.println(e);\t\t}\t\t// 检查是否是软链接\t\tboolean link_isSymbolicLink_1 = Files.isSymbolicLink(link);\t\tboolean target_isSymbolicLink_1 = Files.isSymbolicLink(target);\t\tSystem.out.println(link.toString() + \" is a symbolic link ? \"\t\t\t\t+ link_isSymbolicLink_1);\t\tSystem.out.println(target.toString() + \" is a symbolic link ? \"\t\t\t\t+ target_isSymbolicLink_1);\t\ttry {\t\t\tboolean link_isSymbolicLink_2 = (boolean) Files.getAttribute(link,\t\t\t\t\t\"basic:isSymbolicLink\");\t\t\tboolean target_isSymbolicLink_2 = (boolean) Files.getAttribute(\t\t\t\t\ttarget, \"basic:isSymbolicLink\");\t\t\tSystem.out.println(link.toString() + \" is a symbolic link ? \"\t\t\t\t\t+ link_isSymbolicLink_2);\t\t\tSystem.out.println(target.toString() + \" is a symbolic link ? \"\t\t\t\t\t+ target_isSymbolicLink_2);\t\t} catch (IOException | UnsupportedOperationException e) {\t\t\tSystem.err.println(e);\t\t}\t\t//读取软链接对应的文件\t\ttry {\t\t\tPath linkedpath = Files.readSymbolicLink(link);\t\t\tSystem.out.println(linkedpath.toString());\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\t// 创建硬链接\t\ttry {\t\t\tFiles.createLink(link, target);\t\t\tSystem.out.println(\"The link was successfully created!\");\t\t} catch (IOException | UnsupportedOperationException\t\t\t\t| SecurityException e) {\t\t\tif (e instanceof SecurityException) {\t\t\t\tSystem.err.println(\"Permission denied!\");\t\t\t}\t\t\tif (e instanceof UnsupportedOperationException) {\t\t\t\tSystem.err.println(\"An unsupported operation was detected!\");\t\t\t}\t\t\tif (e instanceof IOException) {\t\t\t\tSystem.err.println(\"An I/O error occured!\");\t\t\t}\t\t\tSystem.err.println(e);\t\t}\t}}","title":"java7 NIO2(3) 文件链接操作"},{"content":"队列：先进先出 list = [\"apple\", \"banana\", \"grape\"] list.append(\"orange\") print list print \"Pop:\",list.pop(0) print list 堆栈：先进后出 list = [\"apple\", \"banana\", \"grape\"] list.append(\"orange\") print list print \"Pop:\",list.pop() print list   2. 切片 #! /usr/bin/env python #coding=utf-8 tuple = (\"apple\", \"banana\", \"grape\", \"orange\") print tuple[:3] #取开头到第三个元素 print tuple[3:] #取第四个元素到最后一个元素 print tuple[0, -1] #整个数组删除最后一个元素  3. 合并 zip函数接受任意多个序列作为参数，将所有序列按相同的索引组合成一个元素是各个序列合并成的tuple的新序列，新的序列的长度以参数中最短的序列为准。另外(*)操作符与zip函数配合可以实现与zip相反的功能，即将合并的序列拆成多个tuple。 ①tuple的新序列 >>>>x=[1,2,3],y=['a','b','c'] >>>zip(x,y) [(1,'a'),(2,'b'),(3,'c')] ②新的序列的长度以参数中最短的序列为准. >>>>x=[1,2],y=['a','b','c'] >>>zip(x,y) [(1,'a'),(2,'b')] ③(*)操作符与zip函数配合可以实现与zip相反的功能,即将合并的序列拆成多个tuple。 >>>>x=[1,2,3],y=['a','b','c'] >>>>zip(*zip(x,y)) [(1,2,3),('a','b','c')]   4. 定义常量 在Python中没有提供定义常量的保留字，需要自己定义一个常量类来实现常量的功能！在此提供《Python Cookbook》一书中定义的常量模块const，代码如下：    说明：此类是定义了一个方法__setattr__()和一个异常类型ConstError，主要是判断定义的常量是否在字典中，在则抛出异常，否则，给新创建的常量赋值 [python] view plaincopyprint? class _const:       class ConstError(TypeError):pass       def __setattr__(self,name,value):           if self.__dict__.has_key(name):               raise self.ConstError,\"Can't rebind const (%s)\"% name           self.__dict__[name]=value      import sys   sys.modules[__name__]=_const()    5.range http://hi.baidu.com/life_to_you/item/b31c8db8ba467fe84ec7fd04 print range(1, 5) 输出1,2,3,4 print range(1,5,1) 输出1234 print range(1,5,2) 输出1,3 print range(0,5,2) 输出0,2,4 6.正则表达式 import re s = \"HELLO WOLRD\" print re.findall(r\"^hello\", s, re.IGNORECASE)   7. 读取文件 #读写模式:r只读,r+读写,w新建(会覆盖原有文件),a追加,b二进制文件.常用模式 rU 或 Ua 以读方式打开, 同时提供通用换行符支持 (PEP 278) w     以写方式打开， a     以追加模式打开 (从 EOF 开始, 必要时创建新文件) r+     以读写模式打开 w+     以读写模式打开 (参见 w ) a+     以读写模式打开 (参见 a ) rb     以二进制读模式打开 wb     以二进制写模式打开 (参见 w ) ab     以二进制追加模式打开 (参见 a ) rb+    以二进制读写模式打开 (参见 r+ ) wb+    以二进制读写模式打开 (参见 w+ ) ab+    以二进制读写模式打开 (参见 a+ ) f = file(\"hello.txt\", \"w+\") li = [\"Sexy boy\\n\", \"test\\n\"] f.writelines(li) f.close() f = file(\"hello.txt\", \"a+\") new_context = \"goodbye\" f.write(new_context) f.close  文件删除 import os file(\"hello.txt\", \"w\") if os.path.exists(\"hello.txt\"):     os.remove(\"hello.txt\")   os.path.split(path) 将path分割成目录和文件名二元组返回。 >>> os.path.split('c:\\\\csv\\\\test.csv') ('c:\\\\csv', 'test.csv') >>> os.path.split('c:\\\\csv\\\\') ('c:\\\\csv', '') os.path.join(path1[, path2[, ...]]) 将多个路径组合后返回，第一个绝对路径之前的参数将被忽略。 >>> os.path.join('c:\\\\', 'csv', 'test.csv') 'c:\\\\csv\\\\test.csv' >>> os.path.join('windows\\temp', 'c:\\\\', 'csv', 'test.csv') 'c:\\\\csv\\\\test.csv' >>> os.path.join('/home/aa','/home/aa/bb','/home/aa/bb/c') '/home/aa/bb/c' 8.批量修改文件名 import shutil import os files = os.listdir(\".\") for filename in files:     pos = filename.find(\".\")     if filename[pos + 1:] == \"html\":         newname = filename[:pos + 1] + \"htm\"         os.rename(filename,newname) files = os.listdir(\".\") for filename in files:     li = os.path.splitext(filename)     if li[1] == \".html\":         newname = li[0] + \".htm\"         os.rename(filename, newname)   9. 在文件中查找内容 #!/usr/bin/python # -*- coding: UTF-8 -*- import shutil import os import re f1 = file(\"hello.txt\", \"r\") count = 0 for s in f1.readlines():     li = re.findall(\"test\", s)     if len(li) > 0:         count = count + li.count(\"test\") print \"find \" + str(count) + \" test\"   10.读取配置文件 import ConfigParser config = ConfigParser.ConfigParser() config.read(“ODBC.ini”) #获取配置块 config.sections() #获取配置项 config.options() #获取配置内容 config.iteams() #根据配置快和配置项返回内容 config.get()   写入配置文件 添加配置快 config.add_section() 设置配置项和配置内容 config.set   修改配置项和配置内容 config.set()   删除配置文件 删除配置项 remove_options 删除配置块 remove_section   11.目录的添加删除操作 import os os.mkdir(\"hello\") os.rmdir(\"hello\") os.makedirs(\"hello/world\") os.removedirs(\"hello/world\")   12. 目录的遍历 #!/usr/bin/python # -*- coding: UTF-8 -*- import os def VisitDir(path):     li = os.listdir(path)     for p in li:         pathname = os.path.join(path, p)         if not os.path.isfile(pathname):             VisitDir(pathname)         else:             print pathname             if __name__ == \"__main__\":     path = r\"C:\\windows\"     VisitDir(path)   13. 文件流(输出流 输出到文件) import sys   sys.stdout = open(r\"./hello.txt\", \"a\") print \"\\ngoodbye\\n\" sys.stdout.close()   输入流读取文件输入到屏幕设备上 import sys   sys.stdin = open(r\"./hello.txt\", \"r\") for line in sys.stdin.readlines():     print line   14. 类 定义私有变量用__定义 class Fruit：      def __init__(self):            self.__color = \"red\" #私有属性定义__   15. 私有变量访问方式 print _Fruit__color   16.抽象类使用 def abstract():     raise NotImplementedError(\"abstract\") class Fruit:     def __init__(self):         if self.__class__ is Fruit:             abstract()         print \"Fruit\" class Apple(Fruit):     def __init__(self):         Fruit.__init__(self)         print \"Apple\"     if __name__ == \"__main__\":     apple = Apple(); 17.多态性 #!/usr/bin/python # -*- coding: UTF-8 -*- class Fruit:     def __init__(self, color = None):         self.color = color class Apple(Fruit):     def __init__(self, color = \"red\"):         Fruit.__init__(self,color)         class Banana(Fruit):     def __init__(self, color = \"yellow\"):         Fruit.__init__(self,color)         class FruitShop:     def sellFruit(self, fruit):         if isinstance(fruit, Apple):             print \"sell apple\"             if __name__ == \"__main__\":     shop = FruitShop()     apple = Apple(\"red\")     banana = Banana(\"yellow\")     shop.sellFruit(apple)     shop.sellFruit(banana)  18. python解析HTML #! /usr/bin/env python #coding=utf-8 import BeautifulSoup import urllib2 page = urllib2.urlopen(\"http://www.baidu.com/index.html\") soup = BeautifulSoup.BeautifulSoup(page) print soup 输出 > \"C:\\Python27\\pythonw.exe\" -u \"C:\\Users\\Administrator\\Desktop\\python\\pachong\\pa.py\" <!doctype html><html><head><meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\" /><title>\\xe7\\x99\\xbe\\xe5\\xba\\xa6\\xe4\\xb8\\x80\\xe4\\xb8\\x8b\\xef\\xbc\\x8c\\xe4\\xbd\\xa0\\xe5\\xb0\\xb1\\xe7\\x9f\\xa5\\xe9\\x81\\x93      <\/title><style>html,body{height:100%;}html{overflow-y:auto}#wrapper{position:relative;_position:;min-height:100%}#content{padding-bottom:100px;text-align:center;}#ftCon{height:100px;position:absolute;bottom:44px;text-align:center;width:100%;margin:0 auto;z-index:0;overflow:hidden;}#ftConw{width:720px;margin:0 auto;}body{font:12px arial;text-align:;background:#fff}body,p,form,ul,li{margin:0;padding:0;list-style:none}body,form,#fm{position:relative}td{text-align:left}img{border:0}a{color:#00c}a:active{color:#f60}#u{color:#999;padding:4px 10px 5px 0;text-align:right}#u a{margin:0 5px}#u .reg{margin:0}#m{width:720px;margin:0 auto;}#nv a,#nv b,.btn,#lk{font-size:14px}#fm{padding-left:110px;text-align:left;z-index:1;}input{border:0;padding:0}#nv{height:19px;font-size:16px;margin:0 0 4px;text-align:left;text-indent:137px;}.s_ipt_wr{width:418px;height:30px;display:inline-block;margin-right:5px;background:url(http://s1.bdstatic.com/r/www/img/i-1.0.0.png) no-repeat -304px 0;border:1px solid #b6b6b6;border-color:#9a9a9a #cdcdcd #cdcdcd #9a9a9a;vertical-align:top}.s_ipt{width:405px;height:22px;font:16px/22px arial;margin:5px 0 0 7px;background:#fff;outline:none;-webkit-appearance:none}.s_btn{width:95px;height:32px;padding-top:2px\\9;font-size:14px;background:#ddd url(http://s1.bdstatic.com/r/www/img/i-1.0.0.png);cursor:pointer}.s_btn_h{background-position:-100px 0}.s_btn_wr{width:97px;height:34px;display:inline-block;background:url(http://s1.bdstatic.com/r/www/img/i-1.0.0.png) no-repeat -202px 0;*position:relative;z-index:0;vertical-align:top}#lg img{vertical-align:top;margin-bottom:3px}#lk{margin:33px 0}#lk span{font:14px \"\\xe5\\xae\\x8b\\xe4\\xbd\\x93\"}#lm{height:60px}#lh{margin:16px 0 5px;word-spacing:3px}.tools{position:absolute;top:-4px;*top:10px;right:7px;}#mHolder{width:62px;position:relative;z-index:296;display:none}#mCon{height:18px;line-height:18px;position:absolute;cursor:pointer;padding:0 18px 0 0;background:url(http://s1.bdstatic.com/r/www/img/bg-1.0.0.gif) no-repeat right -134px;background-position:right -136px\\9}#mCon span{color:#00c;cursor:default;display:block}#mCon .hw{text-decoration:underline;cursor:pointer}#mMenu a{width:100%;height:100%;display:block;line-height:22px;text-indent:6px;text-decoration:none;filter:none\\9}#mMenu,#user ul{box-shadow:1px 1px 2px #ccc;-moz-box-shadow:1px 1px 2px #ccc;-webkit-box-shadow:1px 1px 2px #ccc;filter: progid:DXImageTransform.Microsoft.Shadow(Strength=2, Direction=135, Color=\"#cccccc\")\\9;}#mMenu{width:56px;border:1px solid #9b9b9b;list-style:none;position:absolute;right:27px;top:28px;display:none;background:#fff}#mMenu a:hover{background:#ebebeb}#mMenu .ln{height:1px;background:#ebebeb;overflow:hidden;font-size:1px;line-height:1px;margin-top:-1px}#cp,#cp a{color:#666666;}#seth{display:none;behavior:url(#default#homepage)}#setf{display:none;}#sekj{margin-left:14px;}<\/style> <script type=\"text/javascript\">function h(obj){obj.style.behavior='url(#default#homepage)';var a = obj.setHomePage('http://www.baidu.com/');}<\/script><\/head> <body><div id=\"wrapper\"><div id=\"content\"> <div id=\"ie6tipcon\"><\/div> <div id=\"u\"><a href=\"http://www.baidu.com/gaoji/preferences.html\" name=\"tj_setting\">\\xe6\\x90\\x9c\\xe7\\xb4\\xa2\\xe8\\xae\\xbe\\xe7\\xbd\\xae<\/a>|<a href=\"https://passport.baidu.com/v2/?login&amp;tpl=mn&amp;u=http%3A%2F%2Fwww.baidu.com%2F\" name=\"tj_login\" id=\"lb\" onclick=\"return false;\">\\xe7\\x99\\xbb\\xe5\\xbd\\x95<\/a><a href=\"https://passport.baidu.com/v2/?reg&amp;regType=1&amp;tpl=mn&amp;u=http%3A%2F%2Fwww.baidu.com%2F\" target=\"_blank\" name=\"tj_reg\" class=\"reg\">\\xe6\\xb3\\xa8\\xe5\\x86\\x8c<\/a><\/div> <div id=\"m\"><p id=\"lg\"><img src=\"http://www.baidu.com/img/baidu_sylogo1.gif\" width=\"270\" height=\"129\" /><\/p> <p id=\"nv\"><a href=\"http://news.baidu.com\">\\xe6\\x96\\xb0&nbsp;\\xe9\\x97\\xbb<\/a>\\xe3\\x80\\x80<b>\\xe7\\xbd\\x91&nbsp;\\xe9\\xa1\\xb5<\/b>\\xe3\\x80\\x80<a href=\"http://tieba.baidu.com\">\\xe8\\xb4\\xb4&nbsp;\\xe5\\x90\\xa7<\/a>\\xe3\\x80\\x80<a href=\"http://zhidao.baidu.com\">\\xe7\\x9f\\xa5&nbsp;\\xe9\\x81\\x93<\/a>\\xe3\\x80\\x80<a href=\"http://music.baidu.com\">\\xe9\\x9f\\xb3&nbsp;\\xe4\\xb9\\x90<\/a>\\xe3\\x80\\x80<a href=\"http://image.baidu.com\">\\xe5\\x9b\\xbe&nbsp;\\xe7\\x89\\x87<\/a>\\xe3\\x80\\x80<a href=\"http://video.baidu.com\">\\xe8\\xa7\\x86&nbsp;\\xe9\\xa2\\x91<\/a>\\xe3\\x80\\x80<a href=\"http://map.baidu.com\">\\xe5\\x9c\\xb0&nbsp;\\xe5\\x9b\\xbe<\/a><\/p><div id=\"fm\"><form name=\"f\" action=\"/s\"><span class=\"s_ipt_wr\"><input type=\"text\" name=\"wd\" id=\"kw\" maxlength=\"100\" class=\"s_ipt\" /><\/span><input type=\"hidden\" name=\"rsv_bp\" value=\"0\" /><input type=\"hidden\" name=\"rsv_spt\" value=\"3\" /><span class=\"s_btn_wr\"><input type=\"submit\" value=\"\\xe7\\x99\\xbe\\xe5\\xba\\xa6\\xe4\\xb8\\x80\\xe4\\xb8\\x8b\" id=\"su\" class=\"s_btn\" onmousedown=\"this.className='s_btn s_btn_h'\" onmouseout=\"this.className='s_btn'\" /><\/span><\/form><span class=\"tools\"><span id=\"mHolder\"><div id=\"mCon\"><span>\\xe8\\xbe\\x93\\xe5\\x85\\xa5\\xe6\\xb3\\x95<\/span><\/div><\/span><\/span><ul id=\"mMenu\"><li><a href=\"#\" name=\"ime_hw\">\\xe6\\x89\\x8b\\xe5\\x86\\x99<\/a><\/li><li><a href=\"#\" name=\"ime_py\">\\xe6\\x8b\\xbc\\xe9\\x9f\\xb3<\/a><\/li><li class=\"ln\"><\/li><li><a href=\"#\" name=\"ime_cl\">\\xe5\\x85\\xb3\\xe9\\x97\\xad<\/a><\/li><\/ul><\/div> <p id=\"lk\"><a href=\"http://baike.baidu.com\">\\xe7\\x99\\xbe\\xe7\\xa7\\x91<\/a>\\xe3\\x80\\x80<a href=\"http://wenku.baidu.com\">\\xe6\\x96\\x87\\xe5\\xba\\x93<\/a>\\xe3\\x80\\x80<a href=\"http://www.hao123.com\">hao123<\/a><span> | <a href=\"http://www.baidu.com/more/\">\\xe6\\x9b\\xb4\\xe5\\xa4\\x9a&gt;&gt;<\/a><\/span><\/p><p id=\"lm\"><\/p> <\/div><\/div><div id=\"ftCon\"><div id=\"ftConw\"><p><a id=\"seth\" onclick=\"h(this)\" href=\"/\" onmousedown=\"return ns_c({'fm':'behs','tab':'homepage','pos':0})\">\\xe6\\x8a\\x8a\\xe7\\x99\\xbe\\xe5\\xba\\xa6\\xe8\\xae\\xbe\\xe4\\xb8\\xba\\xe4\\xb8\\xbb\\xe9\\xa1\\xb5<\/a><a id=\"setf\" href=\"http://www.baidu.com/cache/sethelp/index.html\" onmousedown=\"return ns_c({'fm':'behs','tab':'favorites','pos':0})\" target=\"_blank\">\\xe6\\x8a\\x8a\\xe7\\x99\\xbe\\xe5\\xba\\xa6\\xe8\\xae\\xbe\\xe4\\xb8\\xba\\xe4\\xb8\\xbb\\xe9\\xa1\\xb5<\/a><span id=\"sekj\"><a href=\"http://www.baidu.com/search/baidukuaijie_mp.html\" target=\"_blank\" onmousedown=\"return ns_c({'fm':'behs','tab':'kuaijie','pos':1})\">\\xe6\\x8a\\x8a\\xe7\\x99\\xbe\\xe5\\xba\\xa6\\xe6\\xb7\\xbb\\xe5\\x8a\\xa0\\xe5\\x88\\xb0\\xe6\\xa1\\x8c\\xe9\\x9d\\xa2<\/a><\/span><\/p><p id=\"lh\"><a href=\"http://e.baidu.com/?refer=888\" onmousedown=\"return ns_c({'fm':'behs','tab':'btlink','pos':2})\">\\xe5\\x8a\\xa0\\xe5\\x85\\xa5\\xe7\\x99\\xbe\\xe5\\xba\\xa6\\xe6\\x8e\\xa8\\xe5\\xb9\\xbf<\/a> | <a href=\"http://top.baidu.com\">\\xe6\\x90\\x9c\\xe7\\xb4\\xa2\\xe9\\xa3\\x8e\\xe4\\xba\\x91\\xe6\\xa6\\x9c<\/a> | <a href=\"http://home.baidu.com\">\\xe5\\x85\\xb3\\xe4\\xba\\x8e\\xe7\\x99\\xbe\\xe5\\xba\\xa6<\/a> | <a href=\"http://ir.baidu.com\">About Baidu<\/a><\/p><p id=\"cp\">&copy;2013 Baidu <a href=\"/duty/\">\\xe4\\xbd\\xbf\\xe7\\x94\\xa8\\xe7\\x99\\xbe\\xe5\\xba\\xa6\\xe5\\x89\\x8d\\xe5\\xbf\\x85\\xe8\\xaf\\xbb<\/a> <a href=\"http://www.miibeian.gov.cn\" target=\"_blank\">\\xe4\\xba\\xacICP\\xe8\\xaf\\x81030173\\xe5\\x8f\\xb7<\/a> <img src=\"http://www.baidu.com/cache/global/img/gs.gif\" /><\/p><\/div><\/div> <\/div><\/body> <script>var bds={se:{},comm : {ishome : 1,sid : \"1758\",user : \"\",username : \"\",sugHost : \"http://suggestion.baidu.com/su\",loginAction : []}}<\/script><script type=\"text/javascript\" src=\"http://s1.bdstatic.com/r/www/cache/global/js/tangram-1.3.4c1.0.js\"><\/script><script type=\"text/javascript\" src=\"http://s1.bdstatic.com/r/www/cache/user/js/u-1.3.4.js\"><\/script> <\/html> <!--640015f8e5e79ae7-->","title":"python学习笔记"},{"content":"最近突然想学习一下Lucene.net方面的内容，了解一下大数据方面的搜索，这个传智播客有相关光盘视频，不过需要积分，这是链接，麻烦各位网友的帮助，现在还缺30个积分的，只要你们点一次就能加一分的，在此谢谢大家了！！","title":"Lucene.net学习帮助"},{"content":"使用SC 工具可以进行windows服务的添加和删除。步骤如下： 如需要添加一个服务，至少需要知道服务名称，可执行程序，依赖等信息。 一、步骤： 1、创建服务 打开命令行工具，输入： C:\\Documents and Settings\\tiger>sc create dmadmin binPath= \"C:\\WINDOWS\\system32\\dmadmin.exe\" type= own start= auto  depend= PlugPlay/RpcSs/dmserver  DisplayName= \"Logical Disk Manager Administrative Service\" create --创建服务操作 dmadmin --服务名称 binPath --可执行程序或DLL,OCX路径 start --是否自动开始 depend --依赖的服务 DisplayName --现实名称 执行结果： [SC] CreateService SUCCESS 表示成功。若没有SUCCESS字样，则表示失败。 2、删除服务 C:\\Documents and Settings\\tiger>sc delete dmadmin [SC] DeleteService SUCCESS 3、注意 参数格式为：参数名称=【空格】参数 等号一定要加空格，等号前不要加空格。所有参数必须严格遵守此规定，否则不成功。 二、sc 使用参数参考 Creates a service entry in the registry and Service Database. SYNTAX: sc create [service name] [binPath= ] <option1> <option2>... CREATE OPTIONS: NOTE: The option name includes the equal sign.  type= <own|share|interact|kernel|filesys|rec>        (default = own)  start= <boot|system|auto|demand|disabled>        (default = demand)  error= <normal|severe|critical|ignore>        (default = normal)  binPath= <BinaryPathName>  group= <LoadOrderGroup>  tag= <yes|no>  depend= <Dependencies(separated by / (forward slash))>  obj= <AccountName|ObjectName>        (default = LocalSystem)  DisplayName= <display name>  password= <password>","title":"使用添加删除windows的系统服务的例子"},{"content":"boost库中sleep有两个方法: 1. 这个方法只能在线程中用, 在主线程中用无效. 原型: void sleep(TimeDuration const& rel_time);void sleep(system_time const& abs_time);实例: boost::this_thread::sleep(boost::posix_time::seconds(2));    // 这种更好用boost::this_thread::sleep(boost::get_system_time() + boost::posix_time::seconds(2));2. 在主线程中使用 原型: sleep(const system_time& xt);实例: boost::thread::sleep(boost::get_system_time() + boost::posix_time::seconds(5));","title":"【Boost】boost库中sleep方法详解"},{"content":"假设给定一个关键词rob，如果某一个单词中包含此字符串，那么就断定此字符串为bad word。如problem就包含rob，那么它就是bad word。其实这种叙述是：“判断一个字符串是否是另一个字符串的子串”的另外一种描述。熟悉字符串匹配的人都知道，这个问题可以用KMP算法很快就能够解决。但是就像我们不嫌弃自己的钱多的一样，方法多了，路子就多了。所以决定应用后缀trie来解决这个问题。后缀trie是trie树的一种变种形式。给定字符串S=s1s2s3s4....sn，把si...sn称作S的一个后缀，其中 1<=i<=n，按照次序，我们把S的每一个后缀都插入到一个trie树中，最终形成的树，就叫S的后缀trie树。对于单词problem的后缀依次为： problem, roblem, oblem, blem, lem, em , m.给出这个单词的后缀trie： 建立好了后缀trie便可以清楚的看到，在树中寻找rob是相当容易的事情，只需要3次比对，也就是length of “rob”的长度。可以说是如果trie建立好以后，寻找什么都是很快的。但是在建立后缀trie的时候却要耗费很大的空间和很长的时间，这就是为什么后缀trie没有被人们所亲睐的原因。仔细看图，体会一下它的奇妙之处吧，它涵盖了problem中以任何字母开头，在一定长度内的任何子串。下面给出代码，它的时间和空间复杂度都在O(n^2). #include<stdio.h>#include<stdlib.h>#include<string.h>#define CHILD_NUM 26typedef struct trie_node{\tchar key;\tstruct trie_node *child[CHILD_NUM];}TrieNode, *TrieTree;TrieNode *create_node(char key) {\tTrieNode *temp = (TrieNode*)malloc(sizeof(TrieNode));\ttemp->key = key;\tfor(int i = 0; i < CHILD_NUM; i++) {\t\ttemp->child[i] = NULL;\t}\treturn temp;}void insert_trie(TrieTree T, char *p_word) {\tTrieNode *p = T;\twhile(*p_word) {\t\tif(p->child[*p_word - 'a'] == NULL) {\t\t\tp->child[*p_word - 'a'] = create_node(*p_word);\t\t}\t\tp = p->child[*p_word - 'a'];\t\tp_word++;\t}}int search_trie(TrieTree T, char *p_word) {\tTrieNode *p = T;\twhile(p && *p_word) {\t\tif(p->child[*p_word - 'a'] == NULL) {\t\t\treturn 0;\t\t} else {\t\t\tp = p->child[*p_word - 'a'];\t\t\tp_word++;\t\t}\t}\tif(p == NULL && *p_word != '\\0') {\t\treturn 0;\t} else {\t\treturn 1;\t}}void main() {\tTrieTree T = create_node(' ');\tchar word[] = \"problem\";\tchar *p = word;\tchar bad_word[] = \"rob\";\tint len = strlen(word);\tint i;\tfor(i = 0; i < len; i++) {\t\tinsert_trie(T, p + i);\t}\tif(search_trie(T, bad_word)) {\t\tprintf(\"this word is bad word!\\n\");\t} else {\t\tprintf(\"this word is good word!\\n\");\t}}","title":"找出文本中存在的坏单词-后缀trie"},{"content":"java7 NIO2新增了文件系统的相关事件处理API，为目录，文件新增修改删除等事件添加事件处理。 package com.mime;import java.io.IOException;import java.nio.file.FileSystems;import java.nio.file.Path;import java.nio.file.Paths;import java.nio.file.StandardWatchEventKinds;import java.nio.file.WatchEvent;import java.nio.file.WatchEvent.Kind;import java.nio.file.WatchKey;import java.nio.file.WatchService;public class NIO2WatchService {\t\t//WatchService 是线程安全的，跟踪文件事件的服务，一般是用独立线程启动跟踪\tpublic void watchRNDir(Path path) throws IOException, InterruptedException {\t\ttry (WatchService watchService = FileSystems.getDefault().newWatchService()) {\t\t\t//给path路径加上文件观察服务\t\t\tpath.register(watchService, StandardWatchEventKinds.ENTRY_CREATE,\t\t\t\t\tStandardWatchEventKinds.ENTRY_MODIFY,\t\t\t\t\tStandardWatchEventKinds.ENTRY_DELETE);\t\t\t// start an infinite loop\t\t\twhile (true) {\t\t\t\t// retrieve and remove the next watch key\t\t\t\tfinal WatchKey key = watchService.take();\t\t\t\t// get list of pending events for the watch key\t\t\t\tfor (WatchEvent<?> watchEvent : key.pollEvents()) {\t\t\t\t\t// get the kind of event (create, modify, delete)\t\t\t\t\tfinal Kind<?> kind = watchEvent.kind();\t\t\t\t\t// handle OVERFLOW event\t\t\t\t\tif (kind == StandardWatchEventKinds.OVERFLOW) {\t\t\t\t\t\tcontinue;\t\t\t\t\t}\t\t\t\t\t//创建事件\t\t\t\t\tif(kind == StandardWatchEventKinds.ENTRY_CREATE){\t\t\t\t\t\t\t\t\t\t\t}\t\t\t\t\t//修改事件\t\t\t\t\tif(kind == StandardWatchEventKinds.ENTRY_MODIFY){\t\t\t\t\t\t\t\t\t\t\t}\t\t\t\t\t//删除事件\t\t\t\t\tif(kind == StandardWatchEventKinds.ENTRY_DELETE){\t\t\t\t\t\t\t\t\t\t\t}\t\t\t\t\t// get the filename for the event\t\t\t\t\tfinal WatchEvent<Path> watchEventPath = (WatchEvent<Path>) watchEvent;\t\t\t\t\tfinal Path filename = watchEventPath.context();\t\t\t\t\t// print it out\t\t\t\t\tSystem.out.println(kind + \" -> \" + filename);\t\t\t\t}\t\t\t\t// reset the keyf\t\t\t\tboolean valid = key.reset();\t\t\t\t// exit loop if the key is not valid (if the directory was\t\t\t\t// deleted, for\t\t\t\tif (!valid) {\t\t\t\t\tbreak;\t\t\t\t}\t\t\t}\t\t}\t}\t/**\t * @param args\t */\tpublic static void main(String[] args) {\t\tfinal Path path = Paths.get(\"/tmp\");\t\tNIO2WatchService watch = new NIO2WatchService();\t\ttry {\t\t\twatch.watchRNDir(path);\t\t} catch (IOException | InterruptedException ex) {\t\t\tSystem.err.println(ex);\t\t}\t}}","title":"java7 NIO2(6) watching service API"},{"content":"java7NIO2 随机文件访问API package com.mime;import java.io.IOException;import java.nio.ByteBuffer;import java.nio.CharBuffer;import java.nio.MappedByteBuffer;import java.nio.channels.FileChannel;import java.nio.channels.FileLock;import java.nio.channels.SeekableByteChannel;import java.nio.charset.CharacterCodingException;import java.nio.charset.Charset;import java.nio.charset.CharsetDecoder;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.nio.file.StandardOpenOption;import java.nio.file.attribute.FileAttribute;import java.nio.file.attribute.PosixFilePermission;import java.nio.file.attribute.PosixFilePermissions;import java.util.EnumSet;import java.util.Set;public class NIO2RandomAccessFile {\t/**\t * @param args\t */\tpublic static void main(String[] args) {\t\tPath path = Paths.get(\"/tmp\", \"story.txt\");\t\t// create the custom permissions attribute for the email.txt file\t\tSet<PosixFilePermission> perms = PosixFilePermissions\t\t\t\t.fromString(\"rw-r------\");\t\tFileAttribute<Set<PosixFilePermission>> attr = PosixFilePermissions\t\t\t\t.asFileAttribute(perms);\t\t// write a file using SeekableByteChannel\t\ttry (SeekableByteChannel seekableByteChannel = Files.newByteChannel(\t\t\t\tpath, EnumSet.of(StandardOpenOption.WRITE,\t\t\t\t\t\tStandardOpenOption.TRUNCATE_EXISTING), attr)) {\t\t\tByteBuffer buffer = ByteBuffer\t\t\t\t\t.wrap(\"Rafa Nadal produced another masterclass of clay-court tennis to win his fifth French Open title ...\"\t\t\t\t\t\t\t.getBytes());\t\t\tint write = seekableByteChannel.write(buffer);\t\t\tSystem.out.println(\"Number of written bytes: \" + write);\t\t\tbuffer.clear();\t\t} catch (IOException ex) {\t\t\tSystem.err.println(ex);\t\t}\t\t// read a file using SeekableByteChannel\t\ttry (SeekableByteChannel seekableByteChannel = Files.newByteChannel(\t\t\t\tpath, EnumSet.of(StandardOpenOption.READ), attr)) {\t\t\tByteBuffer buffer = ByteBuffer.allocate(12);\t\t\tString encoding = System.getProperty(\"file.encoding\");\t\t\tbuffer.clear();\t\t\t//随机访问定位API//\t\t\tseekableByteChannel.position();//\t\t\tseekableByteChannel.truncate(100);\t\t\twhile (seekableByteChannel.read(buffer) > 0) {\t\t\t\tbuffer.flip();\t\t\t\tSystem.out.print(Charset.forName(encoding).decode(buffer));\t\t\t\tbuffer.clear();\t\t\t}\t\t\t// seekableByteChannel.position(seekableByteChannel.size()/2);\t\t} catch (IOException ex) {\t\t\tSystem.err.println(ex);\t\t}\t\tMappedByteBuffer buffer = null;\t\ttry (FileChannel fileChannel = (FileChannel.open(path,\t\t\t\tEnumSet.of(StandardOpenOption.READ)))) {\t\t\t//文件锁\t\t\tFileLock lock = fileChannel.lock();\t\t\tbuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0,\t\t\t\t\tfileChannel.size());\t\t\t//文件channel操作，从一个channel通道把数据传输到另外一个channel//\t\t\tfileChannel_from.transferTo(0L, fileChannel_from.size(), fileChannel_to);\t\t\tlock.release();\t\t} catch (IOException ex) {\t\t\tSystem.err.println(ex);\t\t}\t\tif (buffer != null) {\t\t\ttry {\t\t\t\tCharset charset = Charset.defaultCharset();\t\t\t\tCharsetDecoder decoder = charset.newDecoder();\t\t\t\tCharBuffer charBuffer = decoder.decode(buffer);\t\t\t\tString content = charBuffer.toString();\t\t\t\tSystem.out.println(content);\t\t\t\tbuffer.clear();\t\t\t} catch (CharacterCodingException ex) {\t\t\t\tSystem.err.println(ex);\t\t\t}\t\t}\t}}","title":"java7 NIO2(7) random access file API"},{"content":"// //  main.cpp //  AUTO_PRO // //  Created by yanzhengqing on 12-12-11. //  Copyright (c) 2012年 yanzhengqing. All rights reserved. // #include <iostream> #include <string> using namespace std; /***  *int memcmp(buf1, buf2, count) - compare memory for lexical order  *  *Purpose:  *       Compares count bytes of memory starting at buf1 and buf2  *       and find if equal or which one is first in lexical order.  *  *Entry:  *       void *buf1, *buf2 - pointers to memory sections to compare  *       size_t count - length of sections to compare  *  *Exit:  *       returns < 0 if buf1 < buf2  *       returns  0  if buf1 == buf2  *       returns > 0 if buf1 > buf2  *  *Exceptions:  *  *******************************************************************************/ ///////////////////////////////////////////////////////////////////////////////// /*说明：   1. __cdecl 是C Declaration的缩写（declaration，声明），表示C语言默认的函数调用方法：所有参数从右到左依次入栈，这些参数由调用者清除，称为手动清栈。被调用函数不会要求调用者传递多少参数，调用者传递过多或者过少的参数，甚至完全不同的参数都不会产生编译阶段的错误。   2.  对从两个内存地址开始的n个字符进行比较   3.  按照ANSI(American National Standards Institute)标准，不能对void指针进行算法操作，即不能对void指针进行如p++的操作,所以需要转换为具体的类型指针来操作,例如char *。（引用网友的结论）   4.  size_t 类型定义在cstddef头文件中，该文件是C标准库的头文件stddef.h的C++版。它是一个与机器相关的unsigned类型，其大小足以保证存储内存中对象的大小。 */ int __cdecl memcmp (                     const void * buf1,                     const void * buf2,                     size_t count                     ) {     if (!count)         return(0);          while ( --count && *(char *)buf1 == *(char *)buf2 ) {         buf1 = (char *)buf1 + 1;         buf2 = (char *)buf2 + 1;     }          return( *((unsigned char *)buf1) - *((unsigned char *)buf2) );//返回的是两个字符accsi的差值,当返回值为零的时候表示字符串相等 } int main() {     int k = 0;     const char src[50] = \"blog.csdn.net/barry_yan\";     const char brc[50] = \"blog.csdn.net/barry_yan\";          k = memcmp(src,brc,strlen(src)+1);     if(!k)     {         cout<<\"两个字符串相等\"<<endl;     }          return 0; }","title":"memcmp源码"},{"content":"//OPT/*算法思想：1.求出当前页架中那个是可以置换的，这就要求分析匹配当前页架中的页面和访问序列，\t\t\t看访问序列中接下来页面中最近访问的位置是哪，然后比较大小。*/#include<iostream>#include<iomanip>using namespace std;void discard(int Array[][19],int page[],int pagenumber[],int max);//置换页面函数int OPT(int pagenumber[],int order);//判断当前页架有没有当前访问页面int selectPage(int page[],int pagenumber[],int now,int max);//选择可置换的页面int main(){\tint Array[4][19];//用来存放页面访问的详细信息\tint page[19] = {7,0,1,2,0,3,0,4,2,3,0,3,2,1,2,0,1,7,0};//页面访问次序数组\tint pagenumber[3] = {-1,-1,-1};//页架\tint max = 19;//页面的数量\tcout<<\"页面访问序列如下：\"<<endl;\tfor(int i = 0;i < 19;i++){\t\tArray[3][i] = -1;//将页面是否中断全部设置成缺页中断\t\tcout<<setw(3)<<page[i];\t}\tdiscard( Array,page,pagenumber,max);\tcout<<endl;\tcout<<endl;\t//输出页面访问详细过程\tcout<<\"输出结果如下表（-2）代表没有缺页中断！\"<<endl;\tint LackPageNumber = 0;\tfor(int j = 0; j < 4;j++){\t\tfor(int k = 0; k  < 19;k++){\t\t\tcout<<setw(3)<<Array[j][k];\t\t\tif(j == 3){\t\t\t\tif(Array[j][k] != -2)\t\t\t\t\tLackPageNumber++;\t\t\t}\t\t}\t\tcout<<endl;\t}\tcout<<\"缺页次数：\"<<LackPageNumber<<endl<<endl;\treturn 0;}void discard(int Array[][19],int page[],int pagenumber[],int max)//置换页面函数{\tfor(int i = 0;i < max;i++){\t\t\t\t\tif(OPT(pagenumber,page[i])>-1){\t\t\t\tArray[0][i] = pagenumber[0];\t\t\t\tArray[1][i] = pagenumber[1];\t\t\t\tArray[2][i] = pagenumber[2];\t\t\t\tArray[3][i] = -2;//表示非缺页\t\t\t}else\t\t\t{//选择最远使用的页面，将这个页面置换掉\t\t\t\tpagenumber[selectPage(page,pagenumber, i,max)] = page[i];\t\t\t\tArray[0][i] = pagenumber[0];\t\t\t\tArray[1][i] = pagenumber[1];\t\t\t\tArray[2][i] = pagenumber[2];\t\t\t\tArray[3][i] = -1;//表示缺页\t\t\t}\t}}int OPT(int pagenumber[],int order){//判断当前访问的页面是否在页架中\tif(pagenumber[0] == order)\t\treturn 0;\telse if(pagenumber[1] == order)\t\treturn 1;\telse if(pagenumber[2] == order)\t\treturn 2;\telse\t\treturn -1;}int selectPage(int page[],int pagenumber[],int now,int max){//选择可置换的页面\tint aay[3]  = {-1,-1,-1};\t//存放 pagenumber[]中页面最近一次使用的位置，用来判断哪个页面是最佳置换的页面\t//（这个数组设置的非常好，应为必须每次都应重算页架中页面下次下次访问的位置，在这定义并初始化）\tfor(int i = now;i <max;i++){\t\t//判断是从当前位置往后找，所以其实位置就是当前位置\t\tif(pagenumber[0] == page[i]){\t\t\taay[0] = i;\t\t\tbreak;\t\t}\t}\tfor(int j = now;j <max;j++){\t\tif(pagenumber[1] == page[j]){\t\t\taay[1] = j;\t\t\tbreak;\t\t}\t}\tfor(int k = now;k <max;k++){\t\tif(pagenumber[2] == page[k]){\t\t\taay[2] = k;\t\t\tbreak;\t\t}\t}\t/*这里最重要，有了这个可以简化discard函数，可以去掉if(i <3)这个条件，\t如果aay的值是-1，则表明接下来的访问序列中没有页架中当前的页面，所以可以直接结束后面的判断，返回这个位置\t*/\tif(aay[0] == -1)\t\treturn 0;\telse if(aay[1] == -1)\t\treturn 1;\telse if(aay[2] == -1)\t\treturn 2;\t/*都不等于-1的时候就要判断哪个的下次访问位置最远，就将这个序列置换\t*/\tint tmp = aay[0],lo=0;\tfor(int t = 1;t < 3;t++){\t\tif(tmp <aay[t]){\t\t\ttmp = aay[t];\t\t\tlo = t;\t\t}\t}\treturn lo;}","title":"页面淘汰算法OPT"},{"content":"java/oracle日期处理 public class Test{  public static void main (String args []){                java.util.Date a = new java.util.Date();  System.out.println(a);  java.sql.Date b = new java.sql.Date(a.getTime());  System.out.println(b); \\\\ java.sql.Time c = new java.sql.Time(a.getTime());  System.out.println(c);  java.sql.Timestamp d=new java.sql.Timestamp(a.getTime());  System.out.println(d);  }  }  Mon Apr 03 18:00:34 CST 2006  2006-04-03  18:00:34  2006-04-03 18:00:34.388  1.         oracle默认的系统时间就是sysdate函数，储存的数据形如25-3-200510:55:33  2.         java 中取时间的对象是java.util.Date。  3.         oracle中对应的时间对象是java.util.Date，java.sql.Time，java.sql.Timestamp、它们都是是java.util.Date的子类。  4.         oracle中与date操作关系最大的就是两个转换函数：to_date(),to_char()。to_date()一般用于写入日期到数据库时用到的函数。to_char()一般用于从数据库读入日期时用到的函数。  DATE、TIME 和 TIMESTAMP：  SQL 定义了三种与时间有关的数据类型：DATE 由日、月和年组成。TIME 由小时、分钟和秒组成。 TIMESTAMP 将 DATE 和 TIME 结合起来，并添加了纳秒域。  标准 Java 类 java.util.Date 可提供日期和时间信息。但由于该类包含 DATE 和 TIME 信息而没有 TIMESTAMP 所需的纳秒，因此并不与上述三种 SQL 类型完全相配。  因此我们定义了 java.util.Date 的三种子类。它们是：  1.       有关 SQL DATE 信息的 java.sql.Date  2.       有关 SQL TIME 信息的 java.sql.Time  3.       有关 SQL TIMESTAMP 信息的 java.sql.Timestamp  对于 java.sql.Time，java.util.Time 基本类的小时、分钟、秒和毫秒域被设置为零。 对于 java.sql.Date，java.util.Date 基本类的年、月和日域被分别设置为 1970 年 1 月 1 日。这是在 Java 新纪元中的“零”日期。java.sql.date中的日期可以和标准的SQL语句中含有日期的字段进行比较.java.sql.Timestamp 类通过添加纳秒域来扩展 java.util.Date。  oracle中两个转换函数：  1.       to_date() 作用将字符类型按一定格式转化为日期类型：  具体用法:to_date(''2004-11-27'',''yyyy-mm-dd''),前者为字符串，后者为转换日期格式，注意，前后两者 要以一对应。如;to_date(''2004-11-27 13:34:43'', ''yyyy-mm-dd hh24:mi:ss'') 将得到具体的时间。  2.       to_char():将日期转按一定格式换成字符类型：  具体用法:to_char(sysdate,''yyyy-mm-dd hh24:mi:ss'')  to_date()与24小时制表示法及mm分钟的显示：  在使用Oracle的to_date函数来做日期转换时，很多Java程序员也许会直接的采用“yyyy-MM-dd HH:mm:ss”的格式作为格式进行转换，但是在Oracle中会引起错误：“ORA 01810 格式代码出现两次”。  如：select to_date('2005-01-01 13:14:20','yyyy-MM-dd HH24:mm:ss') from dual;  原因是SQL中不区分大小写，MM和mm被认为是相同的格式代码，所以Oracle的SQL采用了mi代替分钟。 oracle默认的系统时间就是sysdate函数，储存的数据形如2005-3-2510:55:33，java 中取时间的对象是java.util.Date。  select to_date('2005-01-01 13:14:20','yyyy-MM-dd HH24:mi:ss') from dual  在java对oracle的操作中，对日期字段操作的例子：  表 book 中有name varchar2(20)//书籍名称,buydate Date //购买日期 两个字段。  已经创建了数据库连接Connection conn;  方法一、使用java.sql.Date实现比较简单的yyyy-mm-dd格式日期。java.sql.Date不支持时间格式。切记不要使用new java.sql.Date(int year,int month,int date),因为还要处理时间差问题。  PreparedStatement pstmt = conn.prepareStatement(\"insert into book (name,buydate) values (?,?)\");  java.sql.Date buydate=java.sql.Date.valueOf(\"2005-06-08\");  pstmt.setString(1, \"Java编程思想\");  pstmt.setDate(2,buydate );  pstmt.execute();  方法二、使用java.sql.Timestamp,同上不使用new Timestamp(....)  PreparedStatement pstmt = conn.prepareStatement(\"insert into book (name,buydate) values (?,?)\");  java.sql.Timestamp buydate=java.sql.Timestamp.valueOf(\"2004-06-08 05:33:99\");  pstmt.setString(1, \"Java编程思想\");  pstmt.setTimestamp(2,buydate );  pstmt.execute();  方法三、使用oracle 的to_date内置函数  PreparedStatement pstmt = conn.prepareStatement(\"insert into book (name,buydate) values (?,to_date(?, 'yyyy-mm-dd hh24:mi:ss')\");  String buydate=\"2004-06-08 05:33:99\";  pstmt.setString(1, \"Java编程思想\");  pstmt.setString(2,buydate );  pstmt.execute();  附:oracle日期格式参数含义说明  d:一周中的星期几  day:天的名字，使用空格填充到9个字符  dd:月中的第几天  ddd:年中的第几天  dy:天的简写名  iw: ISO标准的年中的第几周  iyyy:ISO标准的四位年份  yyyy:四位年份  yyy,yy,y:年份的最后三位，两位，一位  hh: 小时，按12小时计  hh24:小时，按24小时计  mi:分  ss:秒  mm:月  mon:月份的简写  month:月份的全名  w:该月的第几个星期  ww:年中的第几个星期 ","title":"java/oracle日期处理"},{"content":"//FIFO#include<iomanip>#include<iostream>using namespace std;void discard(int Array[][19],int pagenumber[],int page[],int max);int FIFO(int pagenumber[],int order);int main(){\tint Array[4][19];\tint page[19] = {7,0,1,2,0,3,0,4,2,3,0,3,2,1,2,0,1,7,0};\tint pagenumber[3] = {-1,-1,-1};\t//请求求页面序列\tcout<<\"请求页面访问序列为：\"<<endl;\tfor(int i = 0;i < 19;i++){\t\tArray[3][i] = -1;\t\t\tcout<<setw(3)<<page[i];\t}\tint max = 19;\tdiscard( Array, pagenumber,page,max);\tcout<<endl;\tcout<<endl;\t//输出\tcout<<\"输出结果如下表（-2）代表没有缺页中断！\"<<endl;\tint LackPageNumber = 0;\tfor(int j = 0; j < 4;j++){\t\tfor(int k = 0; k  < 19;k++){\t\t\tcout<<setw(3)<<Array[j][k];\t\t\tif(j == 3){\t\t\t\tif(Array[j][k] != -2)\t\t\t\t\tLackPageNumber++;\t\t\t}\t\t}\t\tcout<<endl;\t}\tcout<<\"缺页次数：\"<<LackPageNumber<<endl;\treturn 0;}void discard(int Array[][19],int pagenumber[],int page[],int n){\tfor(int tt = 0;tt < n;tt++){\t\tif(FIFO(pagenumber,page[tt])> -1){\t\tArray[0][tt] = pagenumber[0];\t\tArray[1][tt] = pagenumber[1];\t\tArray[2][tt] = pagenumber[2];\t\tArray[3][tt] = -2;//表示非缺页\t}\telse{\t\tArray[0][tt] = page[tt];\t\tArray[1][tt] = pagenumber[0];\t\tArray[2][tt] = pagenumber[1];\t\tArray[3][tt] =-1;\t\tfor(int ii = 2;ii >0;ii--){\t\t\tpagenumber[ii] = pagenumber[ii-1];\t\t}\t\tpagenumber[0] =page[tt];\t}\t}}int FIFO(int pagenumber[],int order){\tif(pagenumber[0] == order)\t\treturn 0;\telse if(pagenumber[1] == order)\t\treturn 1;\telse if(pagenumber[2] == order)\t\treturn 2;\telse\t\treturn -1;}","title":"页面淘汰算法FIFO"},{"content":"Linux编程中创建进程一般可以使用fork()与vfork()，而创建进程时，需要拷贝资源。 Linux中三种拷贝资源方式： （1）共享：新的进程与老进程共享资源。 （2）直接拷贝：将父进程的资源直接拷贝到子进程中。子进程创建后，父进程拥有相同的结构。 （3）写时复制(Copy on Write)：把真正的虚拟内存拷贝推迟到两个进程中的任一个试图写虚拟页的时候。 这里，fork采用的写时复制技术，vfork采用的则是完全共享的技术。 使用fork创建新进程时，父子进程谁先执行需要看操作系统内核的调度算法，但是vfork创建新进程时，父进程将被暂时阻塞。 举个例子说明： 结果： 说明： 这是用vfork创建的新进程，可以看见，程序并不是像我们想象的那样，子进程先暂停，父进程先执行。而是父进程阻塞了，子进程先执行，sleep函数并为起到作用，这就是vfork创建进程时候的特点：父进程阻塞。 如果这个程序换做fork来执行，那么程序将是先执行父进程。","title":"fork与vfork"},{"content":"原文地址:http://blog.csdn.net/yangxiaojun9238/article/details/7337293 １、将java.util.Date 转换为 java.sql.Date java.util.Date utilDate = new java.util.Date(); java.sql.Date sqlDate = new java.sql.Date(utilDate.getTime()); ２、若要插入到数据库并且相应的字段为Date类型 可使用PreparedStatement.setDate(int ,java.sql.Date)方法 其中的java.sql.Date可以用上面的方法得到 也可以用数据库提供TO_DATE函数 比如 现有 ud TO_DATE(new SimpleDateFormat().format(ud,\"yyyy-MM-dd HH:mm:ss\"), \"YYYY-MM-DD HH24:MI:SS\") 注意java中表示格式和数据库提供的格式的不同 sql=\"update tablename set timer=to_date('\"+x+\"','yyyymmddhh24miss') where .....\" 这里的x为变量为类似:20080522131223 ３、如何将\"yyyy-mm-dd\"格式的字符串转换为java.sql.Date 方法１ SimpleDateFormat bartDateFormat = new SimpleDateFormat(\"yyyy-MM-dd\"); String dateStringToParse = \"2007-7-12\"; try{ java.util.Date date = bartDateFormat.parse(dateStringToParse); java.sql.Date sqlDate = new java.sql.Date(date.getTime()); System.out.println(sqlDate.getTime()); } catch (Exception ex) { System.out.println(ex.getMessage()); } 方法２ String strDate = \"2002-08-09\"; StringTokenizer st = new StringTokenizer(strDate, \"-\"); java.sql.Date date=new java.sql.Date(Integer.parseInt(st.nextToken())); java.util.Date和java.sql.Date的区别 java.sql.Date,java.sql.Time和java.sql.Timestamp三个都是java.util.Date的子类（包装类）。 但是为什么java.sql.Date类型的值插入到数据库中Date字段中会发生数据截取呢？ java.sql.Date是为了配合SQL DATE而设置的数据类型。“规范化”的java.sql.Date只包含年月日信息，时分秒毫秒都会清零。格式类似：YYYY-MM-DD。当我们调用ResultSet的getDate()方法来获得返回值时，java程序会参照\"规范\"的java.sql.Date来格式化数据库中的数值。因此，如果数据库中存在的非规范化部分的信息将会被劫取。 在sun提供的ResultSet.java中这样对getDate进行注释的： Retrieves the of the designated column in the current row of this <code>ResultSet<\/code> object as a “java.sql.Date” object in the Java programming language. 同理。如果我们把一个java.sql.Date值通过PrepareStatement的setDate方法存入数据库时，java程序会对传入的java.sql.Date规范化，非规范化的部分将会被劫取。然而，我们java.sql.Date一般由java.util.Date转换过来，如：java.sql.Date sqlDate=new java.sql.Date(new java.util.Date().getTime()). 显然，这样转换过来的java.sql.Date往往不是一个规范的java.sql.Date.要保存java.util.Date的精确值， 我们需要利用java.sql.Timestamp. Calendar: Calendar calendar=Calendar.getInstance(); //获得当前时间，声明时间变量 int year=calendar.get(Calendar.YEAR); //得到年 int month=calendar.get(Calendar.MONTH); //得到月，但是，月份要加上1 month=month+1; int date=calendar.get(Calendar.DATE); //获得日期 String today=\"\"+year+\"-\"+month+\"-\"+date+\"\"; 字符串转换成日期时间格式 //日期时间格式：yyyy-MM-dd hh:mm:ss String time =\"1900-02-21 12:23:33\"; //将字符串转换为日期和时间 SimpleDateFormat dateformat = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\"); //生成的日期和时间 Date date = dateformat .parse(time);","title":"java和oracle日期互转 (转)"},{"content":"准备实现gof上面一个迭代器模式，用到了上面的List基本类，但是一直对赋值函数和拷贝构造函数不是很熟悉，就研读了一下effective c++的关于这方面的一章，颇有收获，抽取了我认为精华的部分分享给大家。由于一直对c++这一类的用法不是很熟悉，有错误或者优化或者需要特别强调的地方希望朋友们帮忙指出来，我再仔细分析改正。 1，拷贝构造函数仍然是构造函数，赋值函数不是构造函数 故而例如一个string类。 string a; string b = a;//由于b还没有被创建，故而调用的是拷贝构造函数。针对这种情况一般写为string b(a); string c; b = c;//由于b已经被创建，调用的是赋值函数。 被赋值的对象存不存在是判断调用的拷贝构造还是赋值函数的根本。 2，什么时候需要拷贝构造函数和赋值函数？ 例如当一个对象中有动态分配的内存的时候，或者简单说来拥有一个成员指针ptr。如果不加拷贝构造函数，而直接调用默认的拷贝构造函数的话，这样执行的是对象的位拷贝，将两个对象的比特流一模一样，于是两个对象分别有一个指针ptr，它们指向实际上是同一块内存区域。当调用析构函数释放ptr的内存的时候，会被释放两次，这显然是不合理的。 摘录effective c++的原话： 解决这类指针混乱问题的方案在于，只要类里有指针时，就要写自己版本的拷贝构造函数和赋值操作符函数。在这些函数里，你可以拷贝那些被指向的数据结构，从而使每个对象都有自己的拷贝；或者你可以采用某种引用计数机制（见条款 m29）去跟踪当前有多少个对象指向某个数据结构。引用计数的方法更复杂，而且它要求构造函数和析构函数内部做更多的工作，但在某些（虽然不是所有）程序里，它会大量节省内存并切实提高速度。 如果你真的很确信不需要拷贝构造和赋值的时候，可以只声明这些函数（声明为private成员）而不去定义（实现）它们。这就防止了会有人去调用它们，也防止了编译器去生成它们。这样在你试图进行赋值或者copy的时候，编译器会给你相应的错误信息，避免你由于无意而进行这些操作 3，构造函数 尽量使用成员初始化列表而不用构造函数赋值。对象的创建分两步，首先是数据成员初始化，然后调用构造函数体。这样如果类的对象成员的初始化在构造函数中的话，就会被初始化两次，一次调用默认构造函数，一次调用赋值函数。如果在成员初始化列表中，就会仅仅调用一次拷贝构造函数来初始化。特别是const和引用数据成员只能用初始化，不能被赋值。“插一句关于const引用的总结：const引用只是表明不能通过此引用间接的改变被引用的对象，对象能不能被更改，取决于对象本身，仅仅是通过引用不可以更改，const放前放后没有关系。\" 摘录的effective c++的原话： 养成尽可能使用成员初始化列表的习惯，不但可以满足const和引用成员初始化的要求，还可以大大减少低效地初始化数据成员的机会。但有一种情况下，对类的数据成员用赋值比用初始化更合理。这就是当有大量的固定类型的数据成员要在每个构造函数里以相同的方式初始化的时候。 manydatambrs::manydatambrs() : a(1), b(1), c(1), d(1), e(1), f(1), g(1), h(1), i(0), j(0), k(0), l(0), m(0) { ... } manydatambrs::manydatambrs(const manydatambrs& x) : a(1), b(1), c(1), d(1), e(1), f(1), g(1), h(1), i(0), j(0), k(0), l(0), m(0) { ... } 写一个单独的init函数，让两个函数都去调用情况似乎会更好一些。 void manydatambrs::init() { a = b = c = d = e = f = g = h = 1; i = j = k = l = m = 0; } 4，赋值运算 函数定义的写法： string& string::operator=(const string& rhs) { if (this == &rhs) return *this; ...//如果是派生类，还需要调用基类的赋值函数base::operator=(rhs); //释放自身动态分配的内存，将rhs的成员赋值给自己 return *this; // 返回左边的对象 } 5,拷贝构造函数 string::string(const string& rhs) { *this = rhs;//调用赋值函数 } 当定义自己的赋值运算符时，必须返回赋值运算符左边参数的引用，*this。如果不这样做，就会导致不能连续赋值，或导致调用时的隐式类型转换不能进行，或两种情况同时发生。 6，技巧总结： 类里有指针的时候，就要写自己版本的拷贝构造和赋值函数。 如果确认不会有拷贝和赋值的情况，那就声明这些函数为private类型，阻止编译器生成默认的。 尽量采用成员初始化列表，少使用构造函数赋值。针对const和引用数据成员，必须采用初始化列表。 赋值函数，需要判定是否自己对自己赋值，如果是派生类需要调用基类的赋值函数，如果自己已经alloc了内存，需要首先释放，然后赋值，最好返回*this. 拷贝构造函数可以通过调用赋值函数来实现构造操作。","title":"c++拷贝构造函数和赋值函数"},{"content":"// //  main.cpp //  AUTO_PRO // //  Created by yanzhengqing on 12-12-11. //  Copyright (c) 2012年 yanzhengqing. All rights reserved. // #include <iostream> using namespace std; /***  *char *memchr(buf, chr, cnt) - search memory for given character.  *  *Purpose:  *       Searches at buf for the given character, stopping when chr is  *       first found or cnt bytes have been searched through.  *  *Entry:  *       void *buf  - memory buffer to be searched  *       int chr    - character to search for  *       size_t cnt - max number of bytes to search  *  *Exit:  *       returns pointer to first occurence of chr in buf  *       returns NULL if chr not found in the first cnt bytes  *  *Exceptions:  *  *******************************************************************************/ ///////////////////////////////////////////////////////////////////////////////// /*说明：   1. __cdecl 是C Declaration的缩写（declaration，声明），表示C语言默认的函数调用方法：所有参数从右到左依次入栈，这些参数由调用者清除，称为手动清栈。被调用函数不会要求调用者传递多少参数，调用者传递过多或者过少的参数，甚至完全不同的参数都不会产生编译阶段的错误。   2.  在从s开始的n个字节内查找c第一次出现的地址并返回，若未找到则返回NULL   3.  按照ANSI(American National Standards Institute)标准，不能对void指针进行算法操作，即不能对void指针进行如p++的操作,所以需要转换为具体的类型指针来操作,例如char *。（引用网友的结论）   4.  size_t 类型定义在cstddef头文件中，该文件是C标准库的头文件stddef.h的C++版。它是一个与机器相关的unsigned类型，其大小足以保证存储内存中对象的大小。 */ void * __cdecl memchr (                        const void * buf,                        char chr,                        size_t cnt                        ) {     while ( cnt && (*(unsigned char *)buf != (unsigned char)chr) ) {         buf = (unsigned char *)buf + 1;         cnt--;     }          return(cnt ? (void *)buf : NULL); } int main() {     void *p = NULL;     const char src[50] = \"blog.csdn.net/barry_yan\";     p = memchr(src,'y',strlen(src));     if(p != NULL)     {        cout << (char*)p << endl;     }     else     {         cout<<\"NULL\"<<endl;     }     return 0; }","title":"memchr源码"},{"content":"//FIFO#include<iostream>#include<iomanip>using namespace std;void discard(int Array[][19],int pagenumber[],int page[],int max);int LRU(int pagenumber[],int order);int main(){\tint Array[4][19];\tint page[19] = {7,0,1,2,0,3,0,4,2,3,0,3,2,1,2,0,1,7,0};\tint pagenumber[3] = {-1,-1,-1};\tint max = 19;//表示总共有多少页面\tcout<<\"页面访问序列如下：\"<<endl;\tfor(int i = 0;i < 19;i++){\t\tArray[3][i] = -1;\t\tcout<<setw(3)<<page[i];\t}\tdiscard( Array, pagenumber,page,max);//页面淘汰\tcout<<endl;\tcout<<endl;\t//输出页面淘汰详细过程\tcout<<\"输出结果如下表（-2）代表没有缺页中断！\"<<endl;\tint LackPageNumber = 0;\tfor(int j = 0; j < 4;j++){\t\tfor(int k = 0; k  < 19;k++){\t\t\tcout<<setw(3)<<Array[j][k];\t\t\tif(j == 3){\t\t\t\tif(Array[j][k] != -2)\t\t\t\t\tLackPageNumber++;\t\t\t}\t\t}\t\tcout<<endl;\t}\tcout<<\"缺页次数\"<<LackPageNumber<<endl;\treturn 0;}void discard(int Array[][19],int pagenumber[],int page[],int max)\t{\tfor(int i = 0;i < max;i++){\t\tif(LRU(pagenumber,page[i])> -1){\t\tfor(int tt = LRU(pagenumber,page[i]);tt>0;tt--){\t\t\tpagenumber[tt] =  pagenumber[tt-1];\t\t}\t\tpagenumber[0] = page[i];\t\tArray[0][i] = pagenumber[0];\t\tArray[1][i] = pagenumber[1];\t\tArray[2][i] = pagenumber[2];\t\tArray[3][i] = -2;//表示非缺页\t\t}\t\telse{\t\t\tArray[0][i] = page[i];\t\t\tArray[1][i] = pagenumber[0];\t\t\tArray[2][i] = pagenumber[1];\t\t\tArray[3][i] = pagenumber[2];\t\t\tfor(int ii = 2;ii >0;ii--){\t\t\t\tpagenumber[ii] = pagenumber[ii-1];\t\t\t}\t\t\tpagenumber[0] = page[i];\t\t}\t}}int LRU(int pagenumber[],int order){//判断当前页架中有没有当前访问页面\tif(pagenumber[0] == order)\t\treturn 0;\telse if(pagenumber[1] == order)\t\treturn 1;\telse if(pagenumber[2] == order)\t\treturn 2;\telse\t\treturn -1;}","title":"页面淘汰算法LRU"},{"content":"struts.xml是我们在S2SH开发中利用率最高的文件，也是Struts2中最重要的配置文件，所以我们对它的了解一定要非常熟悉... 一下分别介绍一下几个struts.xml中常用到的标签 1、<include> 利用include标签，可以将一个struts.xml配置文件分割成多个配置文件，然后在struts.xml中使用<include>标签引入其他配置文件。 比如一个网上购物程序，可以把用户配置、商品配置、订单配置分别放在3个配置文件user.xml、goods.xml和order.xml中，然后在struts.xml中将这3个配置文件引入： struts.xml：   <?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE struts PUBLIC    \"-//Apache Software Foundation//DTD Struts Configuration 2.0//EN\"    \"http://struts.apache.org/dtds/struts-2.0.dtd\"> <struts>    <include file=\"user.xml\"/>    <include file=\"goods.xml\"/>    <include file=\"order.xml\"/><\/struts> user.xml： <?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE struts PUBLIC    \"-//Apache Software Foundation//DTD Struts Configuration 2.0//EN\"    \"http://struts.apache.org/dtds/struts-2.0.dtd\"> <struts>    <package name=\"wwfy\" extends=\"struts-default\">        <action name=\"login\" class=\"wwfy.user.LoginAction\">            <!--省略Action其他配置-->        <\/action>        <action name=\"logout\" class=\"wwfy.user.LogoutAction\">            <!--省略Action其他配置-->        <\/action>    <\/package><\/struts> 2、<constant> 在之前提到struts.properties配置文件的介绍中，我们曾经提到所有在struts.properties文件中定义的属性，都可以配置在struts.xml文件中。而在struts.xml中，是通过<constant>标签来进行配置的： <?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE struts PUBLIC    \"-//Apache Software Foundation//DTD Struts Configuration 2.0//EN\"    \"http://struts.apache.org/dtds/struts-2.0.dtd\"> <struts>    <!-- 开发模式下使用，这样可以打印出更详细的错误信息 -->      <constant name=\"struts.devMode\" value=\"true\"/>        <!-- 指定Web应用的默认编码集，相当于调用HttpServletRequest的setCharacterEncoding方法 -->      <constant name=\"struts.i18n.encoding\" value=\"GB2312\"/>    <!--该属性指定需要Struts 2处理的请求后缀，该属性的默认值是action，即所有匹配*.action的请求都由Struts 2处理。如果用户需要指定多个请求后缀，则多个后缀之间以英文逗号（，）隔开。-->   \t<constant name=\"struts.action.extension\" value=\"do\" />\t       <!-- 设置浏览器是否缓存静态内容，默认值为true（生产环境下使用），开发阶段最好关闭 -->       <constant name=\"struts.serve.static.browserCache \" value=\"false\" />        <!-- 当struts的配置文件修改后，系统是否自动重新加载该文件，默认值为false（生产环境下使用），开发阶段最好打开 -->       <constant name=\"struts.configuration.xml.reload\" value=\"true\" />           <!-- 默认的视图主题 -->       <constant name=\"struts.ui.theme\" value=\"simple\" />           <!-- 该属性指定Struts 2中的action由Spring容器创建  -->       <constant name=\"struts.objectFactory\" value=\"spring\" />         <!--指定所需的国际化资源-->    <constant name=\"struts.custom.i18n.resources\" value=\"messageResource\"> <\/struts> 3、<package> 1、包属性介绍 在Struts2框架中是通过包来管理action、result、interceptor、interceptor-stack等配置信息的。包属性如下： 属性 是否必需 描述 name 是 包名，作为其它包应用本包的标记 extends 否 设置本包继承其它包(struts-default、josn-default) namespace 否 设置包的命名空间 abstact 否 设置为抽象包 2、extends属性的详解 当一个包通过配置extends属性继承了另一个包的时候，该包将会继承父包中所有的配置，包括action、result、interceptor等。 由于包信息的获取是按照配置文件的先后顺序进行的，所以父包必须在子包之前被定义。 通常我们配置struts.xml的时候，都继承一个名为“struts-default.xml”的包，这是struts2中内置的包。 3、namespace的详解 namespace主要是针对大型项目中Action的管理，更重要的是解决Action重名问题，因为不在同一个命名空间的Action可以使用相同的Action名的。 1）如果使用命名空间则URL将改变 比如我们有一下配置文件 <package name=\"wwfy\" extends=\"struts-default\">    <action name=\"login\" class=\"wwfy.action.LoginAction\">        <result>/success.jsp<\/result>    <\/action><\/package>  则此配置下的Action的URL为http://localhost:8080/login.action 假如为这个包指定了命名空间 <package name=\"wwfy\" extends=\"struts-default\" namespace=\"/user\">    <action name=\"login\" class=\"wwfy.action.LoginAction\">        <result>/success.jsp<\/result>    <\/action><\/package> 则此配置下的Action的URL为http://localhost:8080/user/login.action 2)默认命名空间 Struts2中如果没有为某个包指定命名空间,该包使用默认的命名空间,默认的命名空间总是\"\"。 3）指定根命名空间 当设置了命名空间为“/”，即指定了包的命名空间为根命名空间时，此时所有根路径下的Action请求都会去这个包中查找对应的资源信息。 假若前例中路径为http://localhost:8080/login.action则所有http://localhost:8080/*.action都会到设置为根命名空间的包中寻找资源。   4、<action>与<result> 1、<action>属性介绍 属性名称 是否必须 功能描述 name 是 请求的Action名称 class 否 Action处理类对应具体路径 method 否 指定Action中的方法名 converter 否 指定Action使用的类型转换器 如果没有指定method则默认执行Action中的execute方法。 2、<result>属性介绍 属性名称 是否必须 功能描述 name 否 对应Action返回逻辑视图名称，默认为success type 否 返回结果类型，默认为dispatcher   Result类型Webwork提供了一些com.opensymphony.xwork.Result接口的实现来使你的action可以容易的用户交互.这些Result类型包括: Chain Result - 用于 Action Chaining Dispatcher Result - 用于 JSP 整合 FreeMarker Result - 用于 FreeMarker 整合 HttpHeader Result - 用于控制特殊的HTTP行为 JasperReports Result - 用于 JasperReports 整合 Redirect Result - 用于直接跳转到例外的URL Redirect Action Result - 用于直接跳转到另外的action Stream Result - 用于向浏览器返回一个InputStream (一般用于文件下载) Velocity Result - 用于 Velocity 整合 XSL Result - 用于 XML/XSLT 整合 PlainText Result - 用于显示某个页面的原始的文本 (例如 jsp, html 等) 特别的几个Result类型： <result type=\"stream\">    //指定被下载文件的文件类型    //image/jpg   图片jpg    //image/gip   图片gif    //application/zip     <param name=\"contentType\">image/jpg<\/param>    //指定被下载文件的入口输入流    <param name=\"inputName\">targetFile<\/param>        //指定下载的文件名    <param name=\"contentDisposition\">filename=\"wjc_lgo.jpg\"<\/param>        //指定下载文件时的缓冲大小    <param name=\"bufferSize\">4096<\/param>       <\/result>   <result type=\"json\">                  <!-- 这里指定将被Struts2序列化的属性，该属性在action中必须有对应的getter方法 -->                  <!-- 默认将会序列所有有返回值的getter方法的值，而无论该方法是否有对应属性 -->                  <param name=\"root\">dataMap<\/param>                  <!-- 指定是否序列化空的属性 -->                  <param name=\"excludeNullProperties\">true<\/param>                  <!-- 这里指定将序列化dataMap中的那些属性 -->                  <param name=\"includeProperties\">                      userList.*                   <\/param>                  <!-- 这里指定将要从dataMap中排除那些属性，这些排除的属性将不被序列化，一半不与上边的参数配置同时出现 -->                  <param name=\"excludeProperties\">                      SUCCESS                   <\/param>  <\/result>   3、通配符的使用 随着result的增加，struts.xml文件也会随之变得越来越复杂。那么就可以使用通配符来简化配置： 例如下面这个案例： Action为Test.java public class Test {    public String test1(){        return \"result1\";    }         public String test2(){        return \"result2\";    }         public String test3(){        return \"result3\";    }}   struts.xml中配置为 <package name=\"wwfy\" extends=\"struts-default\">    <action name=\"test*\" class=\"wwfy.action.test{1}\">        <result name=\"result{1}\">/result{1}.jsp<\/result>    <\/action><\/package>   4、访问Action方法的另一种实现方式 在Struts2中如果要访问Action中的指定方法，还可以通过改变URL请求来实现，将原本的“Action名称.action”改为“Action名称！方法名称.action”在struts.xml中就不需要指定方法名了。 5、<exception-mapping>与<global-exception-mapping> 这两个标签都是用来配置发生异常时对应的视图信息的,只不过一个是Action范围的,一个是包范围的,当同一类型异常在两个范围都被配置时,Action范围的优先级要高于包范围的优先级.这两个标签包含的属性也是一样的: 属性名称 是否必须 功能描述 name 否 用来表示该异常配置信息 result 是 指定发生异常时显示的视图信息,这里要配置为逻辑视图 exception 是 指定异常类型 两个标签的示例代码为: <?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE struts PUBLIC    \"-//Apache Software Foundation//DTD Struts Configuration 2.0//EN\"    \"http://struts.apache.org/dtds/struts-2.0.dtd\"> <struts>    <package name=\"default\" extends=\"struts-default\">        <global-exception-mappings>            <exception-mapping result=\"逻辑视图\" exception=\"异常类型\"/>        <\/global-exception-mappings>        <action name=\"Action名称\">            <exception-mapping result=\"逻辑视图\" exception=\"异常类型\"/>        <\/action>    <\/package><\/struts>   6、<default-class-ref> 当我们在配置Action的时候，如果没有为某个Action指定具体的class值时，系统将自动引用<default-class-ref>标签中所指定的类。在Struts2框架中，系统默认的class为ActionSupport，该配置我们可以在xwork的核心包下的xwork-default.xml文件中找到。 有特殊需要时，可以手动指定默认的class package wwfy.action; public class DefaultClassRef {    public void execute(){        System.out.println(\"默认class开始执行……\");    }}   在struts.xml中配置 <?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE struts PUBLIC    \"-//Apache Software Foundation//DTD Struts Configuration 2.0//EN\"    \"http://struts.apache.org/dtds/struts-2.0.dtd\"> <struts>    <package name=\"wwfy\" extends=\"struts-default\">        <!-- 指定默认class为Test -->        <default-class-ref class=\"wwfy.action.DefaultClassRef\"/>        <action name=\"test1\">            <result>/index.jsp<\/result>        <\/action>    <\/package><\/struts>   7、<default-action-ref> 如果在请求一个没有定义过的Action资源时，系统就会抛出404错误。这种错误不可避免，但这样的页面并不友好。我们可以使用<default-action-ref>来指定一个默认的Action，如果系统没有找到指定的Action，就会指定来调用这个默认的Action。 <?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE struts PUBLIC    \"-//Apache Software Foundation//DTD Struts Configuration 2.0//EN\"    \"http://struts.apache.org/dtds/struts-2.0.dtd\"> <struts>    <package name=\"wwfy\" extends=\"struts-default\">                 <default-action-ref name=\"acctionError\"><\/default-action-ref>        <action name=\"acctionError\">            <result>/jsp/actionError.jsp<\/result>        <\/action>    <\/package><\/struts> 8、<default-interceptor-ref> 该标签用来设置整个包范围内所有Action所要应用的默认拦截器信息。事实上我们的包继承了struts-default包以后，使用的是Struts的默认设置。我们可以在struts-default.xml中找到相关配置： <default-interceptor-ref name=\"defaultStack\"/> 在实际开发过程中，如果我们有特殊的需求是可以改变默认拦截器配置的。当时一旦更改这个配置，“defaultStack”将不再被引用，需要手动最加。 9、<interceptors> 通过该标签可以向Struts2框架中注册拦截器或者拦截器栈，一般多用于自定义拦截器或拦截器栈的注册。该标签使用方法如下： <interceptors>    <interceptor name=\"拦截器名\" class=\"拦截器类\"/>    <interceptor-stack name=\"拦截器栈名\">        <interceptor-ref name=\"拦截器名\">    <\/interceptor-stack><\/interceptors> 10、<interceptor-ref> 通过该标签可以为其所在的Action添加拦截器功能。当为某个Action单独添加拦截器功能后，<default-interceptor-ref>中所指定的拦截器将不再对这个Action起作用。 11、<global-results> 该标签用于设置包范围内的全局结果集。在多个Action返回相同逻辑视图的情况下，可以通过<global-results>标签统一配置这些物理视图所对应的逻辑视图。 <?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE struts PUBLIC    \"-//Apache Software Foundation//DTD Struts Configuration 2.0//EN\"    \"http://struts.apache.org/dtds/struts-2.0.dtd\"> <struts>    <package name=\"wwfy\" extends=\"struts-default\">        <global-results>            <result name=\"test\">/index.jsp<\/result>        <\/global-results>    <\/package><\/struts>        ","title":"struts.xml详解"},{"content":"系统中的所有线程都要访问系统资源，一个线程霸占某个资源，其他需要该资源的线程就不能完成自己的任务；另外如一个线程在读取某块内存中的数据，而另一个线程又正在修改这块内存的值，这同样不是我们想要的，所以线程之间必须要有一套自己的规则，不然就凌乱了。线程之间需要通信，如A线程霸占某个B线程需要的资源X，在A占用期间，B线程只能等待，或处于挂起状态，当A线程用完资源X后，系统会告诉线程B，资源X可以用了，或是将处于挂起状态的线程B唤醒，然后线程B就获得对资源X的控制权，其他想用资源X的线程就得经历B刚才的遭遇。当多个线程同时需要某个资源时必须遵守下面两个规则： 1：多个线程“同时”访问资源，不能破坏资源的完整性。 2：一个线程需要通知其他线程某项任务已经完成。 原子访问：Interlocked系列函数。多线程编程大部分情况与原子访问有关，即一个线程在访问某个资源时，确保没有其他线程能访问该资源。 增量函数InterlockedExchangeAdd结构如下： InterlockedExchangeAdd(     unsigned long volatile *Addend,//被增量变量的地址     unsigned long Value//增量值 ) Volatile表示每次都成内存中读取数据，而不会从高速缓存中读取数据，如一个全局变量，在一个多线程函数中被修改，在多核CPU中，这个变量可能在多个CPU的高速缓存中都有副本，如果不用volatile修饰，那么可能会因为优化的原因，CPU不会读内存中的数据，而是直接从高速缓存中读取数据，在这种情况下，很可能这个值已经被修改了，这样CPU读取到的不是最新的数据，程序肯定会出错，用volatile修饰后，这个变量的所有高速缓存就会失效，就不会出现这种问题。在多线程编程中volatile作用非常大，效率也最高。但他就是只能修饰单个变量，不能修饰代码段。 InterlockedExchangeAdd执行的速度是非常快的，只需要占用几个CPU周期。用InterlockedExchangeAdd来修改某个变量的值，好像有点大材小用了，因为用Volatile就足够了，简单迅速。但在实现旋转锁时InterlockedExchange就非常有用。旋转锁的代码大致如下：         bool sourceIsUse=false;        void fun()        {            //一直等待直到资源可用            while(InterlockedExchange(&sourceIsUse,true)==true)            {                Sleep(0);            }            //访问资源的操作            ......            //资源用好了，打开锁，让其他等待的资源访问            InterlockedExchange(&sourceIsUse,false);        } InterlockedExchange：将第一个参数的值修改成第二个参数的值，返回第一个参数原来的值。在第一个线程就来的时候，它顺利的闯过了While循环，并上了锁，导致while始终为true，后来的线程就一直在while里面打转，当前面的线程用完之后，他就会把锁打开，然后新来的线程就可以跳出while循环，并上锁（在等待时一直在上锁），开锁独占资源了，新来的线程又开始等待。就像大厦前门的旋转门，一拨人进去之后，后面的人就只能在外面等，等里面的人出去之后，后面的人也就可以进去了，周而复始。 高速缓存行。当CPU从内存中读取一个字节时，它并不是真的只读一个字节，而是读取一个高速缓存行，一个高速缓存行可能是32个字节、64个字节或是128个字节，它始终读取的字节数是32的整数倍，这样CPU就不用非常频繁的读取内存，从而提高程序的性能，当CPU访问某块内存是它会访问这块内存旁边的内存的概率是非常大的，于是就一起读了。更多关于数据对齐的信息请看我的文章《数据对齐》。 高级线程同步。刚刚简单的说了一下旋转锁，现在又来说旋转锁的坏，旋转锁的问题在于等待的线程一直在执行毫无用处的该死的死循环，浪费CPU的时间，这肯定是不能容忍的，虽然曾经一度容忍过它。当一个线程需要某个资源，而这个资源被另一个线程占用时，如果这个线程等了一会儿还不能获得这个资源，那么这个线程就应该被切换到等待状态，让系统充当该线程的代理，当该资源可以被使用时，系统就会将该线程唤醒，然后该线程就可以独占该资源。而实现这一功能的就是关键段。 关键段。关键段是一小段代码，在执行之前需要独占对一些共享资源的访问，这种方式可以让多行代码以原子的方式进行访问，当有一个线程对访问这段代码时其他线程只能等待。使用关键段的步骤如下： CRITICAL_SECTION g_cs;//构造一个CRITICAL_SECTION实例 InitializeCriticalSection(&g_cs);//初始化g_cs的成员 EnterCriticalSection(&g_cs);//进入关键段 LeaveCriticalSection(&g_cs);//离开关键段 DeleteCriticalSection(&g_cs);//清理g_cs EnterCriticalSection会检查结构CRITICAL_SECTION的成员变量，这些成员表示是否有线程正在访问资源，以及哪个线程正在访问资源，EnterCriticalSection会进行一些测试。如果没有线程正在访问资源，EnterCriticalSection会更新变量成员，以表示已经有线程正在访问资源，并马上从EnterCriticalSection返回，继续执行关键段中的代码，如果变量成员表示已经有线程正在访问资源，那么EnterCriticalSection会使用一个事件内核对象把线程切换成等待状态，等待状态的线程是不会浪费CPU的时间的，系统会记住这个线程想要使用这个资源，一旦当前线程调用LeaveCriticalSection，系统会自动更新CRITICAL_SECTION的成员变量，并将等待的线程切换成可调度状态。 LeaveCriticalSection会检查结构CRITICAL_SECTION的成员变量并将计数器减一，如果计数器变为0，LeaveCriticalSection会更新成员变量表示现在没有线程访问资源，若有等待的线程，则将等待的线程切换成可调度的状态。 当一个线程进入关键段时，若有线程正在访问关键段，那么系统就会将新的线程切换成等待状态，这意味着将线程从用户模式切换成内核模式，这个切换的开销大约是1000个CPU周期，这个开销其实是很大的，所以在EnterCriticalSection内部使用旋转锁，并不是马上将线程切换成等待状态，而是先用旋转锁试探一些，看线程是否释放了对资源的访问，如果释放了，新的线程就不用被切换成等待状态了，就可以直接访问资源了，也就是说花了旋转锁轮询的时间，如果旋转锁轮询了一段时间，线程还是没有释放资源，对不起系统就不会让它继续轮询了，因为系统也不知道还要轮询多久，毕竟轮询一直都是在消耗CPU的时间，系统会停止轮询，将新的线程切换成等待状态，当前一个资源释放对资源的访问，系统会将新的线程切换成可调度状态。 Silm读/写锁。SRWLock的目的和关键段是一样的，就是对资源的保护，不让其他线程访问。不同的是，它区分线程是读线程还是写线程。我们都是知道，一个资源可以同时被多个线程同时读，就是不能同时读，或是读写。也是是说写必须是独占的方式，而读可以以共享的方式访问。 读写锁调用的函数如下，跟关键段差不多，我就不废话了。 RTL_SRWLOCK lock; InitializeSRWLock(&lock); AcquireSRWLockExclusive(&lock);//独占的方式访问 ReleaseSRWLockExclusive(&lock); AcquireSRWLockShared(&lock);//共享的方式访问 ReleaseSRWLockShared(&lock); Windows线程基础 Windows内核对象简介 作者：陈太汉 博客：http://www.cnblogs.com/hlxs/","title":"Windows多线程编程基础"},{"content":"标准单源最短路模板，没法再标准了…… 但是WA了两次，原因是I和J没搞清楚，模板题改模板的时候一定要注意格式。 当然，理解思想才是最重要的，DIJKSTRA是标准的贪心思路，不断地从之前的路径中筛选最短-比较-更新。 #include <iomanip>#include <string.h>#include <iostream>using namespace std;const int INF=0x3f3f3f3f;int map[105][105];int path[10005];bool visited[10005];int prev[10005];void clearmap(){    for (int i=0;i<105;i++)    {        for (int j=0;j<105;j++)        {            map[i][j]=INF;        }    }    memset(path,INF,sizeof(path));    memset(prev,0,sizeof(prev));    memset(visited,0,sizeof(visited));}void dijkstra(int n,int start){    for (int i=1;i<=n;i++)    {        path[i]=map[start][i];                if (path[i]==INF)        {            prev[i]=0;        }        else            prev[i]=start;    }    //path[start]=0;    visited[start]=true;    for (int i=1;i<=n-1;i++)    {        int minidx=-1;        int minnum=INF;        for (int j=1;j<=n;j++)        {            if (visited[j]==0 && path[j]<minnum)            {                minidx=j;                minnum=path[j];            }        }        visited[minidx]=1;        for (int j=1;j<=n;j++)        {            if (visited[j]==0 && (path[j]>map[minidx][j]+path[minidx]))            {                prev[j]=minidx;                path[j]=map[minidx][j]+path[minidx];            }        }    }}int main(){    int end,route;    while (cin>>end>>route &&(end!=0 || route!=0))    {        clearmap();        for (int i=1;i<=route;i++)        {            int a,b,value;            cin>>a>>b>>value;            if(value<map[a][b])            {           \t\t map[a][b]=value;                \t map[b][a]=value;            }        }        dijkstra(end,1);        cout<<path[end]<<endl;    }    return 0;}","title":"【DIJKSTRA一定要严格格式】模板题——最短路HDU2544"},{"content":"0. Java的异常机制主要依赖于try、catch、finally、throw和throws五个关键字.  try关键字后紧跟一个花括号括起来的代码块(花括号不能省略), 它里面放置可能引发异常的代码. catch后对应异常类型和一个代码块, 用于表明该catch块用于处理这种类型的代码块.  多个catch块后还可以跟一个finally块, finally块用于回收在try块里打开的物理资源, 异常机制会保证finally块总被执行.  throws关键字主要在方法签名中使用, 用于声明该方法可能抛出的异常. throw用于抛出一个实际的异常, throw可以单独作为语句使用, 抛出一个具体的异常对象.  1. Java异常(Java所有非正常情况分两类: 异常(Exception)和错误(Error), 都继承Throwable父类)分为两类, Checked异常 和 Runtime异常. Java认为Checked异常都是可以在编译阶段被处理的异常, 所以它强制程序处理所有的Checked异常; 而Runtime异常则无需处理.  *所有的RuntimeException类及其子类的实例被称为Runtime异常, 其他异常类的实例被称为Checked异常. *只有Java语言提供了Checked异常(肯定假的~). Java认为Checked异常都是可以被处理(修复)的异常, 所以Java程序必须显式处理Checked异常, 否则编译时就会出现错误.  Checked异常处理方式: a. try了这句; b. 定义该方法时声明抛出(throws)该异常.  Runtime异常无需显式声明抛出, 如果程序需要捕获Runtime异常, 也可以用try...catch块实现.  2. 如果执行try块里的业务实现代码时出现异常, 系统自动生成一个异常对象, 该异常对象被提交给Java运行时环境, 这个过程被称为抛出(throw)异常; 当Java运行时环境收到异常对象时, 会寻找能处理该异常对象的catch块, 如果找到, 则把该异常对象交给catch块处理, 这个过程称为捕获(catch)异常; 如果Java运行时环境找不到能捕获异常的catch块, 则运行时环境终止, Java程序也将退出.  //伪代码try{\t//业务实现代码\t...}catch (Exception e){\talert 输入不合法\tgoto retry} 3. try块被执行一次后, 对应的catch中最多只能有一个被执行(如果都符合条件的话, 执行第一个.).  4. try块里声明的是代码快内局部变量, 只在try块中有效, catch块和finally块中不能访问.  5. Java所有非正常情况分两类: 异常(Exception) 和 错误(Error), 都继承Throwable父类.  其中Error错误, 一般指与虚拟机相关的问题, 如系统崩、虚拟机错误、动态连接失败等, 这种错误无法恢复或不可能捕获, 导致程序中断. 通常应用程序无法处理这些错误, 因此应用程序不应该试图使用catch块来捕获Error对象.定义该方法时, 也无需在其throws子句中声明该方法可能抛出Error及其任何子类.  异常分为两类, Checked异常 和 Runtime异常. Java认为Checked异常都是可以在编译阶段被处理的异常, 所以它强制程序处理所有的Checked异常; 而Runtime异常不强制.  ------------------------------------------------------------------------------- 上面这么多就是说, 编码时只处理Checked异常就好了. Over. 6. 所有父类异常的catch块都应该放在子类异常catch块后面, 否则编译错误.  7. 常见异常: IndexOutOfBoundsException: 数组越界异常, 运行时输入的参数不够. NumberFormatException, 数字格式异常, 例如需要数字却输入字母.  ArithmeticException, 算数异常, 例如 0作被除数.  NullPointerException, 空指针异常, 调用null对象的实例方法或实例变量是发生.  8. Java7之后, 一个catch块可以捕获多种类型的异常: 多种异常类型之间用竖线(|)隔开. 捕获多种类型的异常时, 异常变量有隐式的final修饰, 因此程序不能对异常变量赋新值.  9. 所有异常对象都包含这几个方法: getMessage(): 返回该异常的纤细描述字符串.  printStackTrace(): 将该异常的跟踪栈信息输出到标准错误输出.  printStackTrace(PringStream s): 将该异常的跟踪栈信息输出到指定的输出流. getStackTrace(): 返回该异常的跟踪栈信息.  10. try执行, 对应的finally块总是会被执行, 甚至try块或catch块中已经执行了return语句. (但是用System.exit(1); 语句代替return;则不会执行finally块. 因为System.exit(1)是退出虚拟机用的, 哈哈.) 11. 一般别再finally块中使用return或throw等导致方法终止的语句, 一旦使用, try块和catch块中的return和throw语句全部失效(不是这一句\"失效\", 而是这样: 系统执行到try或catch块的return或throw语句时并不立即结束该方法, 而是先寻找有木有finally块, 没有的话就执行return或throw语句结束该方法; 有的话就先执行finally块, 如果finally块中没有return或throw语句的话, 就在执行完finally块后跳转到try或catch中的return或throw语句, 如果有, 就直接在finally块中结束了这个方法了. ).  12. Java7后, 允许在try关键字后紧跟一对圆括号, 括号内可以声明、初始化一个或多个资源(通常是数据库连接、网络连接等), 在try语句结束时将自动关闭这些资源. (为了保证可以正常关闭, 这些资源实现类必须实现AutoCloseable或Closeable接口, 实现着两个接口就必须实现close()方法.)  13. try块后面必须有catch块或finally块或同事都有, 除了使用自动关闭资源的try(就是try后带括号的)语句时.  14. 使用throws声明抛出异常, 表示当前方法不处理异常, 而将其交给上一级调用者处理; main方法也可以不处理而把异常交给JVM处理(JVM会打印异常的跟踪栈信息, 并中止程序运行.).  15. throws声明抛出只能在方法签名中使用, throws可以声明抛出多个异常类, 多个异常类之间以逗号隔开.  class a{    void a() throws ExceptionClass1, ExceptionClass2 {}} 16. 可以使用throw语句在程序中自行抛出异常, throw语句抛出异常实例(不是异常类), 而且每次只能抛出一个异常实例.  throw ExceptinInstance; 17. Checked异常要被捕获或者在声明方法时显式throws, Runtime异常则不用.  18. Java7以后, 才可以这样... try{\t...}catch (ExceptionClass ec){\t...\tthrow ec;   //把已经捕获的异常再次抛出. } 19. 面向对象的程序在运行时, 经常会发生一系列方法调用, 从而形成\"方法调用栈\".   <----- \"异常跟踪栈\" 也是类似意思.   20.  try{\t...}catch (Throwable t){\t...}这样的Catch All语句是一种通过避免错误处理而加快变成进度的机制, 不能滥用.  ---------------------------------------- Over. 书看太太慢了.. ----------------------------------------","title":"[疯狂Java讲义精粹] 第八章|异常处理"},{"content":"所有递归都可以变循环 　　这是函数帧的应用之二。 　　还记得大一的C程序设计课上讲到汉诺塔的时候老师说： 所有递归都可以用循环实现。这听起来好像可行，然后我就开始想怎么用循环来解决汉诺塔问题，我大概想了一个星期，最后终于选择了……放弃…… 当然，我不是来推翻标题的，随着学习的深入，以及\"自觉修炼\"，现在我可以肯定地告诉大家：所有递归都可以用循环实现，更确切地说：所有递归都可以用循环+栈实现 （就多个数据结构，还不算违规吧O(∩_∩)O~）。 　　通过在我们自定义的栈中自建函数帧，我们可以达到和函数调用一样的效果。但是因为这样做还是比较麻烦，所以就不转换汉诺塔问题了，而是转换之前的那个递归求解阶乘的程序（fac.c）： #include <stdio.h>int fac(int n){    if(n <= 1)        return 1;    return n * fac(n-1);}int main(){    int n = 3;    int ans = fac(n);    printf(\"%d! = %d\\n\", n, ans);    return 0;} 技术难点 　　我们可以在自建的函数帧中存储局部变量、存储参数， 但是我们不能存返回地址，因为我们得不到机器指令的地址！ 不过，C语言有一个类似于指令地址的东西：switch case 中的 case子句，我们可以用一个case代表一个地址，技术难点就此突破了。 源程序 　　虽然我简化了很多步骤，但源程序还是比较长（fac2.c）： #include <stdio.h>// 栈的设置#define STACKDEEPTH 1024int stack[STACKDEEPTH];int *esp = &stack[STACKDEEPTH];#define PUSH(a) *(--esp) = a#define POP(b)  b = *(esp++)// 其它模拟寄存器int eax;// 存返回值int eip;// 用于分支选择int main(){    int n = 3;    // 模仿 main 调用 fac(n)    PUSH(n);    PUSH(10002);// 模仿返回 main 的地址    eip = 10000;    do{        switch(eip){        case 10000:            --esp;// 为帧分配空间            if(esp[2] <= 1){// 模仿递归终止条件                eax = 1;                ++esp;// 回收帧空间                POP(eip);            }else{// 模仿递归计算 fac(n-1)                esp[0] = esp[2] - 1;                PUSH(10001);                eip = 10000;            }            break;        case 10001:// 返回 n * (fac(n-1)的结果)            eax = esp[2] * eax;            ++esp;// 回收帧空间            POP(eip);            break;        }    }while(eip != 10002);    printf(\"%d! = %d\\n\", n, eax);    return 0;} 自建的函数帧 　　为了简化程序，ebp我们就不用了，完全用esp来操作栈，一个函数帧只占用 8 个字节： 　　在计算到 fac(1) 的时候，栈中内容如下： 　　比起肆意挥霍栈空间的 gcc（fac帧用了32字节，浪费了20字节，实际使用了12字节），我们的程序真的是太节省了（一帧只用8字节）。 小结 　　当然，本文的方法只用于学术讨论，说明所有递归都可以变循环，编程的时候还是不要这么用。因为代码复杂、容易出错、难以理解，唯一的优点是能省空间省到极限。 　　这种递归变循环的方式并没有降低时间复杂度，但却是通用的（所有递归都可以这么变循环）；而有一部分递归可以基于巧妙的算法变成循环，并且大大降低时间复杂度，如：动态规划、贪心算法（详见《算法导论》）。","title":"所有递归都可以变循环"},{"content":"不知道对不对……尼玛的编译器只能提交一次的规则。卡__int64卡跪了，没机会验证对不对了。。 维基解密 Time Limit: 1 Seconds   Memory Limit: 65536K     在最近一期的维基解密中，公布了一串神秘的数字，这引起了很多的猜想。 但是只有百小度知道其中的含义——因为这些神秘的数字就是他留下的记录！   其实你有所不知，现在每天忙碌于百度大厦实习的百小度，在学校读书期间有一大爱好——每当他遇到一个MM，总是会不由自主地从相貌和身材上分别给其打分，首先他会在相貌上选择一个奇数分a (-10^18<=a<=10^18)，然后在身材上再选择一个偶数分b (-10^18 <= b <= 10^18)，最后把a与b的乘积v作为总分记录下来。 这就是维基解密公布的神秘数字！   现在，已知这些分数v，你能还原MM们的初始分a,b吗？   Input 输入数据的第一行是一个整数T，表示测试数据的组数； 然后是T组测试数据，每组测试数据包含一个整数v(-10^18<=v<=10^18)。   Output 请对应每组测试数据输出格式如\"Case X: face : A figure : B\"的结果。 其中，X是测试数据的编号，A和B则分别代表MM的初始面貌分和身材分。 如果总分不能被还原，请输出\"Case X: illegal score.\"   特别提醒： 1、百小度是个很注重外貌的人，如果有多种答案，只要输出相貌分最高的那种情况即可。 2、MM的分数v可能为正，也可能为负，甚至可能为0； 3、注意输出格式，比如大小写、空格等； 4、也许你会就此将百小度归为资深屌丝一族，但是，谁没有一段苦逼的青葱岁月呢？   Sample Input 2 7 18   Sample Output Case 1: illegal score. Case 2: face : 9 figure : 2 #include <iostream>#include <stdlib.h>using namespace std;int main(){    int testcase;    cin>>testcase;    for (int i=1;i<=testcase;i++)    {        long long tranum;        cin>>tranum;        if (tranum%2==1)            cout<<\"Case \"<<i<<\": illegal score.\"<<endl;        else if (tranum==0)        {            cout<<\"Case \"<<i<<\": face : \"<<\"999999999999999999\"<<\" figure : \"<<\"0\"<<endl;        }        else if(tranum>0)        {            long long a=tranum/2;            long long b=2;                         if(a%2==1)            {            \tcout<<\"Case \"<<i<<\": face : \"<<a<<\" figure : \"<<b<<endl;            }                       while(a%2==0)            {            \ta/=2;            \tb*=2;            \t if(a%2==1)            {            \tcout<<\"Case \"<<i<<\": face : \"<<a<<\" figure : \"<<b<<endl;            }            }                    }        else        { \t\t    long long a=-1;            long long b=-(tranum);            if(b%2==0)            {            \tcout<<\"Case \"<<i<<\": face : \"<<a<<\" figure : \"<<b<<endl;            }            else            {            \tcout<<\"Case \"<<i<<\": illegal score.\"<<endl;            }                                }    }    return 0;}","title":"【坑爹脑残百度之星12-30 Problem A】维基解密"},{"content":"1、对于全局函数 int f(void) ，与其完全等价的函数原型为（） A、int &f();      B、int f(void) const;       C、const int f();      D、A、B、C都不是 2、下列关于构造函数的描述中，错误的是（） A、构造函数可以设置默认的参数 B、构造函数在定义类对象时自动执行 C、构造函数可以是内联函数 D、构造函数不可以重载 3、考虑函数原型 void test(int a , int b = 7, char ch='*')，下面的函数调用中，属于不合法调用的是（） A、test(5)      B、test(5,8)     C、test(6,'#')      D、test(0,0,'#') 4、所谓LRU页面淘汰算法是指将驻留在内存中（）页面淘汰 A、时间最长的 B、最久未使用的 C、使用频度最少的 D、出现脏数据的 5、下列说法错误的是（） A、构造函数可以有一个参数         B、构造函数可以有多个参数 C、一个类只能有一个构造函数       D、一个类只能有一个析构函数 6、系统在调用重载函数时，能作为确定哪个重载函数被调用的依据是（） A、函数返回类型     B、参数个数    C、函数名称    D、参数名称 7、一个栈的入栈序列是A、B、C、D、E，则栈的不可能的输出序列是（） A、EDCBA       B、DECBA     C、DCEAB     D、ABCDE 8、有12个球，外形相同，其中一个小球的质量与其他11个不同，给一个天平，需要几次把这个小球找出来并且求出这个小球是比其他的轻还是重（） A、3     B、5      C、7      D、9 9、","title":"2013年人人校园招聘笔试题"},{"content":"博客：WordPress WordPress是使用PHP开发的著名博客平台，免费开源，功能强大，不仅仅用于博客搭建，还可以广泛应用于各类网络信息发布平台。 论坛：phpBB phpBB是一种广泛流行的开源论坛软件，具有易于使用的管理面板和友好的用户安装界面，可以轻松地在数分钟内建立起一个论坛，功能上具有很高的可配置性，能够完全定制出相当个性化的论坛。 CMS：Drupal Drupal是一个开源的内容管理系统(CMS)平台，拥有强大并可自由配置的功能，能支持从个人博客到大型社区驱动的网站等各种不同应用的网站项目。 Wiki：MediaWiki MediaWiki是PHP语言写成开源Wiki引擎，全世界最大的Wiki项目维基百科就是使用MediaWiki引擎。 Digg：Pligg Pligg是一套灵活的类似Digg的Web2.0 CMS系统，系统使用PHP开发，模仿了国外流行的DIGG系统。 图像：Gallery Gallery 是一个非常有名的免费开源图库相册软件，基于 PHP 和 MySQL， PostgreSQL 等数据库。功能非常强大，有丰富的扩展可以下载，安装很简单，有很多插件可用。 RSS：Gregarius Gregarius是一个RSS聚合程序，免费开源，具备不错的用户体验，易于操作和管理。可以把其当成RSS阅读器使用。 电子商务：osCommerce osCommerce是一套由自由软件开发社团开发并维护的在线商店的解决方案，免费开源，并可以应用到任何的商业环境中，可以在短时间内生成一个功能强大的电子商务网站。 广告：OpenX OpenX（原名phpAdsNew）是一个用PHP开发的广告管理与跟踪系统，适合各类网站使用，能够管理每个广告主拥有的多种任何尺寸横幅广告，按天查看，详细和概要统计并通过电子邮件发送报表给广告主。 数据库：phpMyadmin phpMyAdmin是用PHP开发的MySQL的数据库管理工具。可以在Web界面上实现各种各样对MySQL数据库的管理和操作。","title":"Php开源建站平台"},{"content":"谁调用了main？ 　　这是函数帧的应用之一。 操作可行性 　　从上一篇中可以发现：用帧指针 ebp 可以回溯到所有的函数帧，那么 main 函数帧之上的函数帧自然也是可以的；而帧中 旧ebp 的上一个四字节存的是函数的返回地址，由这个地址我们可以判断出谁调用了这个函数。 准备活动 　　下面就是这次黑客行动的主角（up.c）： #include <stdio.h>int main(){    int *p;    // 以下这行内联汇编将 ebp 寄存器的值存到指针 p 中    __asm__(\"movl %%ebp, %0\"            :\"=m\"(p));    while(p != NULL){        printf(\"%p\\n\", p[1]);        p = (int*)(p[0]);    }    return 0;} 　　首先，请允许我使用一下 gcc 内联汇编，这里简单的解释一下： \"=m\"(p) 表示将内存变量 p 作为一个输出操作数 %0 代表的是第一个操作数，那就是 p 了 为了与操作数区别开来，寄存器要多加个 %， %%ebp 表示的就是 ebp 寄存器 　　总之，这块内联汇编将 ebp 寄存器的值赋给了指针 p。 　　然后解释一下while循环：循环中，首先打印 p[1]， p[1]就是该帧所存的返回地址；然后将指针 p 改为 p[0]， p[0]是 旧ebp（上一帧的帧指针）；这样，程序将按照调用顺序的逆序打印出各个返回地址。 　　为什么终止条件是 p==NULL 呢？这是 gcc 为了支援我们的黑客行动特意在开始执行程序的时候将 ebp 清零了，所以第一次执行某个函数的时候压栈的 旧ebp 是 NULL。 开始行动 　　我们使用静态链接的方式编译 up.c （静态链接的可执行文件中包含所有用户态下执行的代码），然后执行它： [lqy@localhost temp]$ gcc -static -o up up.c[lqy@localhost temp]$ ./up0x80484640x80481e1[lqy@localhost temp]$ 分析结果 　　up 打印了了两个指向代码区的地址，接着就看它们是属于哪两个函数了： nm up | sort > up.txt nm up 可列出各个全局函数的地址 | sort > up.txt 通过管道将 nm up 的输出作为 sort 的输入， sort 排序后输出重定向到 up.txt 文件中（输出有1910行，不得不这么做o(╯□╰)o） 　　然后发现两个地址分别位于__libc_start_main、_start 中： ...08048140 T _init080481c0 T _start080481f0 t __do_global_dtors_aux08048260 t frame_dummy080482bc T main08048300 T __libc_start_main080484d0 T __libc_check_standard_fds... 　　实际上程序正好是从 _start 开始执行的，而且从 up 的反汇编结果中可看出 _start 的第一条指令 xor %ebp,%ebp 就是那条传说中的将 ebp 清零的指令（两个一样的数相异或的结果一定是0）。 　　那么调用 main 函数之前程序都干了些啥事呢？比如说堆的初始化，如果是 C++ 程序的话，全局对象的构造也是在 main 之前完成的（不能让 main 中使用全局对象的时候竟然还没构造吧！），而全局对象的析构也相当有趣地在 main 执行完了之后才执行。 　　main 在你心目中的地位是不是一落千丈了？","title":"谁调用了main？"},{"content":"   对同一个内存地址，有不同的段:偏移量组合方法，比如2233FH这个地址，既可以表示为1234H:0FFFFH（在1234H段中），也可以表示为2233H:0000FH（在2233H段中）。   那么，如果汇编程序中有下面两个连续的段定义，汇编编译程序会怎么做呢？   name1 segment   d1 db 0   name1 ends   name2 segment   d2 db 0   name2 ends   　　编译程序可以将name1和name2编译成一个段，d1和d2在内存中连续存放，这样可以节省内存空间。比如编译程序以name1为基准，将name1作为一个段的起始，程序加载后会被放在xxxx0H的地方，那么d1就放在该段偏移地址为0字节的位置，d2就放在该段偏移为1字节的位置。   　　这样的处理方式虽然可能会节省一点内存空间，但是对于编译器的智能化要求太高了，它必须将源程序中所有引用到name2和d2的地方，全部调整为以name1段为基准，这实在是太难了，而且也节省不了几个字节的空间，编译器是不会干这种吃力不讨好的事的。        编译器实际的处理方式是将name1中的所有内容放在一个段的起始地址处，name2里的所有内容放在后续一个段的起始地址处（这也是汇编指令segment的本义：将不同数据分段）。这样，即使name1中只包含一个字节，也要占一个段（16个字节）【一个段至少有16个字节】，所以，一个段实际占用的空间＝（段中字节数＋15）/ 16。   　　所以，8086处理器的内部寻址原理和汇编程序编译器共同决定了segment定义的段必须放在按16的倍数对准的段地址边界上，占用的空间也是16的倍数。","title":"8086分配内存空间详解"},{"content":"最好的配置文件写法是采用clj文件，下面先把前面的a.xml文件改成a.clj文件，内容如下： {:mongodb \"localhost\" :listen_port 7777 :login_timeout 200 :check_timeout 200}这里定义了一个map。注意,localhost是字符串，必须用双引号。 这里用空格分开每个key/value组成的pair. 在test.clj文件中添加一行代码： (ns my-website.rest.test  (:require [noir.response :as response])  (:use [noir.core :only [defpage]]))(defpage \"/rest/:id\" {:keys [id]} (response/json {:userId id}))(defpage \"/rest/file/:name\" {:keys [name]} (str (load-file (str \"/opt/\" name))))最后一行允许输入文件名，然后读取/opt/下的该文件内容，并以字符串形式返回到客户端。 在浏览器上输入网址：http://localhost:8080/rest/file/a.clj 返回结果是： {:mongodb \"localhost\", :check_timeout 200, :listen_port 7777, :login_timeout 200} 注意，自动添加了,作为分隔符号。","title":"用Clojure编写REST service 四 读取配置文件"},{"content":"直接介绍如何做： 第一步：准备Apache软件 我们可以下载源代码，也可以下载已经编译好的二进制文件。我下面使用源代码编译出Apache 下载源程序的网站：http://mirror.bit.edu.cn/apache/httpd/ 也可以使用wget获得源程序的压缩包： []$wget  http://mirror.bit.edu.cn/apache/httpd/httpd-2.4.3.tar.bz2 下载后解压： []$tar -xjf httpd-2.4.3.tar.bz2 第二步：编译安装 切换到解压目录； []$cd httpd-2.4.3/ 配置安装目录； []$./configure --prefix=/home/user/soft/apache 解决配置过程中遇到的错误； 执行配置之后，我遇到如下错误： checking for APR... noconfigure: error: APR not found.  Please read the documentation. 错误的原因是没有安装APR，所以下载APR （Apache Portable Runtime）并安装； []$ cd ..[]$ wget http://www.fayea.com/apache-mirror//apr/apr-1.4.6.tar.bz2[]$ tar -xjf apr-1.4.6.tar.bz2[]$ cd apr-1.4.6/[]$ ./configure --prefix=/home/user/soft/apr[]$ make []$ make install 安装APR后继续执行Apache的配置； []$ cd ../httpd-2.4.3/[]$ ./configure --prefix=/home/user/soft/apache --with-apr=/home/user/soft/apr 继续遇到错误； checking for APR-util... noconfigure: error: APR-util not found.  Please read the documentation. 下载并安装APR-util []$ cd ..[]$ wget http://www.fayea.com/apache-mirror//apr/apr-util-1.5.1.tar.bz2[]$ tar -xjf  apr-util-1.5.1.tar.bz2[]$ cd apr-util-1.5.1/[]$ ./configure --prefix=/home/user/soft/apr-util --with-apr=/home/user/soft/apr[]$ make[]$ make install 安装完成之后继续执行Apache的配置； []$ cd ../httpd-2.4.3/[]$ ./configure --prefix=/home/user/soft/apache --with-apr=/home/user/soft/apr --with-apr-util=/home/user/soft/apr-util 又遇到新的错误： checking for pcre-config... falseconfigure: error: pcre-config for libpcre not found. PCRE is required and available from http://pcre.org/ 需要下载pcre，并且安装它； []$ cd ..[]$ wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.21.tar.bz2[]$ tar -xjf pcre-8.21.tar.bz2[]$ cd pcre-8.21/[]$ ./configure --prefix=/home/user/soft/pcre []$ make[]$ make install 安装完成之后继续执行Apache的配置； []$ cd ../httpd-2.4.3/[]$ ./configure --prefix=/home/user/soft/apache --with-apr=/home/user/soft/apr --with-apr-util=/home/user/soft/apr-util --with-pcre=/home/user/soft/pcre[]$ make[]$ make install 到此软件安装完成了。 第三步：启动APATCH 这里以非ROOT用户启动APACHE，所以对某些配置做下改动 进入安装目录的conf子目录，打开httpd.conf，将Listen 80改为Listen 1026，1026也可以为其它大于1024的端口。 将user和group相应的改为启动apache的人的相应信息 然后切换到apache的bin子目录下，执行以下命令即可： ./apachectl -k start 第四步：测试 打开浏览器输入自己的IP即可，然后你会看到显示了一个It works的页面。 O了","title":"Ubuntu下使用APACHE搭建http网站全过程"},{"content":"有X86的前提，不废话了，直接上测试代码主要部分~~~~      char *test_c1=(char *)malloc(Num);     *test_c1='h';          //'h'=0x68     *(test_c1+1)='o';     //'o'=0x6f     *(test_c1+2)='o';          *(test_c1+3)='o';     free(test_c1);num=4 num=14 num=50 num=100    结果分析： 因为ARM Cortex-M3为32位的MCU，而且“堆栈指针的最低两位永远是0(硬件拉低)，这意味着堆栈总是4字节对齐的”——ARM Cortex-M3权威指南P13，所以起码是0x04的整数倍~~~ 所以按这样来说，4起码分配4,14起码分配4*4=16=0xf，50起码分配4*13=52=0x34,100起码分配4*25=100=0x64，但是结尾都以8结尾，这样会浪费一些字节，至于原因不得而知为啥子鸟~~~ ps:其实说是ARM篇有点不确切，应该是由MDK编译器来决定的～～～","title":"关于free如何知道要释放内存空间的长度问题(ARM篇)"},{"content":"注意地址栏：未提交页面时，是login.jsp： 提交页面后，是Login.action:   在Struts.xml文件中有： <action name=\"Login\"    class=\"com.example.struts.action.LoginAction\">    <result name=\"input\">/jsp/login.jsp<\/result>    <result name=\"success\">/jsp/success.jsp<\/result>   <\/action> 即，地址栏中Login.action是Action类对应的映射名。 提交的表单中的数据经由Action类处理后跳转到结果页面，地址栏中仍为Action类映射名。 下面我们再来看一个例子： ErrorAndMessage.jsp: <%@ page language=\"java\" pageEncoding=\"gb2312\"%><!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"><%@taglib prefix=\"s\" uri=\"/struts-tags\"%><html>    <head>      <s:head />    <\/head>\t<body>\t    <s:actionerror />        <p>            <s:actionmessage />\t<\/body><\/html> ErrorAndMessageAction.java: package com.example.struts.action;import com.opensymphony.xwork2.ActionSupport;public class ErrorAndMessageAction extends ActionSupport{\tpublic String execute() throws Exception{\t\taddActionError(\"Action 的错误信息\");\t\taddActionMessage(\"Action 的消息信息\");\t\treturn SUCCESS;\t}} struts.xml: \t<action name=\"ErrorAndMessage\"            class=\"com.example.struts.action.ErrorAndMessageAction\">                        <result name=\"success\">/jsp/ErrorAndMessage.jsp<\/result>        <\/action>   若在地址栏输入：http://localhost:8080/Tg/jsp/ErrorAndMessage.jsp 则什么都不输出。 若在地址栏输入：http://localhost:8080/Tg/jsp/ErrorAndMessage.action 则输出如下： 原因：之前是直接运行.jsp页面，这样标签<s:actionerror />和<s:actionmessage /> 就什么值都没有； 之后是直接运行.action，这样就通过addActionError和addActionMessage方法初始化了error和message， 接着由struts.xml导航到JSP页面，这时标签<s:actionerror />和<s:actionmessage /> 就有值可取了。 注：直接运行.jsp页面之所以不经过struts.xml导航，是因为它没有经过<form>表单\"提交\"操作。","title":"地址栏\".jsp\"变为\".action\"的含义"},{"content":"前言 最近两个星期一直都在断断续续的学习二叉树的数据结构，昨晚突然有点融汇贯通的感觉，这里记录一下吧 题目要求 给定前序序列，abc##de#g##f###,构建二叉树，并且用递归和非递归两种方法去做前序，中序和后序遍历 二叉树的数据结构 /** * 定义二叉树的数据结构 */struct btree{\tchar item;\tstruct btree *lchild;\tstruct btree *rchild;};typedef struct btree* bt;/** * 定义栈数据结构(用于非递归遍历) */struct seqstack{\tbt data[maxsize];\tint top;};typedef struct seqstack* stack; 递归构建二叉树 全局数组、全局变量构建二叉树 char str[101] = \"abc##de#g##f###\";int count = 0;bt createBintree(){\tbt t;\tif(str[count ++] == '#')\t{\t\t//回溯条件\t\tt = NULL;\t}else if(str[count - 1] == '\\0')\t{\t\t//终止条件\t\tt = NULL;\t}\telse\t{\t\tt = (bt)malloc(sizeof(struct btree));\t\tt->item = str[count - 1];\t\tt->lchild = createBintree();\t\tt->rchild = createBintree();\t}\treturn t;} 递归的前序、中序、后序算法（c） /** * Description:递归前序遍历 */void recPreorder(bt root){\tif(root)\t{\t\tprintf(\"%c \", root->item);\t\trecPreorder(root->lchild);\t\trecPreorder(root->rchild);\t}else\t{\t\treturn;\t}}/** * Description:递归中序遍历 */void recInorder(bt root){\tif(root)\t{\t\trecInorder(root->lchild);\t\tprintf(\"%c \", root->item);\t\trecInorder(root->rchild);\t}else\t{\t\treturn;\t}}/** * Description:递归后序遍历 */void recPostorder(bt root){\tif(root)\t{\t\trecPostorder(root->lchild);\t\trecPostorder(root->rchild);\t\tprintf(\"%c \", root->item);\t}else\t{\t\treturn;\t}} 非递归遍历算法(前序，中序) void initStack(stack s){\ts->top = -1;}void pushStack(stack s, const bt t){\tif(s->top <= maxsize)\t{\t\ts->data[++ (s->top)] = t;\t}}bt popStack(stack s){\tif(s->top >= 0)\t{\t\treturn s->data[(s->top) --];\t}else\t{\t\tprintf(\"栈空了\\n\");\t}}/** * Description:非递归前序遍历 */void preorderTraverse(bt root){\tstack s = (struct seqstack *)malloc(sizeof(struct seqstack));\tinitStack(s);\tbt p = root;\twhile(s->top >= 0 || p)\t{\t\tif(p)\t\t{\t\t\tprintf(\"%c \", p->item);\t\t\tpushStack(s, p);\t\t\tp = p->lchild;\t\t}else\t\t{\t\t\tp = popStack(s);\t\t\tp = p->rchild;\t\t}\t}\tprintf(\"\\n\");}/** * Description:非递归中序遍历 */void inorderTraverse(bt root){\tstack s = (struct seqstack *)malloc(sizeof(struct seqstack));\tinitStack(s);\tbt p  = root;\twhile(s->top >=0 || p)\t{\t\tif(p)\t\t{\t\t\tpushStack(s, p);\t\t\tp = p->lchild;\t\t}else\t\t{\t\t\tp = popStack(s);\t\t\tprintf(\"%c \", p->item);\t\t\tp = p->rchild;\t\t}\t}} 非递归遍历算法(后序) 算法思想： 首先，也是找个最左边的叶子结点并把路上遇到的节点依次入栈 然后，弹出栈顶元素(该元素为最左边的叶子)，判断（1）它是否有右节点（2）如果有右节点，是否被访问过。如果满足（1）有右节点并且（2）右节点没有访问过，说明这是后序遍历的相对根节点，因此需要将这个节点再次入栈，并且它的右节点入栈，然后重新执行第一步。否则，就访问该节点，并且设置pre为此节点，同时把将遍历节点附空值，访问进入无限循环 算法代码（c语言）： /** * Description:非递归后序遍历 */void postorderTraverse(bt root){\tstack s = (struct seqstack *)malloc(sizeof(struct seqstack));\tinitStack(s);\tbt pre, p;\tp = root;\t//记录前一个访问节点\tpre = NULL;\twhile(s->top >= 0 || p)\t{\t\tif(p)\t\t{\t\t\tpushStack(s, p);\t\t\tp = p->lchild;\t\t}else\t\t{\t\t\tp = popStack(s);\t\t\tif(p->rchild != NULL && p->rchild != pre)\t\t\t{\t\t\t\t//如果右子树非空且没有被访问过，则p为相对根节点\t\t\t\tpushStack(s, p);\t\t\t\tp = p->rchild;\t\t\t}else\t\t\t{\t\t\t\tprintf(\"%c \", p->item);\t\t\t\tpre = p;\t\t\t\t//设置p为null,才能将上层节点出栈，访问无限循环\t\t\t\tp = NULL;\t\t\t}\t\t}\t}} 注意： 严蔚敏的<<数据结构>>上有一段话很经典，摘录如下：”从二叉树遍历的定义可知，三种遍历算法之不同处仅在于访问根节点和遍历左、右子树的先后关系。如果在算法中暂且抹去和递归无关的visit语句，则三个遍历算法完全相同。因此，从递归执行过程的角度来看，前序、中序、后序遍历也完全相同。“ 这段话给我们的提示就是，前序、中序、后序遍历的算法相同，只是printf()语句位置而已。 根据前序序列、中序序列构建二叉树 函数定义 bt rebuildTree(char *pre, char *in, int len); 参数： * pre：前序遍历结果的字符串数组 * in：中序遍历结果的字符串数组 len : 树的长度 例如： 前序遍历结果: a b c d e f g h 中序遍历结果: c b e d f a g h 算法思想 递归思想，递归的终止条件是树的长度len == 0 在中序遍历的数组中找到前序数组的第一个字符，记录在中序数组中的位置index.如果找不到，说明前序遍历数组和中序遍历数组有问题，提示错误信息，退出程序即可;找到index后，新建一个二叉树节点t，t->item = *pre,然后递归的求t的左孩子和有孩子 递归的左孩子：void rebuildTree(pre + 1, in, index) 递归的右孩子：void rebuildTree(pre + (index + 1), in + (index + 1), len - (index + 1)) 实现代码（c语言版） /** * Description:根据前序和中序构建二叉树 */bt rebuildTree(char *pre, char *in, int len){\tbt t;\tif(len <= 0)\t{ \t\t//递归终止\t\tt = NULL;\t}else\t{ \t\t//递归主体\t\tint index = 0;\t\t\t\twhile(index < len && *(pre) != *(in + index))\t\t{\t\t\tindex ++;\t\t}\t\t\t\tif(index >= len)\t\t{\t\t\tprintf(\"前序遍历或者中序遍历数组有问题!\\n\");\t\t\texit(-1);\t\t}\t\t\t\tt = (struct bintree *)malloc(sizeof(struct bintree));\t\tt->item = *pre;\t\tt->lchild = rebuildTree(pre + 1, in, index);\t\tt->rchild = rebuildTree(pre + (index + 1), in + (index + 1), len - (index + 1));\t}\treturn t;} 后记 2012年今天是最后一天了，哈哈，终于把二叉树该掌握的部分都掌握了，还是不错的，期待新的一年2013年有更多的收获，2013年可能又是我人生发生抉择和变化的一年，我依然会坚持自己的价值观，踏踏实实的走下去，现在我学会最多的就是坚持，坚忍，光说不做是没有的，写程序如此，做人亦如此！","title":"树的学习——（递归构建二叉树、递归非递归前序中序后序遍历二叉树、根据前序序列、中序序列构建二叉树）"},{"content":"这个系列的贴子属于日记类型的帖子，现在看可能会比较水，算是我个人的奋斗记录吧，希望将来可以对后来（学习）人有所帮助 个人技术背景：做JAVA开发五年，懂C#基本语法（停留在2.0）工作经验3.5年 主要技术：为Surface 开发应用，WinRT，XAML   ----------------------------------------------------   2012-12-28 今天的收获不是很大，主要研究了： 1“图片”的显示与隐藏 2模拟实现线程Sleep() 3多图片合成技术   转载请注明作者：二厶可可肉.cyrusLiu.刘.步云.龙飞...小雪  （好吧有点长） 　  　　　　　　出处：http://blog.csdn.net/cyrusliu/article/details/8449507   现实与隐藏 经过多方尝试，以失败告终，但庆幸的是，找到了解决方案，那就是把Image放入StackPanel中，然后再给这个对象设置一下名字，在后台设置图片的Visibility属性就可以了 Visibility是一个枚举类型，他有两个值Visible和Collapsed   第一个是显示，第二个是隐藏，默认情况下是显示的   sp1.Visibility = Visibility.Visible;  sp1.Visibility = Visibility.Collapsed;   Sleep线程 在通常情况下可以使用System.Threading.Thread.Sleep(1000);但是在做Surface的时候，这个类是不能用的，那又该怎么办呢？ 灵机一动，使用for(int i=0;i<10W;I++){}的方法来实现，虽然会有一定的不确定性（精准），但在特殊情况下，可以这样做一下 图片合成技术 如果你是一个很早就接触编程的朋友可能会知道当年￥符号是怎么打的，在这里我再解释一下，但是没有直接的这个符号，需要用两个符号来组合出来。 通常的做法是 先打印Y  然后退格 在打印= 这样，人民币的符号就打印出来了。它的特点是 让两个图片叠加，上面的压下面的。图片合成技术也一样 以前有PictureBox 可以通过设置背景及图片来实现这个效果，优先显示图片，后显示背景，如果图标的对应位置为透明，则显示后面的背景部分。现在说一下我的实现方法 使用StackPanel来包裹Image。分别设置背景及Source即可。 如果你问3个图像合成怎么办？很简单，在外面再包一个StackPanel就行了 顺便说些其他图片的功能 Opacity 透明度100%不透明，0%透明 NineGrid拉伸特效 <Image Height=\"48\" Width=\"48\" Source=\"Assets/勇士.png\" Opacity=\"0.5\" NineGrid=\"0\" RenderTransformOrigin=\"1,0\"   >                    <Image.RenderTransform>                        <CompositeTransform TranslateX=\"60\" TranslateY=\"60\" Rotation=\"26.095\"/>                    <\/Image.RenderTransform>                <\/Image> TranslateX 向右平移显示 Rotation 旋转         对技术的狂热是我进步的阶梯，对知识的渴望是我学习的源动力。       鸣谢   师父         二厶可可肉 2012年12月28日         您的支持是我创作的最大动力            ","title":"可可肉的奋斗（第五天）2012-12-28----------显示与隐藏And线程Sleep的模拟And多图片合成技术"},{"content":"QQ抖动功能其实就是一个音频文件+窗口移动来实现的，这里我用到的播放音频文件的API是PlaySound，播放的音 频文件是\"shake.wav\"，这个文件是直接在QQ安装目录下复制过来的，只要把它放到源程序目录下即可。在使用这个 播放音频的API：PlaySound时，需要在#include<windows.h>后面加上 #include<mmsystem.h>#pragma comment(lib, \"WINMM.LIB\") 先建一个基本对话框的MFC程序，然后把对话框上默认的控件删除（这个不是必须的）。然后添加一个Button控件， 响应按钮的单击事件。 void CMoveDlg::OnBnClickedButton1(){\t// TODO: 在此添加控件通知处理程序代码\tCRect rect;\tGetWindowRect(&rect);\tint m_move=10;\tPlaySound(\"shake.wav\",NULL,SND_FILENAME | SND_ASYNC);\tfor(int i=1;i<9;i++)\t{\t\trect.OffsetRect(0,m_move);\t\tMoveWindow(&rect);\t\tSleep(50);\t\trect.OffsetRect(m_move,0);\t\tMoveWindow(&rect);\t\tSleep(50);\t\tif (10==m_move)\t\t{\t\t\tm_move=-10;\t\t}\t\telse\t\t{\t\t\tm_move=10;\t\t}\t}} 大家自己运行下就可以体会到效果了！","title":"MFC实现QQ抖动"},{"content":"转载注明出处 http://blog.csdn.net/xugangjava/article/details/8450346 工程目录如下： 1.首先编写idl文件 import \"oaidl.idl\";import \"ocidl.idl\";[        uuid(80DDC35E-320E-4f9c-979F-522DDCD34FD3),        dual,        oleautomation]interface IXGUtilitiesInterface : IDispatch {        HRESULT Hello([in] INT a, [in] INT b, [out, retval] INT *presult);}[      uuid(78FBDE61-B979-47cf-B3EC-15F7814E58B1)]library XGUtilitiesLib{        importlib(\"stdole2.tlb\");        [uuid(ED2A47D0-D7CC-4edd-8C17-61361EB1B851)]              coclass XGUtilitiesObject {              [default] interface IXGUtilitiesInterface;        };}; 2.编译idl文件 打开vs 命令行工具cmd，midl XGUtilities.idl /tlb XGUtilities.tlb 在同目录下面生成tlb文件 我的插件是 XGUtilities.tlb 3.编写com实现 # -*- coding: gbk -*-import comtypesimport comtypes.server.localserverfrom comtypes.client import GetModule#每次改动时需要执行一次，打包时无需执行#GetModule(\"XGUtilities.tlb\")from comtypes.gen.XGUtilitiesLib import XGUtilitiesObjectclass XGUtilitiesObjectImpl(XGUtilitiesObject):     _reg_threading_ = \"Both\"    _reg_progid_ = \"XGUtilitiesLib.XGUtilitiesObject.1\"    _reg_novers_progid_ = \"XGUtilitiesLib.XGUtilitiesObject\"    _reg_desc_ = \"许刚工具集\"    _reg_clsctx_ = comtypes.CLSCTX_INPROC_SERVER | comtypes.CLSCTX_LOCAL_SERVER    _regcls_ = comtypes.server.localserver.REGCLS_MULTIPLEUSE        def Hello(self,a, b):        return a + bif __name__ == '__main__':    from comtypes.server.register import UseCommandLine    UseCommandLine(XGUtilitiesObjectImpl) 4.编写py2exe打包 # -*- coding: gbk -*-from distutils.core import setupimport py2exeimport sysmanifest = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">    <noInheritable><\/noInheritable>    <assemblyIdentity type=\"win32\" name=\"Microsoft.VC90.CRT\" version=\"9.0.21022.8\" processorArchitecture=\"x86\" publicKeyToken=\"1fc8b3b9a1e18e3b\"><\/assemblyIdentity>    <file name=\"msvcr90.dll\" hashalg=\"SHA1\" hash=\"9785b1c493deb5b2134dc4aef3719cee207001bc\"><asmv2:hash xmlns:asmv2=\"urn:schemas-microsoft-com:asm.v2\" xmlns:dsig=\"http://www.w3.org/2000/09/xmldsig#\"><dsig:Transforms><dsig:Transform Algorithm=\"urn:schemas-microsoft-com:HashTransforms.Identity\"><\/dsig:Transform><\/dsig:Transforms><dsig:DigestMethod Algorithm=\"http://www.w3.org/2000/09/xmldsig#sha1\"><\/dsig:DigestMethod><dsig:DigestValue>VF5ECUAHPV7EnUf+/UIXMPizPvs=<\/dsig:DigestValue><\/asmv2:hash><\/file> <file name=\"msvcp90.dll\" hashalg=\"SHA1\" hash=\"0f6bbf7fe4fb3fca2cb5b542eca1a1cad051f01c\"><asmv2:hash xmlns:asmv2=\"urn:schemas-microsoft-com:asm.v2\" xmlns:dsig=\"http://www.w3.org/2000/09/xmldsig#\"><dsig:Transforms><dsig:Transform Algorithm=\"urn:schemas-microsoft-com:HashTransforms.Identity\"><\/dsig:Transform><\/dsig:Transforms><dsig:DigestMethod Algorithm=\"http://www.w3.org/2000/09/xmldsig#sha1\"><\/dsig:DigestMethod><dsig:DigestValue>3Wg+StVMq2uhx7POnAkl2w4dDmY=<\/dsig:DigestValue><\/asmv2:hash><\/file> <file name=\"msvcm90.dll\" hashalg=\"SHA1\" hash=\"7f3290ab2b7444c2b4a9b1fedfdb16466d7a21bb\"><asmv2:hash xmlns:asmv2=\"urn:schemas-microsoft-com:asm.v2\" xmlns:dsig=\"http://www.w3.org/2000/09/xmldsig#\"><dsig:Transforms><dsig:Transform Algorithm=\"urn:schemas-microsoft-com:HashTransforms.Identity\"><\/dsig:Transform><\/dsig:Transforms><dsig:DigestMethod Algorithm=\"http://www.w3.org/2000/09/xmldsig#sha1\"><\/dsig:DigestMethod><dsig:DigestValue>/YfRn7UQENzdMeoMHxTgdRMiObA=<\/dsig:DigestValue><\/asmv2:hash><\/file><\/assembly>\"\"\"class Target:    def __init__(self, **kw):        self.__dict__.update(kw)        self.version = \"0.0.0\"        self.company_name = \"http://blog.csdn.net/xugangjava\"        self.copyright = \"@2012,power by 许刚\"        self.name = \"http://blog.csdn.net/xugangjava\"my_com_server_target = Target(        description = \"许刚工具集\",        modules = [\"XGUtilities\"],        other_resources = [                           (\"TYPELIB\", 1,open(r\"XGUtilities.tlb\", \"rb\").read()),                           (24,1,manifest),        ],        create_exe = False)setup(    name=\"许刚工具集\",    options={\"py2exe\": {        \"compressed\": 2,         \"dll_excludes\": [\"mswsock.dll\", \"powrprof.dll\"],         \"includes\":[\"comtypes.gen._78FBDE61_B979_47CF_B3EC_15F7814E58B1_0_0_0\"]    }},    zipfile=None,    version=\"0.0.0\",    description=\"许刚工具集\",    author=\"许刚\",    author_email=\"http://blog.csdn.net/xugangjava\",    ctypes_com_server=[my_com_server_target]) 运行打包 python setup.py py2exe reg.bat 内容 regsvr32 XGUtilities.dll 运行注册  接下来来测试这个插件 Test.html内容 <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"><html>  <head>  \t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/>\t<SCRIPT LANGUAGE=\"JavaScript\">\t    window.onload = function () {\t        var obj = new ActiveXObject(\"XG.Utilities\");\t        alert(obj.Hello(1,3));\t    }\t<\/SCRIPT><\/head>  <body>  <\/body>  <\/html> 打开html 测试成功 为了验证兼容性 ，插件是否依赖python环境， 在没有安装python的环境中测试是否能注册插件，在2003虚拟机（没有安装python环境）下注册插件后 这里html修改为 <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"><html>  <head>  \t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/>\t<SCRIPT LANGUAGE=\"JavaScript\">\t    function Hello() {\t        var obj = document.getElementById(\"obj\")\t        alert(obj.Hello(1,3));\t    }\t<\/SCRIPT><\/head>  <body>  <object id=\"obj\" width=\"100\" height=\"100\" classid=\"clsid:ED2A47D0-D7CC-4edd-8C17-61361EB1B851\" ><\/object><input type=\"button\" value=\"Hello\" onclick=\"Hello()\"/><\/body>  <\/html> 希望大家通过本文的介绍，可以用python快速开发出自己的ActiveX 插件","title":"Python ActiveX Py2exe 制作插件"},{"content":"这开始介绍Zii组件之前，先简要介绍一下Yii支持的数据源接口 IDataProvider，IDataProvider主要功能是为UI组件如GridView，ListView等提供数据源，同时也支持数据的分页和排序。下图为Yii内置的三种数据源： CActiveDataProvider  基于Active Record的数据源 CArraryDataProvider 基于数组的数据源 CSqlDataProvider      基于SQL查询的数据源 三种Data Provider的使用大同小异： CActiveDataProvider 基于ActiveRecord, 它通过AR的 CActiveRecord::findAll方法读取数据库记录，并通过 criteria属性设置查询条件。 如： $dataProvider=new CActiveDataProvider('Post', array(    'criteria'=>array(        'condition'=>'status=1',        'order'=>'create_time DESC',        'with'=>array('author'),    ),    'pagination'=>array(        'pageSize'=>20,    ),));// $dataProvider->getData() will return a list of Post objects CArrayDataProvider 基于数组，其中属性rawData设置原始数据，一般为数组或者DAO查询结果，如： $rawData=Yii::app()->db->createCommand('SELECT * FROM tbl_user')->queryAll();// or using: $rawData=User::model()->findAll();$dataProvider=new CArrayDataProvider($rawData, array(    'id'=>'user',    'sort'=>array(        'attributes'=>array(             'id', 'username', 'email',        ),    ),    'pagination'=>array(        'pageSize'=>10,    ),));// $dataProvider->getData() will return a list of arrays. CSqlDataProvider 基于SQL查询，通过设置 sql语句来配置，比如： $count=Yii::app()->db->createCommand('SELECT COUNT(*) FROM tbl_user')->queryScalar();$sql='SELECT * FROM tbl_user';$dataProvider=new CSqlDataProvider($sql, array(    'totalItemCount'=>$count,    'sort'=>array(        'attributes'=>array(             'id', 'username', 'email',        ),    ),    'pagination'=>array(        'pageSize'=>10,    ),));// $dataProvider->getData() will return a list of arrays.关于DataProvider详细文档可以参见Yii文档","title":"Yii Framework 开发教程(28) Data Provider 简介"},{"content":"归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列， 每个子序列是有序的。然后再把有序子序列合并为整体有序序列。 　归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 动态演示如下：   思路 分割->合并。 归并操作的工作原理如下： 　　申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 　　设定两个指针，最初位置分别为两个已经排序序列的起始位置 　　比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 　　重复步骤3直到某一指针达到序列尾 　　将另一序列剩下的所有元素直接复制到合并序列尾 示例代码： #include<iostream>using namespace std;void merge(int *a,int low,int mid,int high){\tint i=low;//i，j是检测指针分别指向待归并数组的第一子序列和第二子序列的首元素\tint j=mid+1;\tint k=low;//k 是指向辅助数组的第一个元素\tint *b= new int[high]();//动态创建一个辅助数组，并初始化为0\t//int *b= new int[high];这样写的话 辅助数组是没有初始化的\twhile(i<=mid  && j<=high)//两个表都未检测完，两两比较\t\tif(a[i] <= a[j])//此处也算是归并排序稳定性的关键，不能用小于\t\t\tb[k++]=a[i++];\t\telse\t\t\tb[k++]=a[j++];\twhile( i <= mid)//若只有第一个未检测完，复制剩下的元素\t\tb[k++]=a[i++];\twhile( j <= high )//若只有第二个子序列未检测完，复制剩下的元素\t\tb[k++] =a[j++];\tfor(i=low;i<=high;i++)//将辅助数组中的元素写入的原先进行归并排序的数组中\t\ta[i]=b[i];}void mergeSort(int *a,int low,int high){\tif(low < high){\t\tint mid =  (low + high)/2;//从中间划分两个子序列\t\tmergeSort(a,low,mid);//从左侧子序列进行递归排序\t\tmergeSort(a,mid+1,high);//从右侧子序列进行递归排序\t\tmerge(a,low,mid,high);//合并\t}\t\t}void main(){\tint a[]={4,3,2,1,6,7,5};// 用于测试的数据\tcout<<\"Before mergeSort:\"<<endl;\tfor(int i=0;i<7;i++){\t\t\tcout<<a[i]<<\" \";\t}\tcout<<endl;\tcout<<\"After mergeSort\"<<endl;\tmergeSort(a,0,6);\tfor(int i=0;i<7;i++){\t\tcout<<a[i]<<\" \";\t}\tcout<<endl;} 性能分析： 时间复杂度为O(nlogn) 这是该算法中最好、最坏和平均的时间性能。 　　空间复杂度为 O(n) 　　比较操作的次数介于(nlogn) / 2和nlogn - n + 1。 　　赋值操作的次数是(2nlogn)。归并算法的空间复杂度为：0 (n) 　　归并排序比较占用内存，但却效率高且稳定的算法。 有人对归并排序算法也进行了改进，相关链接如下： 点击打开链接","title":"[置顶] 归并排序 知识点小结"},{"content":"纯粹是自娱自乐，并没有对opencv的使用进行深入的学习，用opencv打开视频文件或者打开摄像头采集，然后保存，这也是最基础的东西。 一、安装配置环境                                                                                           VS2008下安装配置opencv，2005、2010的步骤应该差不多的，这里提供网址，没有比这个更详细的了http://www.opencv.org.cn/index.php/VC_2008_Express%E4%B8%8B%E5%AE%89%E8%A3%85OpenCV2.3.1 二、程序代码                                                                                                opencv的学习，推荐《opencv教程——基础篇》，其中第三章有对视频的详细讲解，下面贴出代码： #include \"stdafx.h\"#include \"cv.h\" #include \"highgui.h\" int main( int argc, char** argv ) { \tCvCapture* capture = 0; \tIplImage* frame = 0; \tcapture = cvCaptureFromAVI(\"video.avi\");\t//capture = cvCaptureFromCAM( 0 ); //使用摄像头 就换成这句\tdouble fps = cvGetCaptureProperty(capture,CV_CAP_PROP_FPS); //视频帧率 \t//int fps=25; //捕捉帧率 ,影响生产的文件的播放速度\t\tframe = cvQueryFrame( capture ); //先捕获一帧\tCvVideoWriter* writer = 0; //保存就加上这句\tint isColol=1; \t//int frameW=640; \t//int frameH=480; \twriter=cvCreateVideoWriter(\"out.avi\",CV_FOURCC('F','L','V','1'),fps,cvSize(frame->width,frame->height),isColol);//这里大小随便设好像不行\t//cvNamedWindow( \"窗口\", 1 ); \t//for(int i=0;i<50;i++) //2秒\tfor(;;) //一直读\t{ \t\tframe = cvQueryFrame( capture ); \t\tcvWriteFrame(writer,frame ); \t\tcvShowImage( \"窗口\", frame ); //显示一帧图像\t\tcvWaitKey(1000 / fps);//视频速度 \t} \tcvReleaseVideoWriter(&writer); \tcvReleaseImage(&frame); \tcvReleaseCapture( &capture ); \tcvDestroyWindow(\"窗口\"); \treturn 0; }","title":"opencv采集视频/摄像头数据并保存"},{"content":"      今天做谭浩强的《C程序设计》第四版的辅导手册，做到第七章的13题（用递归求n阶勒让德多项式）时，发现一个错误，以下贴出的书上给出的参考答案。错误的地方我以注释的形式标出吧。 第一个错误出现在题目给出的公式，第二个减号应该为乘号（没办法写出公式），博主是根据维基百科给出的曲线图试答案试出来的。哈哈 int main()#include <stdio.h>{\tint x,n;\tfloat p(int,int);\tprintf(\"\\ninput n & x:\");\tscanf(\"%d,%d\",&n,&x);\tprintf(\"n=%d,x=%d\\n\",n,x);\tprintf(\"P%d(%d)=%6.2f\\n\",n,x,p(n,x));\treturn 0;}float p(int n,int x){\tif(n==0)\t\treturn (1);\telse if(n==1)\t\treturn (x);\telse\treturn(2*n-1)*x*p((n-1),x)-(n-1)*p((n-2),x)/n;  //此处应该为\t\t\t\t\t\t\t//return((2*n-1)*x*p((n-1),x)-(n-1)*p((n-2),x))/n;                                                       //谭老忘了个括号，使式子先运算后面部分。} 输入3，4时书上给出的运行结果是947.33。 实际结果应该是154.00。 希望大家做题时不要以为自己的答案错了。 还有一个是数学公式的错误：勒让德多项式的x的定义域为[-1,1]，根据数学，是不可以拿 3 去测试的。 这么多错误，看来谭老确实老了，但出现这种错误是难免的，我们编程出现的错误更多咧，望在第五版改正哈。谭老的书写得不错，讲解得很详细，自己看的话理解得比老师讲的好。 如果本文如有错误，欢迎留言指出。","title":"C程序设计（谭浩强）的几处错误"},{"content":"转载请注明出处，谢谢http://blog.csdn.net/ACM_cxlove?viewmode=contents    by---cxlove 题目：给出一些点，要求给出4条线，两条平行x轴，两条平等y轴，不经过任何 点，把平面分为9块，每块包含的点数，正数可以满足每个人的需要 http://codeforces.com/contest/260/problem/E  当给定每一个方块的人数之后，我们便可以求出4条线的坐标 这个我们按x,y坐标 排序，取前多少个就行了。 但是这样只是在宏观上大致求出坐标，还需要考察若干个分块，查询数量，进行比较 那么关于查询每个分块的数量的话，我是通过线段树实现的 而且比较暴力 根据x坐标 建立线段树，每个结点存放了一个vector，表示这个区间内所有的点的y坐标值 查询的时候，直接二分vector就行了 #include<iostream>  #include<cstdio>  #include<map>  #include<cstring>  #include<cmath>  #include<vector>  #include<algorithm>  #include<set>  #include<string>  #include<queue>  #define inf 1000000005  #define M 40  #define N 100005#define maxn 300005  #define eps 1e-12#define zero(a) fabs(a)<eps  #define Min(a,b) ((a)<(b)?(a):(b))  #define Max(a,b) ((a)>(b)?(a):(b))  #define pb(a) push_back(a)  #define mp(a,b) make_pair(a,b)  #define mem(a,b) memset(a,b,sizeof(a))  #define LL long long  #define MOD 1000000007#define lson step<<1#define rson step<<1|1#define sqr(a) ((a)*(a))  #define Key_value ch[ch[root][1]][0]  #define test puts(\"OK\");  #define pi acos(-1.0)#define lowbit(x) ((-(x))&(x))#define HASH1 1331#define HASH2 10001#pragma comment(linker, \"/STACK:1024000000,1024000000\")  using namespace std;struct Set_tree{    int left,right;    vector<int>v;}L[N*4];struct Point{    int x,y;    bool operator<(const Point n)const{        return x!=n.x?x<n.x:y<n.y;    }}p[N];int n,x[N],y[N];int a[9],b[9];double ret_x1,ret_x2,ret_y1,ret_y2;void Bulid(int step,int l,int r){    L[step].left=l;    L[step].right=r;    L[step].v.clear();    for(int i=l;i<=r;i++)        L[step].v.pb(p[i].y);    sort(L[step].v.begin(),L[step].v.end());    if(l==r)        return;    int m=(l+r)>>1;    Bulid(lson,l,m);    Bulid(rson,m+1,r);}int Query(int step,int l,int r,int val){    if(L[step].left==l&&r==L[step].right){        if(L[step].v.size()==0) return 0;        if(L[step].v[0]>val) return 0;        if(L[step].v.back()<=val) return L[step].v.size();        return (upper_bound(L[step].v.begin(),L[step].v.end(),val)-L[step].v.begin());    }    int m=(L[step].left+L[step].right)>>1;    if(r<=m) return Query(lson,l,r,val);    else if(l>m) return Query(rson,l,r,val);    else return Query(lson,l,m,val)+Query(rson,m+1,r,val);}bool ok(){    int x1=b[a[0]]+b[a[1]]+b[a[2]]-1;    int x2=x1+b[a[3]]+b[a[4]]+b[a[5]];    int y1=b[a[0]]+b[a[3]]+b[a[6]]-1;    int y2=y1+b[a[1]]+b[a[4]]+b[a[7]];    if(x1+1>=n||x[x1]==x[x1+1]) return false;    if(x2+1>=n||x[x2]==x[x2+1]) return false;    if(y1+1>=n||y[y1]==y[y1+1]) return false;    if(y2+1>=n||y[y2]==y[y2+1]) return false;    if(Query(1,0,x1,y[y1])!=b[a[0]]) return false;    if(Query(1,0,x1,y[y2])!=b[a[0]]+b[a[1]]) return false;    if(Query(1,x1+1,x2,y[y1])!=b[a[3]]) return false;    if(Query(1,x1+1,x2,y[y2])!=b[a[3]]+b[a[4]]) return false;    ret_x1=(x[x1]+x[x1+1])/2.0;    ret_x2=(x[x2]+x[x2+1])/2.0;    ret_y1=(y[y1]+y[y1+1])/2.0;    ret_y2=(y[y2]+y[y2+1])/2.0;    return true; }int main(){    //freopen(\"input.txt\",\"r\",stdin);    while(scanf(\"%d\",&n)!=EOF){        for(int i=0;i<n;i++){            scanf(\"%d%d\",&p[i].x,&p[i].y);            x[i]=p[i].x;y[i]=p[i].y;        }        sort(p,p+n);        sort(x,x+n);        sort(y,y+n);        Bulid(1,0,n-1);        for(int i=0;i<9;i++) scanf(\"%d\",&b[i]);        for(int i=0;i<9;i++) a[i]=i;        int t=362880;        while(t--){            if(ok()){                printf(\"%.1f %.1f\\n%.1f %.1f\\n\",ret_x1,ret_x2,ret_y1,ret_y2);                break;            }            next_permutation(a,a+9);        }        if(t<=0) puts(\"-1\");    }    return 0;}","title":"CF 260E Dividing Kingdom(枚举+线段树)"},{"content":"// //  main.cpp //  AUTO_PRO // //  Created by yanzhengqing on 12-12-11. //  Copyright (c) 2012年 yanzhengqing. All rights reserved. // #include <iostream> using namespace std; /***  *char *strchr(string, c) - search a string for a character  *  *Purpose:  *       Searches a string for a given character, which may be the  *       null character '\\0'.  *  *Entry:  *       char *string - string to search in  *       char c - character to search for  *  *Exit:  *       returns pointer to the first occurence of c in string  *       returns NULL if c does not occur in string  *  *Exceptions:  *  *******************************************************************************/ ///////////////////////////////////////////////////////////////////////////////// /*说明：   1. __cdecl 是C Declaration的缩写（declaration，声明），表示C语言默认的函数调用方法：所有参数从右到左依次入栈，这些参数由调用者清除，称为手动清栈。被调用函数不会要求调用者传递多少参数，调用者传递过多或者过少的参数，甚至完全不同的参数都不会产生编译阶段的错误。   2.  从字符串头开始查找某字符出现的位置   3.  按照ANSI(American National Standards Institute)标准，不能对void指针进行算法操作，即不能对void指针进行如p++的操作,所以需要转换为具体的类型指针来操作,例如char *。（引用网友的结论）   4.  size_t 类型定义在cstddef头文件中，该文件是C标准库的头文件stddef.h的C++版。它是一个与机器相关的unsigned类型，其大小足以保证存储内存中对象的大小。 */ char * __cdecl strchr (                       constchar * string,                       int ch                        ) {    while (*string && *string != (char)ch)         string++;         if (*string == (char)ch)        return((char *)string);     return(NULL); } int main() {    char *p =NULL;     constchar brc[50] =\"blog.csdn.net/barry_yan\";     p =strchr(brc,(int)'a');    if(p)     {       cout<<*p<<endl;     }    else     {        cout<<\"null\"<<endl;     }    return0; }","title":"strchr源码"},{"content":"介绍完Yii数据库接口外，从本篇开始介绍Zii组件，包括列表视图ListView，表格视图GridView，此外还包括一些基于JQuery的UI组件，如AutoComplete,DataPicker, Button, Drag 和 Drop等。 本文介绍Menu菜单用法，CMenu使用Html 列表显示多级菜单，Menu配置通过其属性item来配置，每个菜单项包括三个主要属性 visible  是否可见 active 当前菜单项是否选中， items 子菜单项。 此外还包括如下属性： label: 可选，菜单名称，支持使用HTML标记. url: 可选，点击该菜单转的URL链接 template: 可选，菜单模板 linkOptions: array, 可选，额外的HTML链接属性 itemOptions: array, 可选，额外的显示菜单项的HTML属性。 submenuOptions: array, 可选，额外显示子菜单的HTML属性. 一般可以把Menu定义在Layout布局中，比如本例，修改protected/views/layout/main.php <?php $this->widget('zii.widgets.CMenu',array(\t\t'items'=>array(\t\t\t\t\tarray('label'=>'Home',\t\t\t\t\t\t'url'=>array('/site/index')),\t\t\t\t\tarray('label'=>'About',\t\t\t\t\t\t'url'=>array('/site/page',\t\t\t\t\t\t'view'=>'about')),\t\t\t\t\tarray('label'=>'Contact',\t\t\t\t\t\t'url'=>array('/site/page',\t\t\t\t\t\t'view'=>'contact')),\t\t\t\t\tarray('label'=>'Login',\t\t\t\t\t\t'url'=>array('/site/login'),\t\t\t\t\t\t'visible'=>false),\t\t\t\t\t),\t)); ?> 本例使用CViewAction来显示几个静态页面，静态页面的缺省目录为当前Controller的View目录下的pages子目录，本例在pages目录下创建了两个静态页面about.php, contact. 要使用CViewAction来显示静态页面，需要修改Controller的actions方法： public function actions(){\treturn array(\t\t'page'=>array(\t\t\t'class'=>'CViewAction',\t\t\t)\t\t);} 此外如果要显示菜单的层次轨迹（breadcrumbs），可以使用Zii组件中的CBreadcrumbs组件，CBreadcrumbs一般配合CMenu使用 <?php if(isset($this->breadcrumbs)):?>\t<?php $this->widget('zii.widgets.CBreadcrumbs', array(\t\t\t'links'=>$this->breadcrumbs,\t)); ?><!-- breadcrumbs --><?php endif?> 本例使用Yii缺省的CSS，显示结果如下： 如果不使用CSS，显示结果如下：   由此可见，需要同时使用CMenu组件配合合适的CSS才能显示漂亮的菜单。 本例下载","title":"Yii Framework 开发教程(29) Zii组件-Menu 示例"},{"content":"Linux内核哈希表分析与应用 Author:tiger-john Time:2012-12-20 mail:jibo.tiger@gmail.com Blog:http://blog.csdn.net/tigerjb/article/details/8450995 转载请注明出处。 前言： 1.基本概念：散列表（Hash　table，也叫哈希表），是根据关键码值(Key　value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 2. 常用的构造散列函数的方法散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位。散列表的常用构造方法有： 　(1)直接定址法 　(2)数字分析法 　(3)平方取中法 　(4)折叠法 　(5)随机数法 　(6)除留余数法 3、处理冲突的方法　　散列表函数设计好的情况下，可以减少冲突，但是无法完全避免冲突。常见有冲突处理方法有：   (1)开放定址法   (2)再散列法   (3)链地址法(拉链法)   (4)建立一个公共溢出区 4. 散列表查找性能分析　散列表的查找过程基本上和造表过程相同。一些关键码可通过散列函数转换的地址直接找到，另一些关键码在散列函数得到的地址上产生了冲突，需要按处理冲突的方法进行查找。在介绍的三种处理冲突的方法中，产生冲突后的查找仍然是给定值与关键码进行比较的过程。所以，对散列表查找效率的量度，依然用平均查找长度来衡量。 　　查找过程中，关键码的比较次数，取决于产生冲突的多少，产生的冲突少，查找效率就高，产生的冲突多，查找效率就低。因此，影响产生冲突多少的因素，也就是影响查找效率的因素。影响产生冲突多少有以下三个因素：    1. 散列函数是否均匀；    2. 处理冲突的方法；    3. 散列表的装填因子。 　　散列表的装填因子定义为：α= 填入表中的元素个数 / 散列表的长度。 　　α是散列表装满程度的标志因子。由于表长是定值，α与“填入表中的元素个数”成正比，所以，α越大，填入表中的元素较多，产生冲突的可能性就越大；α越小，填入表中的元素较少，产生冲突的可能性就越小。实际上，散列表的平均查找长度是装填因子α的函数，只是不同处理冲突的方法有不同的函数。 一.Linux内核哈希表数据结构hash最重要的是选择适当的hash函数，从而平均的分配关键字在桶中的位置，从而优化查找 插入和删除所用的时间。然而任何hash函数都会出现冲突问题。内核采用的解决哈希冲突的方法是：拉链法拉链法解决冲突的做法是：将所有关键字为同义词的结点链接在同一个链表中。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针（struct hlist_head name）组成的指针数组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α(装填的元素个数/数组长度)可以大于 1，但一般均取α≤1。当然，用拉链法解决hash冲突也是有缺点的，指针需要额外的空间。 1. 其代码位于include/linux/list.h中，3.0内核中将其数据结构定义放在了include/linux/types.h中哈希表的数据结构定义： 如图：   struct  hlist_head{ struct hlist_node *first; } struct  hlist_node {         struct hlist_node *next,**pprev; }  1>hlist_head表示哈希表的头结点。哈希表中每一个entry(list_entry)所对应的都是一个链表（hlist）.hlist_head结构体只有一个域，即first。First指针指向该hlist链表的第一个结点。 2>hlist_node结构体有两个域，next和pprev。 (1)next指向下个hlist_node结点，倘若改结点是链表的最后一个节点，next则指向NULL (2)pprev是一个二级指针，它指向前一个节点的next指针。 2.Linux 中的hlist(哈希表)和list是不相同的，在list中每个结点都是一样的，不管头结点还是其它结点，使用同一个结构体表示，但是在hlist中，头结点使用的是struct hlist_head来表示的，而对于其它结点使用的是strcuct hlist_node这个数据结果来表示的。还有list是双向循环链表，而hlist不是双向循环链表。因为hlist头结点中没有prev变量。为什么要这样设计呢？散列表的目的是为了方便快速的查找，所以散列表通常是一个比较大的数组，否则“冲突”的概率会非常大，这样就失去了散列表的意义。如何来做到既能维护一张大表，又能不占用过多的内存呢?此时只能对于哈希表的每个entry(表头结点)它的结构体中只能存放一个指针。这样做的话可以节省一半的指针空间，尤其是在hash bucket很大的情况下。（如果有两个指针域将占用8个字节空间） 3.hlist的结点有两个指针，但是pprev是指针的指针，它指向的是前一个结点的next指针，为什么要采用pprev，二不采用一级指针？由于hlist不是一个完整的循环链表，在list中，表头和结点是同一个数据结构，直接用prev是ok的。在hlist中，表头中没有prev，只有一个first。 1>为了能统一地修改表头的first指针，即表头的first指针必须修改指向新插入的结点，hlist就设计了pprev。list结点的pprev不再是指向前一个结点的指针，而是指向前一个节点（可能是表头）中的next(对于表头则是first)指针,从而在表头插入的操作中可以通过一致的node->pprev访问和修改前结点的next（或first）指针。 2>还解决了数据结构不一致，hlist_node巧妙的将pprev指向上一个节点的next指针的地址，由于hlist_head和hlist_node指向的下一个节点的指针类型相同，就解决了通用性。 二.哈希表的声明和初始化宏 1.对哈希表头结点进行初始化实际上，struct hlist_head只定义了链表结点，并没有专门定义链表头，可以使用如下三个宏 #define HLIST_HEAD_INIT { .first = NULL} #define HLIST_HEAD(name) struct hlist_head name = {.first = NULL} #define INIT_HLIST_HEAD(ptr)   ((ptr->first)=NULL)) 1>name 为结构体 struct hlist_head{}的一个结构体变量。 2>HLIST_HEAD_INIT 宏只进行初始化 Eg: struct hlist_head my_hlist = HLIST_HEAD_INIT 调用HLIST_HEAD_INIT对my_hlist哈希表头结点只进行初始化，将表头结点的fist指向空。 3>HLIST_HEAD(name)函数宏既进行声明并且进行初始化。 Eg:  HLIST_HEAD(my_hlist); 调用HLIST_HEAD函数宏对my_hlist哈希表头结点进行声明并进行初始化。将表头结点的fist指向空。 4>HLIST_HEAD宏在编译时静态初始化，还可以使用INIT_HLIST_HEAD在运行时进行初始化 Eg: INIT_HLIST_HEAD(&my_hlist); 调用INIT_HLIST_HEAD俩将my_hlist进行初始化，将其first域指向空即可。 2.对哈希表结点进行初始化1>Linux 对哈希表结点初始化提供了一个接口: static iniline void INIT_HLIST_NODE(struct hlist_node *h) (1) h:为哈希表结点 2>实现： static inline void INIT_HLIST_NODE(struct hlist_node *h) { h->next = NULL;        h->pprev = NULL; }  改内嵌函数实现了对struct hlist_node 结点进行初始化操作，将其next域和pprev都指向空，实现其初始化操作。 三.哈希链表的基本操作（插入，删除，判空） 1.判断哈希链表是否为空1>function:函数判断哈希链表是否为空，如果为空则返回1.否则返回0 2>函数接口： static inline  int hlist_empty(const struct hlist_head *h) h:指向哈希链表的头结点。 3>函数实现： static inline  int hlist_empty(const struct hlist_head *h) { return !h->first; } 通过判断头结点中的first域来判断其是否为空。如果first为空则表示该哈希链表为空。 2.判断节点是否在hash表中1>function:判断结点是否已经存在hash表中。 2>函数接口： static inline int hlist_unhashed(const struct hlist_node *h) h:指向哈希链表的结点 3>函数实现： static inline int hlist_unhashed(const struct hlist_node *h) { return !h->pprev } 通过判断该结点的pprev是否为空来判断该结点是否在哈希链表中。 h->pprev等价于h节点的前一个节点的next域。如果前一个节点的next域为空，说明 改节点不在哈希链表中。 3.哈希链表的删除操作1>function:将一个结点从哈希链表中删除。 2>函数接口： static inline void hlist_del(struct hlist_node *n)  n: 指向hlist的链表结点 static inline void hlist_del_init(struct hlist_node *n)  n: 指向hlist的链表结点 3>函数实现 static inline void __hlist_del(struct hlist_node *n) { struct hlist_node  *next =  n->next;          struct hlist_node  **pprev = n->pprev;         *pprev = next;         if (next)                next->pprev = pprev; } Step1:首先获取n的下一个结点next Step2: n->pprev指向n的前一个结点的next指针的地址，这样*pprev就代表n前一个节点的下一个结点的地址（目前指向n本身） Step3:*pprev=next,即将n的前一个节点和n的下一个结点关联起来。 Step4:如果n是链表的最后一个结点，那么n->next即为空，则无需任何操作；否则，next->pprev=pprev,将n的下一个结点的pprev指向n的pprev（既修改后结点的pprev数值） 此时，我们可以假设 在hlist_node 中采用单级指针，那么该如何进行操作呢？ 此时在进行Step3操作时，就需要判断结点是否为头结点。可以用n->prev是否为NULLL来区分头结点和普通结点。 Eg: struct my_hlist_node *next = n->next ; struct my_hlist_node *prev = n->prev ; if(n->prev) n->prev->next = next ; else n->prev = NULL ; if(next)　　　　 next->prev = prev ; 那为什么不进行以上的操作？ (1)代码不够简洁。使用hlist_node结点的话，头结点和普通结点是一致的； static inline void hlist_del(struct hlist_node *n) { __hlist_del(n);        n->next = LIST_POISON1;        n->pprev = LIST_POISON2; }  Step1:调用__hlist_del(n),删除哈希链表结点n(即修改n的前一个结点和后一个结点的之间的关系) Step2和Step3:将n结点的next和pprev域分别指向LIST_POISON1和LIST_POISON2。这样设置是为了保证不在链表中的结点项不能被访问。 static inline void hlist_del_init(struct hlist_node *n) { if (!hlist_unhashed(n)) {                  __hlist_del(n);   INIT_HLIST_NODE(n);        } } Step1:先判断该结点是否在哈希链表中，如果不在则不进行删除。如果是则进行第二步 Step2:调用__hlist_del删除结点n Step3:调用INIT_HLIST_NODE,将结点n进行初始化。 说明： hlist_del和hlist_del_init都是调用__hlist_dle来删除结点n。唯一不同的是对结点n的处理，前者是将n设置为不可用，后者是将其设置为一个空的结点。 4.添加哈希结点1>function:将一个结点添加到哈希链表中。 hlist_add_head:将结点n插在头结点h之后。 hlist_add_before:将结点n插在next结点的前面（next在哈希链表中） hlist_add_after:将结点next插在n之后（n在哈希链表中） 3.0内核新添加了hlist_add_fake函数。 2>Linux 内核提供了三个接口： static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h) struct hlist_node *n: n为将要插入的哈希结点 struct hlist head *h: h为哈希链表的头结点。 static inline void hlist_add_before(struct hlist node *n,struct hlist_node *next)  struct hlist node *n: n为将要插入的哈希结点. struct hlist node *next :next为原哈希链表中的哈希结点。 static inline void hlist_add_after(struct hlist node *n,struct hlist_node *next)  struct hlist node *n: n与原哈希链表中的哈希结点 struct hlist node *next： next为将要插入的哈希结点 注：在3.0内核中新添加了hlist_add_fake static inline void hlist_add_fake(struct hlist_node *n) struct hlist_node *n :n链表哈希结点 3>函数实现： static inline void hlist_add_head(struct hlist_node *n,struct hlist_head *h) { struct  hlist_node  *first = h->first;        n->next = first;        if (first)                first->pprev = &n->next;         h->first = n;         n->pprev = &h->first;  } Step1: first = h->first。获得当前链表的首个结点. Step2: 将first赋值给n结点的next域。让n的next与first关联起来。 Step3: 如果first不为空，则将first的pprev指向n的next域。此时完成了first结点的关联。 如果fist为空，则不进行操作。 Step4: h->first = n; 将头结点的fist域指向n,使n成为链表的首结点。 Step5: n->pprev = &h->first; 将n结点的pprev指向链表的fist域，此时完成了对n结点的关联。 /*next must be !=NULL*/ static inline void hlist_add_before(struct hlist_node *n, struct hlist_node *next) { n->pprev = next->pprev;        n->next = next;        next->pprev = &n->next;        *(n->pprev) =n ; }  Step1: n->pprev = next->prev;将next的pprev赋值给n->pprev。使n的pprev 指向next的前一个结点的next。 Step2: n->next = next;将n结点的next指向next,完成对n结点的关联。 Step3: next->pprev = &n->next;此时修改next结点的pprev，使其指向n的next的地址。此时完成next结点的关联。 Step4: *(n->pprev) =n;此时*(n->pprev)即n结点前面的next，使其指向n。完成对n结点的关联。 注： (1)next不能为空(next即哈希链表中原有的结点) (2)n为新插入的结点。 static inline void hlist_add_after(struct hlist_node *n, struct hlist_node *next ) {           next->next = n->next;           n->next = next;           next->pprev = &n->next;           if (next->next)                     next->next->pprev = &next->next; }  n为原哈希链表中的结点, next新插入的结点。 将结点next插入到n之后(next是新插入的节点) Step1: next->next = n->next; 将next->next指向结点n的下一个结点。 Step2: n->next = next; 修改n结点的next，使n指向next。 Step3: next->pprev = &n->next; 将next的pprev指向n的next Step4: 判断next后的结点是否为空如果，为空则不进行操作，否则将next后结点的pprev指向自己的next 处。 static inline void hlist_add_fake(struct hlist_node  *n) { n->pprev =&n->next; } 对这个函数的含义不太明白,望高人指点。 三.哈希链表的其他操作 1.哈希链表的移动1>function:将以个哈希聊表的头结点用new结点代替，将以前的头结点删除。 2>接口： static inline void hlist_move_list(struct hlist_head *old, struct hlist_head *new) struct hlist_head *old:原先哈希链表的头结点 struct hlist_head *new:新替换的哈希链表的头结点 3>实现： static inline void hlist_move_list(struct hlist_head *old, struct hlist_head *new) { new->first = old->first;   if (new->first)                   new->fist->pprev = &new->first;        old->first = NULL; } Step1: 将new结点的first指向old的第一个结点 Step2: 判断链表头结点后是否有哈希结点。如果为空，则不操作。否则，将表头后的第一个结点的pprev指向新表头结点的first. Step3:将原先哈希链表头结点的first指向空。 四.哈希链表的遍历为了方便核心应用遍历链表，linux链表将遍历操作抽象成几个宏。在分析遍历宏之前,先分析下如何从链表中访问到我们所需要的数据项 1.hlist_entry(ptr,type,member)1>function:通过成员指针获得整个结构体的指针 Linux链表中仅保存了数据项结构中hlist_head成员变量的地址，可以通过hlist_entry宏通过hlist_head成员访问到作为它的所有者的结点数据 2>接口： hlist_entry(ptr,type,member)  ptr:ptr是指向该数据结构中hlist_head成员的指针,即存储该数据结构中链表的地址值。  type:是该数据结构的类型。  member:改数据项类型定义中hlist_head成员的变量名。 3>hlist_entry宏的实现  #define hlist_entry(ptr, type, member) \\          container_of(ptr, type, member) hlist_entry宏调用了container_of宏，关于container_of宏的用法见： 2.遍历操作1>function:实际上就是一个for循环，从头到尾进行遍历。由于hlist不是循环链表，因此，循环终止条件是pos不为空。使用hlist_for_each进行遍历时不能删除pos(必须保证pos->next有效)，否则会造成SIGSEGV错误。而使用hlist_for_each_safe则可以在遍历时进行删除操作。 2>接口： Linux内核为哈希链表遍历提供了两个接口: hlist_for_each(pos,head)  pos: pos是一个辅助指针(即链表类型struct hlist_node),用于链表遍历  head:链表的头指针(即结构体中成员struct hlist_head). hlist_for_each_safe(pos,n,head)  pos: pos是一个辅助指针(即链表类型struct hlist_node),用于链表遍历  n :n是一个临时哈希结点指针（struct hlist_node）,用于临时存储pos的下一个链表结点。  head:链表的头指针(即结构体中成员struct hlist_head). 3>函数实现： (1)#define hlist_for_each(pos, head)          \\            for(pos = (head)->first; pos ; pos = pos->next) pos是辅助指针，pos是从第一个哈希结点开始的，并没有访问哈希头结点，直到pos为空时结束循环。 (2)#define  hlist_for_each_safe(pos,n,head)    \\             for(pos = (head)->first,pos &&({n=pos->next;1;}) ; pos=n) hlist_for_each是通过移动pos指针来达到遍历的目的。但如果遍历的操作中包含删除pos指针所指向的节点，pos指针的移动就会被中断，因为hlist_del(pos)将把pos的next、prev置成LIST_POSITION2和LIST_POSITION1的特殊值。当然，调用者完全可以自己缓存next指针使遍历操作能够连贯起来，但为了编程的一致性，Linxu内核哈希链表要求调用者另外提供一个与pos同类型的指针n，在for循环中暂存pos下一个节点的地址，避免因pos节点被释放而造成的断链。 此循环判断条件为pos && ({n = pos->next;1;}); 这条语句先判断pos是否为空，如果为空则不继续进行判断。如果pos为真则进行判断({n=pos->next;1;})—》该条语句为复合语句表达式，其数值为最后一条语句，即该条语句永远为真，并且将post下一条结点的数值赋值给n。即该循环判断条件只判断pos是否为真，如果为真，则继续朝下进行判断。 （{n-pos->next;1;}）此为GCC 特有的C扩展，如果你不懂的话，可以参考GCC扩展 五.用链表外的结构体地址来进行遍历，而不用哈希链表的地址进行遍历Linux提供了从三种方式进行遍历，一种是从哈希链表第一个哈希结点开始遍历；第二种是从哈希链表中的pos结点的下一个结点开始遍历；第三种是从哈希链表中的当前结点开始进行遍历。 1.从哈希链表第一个哈希结点开始进行遍历1>function: 从哈希链表的第一个哈希结点开始进行遍历。hlist_for_each_entry在进行遍历时不能删除pos(必须保证pos->next有效)，否则会造成SIGSEGV错误。而使用hlist_for_each_entry_safe则可以在遍历时进行删除操作。 2>Linux提供了两个接口来实现从哈希表第一个结点开始进行遍历 hlist_for_each_entry(tpos, pos, head, member)  tpos: 用于遍历的指针,只是它的数据类型是结构体类型而不是strut hlist_head 类型  pos: 用于遍历的指针,只是它的数据类型是strut hlist_head 类型  head:哈希表的头结点  member: 该数据项类型定义中hlist_head成员的变量名 hlist_for_each_entry_safe(tpos, pos, n, head, member)  tpos: 用于遍历的指针,只是它的数据类型是结构体类型而不是strut hlist_head 类型  pos: 用于遍历的指针,只是它的数据类型是strut hlist_head 类型  n: 临时指针用于占时存储pos的下一个指针,它的数据类型也是struct hlist_list类型  head: 哈希表的头结点  member: 该数据项类型定义中hlist_head成员的变量名 3>实现 #define hlist_for_each_entry(tpos,pos,head,member)                   \\         for (pos = (head)->first;                                    \\              pos &&                                                  \\                 ({tpos = hlist_entry(pos, typeof(*tpos),member);1;});\\              pos = pos->next)            #define hlist_for_each_entry_safe(tpos, pos, n, head, member)         \\         for (pos = (head)->first;                                     \\              pos && ({ n = pos->next;1;})  &&                         \\              ({tpos = hlist_entry(pos, typeof(*tpos),member);1;});    \\              pos = n)    2. 从哈希链表中的pos结点的下一个结点开始遍历1>function:从pos结点的下一个结点进行遍历。 2>函数接口： hlist_for_each_entry_continue(tpos ,pos, member)  tpos: 用于遍历的指针,只是它的数据类型是结构体类型而不是strut hlist_head 类型  pos: 用于遍历的指针,只是它的数据类型是strut hlist_head 类型  member: 该数据项类型定义中hlist_head成员的变量名 3>函数实现： #define  hlist_for_each_entry_continue(tpos, pos, member)                \\              for (pos = (pos)->next;                                     \\                    pos &&                                                \\                   ({tpos = hlist_entry(pos,typeof(*tpos),member);1;});    \\                   pos = pos->next) 3.从哈希链表中的pos结点的当前结点开始遍历1>function:从当前某个结点开始进行遍历。hlist_for_entry_continue是从某个结点之后开始进行遍历。 2>函数接口： hlist_for_each_entry_from(tpos, pos, member)  tpos: 用于遍历的指针,只是它的数据类型是结构体类型而不是strut hlist_head 类型  pos: 用于遍历的指针,只是它的数据类型是strut hlist_head 类型  member: 该数据项类型定义中hlist_head成员的变量名 3>实现 #define hlist_for_each_entry_from(tpos, pos, member)                \\          for (; pos &&                                               \\                   ({tpos = hlist_entry(pos,typeof(*tpos),member);1;});\\                 pos = pos->next)","title":"Linux内核哈希表分析与应用"},{"content":"Rookie零基础学java博客目录（不断更新） 一、Eclipse简介Eclipse就像软件开发者的『打铁铺』，它一开始备有火炉、铁钻与铁锤。就像铁匠会用现有的工具打造新的工具，也能用Eclipse打造新工具来开发软件-这些新工具可扩充Eclipse的功能。(Eclipse其中一个卖点就是它的扩充性) 官网：http://www.eclipse.org 二、Eclipse开发工具： 下载地址：http://www.eclipse.org/downloads Eclipse中文教程下载地址：http://download.csdn.net/detail/lujinjian605894472/4942185 1.下载后直接解压就可以了。   然后运行Eclipse，第一次运行的时候系统会提示用户设置工作目录既workspace，这也就是工程文件的安放位置。   2.File-new-project-java-java Project-next 3.Creat a java project ——输入project name——finish 4.鼠标移到src右键new——class——输入类名HelloWorld。   5.完善程序，输出结果按ctrl+F11：   三、.Eclipse的编辑功能非常强大，掌握了Eclipse快捷键功能，能够大大提高开发效率。Eclipse中有如下一些和编辑相关的快捷键。     1. 【ALT+/】     此快捷键为用户编辑的好帮手，能为用户提供内容的辅助，不要为记不全方法和属性名称犯愁，当记不全类、方法和属性的名字时，多体验一下【ALT+/】快捷键带来的好处吧。    2. 【Ctrl+O】     显示类中方法和属性的大纲，能快速定位类的方法和属性，在查找Bug时非常有用。    3. 【Ctrl+/】     快速添加注释，能为光标所在行或所选定行快速添加注释或取消注释，在调试的时候可能总会需要注释一些东西或取消注释，现在好了，不需要每行进行重复的注释。    4. 【Ctrl+D】     删除当前行，这也是笔者的最爱之一，不用为删除一行而按那么多次的删除键。     5. 【Ctrl+M】     窗口最大化和还原，用户在窗口中进行操作时，总会觉得当前窗口小（尤其在编写代码时），现在好了，试试【Ctrl+M】快捷键。     查看和定位快捷键     在程序中，迅速定位代码的位置，快速找到Bug的所在，是非常不容易的事，Eclipse提供了强大的查找功能，可以利用如下的快捷键帮助完成查找定位的工作。     1. 【Ctrl+K】、【Ctrl++Shift+K】     快速向下和向上查找选定的内容，从此不再需要用鼠标单击查找对话框了。     2. 【Ctrl+Shift+T】     查找工作空间（Workspace）构建路径中的可找到Java类文件，不要为找不到类而痛苦，而且可以使用“*”、“？”等通配符。     3. 【Ctrl+Shift+R】     和【Ctrl+Shift+T】对应，查找工作空间（Workspace）中的所有文件（包括Java文件），也可以使用通配符。     4. 【Ctrl+Shift+G】     查找类、方法和属性的引用。这是一个非常实用的快捷键，例如要修改引用某个方法的代码，可以通过【Ctrl+Shift+G】快捷键迅速定位所有引用此方法的位置。     5. 【Ctrl+Shift+O】  快速生成import，当从网上拷贝一段程序后，不知道如何import进所调用的类，试试【Ctrl+Shift+O】快捷键，一定会有惊喜。     6. 【Ctrl+Shift+F】     格式化代码，书写格式规范的代码是每一个程序员的必修之课，当看见某段代码极不顺眼时，选定后按【Ctrl+Shift+F】快捷键可以格式化这段代码，如果不选定代码则默认格式化当前文件（Java文件）。     7. 【ALT+Shift+W】     查找当前文件所在项目中的路径，可以快速定位浏览器视图的位置，如果想查找某个文件所在的包时，此快捷键非常有用（特别在比较大的项目中）。     8. 【Ctrl+L】     定位到当前编辑器的某一行，对非Java文件也有效。    9. 【Alt+←】、【Alt+→】     后退历史记录和前进历史记录，在跟踪代码时非常有用，用户可能查找了几个有关联的地方，但可能记不清楚了，可以通过这两个快捷键定位查找的顺序。     10. 【F3】  快速定位光标位置的某个类、方法和属性。    11. 【F4】     显示类的继承关系，并打开类继承视图。    调试快捷键     Eclipse中有如下一些和运行调试相关的快捷键。    1. 【Ctrl+Shift+B】：在当前行设置断点或取消设置的断点。     2. 【F11】：调试最后一次执行的程序。     3. 【Ctrl+F11】：运行最后一次执行的程序。     4. 【F5】：跟踪到方法中，当程序执行到某方法时，可以按【F5】键跟踪到方法中。     5. 【F6】：单步执行程序。     6. 【F7】：执行完方法，返回到调用此方法的后一条语句。     7. 【F8】：继续执行，到下一个断点或程序结束。     常用编辑器快捷键     通常文本编辑器都提供了一些和编辑相关的快捷键，在Eclipse中也可以通过这些快捷键进行文本编辑。     1. 【Ctrl+C】：复制。     2. 【Ctrl+X】：剪切。     3. 【Ctrl+V】：粘贴。     4. 【Ctrl+S】：保存文件。     5. 【Ctrl+Z】：撤销。     6. 【Ctrl+Y】：重复。     7. 【Ctrl+F】：查找。     其他快捷键     Eclipse中还有很多快捷键，无法一一列举，用户可以通过帮助文档找到它们的使用方式，另外还有几个常用的快捷键如下。     1. 【Ctrl+F6】：切换到下一个编辑器。     2. 【Ctrl+Shift+F6】：切换到上一个编辑器。     3. 【Ctrl+F7】：切换到下一个视图。     4. 【Ctrl+Shift+F7】：切换到上一个视图。     5. 【Ctrl+F8】：切换到下一个透视图。     6. 【Ctrl+Shift+F8】：切换到上一个透视图。     Eclipse中快捷键比较多，可以通过帮助文档找到所有快捷键的使用，但要掌握所有快捷键的使用是不可能的，也没有必要，如果花点时间熟悉本节列举的快捷键，必将会事半功倍。  ","title":"Rookie零基础学java（三）eclipse安装与配置（快捷键）及重写HelloWorld（有图）"},{"content":"-- 开启Ad Hoc Distributed Queries组件 --exec sp_configure 'show advanced options',1 --reconfigure --exec sp_configure 'Ad Hoc Distributed Queries',1 --reconfigure -- 关闭Ad Hoc Distributed Queries： --exec sp_configure 'Ad Hoc Distributed Queries',0 --reconfigure --exec sp_configure 'show advanced options',0 --reconfigure  --select * from OpenRowSet('Microsoft.Jet.OLEDB.4.0', 'Excel 8.0;HDR=Yes;IMEX=1;Database=c:\\dl.xls', 'select * from [Sheet1$] where f1 is not null')  --select * from OpenRowSet('Microsoft.ACE.OLEDB.4.0', 'Excel 8.0;HDR=Yes;IMEX=1;Database=c:\\dl.xls', 'select * from [Sheet1$]')    SELECT * INTO Temp_Upload1 -- 开启Ad Hoc Distributed Queries组件--exec sp_configure 'show advanced options',1--reconfigure--exec sp_configure 'Ad Hoc Distributed Queries',1--reconfigure-- 关闭Ad Hoc Distributed Queries：--exec sp_configure 'Ad Hoc Distributed Queries',0--reconfigure--exec sp_configure 'show advanced options',0--reconfigure --select * from OpenRowSet('Microsoft.Jet.OLEDB.4.0', 'Excel 8.0;HDR=Yes;IMEX=1;Database=c:\\dl.xls', 'select * from [Sheet1$] where f1 is not null') --select * from OpenRowSet('Microsoft.ACE.OLEDB.4.0', 'Excel 8.0;HDR=Yes;IMEX=1;Database=c:\\dl.xls', 'select * from [Sheet1$]')   SELECT * INTO Temp_Upload1FROM   OPENROWSET('MICROSOFT.JET.OLEDB.4.0','Excel 5.0;HDR=YES;DATABASE=c:\\dl.xls',sheet1$)--SELECT * INTO Temp_Upload1--FROM   OPENROWSET('MICROSOFT.JET.OLEDB.4.0','Excel 5.0;HDR=YES;DATABASE=c:\\dl.xls',sheet1$)--delete from [Card].[dbo].[Temp_Upload1] where f1 is null--delete from [Card].[dbo].[Temp_Upload1] where f1=''--delete from [Card].[dbo].[Temp_Upload1] where f11 is null--SELECT *  FROM [Card].[dbo].[Temp_Upload1] FROM   OPENROWSET('MICROSOFT.JET.OLEDB.4.0','Excel 5.0;HDR=YES;DATABASE=c:\\dl.xls',sheet1$) --SELECT * INTO Temp_Upload1 --FROM   OPENROWSET('MICROSOFT.JET.OLEDB.4.0','Excel 5.0;HDR=YES;DATABASE=c:\\dl.xls',sheet1$) --delete from [Card].[dbo].[Temp_Upload1] where f1 is null --delete from [Card].[dbo].[Temp_Upload1] where f1='' --delete from [Card].[dbo].[Temp_Upload1] where f11 is null --SELECT *  FROM [Card].[dbo].[Temp_Upload1]","title":"Excel文件导入SqlServer最简单方法！（超简单、超实用）"},{"content":" 实验一 线性表及其应用 实验内容：算术表达式求值 表达式求值是实现程序设计语言的基本问题之一，也是栈的应用的一个典型例子。设计一个程序，演示用算符优先法对算术表达式求值的过程。 实验要求： (1)从键盘输入任意一个语法正确的（中缀）表达式，显示并保存该表达式。 (2)利用栈结构，把上述（中缀）表达式转换成后缀表达式，并显示栈的状态变化过程和所得到的后缀表达式。 (3)利用栈结构，对上述后缀表达式进行求值，并显示栈的状态变化过程和最终结果。 实验备注： 一、上传内容： 1. 实验报告 2. 实验程序源代码；打包为rar文件，提交到此处。 二、实验报告格式：见课件下载或下方附件“实验报告样式.doc”  /*-100+((-2.5+3.1*2)/5.1-3.2)/2.8*/ look!本程序只支持：多位数，小数，负数，括号 （1）中缀表达式转后缀表达式的算法： 设立一个栈，存放运算符，首先栈为空，程序从左到右扫描中缀表达     a.若遇到操作数，存放到后缀表达式的数组中，并输出一个空格作为两个操作数的分隔符（这里注意多位数处理，多 位数处理数字与数字之间不要空格）；                  b.若遇到运算符，则必须与栈顶比较，运算符级别比栈顶级别高则进否则退出栈顶元素并存放在后缀表达式中，然后输  出一个空格作分隔符；     c.若遇到左括号，进栈；     d.若遇到右括号，则一直退栈输出，直到退到左括号止。当栈变成空时，输出的结果即为后缀表达式。 （2）计算后缀表达式算法: 设置一个栈，开始时，栈为空，然后从左到右扫描后缀表达式： a.若遇操作数，字符型转化为double类型，进栈； b.若遇运算符，则从栈中退出两个元素，先退出的放到运算符的右边，后退出的放到运算符左边，运算后的结果再进        栈，直到后缀表达式扫描完毕。    c.此时，栈中仅有一个元素，即为运算的结果。 #include <iostream>#include<cstdio>#include<cstring>#include<cstdlib>#define  maxlen 100using namespace std;struct STACK_CHAR{    int top_char;    char element[maxlen];} op_s;struct STACK_NUM{    int top_num;    double element[maxlen];} num_s;char mid[100],end[100];//存放中缀和后缀void makenull_char(STACK_CHAR &S){    S.top_char=maxlen;}void makenull_num(STACK_NUM &S){    S.top_num=maxlen;}bool empty_char(STACK_CHAR S){    if (S.top_char>maxlen-1)   return true;    else return false ;}bool empty_num(STACK_NUM S){    if (S.top_num>maxlen-1)   return true;    else return false ;}char top_char(STACK_CHAR S){    if (empty_char(S)) return NULL;    else return(S.element[S.top_char]);}double top_num(STACK_NUM S){    if (empty_num(S)) return NULL;    else return(S.element[S.top_num]);}void pop_char(STACK_CHAR &S){    if (empty_char(S))  cout << \"STACK_CHAR is empty\" << endl;    else    {        S.top_char =S.top_char+1;        cout << \"符号栈中元素：\" ;        for(int i=maxlen-1; i>=S.top_char; i--)  cout << S.element[i] << \" \";        cout << endl;    }}void pop_num(STACK_NUM &S){    if (empty_num(S))  cout << \"STACK_NUM is empty\" << endl;    else    {        S.top_num =S.top_num+1;        cout << \"数字栈中元素：\";        for(int i=maxlen-1; i>=S.top_num; i--)   cout << S.element[i] << \" \";        cout << endl;    }}void push(char x,STACK_CHAR &S){    if (S.top_char==0)   cout << \" STACK_CHAR  is full \" << endl;    else    {        S.top_char=S.top_char-1;        S.element[S.top_char]=x;        cout << \"符号栈中元素：\" ;        for(int i=maxlen-1; i>=S.top_char; i--)  cout << S.element[i] <<  \" \";        cout << endl;    }}void push_num(double x,STACK_NUM &S){    if (S.top_num==0)   cout << \" STACK_NUM is full \" << endl;    else    {        S.top_num=S.top_num-1;        S.element[S.top_num]=x;        cout << \"数字栈中元素：\";        for(int i=maxlen-1; i>=S.top_num; i--)    cout << S.element[i] << \" \";        cout << endl;    }}/*栈的一系列基本操作函数*/int pre_judge(char x);//优先级判断void mid_to_end(char a[],int n);//转化的函数double calculate_end(char end[],int n);//计算后缀表达式函数int main(){    int j;    makenull_char(op_s);    cout << \"请输入前缀表达式:\";    gets(mid);    cout << \"前缀表达式为:\";    puts(mid);    mid_to_end(mid,100);    cout << endl << \"后缀表达式为：\" ;    for (j=0; end[j]!='\\0'; j++)    {        if(end[j]=='#') cout << '-';//扫描遇到井号那么显示负号        else  cout << end[j];    //显示后缀表达式    }    cout << endl << endl;    cout <<\"表达式的计算结果为：\"<< calculate_end(end,100) << endl;    return 0;}int pre_judge(char x)//符号优先级判断{    int flag=0;    switch(x)    {    case '(':        flag=1;        break;    case ')':        flag=1;        break;    case '+':        flag=2;        break;    case '-':        flag=2;        break;    case '*':        flag=3;        break;    case '/':        flag=3;        break;    default :        break;    }    return flag;}void mid_to_end(char a[],int n)//中缀转后缀函数{    int end_count=0,i,m=0;    if(a[0]=='-')//中缀表达式中是第一个为负号    {        end[end_count]='#';//用＃号标记负号        end_count++;        m=1;//如果为负号，进入循环扫描的时候就从第二个字符开始    }    for (i=m; a[i]!='\\0'; i++)    {        if (a[i]<='9'&&a[i]>='0'&&(a[i+1]>'9'||a[i+1]<'0')&&a[i+1]!='.')        {            end[end_count]=a[i];            end_count++;            end[end_count]=' ';            end_count++;        }//当前字符为0~9而且下一个为运算符（即为数字的最后一位，那么设空格与下一个数字分开）        else if((a[i]<='9'&&a[i]>='0'&&((a[i+1]<='9'&&a[i+1]>='0')||a[i+1]=='.'))||a[i]=='.')        {            end[end_count]=a[i];            end_count++;        }//是数字而且不是数字的最后一位，后最中不设空格        else if(a[i-1]=='('&&a[i]=='-')        {            end[end_count]='#';            end_count++;        }//中缀表达式扫描到的数字的前一个是左括号则当负号处理        else if((a[i]=='+'||a[i]=='-'||a[i]=='*'||a[i]=='/')&&a[i-1]!='(')        {            while(!empty_char(op_s))            {                if(pre_judge(top_char(op_s))>=pre_judge(a[i]))                {                    end[end_count]=top_char(op_s);                    pop_char(op_s);                    end_count++;                    end[end_count]=' ';                    end_count ++;                }                else break;            }            push(a[i],op_s);        }/*若遇到运算符，则必须与栈顶比较，运算符级别比栈顶级别高则进栈，        否则退出栈顶元素并存放在后缀表达式中，然后输出一个空格作分隔符；*/        else if (a[i]=='(') push(a[i],op_s);//若遇到左括号，进栈；        else  if(a[i]==')')        {            while(1)            {                if(top_char(op_s)=='(')                {                    pop_char(op_s);                    break;                }                else                {                    end[end_count]=top_char(op_s);                    pop_char(op_s);                    end_count++;                    end[end_count]=' ';//注意设置空格                    end_count++;                }            }        }//若遇到右括号，则一直退栈输出，直到退到左括号止。        else  continue;    }    while(!empty_char(op_s))//将栈中剩下的元素弹出    {        end[end_count]=top_char(op_s);        pop_char(op_s);        end_count++;        end[end_count]=' ';        end_count++;    }    end[end_count]='\\0';//设置字符串结束标识}double calculate_end(char a[],int n)        //计算后缀表达式的值{    double top,sec,ans=0,number;    int i=0,j=0,k,x;    bool flag=true;//flag用于标记是否为负数，开始时设定为不是负数    char num[100];    STACK_NUM num_s;    makenull_num(num_s);    for(i=0; end[i]!='\\0'; i++)    {        if(end[i]=='#')        {            flag=false;            j=i+1;        }        if(end[i]==' '&&end[i-1]>='0'&&end[i-1]<='9')        {            for(k=j,x=0; k<=i; k++,x++) num[x]=end[k];            //在截取完整的数存放到num中，但是这时的数还是char的，下面用atof函数进行转化            number=atof(num);//将char型的数转化为double            if(flag==false)            {                number=(-1)*number;                flag=true;//处理完为负数之后那么把标识又设为不是负数，下一次循环使用            }            push_num(number,num_s);            memset(num,' ',sizeof(num));            number=0;        }//遇到的是操作数，进栈；        else if(end[i-1]==' '&&end[i]<='9'&&end[i]>='0')  j=i;        //扫描到数字的第一个啦那么把j设置成i一遍循环时候num中截取字符串        else if(a[i]=='+'||a[i]=='-'||a[i]=='*'||a[i]=='/')        {            top=top_num(num_s);            pop_num(num_s);            sec=top_num(num_s);            switch (a[i])  /*对不同运算符进行分别处理*/            {            case'+':                ans=sec+top;                break;            case'-':                ans=sec-top;                break;            case'*':                ans=sec*top;                break;            case'/':                ans=sec/top;                break;            }            pop_num(num_s);            push_num(ans,num_s);        }           /*若遇运算符，则从栈中退出两个元素，            先退出的放到运算符的右边，后退出的放到运算符左边，            运算后的结果再进栈*/        else continue;    }    return  top_num(num_s);//栈中只有一个元素啦，返回为结果}","title":"实验一 线性表及其应用"},{"content":"Rookie零基础学java博客目录（不断更新） 一、安装jdk 下载地址：http://www.liangchan.net/liangchan/1518.html#softdown   二、按照JDK的提示来安装，安装完之后设置环境变量  JDK环境变量配置的步骤如下：  1.我的电脑-->属性-->高级-->环境变量.  2.配置用户变量:  a.新建 JAVA_HOME  C:\\Program Files\\Java\\j2sdk1.5.0 （JDK的安装路径）  b.新建 PATH  %JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin  c.新建 CLASSPATH  .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar  3.测试环境变量配置是否成功：  开始-->运行--〉CMD  键盘敲入： JAVAC JAVA  出现相应的命令，而不是出错信息，即表示配置成功！      三、要善于使用JDK的帮助文件 JDK的帮助文件有在线版本和离线版本两种，可以从Java的官方网站http://java.sun. com上下载到最新的JDK帮助文件，帮助文件分为两种格式，即HTML格式和CHM格式。JDK的帮助文件使用很简单，只需要打开目录下的index.html即可。  ","title":"Rookie零基础学java（一）jdk安装与配置（有图）"},{"content":"java 7 新的NIO API新增了FileSystem和FileStore相关API，最主要的是Path.java类，主要是我们常见的文件的一些相关操作，这个Path是NIO IO操作的基础，我们可以定义一个文件路径，对路径的相关操作等， 我们先看下java7 NIO 2新增的API： 我们看下这个API使用的示例： import java.io.File;import java.io.IOException;import java.nio.file.Files;import java.nio.file.LinkOption;import java.nio.file.NoSuchFileException;import java.nio.file.Path;import java.nio.file.Paths;//NIO 2 file APi filesystem filestorepublic class NIO2File {\tpublic static void main(String[] args) {\t\ttry {\t\t\t// FileSystems.getDefault().getPath(first, more)\t\t\tPath path = Paths.get(System.getProperty(\"user.home\"), \"www\",\t\t\t\t\t\"pyweb.settings\");\t\t\tPath real_path = path.toRealPath(LinkOption.NOFOLLOW_LINKS);\t\t\tSystem.out.println(\"Path to real path: \" + real_path);\t\t\tSystem.out.println(\"Number of name elements in path: \"\t\t\t\t\t+ path.getNameCount());\t\t\tfor (int i = 0; i < path.getNameCount(); i++) {\t\t\t\tSystem.out.println(\"Name element \" + i + \" is: \"\t\t\t\t\t\t+ path.getName(i));\t\t\t}\t\t\tSystem.out.println(\"Subpath (0,3): \" + path.subpath(0, 3));\t\t\tFile path_to_file = path.toFile();\t\t\tPath file_to_path = path_to_file.toPath();\t\t\tSystem.out.println(\"Path to file name: \" + path_to_file.getName());\t\t\tSystem.out.println(\"File to path: \" + file_to_path.toString());\t\t\tPath base = Paths.get(System.getProperty(\"user.home\"), \"www\",\t\t\t\t\t\"pyweb.settings\");\t\t\t// resolve AEGON.txt file\t\t\tPath path1 = base.resolve(\"django.wsgi\");\t\t\tSystem.out.println(path1.toString());\t\t\tPath path2 = base.resolveSibling(\".bashrc\");\t\t\tSystem.out.println(path2.toString());\t\t\tPath path01_to_path02 = path1.relativize(path2);\t\t\tSystem.out.println(path01_to_path02);\t\t\ttry {\t\t\t\tboolean check = Files.isSameFile(path1.getParent(),\t\t\t\t\t\tpath2.getParent());\t\t\t\tif (check) {\t\t\t\t\tSystem.out.println(\"The paths locate the same file!\"); // true\t\t\t\t} else {\t\t\t\t\tSystem.out\t\t\t\t\t\t\t.println(\"The paths does not locate the same file!\");\t\t\t\t}\t\t\t} catch (IOException e) {\t\t\t\tSystem.out.println(e.getMessage());\t\t\t}\t\t\tboolean sw = path1.startsWith(\"/rafaelnadal/tournaments\");\t\t\tboolean ew = path1.endsWith(\"django.wsgi\");\t\t\tSystem.out.println(sw);\t\t\tSystem.out.println(ew);\t\t\tfor (Path name : path1) {\t\t\t\tSystem.out.println(name);\t\t\t}\t\t} catch (NoSuchFileException e) {\t\t\tSystem.err.println(e);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t}} 输出： Path to real path: /home/weijianzhongwj/www/pyweb.settingsNumber of name elements in path: 4Name element 0 is: homeName element 1 is: weijianzhongwjName element 2 is: wwwName element 3 is: pyweb.settingsSubpath (0,3): home/weijianzhongwj/wwwPath to file name: pyweb.settingsFile to path: /home/weijianzhongwj/www/pyweb.settings/home/weijianzhongwj/www/pyweb.settings/django.wsgi/home/weijianzhongwj/www/.bashrc../../.bashrcThe paths does not locate the same file!falsetruehomeweijianzhongwjwwwpyweb.settingsdjango.wsgi API很类似linux上的文件操作命令，新增的unix fifilesystem等。","title":"java 7 NIO2（1） Path类相关新API"},{"content":"转载请注明出处，谢谢http://blog.csdn.net/ACM_cxlove?viewmode=contents    by---cxlove 总体来说，这场不是很好做啊，对于div2 A：显然添加第一位之后如果整除的话，那么之后全添加0的就行了。反过来，如果第一位不满足的话，那么毕竟不行。    那么考虑 (b-a*10%b)是否小于10就行了 B：枚举以每一个字符开始的长度 为10的串，然后进行分解，判断，map搞一下 C：这个题嘛，要考虑球最少的那个盒子。起点只可能是在球最少的盒子处，不是吗？ 然后我们就从终态往前堆到最少的盒子处，有多个也没事，随意取一个 那么中间部分就要全部减1，然后根据最少盒子里的数量就知道中间运转了多少轮，倒推就OK了 D：贪心吧，直接推。将点分为两堆0，1。先考虑权值小的点 从两堆中各取一个，边权便是两者权值的最小值。然后判断是否还剩。 但是有一种情况要注意，如果两个点的边权一样，这时候不能把这两个点都抛弃。 应该选择一个抛弃，不然就不连通了，也就是之前的点和之后的点不连通，保证有一个点留下和接下来的点继续连接 E：枚举所有情况，然后线段树判断 http://blog.csdn.net/acm_cxlove/article/details/8450651","title":"Codeforces Round #158 (Div. 2)"},{"content":"直接插入排序(straight insertion sort)的作法是： 　　每次从无序表中取出第一个元素，把它插入到有序表的合适位置，使有序表仍然有序。 直接插入排序（Straight Insertion Sorting）的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。 把a[i]插入到a[0]，a[1]，...,a[i-1]之中的具体实施过程为:先把a[i]赋值给变量t,然后将t依次与a[i-1],a[i-2],...进行比较,将比t大的元素右移一个位置,直到发现某个j(0<=j<=i-1),使得a[j]<=t或j为(-1),把t赋值给a[j+1]. 代码示例： //直接插入排序#include <iostream>using namespace std;void insertSort(int *a,int left,int right){\tint tmp;\tint i,j;\tfor(i = left+1 ; i<=right;i++){//外层循环是从第二个元素开始的\t\tif(a[i]<a[i-1]){\t\t\ttmp = a[i];\t\t\tj = i-1;\t\t\tdo{\t\t\t\ta[j+1]= a[j--];\t\t\t}while( j>= left && tmp < a[j]);\t\t\ta[j+1] = tmp;\t\t}\t}}void main(){\tint a[]={5,4,3,2,6,3,5,34};\tinsertSort(a,0,7);\tfor(int i=0;i<8;i++)\t\tcout<<a[i]<<\" \";\tcout<<endl;} 直接插入排序的效率分析 （1）时间复杂度 从时间分析，首先外层循环要进行n-1次插入，每次插入最少比较一次（正序），移动两次；最多比较i次，移动i＋2次（逆序）（i=1，2，…，n-1）。若分别用Cmin ，Cmax 和Cave表示元素的总比较次数的最小值、最大值和平均值，用Mmin ，Mmax 和Mave表示元素的总移动次数的最小值、最大值和平均值，则上述直接插入算法对应的这些量为： Cmin=n-1 Mmin=2（n-1） Cmax=1+2+…+n-1=（n2-n）/2 Mmax=3+4+…+n+1=（n2+3n-4）/2 Cave=（n2+n-2）/4 Mmax=（n2+7n-8）/4 因此，直接插入排序的时间复杂度为O（n2）。 由上面对时间复杂度的分析可知,当待排序元素已从小到大排好序(正序)或接近排好序时,所用的比较次数和移动次数较少;当待排序元素已从大到小排好序(逆序)或接近排好序时,所用的比较次数和移动次数较多,所以插入排序更适合于原始数据基本有序(正序)的情况.  插入法虽然在最坏情况下复杂性为O(n2)，但是对于小规模输入来说，插入排序法是一个快速的排序法。许多复杂的排序法，在规模较小的情况下，都使用插入排序法来进行排序，比如快速排序。 （2）空间复杂度 首先从空间来看，它只需要一个元素的辅助空间，用于元素的位置交换O(1) （3）稳定性: 插入排序是稳定的,因为具有同一值的元素必然插在具有同一值得前一个元素的后面,即相对次序不变. （4）结构的复杂性及适用情况 插入排序是一种简单的排序方法,他不仅适用于顺序存储结构(数组),而且适用于链接存储结构,不过在链接存储结构上进行直接插入排序时,不用移动元素的位置,而是修改相应的指针。","title":"[置顶] 直接插入排序"},{"content":" 实验二 树形结构及其应用 实验内容：树型结构的建立与遍历 树型结构的遍历是树型结构算法的基础，本实验要求编写程序演示二叉树的存储结构的建立和遍历过程。 实验要求： (1) 至少用两种方法，编写建立二叉树的二叉链表存储结构的程序，并用广义表的形式显示并保存二叉树； (2) 采用二叉树的二叉链表存储结构，编写程序实现二叉树的先序、中序和后序遍历的递归和非递归算法以及层序遍历算法，并显示二叉树和相应的遍历序列； (3) 在二叉树的二叉链表存储结构基础上，编写程序实现二叉树的先序、中序和后序线索链表存储结构建立的算法，并用广义表的形式显示和保存二叉树的线索链表； (4) 在二叉树的线索链表存储结构上，编写程序分别实现求一个结点的先序（中序、后序）的后继结点的算法； (5) 在 (4) 基础上，编写程序实现对线索二叉树进行先序、中序和后序遍历的非递归算法，并显示线索二叉树和相应的遍历序列。 实验备注： 一、上传内容： 1. 实验报告 2. 实验程序源代码；打包为rar文件，提交到此处。 二、实验报告格式：见课件下载“实验报告样式.doc” #include <iostream>#include<cstdlib>#include<cstdio>#include<cstring>#define  maxlen 100using namespace std;struct BTtree{    char data;    BTtree  *lchild;    BTtree  *rchild;};char genelist[100];//保存广义表int i;BTtree* pre_creat_bt()//先序建立二叉树{    char ch;    BTtree  *T;    cin >> ch;    if(ch=='#')  T=NULL;    else    {        T=(BTtree*)malloc(sizeof(BTtree));        T->data=ch;        printf(\"\\n请输入%c结点的左子结点(如果没有那么输入#代表空):\",T->data );        T->lchild=pre_creat_bt();        printf(\"\\n请输入%c结点的右子结点(如果没有那么输入#代表空):\",T->data );        T->rchild=pre_creat_bt();    }    return T;}BTtree * level_create()//层次建立二叉链表{    BTtree* s[maxlen];    int j;    char ch;    BTtree *T,*p;    while(cin >> i >> ch&&(i!=0||ch!='#'))    {        p=(BTtree*)malloc(sizeof(BTtree));        p->data=ch;        p->lchild=NULL;        p->rchild=NULL;        s[i]=p;        if(i==1)T=p;        else        {            j=i/2;            if(i%2==0)s[j]->lchild=p;//节点为偶数，i为j的左儿子            else    s[j]->rchild=p;//节点为偶数，i为j的左儿子        }    }    return T;}void pre_order(BTtree *T)//递归先根遍历二叉树{    if(T!=NULL)    {        cout << T->data;        pre_order(T->lchild);        pre_order(T->rchild);    }}void in_order(BTtree *T)//递归中序遍历二叉树{    if(T!=NULL)    {        in_order(T->lchild);        cout << T->data;        in_order(T->rchild);    }}void post_order(BTtree *T)//递归后根遍历二叉树{    if(T!=NULL)    {        post_order(T->lchild);        post_order(T->rchild);        cout << T->data;    }}void npre_order(BTtree *T)//非递归先根遍历二叉树{    BTtree* STACK[maxlen];    int top=maxlen;    while(T!=NULL||top!=maxlen)    {        while(T!=NULL)        {            cout << T->data;            STACK[--top]=T;            T=T->lchild;        }        if(top!=maxlen)        {            T=STACK[top++];            T=T->rchild;        }    }}/*当树非空那么循环，访问，左走若S不空，取栈顶右走*/void nin_order(BTtree *T)//非递归中序遍历二叉树{    BTtree* STACK[maxlen];    int top=maxlen;    while(T!=NULL||top!=maxlen)    {        if(T!=NULL)        {            STACK[--top]=T;            T=T->lchild;        }        else        {            T=STACK[top++];            cout << T->data ;            T=T->rchild;        }    }}/*  树不空，左走一步不访问  若栈不空，取出栈顶访问 再访问父亲，再右走*/void npost_order(BTtree *T)//非递归后根遍历二叉树{    struct STACK    {        BTtree*  tree;        int  flag;    } S[maxlen];    int top=maxlen;    BTtree * temp;    temp=T;    while(temp!=NULL||top!=maxlen)    {        if(temp!=NULL)        {            S[--top].tree=temp;            S[top].flag=1;            temp=temp->lchild;        }        else        {            if(S[top].flag==2)            {                T=S[top++].tree;                cout << T->data;            }            else            {                S[top].flag=2;                temp=S[top].tree->rchild;            }        }    }}void lev_order(BTtree* T){    BTtree* Q[maxlen],*q=NULL;    int front=0,rear=0;//建立一个空的队列    if(T==NULL)return;    Q[rear++]=T;//将根指针入队    while(front!=rear)    {        q=Q[front];        cout << q->data;        if(q->lchild!=NULL)        {            Q[rear]=q->lchild;//左儿子不是空，将它入队列            rear++;        }        if(q->rchild!=NULL)        {            Q[rear]=q->rchild;//右边儿子不是空，将它入队列            rear++;        }        front++;//完成上面之后将队首元素就可以出队进行下一次循环操作    }}void  order(BTtree * T)//遍历二叉链表{    printf(\"********递归遍历二叉链表***********\\n\");    printf(\"\\n先序递归遍历二叉链表:\");    pre_order(T);    printf(\"\\n中序递归遍历二叉链表:\");    in_order(T);    printf(\"\\n后序递归遍历二叉链表:\");    post_order(T);    printf(\"\\n********非递归遍历二叉链表***********\\n\");    printf(\"\\n先序非递归遍历二叉链表:\");    npre_order(T);    printf(\"\\n中序非递归遍历二叉链表:\");    nin_order(T);    printf(\"\\n后序非递归遍历二叉链表:\");    npost_order(T);    printf(\"\\n**********层次遍历二叉链表***********:\\n\");    lev_order(T);}void print_tree(BTtree *T) /*按广义表方式打印*/{    if(T!=NULL)    {        if(T->lchild==NULL&&T->rchild==NULL)        {            genelist[i]=T->data;            i++;        }        else        {            genelist[i]=T->data;            i++;            genelist[i]='(';            i++;            print_tree(T->lchild);            genelist[i]=',';            i++;            print_tree(T->rchild);            genelist[i]=')';            i++;        }    }}void print(BTtree *T){    BTtree *t=T;    i=0;    genelist[i]='(';    i++;    print_tree(t);    genelist[i]=')';    i++;    genelist[i]='\\0';}int main(){    BTtree *pre_t=NULL,*lev_t=NULL;    int N;    printf(\"********输入1先序建立二叉链表***********\\n********输入2层次建立二叉链表***********\\n********输入0退出***********\\n\");    while(cin >> N)    {        switch(N)        {        case 1:            printf(\"********先序建立二叉链表***********\\n输入根节点(如果没有那么输入#代表空):\");            pre_t=pre_creat_bt();            order(pre_t);//遍历二叉链表            printf(\"\\n********二叉树用广义表表示为********:\\n\");            print(pre_t);            for(i=0; genelist[i]!='\\0'; i++) cout << genelist[i];            printf(\"\\n\");            break;        case 2:            printf(\"********层次建立二叉链表***********\\n输入节点次序和元素:\");            lev_t=level_create();            order(lev_t);//遍历二叉链表*/            printf(\"\\n********二叉树用广义表表示为********:\\n\");            print(lev_t);            for(i=0; genelist[i]!='\\0'; i++)cout << genelist[i];            printf(\"\\n\");            break;        case 0:            break ;        default :            break;        }        memset(genelist,' ',sizeof(genelist));        printf(\"********输入1先序建立二叉链表***********\\n********输入2层次建立二叉链表***********\\n********输入0退出***********\\n\");    }    return 0;}/*1A 2B 3C 4D 5E 6F 7G 8H 9I 10J 0#*/","title":"实验二 树形结构及其应用"},{"content":"// //  main.cpp //  AUTO_PRO // //  Created by yanzhengqing on 12-12-11. //  Copyright (c) 2012年 yanzhengqing. All rights reserved. // #include <iostream> using namespace std; /***  *strlen - return the length of a null-terminated string  *  *Purpose:  *       Finds the length in bytes of the given string, not including  *       the final null character.  *  *Entry:  *       const char * str - string whose length is to be computed  *  *Exit:  *       length of the string \"str\", exclusive of the final null byte  *  *Exceptions:  *  *******************************************************************************/ ///////////////////////////////////////////////////////////////////////////////// /*说明：   1. __cdecl 是C Declaration的缩写（declaration，声明），表示C语言默认的函数调用方法：所有参数从右到左依次入栈，这些参数由调用者清除，称为手动清栈。被调用函数不会要求调用者传递多少参数，调用者传递过多或者过少的参数，甚至完全不同的参数都不会产生编译阶段的错误。   2. 返回一个字符串的长度   3.  按照ANSI(American National Standards Institute)标准，不能对void指针进行算法操作，即不能对void指针进行如p++的操作,所以需要转换为具体的类型指针来操作,例如char *。（引用网友的结论）   4.  size_t 类型定义在cstddef头文件中，该文件是C标准库的头文件stddef.h的C++版。它是一个与机器相关的unsigned类型，其大小足以保证存储内存中对象的大小。 */ size_t __cdecl strlen (                       const char * str                        ) {    const char *eos = str;    while( *eos++ );         return( (int)(eos - str -1) ); } int main() {  size_t k = 0;     constchar brc[50] =\"blog.csdn.net/barry_yan\";     k =strlen(brc);    cout<<k<<endl;    return 0; }","title":"strlen源码"},{"content":"// //  main.cpp //  AUTO_PRO // //  Created by yanzhengqing on 12-12-11. //  Copyright (c) 2012年 yanzhengqing. All rights reserved. // #include <iostream> using namespace std; /***  *char *strncpy(dest, source, count) - copy at most n characters  *  *Purpose:  *       Copies count characters from the source string to the  *       destination.  If count is less than the length of source,  *       NO NULL CHARACTER is put onto the end of the copied string.  *       If count is greater than the length of sources, dest is padded  *       with null characters to length count.  *  *  *Entry:  *       char *dest - pointer to destination  *       char *source - source string for copy  *       unsigned count - max number of characters to copy  *  *Exit:  *       returns dest  *  *Exceptions:  *  *******************************************************************************/ ///////////////////////////////////////////////////////////////////////////////// /*说明：   1. __cdecl 是C Declaration的缩写（declaration，声明），表示C语言默认的函数调用方法：所有参数从右到左依次入栈，这些参数由调用者清除，称为手动清栈。被调用函数不会要求调用者传递多少参数，调用者传递过多或者过少的参数，甚至完全不同的参数都不会产生编译阶段的错误。   2. 将一个字符串从一个位置复制到另一个位置，最多复制n个字节   3.  按照ANSI(American National Standards Institute)标准，不能对void指针进行算法操作，即不能对void指针进行如p++的操作,所以需要转换为具体的类型指针来操作,例如char *。（引用网友的结论）   4.  size_t 类型定义在cstddef头文件中，该文件是C标准库的头文件stddef.h的C++版。它是一个与机器相关的unsigned类型，其大小足以保证存储内存中对象的大小。 */ char * __cdecl strncpy (                        char * dest,                        constchar * source,                        size_t count                         ) {    char *start = dest;         while (count && (*dest++ = *source++))   /* copy string */         count--;         if (count)                             /* pad out with zeroes */        while (--count)             *dest++ ='\\0';         return(start); } int main() {    char src[50] =\"\";     constchar brc[50] =\"blog.csdn.net/barry_yan\";    cout<<src<<endl;    cout<<brc<<endl;    strncpy(src,brc,strlen(brc));    cout<<src<<endl;    return0; }","title":"strncpy源码"},{"content":"// //  main.cpp //  AUTO_PRO // //  Created by yanzhengqing on 12-12-11. //  Copyright (c) 2012年 yanzhengqing. All rights reserved. // #include <iostream> using namespace std; /***  *int strncmp(first, last, count) - compare first count chars of strings  *  *Purpose:  *       Compares two strings for lexical order.  The comparison stops  *       after: (1) a difference between the strings is found, (2) the end  *       of the strings is reached, or (3) count characters have been  *       compared.  *  *Entry:  *       char *first, *last - strings to compare  *       unsigned count - maximum number of characters to compare  *  *Exit:  *       returns <0 if first < last  *       returns  0 if first == last  *       returns >0 if first > last  *  *Exceptions:  *  *******************************************************************************/ ///////////////////////////////////////////////////////////////////////////////// /*说明：   1. __cdecl 是C Declaration的缩写（declaration，声明），表示C语言默认的函数调用方法：所有参数从右到左依次入栈，这些参数由调用者清除，称为手动清栈。被调用函数不会要求调用者传递多少参数，调用者传递过多或者过少的参数，甚至完全不同的参数都不会产生编译阶段的错误。   2. 基于字典顺序比较两个字符串，最多比较n个字节   3.  按照ANSI(American National Standards Institute)标准，不能对void指针进行算法操作，即不能对void指针进行如p++的操作,所以需要转换为具体的类型指针来操作,例如char *。（引用网友的结论）   4.  size_t 类型定义在cstddef头文件中，该文件是C标准库的头文件stddef.h的C++版。它是一个与机器相关的unsigned类型，其大小足以保证存储内存中对象的大小。 */ int __cdecl strncmp (                     const char * first,                     const char * last,                     size_t count                      ) {    if (!count)        return(0);         while (--count && *first && *first == *last)     {         first++;         last++;     }         return( *(unsignedchar *)first - *(unsignedchar *)last ); } int main() {    int p = 0;    const char src[50] =\"blog.csdn.con\";     constchar brc[50] =\"blog.csdn.net/barry_yan\";    cout<<src<<endl;    cout<<brc<<endl;     p =strncmp(src,brc,strlen(src)+1);    cout<<p<<endl;    return 0; }","title":"strncmp源码"},{"content":"// //  main.cpp //  AUTO_PRO // //  Created by yanzhengqing on 12-12-11. //  Copyright (c) 2012年 yanzhengqing. All rights reserved. // #include <iostream> using namespace std; /***  *char *strrchr(string, ch) - find last occurrence of ch in string  *  *Purpose:  *       Finds the last occurrence of ch in string.  The terminating  *       null character is used as part of the search.  *  *Entry:  *       char *string - string to search in  *       char ch - character to search for  *  *Exit:  *       returns a pointer to the last occurrence of ch in the given  *       string  *       returns NULL if ch does not occurr in the string  *  *Exceptions:  *  *******************************************************************************/ ///////////////////////////////////////////////////////////////////////////////// /*说明：   1. __cdecl 是C Declaration的缩写（declaration，声明），表示C语言默认的函数调用方法：所有参数从右到左依次入栈，这些参数由调用者清除，称为手动清栈。被调用函数不会要求调用者传递多少参数，调用者传递过多或者过少的参数，甚至完全不同的参数都不会产生编译阶段的错误。   2.  从字符串尾开始查找某字符出现的位置   3.  按照ANSI(American National Standards Institute)标准，不能对void指针进行算法操作，即不能对void指针进行如p++的操作,所以需要转换为具体的类型指针来操作,例如char *。（引用网友的结论）   4.  size_t 类型定义在cstddef头文件中，该文件是C标准库的头文件stddef.h的C++版。它是一个与机器相关的unsigned类型，其大小足以保证存储内存中对象的大小。 */ char * __cdecl strrchr (                        const char * string,                        int ch                         ) {    char *start = (char *)string;         while (*string++)                       /* find end of string */         ;     /* search towards front */    while (--string != start && *string != (char)ch)         ;         if (*string == (char)ch)               /* char found ? */        return( (char *)string );          return(NULL); } int main() {    char *p = NULL;    int j = 0;     constchar brc[50] =\"blog.csdn.net/barry_yan\";     p =strrchr(brc,(int)'\\0');     j = (int)'\\0';    cout<<j<<endl;         if(p)     {       cout<<*p<<endl;     }    else     {        cout<<\"null\"<<endl;     }    return 0; }","title":"strrchr源码"},{"content":"昨天遇到个问题，需要给列表指定一个自定义显示页面。因为自带的displayform.aspx格式比较单一，所以我们重新做了一个表单显示页面，如何将原来默认的displayform.aspx替换成我们自定义的表单页面，主要是根据SPContentType这个类，修改其中的DisplayFormUrl，执行下这个程序就搞定。当然还可以修改其它SPContentType有的属性，这里只是修改其中的DisplayFormUrl。 //提升管理员权限 SPSecurity.RunWithElevatedPrivileges(delegate() {                 //根据指定站点，获取site                 SPSite site = new SPSite(\"http://moss:8000\");                 SPWeb web = site.OpenWeb();                 web.AllowUnsafeUpdates = true;                 SPList list=web.Lists[\"listname\"];                 SPContentType contentType=list.ContentTypes[\"contenttypename or index\"];                 contentType.DisplayFormUrl = \"/_layouts/project/CustomDisplayForm.aspx\";                 contentType.Update();  });","title":"sharepoint 2010 用contenttype自定义表单显示页面 custom displayForm page by contenttype"},{"content":"1.struts2的类型转换，对于8个元素数据类型以及java.util.Date,String等常见数据，struts2可以使用内建的类型转化器实现自动的转换； 但对于自定义的对象类型来说，就需要我们自己指定类型转换的方式了。 2.对于自定义的类型转换器来说需要提供3个信息：Action名字、Action中待转换的属性名以及该属性对应的转换器。其中Action的名称是通过struts.xml属性文件获得的、Action中待转换的属性名是通过xxx-conversion.properties属性文件中的key来获取，该属性对应的转换器是通过key所对应的value来获得的。 例如：字符串与对象的相互转化。创建如下的目录结构，导入struts2相关jar包，在xml中配置PreparedAndExecuteFilter过滤器            index.jsp中代码如下：   <h1>使用分号隔开用户名和密码信息<\/h1><form action=\"userAction.action\">\tuser info:<input type=\"text\" value=\"\" name=\"user\"><br>\t<input type=\"submit\" value=\"submit\"/><\/form> struts.xml中代码如下： \t<struts>\t\t<package name=\"struts2\" extends=\"struts-default\">\t\t\t<action name=\"userAction\" class=\"com.struts.action.UserAction\">\t\t\t\t<result name=\"success\">/index.jsp<\/result>\t\t\t<\/action>\t\t<\/package>\t<\/struts> UserAction.java中代码如下： package com.struts.action;import com.opensymphony.xwork2.ActionSupport;import com.struts.bean.User;public class UserAction extends ActionSupport{\tprivate User user;\t@Override\tpublic String execute() throws Exception {\t\tSystem.out.println(user.getUsername());\t\tSystem.out.println(user.getPassword());\t\treturn SUCCESS;\t}\tpublic User getUser() {\t\treturn user;\t}\tpublic void setUser(User user) {\t\tthis.user = user;\t}} UserAction-conversion.properties中代码如下： user=com.struts.converter.UserConverter     UserConverter.java代码如下： package com.struts.converter;import java.util.Map;import java.util.StringTokenizer;import com.struts.bean.User;import ognl.DefaultTypeConverter;public class UserConverter extends DefaultTypeConverter{\t//从页面到后台\t@Override\tpublic Object convertValue(Map context, Object value, Class toType) {\t\tif(User.class == toType)//从页面向后台对象转换\t\t{\t\t\tString[] str = (String[])value;\t\t\tString firstValue = str[0];\t\t\tStringTokenizer st = new StringTokenizer(firstValue,\";\");\t\t\tString username = st.nextToken();\t\t\tString password = st.nextToken();\t\t\tUser user = new User();\t\t\tuser.setUsername(username);\t\t\tuser.setPassword(password);\t\t\treturn user;\t\t}else if(String.class == toType){//从后台对象向页面转换\t\t\tUser user = (User)value;\t\t\tString username = user.getUsername();\t\t\tString password = user.getPassword();\t\t\tString userInfo = \"username: \"+username+\", password: \"+password;\t\t\treturn userInfo;\t\t}\t\treturn null;\t}}  ","title":"struts2学习（一）类型转换--DefaultTypeConverter"},{"content":"题目: 从N个数中选取最大的前10个, 有序输出. N最大可能达到1000亿 每个数范围是0 - 2147483647 堆排序版测试结果: 总计[1000000]个输入 总计比较[4232804]次 总计写内存[3849024]次 总计耗时[0.046478s] /*   * author: goosman.lei  * mail: lgg860911@yahoo.com.cn  * blog: http://blog.csdn.net/lgg201  */ #include <stdio.h>#include <time.h>#include <stdlib.h>#include <unistd.h>#include <strings.h>#define BUFF_LEN\t(4096)#define PARENT(i)\t((i) / 2 - 1)#define LEFT(i)\t\t((i + 1) * 2 - 1)#define RIGHT(i)\t((i + 1) * 2)/* #define DEBUG */#define INFO#ifdef INFO\tint\t\ts_0, s_1, s_2;\tstruct timeval\tbegin, end;#endiftypedef struct queue_s\tqueue_t;struct queue_s {\tint\t\tdata;\tqueue_t\t*next;};static void generate_test_data(long n) {\tlong\ti;\tint\t\tr;\tint\t\tl;\tl\t= sizeof(int);\tsrand(time(NULL));\tfor ( i = 0; i < n; i ++ ) {\t\tr\t= rand();\t\tfprintf(stdout, \"%d\\n\", r);\t\twrite(STDERR_FILENO, &r, l);\t}}static int read_input(int fd, void *buff, int buff_len) {\tint\t\ti, ret;\tfor ( i = 0; i < buff_len; ) {\t\tret = read(fd, buff, BUFF_LEN);\t\tif ( -1 == ret ) {\t\t\tperror(\"read error\\n\");\t\t\texit(0);\t\t} else if ( 0 == ret ) {\t\t\tbreak;\t\t} else {\t\t\tbuff\t+= ret;\t\t\ti\t\t+= ret;\t\t}\t}\treturn i;}static void dump_link(queue_t *q, int n) {\tfor ( ; q != NULL; q = q->next )\t\tfprintf(n ? stderr : stdout, \"%d\\n\", q->data);\tif ( n ) printf(\"\\n\");}void max_heapify(int *sbuff, int j) {\tint\ti;#ifdef INFO\ts_0 += 3;\ts_1 ++;#endif\tif ( sbuff[j] < sbuff[LEFT(j)] )\t\ti\t= LEFT(j);\telse\t\ti\t= j;\tif ( sbuff[i] < sbuff[RIGHT(j)] ) {\t\ti\t= RIGHT(j);#ifdef INFO\ts_1 ++;#endif\t}\tif ( i != j ) {\t\tsbuff[i]\t^= sbuff[j];\t\tsbuff[j]\t^= sbuff[i];\t\tsbuff[i]\t^= sbuff[j];\t\tmax_heapify(sbuff, i);#ifdef INFO\ts_1 += 3;#endif\t}}int main(int argc, char *argv[]) {\tint\t\t*sbuff, *rbuff, *rbuff_t;\tint\t\ti, j, n, rbuff_n;\tif ( argc < 2 ) {\t\tprintf(\"usage: \\n\\t1. 生成测试数据: %s <number> /* 标准错误以二进制方式输出测试数据, 标准输出以文本方式输出测试数据用于脚本校验 */\\n\\t2. 执行Top 10查找: %s <exec> /* 标准输出输出前10个最大数据(倒序), 开启INFO时在标准错误输出统计信息, 开启DEBUG时在标准错误输出调试信息\\n\", \t\t\targv[0], argv[0]);\t\treturn (0);\t}\tif ( strcmp(argv[1], \"exec\") != 0 ) {\t\t/* 不考虑数字输入的容错了 */\t\tgenerate_test_data(atoi(argv[1]));\t\treturn 0;\t}\tsbuff\t= malloc(1024 * 1024 * 4 - 4);\trbuff\t= malloc(256 * 1024 * 10 * 4);\t/* 足够10000亿数据 */\trbuff_t\t= rbuff;\trbuff_n\t= 0;#ifdef INFO\ts_0\t= 0;\ts_1\t= 0;\ts_2\t= 0;\tgettimeofday(&begin, NULL);#endif\twhile ( 0 != (n = read_input(STDIN_FILENO, sbuff, 1024 * 1024 * 4 - 4)) ) {#ifdef INFO\ts_2\t+= n / 4;#endif\t\tfor ( j = (n / 4) / 2; j >= 0; j -- ) {#ifdef INFO\ts_0 ++;#endif\t\t\tmax_heapify(sbuff, j);\t\t}\t\tfor ( i = 0; i < 10; i ++ ) {#ifdef INFO\ts_0 ++;\ts_1 += 4;#endif\t\t\trbuff[rbuff_n]\t= sbuff[0];\t\t\tsbuff[0]\t\t= sbuff[(n / 4) - 1 - i];\t\t\tsbuff[(n / 4) - 1 - i]\t= -1;\t\t\tmax_heapify(sbuff, 0);\t\t\trbuff_n ++;\t\t}\t}\tfor ( j = rbuff_n / 2; j >= 0; j -- ) {#ifdef INFO\ts_0 ++;#endif\t\tmax_heapify(rbuff, j);\t}\tfor ( i = 0; i < 10; i ++ ) {#ifdef INFO\ts_0 ++;\ts_1 += 4;#endif\t\tprintf(\"%d\\n\", rbuff[0]);\t\trbuff[0]\t= rbuff[rbuff_n - i];\t\trbuff[rbuff_n - i]\t= -1;\t\tmax_heapify(rbuff, 0);\t}#ifdef INFO\tgettimeofday(&end, NULL);#endif#ifdef INFO\tfprintf(stderr, \"总计[%d]个输入\\n总计比较[%d]次\\n总计写内存[%d]次\\n总计耗时[%0.6fs]\\n\", \t\ts_2, s_0, s_1, (end.tv_sec * 1000000 + end.tv_usec - begin.tv_sec * 1000000 - begin.tv_usec) / 1000000.0);#endif\treturn 0;}","title":"从N个数中选取最大的前10个[堆排序版]"},{"content":"快速排序是一种最坏情况运行时间为O(n*n)，虽然这个最坏情况运行时间比较差，但快速排序通常都是用于排序的最 佳的实用选择，这是因为其平均性能相当好：期望的运行时间为O(nlgn)，且O(nlgn)记号中隐含的常数因子很小。另 外，它还能够进行就地排序。 快速排序和合并排序一样，采用的都是分治思想。快排中利用该思想解决步骤为： 1、先从数组中取出一个数作为基数，基数的选择对排序效率的影响很大 2、分区，将比这个基数小的数全部放到它的左边，比基数大的数全部放到其右边 3、对左右两个区间重复第二步，直到每个区间只有一个数 下面结合代码来进一步理解快速排序。算法导论上一开始给出的基数选择就是直接选择待排序数组中最后一个元素作 为基数，即对于数组a[N]，以a[N-1]作为基数。以一般情况来讨论，当我们要进行排序的数组为a[p...r]时，选择a[r]为 基数，然后将这个序列分为3部分，a[p...q-1]，a[q]， a[q+1, r]，其中a[p...q-1]的元素都是小于基数的，a[q]就是基 数，a[q+1, r]的元素都大于基数。其实现代码如下： int partition (int a[], int p, int r){\tint i = p - 1;\tfor (int j = p; j < r; j++)\t{\t\tif (a[j] < a[r])\t\t{\t\t\tswap (a[++i], a[j]);\t\t}\t}\tswap (a[++i], a[r]);\treturn i;}该函数的执行过程如下图： 这个函数最后返回的便是q，接下来我们便要对a[p...q-1]和a[q+1, r]重复上述步骤，直到只剩下一个元素。代码如下： void quick_sort (int a[], int p, int r){\tif (p < r)\t{\t\tint q = partition (a, p, r);\t\tquick_sort (a, p, q - 1);\t\tquick_sort (a, q + 1, r);\t}} 最后附上我自己的一个完整的代码，可以直接运行测试运行结果： #include<iostream>using namespace std;void display (int a[], int n);void swap (int& n, int& m);int partition (int a[], int p, int r);void quick_sort (int a[], int p, int r);int main(){\tint a[100];\tint n;\twhile (cin >> n)\t{\t\tfor (int i = 0; i < n; i++)\t\t\tcin >> a[i];\t\tquick_sort (a, 0, n - 1);\t\tdisplay (a, n);\t}\treturn 0;}void display (int a[], int n){\tfor (int i = 0; i < n; i++)\t\tcout << a[i] << \" \";\tcout << endl;}void swap (int& n, int& m){\tint temp;\ttemp = n;\tn = m;\tm = temp;}int partition (int a[], int p, int r){\tint i = p - 1;\tfor (int j = p; j < r; j++)\t{\t\tif (a[j] < a[r])\t\t{\t\t\tswap (a[++i], a[j]);\t\t}\t}\tswap (a[++i], a[r]);\treturn i;}void quick_sort (int a[], int p, int r){\tif (p < r)\t{\t\tint q = partition (a, p, r);\t\tquick_sort (a, p, q - 1);\t\tquick_sort (a, q + 1, r);\t}} 算法导论书上在最后还提供了几个改进的版本，如随机化版本，三数取中等，这些改进的版本基本都是在对基数选择 方法上进行改进的。有兴趣的朋友可以自己试试！","title":"快速排序"},{"content":"Rookie零基础学java博客目录（不断更新） 一、在window下编写： 打开文本文件编辑器，如Windows的记事本，也可使用更高级的编写工具。如Eclipse、JBuilder、NetBeans等，这些工具具有更加强大的功能，但现在不推荐使用，不利于初学者打下良好的编程基础。首先，在记事本里添加如下代码。该代码可以直接从光盘中复制到记事本中，当然亲自动手输入是最好的。 (1)用文本编辑器写一个简单的java程序：  public class HelloWorld { public static void main(String args[]) { System.out.println(\"Hello World!\"); } }   这个例子就是著名的“Hello World”，它的功能就是显示“Hello World”。  注意：该文件名称必须为“HelloWorld.java”，大小写也区分。细心的朋友会注意到就是和public class后的名字一样的。  (2)编译：在dos命令提示符下执行：（注意大小写）  javac HelloWorld.java  如果正常的话，将生成HelloWorld.class文件。  (3)运行：在dos命令提示符下执行：（注意大小写）  java HelloWorld  这里有一个java初学者很有可能遇到的问题（不怕笑话，我也是）就是输入：  java HelloWorld.class  多了后面的.class，一定要注意，否则会出现下面的错误：  Exception in thread \"main\" java.lang.NoClassDefFoundError:HelloWorld/class  （本人猜想，是不是java翻译“.”的时候换成了“/”，或者是其他的本人不知道的原因）  好了，运行java HelloWorld应该会出现伟大的“Hello World”了。  到这一步，你已经成功配置好了JDK，可以开始漫长而痛苦(对于象我一样的，以前不懂java的朋友来说，可以用“痛苦”来形容，不理解的概念，不熟悉的java api...，不过，不要急，我将和大家一起慢慢入门，慢慢提高... ...)的Java过程了。   二、在linux系统下运行： [haoyue@centos ~]$ javac 1.java  1.java:2: 类 HelloWorld 是公共的，应在名为 HelloWorld.java 的文件中声明 public class HelloWorld {  ^ 1 错误 [haoyue@centos ~]$ mv 1.java HelloWorld.java [haoyue@centos ~]$ javac HelloWorld.java  [haoyue@centos ~]$ java HelloWorld Hello world ! This is my first program with java! [haoyue@centos ~]$  三、注意事项： 在编写、编译和运行Java程序时有很多注意点，这也是初学者需要注意的地方。 在运行时如果提示“java.lang.NoClassDefFoundError”的话，请查找环境变量是否设置正确。 在命令提示符下输入命令的时候要注意区分大小写，Java是区分大小写的。 用javac编译程序时是有扩展名的。 用java运行程序时是没有扩展名的。 源程序里要有main方法。 源程序里的类名要和文件名相同，包括大小写。      ","title":"Rookie零基础学java（二）第一个java程序HelloWorld（在win7和linux下）"},{"content":"用socket做网络应用程序，发送和接收超时好办，Connect超时目前找来找去只有select这招了 于是，用到了timeval这个家伙。   起初我以为，要粗略设置秒数，就用tv_sec成员，要精确到百万分之一秒，就用tv_usec，结果设置为1秒的时候 \tFD_ZERO(&fs);\tFD_SET(sock, &fs);\ttv.tv_sec = 0;\ttv.tv_usec = 1000000;\tret = select(0, 0, &fs, 0, &tv);\tif(ret <= 0)\t{\t// 链接超时\t\tclosesocket(sock);\t\treturn FALSE;\t} 编译为debug，运行正常，1秒后超时返回；编译为release问题就来了，一般等待20多秒，丫丫的 查百度，谷歌未果；查MSDN->NULL 于是自己试试，发现跟64位那个结构体差不多，一个高32位一个低32位；这里是一个秒数部分，一个微秒部分……   \tFD_ZERO(&fs);\tFD_SET(sock, &fs);\tret = dwConnTime / 1000000;\ttv.tv_sec = (long)ret;\t//timeval结构体是多少秒又多少微秒\tret = dwConnTime % 1000000;\ttv.tv_usec = (long)ret;\t//精度百万分之一秒\tret = select(0, 0, &fs, 0, &tv);\tif(ret <= 0)\t{\t\tclosesocket(sock);\t\treturn FALSE;\t} 这样就ooxx了！","title":"说一个丢人现眼的错误"},{"content":"——上帝给了我们每个人同样的机会去创造未来 我的选择是用代码敲出未来。         初接触c++，心里有点小纠结。为什么代码要这样写，为什么要费尽心机解释那么多行代码，为什么都是英文。。。。。未来渺茫,前途无光.    再接触c++,心里有了点小激动。神奇的代码，为我编译梦想。博客上留下岁月的痕迹，每一篇博文都记录了我的成长    但是通过一步步的编程，逐步的成长，慢慢地记住了程序编写的固定格式,渐渐学会了各种各样的函数语法,感觉自己对未来有了希望.    ","title":"[置顶] c++第一学期菜鸟总结"},{"content":"如你所见，在NIO中，数据的读写操作始终是与缓冲区相关联的。Channel将数据读入缓冲区，然后我们又从缓冲区访问数据。写数据时，首先将要发送的数据按顺序填入缓冲区。基本上，缓冲区只是一个列表，它的所有元素都是基本数据类型（通常为字节型）。缓冲区是定长的，它不像一些类那样可以扩展容量（例如，List，StringBuffer等）。注意，ByteBuffer是最常用的缓冲区，因为：1）它提供了读写其他数据类型的方法，2）信道的读写方法只接收ByteBuffer。那么其他类型的信道，如IntBuffer，DoubleBuffer等的优点在哪呢？稍安毋躁！答案将在第5.4.6节揭晓。   5.4.1 Buffer索引 缓冲区不仅仅是用来存放一组元素的列表。在读写数据时，它有内部状态来跟踪缓冲区的当前位置，以及有效可读数据的结束位置等。为了实现这些功能，每个缓冲区维护了指向其元素列表的4个索引，如表5.1所示。（不久我们将看到如何使用缓冲区的各种方法来修改索引值。）   表5.1：缓冲区内部状态 position和limit之间的距离指示了可读取/存入的字节数。Java中提供了两个方便的方法来计算这个距离。 ByteBuffer:剩余字节 boolean hasRemaining() int remaining() 当缓冲区至少还有一个元素时，hasRemaining()方法返回true，remaining()方法返回剩余元素的个数。 在这些变量中，以下关系保持不变： 0  ≤ mark     ≤ position          ≤ limit        ≤ capacity   mark变量的值\"记录\"了一个将来可返回的位置，reset()方法则将position的值还原成上次调用mark()方法后的position值（除非这样做会违背上述的不变关系）。   5.4.2创建Buffer   通常使用分配空间或包装一个现有的基本类型数组来创建缓冲区。创建ByteBuffer的静态工厂方法，以及相应的capacity，position，和limit的初始值见表5.2。所有新创建的Buffer实例都没有定义其mark值，在调用mark()方法前，任何试图使用reset()方法来设置position的值的操作都将抛出InvalidMarkException异常。 要分配一个新的实例，只需要简单地调用想要创建的缓冲区类型的allocate()静态方法，并指定元素的总数： ByteBuffer byteBuf = ByteBuffer.allocate(20); DoubleBuffer dblBuf = DoubleBuffer.allocate(5);   表5.2：ByteBuffer      创建方法   在上面代码中，byteBuf分配了20个字节，dblBuf分配了5个Java的double型数据。这些缓冲区都是定长的，因此无法扩展或缩减它们的容量。如果发现刚创建的缓冲区容量太小，惟一的选择就是重新创建一个大小合适的缓冲区。 还可以通过调用wrap()静态方法，以一个已有的数组为参数，来创建缓冲区： byteArray[] = new byte[BUFFERSIZE]; // ...Fill array... ByteBuffer byteWrap = ByteBuffer.wrap(byteArray); ByteBuffer subByteWrap = ByteBuffer.wrap(byteArray, 3, 3); 通过包装的方法创建的缓冲区保留了被包装数组内保存的数据。实际上，wrap()方法只是简单地创建了一个具有指向被包装数组的引用的缓冲区，该数组称为后援数组。对后援数组中的数据做的任何修改都将改变缓冲区中的数据，反之亦然。如果我们为wrap()方法指定了偏移量（offset）和长度（length），缓冲区将使用整个数组为后援数组，同时将position和limit的值初始化为偏移量（offset）和偏移量+长度（offset+length）。在偏移量之前和长度之后的元素依然可以通过缓冲区访问。  使用分配空间的方式来创建缓冲区其实与使用包装的方法区别不大。惟一的区别是allocate()方法创建了自己的后援数组。在缓冲区上调用array()方法即可获得后援数组的引用。通过调用arrayOffset()方法，甚至还可以获取缓冲区中第一个元素在后援数组中的偏移量。使用wrap()方法和非零偏移量参数创建的缓冲区，其数组偏移量依然是0。 到目前为止，我们实现的所有缓冲区都将数据存放在Java分配的后援数组中。通常，底层平台（操作系统）不能使用这些缓冲区进行I/O操作。操作系统必须使用自己的缓冲区来进行I/O，并将结果复制到缓冲区的后援数组中。这些复制过程可能非常耗费系统资源，尤其是在有很多读写需求的时候。Java的NIO提供了一种直接缓冲区（direct buffers）来解 决这个问题。使用直接缓冲区，Java将从平台能够直接进行I/O操作的存储空间中为缓冲区分配后援存储空间，从而省略了数据的复制过程。这种低层的、本地的I/O通常在字节层进行操作，因此只能为 ByteBuffer进行直接缓冲区分配。 ByteBuffer byteBufDirect =ByteBuffer.allocateDirect(BUFFERSIZE); 通过调用isDirect()方法可以查看一个缓冲区是否是直接缓冲区。由于直接缓冲区没有后援数组，在它上面调用array()或arrayOffset()方法都将抛出UnsupportedOperationException异常。在考虑是否使用直接缓冲区时需要牢记几点。首先，要知道调用allocateDirect()方法并不能保证能成功分配直接缓冲区--有的平台或JVM可能不支持这个操作，因此在尝试分配直接缓冲区后必须调用isDirect()方法进行检查。其次，要知道分配和销毁直接缓冲区通常比分配和销毁非直接缓冲区要消耗更多的系统资源，因为直接缓冲区的后援存储空间通常存在与JVM之外，对它的管理需要与操作系统进行交互。所以，只有当需要在很多I/O操作上长时间使用时，才分配直接缓冲区。实际上，在相对于非直接缓冲区能明显提高系统性能时，使用直接缓冲区是个不错的主意。   5.4.3存储和接收数据 只要有了缓冲区，就可以用它来存放数据了。作为数据的\"容器\"，缓冲区既可用来输入也可用来输出。这一点就与流不同，流只能向一个方向传递数据。使用put()方法可以将数据放入缓冲区，使用get()方法则可以从缓冲区获取数据。信道的read()方法隐式调用了给定缓冲区的put()，而其write()方法则隐式调用了缓冲区的get()方法。下面展示ByteBuffer的get()和put()方法，当然，其他类型的缓冲区也有类似的方法。  ByteBuffer:获取和存放字节 相对位置： byte get() ByteBuffer get(byte[] dst) ByteBuffer get(byte[] dst, int offset, int length) ByteBuffer put(byte b) ByteBuffer put(byte[] src) ByteBuffer put(byte[] src, int offset, int length) ByteBuffer put(ByteBuffer src) 绝对位置： byte get(int index) ByteBuffer put(int index, byte b) 有两种类型的get()和put()：基于相对位置和基于绝对位置。基于相对位置的版本根据position的当前值，从\"下一个\"位置读取或存放数据，然后根据数据量给position增加适当的值（即，单字节形式增加1，                                         数组形式增加array.length，     数组/偏移量/长度形式则增加length）。也就是说，每次调用put()方法，都是在缓冲区中的已有元素后面追加数据，每次调用get()方法，都是读取缓冲区的后续元素。不过，如果这些操作会导致position的值超出limit的限制，get()方法将抛出BufferUnderflowException异常，put()方法将抛出BufferOverflowException异常。例如，如果传给get()方法的目标数组长度大于缓冲区的剩余空间大小，get()方法将抛出BufferUnderflowException异常，部分数据的get/put是不允许的。基于绝对位置的get()和put()以指定的索引位置为参数，从该位置读取数据或向该位置写入数据。绝对位置形式的get和put不会改变position的值。如果给定的索引值超出了limit的限制，它们将抛出IndexOutOfBoundsException异常。 除了字节类型外，ByteBuffer类还提供了其他类型数据的相当位置和绝对位置的get/put方法。这样一来，就有点像DataOutputStream了。  ByteBuffer:读取和存放Java多字节基本数据 <type> get<Type>() <type> get<Type>(int index) ByteBuffer put<Type>(<type> value) ByteBuffer put<Type>(int index,<type> value) 其中\"<Type>\"代表Char，Double，Int，Long，Short之一，而\"<type>\"代表char，double，int，long，short之一。 每次调用基于相对位置的put()或get()方法，都将根据特定参数类型的长度增加position的值：short加2，int加4，等。不过，如果这样做会导致position的值超出limit的限制，get()和put()方法将分别抛出BufferUnderflowException和BufferOverflowException异常：get和put不允许只对部分数据进行操作。发生了下溢/上溢（under/overflow）时，position的值不变。 可能你已经注意到，很多get/put方法都返回一个ByteBuffer。实际上它们返回的就是调用它们的那个ByteBuffer。这样做可以实现链式调用（call chaining），即第一次调用的结果可以直接用来进行后续的方法调用。例如，可以像下面那样将整数1和2存入ByteBuffer实例 myBuffer中：myBuffer.putInt(1).putInt(2);   回顾第3章的内容我们知道，多字节数据类型有一个字节顺序，称为big-endian或little-endian。Java默认使用big-endian。通过使用内置的ByteOrder.BIG_ENDIAN和 ByteOrder.LITTLE_ENDIAN实例，可以获取和设定多字节数据类型写入字节缓冲区时的字节顺序。  ByteBuffer:缓冲区中的字节顺序 ByteOrder order() ByteBuffer order(ByteOrder order) 第一个方法以ByteOrder常量的形式返回缓冲区的当前字节顺序。第二个方法用来设置 写多字节数据时的字节顺序。 下面来看一个使用字节顺序的例子： ByteBuffer buffer = ByteBuffer.allocate(4); buffer.putShort((short) 1); buffer.order(ByteOrder.LITTLE_ENDIAN); buffer.putShort((short) 1); // Predict the byte values for buffer and test your prediction 看了这些有关字节顺序的讨论，你可能希望知道自己的处理器是什么字节顺序，ByteOrder定义了一个方法来解答这个问题： ByteOrder:查找字节顺序 static final ByteOrder BIG_ENDIAN static final ByteOrder LITTLE_ENDIAN static ByteOrder nativeOrder() nativeOrder()方法返回常量BIG_ENDIAN或LITTLE_ENDIAN之一。   5.4.4准备Buffer：clear()，flip()，和rewind() 在使用缓冲区进行输入输出数据之前，必须确定缓冲区的position，limit都已经设置了正确的值。下面考虑一个容量为7的CharBuffer实例，并已经连续调用了put()或read()方法：    如果现在想用这个缓冲区进行信道的写操作，由于write()方法将从position指示的位置开始读取数据，在limit指示的位置停止，因此在进行写操作前，先要将limit的值设为position的当前值，再将position的值设为0。    这种情况我们可以自己处理，不过，幸运的是Java已经提供了一些便利的方法来完成 这些工作，见表5.3。   注意，这些方法不会改变缓冲区中的数据，只是改变缓冲区的索引。clear()方法将position 设置为0，并将limit设置为等于capacity，从而使缓冲区准备好从缓冲区的put操作或信道 的读操作接收新的数据。    表5.3：ByteBuffer实例的方法   后续的put()/read()调用，将数据从第一个元素开始填入缓冲区，直到填满了limit所指 定的限制，其值等于capacity的值。 // Start with buffer in unknown state buffer.clear(); // Prepare buffer for input,  ignoring existing state channel.read(buffer); // Read new data into  buffer, starting at first element   虽然名字是clear()，但它实际上不会改变缓冲区中的数据，而只是简单地重置了缓冲区的主要索引值。考虑一个最近使用put()或read()存入了数据的缓冲区，其position值指示了不包含有效字符的第一个元素位置。 flip()方法用来将缓冲区准备为数据传出状态，这通过将limit设置为position的当前值，再将 position的值设为0来实现： 后续的get()/write()调用将从缓冲区的第一个元素开始检索数据，直到到达limit指示的位置。下面是使用flip()方法的例子： // ... put data in buffer with put() or read() ... buffer.flip(); // Set position to 0, limit to old position while (buffer.hasRemaining()) // Write buffer  data from the first element up to limit channel.write(buffer); 假设在写出缓冲区的所有数据后，你想回到缓冲区的开始位置再重写一次相同的数据（例如，想要将同样的数据发送给另一个信道）。rewind()方法将position设置为0，并使mark值无效。这很像flip()方法的操作，只是limit的值没变。这些操作什么时候会有用呢？当你想要将在网络上发送的所有数据都写入日志时就会用到： // Start with buffer ready for writing while (buffer.hasRemaining()) // Write all data to network networkChannel.write(buffer); buffer.rewind(); // Reset buffer to write again while (buffer.hasRemaining()) // Write all data to logger loggerChannel.write(buffer);   5.4.5压缩Buffer中的数据 compact()方法将 position与limit之间的元素复制到缓冲区的开始位置，从而为后续的put()/read()调用让出空间。position的值将设置为要复制的数据的长度，limit的值将设置为capacity，mark则变成未定义。考虑在下面的缓冲区调用compact()前的状态： 下面是调用compact()后的状态：   为什么要使用这个操作呢？假设你有一个缓冲区要写数据。回顾前面的内容我们知道，对write()方法的非阻塞调用只会写出其能够发送的数据，而不会阻塞等待所有数据发送完。因此write()方法不一定会将缓冲区中的所有元素都发送出去。又假设现在要调用read()方法，在缓冲区中没有发送的数据后面读入新数据。处理方法之一就是简单地设置position = limit和limit = capacity。当然，在读入新数据后，再次调用write()方法前，还需要将这些值还原。这样做有个问题即缓冲区的空间最终将消耗殆尽，如上图中，只剩下一个元素位置可以再存入一个字节。此外，缓冲区前面的空间又被浪费掉了。这就是compact()方法要解决的问题。在调用write()方法后和添加新数据的read()方法前调用compact()方法，则将所有\"剩余\"的数据移动到缓冲区的开头，从而为释放最大的空间来存放新数据。 // Start with buffer ready for reading while (channel.read(buffer) != -1) { buffer.flip(); channel.write(buffer); buffer.compact(); } while (buffer.hasRemaining()) channel.write(buffer);  注意，如在本章开始已经提到的，复制数据是一个非常耗费系统资源的操作，因此要保守地使用compact()方法。   5.4.6 Buffer透视：duplicate()，slice()等  NIO提供了多种方法来创建一个与给定缓冲区共享内容的新缓冲区，这些方法对元素的处理过程各有不同。基本上，这种新缓冲区有自己独立的状态变量（position，limit，capacity和mark），但与原始缓冲区共享了同一个后援存储空间。任何对新缓冲区内容的修改都将反映到原始缓冲区上。可以将新缓冲区看作是从另一个角度对同一数据的透视。表5.4列出了相关的方法。 duplicate()方法用于创建一个与原始缓冲区共享内容的新缓冲区。新缓冲区的position， limit，mark和capacity都初始化为原始缓冲区的索引值，然而，它们的这些值是相互独立的。 表 5.4：在Buffer上创建不同透视的方法   由于共享了内容，对原始缓冲区或任何复本所做的改变在所有复本上都可见。下面回到 前面的例子，假设要将在网络上发送的所有数据都写进日志。 // Start with buffer ready for writing ByteBuffer logBuffer = buffer.duplicate(); while (buffer.hasRemaining()) // Write all data to network networkChannel.write(buffer); while (logBuffer.hasRemaining()) // Write all data to logger loggerChannel.write(buffer); 注意，使用了缓冲区复制操作，向网络写数据和写日志就可以在不同的线程中并行进行。slice()方法用于创建一个共享了原始缓冲区子序列的新缓冲区。新缓冲区的position值是0，而其limit和capacity的值都等于原始缓冲区的limit和position的差值。slice()方法将新缓冲区数组的offset值设置为原始缓冲区的position值，然而，在新缓冲区上调用array()方法还是会返回整个数组。  Channel在读写数据时只以ByteBuffer为参数，然而我们可能还对使用其他基本类型的数据进行通信感兴趣。ByteBuffer能够创建一种独立的\"视图缓冲区（view buffer）\"，用于将ByteBuffer的内容解释成其他基本类型（如CharBuffer）。这样就可以从该缓冲区中读取（写入数据是可选操作）新类型的数据。新缓冲区与原始缓冲区共享了同一个后援存储空间，因此，在任一缓冲区上的修改在新缓冲区和原始缓冲区上都可以看到。新创建的视图缓冲区的position值为0，其内容从原始缓冲区的position所指位置开始。这与slice()操作非常相似。不过，由于视图缓冲区操作的是多字节元素，新缓冲区的capacity和limit的值等于剩余总字节数除以每个该类型元素对应的字节数（例如，创建DoubleBuffer时则除以8）。 下面来看一个例子。假设通过某个Channel接收到一条消息，该消息由一个单独字节，后跟大量big-endian顺序的双字节整数（如short型）组成。由于该消息是通过Channel送达的，它一定在一个ByteBuffer中，在此为buf。消息的第一个字节包含了消息中双字节整数的数量。你可能要调用第一个字节指定次数的buf.getShort()方法，或者你可以一次获取所有的整数，如下所示： // ...get message by calling channel.read(buf) ... int numShorts = (int)buf.get(); if (numShorts < 0) { throw new SomeException() } else { short[] shortArray = new short[numShorts]; ShortBuffer sbuf = buf.asShortBuffer(); sbuf.get(shortArray); // note: will throw if header was incorrect! } asReadOnlyBuffer()方法的功能与duplicate()方法相似，只是任何会修改新缓冲区内容的方法都将抛出ReadOnlyBufferException异常。包括各种型式的put()，compact()等，甚至连在缓冲区上调用无方向性的array()和arrayOffset()方法也会抛出这个异常。当然，对产生这个只读缓冲区的非只读缓冲区进行的任何修改，仍然会与新的只读缓冲区共享。就像用duplicate()创建的缓冲区一样，只读缓冲区也有独立的缓冲区状态变量。可以使用isReadOnly()方法来检查一个缓冲区是否是只读的。如果原缓冲区已经是只读的，调用duplicate()或slice()方法也将创建新的只读缓冲区。   5.4.7字符编码 回顾第3章介绍的内容我们知道，字符是由字节序列进行编码的，而且在字节序列与字符集合之间有各种映射（称为字符集）方式。NIO缓冲区的另一个用途是在各种字符集之间进行转换。要使用这个功能，还需要了解java.nio.charset包中另外两个类（在第3章中我们已经介绍了Charset类）：CharsetEncoder和CharsetDecoder类。要进行编码，需要使用一个Charset实例来创建一个编码器并调用encode方法： Charset charSet = Charset.forName(\"US-ASCII\"); CharsetEncoder encoder = charSet.newEncoder(); ByteBuffer buffer = encoder.encode(CharBuffer.wrap(\"Hi mom\")); 要进行解码，需要使用Charset实例来创建一个解码器，并调用decode方法： CharsetDecoder decoder = charSet.newDecoder(); CharBuffer cBuf = decoder.decode(buffer); 虽然这种方法能够正常工作，但当需要进行多次编码时，效率就会变得较低。例如，每次调用encode/decode方法都会创建一个新Byte/CharBuffer实例。其他导致低效率的地方与编码器的创建和操作有关。 encoder.reset(); if (encoder.encode(CharBuffer.wrap(\"Hi \"),buffer,false) == CoderResult.OVERFLOW) { // ... deal with lack of space in buffer ... } if (encoder.encode(CharBuffer.wrap(\"Mom\"),buffer,true) == CoderResult.OVERFLOW) { // ... ditto ... } encoder.flush(buffer); encode()方法将给定CharBuffer转换为一个字节序列，并将其写入给定的缓冲区。如果缓冲区太小，encode()方法的返回值等于CoderResult.OVERFLOW。如果输入的数据完全被接收，并且编码器还准备对更多数据进行编码，encode()方法的返回值则等于CoderResult.UNDERFLOW。另外，如果输入的数据格式有错误，则将返回一个CoderResult对象，并指示了所存在的问题的位置和类型。只有到达了输入数据的结尾时，才将最后的boolean参数设为true。flush()方法将任何缓存的编码数据推送到缓冲区。注意，在新创建的编码器上调用reset()方法并不是必需的，该方法用来重新设置编码器的内部状态，以使其能够进行再次编码。   相关下载： Java_TCPIP_Socket编程(doc) http://download.csdn.net/detail/undoner/4940239   文献来源： UNDONER(小杰博客) ：http://blog.csdn.net/undoner LSOFT.CN(琅软中国) ：http://www.lsoft.cn  ","title":"NIO：Buffer 详解"},{"content":"今天在做POST登陆程序，在用httpclient得到登陆页面的时候出问题了，页面代码如下： < !DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\"> <html><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\"> <meta http-equiv=\"Content-Script-Type\" content=\"text/javascript\"> <script type=\"text/javascript\"> function setCookie(c_name, value, expiredays) { var exdate = new Date(); exdate.setDate(exdate.getDate()+expiredays); document.cookie = c_name + \"=\" + escape(value) + ((expiredays==null) ? \"\" : \";expires=\" + exdate.toGMTString()) + \";path=/\"; } function getHostUri() { var loc = document.location; return loc.toString(); } setCookie('YPF8827340282Jdskjhfiw_928937459182JAX666', '115.173.104.54', 10); setCookie('DOAReferrer', document.referrer, 10); location.href = getHostUri(); <\/script><\/head>< body>< noscript>This site requires JavaScript and Cookies to be enabled. Please change your browser settings or upgrade your browser.<\/noscript><\/body><\/html> This site requires JavaScript and Cookies to be enabled. Please change your browser settings or upgrade your browser. 开始以为这一句是浏览器可以监测到JS是否运行，那我这个POST登陆就做不成了，只能考虑用IE插件模拟登陆了。 但查资料，有人说“服务器是没法判断你是否启用JS的。而判断COOKIE的话，应该是在首页的时候会发给你一个COOKIE，并且在其他页面判断是否有COOKIE，所以就得在COOKIE上入手，而不是User-agent” 这下就放心了。这个解决方法还是很简单的，就是模拟JS，给httpclient加上页面代码里的COOKIE后，再次访问登陆页面就可以得到正常的代码了。 问题终于解决了，就在于第一次抓取数据时，如上返回的数据，根据该数据，只要给HttpClient设置好Cookie,再重新抓取就可以了  ","title":"This site requires JavaScript and Cookies to be enabled的解决方法"},{"content":"最近一段时间写一个授权的程序，需要获取很多信息来保证程序不能随意复制使用，必须经过授权才可以。 为了限制用户使用的操作系统，必须有统一的方法来获取才可以。 在JAVA中，通过System.getProperty(\"os.name\")来获取，通过参考：http://lopica.sourceforge.net/os.html 来实现各操作系统的判断。 针对windows系统，这里不具体判断是那个版本，如果有需要，可以在判断出windows之后，继续判断，判断需要考虑java的版本，版本不同，结果也不一样。 下面上代码： 1.枚举类型：EPlatform /** * 平台 * @author isea533 */public enum EPlatform {\tAny(\"any\"),\tLinux(\"Linux\"),\tMac_OS(\"Mac OS\"),\tMac_OS_X(\"Mac OS X\"),\tWindows(\"Windows\"),\tOS2(\"OS/2\"),\tSolaris(\"Solaris\"),\tSunOS(\"SunOS\"),\tMPEiX(\"MPE/iX\"),\tHP_UX(\"HP-UX\"),\tAIX(\"AIX\"),\tOS390(\"OS/390\"),\tFreeBSD(\"FreeBSD\"),\tIrix(\"Irix\"),\tDigital_Unix(\"Digital Unix\"),\tNetWare_411(\"NetWare\"),\tOSF1(\"OSF1\"),\tOpenVMS(\"OpenVMS\"),\tOthers(\"Others\");\t\tprivate EPlatform(String desc){\t\tthis.description = desc;\t}\t\tpublic String toString(){\t\treturn description;\t}\t\tprivate String description;} 2.操作系统类：OSinfo /** * 操作系统类： * 获取System.getProperty(\"os.name\")对应的操作系统 * @author isea533 */public class OSinfo {\t\tprivate static String OS = System.getProperty(\"os.name\").toLowerCase();\t\tprivate static OSinfo _instance = new OSinfo();\t\tprivate EPlatform platform;\t\tprivate OSinfo(){}\t\tpublic static boolean isLinux(){\t\treturn OS.indexOf(\"linux\")>=0;\t}\t\tpublic static boolean isMacOS(){\t\treturn OS.indexOf(\"mac\")>=0&&OS.indexOf(\"os\")>0&&OS.indexOf(\"x\")<0;\t}\t\tpublic static boolean isMacOSX(){\t\treturn OS.indexOf(\"mac\")>=0&&OS.indexOf(\"os\")>0&&OS.indexOf(\"x\")>0;\t}\t\tpublic static boolean isWindows(){\t\treturn OS.indexOf(\"windows\")>=0;\t}\t\tpublic static boolean isOS2(){\t\treturn OS.indexOf(\"os/2\")>=0;\t}\t\tpublic static boolean isSolaris(){\t\treturn OS.indexOf(\"solaris\")>=0;\t}\t\tpublic static boolean isSunOS(){\t\treturn OS.indexOf(\"sunos\")>=0;\t}\t\tpublic static boolean isMPEiX(){\t\treturn OS.indexOf(\"mpe/ix\")>=0;\t}\t\tpublic static boolean isHPUX(){\t\treturn OS.indexOf(\"hp-ux\")>=0;\t}\t\tpublic static boolean isAix(){\t\treturn OS.indexOf(\"aix\")>=0;\t}\t\tpublic static boolean isOS390(){\t\treturn OS.indexOf(\"os/390\")>=0;\t}\t\tpublic static boolean isFreeBSD(){\t\treturn OS.indexOf(\"freebsd\")>=0;\t}\t\tpublic static boolean isIrix(){\t\treturn OS.indexOf(\"irix\")>=0;\t}\t\tpublic static boolean isDigitalUnix(){\t\treturn OS.indexOf(\"digital\")>=0&&OS.indexOf(\"unix\")>0;\t}\t\tpublic static boolean isNetWare(){\t\treturn OS.indexOf(\"netware\")>=0;\t}\t\tpublic static boolean isOSF1(){\t\treturn OS.indexOf(\"osf1\")>=0;\t}\t\tpublic static boolean isOpenVMS(){\t\treturn OS.indexOf(\"openvms\")>=0;\t}\t\t/**\t * 获取操作系统名字\t * @return 操作系统名\t */\tpublic static EPlatform getOSname(){\t\tif(isAix()){\t\t\t_instance.platform = EPlatform.AIX;\t\t}else if (isDigitalUnix()) {\t\t\t_instance.platform = EPlatform.Digital_Unix;\t\t}else if (isFreeBSD()) {\t\t\t_instance.platform = EPlatform.FreeBSD;\t\t}else if (isHPUX()) {\t\t\t_instance.platform = EPlatform.HP_UX;\t\t}else if (isIrix()) {\t\t\t_instance.platform = EPlatform.Irix;\t\t}else if (isLinux()) {\t\t\t_instance.platform = EPlatform.Linux;\t\t}else if (isMacOS()) {\t\t\t_instance.platform = EPlatform.Mac_OS;\t\t}else if (isMacOSX()) {\t\t\t_instance.platform = EPlatform.Mac_OS_X;\t\t}else if (isMPEiX()) {\t\t\t_instance.platform = EPlatform.MPEiX;\t\t}else if (isNetWare()) {\t\t\t_instance.platform = EPlatform.NetWare_411;\t\t}else if (isOpenVMS()) {\t\t\t_instance.platform = EPlatform.OpenVMS;\t\t}else if (isOS2()) {\t\t\t_instance.platform = EPlatform.OS2;\t\t}else if (isOS390()) {\t\t\t_instance.platform = EPlatform.OS390;\t\t}else if (isOSF1()) {\t\t\t_instance.platform = EPlatform.OSF1;\t\t}else if (isSolaris()) {\t\t\t_instance.platform = EPlatform.Solaris;\t\t}else if (isSunOS()) {\t\t\t_instance.platform = EPlatform.SunOS;\t\t}else if (isWindows()) {\t\t\t_instance.platform = EPlatform.Windows;\t\t}else{\t\t\t_instance.platform = EPlatform.Others;\t\t}\t\treturn _instance.platform;\t}\t/**\t * @param args\t */\tpublic static void main(String[] args) {\t\tSystem.out.println(OSinfo.getOSname());\t}} 我使用的Windows 7 识别出来：Windows ，如果大家使用别的操作系统，希望能把操作系统和结果在这里留言写下来。 如果结果错误，你可以使用下面的代码获取你的操作系统信息： class WhatOS {  public static void main( String args[] )   {    System.out.println( System.getProperty(\"os.name\") );    System.out.println( System.getProperty(\"os.version\") );    System.out.println( System.getProperty(\"os.arch\") );  }}","title":"Java 判断操作系统类型(适用于各种操作系统)"},{"content":"构造函数 bitset<n> b;  b有n位，每位都为0.参数n可以为一个表达式. 如bitset<5> b0;则\"b0\"为\"00000\";   bitset<n> b(unsigned long u);  b有n位,并用u赋值;如果u超过n位,则顶端被截除 如:bitset<5>b0(5);则\"b0\"为\"00101\";   bitset<n> b(string s);  b是string对象s中含有的位串的副本 string bitval ( \"10011\" ); bitset<5> b0 ( bitval4 ); 则\"b0\"为\"10011\"; bitset<n> b(s, pos);  b是s中从位置pos开始位的副本,前面的多余位自动填充0; string bitval (\"01011010\"); bitset<10> b0 ( bitval5, 3 ); 则\"b0\" 为 \"0000011010\";   bitset<n> b(s, pos, num);  b是s中从位置pos开始的num个位的副本,如果num<n,则前面的空位自动填充0; string bitval (\"11110011011\"); bitset<6> b0 ( bitval5, 3, 6 ); 则\"b0\" 为 \"100110\"; 其他函数 os << b  把b中的位集输出到os流 os >>b 输入到b中,如\"cin>>b\",如果输入的不是0或1的字符,只取该字符前面的二进制位. bool any( )  是否存在置为1的二进制位？和none()相反   bool none( ) 是否不存在置为1的二进制位,即全部为0？和any()相反.   size_t count( ) 二进制位为1的个数.   size_t size( )  二进制位的个数 flip()  把所有二进制位逐位取反   flip(size_t pos)  把在pos处的二进制位取反   bool operator[](   size_type _Pos )  获取在pos处的二进制位   set()  把所有二进制位都置为1   set(pos)  把在pos处的二进制位置为1   reset()  把所有二进制位都置为0   reset(pos)  把在pos处的二进制位置为0 test(size_t pos) 在pos处的二进制位是否为1？ unsigned long to_ulong( )  用同样的二进制位返回一个unsigned long值 string to_string () 返回对应的字符串. 例子 void test_bitset_constructor(){\t// 构造函数1: bitset<n> b\tstd::bitset<10> bs1;\t// 构造函数2: bitset<n> b(unsigned long u)\tstd::bitset<5> bs2(10);\t// 构造函数3: bitset<n> b(string s)\tstd::bitset<5> bs3(\"10100\");\t// 构造函数4: 复制构造\tstd::bitset<5> bs4(bs3);\t// 构造函数5: bitset<n> b(s, pos)\tstd::string str = \"10100110\";\tstd::bitset<9> bs5(str, 2);\t\t// 000100110\t// 构造函数6: bitset<n> b(s, pos, num);\tstd::bitset<9> bs6(str, 2, 4);\t// 000001001}void test_bitset_func(){    std::string str = \"10100110\";    std::bitset<10> bs1;    std::bitset<5> bs2(10);    std::bitset<5> bs3(\"10100\");    std::bitset<5> bs4(bs3);    std::bitset<9> bs5(str, 2);        // 000100110    std::bitset<9> bs6(str, 2, 4);    // 000001001    // any()是否存在置为1的二进制位    assert(bs1.any() == 0);    assert(bs2.any() == 1);    // none()是否不存在置为1的二进制位, 即全部为0    assert(bs1.none() == 1);    assert(bs2.none() == 0);    // size()二进制位的个数    assert(bs5.size() == 9);    // count()二进制位为1的个数    assert(bs5.count() == 3);    // 访问其中元素, 低位为下标的低位    assert(bs3[0] == 0);    assert(bs3[1] == 0);    assert(bs3[2] == 1);    assert(bs3[3] == 0);    assert(bs3[4] == 1);    // ...}","title":"【STL】bitset示例"},{"content":"jQuery插件开发全解析  jQuery插件的开发包括两种： 一种是类级别的插件开发，即给jQuery添加新的全局函数，相当于给jQuery类本身添加方法。jQuery 的全局函数就是属于jQuery命名空间的函数，另一种是对象级别的插件开发，即给jQuery对象添加方法。下 面就两种函数的开发做详细的说明。 1、类级别的插件开发 类级别的插件开发最直接的理解就是给jQuery类添加类方法，可以理解为添加静态方法。典型的例子就 是$.AJAX()这个函数，将函数定义于jQuery的命名空间中。关于类级别的插件开发可以采用如下几种形式进 行扩展： 1.1 添加一个新的全局函数 添加一个全局函数，我们只需如下定义： jQuery.foo = function() { alert('This is a test. This is only a test.'); }; 调用的时候可以这样写： jQuery.foo(); 或 $.foo(); 1.2 增加多个全局函数 添加多个全局函数，可采用如下定义： jQuery.foo = function() { alert('This is a test. This is only a test.'); }; jQuery.bar = function(param) { alert('This function takes a parameter, which is \"' + param + '\".'); }; 调用时和一个函数的一样的:jQuery.foo();jQuery.bar();或者$.foo();$.bar('bar'); 1.3 使用jQuery.extend(object); jQuery.extend({ foo: function() { alert('This is a test. This is only a test.'); }, bar: function(param) { alert('This function takes a parameter, which is \"' + param +'\".'); } }); 1.4 使用命名空间 虽然在jQuery命名空间中，我们禁止使用了大量的javaScript函数名和变量名。但是仍然不可避免某 些函数或变量名将于其他jQuery插件冲突，因此我们习惯将一些方法封装到另一个自定义的命名空间。 jQuery.myPlugin = { foo:function() { alert('This is a test. This is only a test.'); }, bar:function(param) { alert('This function takes a parameter, which is \"' + param + '\".'); } }; 采用命名空间的函数仍然是全局函数，调用时采用的方法： $.myPlugin.foo(); $.myPlugin.bar('baz'); 2通过这个技巧（使用独立的插件名），我们可以避免命名空间内函数的冲突。 2、对象级别的插件开发 对象级别的插件开发需要如下的两种形式：、 形式1： (function($){ $.fn.extend({ pluginName:function(opt,callback){ // Our plugin implementation code goes here. } }) })(jQuery); 形式2： (function($) { $.fn.pluginName = function() { // Our plugin implementation code goes here. }; })(jQuery); 上面定义了一个jQuery函数,形参是$，函数定义完成之后,把jQuery这个实参传递进去.立即调用执行。 这样的好处是,我们在写jQuery插件时,也可以使用$这个别名,而不会与prototype引起冲突. 2.1 在JQuery名称空间下申明一个名字 这是一个单一插件的脚本。如果你的脚本中包含多个插件，或者互逆的插件（例如： $.fn.doSomething() 和 $.fn.undoSomething()），那么你需要声明多个函数名字。但是，通常当我们编写一个插件时，力求仅 使用一个名字来包含它的所有内容。我们的示例插件命名为“highlight“ $.fn.hilight = function() { // Our plugin implementation code goes here. }; 我们的插件通过这样被调用： $('#myDiv').hilight(); 但是如果我们需要分解我们的实现代码为多个函数该怎么办？有很多原因：设计上的需要；这样做更容易 或更易读的实现；而且这样更符合面向对象。这真是一个麻烦事，把功能实现分解成多个函数而不增加多余的 命名空间。出于认识到和利用函数是javascript中最基本的类对象，我们可以这样做。就像其他对象一样， 函数可以被指定为属性。因此我们已经声明“hilight”为jQuery的属性对象，任何其他的属性或者函数我们 需要暴露出来的，都可以在\"hilight\" 函数中被声明属性。稍后继续。 2.2 接受options参数以控制插件的行为 让我们为我们的插件添加功能指定前景色和背景色的功能。我们也许会让选项像一个options对象传递给 插件函数。例如： // plugin definition $.fn.hilight = function(options) { var defaults = { foreground: 'red', background: 'yellow' }; // Extend our default options with those provided. var opts = $.extend(defaults, options); // Our plugin implementation code goes here. }; 我们的插件可以这样被调用： $('#myDiv').hilight({ foreground: 'blue' }); 2.3 暴露插件的默认设置 我们应该对上面代码的一种改进是暴露插件的默认设置。这对于让插件的使用者更容易用较少的代码覆盖 和修改插件。接下来我们开始利用函数对象。 // plugin definition $.fn.hilight = function(options) { // Extend our default options with those provided. // Note that the first arg to extend is an empty object - // this is to keep from overriding our \"defaults\" object. var opts = $.extend({}, $.fn.hilight.defaults, options); // Our plugin implementation code goes here. }; // plugin defaults - added as a property on our plugin function $.fn.hilight.defaults = { foreground: 'red', background: 'yellow' }; 现在使用者可以包含像这样的一行在他们的脚本里： //这个只需要调用一次，且不一定要在ready块中调用 $.fn.hilight.defaults.foreground = 'blue'; 接下来我们可以像这样使用插件的方法，结果它设置蓝色的前景色： $('#myDiv').hilight(); 如你所见，我们允许使用者写一行代码在插件的默认前景色。而且使用者仍然在需要的时候可以有选择的 覆盖这些新的默认值： // 覆盖插件缺省的背景颜色 $.fn.hilight.defaults.foreground = 'blue'; // ... // 使用一个新的缺省设置调用插件 $('.hilightDiv').hilight(); // ... // 通过传递配置参数给插件方法来覆盖缺省设置 $('#green').hilight({ foreground: 'green' }); 2.4 适当的暴露一些函数 这段将会一步一步对前面那段代码通过有意思的方法扩展你的插件（同时让其他人扩展你的插件）。例如， 我们插件的实现里面可以定义一个名叫\"format\"的函数来格式化高亮文本。我们的插件现在看起来像这样， 默认的format方法的实现部分在hiligth函数下面。 // plugin definition $.fn.hilight = function(options) { // iterate and reformat each matched element return this.each(function() { var $this = $(this); // ... var markup = $this.html(); // call our format function markup = $.fn.hilight.format(markup); $this.html(markup); }); }; // define our format function $.fn.hilight.format = function(txt) { return '<strong>' + txt + '<\/strong>'; }; 我们很容易的支持options对象中的其他的属性通过允许一个回调函数来覆盖默认的设置。这是另外一个 出色的方法来修改你的插件。这里展示的技巧是进一步有效的暴露format函数进而让他能被重新定义。通过这 技巧，是其他人能够传递他们自己设置来覆盖你的插件，换句话说，这样其他人也能够为你的插件写插件。 考虑到这个篇文章中我们建立的无用的插件，你也许想知道究竟什么时候这些会有用。一个真实的例子是Cycle 插件.这个Cycle插件是一个滑动显示插件，他能支持许多内部变换作用到滚动，滑动，渐变消失等。但是实际 上，没有办法定义也许会应用到滑动变化上每种类型的效果。那是这种扩展性有用的地方。 Cycle插件对使用 者暴露\"transitions\"对象，使他们添加自己变换定义。插件中定义就像这样： $.fn.cycle.transitions = { // ... }; 这个技巧使其他人能定义和传递变换设置到Cycle插件。 2.5 保持私有函数的私有性 这种技巧暴露你插件一部分来被覆盖是非常强大的。但是你需要仔细思考你实现中暴露的部分。一但被暴 露，你需要在头脑中保持任何对于参数或者语义的改动也许会破坏向后的兼容性。一个通理是，如果你不能肯 定是否暴露特定的函数，那么你也许不需要那样做。 那么我们怎么定义更多的函数而不搅乱命名空间也不暴露实现呢？这就是闭包的功能。为了演示，我们将 会添加另外一个“debug”函数到我们的插件中。这个 debug函数将为输出被选中的元素格式到firebug控制 台。为了创建一个闭包，我们将包装整个插件定义在一个函数中。 (function($) { // plugin definition $.fn.hilight = function(options) { debug(this); // ... }; // private function for debugging function debug($obj) { if (window.console && window.console.log) window.console.log('hilight selection count: ' + $obj.size()); }; // ... })(jQuery); 我们的“debug”方法不能从外部闭包进入,因此对于我们的实现是私有的。 2.6 支持Metadata插件 在你正在写的插件的基础上，添加对Metadata插件的支持能使他更强大。个人来说，我喜欢这个 Metadata插件，因为它让你使用不多的\"markup”覆盖插件的选项（这非常有用当创建例子时）。而且支持它 非常简单。更新：注释中有一点优化建议。 $.fn.hilight = function(options) { // ... // build main options before element iteration var opts = $.extend({}, $.fn.hilight.defaults, options); return this.each(function() { var $this = $(this); // build element specific options var o = $.meta ? $.extend({}, opts, $this.data()) : opts; //... 这些变动行做了一些事情：它是测试Metadata插件是否被安装 如果它被安装了，它能扩展我们的options对象通过抽取元数据 这行作为最后一个参数添加到JQuery.extend，那么它将会覆盖任何其它选项设置。现在我们能从\"markup” 处驱动行为,如果我们选择了“markup”： <!-- markup --> <div class=\"hilight { background: 'red', foreground: 'white' }\"> Have a nice day! <\/div> <div class=\"hilight { foreground: 'orange' }\"> Have a nice day! <\/div> <div class=\"hilight { background: 'green' }\"> Have a nice day! <\/div> 现在我们能高亮哪些div仅使用一行脚本： $('.hilight').hilight(); 2.7 整合 下面使我们的例子完成后的代码： // 创建一个闭包 (function($) { // 插件的定义 $.fn.hilight = function(options) { debug(this); // build main options before element iteration var opts = $.extend({}, $.fn.hilight.defaults, options); // iterate and reformat each matched element return this.each(function() { $this = $(this); // build element specific options var o = $.meta ? $.extend({}, opts, $this.data()) : opts; // update element styles $this.css({ backgroundColor: o.background, color: o.foreground }); var markup = $this.html(); // call our format function markup = $.fn.hilight.format(markup); $this.html(markup); }); 6 }; // 私有函数：debugging function debug($obj) { if (window.console && window.console.log) window.console.log('hilight selection count: ' + $obj.size()); }; // 定义暴露format函数 $.fn.hilight.format = function(txt) { return '<strong>' + txt + '<\/strong>'; }; // 插件的defaults $.fn.hilight.defaults = { foreground: 'red', background: 'yellow' }; // 闭包结束 })(jQuery); 这段设计已经让我创建了强大符合规范的插件。我希望它能让你也能做到。 3、总结 jQuery为开发插件提拱了两个方法，分别是： jQuery.fn.extend(object); 给jQuery对象添加方法。 jQuery.extend(object); 为扩展jQuery类本身.为类添加新的方法。 3.1 jQuery.fn.extend(object); fn 是什么东西呢。查看jQuery代码，就不难发现。 jQuery.fn = jQuery.prototype = { init: function( selector, context ) {//.... //...... }; 原来 jQuery.fn = jQuery.prototype.对prototype肯定不会陌生啦。虽然 javascript 没有 明确的类的概念，但是用类来理解它，会更方便。jQuery便是一个封装得非常好的类，比如我们用语句 $(\"#btn1\") 会生成一个 jQuery类的实例。 jQuery.fn.extend(object); 对jQuery.prototype进得扩展，就是为jQuery类添加“成员函数”。 jQuery类的实例可以使用这个“成员函数”。 比如我们要开发一个插件，做一个特殊的编辑框，当它被点击时，便alert 当前编辑框里的内容。可以这 么做： $.fn.extend({ alertWhileClick:function(){ $(this).click(function(){ alert($(this).val()); }); } }); $(\"#input1\").alertWhileClick(); //页面上为：<input id=\"input1\" type=\"text\"/> $(\"#input1\") 为一个jQuery实例，当它调用成员方法 alertWhileClick后，便实现了扩展，每次 被点击时它会先弹出目前编辑里的内容。 3.2 jQuery.extend(object); 为jQuery类添加添加类方法，可以理解为添加静态方法。如： $.extend({ 7 add:function(a,b){return a+b;} }); 便为 jQuery 添加一个为 add 的 “静态方法”，之后便可以在引入 jQuery 的地方，使用这个方 法了，$.add(3,4); //return ","title":"Jquery系列---Jquery插件开发"},{"content":"初学者可能会想反射是什么，有什么作用。那我就以一个简单的小需求开始。现在有3个类，A,B,C. 现在我想要一个方法，根据输入的字符串，获取相应的实例对象，即当我给这个对象传入“A”的时候，我要获取一个A实例，传入“B”的时候获取一个B实例，有人说用if, 那么如果有1000个类，就用1000个if或者case么，而且，如果不事先知道有多少种情况呢？ Public Object (string type){　　……} 要解决这个问题，我们先从基础知识开始学习。 在Java程序执行的时候，在这个进程中，内存分为代码区，静态存储区，堆内存和栈内存。一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。堆内存用于存放由new创建的对象和数组。在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。静态存储区，主要是用来存储字符串和类的静态成员变量等。现在说到了对于反射来讲很重要的一块内存，代码区（CodeSegment）。代码区主要存放的是加载到内存的二进制文件。注意，这不是对象实例，而是那些一个个还没有被唤醒的.class文件。 从面相对象的角度来讲，这些文件都是一类，都是Class类。至于如何理解.class文件对象和实例对象，我是这样理解的。在代码区的.class对象就像是下载视频的种子，虽然它并不是一个实实在在的视频，但是必须要通过这个种子才能获得视频文件，而且一个种子可以使用多次。相对应的，在程序中.class文件对象，要通过这个对象来获取需要的对象，而且能多次使用。 在Java虚拟机中，有一个很重要的搬运工的角色，就是ClassLoader，这是一大类Class，它们的作用就是把相应的用到的二进制的Class文件加载到内存中。注意，这里有一个动态的加载机制，不是说，在程序启动的时候，如果ClassPath下有100个.class文件，就会把所有的二进制码一下子加载到内存中，而是刚刚开始的时候JVM使用ClassLoader把最初的几个.class二进制码Load到内存中，之后的是用到的时候才加载，慢慢的会有更多的加载到存中。当然也可以通过代码显示的要求立即把相应的二进制类代码加载到内存，如JDBC驱动的加载 Class.forName(\"com.mysql.jdbc.Driver\") 在这里有一个相关的知识点就是static静态语句块的问题。有人说，静态语句块是第一次new对象的时候执行，这种说法是不准确的，确切的说，是加载到内存中的时候执行。一般来讲我们自己写的类，是用的时候才加载到内存，而我们用的方式，一般都是new一个对象，一般不会强制显示的去加载，所以，大家就以为是第一次实例化的时候执行。如果我们使用Class.Forname显示的把它load到内存，而并不new对象，可以发现，此时静态代码块也执行了。 现在解决最初提出的那个问题，只需要一句代码 String type = “A”; Object o = Class.forName(type).newInstance(); 下面是有关反射使用的一些常用的方法，包括获取成员方法等。从面相对象的角度看，类中的一个个属性或者方法都是对象，要让其执行，调用invoke就可以了。","title":"反射机制简单解析"},{"content":"好久没有更新博客了，今天临时起意，将以前写的示例代码整理了一下，暂且发布一篇，希望对大家有用！ 代码一：点击时显示坐标，鼠标移动时不显示。 #include <cv.h>#include <highgui.h>#include <stdio.h>IplImage* src=0;void on_mouse( int event, int x, int y, int flags, void* ustc){\tCvFont font;\tcvInitFont(&font, CV_FONT_HERSHEY_SIMPLEX, 0.5, 0.5, 0, 1, CV_AA);\t\t\tif( event == CV_EVENT_LBUTTONDOWN )\t{\t\tCvPoint pt = cvPoint(x,y);\t\tchar temp[16];\t\tsprintf(temp,\"(%d,%d)\",pt.x,pt.y);\t\tcvPutText(src,temp, pt, &font, cvScalar(255, 255, 255, 0));\t\tcvCircle( src, pt, 2,cvScalar(255,0,0,0) ,CV_FILLED, CV_AA, 0 );\t\tcvShowImage( \"src\", src );\t} }int main(){\tsrc=cvLoadImage(\"lena.jpg\",1);\tcvNamedWindow(\"src\",1);\tcvSetMouseCallback( \"src\", on_mouse, 0 );\t\tcvShowImage(\"src\",src);\tcvWaitKey(0); \tcvDestroyAllWindows();\tcvReleaseImage(&src);\treturn 0;} 代码二：鼠标移动时显示坐标，点击时不显示坐标 #include <cv.h>#include <highgui.h>#include <stdio.h>IplImage* src=0;IplImage* dst=0;void on_mouse( int event, int x, int y, int flags, void* ustc){\tCvFont font;\tcvInitFont(&font, CV_FONT_HERSHEY_SIMPLEX, 0.5, 0.5, 0, 1, CV_AA);\t\t\tif( event == CV_EVENT_MOUSEMOVE )\t{\t\tcvCopy(dst,src);\t\tCvPoint pt = cvPoint(x,y);\t\tchar temp[16];\t\tsprintf(temp,\"(%d,%d)\",pt.x,pt.y);\t\tcvPutText(src,temp, pt, &font, cvScalar(255, 255, 255, 0));\t\tcvCircle( src, pt, 2,cvScalar(255,0,0,0) ,CV_FILLED, CV_AA, 0 );\t\tcvShowImage( \"src\", src );\t} }int main(){\tsrc=cvLoadImage(\"lena.jpg\",1);\tdst=cvCloneImage(src);\tcvNamedWindow(\"src\",1);\tcvSetMouseCallback( \"src\", on_mouse, 0 );\t\tcvShowImage(\"src\",src);\tcvWaitKey(0); \tcvDestroyAllWindows();\tcvReleaseImage(&src);\tcvReleaseImage(&dst);\treturn 0;} 代码三：鼠标移动和点击时均显示坐标 #include <cv.h>#include <highgui.h>#include <stdio.h>IplImage* src=0;IplImage* dst=0;void on_mouse( int event, int x, int y, int flags, void* ustc){\tchar temp[16];\tCvPoint pt;\tCvFont font;\tcvInitFont(&font, CV_FONT_HERSHEY_SIMPLEX, 0.5, 0.5, 0, 1, CV_AA);\t\t\tif( event == CV_EVENT_MOUSEMOVE )\t{\t\tcvCopy(dst,src);\t\t\t\tsprintf(temp,\"(%d,%d)\",x,y);\t\tpt = cvPoint(x,y);\t\tcvPutText(src,temp, pt, &font, cvScalar(255, 255, 255, 0));\t\tcvCircle( src, pt, 2,cvScalar(255,0,0,0) ,CV_FILLED, CV_AA, 0 );\t\tcvShowImage( \"src\", src );\t} \telse if( event == CV_EVENT_LBUTTONDOWN )\t{\t\t//cvCopy(dst,src);\t\t\t\t\tsprintf(temp,\"(%d,%d)\",x,y);\t\tpt = cvPoint(x,y);\t\tcvPutText(src,temp, pt, &font, cvScalar(255, 255, 255, 0));\t\tcvCircle( src, pt, 2,cvScalar(255,0,0,0) ,CV_FILLED, CV_AA, 0 );\t\tcvCopy(src,dst);\t\tcvShowImage( \"src\", src );\t} }int main(){\tsrc=cvLoadImage(\"lena.jpg\",1);\tdst=cvCloneImage(src);\tcvNamedWindow(\"src\",1);\tcvSetMouseCallback( \"src\", on_mouse, 0 );\t\tcvShowImage(\"src\",src);\tcvWaitKey(0); \tcvDestroyAllWindows();\tcvReleaseImage(&src);\tcvReleaseImage(&dst);\treturn 0;} 代码四，上面的代码在边界处处理的不好，坐标值显示的不完全，下面是对代码三的改进。下面的代码还将点约束在图像的几何区域范围内。 #include <cv.h>#include <highgui.h>#include <stdio.h>#define max(a,b)            (((a) > (b)) ? (a) : (b))#define min(a,b)            (((a) < (b)) ? (a) : (b))//注意参数是有符号短整型，该函数的作用是使i限定为[a,b]区间内int bound(short i,short a,short b){\treturn min(max(i,min(a,b)),max(a,b));}IplImage* src=0;IplImage* dst=0;void on_mouse( int event, int x, int y, int flags, void* ustc){\tchar temp[16];\tCvPoint pt;\tCvFont font;\tcvInitFont(&font, CV_FONT_HERSHEY_SIMPLEX, 0.5, 0.5, 0, 1, CV_AA);\tCvPoint tmp_pt = {-1,-1};\tCvSize text_size;\tint baseline;\tif( event == CV_EVENT_MOUSEMOVE )\t{\t\tcvCopy(dst,src);\t\t\tx=bound(x,0,src->width-1);\t\ty=bound(y,0,src->height-1);\t\tpt = cvPoint(x,y);\t\tcvCircle( src, pt, 2,cvScalar(255,0,0,0) ,CV_FILLED, CV_AA, 0 );\t\tsprintf(temp,\"(%d,%d)\",x,y);\t\tcvGetTextSize(temp,&font,&text_size,&baseline);\t\ttmp_pt.x = bound(pt.x,0,src->width-text_size.width);\t\ttmp_pt.y = bound(pt.y,text_size.height+baseline,src->height-1-baseline);\t\tcvPutText(src,temp, tmp_pt, &font, cvScalar(255, 255, 255, 0));\t\tcvShowImage( \"src\", src );\t} \telse if( event == CV_EVENT_LBUTTONDOWN )\t{\t\t//cvCopy(dst,src);\t\tpt = cvPoint(x,y);\t\tcvCircle( src, pt, 2,cvScalar(255,0,0,0) ,CV_FILLED, CV_AA, 0 );\t\tsprintf(temp,\"(%d,%d)\",x,y);\t\tcvGetTextSize(temp,&font,&text_size,&baseline);\t\ttmp_pt.x = bound(pt.x,0,src->width-text_size.width);\t\ttmp_pt.y = bound(pt.y,text_size.height+baseline,src->height-1-baseline);\t\tcvPutText(src,temp, tmp_pt, &font, cvScalar(255, 255, 255, 0));\t\tcvCopy(src,dst);\t\tcvShowImage( \"src\", src );\t} }int main(){\tsrc=cvLoadImage(\"lena.jpg\",1);\tdst=cvCloneImage(src);\tcvNamedWindow(\"src\",1);\tcvSetMouseCallback( \"src\", on_mouse, 0 );\t\tcvShowImage(\"src\",src);\tcvWaitKey(0); \tcvDestroyAllWindows();\tcvReleaseImage(&src);\tcvReleaseImage(&dst);\treturn 0;} 代码五，上面的代码不能撤销选定的坐标，下面的代码对此进行了改进，右击撤销最近选择的点，并用互补的颜色表示选择的点和撤销选定的点。除此之外还将选择的坐标输出到文件。在点的坐标前还有一个数表示点的选定次序。 #include <cv.h>#include <highgui.h>#include <stdio.h>#include <vector>#include <fstream>using namespace std;#define max(a,b)            (((a) > (b)) ? (a) : (b))#define min(a,b)            (((a) < (b)) ? (a) : (b))//注意参数是有符号短整型，该函数的作用是使i限定为[a,b]区间内int bound(short i,short a,short b){\treturn min(max(i,min(a,b)),max(a,b));}CvScalar getInverseColor(CvScalar c){\tCvScalar s;\tfor(int i=0;i<=2;++i)\t{\t\ts.val[i]=255-c.val[i];\t}\treturn s;}IplImage* src=0;IplImage* dst=0;int n=0;vector<CvPoint> points;void on_mouse( int event, int x, int y, int flags, void* ustc){\tCvPoint pt;\tCvPoint tmp_pt = {-1,-1};\tCvFont font;\tcvInitFont(&font, CV_FONT_HERSHEY_SIMPLEX, 0.4, 0.4, 0, 1, CV_AA);\tchar temp[16];\tCvSize text_size;\tint baseline;\tCvScalar clrPoint=cvScalar(255,0,0,0);\tCvScalar clrText=cvScalar(255, 255, 255, 0);\tif( event == CV_EVENT_MOUSEMOVE )\t{\t\tcvCopy(dst,src);\t\t\tx=bound(x,0,src->width-1);\t\ty=bound(y,0,src->height-1);\t\tpt = cvPoint(x,y);\t\tcvCircle( src, pt, 2,clrPoint ,CV_FILLED, CV_AA, 0 );\t\tsprintf(temp,\"%d (%d,%d)\",n+1,x,y);\t\tcvGetTextSize(temp,&font,&text_size,&baseline);\t\ttmp_pt.x = bound(pt.x,0,src->width-text_size.width);\t\ttmp_pt.y = bound(pt.y,text_size.height+baseline,src->height-1-baseline);\t\tcvPutText(src,temp, tmp_pt, &font, clrText);\t\tcvShowImage( \"src\", src );\t} \telse if( event == CV_EVENT_LBUTTONDOWN)\t{\t\tpt = cvPoint(x,y);\t\tpoints.push_back(pt); n++;\t\tcvCircle( src, pt, 2, clrPoint ,CV_FILLED, CV_AA, 0 );\t\tsprintf(temp,\"%d (%d,%d)\",n,x,y);\t\tcvGetTextSize(temp,&font,&text_size,&baseline);\t\ttmp_pt.x = bound(pt.x,0,src->width-text_size.width);\t\ttmp_pt.y = bound(pt.y,text_size.height+baseline,src->height-1-baseline);\t\tcvPutText(src,temp, tmp_pt, &font, clrText);\t\tcvCopy(src,dst);\t\tcvShowImage( \"src\", src );\t} \telse if( event == CV_EVENT_RBUTTONDOWN )\t{\t\tif(!points.empty())\t\t{\t\t\tcvCopy(dst,src);\t\t\tpt=points.back();\t\t\tpoints.pop_back(); \t\t\tcvCircle( src, pt, 2, getInverseColor(clrPoint),CV_FILLED, CV_AA, 0 );\t\t\tsprintf(temp,\"%d (%d,%d)\",n,pt.x,pt.y); --n;\t\t\tcvGetTextSize(temp,&font,&text_size,&baseline);\t\t\ttmp_pt.x = bound(pt.x,0,src->width-text_size.width);\t\t\ttmp_pt.y = bound(pt.y,text_size.height+baseline,src->height-1-baseline);\t\t\tcvPutText(src,temp, tmp_pt, &font, getInverseColor(clrText));\t\t\tcvCopy(src,dst);\t\t\tcvShowImage( \"src\", src );\t\t}\t}}int main(){\tsrc=cvLoadImage(\"lena.jpg\",1);\tdst=cvCloneImage(src);\tcvNamedWindow(\"src\",1);\tcvSetMouseCallback( \"src\", on_mouse, 0 );\t\tcvShowImage(\"src\",src);\tcvWaitKey(0); \tcvDestroyAllWindows();\tcvReleaseImage(&src);\tcvReleaseImage(&dst);\tofstream file(\"sample.txt\");\tif(!file)\t{\t\tcout << \"open file error!\";\t\treturn 1;\t}\tvector<CvPoint>::iterator it=points.begin();\tfor(;it!=points.end();++it)\t{\t\tfile<< it->x<<','<<it->y<<endl;\t}\tfile<<endl;\tfile.close();\treturn 0;} 其的演示如下： sample.txt中的内容如下： 319,351382,284275,292194,249357,210424,260350,251305,238274,189227,140224,375","title":"OpenCV之利用鼠标获取坐标"},{"content":"在讲之前，一些基本知识是应该具备的： 1.如果一个类中没有定义构造器，编译器在编译时会自动加上默认无参构造器: public ClassName {} 2. this 和 super 的区别。 3.每个类直接或间接是Object的子类，Object只有一个无参构造方法。 4.编译器会在每个构造方法的第一行隐式添加父类的默认无参构造器，即添加super()。 新手容易犯的错误: class Employee extends Object {\tpublic Employee(int id) {\t}}class Teacher extends Employee {\t\tpublic Teacher() {\t}} 以上代码会产生编译错误： Implicit super constructor Employee() is undefined. Must explicitly invoke another constructor因为父类定义了一个带参数的构造器，因此编译器不会添加默认无参构造方法，但是因为在子类的构造器中没有显式调用父类的某个构造方法，因此编译器会自动添加super()方法， 但是父类中不存在默认无参构造方法，因此会提示默认无参构造方法未定义错误。 修改后的代码: class Employee {\tpublic Employee(int id) {\t}}class Teacher extends Employee {\t\tpublic Teacher() {\t\tsuper(10);\t}} 这样，在子类的构造器中显式调用了父类的某个构造器，所以编译器不会自动添加super()方法。 构造器的访问修饰符: 一般可以用public,protected,default和private修饰，但是对于private，子类是无法调用该类构造器的。 多层次调用父类构造方法： 假设我们有这样一个层次结构: Object->Employee->Teacher->Professor class Employee {\tpublic Employee() {\t\tSystem.out.println(\"Employee constructor called\");\t}}class Teacher extends Employee {\t\tpublic Teacher() {\t\tSystem.out.println(\"Teacher constructor called\");\t}}class Professor extends Teacher {\tpublic Professor() {\t\tSystem.out.println(\"Professor constructor called\");\t}}public class Test {\tpublic static void main(String args[]) {\t\tEmployee p = new Professor();\t}} 打印结果: Employee constructor calledTeacher constructor calledProfessor constructor called 在创建Professor对象时(new Professor())，首先会找到该类的无参构造方法，然后首先调用super()方法，调用Teacher类的无参构造方法，接着再调用Employee的无参构造方法，最后再调用Object的无参构造方法。最后再打印出信息。","title":"Java中子类和父类之间的调用关系"},{"content":"算法设计例题：主元素（随机算法） memory limit: 5000KB    time limit: 1000MS accept: 1    submit: 5 Description 设T[1:n]是一个含有n个元素的数组（集合）。当 | {i | T[i]=x} | > n/2 时，称元素x是数组T的主元素。 Input 第一行是一个正整数T，表示测试用例的个数。每个测试用例占两行，第一行是一个整数N（ 0 < N < 100000 ），表示集合元素的个数，第二行是N个整数。 Output 为每个测试用例输出一行结果：如果该集合有主元素，输出该主元素，如果没有主元素，则输出 no 。 Sample Input 2 10 3 5 7 3 9 3 3 1 3 3 10 3 3 3 3 1 2 4 5 6 7 Sample Output 3 no Author John 解决方法： #include<stdio.h> #include<cstdlib> #include<time.h> #define N 200000 int x;  int a[N];//这个不能放在main()函数中，局部变量的数组不能开太大，不然提交的时候会出现\"Runtime Error!\" bool b(int a[],int n) { int i=rand()%n+1;//产生从1~n之间的整数 x=a[i]; int count=0; for(int j=1;j<=n;j++) if(a[j]==x) count++; return (count>n/2); } bool majority(int a[],int n) { if(b(a,n))       return true; else  return b(a,n); } int main() {   srand((int)time(0));   int n,k=0,testNum;   scanf(\"%d\",&testNum);   while(k!=testNum)   {   scanf(\"%d\",&n);  for(int i=1;i<=n;i++)  scanf(\"%d\",&a[i]);  if(majority(a,n))  printf(\"%d\\n\",x);  else  printf(\"no\\n\");  k++;   } return 0; } //特别注意的是，当换成c++的输入输出方式提交时会出现\"Time Limit Exceed\"的提示，当改成C的输入输出方式时就可以通过了，由此可见C的输入输出方式比C++的节省时间","title":"主元素问题（随机算法）"},{"content":"super关键字 如果子类中定义的成员变量和父类 中的成员变量同名时，子类就隐藏了从父类继承的成员变量。当子类中定义了一个方法，并且这个方法的名字，返回类型，参数个数和父类的某个方法完全相同，子类从父类继承的方法将被隐藏。如果在子类中想要使用被子类隐藏的成员变量或方法就可以使用关键字super class student { int number;String name; student()  //使用构造方法{ }student(int number,String name){ this.number=number; //使用this关键字调用成员变量 this.name=name;System.out.println(\"I am \"+name+\"my number is \"+number);}}xiongyao@xiongyao-Lenovo:~/java编程$ javac example7.javaclass univer_student extends student{ boolean 婚否; univer_student(int number,String name,boolean b){ super(number,name);婚否=b;System.out.println(\"婚否=\"+婚否);}}public class example7{public static void main(String args[]){univer_student zhang=new univer_student(9901,\"熊尧\",false); }}xiongyao@xiongyao-Lenovo:~/java编程$ javac example7.java xiongyao@xiongyao-Lenovo:~/java编程$ java example7 I am 熊尧my number is 9901 婚否=false","title":"java书中小例子5"},{"content":"//============================================================================ // Name        : 11.cpp // Author      : zhaoming // Version     : // Copyright   : copyright to zhaoming // Description : Hello World in C++, Ansi-style //============================================================================ #include <iostream> using namespace std; class INTSET;  //不完整声明或前向声明 class REALSET{ float *elems; int card,maxcard; public: REALSET(INTSET &s); int sum(REALSET s); ~REALSET(){ cout <<\"aaaa\"; delete elems; } }; class INTSET{ int *elems,card,maxcard; //注意：不能在一个类的内部定义另一个类的构造函数，但可以声明 /* * 课本上是这样写的 * friend  REALSET::REALSET(INTSET &s)//自动成为inline函数 { //本函数声明为INTSET的友元后，可直接访问INTSET的成员 elems = new float[maxcard = s.maxcard]; card = s.card; for(int i = 0; i < card; i++){ elems[i] = s.elems[i]; } } */ friend int sum(REALSET s) { s.~REALSET(); return 0; } friend  REALSET::REALSET(INTSET &s);//自动成为inline函数 public: INTSET(int maxcard); ~INTSET(){ delete elems; } int getcard(){ return card; } int getelems(int i){ return elems[i]; } }; REALSET::REALSET(INTSET &s) { //本函数声明为INTSET的友元后，可直接访问INTSET的成员 elems = new float[maxcard = s.maxcard]; card = s.card; for(int i = 0; i < card; i++){ elems[i] = s.elems[i]; } } INTSET::INTSET(int max){ elems = new int[maxcard = max]; card = 0; } int main() { INTSET iset(20); REALSET rset(iset); }","title":"C++ 基础 不能在一个类中定义另一个类的成员函数 课本5.11"},{"content":"问：链表和数组各有自己的优越性，那么分别在什么情况下使用更适合？          当我们期望进行频繁的插入和删除时，链表比数组更有优势。然而，如果当我们期望进行随机访问的次数高于插入和删除操作的次数时，数组就显得更有优势了。随机访问时数组的强项，因为他们的元素在内存中是连续排列的。哲宗连续的排列方式使得数组中的任何元素能够在O（1）的时间内通过其索引访问。回顾一下访问链表中元素的方法，我们必须的有一个指向元素的指针，如果我们对访问元素的方法不是很了解的话，那么要获取一个指向特定元素的指针的代价就非常高。在实际中，对于许多的应用程序来说，我们必须要遍历链表的一部分。如果存储数据的总量是一定的，那么数组会有一定的优势，数组不需要额外的指针是他们的元素链接起来，也不需要动态的申请空间。 问：关于链表的插入、删除、记忆访问元素的操作和数组相比有何差异？      回顾一下各种形式的链表，除了销毁链表的操作外，其他的操作都是O（1）的空间复杂度。确实，这种表现似乎很难控制。然而，在分析过程中我们会发现有一点并没有说明，那就是对于许多的链表来说，想得到指向链表中的特定元素的指针，其操作还还很复杂的。在最坏的情况下，可能要遍历完真个链表。此时的复杂度可能就是O（n）了，这里n代表元素的个数。另外，在一个设计得当的应用中，不如前面介绍的例子页帧的管理，则对此就不会有任何性能上额外开销。因此，观察应用的特点也是很重的。相对于数组来说，插入和删除都是O（n）级别的复杂度操作，因此在最坏的情况下，插入和删除索引为0的元素需要将其他的所有元素都移动一个位置俩调整整个数组的布局。如果我们知道索引数值，则访问数组中的元素就是O（1）的复杂度操作。      所以数组和链表的操作的使用，很大程度上取决于我们所需要的功能。去合理的选择需要的操作！","title":"链表和数组的问与答"},{"content":"如本章第1节中提到的，Selector类可用于避免使用非阻塞式客户端中很浪费资源的\"忙等\"方法。例如，考虑一个即时消息服务器。可能有上千个客户端同时连接到了服务器，但在任何时刻都只有非常少量的（甚至可能没有）消息需要读取和分发。这就需要一种方法阻塞等待，直到至少有一个信道可以进行I/O操作，并指出是哪个信道。NIO的选择器就实现了这样的功能。一个Selector实例可以同时检查（如果需要，也可以等待）一组信道的I/O状态。用专业术语来说，选择器就是一个多路开关选择器，因为一个选择器能够管理多个信道上的I/O操作。    要使用选择器，需要创建一个Selector实例（使用静态工厂方法open()）并将其注册（register）到想要监控的信道上（注意，这要通过channel的方法实现，而不是使用selector的方法）。最后，调用选择器的select()方法。该方法会阻塞等待，直到有一个或更多的信道准备好了I/O操作或等待超时。select()方法将返回可进行I/O操作的信道数量。现在，在一个单独的线程中，通过调用select()方法就能检查多个信道是否准备好进行I/O操作。如果经过一段时间后仍然没有信道准备好，select()方法就返回0，并允许程序继续执行其他任务。   下面来看一个例子。假设我们想要使用信道和选择器来实现一个回显服务器，并且不使用多线程和忙等。为了使不同协议都能方便地使用这个基本的服务模式，我们把信道中与具体协议相关的处理各种I/O的操作（接收，读，写）分离了出来。TCPProtocol定义了通用TCPSelectorServer类与特定协议之间的接口，包括三个方法，每个方法代表了一种I/O型式。当有信道准备好I/O操作时，服务器只需要调用相应的方法即可。   TCPProtocol.java 0 import java.nio.channels.SelectionKey; 1 import java.io.IOException; 2 3 public interface TCPProtocol { 4 void handleAccept(SelectionKey key) throws IOException; 5 void handleRead(SelectionKey key) throws IOException; 6 void handleWrite(SelectionKey key) throws IOException; 7 }   TCPProtocol.java 在服务器端创建一个选择器，并将其与每个侦听客户端连接的套接字所对应的ServerSocketChannel注册在一起。然后进行反复循环，调用select()方法，并调用相应的操作器例程对各种类型的I/O操作进行处理。  TCPServerSelector.java 0 import java.io.IOException; 1 import java.net.InetSocketAddress; 2 import java.nio.channels.SelectionKey; 3 import java.nio.channels.Selector; 4 import java.nio.channels.ServerSocketChannel; 5 import java.util.Iterator; 6 7 public class TCPServerSelector { 8 9 private static final int BUFSIZE = 256; // Buffer size (bytes) 10 private static final int TIMEOUT = 3000; // Wait timeout (milliseconds) 11 12 public static void main(String[] args) throws IOException { 13 14 if (args.length < 1) { // Test for correct # of args 15 throw new IllegalArgumentException(\"Parameter(s): <Port> ...\"); 16 } 17 18 // Create a selector to multiplex listening sockets and connections 19 Selector selector = Selector.open(); 20 21 // Create listening socket channel for each port and register selector 22 for (String arg : args) { 23 ServerSocketChannel listnChannel = ServerSocketChannel.open(); 24 listnChannel.socket().bind(new InetSocketAddress(Integer.parseInt(arg))); 25 listnChannel.configureBlocking(false); // must be nonblocking to register 26 // Register selector with channel. The returned key is ignored 27 listnChannel.register(selector, SelectionKey.OP_ACCEPT); 28 } 29 30 // Create a handler that will implement the protocol 31 TCPProtocol protocol = new EchoSelectorProtocol(BUFSIZE); 32 33 while (true) { // Run forever, processing available I/O operations 34 // Wait for some channel to be ready (or timeout) 35 if (selector.select(TIMEOUT) == 0) { // returns # of ready chans 36 System.out.print(\".\"); 37 continue; 38 } 39 40 // Get iterator on set of keys with I/O to process 41 Iterator<SelectionKey> keyIter = selector.selectedKeys().iterator(); 42 while (keyIter.hasNext()) { 43 SelectionKey key = keyIter.next(); // Key is bit mask 44 // Server socket channel has pending connection requests? 45 if (key.isAcceptable()) { 46 protocol.handleAccept(key); 47 } 48 // Client socket channel has pending data? 49 if (key.isReadable()) { 50 protocol.handleRead(key); 51 } 52 // Client socket channel is available for writing and 53 // key is valid (i.e., channel not closed)? 54 if (key.isValid() && key.isWritable()) { 55 protocol.handleWrite(key); 56 } 57 keyIter.remove(); // remove from set of selected keys 58 } 59 } 60 } 61 }   TCPServerSelector.java 1.设置：第14-19行 验证至少有一个参数，创建一个Selector实例。 2.为每个端口创建一个ServerSocketChannel：第22-28行 创建一个ServerSocketChannel实例:第23行 使其侦听给定端口：第24行 需要获得底层的ServerSocket，并以端口号作为参数调用其bind()方法。任何超出适当数值范围的参数都将导致抛出IOException异常。 配置为非阻塞模式：第25行 只有非阻塞信道才可以注册选择器，因此需要将其配置为适当的状态。 为信道注册选择器：第27行 在注册过程中指出该信道可以进行\"accept\"操作。 3.创建协议操作器：第31行 为了访问回显协议中的操作方法，创建了一个EchoSelectorProtocol实例。该实例包含了需要用到的方法。 4.反复循环，等待I/O，调用操作器：第33-59行 选择：第35行 这个版本的select()方法将阻塞等待，直到有准备好I/O操作的信道，或直到发生了超时。该方法将返回准备好的信道数。返回0表示超时，这时程序将打印一个点来标记经过的时间和迭代次数。 获取所选择的键集：第41行 调用selectedKeys()方法返回一个Set实例，并从中获取一个Iterator。该集合中包含了每个准备好某一I/O操作的信道的SelectionKey（在注册时创建）。 在键集上迭代，检测准备好的操作：第42-58行  对于每个键，检查其是否准备好进行accep()操作，是否可读或可写，并调用相应的操作器方法对每种情况进行指定的操作。 从集合中移除键：第57行 由于select()操作只是向Selector所关联的键集合中添加元素，因此，如果不移除每个处理过的键，它就会在下次调用select()方法是仍然保留在集合中，而且可能会有无用的操作来调用它。 TCPServerSelector的大部分内容都与协议无关，只有协议赋值那一行代码是针对的特定协议。所有协议细节都包含在了TCPProtocol接口的具体实现中。EchoSelectorProtocol类就实现了该回显协议的操作器。你可以轻松地为自其他协议编写自己的操作器，或在我们的回显协议操作器上进行改进。 EchoSelectorProtocol.java 0 import java.nio.channels.SelectionKey; 1 import java.nio.channels.SocketChannel; 2 import java.nio.channels.ServerSocketChannel; 3 import java.nio.ByteBuffer; 4 import java.io.IOException; 5 6 public class EchoSelectorProtocol implements TCPProtocol { 7 8 private int bufSize; // Size of I/O buffer 9 10 public EchoSelectorProtocol(int bufSize) { 11 this.bufSize = bufSize; 12 } 13 14 public void handleAccept(SelectionKey key) throws IOException { 15 SocketChannel clntChan = ((ServerSocketChannel) key.channel()).accept(); 16 clntChan.configureBlocking(false); // Must be nonblocking to register 17 // Register the selector with new channel for read and attach byte buffer 18 clntChan.register(key.selector(), SelectionKey. OP_READ, ByteBuffer.allocate(bufSize)); 19 20 } 21 22 public void handleRead(SelectionKey key) throws IOException { 23 // Client socket channel has pending data 24 SocketChannel clntChan = (SocketChannel) key.channel(); 25 ByteBuffer buf = (ByteBuffer) key.attachment(); 26 long bytesRead = clntChan.read(buf); 27 if (bytesRead == -1) { // Did the other end close? 28 clntChan.close(); 29 } else if (bytesRead > 0) { 30 // Indicate via key that reading/writing are both of interest now. 31 key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE); 32 } 33 } 34 35 public void handleWrite(SelectionKey key) throws IOException { 36 /* 37 * Channel is available for writing, and key is valid (i.e., client channel 38 * not closed). 39 */ 40 // Retrieve data read earlier 41 ByteBuffer buf = (ByteBuffer) key.attachment(); 42 buf.flip(); // Prepare buffer for writing 43 SocketChannel clntChan = (SocketChannel) key.channel(); 44 clntChan.write(buf); 45 if (!buf.hasRemaining()) { // Buffer completely written? 46 // Nothing left, so no longer interested in writes 47 key.interestOps(SelectionKey.OP_READ); 48 } 49 buf.compact(); // Make room for more data to be read in 50 } 51 52 }32   EchoSelectorProtocol.java 1.声明实现TCPProtocol接口：第6行 2.成员变量和构造函数：第8-12行 每个实例都包含了将要为每个客户端信道创建的缓冲区大小。 3. handleAccept()：第14-20行 从键中获取信道，并接受连接：第15行 channel()方法返回注册时用来创建键的Channel。（我们知道该Channel是一个ServerSocketChannel，因为这是我们注册的惟一一种支持\"accept\"操作的信道。）accept()方法为传入的连接返回一个SocketChannel实例。  设置为非阻塞模式：第16行 再次提醒，这里无法注册阻塞式信道。 为信道注册选择器：第18-19行 可以通过SelectionKey类的selector()方法来获取相应的Selector。我们根据指定大小创建了一个新的ByteBuffer实例，并将其作为参数传递给register()方法。它将作为附件，与register()方法所返回的SelectionKey实例相关联。（在此我们忽略了返回的键，但当信道准备好读数据的I/O操作时，可以通过选出的键集对其进行访问。） 4. handleRead()：第22-33行 获取键关联的信道：第24行 根据其支持数据读取操作可知，这是一个SocketChannel。 获取键关联的缓冲区：第25行 连接建立后，有一个ByteBuffer附加到该SelectionKey实例上。 从信道中读数据：第27行 检查数据流的结束并关闭信道：第27-28行 如果read()方法返回-1，则表示底层连接已经关闭，此时需要关闭信道。关闭信道时，将从选择器的各种集合中移除与该信道关联的键。 如果接收完数据，将其标记为可写：第29-31行 注意，这里依然保留了信道的可读操作，虽然缓冲区中可能已经没有剩余空间了。 5. handleWrite()：第35-50行 获取包含数据的缓冲区：第41行 附加到SelectionKey上的ByteBuffer包含了之前从信道中读取的数据。 准备缓冲区的写操作：第42行 Buffer的内部状态指示了在哪里放入下一批数据，以及缓冲区还剩多少空间。flip()方法用来修改缓冲区的内部状态，以指示write()操作从什么地方获取数据，以及还有剩余多少数据。（下一章将对其进行详细介绍。）该方法的作用是使写数据的操作开始消耗由读操作产生的数据。 获取信道：第43行  向信道写数据：第44行  如果缓冲区为空，则标记为不再写数据：第45-48行  如果缓冲区中之前接收的数据已经没有剩余，则修改该键关联的操作集，指示其只能进行读操作。 压缩缓冲区：第49行 如果缓冲区中还有剩余数据，该操作则将其移动到缓冲区的前端，以使下次迭代能够读入更多的数据（第5.4.5节将对这个操作的语义进行详细介绍）。在任何情况下，该操作都将重置缓冲区的状态，因此缓冲区又变为可读。注意，除了在handleWrite()方法内部，与信道关联的缓冲区始终是设置为可读的。 现在我们已经准备好对三大NIO 抽象的细节进行深入研究了。   相关下载： Java_TCPIP_Socket编程(doc) http://download.csdn.net/detail/undoner/4940239   文献来源： UNDONER(小杰博客) ：http://blog.csdn.net/undoner LSOFT.CN(琅软中国) ：http://www.lsoft.cn  ","title":"NIO：Selector 类用法"},{"content":"这一节主要是讲述如何定位一个堆内存越界导致在free时coredump的问题。","title":"《coredump问题原理探究》windows版8.7节堆布局heap corruption第二个例子"},{"content":"static void f3(short x) { prt(\"f3(short)\"); } static void f3(int x) { prt(\"f3(int)\"); } static void f3(long x) { prt(\"f3(long)\"); } static void f3(float x) { prt(\"f3(float)\"); } static void f3(double x) { prt(\"f3(double)\");} static void prt(String s) {   System.out.println(s); } 方法的重载(有的翻译成过载)就是方法名相同，方法的参数序列不相同（这里不是指继承关系中的重写）： 1)仅仅是返回类型不同，不能重载；这在一般编程语言中都是这样规定的，原因非常简单，根据返回类型确定要调用那个方法， 需要根据返回值的接受者类型来确定，这在很多时候都是非常困难的（例如接受类型是Object,或者不需要接收返回值的情况）。 2)参数序列的不同主要是指参数类型序列的不同，而不是参数名字的不同； 3)在确定参数类型不同时，不会考虑继承关系，虽然ClassA是ClassB的父类，下面： public String DoSomething(ClassA A)和public String DoSomething(ClassB B)是符合重载的. 对于重载需要注意以下： 1)对于主类型(基本类型)重载,如果调用时实参是变量或者指定了类型的常数(2.0d)，或者常数的类型唯一确定(字符，字符串，布尔)， 则根据变量类型来选择要调用的方法，但对于实参是常数,不易确定的数字类型，在没有明确类型标记的情况下，一般整数会转换成int型， 一般小数会被转换成double，测试如下:   //调用测试： char a='A';  f3(a);  f3(1);  //f3(10000000000);出错  f3(10000000000l);  f3(2.0);  f3(2.0f);  f3(2.0d); 测试结果: f3(int) f3(int) f3(long) f3(double) f3(float) f3(double) 2)对于有继承关系的类型形成的重载，调用的时候也是根据变量类型来确定调用方法的，只不过，如果当前变量类型没有，则寻着父类型方向 向上寻找，直到找到为止(肯定会找到，如果找不到编译的时候就会报错)： 下面的MyClassA->D依次为父子关系，下面是重载方法： public class OverloadClass {\tpublic void DoSomething(MyClassA a)\t{\t\tSystem.out.println(\"MyClassA a:\"+a.getClass().getName());\t}    public void DoSomething(MyClassB b)    {    \tSystem.out.println(\"MyClassB b:\"+b.getClass().getName());    }    public void DoSomething2(MyClassA a)    {    \tSystem.out.println(\"MyClassA a:\"+a.getClass().getName());    }    public void DoSomething2(MyClassC c)    {    \tSystem.out.println(\"MyClassC c:\"+c.getClass().getName());    }    public void DoSomething3(MyClassC c)    {    \tSystem.out.println(\"MyClassC c:\"+c.getClass().getName());    }} 重载测试代码： OverloadClass theOC = new OverloadClass();  MyClassA theA = new MyClassA();  MyClassB theB = new MyClassB();  MyClassA theC = new MyClassC();  MyClassB theD = new MyClassC();  MyClassC theE = new MyClassD();  MyClassD theF = new MyClassD();    //theOC.DoSomething(theA);  //theOC.DoSomething(theB);  //theOC.DoSomething(theC);    theOC.DoSomething2(theA);  theOC.DoSomething2(theB);  theOC.DoSomething2(theC);  theOC.DoSomething2(theD);  theOC.DoSomething2(theE);  theOC.DoSomething2(theF);    //theOC.DoSomething3(theA);//编译错误. 这种重载判断规则，同样也适用于C#.之所以重载是根据变量类型而不是实际类型来判断，其实原因非常简单,因为重载是在编译期就 会确定的，这个时候变量类型也是确定的，因此比较好判断，而实际类型往往是在运行期间才知道，编译期的重载当然不可能根据运行期 的事情来确定(这也是强类型语言的一个优势和劣势)。 ＰＳ：构造函数也可以重载。注意如果在构造函数中调用另外一个构造函数一定要放在构造函数的第１行，且只能调用一次。这个规定在C#中 也是一样，只是书写语法不一样。","title":"Java学习笔记(方法重载)"},{"content":"如前文所述，Channel实例代表了一个与设备的连接，通过它可以进行输入输出操作。实际上Channel的基本思想与我们见过的普通套接字非常相似。对于TCP协议，可以使用ServerSocketChannel和SocketChannel。还有一些针对其他设备的其他类型信道（如，FileChannel），尽管我们在后文中不会再提及，这里介绍的大部分内容对于它们同样适用。信道（channel）和套接字（socket）之间的不同点之一，可能是信道通常要调用静态工厂方法来获取实例： SocketChannel clntChan = SocketChannel.open(); ServerSocketChannel servChan = ServerSocketChannel.open();  Channel使用的不是流，而是缓冲区来发送或读取数据。Buffer类或其任何子类的实例都可以看作是一个定长的Java基本数据类型元素序列。与流不同，缓冲区有固定的、有限的容量，并由内部（但可以被访问）状态记录了有多少数据放入或取出，就像是有限容量的队列一样。Buffer是一个抽象类，只能通过创建它的子类来获得Buffer实例，而每个子类都设计为用来容纳一种Java基本数据类型（boolean除外）。因此，这些实例分别为FloatBuffer，或IntBuffer，或ByteBuffer，等等（ByteBuffer是这些实例中最灵活的，并将在后面很多例子中用到）。在channel中使用Buffer实例通常不是使用构造函数创建的，而是通过调用allocate()方法创建指定容量的Buffer实例， ByteBuffer buffer = ByteBuffer.allocate(CAPACITY); 或通过包装一个已有的数组来创建： ByteBuffer buffer = ByteBuffer.wrap(byteArray);    NIO的强大功能部分来自于channel的非阻塞特性。回顾前面介绍的内容可以知道，套接字的某些操作可能会无限期地阻塞。例如，对accept()方法的调用可能会因为等待一个客户端连接而阻塞；对read()方法的调用可能会因为没有数据可读而阻塞，直到连接的另一端传来新的数据。总的来说，创建/接收连接或读写数据等I/O调用，都可能无限期地阻塞等待，直到底层的网络实现发生了什么。慢速的、有损耗的网络，或仅仅是简单的网络故障都可能导致任意时间的延迟。然而不幸的是，在调用一个方法之前无法知道其是否会阻塞。NIO的channel抽象的一个重要特征就是可以通过配置它的阻塞行为，以实现非阻塞式的信道。 clntChan.configureBlocking(false);   在非阻塞式信道上调用一个方法总是会立即返回。这种调用的返回值指示了所请求的操作完成的程度。例如，在一个非阻塞式ServerSocketChannel上调用accept()方法，如果有连接请求在等待，则返回客户端SocketChannel，否则返回null。下面我们来创建一个非阻塞式TCP回显客户端。可能阻塞的I/O操作包括建立连接，读和写。通过使用非阻塞式信道，这些操作都将立即返回。我们必须反复调用这些操作，直到所有I/O操作都成功完成。   TCPEchoClientNonblocking.java 0 import java.net.InetSocketAddress; 1 import java.net.SocketException; 2 import java.nio.ByteBuffer; 3 import java.nio.channels.SocketChannel; 4 5 public class TCPEchoClientNonblocking { 6 7 public static void main(String args[]) throws Exception { 8 9 if ((args.length < 2) || (args.length > 3)) // Test for correct # of args 10 throw new IllegalArgumentException(\"Parameter(s): <Server> <Word> [<Port>]\"); 11 12 String server = args[0]; // Server name or IP address 13 // Convert input String to bytes using the default charset 14 byte[] argument = args[1].getBytes(); 15 16 int servPort = (args.length == 3) ? Integer.parseInt(args[2]) : 7; 17 18 // Create channel and set to nonblocking 19 SocketChannel clntChan = SocketChannel.open(); 20 clntChan.configureBlocking(false); 21 22 // Initiate connection to server and repeatedly poll until complete 23 if (!clntChan.connect(new InetSocketAddress(server, servPort))) { 24 while (!clntChan.finishConnect()) { 25 System.out.print(\".\"); // Do something else 26 } 27 } 28 ByteBuffer writeBuf = ByteBuffer.wrap(argument); 29 ByteBuffer readBuf = ByteBuffer.allocate(argument.length); 30 int totalBytesRcvd = 0; // Total bytes received so far 31 int bytesRcvd; // Bytes received in last read 32 while (totalBytesRcvd < argument.length) { 33 if (writeBuf.hasRemaining()) { 34 clntChan.write(writeBuf); 35 } 36 if ((bytesRcvd = clntChan.read(readBuf)) == -1) { 37 throw new SocketException(\"Connection closed prematurely\"); 38 } 39 totalBytesRcvd += bytesRcvd; 40 System.out.print(\".\"); // Do something else 41 } 42 43 System.out.println(\"Received: \" + // convert to String per default charset 44 new String(readBuf.array(), 0, totalBytesRcvd)); 45 clntChan.close(); 46 } 47 }   TCPEchoClientNonblocking.java  1.获取并转换参数：第9-16行 2. 创建非阻塞式SocketChannel：第19-20行 3.连接服务器：第23-27行  由于该套接字是非阻塞式的，因此对connect()方法的调用可能会在连接建立之前返回，如果在返回前已经成功建立了连接，则返回true，否则返回false。对于后一种情况，任何试图发送或接收数据的操作都将抛出NotYetConnectedException异常，因此，我们通过持续调用finishConnect()方法来\"轮询\"连接状态，该方法在连接成功建立之前一直返回false。打印操作演示了在等待连接建立的过程中，程序还可以执行其他任务。不过，这种忙等的方法非常浪费系统资源，这里这样做只是为了演示该方法的使用。  4.创建读写缓冲区：第28-29行  我们分别使用了两种方法来创建将要用来读写数据的ByteBuffer实例。一是通过包装包含了要发送数据的byte[]数组，另一个方法是调用allocate()方法，创建具有与前面byte[]数组大小相同缓冲区的ByteBuffer实例。  5.反复循环直到发送和接收完所有字节：第32-41行 只要输出缓冲区中还留有数据，就调用write()方法。对read()方法的调用不会阻塞等待，但是当没有数据可读时该方法将返回0。这里，打印语句再次举例说明了在等待通信完成的过程中，程序可以执行其他任务。 6.打印接收到的数据：第43-44行 7.关闭信道：第45行 与套接字类似，信道在完成其任务后也需要关闭。   相关下载： Java_TCPIP_Socket编程(doc) http://download.csdn.net/detail/undoner/4940239   文献来源： UNDONER(小杰博客) ：http://blog.csdn.net/undoner LSOFT.CN(琅软中国) ：http://www.lsoft.cn  ","title":"NIO：与 Buffer 一起使用 Channel"},{"content":"这个主要是在CSAPP基础上做的，添加了POST，SSL，目录显示等功能。 一、 实现功能： 1. 支持GET/POST方法 2. 支持SSL安全连接即HTTPS 3. 支持CGI 4. 基于IP地址和掩码的认证 5. 目录显示 6. 日志功能 7. 错误提示页面 二、设计原理 首先介绍一些HTTP协议基本知识。 #1.GET/POST 本实现支持GET/POST方法，都是HTTP协议需要支持的标准方法。 GET方法主要是通过URL发送请求和传送数据，而POST方法在请求头空一格之后传送数据，所以POST方法比GET方法安全性高，因为GET方法可以直接看到传送的数据。另外一个区别就是GET方法传输的数据较小，而POST方法很大。所以一般表单，登陆页面等都是通过POST方法。 #2.MIME类型    当服务器获取客户端的请求的文件名，将分析文件的MIME类型，然后告诉浏览器改文件的MIME类型，浏览器通过MIME类型解析传送过来的数据。具体来说，浏览器请求一个主页面，该页面是一个HTML文件，那么服务器将”text/html”类型发给浏览器，浏览器通过HTML解析器识别发送过来的内容并显示。 下面将描述一个具体情景。    客户端使用浏览器通过URL发送请求，服务器获取请求。 如浏览器URL为：127.0.0.1/postAuth.html, 那么服务器获取到的请求为：GET  /postAuth.html  HTTP/1.1 意思是需要根目录下postAuth.html文件的内容，通过GET方法，使用HTTP/1.1协议(1.1是HTTP的版本号)。这是服务器将分析文件名，得知postAuth.html是一个HTML文件，所以将”text/html”发送给浏览器，然后读取postAuth.html内容发给浏览器。 实现简单的MIME类型识别代码如下： 主要就是通过文件后缀获取文件类型。 static void get_filetype(const char *filename, char *filetype) {    if (strstr(filename, \".html\"))\t\tstrcpy(filetype, \"text/html\");    else if (strstr(filename, \".gif\"))\t\tstrcpy(filetype, \"image/gif\");    else if (strstr(filename, \".jpg\"))\t\tstrcpy(filetype, \"image/jpeg\");    else if (strstr(filename, \".png\"))\t\tstrcpy(filetype, \"image/png\");    else\tstrcpy(filetype, \"text/plain\");}  如果支持HTTPS的话，那么我们就#define HTTPS，这主要通过gcc 的D选项实现的，具体细节可参考man手册。 静态内容显示实现如下： static void serve_static(int fd, char *filename, int filesize) {    int srcfd;    char *srcp, filetype[MAXLINE], buf[MAXBUF];     /* Send response headers to client */    get_filetype(filename, filetype);    sprintf(buf, \"HTTP/1.0 200 OK\\r\\n\");    sprintf(buf, \"%sServer: Tiny Web Server\\r\\n\", buf);    sprintf(buf, \"%sContent-length: %d\\r\\n\", buf, filesize);    sprintf(buf, \"%sContent-type: %s\\r\\n\\r\\n\", buf, filetype);    /* Send response body to client */    srcfd = Open(filename, O_RDONLY, 0);    srcp = Mmap(0, filesize, PROT_READ, MAP_PRIVATE, srcfd, 0);    Close(srcfd);    #ifdef HTTPS     if(ishttps)    {    \tSSL_write(ssl, buf, strlen(buf));\tSSL_write(ssl, srcp, filesize);    }    else    #endif    {\tRio_writen(fd, buf, strlen(buf));\tRio_writen(fd, srcp, filesize);    }    Munmap(srcp, filesize);} #3.CGI规范    如果只能显示页面那么无疑缺少动态交互能力，于是CGI产生了。CGI是公共网关接口(Common Gateway Interface),是在CGI程序和Web服务器之间传递信息的规则。CGI允许Web服务器执行外部程序，并将它们的输出发送给浏览器。这样就提供了动态交互能力。  那么服务器是如何分开处理静态页面和动态CGI程序的呢？这主要是通过解析URL的方式。我们可以定义CGI程序的目录，如cgi-bin,那么如果URL包含”cgi-bin”字符串则这是动态程序，且将URL的参数给cgiargs。如果是静态页面，parse_uri返回1，反正返回0。所以我们可以通过返回值区别不同的服务类型。 具体解析URL方式如下： static int parse_uri(char *uri, char *filename, char *cgiargs) {    char *ptr;    char tmpcwd[MAXLINE];    strcpy(tmpcwd,cwd);    strcat(tmpcwd,\"/\");    if (!strstr(uri, \"cgi-bin\"))     {  /* Static content */\tstrcpy(cgiargs, \"\");\tstrcpy(filename, strcat(tmpcwd,Getconfig(\"root\")));\tstrcat(filename, uri);\tif (uri[strlen(uri)-1] == '/')\t    strcat(filename, \"home.html\");\treturn 1;    }    else     {  /* Dynamic content */\tptr = index(uri, '?');\tif (ptr) \t{\t    strcpy(cgiargs, ptr+1);\t    *ptr = '\\0';\t}\telse \t    strcpy(cgiargs, \"\");\tstrcpy(filename, cwd);\tstrcat(filename, uri);\treturn 0;    }} GET方式的CGI规范实现原理:    服务器通过URL获取传给CGI程序的参数，设置环境变量QUERY_STRING，并将标准输出重定向到文件描述符，然后通过EXEC函数簇执行外部CGI程序。外部CGI程序获取QUERY_STRING并处理，处理完后输出结果。由于此时标准输出已重定向到文件描述符，即发送给了浏览器。 实现细节如下：由于涉及到HTTPS，所以稍微有点复杂。 void get_dynamic(int fd, char *filename, char *cgiargs) {    char buf[MAXLINE], *emptylist[] = { NULL },httpsbuf[MAXLINE];    int p[2];    /* Return first part of HTTP response */    sprintf(buf, \"HTTP/1.0 200 OK\\r\\n\");    sprintf(buf, \"%sServer: Web Server\\r\\n\",buf);    #ifdef HTTPS     if(ishttps)    \tSSL_write(ssl,buf,strlen(buf));    else    #endif       \tRio_writen(fd, buf, strlen(buf));\t    #ifdef HTTPS     if(ishttps)    {    \tPipe(p);       \tif (Fork() == 0)\t{  /* child  */ \t\tClose(p[0]);\t\tsetenv(\"QUERY_STRING\", cgiargs, 1); \t\tDup2(p[1], STDOUT_FILENO);         /* Redirect stdout to p[1] */\t\tExecve(filename, emptylist, environ); /* Run CGI program */\t\t}\tClose(p[1]);\tRead(p[0],httpsbuf,MAXLINE);   /* parent read from p[0] */\tSSL_write(ssl,httpsbuf,strlen(httpsbuf));    }    else    #endif    {\tif (Fork() == 0) \t{ /* child */\t\t/* Real server would set all CGI vars here */\t\tsetenv(\"QUERY_STRING\", cgiargs, 1); \t\tDup2(fd, STDOUT_FILENO);         /* Redirect stdout to client */\t\tExecve(filename, emptylist, environ); /* Run CGI program */\t}}} POST方式的CGI规范实现原理：    由于POST方式不是通过URL传递参数，所以实现方式与GET方式不一样。 POST方式获取浏览器发送过来的参数长度设置为环境变量CONTENT-LENGTH。并将参数重定向到CGI的标准输入，这主要通过pipe管道实现的。CGI程序从标准输入读取CONTENT-LENGTH个字符就获取了浏览器传送的参数，并将处理结果输出到标准输出，同理标准输出已重定向到文件描述符，所以浏览器就能收到处理的响应。 具体实现细节如下： static void post_dynamic(int fd, char *filename, int contentLength,rio_t *rp){    char buf[MAXLINE],length[32], *emptylist[] = { NULL },data[MAXLINE];    int p[2];    #ifdef HTTPS     int httpsp[2];    #endif    sprintf(length,\"%d\",contentLength);    memset(data,0,MAXLINE);    Pipe(p);    /*       The post data is sended by client,we need to redirct the data to cgi stdin.    *  \t so, child read contentLength bytes data from fp,and write to p[1];    *    parent should redirct p[0] to stdin. As a result, the cgi script can    *    read the post data from the stdin.     */    /* https already read all data ,include post data  by SSL_read() */       \tif (Fork() == 0)\t{                     /* child  */ \t\tClose(p[0]);\t\t#ifdef HTTPS \t\tif(ishttps)\t\t{\t\t\tWrite(p[1],httpspostdata,contentLength);\t\t\t}\t\telse\t\t#endif\t\t{\t\t\tRio_readnb(rp,data,contentLength);\t\t\tRio_writen(p[1],data,contentLength);\t\t}\t\texit(0)\t;\t}        /* Send response headers to client */    sprintf(buf, \"HTTP/1.0 200 OK\\r\\n\");    sprintf(buf, \"%sServer: Tiny Web Server\\r\\n\",buf);    #ifdef HTTPS     if(ishttps)    \tSSL_write(ssl,buf,strlen(buf));    else    #endif        Rio_writen(fd, buf, strlen(buf));    Dup2(p[0],STDIN_FILENO);  /* Redirct p[0] to stdin */    Close(p[0]);    Close(p[1]);    setenv(\"CONTENT-LENGTH\",length , 1);     #ifdef HTTPS     if(ishttps)  /* if ishttps,we couldnot redirct stdout to client,we must use SSL_write */    {    \tPipe(httpsp);\t   if(Fork()==0)\t  {    \tDup2(httpsp[1],STDOUT_FILENO);        /* Redirct stdout to https[1] */ \t\tExecve(filename, emptylist, environ); \t}\tRead(httpsp[0],data,MAXLINE);\tSSL_write(ssl,data,strlen(data));    }    else    #endif    {    \tDup2(fd,STDOUT_FILENO);        /* Redirct stdout to client */ \t    Execve(filename, emptylist, environ);     }} 目录显示功能原理：    主要是通过URL获取所需目录，然后获取该目录下所有文件，并发送相应信息，包括文件格式对应图片，文件名，文件大小，最后修改时间等。由于我们发送的文件名是通过超链接的形式，所以我们可以点击文件名继续浏览信息。 具体实现细节如下： static void serve_dir(int fd,char *filename){\tDIR *dp;\tstruct dirent *dirp;    \tstruct stat sbuf;\tstruct passwd *filepasswd;\tint num=1;\tchar files[MAXLINE],buf[MAXLINE],name[MAXLINE],img[MAXLINE],modifyTime[MAXLINE],dir[MAXLINE];\tchar *p;\t/*\t* Start get the dir   \t* for example: /home/yihaibo/kerner/web/doc/dir -> dir[]=\"dir/\";\t*/\tp=strrchr(filename,'/');\t++p;\tstrcpy(dir,p);\tstrcat(dir,\"/\");\t/* End get the dir */\tif((dp=opendir(filename))==NULL)\t\tsyslog(LOG_ERR,\"cannot open dir:%s\",filename);    \tsprintf(files, \"<html><title>Dir Browser<\/title>\");\tsprintf(files,\"%s<style type=\"\"text/css\"\"> a:link{text-decoration:none;} <\/style>\",files);\tsprintf(files, \"%s<body bgcolor=\"\"ffffff\"\" font-family=Arial color=#fff font-size=14px>\\r\\n\", files);\twhile((dirp=readdir(dp))!=NULL)\t{\t\tif(strcmp(dirp->d_name,\".\")==0||strcmp(dirp->d_name,\"..\")==0)\t\t\tcontinue;\t\tsprintf(name,\"%s/%s\",filename,dirp->d_name);\t\tStat(name,&sbuf);\t\tfilepasswd=getpwuid(sbuf.st_uid);\t\tif(S_ISDIR(sbuf.st_mode))\t\t{\t\t\tsprintf(img,\"<img src=\"\"dir.png\"\" width=\"\"24px\"\" height=\"\"24px\"\">\");\t\t}\t\telse if(S_ISFIFO(sbuf.st_mode))\t\t{\t\t\tsprintf(img,\"<img src=\"\"fifo.png\"\" width=\"\"24px\"\" height=\"\"24px\"\">\");\t\t}\t\telse if(S_ISLNK(sbuf.st_mode))\t\t{\t\t\tsprintf(img,\"<img src=\"\"link.png\"\" width=\"\"24px\"\" height=\"\"24px\"\">\");\t\t}\t\telse if(S_ISSOCK(sbuf.st_mode))\t\t{\t\t\tsprintf(img,\"<img src=\"\"sock.png\"\" width=\"\"24px\"\" height=\"\"24px\"\">\");\t\t}\t\telse\t\t\tsprintf(img,\"<img src=\"\"file.png\"\" width=\"\"24px\"\" height=\"\"24px\"\">\");\tsprintf(files,\"%s<p><pre>%-2d%s\"\"<a href=%s%s\"\">%-15s<\/a>%-10s%10d %24s<\/pre><\/p>\\r\\n\",files,num++,img,dir,dirp->d_name,dirp->d_name,filepasswd->pw_name,(int)sbuf.st_size,timeModify(sbuf.st_mtime,modifyTime));\t}\tclosedir(dp);\tsprintf(files,\"%s<\/body><\/html>\",files);\t/* Send response headers to client */\tsprintf(buf, \"HTTP/1.0 200 OK\\r\\n\");\tsprintf(buf, \"%sServer: Tiny Web Server\\r\\n\", buf);\tsprintf(buf, \"%sContent-length: %d\\r\\n\", buf, strlen(files));\tsprintf(buf, \"%sContent-type: %s\\r\\n\\r\\n\", buf, \"text/html\");\t#ifdef HTTPS\tif(ishttps)\t{\t\tSSL_write(ssl,buf,strlen(buf));\t\tSSL_write(ssl,files,strlen(files));\t}\telse\t#endif\t{\t\tRio_writen(fd, buf, strlen(buf));\t\tRio_writen(fd, files, strlen(files));\t}\texit(0);} HTTPS的实现：    HTTPS主要基于openssl的开源库实现。如果没有安装，那么我们就不#define HTTPS。 HTTPS的功能主要就是提供安全的连接，服务器和浏览器之间传送的数据是通过加密的，加密方式可以自己选定。    开始连接时，服务器需要发送CA，由于我们的CA是自己签发的，所以需要我们自己添加为可信。 访问控制功能： 主要是通过获取客户端IP地址，并转换为整数，与上配置文件中定义的掩码，如果符合配置文件中允许的网段，那么可以访问，否则不可以。 具体实现如下。 static long long ipadd_to_longlong(const char *ip){\tconst char *p=ip;\tint ge,shi,bai,qian;\tqian=atoi(p);\tp=strchr(p,'.')+1;\tbai=atoi(p);\tp=strchr(p,'.')+1;\tshi=atoi(p);\tp=strchr(p,'.')+1;\tge=atoi(p);\treturn (qian<<24)+(bai<<16)+(shi<<8)+ge;}int access_ornot(const char *destip) // 0 -> not 1 -> ok{\t//192.168.1/255.255.255.0\tchar ipinfo[16],maskinfo[16];\tchar *p,*ip=ipinfo,*mask=maskinfo;\tchar count=0;\tchar *maskget=Getconfig(\"mask\");\tconst char *destipconst,*ipinfoconst,*maskinfoconst;\tif(maskget==\"\")\t{\t\tprintf(\"ok:%s\\n\",maskget);\t\treturn 1;\t}\t\tp=maskget;/* get ipinfo[] start */\twhile(*p!='/')\t{\t\tif(*p=='.')\t\t\t++count;\t\t*ip++=*p++;\t}\twhile(count<3)\t{\t\t*ip++='.';\t\t*ip++='0';\t\t++count;\t}\t*ip='\\0';/* get ipinfo[] end *//* get maskinfo[] start */\t++p;\twhile(*p!='\\0')\t{\t\tif(*p=='.')\t\t\t++count;\t\t*mask++=*p++;\t}\twhile(count<3)\t{\t\t*mask++='.';\t\t*mask++='0';\t\t++count;\t}\t*mask='\\0';/* get maskinfo[] end */\tdestipconst=destip;\tipinfoconst=ipinfo;\tmaskinfoconst=maskinfo;\treturn ipadd_to_longlong(ipinfoconst)==(ipadd_to_longlong(maskinfoconst)&ipadd_to_longlong(destipconst));} 配置文件的读取： 主要选项信息都定义与配置文件中。 格式举例如下; #HTTP PORT PORT = 8888 所以读取配置文件函数具体如下： static char* getconfig(char* name){/*pointer meaning:...port...=...8000...   |  |   |   |  |  *fs |   |   |  *be    f->forward  b-> back      *fe |   *bs       s->start    e-> end          *equal*/\tstatic char info[64];\tint find=0;\tchar tmp[256],fore[64],back[64],tmpcwd[MAXLINE];\tchar *fs,*fe,*equal,*bs,*be,*start;\tstrcpy(tmpcwd,cwd);\tstrcat(tmpcwd,\"/\");\tFILE *fp=getfp(strcat(tmpcwd,\"config.ini\"));\twhile(fgets(tmp,255,fp)!=NULL)\t{\t\tstart=tmp;\t\tequal=strchr(tmp,'=');\t\twhile(isblank(*start))\t\t\t++start;\t\tfs=start;\t\tif(*fs=='#')\t\t\tcontinue;\t\twhile(isalpha(*start))\t\t\t++start;\t\tfe=start-1;\t\tstrncpy(fore,fs,fe-fs+1);\t\tfore[fe-fs+1]='\\0';\t\tif(strcmp(fore,name)!=0)\t\t\tcontinue;\t\tfind=1;\t\tstart=equal+1;\t\twhile(isblank(*start))\t\t\t++start;\t\tbs=start;\t\twhile(!isblank(*start)&&*start!='\\n')\t\t\t++start;\t\tbe=start-1;\t\tstrncpy(back,bs,be-bs+1);\t\tback[be-bs+1]='\\0';\t\tstrcpy(info,back);\t\tbreak;\t}\tif(find)\t\treturn info;\telse\t\treturn NULL;} 二、 测试 本次测试使用了两台机器。一台Ubuntu的浏览器作为客户端，一台Redhat作为服务器端，其中Redhat是Ubuntu上基于VirtualBox的一台虚拟机。 IP地址信息如下： Ubuntu的vboxnet0： RedHateth0: RedHat主机编译项目： 由于我们同事监听了8000和4444，所以有两个进程启动。 HTTP的首页： 目录显示功能： HTTP GET页面： HTTPGET响应： 从HTTP GET响应中我们观察URL，参数的确是通过URL传送过去的。 其中getAuth.c如下： #include \"wrap.h\"#include \"parse.h\"int main(void) {    char *buf, *p;    char name[MAXLINE], passwd[MAXLINE],content[MAXLINE];    /* Extract the two arguments */    if ((buf = getenv(\"QUERY_STRING\")) != NULL) {\tp = strchr(buf, '&');\t*p = '\\0';\tstrcpy(name, buf);\tstrcpy(passwd, p+1);    }    /* Make the response body */    sprintf(content, \"Welcome to auth.com:%s and %s\\r\\n<p>\",name,passwd);    sprintf(content, \"%s\\r\\n\", content);    sprintf(content, \"%sThanks for visiting!\\r\\n\", content);      /* Generate the HTTP response */    printf(\"Content-length: %d\\r\\n\", strlen(content));    printf(\"Content-type: text/html\\r\\n\\r\\n\");    printf(\"%s\", content);    fflush(stdout);    exit(0);} HTTPS的首页：由于我们的CA不可信，所以需要我们认可 认可后HTTPS首页： HTTPS POST页面： HTTPS POST响应： 从上我们可以看出，POST提交的参数的确不是通过URL传送的。","title":"C语言开发Linux下web服务器(支持GET/POST,SSL,目录显示等)"},{"content":"  Oracle培训（四十一）——Servlet第一章知识点总结——Servlet 基础   Java Web控制器Servlet程序设计   1.         WEB应用程序 a)         概念：                                       i.              WEB应用程序是在Internet（国际互联网）之上的一种应用程序                                     ii.              通常是B/S（浏览器端/服务器端）形式的程序 b)        优势：                                       i.              用户不需要更新应用程序                                     ii.              几乎不占用用户的资源                                   iii.              数据更安全 2.         WEB运作的机制     3.         目标 a)         了解公共网关接口(CGI)基本原理 b)        了解servlet基本原理 c)         理解并能够运用servlet 4.         概述 a)         Servlet:                                       i.              Java程序设计对象                                     ii.              基于CGI解决方案的替代品 b)        课程:                                       i.              开发servlets解决现实问题                                     ii.              论述servlet开发                                   iii.              介绍Web 服务器的主要servlet相关功能 5.         课程整体目标 a)         开发简单的超文本传送协议(HTTP) servlet. b)        表单处理servlet开发. c)         修改一个数据库访问servlet为使用连接池. d)        追踪状态 e)         代码过滤器和监听器 f)         部署网络应用程序 6.         课程主要内容 a)         Servlets 基础 b)        用Servlets进行表单处理 c)         生命周期 d)        资源访问 e)         在Http Servlets中持久化状态 f)         过滤器开发 g)        网络应用生命周期事件     目标   了解CGI原理 了解servlet原理 理解并熟练掌握如何创建HttpServlet 理解并熟练掌握Servlet开发步骤   知识点预览   通用网关接口 Servlet   通用网关接口(CGI)   1.       定义 a)         Common Gateway Interface，简称CGI。是运行在服务器上的一段程序，主要作用是提供同客户端HTML页面的接口。 2.       应用示例 a)         提供网络服务器的入口 b)        返回数据库信息 c)         执行运算 3.       CGI 请求/响应     4.       CGI 和 HTTP a)         HTTP是被多数网络服务器应用的请求/响应协议 b)        HTTP响应的头信息指明响应的数据类型 5.       用C/Perl编写的HelloWorld CGI     6.       如何调用CGI脚本程序 a)         将脚本放置在服务器server_root/cgi-bin/目录下 b)        打开浏览器输入地址进行调用 c)         举例： d)        Helloworld或者helloworld.pl脚本使用以下方式调用: e)         http:// host_name:port/cgi-bin/helloworld 7.       CGI应用 a)         大多数网络服务器支持CGI脚本. b)        大多数网络服务器支持若干个CGI脚本语言:                                       i.              Perl                                     ii.              C                                   iii.              Tool command language (TCL)工具命令语言   Servlet 1.       什么是Servlet a)         定义                                       i.              是一种服务器端的Java应用程序，具有独立于平台和协议的特性,可以生成动态的Web页面。                                     ii.              担当客户请求（Web浏览器或其他HTTP客户程序）与服务器响应（HTTP服务器上的数据库或应用程序）的中间层 b)        作用:                                       i.              能够使用对象进行编程                                     ii.              可以保存和使用大量信息                                   iii.              允许多个用户之间的协作 2.       Servlets 请求/响应       3.       Servlet容器 a)         Servlet需要servlet“容器”来运行                                       i.              Catalina in Tomcat（使用Tomcat7） b)        支持由具备servlet容器的多个网络服务器提供                                       i.              Apache Web Server                                     ii.              SunONE Web Server 4.       Servlet框架     5.       请求响应流程     6.       创建HttpServlet的步骤—“四部曲” a)         第一步：扩展HttpServlet抽象类 public class HelloServlet extends HttpServlet{} b)        第二步：覆盖doGet()方法 public void doGet(HttpServletRequest request, HttpServletResponse response)throws IOException,ServletException{ c)         第三步：获取HTTP请求中的参数信息 String userName=request.getParameter(“userName\");…… d)        第四步：生成HTTP响应结果 Response.setContenType()…… 7.       HelloWorldServlet     8.       HttpResponse常用方法—set方法 a)         setContentType()方法 设置ContentType b)        setContentLength()方法 设置响应文本长度 c)         setHeader(),setIntHeader和setDateHeader()方法 响应头部信息添加的字段信息通过设置. setHeader(“Author”,”Marry”)－〉<meta name=“Author” contect=“Marry”> 9.       HttpResponse常用方法—get方法 a)         getWriter()                                       i.              返回PrintWriter对象                                     ii.              在返回文本数据时使用 b)        getOutputStream()                                       i.              返回ServletOutputStream对象                                     ii.              在返回二进制数据时使用 10.   ServletContext a)         ServletContext                                       i.              Servlet对象可以通过它来访问容器中的各种资源                                     ii.              同一个Web应用所有的Servlet对象共享一个ServletContext                                   iii.              Servlet容器在启动一个Web应用时，会为它创建一个ServletContext对象                                    iv.              getServletContext()是ServletContext实例 b)        javax.servlet.servletContext 接口 提供两个log方法调试servlets 11.   Servlet 调用步骤 a)         使用Eclipse创建HelloWorldServlet.java b)        创建web.xml　文件以包含这个servlet定义,如     c)         通过以下方式调: http://127.0.0.1:8080/myapp/helloworld   Servlet基础的回顾   扩展HttpServlet 重写一个服务方法去接受servlet的请求 设置内容类型 使用getPrintWriter()或getServletOutputStream() 利用println方法生成动态HTML 使用output.close() 使用getServletContext().log()记录日志信息    ","title":"Oracle培训（四十一）——Servlet第一章知识点总结——Servlet 基础"},{"content":"  Oracle培训（四十一）——Servlet第一章知识点总结——Web工作原理   知识点预览 1.      HTTP 2.      HTTP处理流程 3.       服务器的缺陷 4.       辅助应用程序之CGI（Common Gateway Interface） 5.      Servlet容器 6.      Servlet规范 7.      Servlet和web容器配合 8.      Java Web应用程序的组成   1.HTTP        1).what?              位于OSI(Open System Interconnection，开放系统互连)七层网络模型中最上层（表示层）。它是一种为操作系统和应用程序提供访问网络的接口的通信协议（同层协议还包括：SMTP、FTP等） 特点： 数据在网络传输中都是以包的形式进行传输，利用不同的通信协议，包里的数据形式和格式要求不一样。例如FTP、SMTP、HTTP所要求的数据包的格式都不一样。 在web应用程序中，以浏览器端发送请求数据包，服务器端返回响应包为主要特点。 其中请求和响应内容都必须遵守一定的规定，即HTTP通信协议的要求 当服务器端向客户端返回响应之后，整个连接即会关闭。所以他是一种无状态的连接。        2).why? 要真正理解Web的工作原理，必须彻底理解HTTP协议！因为我们的服务器端编程主要是处理请求信息，并向客户端返回处理之后的响应。   2.HTTP处理流程（无状态）——通信原理   3.服务器的缺陷 a)         当我们访问一个在服务器端存在的文件的时候，服务器端能够找到该文件并将它里边的信息读取出来并封装到请求体里，以消息体的形式返回给客户端。这种在服务器端存在的文件，我们称之为静态文件。 b)        问题?              当我们想访问服务器不存在的文件的时候，比如：用户登录后的用户信息（这些信息不可能以静态文件的形式存在），而且必须和数据库交互。这个时候静态文件服务器就无能为力了。 c)         解决方法              为web服务器，配一个辅助应用程序。该程序主要完成对用户请求的非静态文件动态生成消息体内容。这种通过web端辅助应用程序生成的文件我们称之为动态文件。   4.辅助应用程序之CGI（Common Gateway Interface） a)         它最大的好处是可以用不同的程序语言来生成动态文件。如C、PHP、Delphi等 b)        缺陷？                     服务器端的CGI程序为每个请求开启一个进程，对服务器端资源消耗比较大。 c)         解决方案 i.          线程，为每个请求开启一个线程，这样服务器端资源消耗会小的多。 ii.        在Java方面，为了解决这个问题，产生了web容器（servlet容器）。它作为一个服务器端的辅助应用程序解决了CGI面临的缺陷。 iii.      Servlet概貌（Web容器管理） 1.         没有main方法 2.         常规的java代码，新的servlet API 3.         主要负责处理请求和响应，比如用户登录：接受客户端发送的登录数据，连接数据进行数据验证。以响应的形式返回处理后的结果。 4.         通过Servlet容器对Servlet进行处理和调用 5.         Web服务器和Servlet容器之间再进行数据交互，最后由web服务器将结果返回给客户端。   5.Servlet容器 a)         职责 i.          负责管理和运行Servlet b)        支持 i.          多线程 ii.        管理Servlet生命周期 iii.      JSP支持 iv.       与web服务器通信 v.         安全性（隐私数据保护，如：有些文件不希望客户端能够浏览） c)         好处： i.          当Servlet容器对为Servlet提供了上述支持后，我们能够将更多的精力放在业务逻辑处理上。   6.Servlet规范 a)         当这种Servlet容器盛行之后，出现了很多web应用服务器，他们集成了Servlet容器的功能，但一个Servlet能够运行在众多的不同的第三方的Servlet容器产品上，就势必要对Servlet容器有一个规范（约定），如必须要有上述的功能支持。只有这样，同一个Servlet web系统才能在不同的Servlet容器产品上运行。 b)        集成了Servlet容器的web应用服务器 i.          Tomcat、Jboss、WebLogic、WebSphere、Oracle AS ii.        Tomcat作为开源免费且稳定的Servlet容器，受到了广大开发人员的喜爱。 iii.      而我们也以Tomcat作为教学和个人web系统开发   7.Servlet和web容器配合 a)         Web容器为每个对servlet的请求都开启一个线程，web容器同时负责管理servlet的生命周期和它的运行。 b)        当一个请求到来的时候，web容器负责将请求以对象的方式（请求体）传递给servlet，当servlet处理完请求后（servlet运行结束），由web容器刷新响应对象，并将该对象返回给web服务器，由web服务器返回给客户端。     8.Java Web应用程序的组成 a)         规范规定Java Web应用程序主要由如下部分组成 i.          配置文件（web.xml） ii.        静态文件和JSP iii.      类文件和包 (Servlet类对应的字节码class文件，Servlet API 所需要的jar包) b)        部署一个java web应用到Tomcat i.          首先介绍Tomcat的文件目录即相关配置文件 ii.        打包和部署java web应用 iii.      启动Tomcat并访问java web应用程序    ","title":"Oracle培训（四十一）——Servlet第一章知识点总结——Web工作原理"},{"content":"字符编码这个东西，一旦和中文打上交道就不可避免出现乱码，今天项目用到了JQuery向ashx提交中文参数的这一块，折腾了一天，开始是各种乱码，最后中算弄好了。 客户端： //异步获取数据var tpAction=action+'getSearch.ashx?key='+encodeURIComponent('中国');        \t\t\t\t\t$.getJSON(tpAction,function(rsp){//请求成功        \t\t\t\t\t\t\tif(rsp.status=='1'){\t\tvar list=rsp.item;\t\tvar len=list.length;\t\t\t\t\t\t        \tif(len==0){\t\t\t//没有数据直接返回             \t\t\t\t\t\t        \t\tsetNull();\t\t\treturn;        \t}\t\t\t\t\t\t        \t//组装数据\t\t\t        \t        \tvar s=zy_tmpl(templ,list,len);        \t\t\t\t\t\t        \t$list.append(s);        \t}else{        \t\talert('','加载数据失败，请重试','确定');\t\t\t\t\t        \t}        \t\t\t\t\t        },'json',function(err){//请求失败        \talert('','加载失败，请检查网络设置！','确定');        \t\t\t\t\t     },'POST',''); 服务器端：         string keyy = context.Request[\"key\"];        if (keyy != null)        {            string key = HttpUtility.UrlDecode(context.Request[\"key\"].ToString());            //string key = context.Server.HtmlDecode(context.Request.Params[\"key\"].ToString());            string log = \"getSearch.ashx?key=\" + key;            string logsql = \"insert into logs(createtime,contents) values('\" + DateTime.Now.ToString() + \"','\" + log + \"')\";            Sqlbase.ExecuteNonQuery(CommandType.Text, logsql, null);                        //more            string sql = \"select * from news where title like '%\" + key + \"%' order by id desc\";            DataTable dt = Sqlbase.ExecuteTable(CommandType.Text, sql, null);            result rs = new result();            rs.status = 1;            rs.msg = \"成功\";            rs.item = dt;            string strJson = Newtonsoft.Json.JsonConvert.SerializeObject(rs);            context.Response.Clear();            context.Response.ContentEncoding = Encoding.UTF8;            context.Response.ContentType = \"application/json\";            context.Response.Write(strJson);            context.Response.Flush();            context.Response.End();        } 这里根本就没有进行什么编码设置，其实就是JS用encodeURIComponent()对中文字符串编码，C#用HttpUtility.UrlDecode(context.Request[\"key\"].ToString())进行解码，是不是很简单呢！可是我一天的实践证明：JS端用encodeURIComponent()要比escape()好多了，至于区别大家可以google一下，C#的解码函数也一堆，像什么Server.UrlDecode之类的，但是推荐使用HttpUtility.UrlDecode()，好处大家同样也可以google！","title":"JQuery向ashx提交中文参数方案"},{"content":"cast(@SmsContent as numeric(18,0))","title":"Sql Server中字符转换成整型或小数位的函数用法！"},{"content":"       光照和材质的加入使得场景的真实感大大增加，但仅仅这些依然不足以表现出真实世界中物体表面的各种细节。毕竟，材质所能够提供的细节等级仅仅停留在顶点级别上。纹理的引入，使得在像素级别上提供细节成为可能，因而可以进一步大大提高物体的真实感。          1. 纹理类型        一般情况下，纹理可以看成是一个二维的数组（这里只讨论二维纹理，一维纹理和三维纹理暂时不讨论），数组中每个元素可以具有不同的数据类型，代表不同的意义。根据元素的类型，纹理可以分为如下几种：           1.1 普通纹理贴图           这种纹理的每个元素代表一个颜色值，可以是3维向量(RGB)或4维向量（RGBA），分别代表颜色值中的红、绿、蓝成分，对于32位颜色值，还有代表透明度的第4个成分。这种纹理是最常见的一种类型，通过把现成的图片贴在物体表面，来增加物体的真实度。           1.2 法线贴图           这种纹理的每个元素代表一个法线，即一个3维向量（位于切线空间Tangent Space：TBN），代表物体表面各处的法线值。这种纹理主要用于法线映射（Normal Mapping）技术中，通过贴图来直接修改物体表面的法线，从而模拟表面的凹凸细节。           1.3 高度图           这种纹理的每个元素代表一个高度值。一个常见的用途即地形渲染，地形渲染中用到的雏形是一个平面的网格，然后通过读取高度图来获取网格不同位置的高度信息（大多数情况下，对读取到的高度值，会再乘以一定的系数来满足所需的高度范围）。另一个用途是Displacement Mapping，配合曲面细分技术，可以修改物体表面的顶点位置，从而实现表面的凹凸细节。通过D3D11新增的Tessellation Stage来实现Displacement Mapping在以后会有专门的例子。           当然，纹理的用途不仅仅这些。我们需要知道的是，提到纹理，不能仅仅认为它就是一个贴在物体表面的图片。不过，在这篇文章中，作为一个纹理的简介，我们仅仅考虑纹理最常见的一个用途，其他高级纹理技术在我们后面学到时会详细介绍。          2. 纹理坐标        对于最常见的二维纹理，纹理坐标用一个二维向量（u,v）表示。在D3D11中，以贴图的左上角为原点，u相对于贴图水平向右，v相对于贴图垂直向下。如下图所示：        该坐标空间我们称之为纹理空间。为了让纹理坐标能够与贴图的尺寸无关，纹理坐标u和v被限制在0到1之间，左上角为(0,0)，右上角为(1,0)，左下角为(0,1)，右下角为(1,1)。这样，我们在给顶点指定纹理坐标时，不需要考虑贴图的大小。无论是一张256*256，还是1024*1024的贴图，纹理坐标都适用。       正如利用顶点坐标的插值来计算一个三角形内部各点的坐标一样，三角形内部的纹理坐标同样需要插值计算，计算方法与顶点一样。例如对于一个三角形的三个顶点坐标p0,p1,p2，对应的纹理坐标为q0,q1,q2。对于三角形内部一点：（x,y,z) = p0 + s(p1 - p0) + t(p2 - p0)，那么相应的纹理坐标就是：(u,v) = q0 + s(q1 - q0) + t(q2 - q0)。如下图所示：          3. 纹理寻址模式           尽管纹理坐标被限制在0到1之间，但是D3D依然允许我们为顶点指定该区间之外的坐标值。这时，解析该坐标值依赖于不同的纹理寻址模式。D3D支持如下几种寻址模式：           1. Wrap           Wrap模式下，允许贴图在物体表面进行重复。换句话说，当坐标大于1时，通过去除整数成份而得到的坐标值来读取纹理值，当坐标小于0时，通过加上一个最小的正数，使得坐标值大于0，然后利用该值来获取纹理值。这种方法造成的效果，即坐标超出0到1区间时，纹理在物体表面进行重复。如下图所示：           2. Border          Border模式下，我们可以手动指定一个特定的值，当纹理坐标不在0到1区间内时，即使用该指定值。如下图所示（此时指定值为“蓝色”：           3. Clamp           Clamp模式下，当超出正常坐标范围时，使用正常范围[0,1]内与该坐标最近的那个点的纹理值。举个例子，对于坐标(u,v)，如果u>1，v位于[0,1]，则使用[1,v]片的纹理值；同样，如果v>1,u位于[0,1]，则使用[u,1]处的纹理值；如果u,v都>1，则使用[1,1]处的纹理值。如下图所示：           4. Mirror           Mirror模式下，每当纹理坐标越过一个整数值时，使用的纹理与越过整数值之前的纹理成镜像关系。下图可以直观地说明：          4. 纹理过滤        由于纹理实际上是由多个离散的颜色值组成的，因此，对于一张256*256尺寸的纹理，如果它正好投影在屏幕上256*256尺寸的区域内，那么一个像素对应一个纹理值，这是最理想的情形。但是，当这些颜色值与屏幕上的像素不能够一一对应时，如何计算特定像素处的颜色值？在这种情况下，就需要用到纹理过滤。设想如下两种情形：        1. 当照相机与一张纹理不断靠近时，即使该纹理尺寸远小于屏幕，当距离足够近时，该纹理也有可能投影在整个屏幕上。这时，纹理上的一个元素将覆盖很多个屏幕像素。        2. 当照相机不断远离时，纹理在屏幕上的投影会越来越小，当距离足够远时，有可能带个纹理会投影在一个屏幕像素内。        在这两种情况下，如果计算纹理在屏幕投影范围内对应各个像素的值，即需要纹理过滤。        纹理过滤分为两种：一种为放大，即Magnification; 一种为缩小，即Minification。当一个纹理元素覆盖屏幕上多个像素时，使用的过滤为Magnification，对应于上述第一种情形；当多个纹理元素投影在一个屏幕像素内时，使用的过滤为Minification，对应于上述第二个例子。        4.1 Magnification        考虑一张256*256的纹理，它投影在屏幕上1024*1024范围的空间内。这时，平均一个纹理值覆盖4*4个屏幕上的像素。由于这4*4个像素位于同一个纹理值处，如何决定它们各自的颜色值？D3D提供了如下几种过滤方法：           1. 取最近点（Nearest Point）           这是最快速也是最简单的方法。利用该方法，对于任一像素对应的纹理坐标值，取距离最近的纹理值。比如对于u = 0.126,它对应于纹理上0.126*256 = 32.38的位置，这时最近的位置为32。同理，如果一个像素对应纹理上(80.6,60.2)的位置，则选取(81，60)处的纹理值作为结果。           2. 线性过滤（Linear）           在该方法中，通过与该坐标值最近的4个纹理值进行插值来计算最终颜色值。以一个一维的纹理作为例子，比如对于坐标60.6，首先获取60和61处的两个颜色值C60,C61，然后对它们进行插值来计算最终颜色：C = 0.4*C60 + 0.6*C61。同理，对于二维纹理，需要在u、v方向上进行两次插值，如下图所示例子：        我们要计算c处的纹理值，与c最近的两处分别为Ci,j，Ci,j+1，Ci+1,j，Ci+1,j+1。C在u方向上距离左、右两边的点相对距离分别为0.75和0.25，在v方向上距离上、下两边相对距离分别为0.38和0.62。因此首先在u方向上进行插值计算Ct = 0.25*Ci,j + 0.75*Ci,j+1，Cb = 0.25*Ci+1,j + 0.75*Ci+1,j+1。然后在v方向上对Ct和Cb进行插值，C = 0.62*Ct + 0.38 * Cb。即最终的颜色值。        4.2 Minification        现在来讨论相反的情况。在Minification情况下，多个纹理元素被投影在屏幕上同一个像素位置。比如一个1024*1024的纹理，投影在屏幕上256*256范围的空间内，这样平均每个像素覆盖4*4个纹理值。这种情况下，最流行的过滤方法称为Mipmaping。在该方法中，使用到一个Mipmap链。Mipmap链是原纹理组成的一个数组，数组中第一个纹理为原始纹理，后面的第一个纹理在u、v尺寸上为上一个纹理的一半，依次计算，直接纹理尺寸为1为止。如下图所示：        这样，在运行时，硬件会先把合适的纹理为解决该问题。在Mipmap连中选择合适的纹理同样有两种方法：Point Filtering和Linear Filtering。        1. 使用Point Filtering方法时，硬件会根据多边形在屏幕上投影的尺寸选择最接近的纹理，然后在该纹理上再继续利用Point Filtering或Linear Filtering计算颜色值，作为最终颜色值。        2. 使用Linear Filtering方法时，硬件会选出最接近的两个纹理，然后分别在该两个纹理上利用Point Filtering或Linear Filtering计算颜色值，最终再把两个颜色值进行插值，作为最终结果。           4.3 各向异性过滤（Anisotropic Filtering）        此外还有一种更高级的过滤方法称为各向异性过滤。 这种方法可以更好地解决如下问题，即当物体表面的法线与视线接近90度时的情形。比如水平方向上观察一个立方体的顶部，如下图所示： 左边为使用线性过滤的结果，右边为使用各向异性过滤的结果。这种方法效果最好，当然也最昂贵。          5. 纹理坐标变换        如果位置坐标一样，顶点的纹理坐标一样可以进行各种变换，比如平移、伸缩、旋转等。尽管多大数情况下，我们直接使用初始指定的纹理坐标来提取纹理值，但在一些情况下，通过对纹理坐标进行变换，可以实现一些特殊的效果：        1. 通过使用伸缩变换，可以让纹理沿多边形进行重复。比如一张砖块纹理贴在墙上，顶点纹理坐标位于[0,1]之间的坐标，通过u或v方向上5倍的变换后，将位于[0,5]之间，这样纹理将在墙上被重复5次。可以任意地调整伸缩的实数来实现不同的要求。        2. 通过平移变换，可以让纹理坐标沿特定方向进行平移，从而实现诸如云彩飘动、水流等效果        总之，纹理坐标变换可以在很多场合使用，实现有趣的动画效果。          6. 在D3D11中使用纹理         好了，现在可以来学习D3D11中关于纹理使用的知识了。        在D3D11中，二维纹理对应的接口为ID3D11Texture2D。在前面介绍3D渲染管线时提到过，一个纹理可以在管线的多个阶段使用，且使用前需要先绑定到相应的阶段。此外，真正绑定到管线上的并不是纹理本身，而是相应的视图(View)。在C++程序和Effect中使用纹理的方法如下：         6.1 C++程序        在C++程序中，通过读取图片使用纹理的过程如下：        1. 创建纹理        2. 创建相应阶段的视图        一般情况下，这两步可以通过一个函数实现，该函数原型如下：  HRESULT  D3DX11CreateShaderResourceViewFromFile(  __in   ID3D11Device *pDevice,  __in   LPCTSTR pSrcFile,  __in   D3DX11_IMAGE_LOAD_INFO *pLoadInfo,  __in   ID3DX11ThreadPump *pPump,  __out  ID3D11ShaderResourceView **ppShaderResourceView,  __out  HRESULT *pHResult);        pDevice为渲染设备接口指针；        pSrcFile为纹理文件目录；        pLoadInfo负责以特定的格式来读取纹理，如果遵从纹理本身的尺寸、格式等全部信息，则可以设为NULL；        pPump用来另创建一个线程来读取纹理，我们学习过程中只用单个线程，因此这个设为NULL；        ppShaderResourceView即要创建的视图指针的地址；        对于pHResult，如果pPump为NULL，则这个也为NULL。        整个调用如下所示： \tD3DX11CreateShaderResourceViewFromFile(m_d3dDevice,L\"Texture/Wood.dds\",0,0,&m_texView,0)        调用完该函数，指定的纹理视图就产生了。        此外，为了能够将纹理资源传递到Effect中，需要一个指向相应的Effect全局变量的接口：ID3DX11EffectShaderResourceVariable。创建好该接口后，通过调用将相应的函数：ID3DX11EffectShaderResourceVariable::SetResource(ID3D11ShaderResourceView **ppResource)，从而把创建好的纹理视图赋给Effect中的变量。 \tm_fxTex = m_fx->GetVariableByName(\"g_tex\")->AsShaderResource();\tm_fxTex->SetResource(m_texView);            6.2 Effect程序        在Effect中，对应于二维纹理资源的类型为Texture2D。注意纹理资源不能与其他全局变量一样声明在cbuffer中！ \t//纹理\tTexture2D g_tex;        在Effect中，可以通过SamplerState结构来指定过滤方法。如下： \tSamplerState samTex\t{\t\tFilter = MIN_MAG_MIP_LINEAR;\t};        该方法即针对Minification、Magnification和Mipmap中纹理的选择全部使用线性过滤方法。此外，还有其他方法可以选择：        MIN_LINEAR_MAG_MIP_POINT：Minification使用线性方法，Magnification和Mipmap选取使用最近点（Point）方法；        MIN_POINT_MAG_LINEAR_MIP_POINT：Minification使用Point方法，Magnification使用线性方法，Mipmap选取使用Point方法；        等等。从中可以看出规律，对于MIN、MAG和MIP，可以分别指定相应的方法（Point或Linear），这样就很容易记住各种参数的命名了。如果需要查看所有Filter参数，可以查看SDK中的D3D11_FILTER部分。        此外，使用各向异性过滤方法如下： \tSamplerState samp\t{\t\tFilter = ANISOTROPIC; \t\tMaxAnisotropy = 4;\t};        此时，除了指定各向异性方法外，还需要指定其最高级别，即1到16。等级越高，效果越好，速度当然也越慢。        当然，纹理的引入，顶点的信息也要发生相应的改变，我们需要加入纹理坐标，这时的顶点结构如下： //输入顶点信息：位置坐标、法线、纹理坐标struct VertexIn{\tfloat3\tpos:\tPOSITION;\tfloat3\tnormal:\tNORMAL;\tfloat2\ttex:\tTEXCOORD;};//输出顶点信息struct VertexOut{ \tfloat4 posH: SV_POSITION; //投影后坐标 \tfloat3 pos: POSITION;  //世界变换后坐标 \tfloat3 normal: NORMAL;   //世界变换后法线\tfloat2 tex: TEXCOORD;  //纹理坐标};        在顶点着色器中也需要添加针对纹理坐标相应的操作，如下（这里未对纹理坐标进行变换，而是直接使用指定的坐标）： VertexOut VS(VertexIn vin){\tVertexOut vout;\tvout.posH = mul(float4(vin.pos,1.f),g_worldViewProj);\tvout.pos = mul(float4(vin.pos,1.f),g_world).xyz;\tvout.normal = mul(vin.normal,(float3x3)g_worldInvTranspose);\tvout.tex = vin.tex;\treturn vout;}        在像素着色器中，使用纹理资源的函数为：Texture2D::sample(SamplerState samper, float2 texcoord)。如下： //设置过滤SamplerState samTex{\tFilter = MIN_MAG_MIP_LINEAR;};float4 texColor = g_tex.Sample(samTex,pin.tex);          D3D11中纹理的基本使用就这些，下面是这次的示例程序，实现一个基本纹理+光照的效果。        在程序中，通过按‘1’和‘2’来关闭、打开光照（这次例子中使用的是聚光灯）。关闭光照的情况下，物体表面的颜色值只由纹理决定；在打开光照的情况下，纹理颜色和光照计算结果通过如下公式得出：        finalColor = texColor * (ambient + diffuse) + specular        finalColor.a = texColor.a * g_material.diffuse.a        即纹理颜色与环境光和漫反射光的和相乘，再加上全反射光。最终的alpha值通过纹理alpha值与材质的漫反射部分的alpha值相乘。        当然，这只是一种最常用的方法之一，在编写着色器代码，没有哪一种方法是最好的，只要适合自己的需求即可。这也是可编程管线给程序员带来的灵活性的体现。        以下是示例程序的源代码：        纹理使用基础示例代码          ","title":"【D3D11游戏编程】学习笔记十四：纹理基础"},{"content":"<insert id=\"insert\" parameterClass=\"com.xx.center.entity.Organization\" >  \t <selectKey resultClass=\"long\" keyProperty=\"id\" type=\"pre\">      SELECT SEQ_ORDER_ORG_ID.NEXTVAL AS id FROM DUAL    <\/selectKey>    insert into ORGANIZATION (ID, NAME, URL, CODE, STATUS, REG_TIME, TYPE, MEMO)    values (#id:DECIMAL#, #name:VARCHAR#, #url:VARCHAR#, #code:VARCHAR#, #status:DECIMAL#,      #regTime:TIMESTAMP#, #type:DECIMAL#, #memo:VARCHAR#)  <\/insert> 自增长字段中 有个  type属性 值为 pre ：表示 在执行插入之前 先执行 select语句  否则，你在insert中加入了 自增长字段时，会报错。。。。","title":"mybatis中关于自增长字段"},{"content":"好久没有写博客了，到年底了，很多杂事，都没有办法静下心来学习，现在就 期盼着放假，能够有一个安静的一段时间好好做一些自己想做的事情。 发一个前两天自己写的QQ程序。 完全仿照QQ2012写的，皮肤完全是贴图上去的。 这个QQ是基于TCP/IP写的，可能与Q的技术不一样，但是同样能够实现远程多人登陆相互聊天。 没有加数据库，只是简单的写了一下，还有许多BUG，但是基本上能够实现登陆，聊天面板，聊天窗口，还有窗口振动的功能。   代码就不上了，写的比较乱，而且没有对数据封装，数据的传递全部都是以报头命令的形式传递的。 主要的难点我认为还是在保证通信的校验上，这方面我没有做任何测试，因为我都是在本机上测的，由于没有静态ip，只能在机房测一测。 除了聊天 震动，其他没有任何功能，以后有需要再扩充吧。 又是一年，这一年过的真快。","title":"QQ聊天程序"},{"content":"　　系统静态图:从字面意思来理解,显而易见的:是UML中从系统静态角度来描述的系统.主要包括类图,对象图,包图三种.系统静态图主要是相对于系统动态图(活动图,状态图,交互图而言)而言.  　　类图(Classdiagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等.从类图的组成上看,系统中的每个类都有名称,属性,方法等.其中的属性有具有可见性,范围,抽象性,多重性等特点.从类与类之间的关系来讲,最基本的四种关系:关联关系,依赖关系,泛化关系。 　　关联关系:Association关联关系表现为变量(has a )。描述了两个或多个类之间的结构性关系.给定关联的2个类，可以从其中的一个类的对象访问到另一个类的相关对象。例如如果A依赖于B，则B体现为A的全局变量。在UML图中，关联关系用一条实线来表示。 　　关联关系有双向关联和单向关联。双向关联：两个类都知道另一个类的公共属性和操作。单向关联：只有一个类知道另外一个类的公共属性和操作。大多数关联应该是单向的，单向关系更容易建立和维护，有助于寻找可服用的类。同时关联中还有两种类型:一种是组合,一种是聚合.对于二者区别:组合描述的是子类和父类的依赖关系，没父类就没有子类；而聚合则不是严格的依赖关系.例如:火车与发动机关系式聚合，一个引擎可以属于一个活多个火车，引擎可以脱离火车而存在。链表和节点的关系是组合，节点必须属于一个链表，节点不能脱离链表而存在. 　　依赖关系:表现为函数中的参数(usea)。依赖是一种使用关系,它表明了一个事务规格说明的变化会影响到使用它的另一个事务,反之未然.依赖关系用一根带箭头的虚线表示，箭头直线被依赖的类.例如如果A依赖于B，则B体现为局部变量，方法的参数、或静态方法的调用。 　　泛化关系:Generalization(泛化)表现为继承或实现关系(isa)。具体形式为类与类之间的继承关系，接口与接口之间的继承关系，类对接口的实现关系。 　 　　对象图:对象图(ObjectDiagram)描述的是参与交互的各个对象在交互过程中某一时刻的状态。对象图可以被看作是类图在某一时刻的实例。在UML中，对象图使用的是与类图相同的符号和关系，因为对象就是类的实例。下图显示了对象图的模型。其中节点可以是对象也可以是类，连线表示对象之间的关系.如前面所说的那样,对象图是类图在某一时刻的具体的实例化,那么我们可以这样理解,对象图具有类图所具有的属性,事件和方法等. 　　对象图的作用:              ·   捕获实例和连接 　　· 在分析和设计阶段创建 　　· 捕获交互的静态部分 　　· 举例说明数据/对象结构 　　· 详细描述瞬态图 　　· 由分析人员、设计人员和代码实现人员开发   　　包图:包可直接理解为命名空间，文件夹，是用来组织图形的封装，包图可以用来表述功能组命名空间的组织层次。在面向对象软件开发的视角中，类显然是构建整个系统的基本构造块。但是对于庞大的应用系统而言，其包含的类将是成百上千，再加上其间“阡陌交纵”的关联关系、多重性等，必然是大大超出了人们可以处理的复杂度。这也就是引入了“包”这种分组事物构造块。  •包的作用是： 1）对语义上相关的元素进行分组； 2）定义模型中的“语义边界”； 3）提供配置管理单元； 4）在设计时，提供并行工作的单元； 5）提供封装的命名空间，其中所有名称必须惟一 •包的构成:类,接口,构件,用例 •包之间的关系:泛化，细化，继承","title":"UML总结——系统静态图"},{"content":"第一百零一篇博文了哟~ 比赛的时候直接看D和E了，结果都没做出来，我这个大水货。 A题  ： 水题，满足整除其实就是余数为0 B提  ： 模拟题 C题  ： 逆着恢复原来的数列就好了（不断的减一），直到碰到0就停止，当然不能模拟 D题 ：  给你一棵黑白树的每个点的颜色，以及这个点周围所有边的权值和，让你还原这棵树。 将白点和黑点排成两排，按照权值从小到大，每次都从端点建边，边的权值为两个点权值（题目给的权值）的最小值，然后可知有一个点还有权值剩余，继续从这个点出发向另一排点的下一个点连边，这样子到最后肯定能构造出一棵满足条件的树来。因为 1 ： 每次连边都是在两排点的端点，不会产生交叉边，有环的前提是有交叉边，到最后肯定能连n-1条边，然后又是无环的，肯定是棵树喽 2 ：白点的权值和与黑点的权值和是相等的，而每次连边，双方都会减少相同的权值，最后一次连边肯定会消耗相同的权值，因为前面都是一样的 E题：给你10W个点，在给你9个数，问你能否用两条横线和两条竖线将这10w个点分成九块，每一块的点数会对应这九个数的某个排列，如果能，输出这四条线 显然，可以暴力枚举排列，然后验证是否可行，考虑到不用每一块都去验证，可以先快速判断一下三行三列的数目是否合法，这个将x和y分别处理出来就可以在O(1)时间做到，然后这样子如果还是合法，就需要验证每个小块是否合法，也不用求九个，只要左下角的四个就可以了，问题转换为了求一个矩形区域内点的个数，比赛的时候想到用线段树，但是一直想不到怎么求一个区间内（下标）有多少个点的y值是小于等于一个值的，以前好像听说过这种好几维的东东可以用树套树来做，不过一直拖着没去做过，可能这道题要实现的操作比较简单，只要求某一维小于等于一个数的点有几个就可以（可以二分求），所以可以用一棵线段树搞定，不过线段树的每个节点必须要记录该节点表示的区间内的所有的y值，并排好序，所以这样子的话预处理的复杂度就是n logn logn  空间复杂度为n logn ,总的时间复杂度是，(nlogn*logn + 9! * logn * logn ) 可能由于前面的三行三列的判断是很有效的吧，代码的速度还挺快的 戳这里看代码","title":"Codeforces Round #158 (Div. 2) （完全）"},{"content":"因为保证有解，所以尽可能去构造就可以了。 每次在一个节点上连尽可能多的边。 #include <cstdio>#include <cstring>#include <algorithm>using namespace std;const int MAXN = 100005;struct Node{    int index, sum;} black[MAXN], white[MAXN];int blackNum, whiteNum;int main(){    int n, color;    while(~scanf(\"%d\", &n))    {        blackNum = whiteNum = 0;        for(int i=1;i<=n;++i)        {            scanf(\"%d\", &color);            if(color)            {                black[blackNum].index = i;                scanf(\"%d\", &black[blackNum].sum);                ++ blackNum;            }            else            {                white[whiteNum].index = i;                scanf(\"%d\", &white[whiteNum].sum);                ++ whiteNum;            }        }        for(int i=0,j=0;j<whiteNum;)        {            for(;black[i].sum>=0&&j<whiteNum;++j)            {                if(black[i].sum >= white[j].sum)                {                    printf(\"%d %d %d\\n\", black[i].index, white[j].index, white[j].sum);                    black[i].sum -= white[j].sum;                }                else                {                    printf(\"%d %d %d\\n\", black[i].index, white[j].index, black[i].sum);                    white[j].sum -= black[i].sum;                    black[i].sum = -1;                }            }            ++ i, -- j;            for(;white[j].sum>=0&&i<blackNum;++i)            {                if(white[j].sum >= black[i].sum)                {                    printf(\"%d %d %d\\n\", white[j].index, black[i].index, black[i].sum);                    white[j].sum -= black[i].sum;                }                else                {                    printf(\"%d %d %d\\n\", white[j].index, black[i].index, white[j].sum);                    black[i].sum -= white[j].sum;                    white[j].sum = -1;                }            }            --i, ++ j;        }    }    return 0;}","title":"CF260D Black and White Tree"},{"content":"前面一节介绍了Noir如何非常方便的创建一个web app，但是我的实际一个项目的需求中只需要REST API开发，页面部分都交给了html和Javascript，并不需要Noir在后台渲染网页。 同样无需重新启动程序，在src目录下创建rest目录，里面有一个test.clj文件： $ tree.├── models├── rest│   └── test.clj├── server.clj└── views    ├── common.clj    └── welcome.clj test.clj文件内容如下： (ns my-website.rest.test  (:require [my-website.views.common :as common]            [noir.content.getting-started])  (:use [noir.core :only [defpage]]))(defpage \"/rest/get\" []         (common/layout           [:p \"get\"])) 同时在serer.clj文件中添加一行： (server/load-views-ns 'my-website.rest.test)注意namespace my-website.rest.test中rest对应rest目录，test对应test.clj文件。 然后通过浏览器访问http://localhost:8080/rest/get 可以看到返回的是get字符串。这个最简单的rest api已经有了。 defpage宏定义了URL的路由，默认是处理http get请求的。 文档参考：http://www.webnoir.org/autodoc/1.3.0/noir.core.html#var-defpage (defpage & args)Adds a route to the server whose content is the the result of evaluating the body.The function created is passed the params of the request and the destruct param allowsyou to destructure that meaningfully for use in the body.There are several supported forms:(defpage \"/foo/:id\" {id :id})  an unnamed route(defpage [:post \"/foo/:id\"] {id :id}) a route that responds to POST(defpage foo \"/foo:id\" {id :id}) a named route(defpage foo [:post \"/foo/:id\"] {id :id})The default method is GET.由于我们不需要渲染网页，现在简化一下test.clj文件的代码： (ns my-website.rest.test  (:require [noir.content.getting-started])  (:use [noir.core :only [defpage]]))(defpage \"/rest/get\" [] \"get\")现在，去掉了views.common的使用。解释： 1. 第一个参数\"/rest/get\" 是这个rest api的URL 2. 第二个参数 [ ] 是http 请求的参数，这里暂时没有使用 3. 第三个参数\"get\"是http response的响应内容  现在演示一下如何获得http get请求的参数，比如浏览器输入：http://localhost:8080/rest/freebird freebird就是参数，修改test.clj代码如下： (defpage \"/rest/:id\" {:keys [id]} (str \"user id: \" id))第二个参数将第一个参数的:id绑定到id上， 第三个参数使用id的值组成response的字符串。 最后返回： user id: freebird 也可以很方便的处理post请求，具体参考文档： http://www.webnoir.org/tutorials/routes/","title":"用Clojure编写REST service 二 Noir创建Rest API"},{"content":"流信道有两个变体：SocketChannel和ServerSocketChannel。像其对应的Socket一样，SocketChannel是相互连接的终端进行通信的信道。 SocketChannel:创建，连接和关闭 static SocketChannel open(SocketAddress remote) static SocketChannel open() boolean connect(SocketAddress remote) boolean isConnected() void close() boolean isOpen() Socket socket() 调用SocketChannel的静态工厂方法open()可以创建一个实例。open()方法的第一种形式以SocketAddress（见第2章）为参数，返回一个连接到指定服务器的SocketChannel实例。注意，该方法可能会无限期地阻塞下去。open()的无参数形式用于创建一个没有连接的SocketChannel实例，该实例可以通过调用connect()方法连接到指定终端。当使用完SocketChannel后，需要调用close()方法将其关闭。有一点很重要，即每个SocketChannel实例都\"包裹\"了一个基本Java Socket，并可以通过socket()方法对该Socket进行访问。这就可以通过基本的Socket方法进行绑定、设置套接字选项等操作。一个SocketChannel的创建、连接和关闭的例子，见TCPEchoClientNonblocking.java（第113-114页）。  在创建并连接SocketChannel后，就可以调用该信道的读写方法进行I/O操作。  SocketChannel:读和写 int read(ByteBuffer dst) long read(ByteBuffer[] dsts) long read(ByteBuffer[] dsts, int offset, int length) int write(ByteBuffer src) long write(ByteBuffer[] srcs) long write(ByteBuffer[] srcs, int offset, int length)  读操作的最基本形式以一个ByteBuffer为参数，并将读取的数据填入该缓冲区所有的剩余字节空间中。另一种形式以多个ByteBuffer为参数（ByteBuffer数组），并根据其在数组中的顺序，将读取的数据依次填入每个缓冲区的剩余字节空间中。这种方法称为散射式读，因为它将读入的字节分散到了多个缓冲区中。需要注意重要的一点，散射式读不一定会将所有缓冲区填满，这些缓冲区的总空间大小只是一个上限。 写操作的最基本形式以一个ByteBuffer为参数，并试图将该缓冲区中剩余的字节写入信道。另一种形式以一个ByteBuffer数组作为参数，并试图将所有缓冲区中的剩余字节都写入信道。这种方法称为聚集式写，因为它把多个缓冲区中的字节聚集起来，一起发送出去。读 写操作的例子见TCPEchoClientNonblocking.java和TCPServerSelector.java。 与其对应的ServerSocket一样，ServerSocketChannel是用来侦听客户端连接的信道。 ServerSocketChannel: 创建，接受和关闭 static ServerSocketChannel open() ServerSocket socket() SocketChannel accept() void close() boolean isOpen() 调用静态工厂方法open()可以创建一个ServerSocketChannel实例。每个实例都包裹了一个ServerSocket实例，并可以通过socket()方法对其访问。正如前面的例子所表明的，必须通过访问底层的ServerSocket实例来实现绑定指定端口，设置套接字选项等操作。在创建了信道实例并绑定端口后，就可以调用accept()方法来准备接收客户端的连接请求。连接成功则返回一个新的已连接的SocketChannel。在用完ServerSocketChannel后，需要调用close()方法将其关闭。使用ServerSocket的例子见TCPServerSelector.java（第116-117页）。 如前文提到的那样，阻塞式信道除了能够（必须）与Buffer一起使用外，对于普通套接字来说几乎没有优点。因此，可能总是需要将信道设置成非阻塞式的。  SocketChannel, Server SocketChannel:设置阻塞行为 SelectableChannel configureBlocking(boolean block) boolean isBlocking() 通过调用configureBlocking(false)可以将SocketChannel或ServerSocketChannel设置为非阻塞模式。configureBlocking()方法将返回一个SelectableChannel，它是SocketChannel和ServerSocketChannel父类。  考虑为SocketChannel设置连接的情况。如果传给SocketChannel的工厂方法open()一个远程地址，对该方法的调用则将阻塞等待，直到成功建立了连接。要避免这种情况，可以使用open()方法的无参数形式，配置信道为非阻塞模式，再调用connect()方法，指定远程终端地址。如果在没有阻塞的情况下连接已经建立，connect()方法返回true；否则需要有检查套接字是否连接成功的方法。 SocketChannel:测试连接性 boolean finishConnect() boolean isConnected() boolean isConnectionPending() 对于非阻塞SocketChannel来说，一旦已经发起连接，底层套接字可能即不是已经连接，又不是没有连接，而是连接\"正在进行\"。由于底层协议的工作机制（见第6章），套接字可能会在这个状态一直保持下去。finishConnect()方法可以用来检查在非阻塞套接字上试图进行的连接的状态，还可以在阻塞套接字建立连接的过程中阻塞等待，直到连接成功建立。例如，你可能需要将信道配置成非阻塞模式，通过connect()方法发起连接，做完一些其他工作后，又将信道配置成阻塞模式，然后调用finishConnect()方法等待连接建立完成。或者可以让信道保持在非阻塞模式，并反复调用finishConnect()方法，如TCPEchoClientNonblocking.java中所示。 isConnected()用于检查套接字是否已经建立了连接，从而避免在进行其他操作时抛出NotYetConnectedException异常（如调在用read()或write()时）。还可以使用isConnectionPending()方法来检查是否有连接在该信道上发起。知道是否有连接发起是必要的，因为如果没有的话，finishConnect()方法将抛出NoConnectionPendingException异常。   相关下载： Java_TCPIP_Socket编程(doc) http://download.csdn.net/detail/undoner/4940239   文献来源： LSOFT.CN(琅软中国)  ","title":"NIO：流（TCP）信道详解"},{"content":"Import语句 使用import语句可以引入包中的类，在编写源文件时，除了自己编写类外，经常需要使用Java 提供的许多类，这些类可能在不同的包中，java提供了130多个包 如: java.applet 包含所有的实现Javaapplet 的类 java.awt 包含抽象窗口工具集中的图形，文本，窗口GUI类 java.awt.image 包含抽象窗口工具集中的图像处理类 java.lang 包含所有的基本语言类 java.io 包含所有的输入输出类 java.net 包含所有实现网络功能的类 java.util 包含有用的数据类型类  import java.applet.Applet;import java.awt.*;public class xiaochengxu extends Applet{  Button  redbutton;  public void init(){  redbutton=new Button(\"我是一个红色的按钮\");  redbutton.setBackground(Color.red);  redbutton.setForeground(Color.white);  add(redbutton);}} 不能使用protected和private修饰类 访问级别的限制 public protected 友好的，private","title":"java课本小例子3"},{"content":"对象的上转型对象 假设B类是A类的子类或间接子类，当用子类B创建一个对象，并把这个对象的应用放到A类的对象中时 A  a； a=new B(); 或 A    a； B  b=new  B(); a=b; 那么，称这个A类对象a是子类对象b的上转型对象 上转型对象特点； 1:上转型对象不能操作子类新增的成员变量（失去这部分属性），不能使用子类新增的方法（失去一些个功能） 2：上转型对象可以操作子类继承或隐藏的成员变量，也可一使用子类继承或重写的方法 3：上转型对象操作子类继承或重写的方法时，就是通知对应的子类对象去调用这些方法 4：可以将对象的上转型对象在强制转换到一个子对象，这时，该子类对象有具有子类的所有属性和功能； class 类人猿{ private int n=100; void crySpeak(String s)  {  System.out.println(s);}} class people extends 类人猿 { void computer(int a,int b) //子类新增的方法，上转型对象不能引用{ int c=a*b; System.out.println(c);} void crySpeak(String s){ System.out.println(\"**\"+s+\"**\");//子类重写父类的方法}}class example6{ public static void main(String args[]){ 类人猿 monkey=new people();  //monkey 是people对象的上转型对象monkey.crySpeak(\"I love this game!\"); people people1=(people)monkey;  //把上转型对象转化为子类的对象people1.computer(10,10);}}","title":"java书中小例子4"},{"content":"class A{public:\tA(){};\tvirtual ~A(){};protected:private:};struct B{\tint a;\tlong b;};void test_typeid(){\tusing namespace boost;\tint_fast_t<char>::fast a;\t\t\t//char 类型的最快类型\tstd::cout << typeid(a).name() << std::endl;\tint_fast_t<int>::fast b;\t\t\t//int 类型的最快类型\tstd::cout << typeid(b).name() << std::endl;\tint_fast_t<uint16_t>::fast c;\t\t//uint16 类型的最快类型\tstd::cout << typeid(c).name() << std::endl;\tA aa;\tB bb;\tstd::cout << typeid(aa).name() << std::endl;\tstd::cout << typeid(bb).name() << std::endl;}运行结果: charintunsigned shortclass Astruct B","title":"【Boost】利用typeid来获取变量的类型"},{"content":"vim中的swp即swap文件，在编辑文件时产生，它是隐藏文件，如果原文件名是data，那么swp文件名就是.data.swp。如果文件正常退出，则此文件自动删除。以下两种情况不会删除swp文件： 1、Vim非正常退出,这种情况下,除非手动删除swp文件（也可以在vim提示时删除），否则它会一直存在。 2、多个程序同时编辑一个文件。 可用vim带-r参数编辑 #vim -r data 然后w保存即可，其中-r代表recovery 最后记得删除.swp文件： #rm -rf .*swp 补充： 可以通过选项禁止产生swp文件 #set noswapfile 参考资料： http://zhidao.baidu.com/question/455983469.html http://www.cnblogs.com/softwaretesting/archive/2011/09/23/2185851.html http://hi.baidu.com/itnote/item/2008b93a6f6d93c7392ffaab","title":"Vim中的swp文件"},{"content":"写一个真正的互联网应用，才可以观察Clojure的威力。 本文使用Noir框架，参考官方站点：http://www.webnoir.org/ 执行三行命令： lein new noir my-websitecd my-websitelein run也可以在lein run命令前运行lein deps命令。 国内网络下载依赖比较痛苦，还好用了proxy，试了好多次，web应用的所有java依赖才下载完成，程序启动成功： ~/my-website$ lein depsRetrieving org/codehaus/jackson/jackson-core-asl/1.9.5/jackson-core-asl-1.9.5.jar (223k)    from http://repo1.maven.org/maven2/chenshu@chenshu-yangzhou-home:~/my-website$ lein runCompiling my-website.serverStarting server...2012-12-29 18:00:00.230:INFO::Logging to STDERR via org.mortbay.log.StdErrLogServer started on port [8080].2012-12-29 18:00:00.231:INFO::jetty-6.1.252012-12-29 18:00:00.312:INFO::Started SocketConnector@0.0.0.0:8080You can view the site at http://localhost:8080#<Server Server@17c2891> 好，现在打开网站：http://localhost:8080，看到下面的网页： 现在打开目录中views/welcome.clj文件： (ns my-website.views.welcome  (:require [my-website.views.common :as common]            [noir.content.getting-started])  (:use [noir.core :only [defpage]]))(defpage \"/welcome\" []         (common/layout           [:p \"Welcome to my-website\"])) 看到URL路径是welcome，好，在浏览器中输入网址：http://localhost:8080/welcome 页面上显示文字： Welcome to my-website 然后修改welcome.clj文件中的显示文字：            [:p \"Welcome to my-website2\"]))保存后，刷新浏览器。页面上文字也变了。 这是Clojure的优点，程序可以在运行时修改。","title":"用Clojure编写REST service 一 Noir创建web app"},{"content":"接口：  java不支持多继承性，即一个类只能有一个父类，单继承性使得java简单，易于管理程序，为了克服单继承的缺点，java使用接口，一个类可以使用多个接口 使用 interface来定义接口 接口体中包含常量定义和方法体定义两部分，接口体中只是进行方法的声明，不允许方法的实现 一个类通过使用关键字implements声明自己使用一个或多个接口，如果使用多个接口，用逗号隔开接口名。如果一个类使用了某个接口，那么这个类 必须实现该接口的所有方法，即这些方法提供的方法体，在类实现接口时必须给出方法体，并且一定要用public来修饰. interface computable  //定义一个接口{ int Max=100; int f(int x);}class china implements computable  //实现这个接口{ int number;public int f(int x)  //不要忘记public关键字{ int sum=0; for(int i=1;i<=x;i++){ sum=sum+i;}return sum;}}class japan implements computable{ int number; public int f(int x){ return 44+x;}}public class example8{ public static void main(String args[]){  china zhang;  japan li; zhang=new china();  li=new japan();zhang.number=991898+computable.Max;li.number=941448+computable.Max;System.out.println(\"number:\"+zhang.number+\"求和\"+zhang.f(100));System.out.println(\"number:\"+li.number+\"求和\"+zhang.f(100));}} xiongyao@xiongyao-Lenovo:~/java编程$ javac example8.java xiongyao@xiongyao-Lenovo:~/java编程$ java example8 number:991998求和5050 number:941548求和5050","title":"java书上小例子6"},{"content":"一、概述     1. Apache POI是Apache软件基金会的开放源码函式库，POI提供API给java程式对Microsoft Office格式档案读和写的功能.     2. 结构         HSSF － 提供读写Microsoft Excel XLS格式档案的功能。         XSSF － 提供读写Microsoft Excel OOXML XLSX格式档案的功能。         HWPF － 提供读写Microsoft Word DOC格式档案的功能。         HSLF － 提供读写Microsoft PowerPoint格式档案的功能。         HDGF － 提供读Microsoft Visio格式档案的功能。         HPBF － 提供读Microsoft Publisher格式档案的功能。         HSMF － 提供读Microsoft Outlook格式档案的功能      二、HSSF代码示例     1.excel结构         HSSFWorkbook     excel文档对象介绍         HSSFSheet         excel的表单         HSSFRow         excel的行         HSSFCell         excel的格子单元         HSSFFont         excel字体         HSSFName         名称         HSSFDataFormat     日期格式         poi1.7中增加以下2项：         HSSFHeader         sheet头         HSSFFooter         sheet尾         HSSFCellStyle    cell样式         辅助操作包括         HSSFDateUtil         日期         HSSFPrintSetup         打印         HSSFErrorConstants    错误信息表     2.代码示例： \t//导包：commons-logging..jar、log4j...jar、poi-..jar\timport java.io.FileOutputStream;\timport java.util.Calendar;\timport java.util.Date;\timport org.apache.poi.hssf.usermodel.HSSFCell;\timport org.apache.poi.hssf.usermodel.HSSFCellStyle;\timport org.apache.poi.hssf.usermodel.HSSFDataFormat;\timport org.apache.poi.hssf.usermodel.HSSFFont;\timport org.apache.poi.hssf.usermodel.HSSFRichTextString;\timport org.apache.poi.hssf.usermodel.HSSFRow;\timport org.apache.poi.hssf.usermodel.HSSFSheet;\timport org.apache.poi.hssf.usermodel.HSSFWorkbook;\timport org.apache.poi.hssf.util.HSSFColor;\tpublic class test {\t\tpublic static void main(String[] args) throws Exception {\t\t\t//创建，存在内存中\t\t\tHSSFWorkbook wb = new HSSFWorkbook();\t\t\tHSSFSheet sheet = wb.createSheet(\"first sheet中文\");\t\t\twb.createSheet(\"second sheet\");\t\t\t\t\t\t//创建行，并存放各种类型数据\t\t\tHSSFRow row = sheet.createRow(0);\t\t\tHSSFCell cell = row.createCell(0);\t\t\tcell.setCellValue(false);\t\t\trow.createCell(1).setCellValue(Calendar.getInstance());\t\t\trow.createCell(2).setCellValue(new Date());\t\t\trow.createCell(3).setCellValue(1234567.987654f);\t\t\tString desc = \"asdfsadfdsafdfasfasdf\";\t\t\trow.createCell(4).setCellValue(new HSSFRichTextString(desc));\t\t\t\t\t\t//格式化数据\t\t\tHSSFDataFormat format = wb.createDataFormat();//创建格式对象\t\t\tHSSFCellStyle style = wb.createCellStyle();//创建样式对象\t\t\t\t\t\t//设置格式\t\t\tstyle.setDataFormat(format.getFormat(\"yyyy-MM-dd hh:mm:ss\"));\t\t\tcell = row.getCell(1);\t\t\tcell.setCellStyle(style);//对cell应用样式\t\t\trow.getCell(2).setCellStyle(style);\t\t\t\t\t\t//设置列宽\t\t\tsheet.setColumnWidth(1, 5000);//单位：点的1/20\t\t\tsheet.autoSizeColumn(2);\t\t\t\t\t\t//格式化数字\t\t\tstyle = wb.createCellStyle();\t\t\tstyle.setDataFormat(format.getFormat(\"#,###.###\"));//保留3位小数\t\t\trow.getCell(3).setCellStyle(style);\t\t\t\t\t\t//文本自动换行\t\t\tsheet.setColumnWidth(4, 3000);\t\t\tstyle = wb.createCellStyle();\t\t\tstyle.setWrapText(true);//回绕文本（wrap：缠绕）\t\t\trow.getCell(4).setCellStyle(style);\t\t\t\t\t\t//设置文本对齐方式\t\t\tsheet.setColumnWidth(0, 5000);\t\t\trow = sheet.createRow(1);\t\t\trow.createCell(0).setCellValue(\"left top\");\t\t\trow.createCell(1).setCellValue(\"center center\");\t\t\trow.createCell(2).setCellValue(\"right bottom\");\t\t\t\t\t\t//对齐方式-->左上\t\t\tstyle = wb.createCellStyle();\t\t\tstyle.setAlignment(HSSFCellStyle.ALIGN_LEFT);//（alignment：队列 ；align：排列）\t\t\tstyle.setVerticalAlignment(HSSFCellStyle.VERTICAL_TOP);\t\t\trow.getCell(0).setCellStyle(style);\t\t\t//对齐方式-->中中\t\t\tstyle = wb.createCellStyle();\t\t\tstyle.setAlignment(HSSFCellStyle.ALIGN_CENTER);\t\t\tstyle.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER);\t\t\trow.getCell(1).setCellStyle(style);\t\t\t//对齐方式-->右下\t\t\tstyle = wb.createCellStyle();\t\t\tstyle.setAlignment(HSSFCellStyle.ALIGN_RIGHT);\t\t\tstyle.setVerticalAlignment(HSSFCellStyle.VERTICAL_BOTTOM);\t\t\trow.getCell(2).setCellStyle(style);\t\t\t\t\t\t//设置行高\t\t\trow.setHeightInPoints(50);\t\t\t//设置字体\t\t\tstyle = row.getCell(1).getCellStyle();\t\t\tHSSFFont font = wb.createFont();\t\t\tfont.setFontName(\"宋体\");\t\t\tfont.setFontHeightInPoints((short) 13);\t\t\tfont.setColor(HSSFColor.RED.index);\t\t\tstyle.setFont(font);\t\t\t\t\t\t//文本旋转（正数为逆时针，负数为顺时针）\t\t\tstyle.setRotation((short) -30);\t\t\t\t\t\t//设置边框\t\t\trow = sheet.createRow(2);\t\t\tcell = row.createCell(0);\t\t\tstyle = wb.createCellStyle();\t\t\tstyle.setBorderBottom(HSSFCellStyle.BORDER_DASH_DOT_DOT);//（dash：破折号）\t\t\tstyle.setBottomBorderColor(HSSFColor.BLUE.index);\t\t\tcell.setCellStyle(style);\t\t\t\t\t\t//计算列（运用函数）\t\t\trow = sheet.createRow(3);\t\t\trow.createCell(0).setCellValue(2);\t\t\trow.createCell(1).setCellValue(5.1);\t\t\trow.createCell(2).setCellValue(3.9);\t\t\trow.createCell(3).setCellFormula(\"sum(A4:C4)\");\t\t\t\t\t\t//整体移动行（1：开始行；3：结束行；2：向下移动多少行，负数则为上移）\t\t\tsheet.shiftRows(1, 3, 2);\t\t\t\t\t\t/*拆分窗格\t\t\t * 1000：左侧窗格的宽度\t\t\t * 2000：上侧窗格的高度\t\t\t * 3：右侧窗格开始显示的列的索引\t\t\t * 4：下侧窗格开始显示的行的索引\t\t\t * 1：激活哪个面板区\t\t\t */\t\t\tsheet.createSplitPane(1000, 2000, 3, 4, 1);\t\t\t\t\t\t//冻结窗口\t\t\t//1:冻结前几列； 2：冻结前几行\t\t\tsheet.createFreezePane(1, 2, 3, 4);\t\t\t\t\t\t//从内存写出到e:/testPOI.xls，不存在就创建\t\t\twb.write(new FileOutputStream(\"e:/testPOI.xls\"));\t\t}\t}","title":"POI-HSSF小结"},{"content":"python30多种ide，总有适合你的一款。  BlackAdder      BlueFish      Boa Constructor  ConTEXT         DABO           DreamPie    Dr.Python   Editra    Emacs         Eric Ide     E-Texteditor   Geany    Gedit   Idle   JEdit   KDevelop   Komodo   NetBeans    NotePad++  Pfaide  PIDA   PTVS   PyCharm   PyDev(Eclipse)   Pyscripter   PythonWin   SciTE   ScriptDev   SPE    Spyder    Sublime Text  TextMate  UliPad  Vim   WingIde  Zeus  以上UliPad由国人limodou开发，一般学习用python自带idle就可以。习惯于以前的vs或delphi者用Eclipse+PyDev(免费) 。  PyCharm是windows下最好的ide,非免费版。  linux下牛人用vim配置成python的ide","title":"python30多种ide，总有适合你的一款。"},{"content":"bitset 与vector<bool> 类似，同样存储二进制位，但它的大小固定，而且比vector<bool>支持更多的位运算。 vector<bool〉和bitset 各有优缺点: vector<bool>可以动态增长，但不能方便地进行位运算; bitset 则正好相反，可以方便地对容纳的二进制位做位运算，但不能动态增长。 boost.dynamic_bitset的出现恰好填补了这两者之间的空白，它类似标准库的bitset，提供丰富的位运算，同时长度又是动态可变的。 dynamic_bitset位于名字空间boost，为了使用dynamic_bitset组件，需要包含头文件<boost/dynamic_bitset.hpp> ， 即: #include <boost/dynamic_bitset.hpp> using namespace boost; void test_dynamic_bitset(){\tusing namespace boost;\t// 1. 构造\tdynamic_bitset<> db1;                              // 空的dynamic_bitset\tdynamic_bitset<> db2(10);                          // 大小为10的dynamic_bitset\tdynamic_bitset<> db3('Ox16', BOOST_BINARY(10101)); // \tdynamic_bitset<> db4(std::string(\"0101\"));         // 字符串构造\t// 2. resize\tdb1.resize(8, true);\tassert(db1.to_ulong() == BOOST_BINARY(11111111));\tdb1.resize(5);\tassert(db1.to_ulong() == BOOST_BINARY(11111));\tdb1.clear();\tassert(db1.empty() && db1.size() == 0);\t// 3. push_back\t// dynamic_bitset可以像vector那样使用push_back()向容器末尾(二制数头部)追加一个值\tdynamic_bitset<> db5(5, BOOST_BINARY(01010));\tassert(db5.to_ulong() == BOOST_BINARY(01010));\tdb5.push_back(true);\t// 添加二进制位1\tassert(db5.to_ulong() == BOOST_BINARY(101010));\tdb5.push_back(false);\t// 添加二进制位0\tassert(db5.to_ulong() == BOOST_BINARY(0101010));\t// 4. block\t// dynamic_bitset使用block来存储二进制位, 一个block就可以存储32个二进制位\tassert(dynamic_bitset<>(32).num_blocks() == 1);\tassert(dynamic_bitset<>(33).num_blocks() == 2);\t// 5. 位运算\tdynamic_bitset<> db6(4, BOOST_BINARY(1010));\tdb6[0] &= 1;\t// 按位与运算\tdb6[1] ^= 1;\t// 按位异或运算\tdb6[2] |= 1;\t// 按位或运算\tassert(db6.to_ulong() == BOOST_BINARY_UL(1100));\t\t// 6. 访问元素\tdynamic_bitset<> db7(4, BOOST_BINARY(1100));\tassert(!db7.test(0) && !db7.test(1));\tassert(db7.any() && !db6.none());\tassert(db7.count() == 2);\tassert(db7.set().to_ulong() == BOOST_BINARY(1111));\tassert(db7.reset().to_ulong() == BOOST_BINARY(0000));\tassert(db7.set(0, 1).to_ulong() == BOOST_BINARY(0001));\t\tassert(db7.set(2, 1).to_ulong() == BOOST_BINARY(0101));\tassert(db7.reset(0).to_ulong() == BOOST_BINARY(0100));\tassert(db7.find_first() == 2);\tassert(db7.find_next(2) == ULONG_MAX);\t// 没有找到的情况}","title":"【Boost】boost::dynamic_bitset介绍"},{"content":"●首先提出一个功能实现，思考自己平时的代码怎么写 ●然后用设计模式重构。寻找优缺点。 ●反思这么写是不是多人配合更好了，扩展性强了，面向对象，体现解耦性............？ ●反思该设计模式应用场景。使用范围。 本文代码示例下载地址：http://download.csdn.net/detail/b275518834/4942096 策略模式的结构     策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一 个抽象策略类的子类。用一句话来说，就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。 ●精髓：一个对象一个行为 ●写一个工具类 将字符串大写输出 将字符串小写输出    将字符串按空格分割输出 你大概会这么写   A例子 import java.util.Arrays;public class MainDemo1 {\tpublic static void main(String[] args) {        String s =         \t\"Disagreement with beliefs is by definition incorrect\";\t\tSystem.out.println(s);\t\tSystem.out.println(MainDemo1.toSplitter(s));\t\tSystem.out.println(MainDemo1.toDowncase(s));\t\tSystem.out.println(MainDemo1.toUpcase(s));\t}\tpublic static Object toSplitter(String str) {\t\treturn Arrays.toString(str.split(\" \"));\t}\tpublic static Object toDowncase(String str) {\t\treturn str.toLowerCase();\t}\tpublic static Object toUpcase(String str) {\t\treturn str.toUpperCase();\t}} 以下代码摘自《Java编程思想 ThanksInJava》策略模式 B例子 package interfaces.classprocessor;import java.util.Arrays;/** * 策略模式 创建一个能够根据所传递的参数对象的不同而具有的不同行为的方法 * */class Processor {\tpublic String name() {\t\treturn getClass().getSimpleName();\t};\tObject process(Object input)\t{\t\treturn input;\t\t\t}}class Upcase extends Processor {\tString process(Object input) {\t\treturn \"大写输出：\"+((String) input).toUpperCase();\t}}class Downcase extends Processor {\tString process(Object input) {\t\treturn \"小写输出：\"+((String) input).toLowerCase();\t}}class Splitter extends Processor {\tString process(Object input) {\t\treturn \"分割输出：\"+Arrays.toString(((String) input).split(\" \"));\t}}public class Apply {\tpublic static void process(Processor p, Object s) {\t\tSystem.out.println(\"Using Processor \" + p.name());\t\tSystem.out.println(p.process(s));\t}\tpublic static String s = \"Disagreement with beliefs is by definition incorrect\";\tpublic static void main(String[] args) {\t\tprocess(new Upcase(), s);\t\tprocess(new Downcase(), s);\t\tprocess(new Splitter(), s);\t}} 策略模式 就是这样一种对象一种行为。 也许你会觉得B例子不如A例子，这个例子的确不能一眼就看出B例子比A例子优秀， 我当时也相当疑惑。B例子比A例子相同的功能不是还多了创建对象吗？画蛇添足？ System.out.println(MainDemo1.toDowncase(s)); // A例子 process(new Downcase(), s);          //B例子 思维扩展一下B例子的优点---一个对象一种行为： 优势1：维护性--但是假如的你要写的工具类很多比如几百种如将字符串倒转，将字符串去重复，将字符串去空格，将字符串转成字节........ 于是A 例子这个类的代码就会越挤越多。而B例子创建对象就可以了，将来要维护很容易定位修改。 优势2:多人分工--如果是一个团队开发一个工具类，B例子的扩展性就比A例子强大的多。 优势3：编程的灵活性--《一个对象一种行为》，在动态的编程的非常灵活。配合委托非常棒。 （例如比如说植物大战僵尸，在某些场景普通僵尸走路方式变成蹦跳僵尸（外形不变）， 我们定义每个僵尸都有script类，我们要改变僵尸的一个行为只要修改这个普通僵尸的script这个类脚本该为蹦跳僵尸）。 B例子就是利用多态为我们演示如何“使算法的责任和算法本身分割开来，委派给不同的对象管理\" 由于这个例子没有体现算法的责任和算法本身分割的优点，为了更好理解这个模式： 我利用一些开源库http://www.jhlabs.com/ip/filters/index.html编写了滤镜项目demo。 其主要功能是图片---》滤镜---》滤镜图片效果 这个例子同时还用到模板模式 界面效果 MainTryImageUI.class //界面类 Action.class//动作 package com.jhlabs.work.ui;import java.awt.image.BufferedImage;import javax.swing.JMenuItem;import com.jhlabs.image.AbstractBufferedImageOp;import com.jhlabs.image.ContourFilter;import com.jhlabs.image.DespeckleFilter;import com.jhlabs.image.DiffusionFilter;import com.jhlabs.image.EdgeFilter;import com.jhlabs.image.EmbossFilter;import com.jhlabs.image.EqualizeFilter;import com.jhlabs.image.Flush3DFilter;import com.jhlabs.image.LevelsFilter;import com.jhlabs.image.LightFilter;import com.jhlabs.image.MedianFilter;import com.jhlabs.image.OilFilter;import com.jhlabs.image.PlasmaFilter;import com.jhlabs.image.QuantizeFilter;import com.jhlabs.image.SmearFilter;public enum Action {\t//为每一个动作注册名称和对应的滤镜\tContourFilter(\"轮廓\",new ContourFilter()),\tDespeckleFilter(\"去斑\",new DespeckleFilter()),\tDiffusionFilter(\"扩散\",new DiffusionFilter()),\tEdgeFilter(\"滤光\",new EdgeFilter()),\tEmbossFilter(\"浮雕\",new EmbossFilter()),\tEqualizeFilter(\"补偿\",new EqualizeFilter()),\tFlush3DFilter(\"3D\",new Flush3DFilter()),\tLevelsFilter(\"水平\",new LevelsFilter()),\tLightFilter(\"光源\",new LightFilter()),\tMedianFilter(\"中线\",new MedianFilter()),\tOilFilter(\"曝光\",new OilFilter()),\tPlasmaFilter(\"等离子\",new PlasmaFilter()),\tQuantizeFilter(\"量子化\",new QuantizeFilter()),\tSmearFilter(\"风化\",new SmearFilter());\t//名称\tprivate String name;\t//按钮\tprivate JMenuItem jMenuItem;\t//滤镜\tprivate AbstractBufferedImageOp filter;        //构造器\tprivate Action(String name,AbstractBufferedImageOp filter) {\t\tthis.name = name;\t\tthis.jMenuItem=new JMenuItem(name);\t\tthis.filter=filter;\t}\t//指定动作进行滤镜操作\tpublic static void actionScript(Action action,BufferedImage sourceBuf,BufferedImage targetBuf)\t{\t\taction.getFilter().filter(sourceBuf, targetBuf); \t}\tpublic AbstractBufferedImageOp getFilter() {\t\treturn filter;\t}\tpublic String getName() {\t\treturn name;\t}\tpublic JMenuItem getjMenuItem() {\t\treturn jMenuItem;\t}\t} 本文代码示例下载地址：http://download.csdn.net/detail/b275518834/4942096","title":"Java Design Demo--策略模式 （图片滤镜小工程）"},{"content":"继承、实现、依赖、关联、聚合、组合的联系与区别 分别介绍这几种关系： 继承 指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；在Java中此类关系通过关键字extends明确标识，在设计时一般没有争议性； 实现 指的是一个class类实现interface接口（可以是多个）的功能；实现是类与接口之间最常见的关系；在Java中此类关系通过关键字implements明确标识，在设计时一般没有争议性； 依赖 可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、、临时性的、非常弱的，但是B类的变化会影响到A；比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖；表现在代码层面，为类B作为参数被类A在某个method方法中使用； 关联 他体现的是两个类、或者类与接口之间语义级别的一种强依赖关系，比如我和我的朋友；这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的、关联可以是单向、双向的；表现在代码层面，为被关联类B以类属性的形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量； 聚合 聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享；比如计算机与CPU、公司与员工的关系等；表现在代码层面，和关联关系是一致的，只能从语义级别来区分； 组合 组合也是关联关系的一种特例，他体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合；他同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束；比如你和你的大脑；表现在代码层面，和关联关系是一致的，只能从语义级别来区分； 对于继承、实现这两种关系没多少疑问，他们体现的是一种类与类、或者类与接口间的纵向关系；其他的四者关系则体现的是类与类、或者类与接口间的引用、横向关系，是比较难区分的，有很多事物间的关系要想准备定位是很难的，前面也提到，这几种关系都是语义级别的，所以从代码层面并不能完全区分各种关系； 但总的来说，后几种关系所表现的强弱程度依次为：组合>聚合>关联>依赖； 聚合跟组合其实都属于关联 只不过它们是两种特殊的关联 因为本是同根生 所以它们之间难免会有相似之处 下面让我们一起来看一下它们之间有何不同 聚合与组合的概念相信不用我在此赘述大家就已经了解了 下面直接上例子 程老师的《大话》里举大那个大雁的例子很贴切 在此我就借用一下 大雁喜欢热闹害怕孤独 所以它们一直过着群居的生活 这样就有了雁群 每一只大雁都有自己的雁群 每个雁群都有好多大雁 大雁与雁群的这种关系就可以称之为聚合 另外每只大雁都有两只翅膀 大雁与雁翅的关系就叫做组合 有此可见 聚合的关系明显没有组合紧密 大雁不会因为它们的群主将雁群解散而无法生存 而雁翅就无法脱离大雁而单独生存——组合关系的类具有相同的生命周期","title":"UML类图关系（泛化 、继承、实现、依赖、关联、聚合、组合）"},{"content":"首先说明，本文的分析对象是运行在IA32平台上的程序，试验用的编译器是Visual C++ 6.0中的cl.exe(Microsoft 32-bit C/C++ Optimizing Compiler Version 12.00.8804 for 80x86)。     IA32程序利用程序堆栈来支持过程(procedure)调用，比如创建局部数据、传递参数、保存返回值信息、保存待今后恢复的寄存器等。为了一个过程调用而分配的堆栈空间称为一个stack frame。最顶层的stack frame由两个寄存器标识：ebp保存stack frame的基址，esp保存栈顶地址，因为在过程执行的时候栈顶寄存器的值会经常变化，所以绝大多数的信息都是通过ebp来相对寻址的。图1描绘了stack frame的基本结构。注意在IA32机器上，栈是向低地址方向增长，所以栈顶的地址值小于等于栈底的地址值。                    stack \"bottom\"                   ________________ ______                  |                |  |                  |       .        |  |                  |                |  |                  |       .        |  |                  |                |  |--->Earlier frames                  |       .        |  |                  |                |  |                  |       .        |  |           |            |                |  |     |            |________________|__|___     |            |       .        |  |     |            |       .        |  |     |            |       .        |  | Decreasing       |________________|  |  address         |   Argument n   |  |     |       4m-->|________________|  |     |   (m为整数) |       .        |  |-->Caller's frame     |            |       .        |  |     |            |________________|  |     |            |   Argument 1   |  |     |       +8-->|________________|  |     V            | Return address |  |             +4-->|________________|__|___                  |   Saved  ebp   |  |  Frame Pointer-->|________________|  |            ebp   |Saved  registers|  |                  |local  variables|  |                  |      and       |  |-->Current frame                  |   temporaries  |  |                  |________________|  |                  |    Argument    |  |                  |   build area   |  |  Stack pointer-->|________________|__|___            esp       stack \"top\"                         图1     调用C函数时，不管参数类型如何(包括浮点和struct类型)调用者(caller)负责从右至左将参数依次压栈，最后压入返回地址并跳转到被调函数入口处执行，其中每个参数都要按4字节地址对齐。按照地址来说被传递的参数和返回地址都是位于调用者stack frame中的。如果函数的返回值类型是整型(包括char,short,int,long及它们的无符号型)或指针类型的话，那么就利用EAX寄存器来传回返回值。请看下面的函数： long foo_long(long offset) {    long val = 2006 + offset;    return val; } 用 /c /Od /FAsc 的编译选项(下文均同)编译出如下的汇编码： PUBLIC    _foo_long _TEXT    SEGMENT _offset$ = 8 _val$ = -4 _foo_long PROC NEAR ; 38   : { push    ebp ;保存调用者的stack frame基址 mov     ebp, esp push    ecx ; 39   :    long val = 2006 + offset; mov     eax, DWORD PTR _offset$[ebp] add     eax, 2006 mov     DWORD PTR _val$[ebp], eax ; 40   :    return val; ; 将返回值保存进eax寄存器 mov  eax, DWORD PTR _val$[ebp] ; 41   : } mov     esp, ebp pop     ebp ret     0 _foo_long ENDP _TEXT    ENDS     如果函数返回的是结构体数据(非结构体指针)那得通过哪个中转站传递呢？这就要分三种情况： 1、结构体大小不超过4字节，那么仍然使用EAX寄存器传递返回值。比如： /* 4字节大小结构体 */ typedef struct small_t {    char m1;    char m2;    char m3;    char m4; } small_t; small_t create_small(void) {    small_t small = {'s','m','a','l'};    return small; } void call_small(void) {    small_t small_obj = create_small(); } 编译出的汇编码是： ;create_small函数 PUBLIC    _create_small _TEXT    SEGMENT _small$ = -4 _create_small PROC NEAR ; 16   : { push     ebp mov     ebp, esp push     ecx ; 17   :    small_t small = {'s','m','a','l'}; mov BYTE PTR _small$[ebp], 115 ; 00000073H mov BYTE PTR _small$[ebp+1], 109 ; 0000006dH mov BYTE PTR _small$[ebp+2], 97 ; 00000061H mov BYTE PTR _small$[ebp+3], 108 ; 0000006cH ; 18   :    return small; ;依然用EAX保存返回值 mov     eax, DWORD PTR _small$[ebp] ; 19   : } mov     esp, ebp pop     ebp ret     0 _create_small ENDP _TEXT    ENDS ;call_mall函数 PUBLIC    _call_small _TEXT    SEGMENT _small_obj$ = -4 _call_small PROC NEAR ; 22   : { push     ebp mov     ebp, esp push     ecx ; 23   :    small_t small_obj = create_small(); call  _create_small ;从eax寄存器中取出返回值填充到small_obj变量中 mov DWORD PTR _small_obj$[ebp], eax ; 24   : } mov     esp, ebp pop     ebp ret     0 _call_small ENDP _TEXT    ENDS 2、结构体超过4字节但不等于8字节时，调用者将首先在栈上分配一块能容纳结构体的临时内存块，然后在传递完函数参数后将该临时内存块的首地址作为隐含的第一个参数最后(因为压栈顺序是从右到左)压栈，接下的动作同前所述。当被调用函数返回时，它会通过第一个隐含参数寻址到临时内存块并将返回值拷贝到其中，然后将保存有返回值内容的临时内存块的首址存进eax寄存器中，最后退出。请看下例： typedef struct fool_t {    short a;    short b;    short c; } fool_t; fool_t create_fool(short num) {    fool_t fool = {num,num,num};    return fool; } void call_fool(void) {    fool_t fool_obj = create_fool(2006); } 汇编码为： ; create_fool函数 PUBLIC    _create_fool _TEXT    SEGMENT _num$ = 12 _fool$ = -8 ; 编译器隐含传递的第一个参数(相对于stack frame基址)的偏移值， ; 该参数等于用于传递结构体返回值的临时内存块的首地址。 ; $T480是编译器自动生成的标号。 $T480 = 8 _create_fool PROC NEAR ; 9    : { push    ebp mov     ebp, esp sub     esp, 8 ; 10   :    fool_t fool = {num,num,num}; mov     ax, WORD PTR _num$[ebp] mov     WORD PTR _fool$[ebp], ax mov     cx, WORD PTR _num$[ebp] mov     WORD PTR _fool$[ebp+2], cx mov     dx, WORD PTR _num$[ebp] mov     WORD PTR _fool$[ebp+4], dx ; 11   :    return fool; ; 将临时内存块的首地址存入eax mov     eax, DWORD PTR $T480[ebp] ; 将结构体返回值的低4字节通过ecx存入临时内存块的低4字节 mov     ecx, DWORD PTR _fool$[ebp] mov     DWORD PTR [eax], ecx ; 将结构体返回值的高2字节通过dx存入临时内存块的高2字节 mov     dx, WORD PTR _fool$[ebp+4] mov     WORD PTR [eax+4], dx ; 将临时内存块的首地址存入eax，并准备退出 mov     eax, DWORD PTR $T480[ebp] ; 12   : } mov     esp, ebp pop     ebp ret     0 _create_fool ENDP _TEXT    ENDS ; call_fool函数 PUBLIC    _call_fool _TEXT    SEGMENT _fool_obj$ = -8 ; 编译器为接纳结构体返回值而自动在栈上临时分配了一块内存， ; 注意fool_t结构体大小虽为6字节，但需要对齐到4字节边界， ; 所以分配了8字节大小的空间。 $T482 = -16 _call_fool PROC NEAR ; 15   : { push    ebp mov     ebp, esp sub     esp, 16     ; 00000010H ; 16   :    fool_t fool_obj = create_fool(2006); push     2006  ; 000007d6H ; 取得临时内存块的首地址并压栈 lea     eax, DWORD PTR $T482[ebp] push    eax ; 函数调用完毕后，临时内存块将被填入结构体返回值 call     _create_fool add     esp, 8 ; 通过ecx将临时内存块的低4字节数据存进fool_obj的低4字节 mov     ecx, DWORD PTR [eax] mov     DWORD PTR _fool_obj$[ebp], ecx ; 通过dx将临时内存块的高2字节数据存进fool_obj的高2字节 mov     dx, WORD PTR [eax+4] mov     WORD PTR _fool_obj$[ebp+4], dx ; 17   : } mov     esp, ebp pop     ebp ret     0 _call_fool ENDP _TEXT    ENDS 3、结构体大小刚好为8个字节时编译器不再于栈上分配内存，而直接同时使用EAX和EDX两个寄存器传递返回值，其中EAX保存低4字节数据，EDX保存高4字节数据。请看下面2个函数： /* 如果编译器的最大对齐模数是8，则该结构体大小为8字节 */ typedef struct big_t {    char m1;    long m2; } big_t; big_t create_big(char c) {    big_t big = {c, 2006};    return big; } void call_big(void) {    big_t big_obj = create_big('A'); } 编译出的汇编码是： ; create_big函数 PUBLIC    _create_big _TEXT    SEGMENT _c$ = 8 _big$ = -8 _create_big PROC NEAR ; 27   : { push    ebp mov     ebp, esp sub     esp, 8 ; 28   :    big_t big = {c, 2006}; mov     al, BYTE PTR _c$[ebp] mov     BYTE PTR _big$[ebp], al mov     DWORD PTR _big$[ebp+4], 2006 ; 000007d6H ; 29   :    return big; ; 通过eax和edx返回 big mov eax, DWORD PTR _big$[ebp] mov edx, DWORD PTR _big$[ebp+4] ; 30   : } mov     esp, ebp pop     ebp ret     0 _create_big ENDP _TEXT    ENDS ;call_big函数 PUBLIC    _call_big _TEXT    SEGMENT _big_obj$ = -8 _call_big PROC NEAR ; 33   : { push  ebp mov   ebp, esp sub   esp, 8 ; 34   :    big_t big_obj = create_big('A'); push  65       ; 00000041H call     _create_big add     esp, 4 ; 通过eax和edx取得返回值 mov     DWORD PTR _big_obj$[ebp], eax mov     DWORD PTR _big_obj$[ebp+4], edx ; 35   : } mov     esp, ebp pop     ebp ret     0 _call_big ENDP _TEXT    ENDS 因为结构体大小与编译时的最大对齐模数选项有关(具体关系请参见《内存对齐与结构体的内存布局》)，所以当最大对齐模数改变时返回动作将可能改变。对于本例，在编译时加上/Zp2选项，则big_t结构体类型大小为6字节，create_big函数也将相应地利用临时内存块而非edx寄存器来返回数据。     至于返回值为浮点类型则与整型和结构体型有相当的不同，因为IA32架构CPU有一套特殊的基于浮点寄存器栈操作的浮点指令集。浮点寄存器栈包括8个浮点寄存器，编号从0到7，其中0号为栈顶，7号为栈底，指令可通过编号访问相应寄存器，所有浮点运算的结果均保存在栈顶。取得浮点返回值很简单，只需直接弹出栈顶元素并拷贝到相应的变量中就可以了。我们通过下面这段小程序来验证一下。 double foo(double a) {    return a + 10; } void goo() {    double b;    b = foo(10.0); } ; foo函数 PUBLIC    _foo PUBLIC    __real@8@4002a000000000000000 EXTRN    __fltused:NEAR ;    COMDAT __real@8@4002a000000000000000 ; File convention.c CONST    SEGMENT __real@8@4002a000000000000000 DQ 04024000000000000r ; 10 CONST    ENDS _TEXT    SEGMENT _a$ = 8 _foo    PROC NEAR ; 19   : { push     ebp mov      ebp, esp ; 20   :    return a + 10; ; 从变量a中读入一个double型浮点数并压入浮点栈 fld     QWORD PTR _a$[ebp] ; 将浮点栈的栈顶元素与10相加，将结果压入浮点栈 fadd     QWORD PTR __real@8@4002a000000000000000 ; 21   : } pop     ebp ret     0 _foo     ENDP _TEXT    ENDS ; goo函数 PUBLIC    _goo _TEXT    SEGMENT _b$ = -8 _goo    PROC NEAR ; 24   : { push    ebp mov     ebp, esp sub     esp, 8 ; 25   :    double b; ; 26   :    b = foo(10.0); push 1076101120 ; 40240000H push     0 call     _foo add   esp, 8 ; 将浮点栈顶元素弹出并存入变量b，此即保存foo函数返回值的动作 fstp     QWORD PTR _b$[ebp] ; 27   : } mov     esp, ebp pop     ebp ret     0 _goo     ENDP _TEXT    ENDS 参考资料： [1] 《Computer Systems: A Programmer's Perspective》.     Randal E. Bryant, David R. O'Hallaron.     电子工业出版社","title":"vc如何返回函数结果及压栈参数"},{"content":"        排序 + 分离单词技巧 #include <stdio.h>#include <string.h>#include <stdlib.h>bool isLetter(char &ch) {    if (ch >= 'a' && ch <= 'z')        return true;    if (ch >= 'A' && ch <='Z') {        ch += 'a' - 'A';        return true;    }    return false;}int cmp(const void* _a, const void* _b) {    char *a = (char*)_a;    char *b = (char*)_b;    return strcmp(a, b);}char b[50005][205];int main(){    char tmp;    bool flag = false;    int i = 0, j = 0;    while ((tmp = getchar()) != EOF) {        if (isLetter(tmp) && !flag) {            i = 0;            b[j][i++] = tmp;            flag = true;        }        else if (isLetter(tmp) && flag) {            b[j][i++] = tmp;        }        else if (!isLetter(tmp) && flag) {            flag = false;            b[j][i] = '\\0';            j++;        }    }    qsort(b, j, sizeof (b[0]), cmp);    for (i=0; i<j-1; i++)    {        if (0 == strcmp(b[i], b[i+1]))            continue;        printf(\"%s\\n\", b[i]);    }    printf(\"%s\\n\", b[i]);    return 0;}    ","title":"UVA10815 Andy's First Dictionary"},{"content":"final: 继承的弊端:打破了代码的封装性,final的出现正好弥补了这一弊端 final关键字: 1-final是一个修饰符,可以修饰类,方法,变量; 2-final修饰的类不能被继承 3-final修饰的方法不可以被覆盖 4-final修饰的变量是一个常数,只能被赋值一次并且要在定义时就将其赋予某值 规则: 被定义final的常量要用大写字母表示,各单词之间用下划线_来隔开. 实例一: class Father01{ final String FATHER01_NAME = \"张三\"; final int FATHER01_AGE = 20;   final void show(){ // age=9;   //错误!!!age被定义为final,定义时已经被赋值,不能再被赋值 System.out.println(\"姓名: \" + FATHER01_NAME); }   } final class Father02{ } class  Son01 extends Father01{ // public void show() {      //错误!!!被final定义的方法不能被覆盖 // // } } //class Son02 extends Father02{  //错误!!!被final定义的类不能被继承 // //} 原文来自站长网www.software8.co/","title":"java面向对象基础_final"},{"content":"ARM9触摸屏的程序的控制，主要对3个寄存器的控制 （1）、ADCCON 设置AD转化频率  /*设置AD转频率*/  preScaler = ADC_FREQ; Uart_Printf(\"ADC conv,freq. = %dHz\\n\",preScaler); preScaler = 50000000/ADC_FREQ - 1; //PCLK=50M rADCCON = (1<<14)|(preScaler<<6);//ADCPRS En,PRSCVL // rADCCON=(1<<14)+(preScaler<<6);   //ADCPRS En, ADCPRS Value （2）、ADCTSC设置触屏控制寄存器 /*设置触摸屏为等待中断模式，等待触摸笔被按下*/ rADCTSC=0xd3;  //Wfait,XP_PU,XP_Dis,XM_Dis,YP_Dis,YM_En （3）、SRCPND、INTPND设置寄存器，即设置父中断和子中断，即INT_ADC 和 INT_ADC_S、INT_TC rSRCPND = 0x80000000;  //父中断 INT_ADC  rINTPND = 0x80000000;//父中断  INT_ADC   ClearSubPending(BIT_SUB_TC); //SUBSRCPND 子中断  INT_TC  pISR_ADC = (U32)AdcTsAuto; /*enable INT_TC irq*/ //EnableIrq(BIT_ADC); rINTMSK = 0x7fffffff;    EnableSubIrq(BIT_SUB_TC)   //开启子中断  #define EnableSubIrq(bit)rINTSUBMSK &= ~(bit) #define BIT_SUB_TC(0x1<<9) __inline void ClearSubPending(int bit) { register i; rSUBSRCPND = bit; i = rINTPND; } （4）、当中断产生时，引发中断服务程序  pISR_ADC = (U32)AdcTsAuto;","title":"ARM9触摸屏"},{"content":"在许多需要分模块开发，较为复杂的应用项目（如ERP之类）中，如何做到轻松扩展，往往是一个头疼的问题。 在传统条件下，我们会把各个功能分布在不同的类库中，每添加一个功能就引用一个程序集，而这种方法，我们会发现，当你每添加一个新扩展后，都要对新增的程序集进行引用，这样也意味着，你每次都要重新编译一次主应用程序，这一来一往，维护成本也是有的。 到了.NET 3.5时代，你可能会想到Addin，但这个方法也会带来扩展成本。 而我们所追求的最完美解决方案是： 如果我od 们编写完应用程序后，可以在原有程序不变的情况下，无限添加扩展就好了。也就是说，我把应用A在用户的机器上安装好了，后来我做了一点扩展，这个新功能我已经编译到fc.dll类库中了，可我不想每次升级都要把EXE文件和所有组件重新编译，我只需要把新的fc.dll复制到应用安装目录下就可以了。   也许这样一来，维护成本可以大大降低了，到了.NET 4.0时代，利用MEF框架确实可以做到以上要求，但前提条件是： 1、在开发项目前，对整个项目的结构和规范必须明确，至少整个应用程序是什么样子的，你必须在大脑里面有个底。 2、编写一个公共类库，里面包含所有将来要进行扩展组件的行为规范，也就是在这个公共类库中定义所有将来可能被实现的接口，后面所有扩展的程序集都必须实现这些接口。   本文涉及的内容可能有些深奥，但愿大家可以接受，接受不了也没关系，毕竟许多东西是需要时间去掌握的。   我弄个简单的例子吧，比如，我现在要开发一个应用，在一个窗口上点击按钮后，显示对应球类的名字，如“足球”、“皮球”、“排球”等。但是，可能当初我只给出两个选项——足球和排球，这是我在把程序给客户前就扩展的两个程序集，但过了几天，我突然想起，还有“羽毛球”、“篮球”等，于是，我要为应用程序再加两个dll，但我希望应用程序扩展后不用修改代码，无论我将来扩展100个还是10000个dll我都不需要重新生成主程序，我只要把新的dll扔到应用程序中的Ext文件夹中就可以了。   我们来看看如何实现。 1、新建一个公共类库，写两个接口，IBall接口就是与球类信息有关的类，提供扩展时实现该接口。     public interface IBall    {        string GetInformation();    } 它有一个公共方法GetInformation，返回对应球类的名字，如“足球”. 另一个接口是用来描述元数据的。     public interface IMetaData    {        string BallType { get; }    } 为什么要定义这个元数据的接口呢？就是为了识别我们应用程序调用了哪个扩展。 比如，FootBall（足球）类扩展实现了IBall接口，VolleyBall（排球）类扩展也实现了IBall接口，BasketBall（篮球）类扩展也实现了IBall接口，可能以后会更多，所有的扩展都实现IBall，那么，我们怎么知道我们正在调用的足球？而不是篮球呢？所以，就需要这个IMetaData类，在进行扩展的导出类时，我们为每一个类型定义一下IMetaData的BallType属性，例如，我在定义足球类时，我定义BallType为“foot ball”，在定义排球类时，把BallType设置为“volley ball”，这样，在我们的应用程序中，就可以通过这个来判断我们正在调用哪个扩展，当然，如果你不需要明确知道调用哪个扩展，这个元数据就可以忽略。   2、分别编写两个类库，符合以下两个条件： a、实现IBall接口。 b、用ExportAttribute标识为导出类型。 MEF的类都是来自System.ComponentModel.Composition程序集，在需要的地方引用就行了，如何引用程序集，我就不说了，这是基础知识。这些类分布在以下三个命名空间。 System.ComponentModel.Composition System.ComponentModel.Composition.Hosting System.ComponentModel.Composition.Primitives   using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.ComponentModel.Composition;using System.ComponentModel.Composition.Hosting;namespace BallLibA{    /// <summary>    /// 足球    /// <\/summary>    [Export(typeof(CommonLib.IBall))]    [ExportMetadata(\"BallType\",\"Foot Ball\")]    public class FootBall:CommonLib.IBall    {        public string GetInformation()        {            return \"足球\";        }    }} 在MEF中，我们不需要实现提供元数据的接口，只需要在ExportMetadata特性中直接为属性设置值就行，运行时会自动生成实现元数据（本例是IMetaData接口）的类。   接照同样的方法，我们再做一个类库。     /// <summary>    /// 排球    /// <\/summary>    [Export(typeof(CommonLib.IBall))]    [ExportMetadata(\"BallType\", \"Volley Ball\")]    public class VolleyBall : CommonLib.IBall    {        public string GetInformation()        {            return \"排球\";        }    } 现在，我们的项目已经有两个扩展了。   3、我们来实现我们的主应用程序，我们只需引用我们前面编写的公共类库中的接口即可，而扩展的dll我们不需要引用，MEF会自动寻找。因此，把所有扩展的程序集都生成dll文件，然后统一扔到与exe文件同一位置的Ext文件夹中就行了，你有1000个dll就全部扔到文件夹里就行，MEF会自动寻找。 我们用一个WinForm程序作为主程序，如下图所示。 在程序运行时，会根据Ext目录下的所有扩展的dll自动发现所有程序集，然后显示在ComboBox中，我们选择对应的球类，然后点击按钮，这样在文本框中就会对应地显示球类的名称。 using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using System.ComponentModel.Composition;using System.ComponentModel.Composition.Hosting;namespace TestApp{    public partial class Form1 : Form    {        CompositionContainer myContainer = null;        // 引入的组合类型        [ImportMany]        IEnumerable<Lazy<CommonLib.IBall, CommonLib.IMetaData>> mBalls;        public Form1()        {            InitializeComponent();            DirectoryCatalog catl = new DirectoryCatalog(\"Ext\");            myContainer = new CompositionContainer(catl);            try            {                myContainer.ComposeParts(this);//组合组件            }            catch (Exception ex)            {                MessageBox.Show(ex.Message);            }            var resBalls = (from t in mBalls                            select t.Metadata.BallType).ToArray();            this.comboBox1.DataSource = resBalls;        }        private void button1_Click(object sender, EventArgs e)        {            if (this.comboBox1.SelectedIndex == -1)            {                MessageBox.Show(\"请选择一个扩展。\"); return;            }            string ballName = this.comboBox1.SelectedItem.ToString();            // 取出要执行哪个扩展程序集            var ballInstance = mBalls.FirstOrDefault(x => x.Metadata.BallType == ballName);            if (ballInstance != null)            {                this.txtResult.Text = ballInstance.Value.GetInformation();            }        }    }} 从上面的代码中，可以总结出MEF的用法，这方法你有兴趣的话可以背下来，因为无论你用到什么项目，思路都是一样的。 1、声明一个CompositionContainer变量是必须的，因为它可以用来指示当前应用程序与哪些扩展程序集进行合并。 2、在实例化CompositionContainer时，我使用DirectoryCatalog类，为什么？因为这个类好用，你只需要告诉它你扩展的dll放在哪个文件夹就行了。它会在你指定的文件夹里面自动找到导出的扩展类。 3、有导出类，自然就有导入类，因为我们的所有扩展都是实现IBall接口的，所以，扩展的类的导出类型应使用IBall，这样，凡是声明为导出类的都会被MEF发现并自动加载。 所以，导出是针对扩展的程序集而言的，那导入就好理解了，就是针对我们的主应用程序而言，像本例，WinForm应用作为主程序，所有扩展都是在这个WinForm中使用的，所以这个WinForm就必须对类型进行导入。因此才有了以下代码。         // 引入的组合类型        [ImportMany]        IEnumerable<Lazy<CommonLib.IBall, CommonLib.IMetaData>> mBalls; 使用Lazy来延迟实例化的好处是提高性能，记住，加了Import的导入类型是不用new的，因为DirectoryCatalog在Ext文件夹下找到所有的dll都会自动实例化，这就是要用延迟实便化的原因，只有在用的时候才new，不然，如果我的扩展目录下有100000个dll，350000000个类，那你一运行就全部实例化，那这性能估计要把内存用爆。 前面我说过，IMetaData用于标识元数据，我们不必自己去实现，而我们也不必指事实上哪个接口，因为上面代码中，Lazy<T, TMetadata>就有两个泛型参数，看到没？ T是我们要导入的类型，本例中是IBall，注意，我们这里的类型一定要是公共的接口，不是扩展的具体类，不然就实现不了无限扩展的目的，接口用途就是它有通用性。 TMetadata就是用来标识元数的类型，本例是IMetaData接口，所以，前面我为什么不用指定IMetaData的原因，因为这里会指定，MEF会沿着这个线索自动搜索它的属性BallType。   在实例化CompositionContainer容器后，要记得调用扩展方法ComposeParts，告诉MEF，所有扩展的程序集将和当前实例进行组合，不然你将无法调用。   现在，你运行一个这个WinForm，你就明白了。   看到了吧，FootBall和VolleyBall类所在的两个程序集我并没有在项目中，引用，只是把它们扔到Ext目录下，应用程序就自动识别了。 我们的WinForm程序不用修改一行代码。   如果你还不信的话，我们接下来再增加一个dll，定义一个BasketyBall（篮球类），然后，把这个篮球类库也生成一个dll，同样扔到Ext目录下，而WinForm程序我根本不需要改动。 using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.ComponentModel.Composition;using System.ComponentModel.Composition.Hosting;namespace BallLibC{    /// <summary>    /// 篮球    /// <\/summary>    [Export(typeof(CommonLib.IBall))]    [ExportMetadata(\"BallType\",\"Basket Ball\")]    public class BasketBall:CommonLib.IBall    {        public string GetInformation()        {            return \"篮球\";        }    }} 同样道理，把这个类库编译成dll，然后扔到Ext文件下，然后你再运行一下WinForm程序看看。 看到了吧，我没有对WinForm做任何修改，只是在Ext目录下多放了一个dll而已，运行后，程序就自动识别并找到对应的类型了。下拉列表框中就自动多了一个Basket Ball的选项了。选择它，并单击按钮，这个BadketBall类就被执行了，输出“篮球”。   以此类推，你再添加一千个一万个dll，只要它符合IBall接口规范并设置导出，然后把这一千个一万个dll全放到Ext目录下，应用程序不需要做任何修改，运行后就会自动找到一千个一万个扩展类了。 这样一来，是不是节约了不少维护和升级成本了？MEF（Managed Extensibility Framework）强大吧？","title":"在不修改代码的情况下无限扩展应用项目"},{"content":"","title":"ARM9时钟FCLK HCLK PCLK为各个模块提供的时钟频率"},{"content":"类的初始化包括实例成员的初始化和静态成员的初始化: 1、静态成员变量的初始化      静态变量的初始化方法：           A)直接赋值 public static String variableA=\"hello\",//当然也可以调用方法或者其它变量来赋值,但必须满足前向引用的原则.           B)在静态从句中写赋值语句:static{//初始化语句块}          其中直接赋值触发在第一次引用该变量时执行;而静态从句得触发有两个时刻,一是静态变量被引用时,二是在类第一次被实例化时.      如果同时包含A,B情况,其执行初始化顺序是A->B.这种初始化是一种规定,记住就好,当然,这种规则业必须满足合理性,这就是类第一次    实例化前,静态变量必须被初始化的原因:实例初始化可能会访问静态变量,所以必须准备好.C#的静态变量初始化策略跟Java很类似,静态    初始化从句的作用根C#的静态构造函数类似,静态变量的初始化都不是在类加载时，而是在类实例化时.类实例化的触发是在类变量第一次(类的   静态变量)被调用时，或者对象第一次被实例化时。　 2、实例成员的初始化       实例成员初始化有三个方式：      A）直接赋值：public String variableA=\"hello\";      B)在实例初始化从句中          public class A{               //实例初始化从句.               {                    //这里写初始化语句.               }         }      C)在构造函数中.      实例成员变量初始化是在实例时执行，执行的顺序是A->B->C. 下面是测试代码： public class ClassA {\t/*\t * 静态成员变量\t */\tpublic static String variableA=\"直接初始化值\";\tpublic static String variableA1;\t/*\t * 实例变量\t */\tpublic String variableB;\t//静态初始化从句\tstatic{              System.out.println(\"变量A:\"+variableA);\t    variableA =\"varibleA 在静态从句中 初始化!\";\t    System.out.println(\"变量A:\"+variableA);\t}         //实例成员初始化从句块\t{             System.out.println(\"初始化前变量B:\"+variableB);\t    variableB =\"varibleB 初始化!\";\t    System.out.println(\"初始化后变量B:\"+variableB);\t}}下面是调用测试代码： //如下三个语句都可以导致静态初始化从句执行,但注意静态初始化从句仅执行一次  //String theA=ClassA.varibleA;  String theB=ClassA.variableA;  //ClassA theCA=new ClassA(); 　//下面这条语句并不会引起静态变量初始化.也就是说Java在类加载时并不进行  //静态变量的初始化.  String theNameString=ClassA.class.getName();初看起来，实例初始化从句没什么必要，完全可以用构造函数来替代，但这种机制对于匿名类来说非常关键， 因为匿名类是无法写构造函数的。C#中的匿名类型比Java的匿名类要简单很多。一个可能的原因是因为C#有 委托类型，而Java需要用匿名类来比较便捷的实现类似Ｃ＃委托那样的功能。 弄清成员变量的初始化的机制，可以防止一些Bug的出现，","title":"Java学习笔记(成员变量的初始化)"},{"content":"在核心包的目录：struts2-core-2.1.8.1\\template下查看有哪些主题theme可用: 我的如图： 故而，用theme=\"ajax\"肯定出错，因为根本就没有\"ajax\"这个主题文件存在。 这就要看使用的版本了，看有哪些主题可用，以避免出错！","title":"theme=\"ajax\" : Template /template/ajax/head.ftl not found异常解决"},{"content":"编写一个简单的给予QT的DEMO程序步骤大致如下： 下面开始编程： A 编写 main.cpp B 编写 hello.h C 编写 hello.cpp D 制作.ui文件，并生成ui_hello.h     打开designer,拖入一个pushButton，一个label。保存为hello.ui。然后生成ui_hello.h，并添加到项目的源文件中。   编译运行，则出现如下错误： 错误 1 error LNK2001: 无法解析的外部符号 \"public: virtual struct QMetaObject const * __thiscall Widget::metaObject(void)const \" (?metaObject@Widget@@UBEPBUQMetaObject@@XZ) 错误 2 error LNK2001: 无法解析的外部符号 \"public: virtual void * __thiscall Widget::qt_metacast(char const *)\" (?qt_metacast@Widget@@UAEPAXPBD@Z) 错误 3 error LNK2001: 无法解析的外部符号 \"public: virtual int __thiscall Widget::qt_metacall(enum QMetaObject::Call,int,void * *)\" (?qt_metacall@Widget@@UAEHW4Call@QMetaObject@@HPAPAX@Z) 错误 4 fatal error LNK1120: 3 个无法解析的外部命令           这是因为在源文件中没有添加上moc_hello.cpp文件。     解决方法：右击hello.h，选择“自定义生成步骤”，“常规”     命令行：moc.exe hello.h -o moc_hello.cpp     输出：moc_hello.cpp     附加依赖项：moc.exe hello.h     确定，然后，右击hello.h，选择 “编译”，则在文件夹中生成moc_hello.cpp，再将其添加到源文件中。     然后，运行程序，出现错误：     错误  fatal error C1010: 在查找预编译头时遇到意外的文件结尾。是否忘记了向源中添加“#include \"stdafx.h\"”?     则在moc_hello.cpp文件的开头添加上：#include \"stdafx.h\"。     然后，再运行。仍然出现上面错误。这是因为当运行程序，又重新生成了moc_hello.cpp文件（这个新的文件的开头显然是没有#include \"stdafx.h\"），覆盖了已经修改过的文件。     解决方法：右击hello.h，选择“自定义生成步骤”，“常规”     清空“命令行” “输出” “附加依赖项” 里对应的内容。这样在运行程序时就不会再生成新的moc_hello.cpp文件了。然后确定。       这样再次运行程序，可以成功运行。 对于上述的第二个错误可以直接在项目属性--》C/C++--》预编译头--》创建/使用预编译头改为不使用预编译头。就可以一劳永逸了，不用上述这么麻烦的方法了。","title":"error LNK2001: 无法解析的外部符号 \"public: virtual struct QMetaObject const * __thiscall Widget::metaObject"},{"content":"注：以下程序系原创，若有bug欢迎指正，若有问题欢迎交流，转载请注明出处。若能有益于一二访客，幸甚。 1.VGA VGA（Video Graphics Array）即视频图形阵列，是IBM在1987年随PS/2机推出的。 VGA主要由七大块组成：图形控制器、显示存储器、定序器、CRT控制器、数据串行发生器、属性控制器和数模转换器DAC。 2.VBE IBM的VGA标准是显示卡发展史上的一块丰碑。但后来无法满足人们的需要，于是市场上出现了TVGA、S3系列、Cirrus Logic、ET等为首的一批显示卡，提供了比VGA分辨率更高，颜色更丰富的显示模式，又兼容VGA显示卡，它们被统称为Super VGA（SVGA）。 各种不同的SVGA之间的显示控制各不相同，带来软件兼容性问题，为此视频电子学标准协会VESA（Video Electronics Standards Association）提出了一组附加的BIOS功能调用借口——VBE（VESA BIOS EXTENSION）标准，从而在软件接口层次上实现了各种SVGA显示卡之间的兼容性。时至今日，所有的显示卡OEM厂商都提供了符合VESA SUPER标准的扩展BIOS。通过一组INT 10H中断调用（AH=4FH），可以方便地使用VESA SVGA的扩展功能而不必了解各种显示卡的硬件细节。 Super VGA的扩充显示能力关键取决于对较大显示存储器的寻址能力。 各Super VGA 卡提供的分辨率远高于VGA，VESA VBE均赋予一个标准的16位模式号（实际上是9位，其他各位为标志位或留给以后扩充）。 3.VBE功能调用和返回值 VBE功能调用的共同点： 1）AH必须等于4FH，表明是VBE标准； 2）AL等于VBE功能号，0<= AL <= 0BH； 3）BL等于子功能号，也可以没有子功能； 4）调用INT 10H； 5）返回值 VBE返回值一般在AX中： 1）AL=4FH：支持该功能 2）AL!=4FH：不支持该功能； 3）AH=00H：调用成功； 4）AH=01H：调用失败； 5）AH=02H：当前硬件配置不支持该功能； 6）AH=03H：当前的显示模式不支持该功能； 4.VBE 功能 -----------------------------------------------------------\t\t\t\t功能0x00：返回VBE信息------------------------------------------------------入口：\tAX\t\t\t0x4F00\tES：DI\t\t指向VBE信息块的指针出口：\tAX\t\t\tVBE返回值-----------------------------------------------------------------------------------------------------------------------\t\t\t功能0x01：返回VBE特定模式信息------------------------------------------------------入口：\tAX\t\t\t0x4F01\tCX\t\t\t模式号\tES：DI\t\t指向VBE特定模式信息块的指针出口：\tAX\t\t\tVBE返回值-----------------------------------------------------------------------------------------------------------------------\t\t\t功能0x02：设置VESA VBE 模式------------------------------------------------------入口：\tAX\t\t\t0x4F02\tBX\t\t\t模式号出口：\tAX\t\t\tVBE返回值------------------------------------------------------------当设置模式失败时，返回错误代码，一般返回AH=01HVESA 2.0以上增加了BX中D14，D15的位定义，完整定义如下：BX = 模式号\tD0～D8：9位模式号\tD9～D13：保留，必须为0\tD14 = 0：使用普通的窗口页面缓存模式，用VBE功能05H切换显示页面\t\t= 1：使用大的线性缓存区，其地址可从VBE功能01H的返回信息ModeInfo获得\tD15 = 0：清除显示内存\t\t= 1：不清除显示内存------------------------------------------------------------ 5.示例 检查VBE可否使用、版本、模式0x103，并切换到模式0x103（800*600， 256色）： # 本程序测试VBE（VESA BIOS EXTENSION）显示模式,然后切换到1024*768 256色模式，# 并通过软盘读取Baby OS 的简单LOGO，显示在屏幕上# 2012-12-28 21:03# guzhoudiaoke@126.com.section .text.global _start.code16_start:\tjmp\t\tmain#--------------------------------------------------------------# 清屏函数：#\t设置屏幕背景色，调色板的索引0指代的颜色为背景色clear_screen:\t\t\t\t# 清屏函数\tmovb\t$0x06,\t%ah\t\t# 功能号0x06\tmovb\t$0,\t\t%al\t\t# 上卷全部行，即清屏\tmovb\t$0,\t\t%ch\t\t# 左上角行\tmovb\t$0,\t\t%ch\t\t# 左上角列\t\tmovb\t$24,\t%dh\t\t# 右下角行\tmovb\t$79,\t%dl\t\t# 右下角列\tmovb\t$0x07,\t%bh\t\t# 空白区域属性\tint\t\t$0x10\tret#----------------------------------------------------------------# 设置VGA 0x13显示模式函数set_video_mode_0x13:\tmovb\t$0,\t\t\t%ah\t\t\t# 功能号0x0\tmovb\t$MODE_0x13,\t%al\t\t\t# 显示模式\tint\t\t$0x10\tmovw\t$0x13,\t\tvideo_mode\tmovw\t$320,\t\tscreen_x\tmovw\t$200,\t\tscreen_y\tmovl\t$0xb8000,\tvideo_ram\t\tret#----------------------------------------------------------------# 设置VBE 0x103显示模式#\t因第一次写此类程序，只考虑了可读性，未考虑效率，比如al、ah分开赋值等set_video_mode_vbe_0x103:\t# 确认VBE是否存在\tmovw\t$BUFFER_SEG,\t\t%ax\tmovw\t%ax,\t\t\t\t%es\tmovw\t%ax,\t\t\t\t%ds\txorw\t%di,\t\t\t\t%di\t\t# 下面检查是否支持VBE及VBE版本\tmovb\t$0x4f,\t\t\t\t%ah\t\t\t# VBE标准\tmovb\t$0x00,\t\t\t\t%al\t\t\t# 功能号\tint\t\t$0x10\tcmp\t\t$0x004f,\t\t\t%ax\t\t\t# 若有VBE，AX应该为0x004f\tjne\t\t1f\tmovw\t0x04(%di),\t\t\t%ax\tcmp\t\t$0x0200,\t\t\t%ax\t\t\t# 若VBE版本不是2.0以上，不能使用髙分辨率\tjb\t\t1f\t# 下面检查MODE_VBE_0x13的参数\tmovw\t$MODE_VBE_0x103,\t%cx\tmovb\t$0x4f,\t\t\t\t%ah\t\t\t# 表明VBE标准\tmovb\t$0x01,\t\t\t\t%al\t\t\t# 子功能号\tint\t\t$0x10\tcmpb\t$0x00,\t\t\t\t%ah\t\t\t# 是否调用成功\tjne\t\t1f\tcmpb\t$0x4f,\t\t\t\t%al\t\t\t# 是否支持该模式\tjne\t\t1f\tcmpb\t$8,\t\t\t\t\t0x19(%di)\t# 颜色是否占8bit\tjne\t\t1f\tcmpb\t$4,\t\t\t\t\t0x1b(%si)\t# 颜色的指定方法是否为4，即调色板方式\tjne\t\t1f\tmovw\t(%di),\t\t\t\t%ax\tandw\t$0x0080,\t\t\t%ax\tjz\t\t1f\t\t\t\t\t\t\t\t# AX第7个比特是否为1，该位表示线性帧缓存是否有效\t# 下面设置模式\tmovw\t$MODE_VBE_0x103,\t%bx\taddw\t$0x4000,\t\t\t%bx\t\t\t# BX第14个比特表示是否使用大的线性缓存区，故置位\tmovb\t$0x4f,\t\t\t\t%ah\t\t\t# 表示使用VBE标准\tmovb\t$0x02,\t\t\t\t%al\t\t\t# 功能号，表示设置模式\tint\t\t$0x10\t# 下面记录切换到的模式的一些参数信息\tmovw\t$MODE_VBE_0x103,\tvideo_mode\tmovw\t0x12(%di),\t\t\t%ax\tmovw\t%ax,\t\t\t\tscreen_x\tmovw\t0x02(%di),\t\t\t%ax\tmovw\t%ax,\t\t\t\tscreen_y\tmovl\t0x28(%di),\t\t\t%eax\tmovl\t%eax,\t\t\t\tvideo_ram\tmovw\t$1,\t\t\t\t\t%ax\tret1:\tmovw\t$0,\t\t\t\t\t%ax\tret\t#----------------------------------------------------------------# 设置背景颜色为深蓝色set_screen_bk_color:\tmovw\t$VIDEO_PALLETE_PORT,\t%dx\tmovb\t$PA_INDEX_BACKGROUND,\t%al\toutb\t%al,\t\t\t\t\t%dx\tmovw\t$COLOR_SELECTION_PORT,\t%dx\tmovb\t$0,\t\t\t\t\t\t%al\t\t# 红\toutb\t%al,\t\t\t\t\t%dx\tmovb\t$0,\t\t\t\t\t\t%al\t\t# 绿\toutb\t%al,\t\t\t\t\t%dx\tmovb\t$18,\t\t\t\t\t%al\t\t# 蓝（亮度18/63）\toutb\t%al,\t\t\t\t\t%dx\tret#----------------------------------------------------------------# 通过写显存绘制一些像素点：#\t首先设置调色板索引1处的颜色为白色#\t然后通过写显存的方式，向ES：DI写入数据（PA_INDEX_WHITE）draw_some_pixels:\t# 把索引1处的颜色改为白色（63，63，63）\tmovw\t$VIDEO_PALLETE_PORT,\t%dx\tmovb\t$PA_INDEX_WHITE,\t\t%al\toutb\t%al,\t\t\t\t\t%dx\tmovw\t$COLOR_SELECTION_PORT,\t%dx\tmovb\t$63,\t\t\t\t\t%al\t\t# 红\toutb\t%al,\t\t\t\t\t%dx\tmovb\t$63,\t\t\t\t\t%al\t\t# 绿\toutb\t%al,\t\t\t\t\t%dx\tmovb\t$63,\t\t\t\t\t%al\t\t# 蓝\toutb\t%al,\t\t\t\t\t%dx\t# 设置ES的值\tmovw\t$VIDEO_SEG_GRAPHIC,\t\t%ax\tmovw\t%ax,\t\t\t\t\t%es\t# 设置要显示的像素位置的显存地址（目的地址）\tmovw\t$(800*5),\t\t\t\t%di\t\t# 从第五行像素开始开始\tmovb\t$PA_INDEX_WHITE,\t\t%al\tmovw\t$800,\t\t\t\t\t%cx\t\t# 画800个连续像素即一条直线draw_a_pixel:\tstosb\t#addl\t$799,\t\t\t\t\t%edi\tloop\tdraw_a_pixel\tretmain:\tmovw\t%cx,\t%ax\tmovw\t%ax,\t%ds\tmovw\t%ax,\t%es\tcall\tclear_screen\t\t\t\t\t# 清屏\tcall\tset_video_mode_vbe_0x103\t\t# 设置显示模式\tcmpw\t$0,\t\t%ax\tjne\t\t1f\tcall\tset_video_mode_0x131:\tcall\tset_screen_bk_color\t# 设置背景颜色\tcall\tdraw_some_pixels\t# 绘制像素1:\tjmp\t\t1b# 常量定义：\tVIDEO_SEG_TEXT\t\t= 0x0e00\tVIDEO_SEG_GRAPHIC\t= 0xa000\tBUFFER_SEG\t\t\t= 0x800\tVIDEO_PALLETE_PORT\t= 0x3c8\tCOLOR_SELECTION_PORT= 0x3c9\t\tMODE_0x13\t\t\t= 0x13\tMODE_VBE_0x105\t\t= 0x0105\tMODE_VBE_0x103\t\t= 0x0103\tPA_INDEX_BACKGROUND\t= 0x0\tPA_INDEX_WHITE\t\t= 0x1video_mode:\t.short\t0screen_x:\t.short\t0screen_y:\t.short\t0video_ram:\t.long\t0\t.org\t0x1fe,\t0x90\t.word\t0xaa55","title":"babyos （四）—— SVGA、VBE基础与切换到髙分辨率模式"},{"content":"基本的Java套接字对于小规模系统可以很好地运行，但当涉及到要同时处理上千个客户端的服务器时，可能就会产生一些问题。其实在第4章已经可以看到一些迹象：由于创建、维护和切换线程需要的系统开销，一客户一线程方式在系统扩展性方面受到了限制。使用线程池可以节省那种系统开销，同时允许实现者利用并行硬件的优势。但对于连接生存期比较长的协议来说，线程池的大小仍然限制了系统可以同时处理的客户端数量。考虑一个在客户端之间传递消息的即时消息服务器（Instant Messaging）。客户端必须不停地连接服务器以接收即时消息，因此线程池的大小限制了系统可以同时服务的客户端总数。如果增加线程池的大小，将带来更多的线程处理开销，而不能提升系统的性能，因为在大部分的时间里客户端是处于闲置状态的。    如果这就是所有问题，可能NIO还不是必要的。不幸的是，在使用线程的扩展性方面还涉及一些更加难以把握的挑战。其中一个挑战就是程序员几乎不能对什么时候哪个线程将获得服务进行控制。你可以设置一个线程实例的优先级（priority）（高优先级的线程相对于低优先级的线程有优先权），但是这个优先级只是一种\"建议\"--下一个选择执行的线程完全取决于具体实现。[ ]因此，如果程序员想要保证某些连接优先获得服务，或想要指定一定的服务顺序，线程可能就很难做到。    然而，有关线程的最重要的问题可能是我们至今还未提及。那是因为在\"回显服务\"示例程序中，每个客户端都与其他客户端相互独立，客户端之间没有交互，也不会影响服务器的状态。但是在实际情况中，大多数的服务器有一些信息（称为\"状态\"）需要由不同的客户端同时访问或修改。例如，考虑一种允许大城市的市民保留一个小时停车位的服务。计划什么时间段由谁获得哪个停车位必须保持一致，而且，该服务必须保证同一用户在同一时间段内最多只能获得一个停车位。这些限制就要求在所有客户之间共享一些状态信息（即调度表）。这需要通过使用锁（locks）机制或其他互斥机制对依次访问状态进行严格的同步（synchronized）。否则，由于调度程序能够使不同线程上的程序段在一定程度上交错执行，如果不同线程试图同时更新调度表，它们就可能改写掉其他线程所作的修改。   由于需要对共享状态进行同步访问，要同时考虑到多线程服务器的正确性和高效性就变得非常困难。至于其为什么会增加复杂性已经超出了本书的讨论范围，只要进行简单的了解就足够了：使用同步机制将增加更多的系统调度和上下文切换开销，而程序员对这些开销又无法控制。由于其复杂性，一些程序员宁愿继续使用单线程（single-threaded）方法。这类服务器只用一个线程来处理所有的客户端--不是顺序处理，而是一次全部处理。这种服务器     不能为任何客户端提供I/O操作的阻塞等待，而必须排他地使用非阻塞式（nonblocking）I/O。回顾前面所介绍的非阻塞式I/O，我们需要指定调用I/O方法时的最长阻塞时间（包括0）。   在前面我们见过一个为accept操作设置超时（通过使用ServerSocket类的setSoTimeout()方法）的例子。当在ServerSocket实例上调用accept()方法时，如果有一个新的连接请求正在等待，accept()方法则立即返回；否则该方法将阻塞等待，直到有新的连接请求到来或计时器超时，这取决于哪个先发生（有连接请求或超时）。这里只有一个线程来处理多个连接。不幸的是，这种方法要求我们不断地轮询（poll）所有I/O源，而这种\"忙等（busy waiting）\"方法又会引入很多系统开销，因为程序要在连接之间反复循环，却又发现什么都不用做。   我们需要一种方法来一次轮询一组客户端，以查找哪个客户端需要服务。这正是NIO中将要介绍的Selector和Channel抽象的关键点。一个Channel实例代表了一个\"可轮询的（pollable）\"I/O目标，如套接字（或一个文件、设备等）。Channel能够注册一个Selector类的实例。Selector的select()方法允许你询问\"在一组信道中，哪一个当前需要服务（即，被接受，读或写）？\"大量的细节将在后文中介绍，但这就是使用Selector和Channel的基本动机。这两个类都包含在java.nio.channels包中。   NIO中将介绍的另一个主要特性是Buffer类。就像selector和channel为一次处理多个客户端的系统开销提供了更高级的控制和可预测性，Buffer则提供了比Stream抽象更高效和可预测的I/O。 Stream 抽象好的方面是隐藏了底层缓冲区的有限性，提供了一个能够容纳任意长度数据的容器的假象。坏的方面是要实现这样一个假象，要么会产生大量的内存开销，要么会引入大量的上下文切换，甚至可能两者都有。在使用线程时，这些开销都隐藏在了具体实现中，因此也失去了对其的可控性和可预测性。这种方法使编写程序变得容易，但要调整它们的性能则变得更困难。不幸的是，如果要使用Java的Socket抽象，流就是唯一的选择。   这就是为什么要把channel设计为使用Buffer实例来传递数据。Buffer抽象代表了一个有限容量（finite-capacity）的数据容器--其本质是一个数组，由指针指示了在哪存放数据和从哪读取数据。使用Buffer有两个主要好处。第一，与读写缓冲区数据相关联的系统开销暴露给了程序员。例如，如果想要向缓冲区存入数据，但又没有足够的空间时，就必须采取一些措施来获得空间（即，移出一些数据，或移开已经在那个位置的数据来获得空间，或者创建一个新的实例）。这意味着需要额外的工作，但是你（程序员）可以控制它什么时候发生，如何发生，以及是否发生。一个聪明的程序员如果清楚地了解了应用程序的需求，就那能通过权衡这些选择来降低系统开销。第二，一些对Java对象的特殊Buffer映射操作能够直接操作底层平台的资源（例如，操作系统的缓冲区）。这些操作节省了在不同地址空间中复制数据的开销--这在现代计算机体系结构中是开销很大的操作。   相关下载： Java_TCPIP_Socket编程(doc) http://download.csdn.net/detail/undoner/4940239   文献来源： UNDONER(小杰博客) ：http://blog.csdn.net/undoner LSOFT.CN(琅软中国) ：http://www.lsoft.cn  ","title":"NIO：为什么需要 NIO？"},{"content":"Java和C++一样，也有一些关键字用于处理异常。 注：以下2个示例只是为了尽可能把所有关键字都使用到，为了介绍关键字的使用位置，并不推荐以下做法。 C++中异常处理的关键字有：try.catch.throw，基本用法示例： \t\ttry\t\t{\t\t\tthrow E;\t\t}\t\tcatch (E e)\t\t{\t\t\t\t\t}\t\tcatch (...)\t\t{\t\t} throw E抛出自己定义的异常，然后catch。catch(...)用于处理所有上面没有catch的异常。 Java中异常处理的关键字有：try.catch.finally.throw.throws，基本用法示例： public void Err() throws E{　　try     { 　　   ... 　　}     catch (E e)     { 　　   throw e; 　　}    finally    {       ...    }} try.catch和C++类似，不过这里的catch没有catch(...)，但是有finally块，这个块是try结束以后，不管是否有异常，不管异常是否被捕获，都会执行的一个块。 另外，throw用于抛出异常，throws用于说明函数可能抛出什么异常。 Java异常分类 Throwable--异常基类 Error--Throwable的子类，一般由虚拟机抛出，比较严重的错误，程序要做的是安全退出，其他的无能为力 Exception--Throwable的子类，一般是由程序引起的异常 RuntimeException--Exception的子类，运行时出现的异常，数组越界、空指针这一类的，一般可以通过修改程序来避免 非RuntimeException--Exception的子类，IOException之类的 检验异常与非检验异常 看到有些地方把这2个概念说的很绕口，我个人的理解是： 1.检验异常就是编译器会检验你是否catch了的异常，编译器会强制要求你写对应的catch语句，否则编译报错。这些异常一般都是方法后面带有throws的，就是说，方法说明了自己可能会抛出异常的。至于编译器为什么要这么做，也比较好理解，因为我一个方法，既然我已经预见到了可能会抛出异常，那么你就必须要处理一下，我都提醒你会出错了，你还不处理，那你这安的是什么心？除非检验异常以外的异常，都属于这一类。 2.非检验异常就是编译器不会去检验你是否catch的，比如像数组越界、空指针这一类的，编译器不会来管你。RuntimeException和Error属于这一类。 以上是个人理解，如果有误，还请各位指出，以便及时纠正，谢谢！ 常见异常 ArrayIndexOfBoundsException--数组下标越界 ClassCastException-----------强制转换类失败 IllegalArgumentException-----参数异常 NullPointException-----------空指针异常 AssertionError---------------断言出错 ExceptionInInitializerError--初始化异常 StackOverflowError-----------栈溢出","title":"Java异常处理及与C++的比较--异常分类.检验异常.非检验异常.常见异常"},{"content":"java 7 NIO2新特性支持操作文件的属性，使用NIO2的API操作你自己的文件元数据。 NIO2的属性操作相关类包 我们看下示例代码： package com.mime;import java.io.IOException;import java.nio.ByteBuffer;import java.nio.charset.Charset;import java.nio.file.FileStore;import java.nio.file.FileSystem;import java.nio.file.FileSystems;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.nio.file.attribute.AclEntry;import java.nio.file.attribute.AclEntryPermission;import java.nio.file.attribute.AclEntryType;import java.nio.file.attribute.AclFileAttributeView;import java.nio.file.attribute.BasicFileAttributeView;import java.nio.file.attribute.BasicFileAttributes;import java.nio.file.attribute.DosFileAttributes;import java.nio.file.attribute.FileAttribute;import java.nio.file.attribute.FileOwnerAttributeView;import java.nio.file.attribute.FileStoreAttributeView;import java.nio.file.attribute.FileTime;import java.nio.file.attribute.GroupPrincipal;import java.nio.file.attribute.PosixFileAttributeView;import java.nio.file.attribute.PosixFileAttributes;import java.nio.file.attribute.PosixFilePermission;import java.nio.file.attribute.PosixFilePermissions;import java.nio.file.attribute.UserDefinedFileAttributeView;import java.nio.file.attribute.UserPrincipal;import java.util.List;import java.util.Set;import static java.nio.file.LinkOption.NOFOLLOW_LINKS;public class NIO2FileAttribute {\tpublic static void main(String[] args) {\t\tFileSystem fs = FileSystems.getDefault();\t\tSet<String> views = fs.supportedFileAttributeViews();\t\tfor (String view : views) {\t\t\tSystem.out.println(view);\t\t}\t\t/*\t\t * BasicFileAttributeView: This is a view of basic attributes that must\t\t * be supported by all file system implementations. The attribute view\t\t * name is basic. • DosFileAttributeView: This view provides the\t\t * standard four supported attributes on file systems that support the\t\t * DOS attributes. The attribute view name is dos. •\t\t * PosixFileAttributeView: This view extends the basic attribute view\t\t * with attributes supported on file systems that support the POSIX\t\t * (Portable Operating System Interface for Unix) family of standards,\t\t * such as Unix. The attribute view name is posix. •\t\t * FileOwnerAttributeView: This view is supported by any file system\t\t * implementation that supports the concept of a file owner. The\t\t * attribute view name is owner. • AclFileAttributeView: This view\t\t * supports reading or updating a file’s ACL. The NFSv4 ACL model is\t\t * supported. The attribute view name is acl.\t\t * UserDefinedFileAttributeView: This view enables support of metadata\t\t * that is user defined.\t\t */\t\tfor (FileStore store : fs.getFileStores()) {\t\t\tboolean supported = store\t\t\t\t\t.supportsFileAttributeView(BasicFileAttributeView.class);\t\t\tSystem.out.println(store.name() + \" ---\" + supported);\t\t}\t\tPath path = null;\t\ttry {\t\t\tpath = Paths.get(System.getProperty(\"user.home\"), \"www\",\t\t\t\t\t\"pyweb.settings\");\t\t\tFileStore store = Files.getFileStore(path);\t\t\tboolean supported = store.supportsFileAttributeView(\"basic\");\t\t\tSystem.out.println(store.name() + \" ---\" + supported);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\tBasicFileAttributes attr = null;\t\ttry {\t\t\tattr = Files.readAttributes(path, BasicFileAttributes.class);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\tSystem.out.println(\"File size: \" + attr.size());\t\tSystem.out.println(\"File creation time: \" + attr.creationTime());\t\tSystem.out.println(\"File was last accessed at: \"\t\t\t\t+ attr.lastAccessTime());\t\tSystem.out.println(\"File was last modified at: \"\t\t\t\t+ attr.lastModifiedTime());\t\tSystem.out.println(\"Is directory? \" + attr.isDirectory());\t\tSystem.out.println(\"Is  regular file? \" + attr.isRegularFile());\t\tSystem.out.println(\"Is  symbolic link? \" + attr.isSymbolicLink());\t\tSystem.out.println(\"Is  other? \" + attr.isOther());\t\t// 只获取某个属性 [view-name:]attribute-name\t\t/**\t\t * Basic attribute names are listed here: lastModifiedTime\t\t * lastAccessTime creationTime size isRegularFile isDirectory\t\t * isSymbolicLink isOther fileKey\t\t **/\t\ttry {\t\t\tlong size = (Long) Files.getAttribute(path, \"basic:size\",\t\t\t\t\tjava.nio.file.LinkOption.NOFOLLOW_LINKS);\t\t\tSystem.out.println(\"Size: \" + size);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\t// Update a Basic Attribute\t\tlong time = System.currentTimeMillis();\t\tFileTime fileTime = FileTime.fromMillis(time);\t\ttry {\t\t\tFiles.getFileAttributeView(path, BasicFileAttributeView.class)\t\t\t\t\t.setTimes(fileTime, fileTime, fileTime);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\ttry {\t\t\tFiles.setLastModifiedTime(path, fileTime);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\ttry {\t\t\tFiles.setAttribute(path, \"basic:lastModifiedTime\", fileTime,\t\t\t\t\tNOFOLLOW_LINKS);\t\t\tFiles.setAttribute(path, \"basic:creationTime\", fileTime,\t\t\t\t\tNOFOLLOW_LINKS);\t\t\tFiles.setAttribute(path, \"basic:lastAccessTime\", fileTime,\t\t\t\t\tNOFOLLOW_LINKS);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\t// DosFileAttributeView DOS attributes can be acquired with the\t\t// following names:hidden readonly system archive\t\tDosFileAttributes docattr = null;\t\ttry {\t\t\tdocattr = Files.readAttributes(path, DosFileAttributes.class);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\tSystem.out.println(\"Is read only ? \" + docattr.isReadOnly());\t\tSystem.out.println(\"Is Hidden ? \" + docattr.isHidden());\t\tSystem.out.println(\"Is archive ? \" + docattr.isArchive());\t\tSystem.out.println(\"Is  system ? \" + docattr.isSystem());\t\t// FileOwnerAttributeView\t\t// Set a File Owner Using Files.setOwner() 三种设置文件所有者的方法\t\tUserPrincipal owner = null;\t\ttry {\t\t\towner = path.getFileSystem().getUserPrincipalLookupService()\t\t\t\t\t.lookupPrincipalByName(\"apress\");\t\t\tFiles.setOwner(path, owner);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\tFileOwnerAttributeView foav = Files.getFileAttributeView(path,\t\t\t\tFileOwnerAttributeView.class);\t\ttry {\t\t\towner = path.getFileSystem().getUserPrincipalLookupService()\t\t\t\t\t.lookupPrincipalByName(\"apress\");\t\t\tfoav.setOwner(owner);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\ttry {\t\t\towner = path.getFileSystem().getUserPrincipalLookupService()\t\t\t\t\t.lookupPrincipalByName(\"apress\");\t\t\tFiles.setAttribute(path, \"owner:owner\", owner, NOFOLLOW_LINKS);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\t// 获取文件所有者\t\ttry {\t\t\tString ownerName = foav.getOwner().getName();\t\t\tSystem.out.println(ownerName);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\ttry {\t\t\tUserPrincipal owner1 = (UserPrincipal) Files.getAttribute(path,\t\t\t\t\t\"owner:owner\", NOFOLLOW_LINKS);\t\t\tSystem.out.println(owner1.getName());\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\t// POSIX View file owner, group owner, and nine related access\t\t// permissions (read, write, members of the same group, etc.). •group\t\t// permissions\t\tPosixFileAttributes positattr = null;\t\ttry {\t\t\tpositattr = Files.readAttributes(path, PosixFileAttributes.class);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\tSystem.out.println(\"File owner: \" + positattr.owner().getName());\t\tSystem.out.println(\"File group: \" + positattr.group().getName());\t\tSystem.out.println(\"File permissions: \"\t\t\t\t+ positattr.permissions().toString());\t\t// 设置文件访问权限\t\tFileAttribute<Set<PosixFilePermission>> posixattrs = PosixFilePermissions\t\t\t\t.asFileAttribute(positattr.permissions());\t\ttry {\t\t\tFiles.createFile(path, posixattrs);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\tSet<PosixFilePermission> permissions = PosixFilePermissions\t\t\t\t.fromString(\"rw-r--r--\");\t\ttry {\t\t\tFiles.setPosixFilePermissions(path, permissions);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\t// 设置分组用户\t\ttry {\t\t\tGroupPrincipal group = path.getFileSystem()\t\t\t\t\t.getUserPrincipalLookupService()\t\t\t\t\t.lookupPrincipalByGroupName(\"apressteam\");\t\t\tFiles.getFileAttributeView(path, PosixFileAttributeView.class)\t\t\t\t\t.setGroup(group);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\t// 查询组用户\t\ttry {\t\t\tGroupPrincipal group = (GroupPrincipal) Files.getAttribute(path,\t\t\t\t\t\"posix:group\", NOFOLLOW_LINKS);\t\t\tSystem.out.println(group.getName());\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\t// ACL View access control list acl owner\t\t// 查询acl属性\t\tList<AclEntry> acllist = null;\t\tAclFileAttributeView aclview = Files.getFileAttributeView(path,\t\t\t\tAclFileAttributeView.class);\t\ttry {\t\t\tacllist = aclview.getAcl();\t\t\tfor (AclEntry aclentry : acllist) {\t\t\t\tSystem.out\t\t\t\t\t\t.println(\"++++++++++++++++++++++++++++++++++++++++++++++++++++\");\t\t\t\tSystem.out.println(\"Principal: \"\t\t\t\t\t\t+ aclentry.principal().getName());\t\t\t\tSystem.out.println(\"Type: \" + aclentry.type().toString());\t\t\t\tSystem.out.println(\"Permissions: \"\t\t\t\t\t\t+ aclentry.permissions().toString());\t\t\t\tSystem.out.println(\"Flags: \" + aclentry.flags().toString());\t\t\t}\t\t} catch (Exception e) {\t\t\tSystem.err.println(e);\t\t}\t\t// 设置ACL属性\t\ttry {\t\t\t// Lookup for the principal\t\t\tUserPrincipal user = path.getFileSystem()\t\t\t\t\t.getUserPrincipalLookupService()\t\t\t\t\t.lookupPrincipalByName(\"apress\");\t\t\t// Get the ACL view\t\t\tAclFileAttributeView view = Files.getFileAttributeView(path,\t\t\t\t\tAclFileAttributeView.class);\t\t\t// Create a new entry\t\t\tAclEntry entry = AclEntry\t\t\t\t\t.newBuilder()\t\t\t\t\t.setType(AclEntryType.ALLOW)\t\t\t\t\t.setPrincipal(user)\t\t\t\t\t.setPermissions(AclEntryPermission.READ_DATA,\t\t\t\t\t\t\tAclEntryPermission.APPEND_DATA).build();\t\t\t// read ACL\t\t\tList<AclEntry> acl = view.getAcl();\t\t\t// Insert the new entry\t\t\tacl.add(0, entry);\t\t\t// rewrite ACL\t\t\tview.setAcl(acl);\t\t\t// or, like this\t\t\t// Files.setAttribute(path, \"acl:acl\", acl, NOFOLLOW_LINKS);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\t// File Store Attributes\t\t// 获取所有的fifilestore的属性信息\t\tFileSystem fs1 = FileSystems.getDefault();\t\tfor (FileStore store : fs1.getFileStores()) {\t\t\ttry {\t\t\t\tlong total_space = store.getTotalSpace() / 1024;\t\t\t\tlong used_space = (store.getTotalSpace() - store\t\t\t\t\t\t.getUnallocatedSpace()) / 1024;\t\t\t\tlong available_space = store.getUsableSpace() / 1024;\t\t\t\tboolean is_read_only = store.isReadOnly();\t\t\t\tSystem.out.println(\"--- \" + store.name() + \" --- \"\t\t\t\t\t\t+ store.type());\t\t\t\tSystem.out.println(\"Total space: \" + total_space);\t\t\t\tSystem.out.println(\"Used space: \" + used_space);\t\t\t\tSystem.out.println(\"Available space: \" + available_space);\t\t\t\tSystem.out.println(\"Is read only? \" + is_read_only);\t\t\t} catch (IOException e) {\t\t\t\tSystem.err.println(e);\t\t\t}\t\t}\t\t// 获取某个文件的fifilestore，再查询filestroe的属性信息\t\ttry {\t\t\tFileStore store = Files.getFileStore(path);\t\t\tFileStoreAttributeView fsav = store\t\t\t\t\t.getFileStoreAttributeView(FileStoreAttributeView.class);\t\t} catch (IOException e) {\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t}\t\t// User-Defined File Attributes View 用户自定义文件属性\t\t// 检测文件系统是否支持自定义属性\t\ttry {\t\t\tFileStore store = Files.getFileStore(path);\t\t\tif (!store\t\t\t\t\t.supportsFileAttributeView(UserDefinedFileAttributeView.class)) {\t\t\t\tSystem.out\t\t\t\t\t\t.println(\"The user defined attributes are not supported on: \"\t\t\t\t\t\t\t\t+ store);\t\t\t} else {\t\t\t\tSystem.out\t\t\t\t\t\t.println(\"The user defined attributes are supported on: \"\t\t\t\t\t\t\t\t+ store);\t\t\t}\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\t// 设置文件属性\t\tUserDefinedFileAttributeView udfav = Files.getFileAttributeView(path,\t\t\t\tUserDefinedFileAttributeView.class);\t\ttry {\t\t\tint written = udfav.write(\t\t\t\t\t\"file.description\",\t\t\t\t\tCharset.defaultCharset().encode(\t\t\t\t\t\t\t\"This file contains private information!\"));\t\t\tSystem.out.println(\"write user defined file attribute return :\"\t\t\t\t\t+ written);\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\t// 获取文件的所有自定义属性\t\ttry {\t\t\tfor (String name : udfav.list()) {\t\t\t\tSystem.out.println(udfav.size(name) + \"\" + name);\t\t\t}\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\ttry {\t\t\tint size = udfav.size(\"file.description\");\t\t\tByteBuffer bb = ByteBuffer.allocateDirect(size);\t\t\tudfav.read(\"file.description\", bb);\t\t\tbb.flip();\t\t\tSystem.out.println(Charset.defaultCharset().decode(bb).toString());\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t\t//删除自定义文件属性\t\ttry {\t\t\tudfav.delete(\"file.description\");\t\t} catch (IOException e) {\t\t\tSystem.err.println(e);\t\t}\t}} 在我的文件系统的输出 basicowneruserunixdosposix/dev/loop0 ---trueproc ---truesysfs ---truenone ---truenone ---truenone ---trueudev ---truedevpts ---truetmpfs ---truenone ---truenone ---truenone ---true/dev/sda6 ---truebinfmt_misc ---truegvfsd-fuse ---true/dev/sda5 ---truerootfs ---trueFile size: 265File creation time: 2012-12-29T12:53:35ZFile was last accessed at: 2012-12-29T12:53:35ZFile was last modified at: 2012-12-29T12:53:35ZIs directory? falseIs  regular file? trueIs  symbolic link? falseIs  other? falseSize: 265Is read only ? falseIs Hidden ? falseIs archive ? falseIs  system ? falsejava.nio.file.attribute.UserPrincipalNotFoundExceptionweijianzhongwjweijianzhongwjFile owner: weijianzhongwjjava.nio.file.attribute.UserPrincipalNotFoundExceptionjava.nio.file.attribute.UserPrincipalNotFoundExceptionFile group: weijianzhongwjFile permissions: [OWNER_WRITE, OTHERS_READ, GROUP_READ, OWNER_READ]java.nio.file.FileAlreadyExistsException: /home/weijianzhongwj/www/pyweb.settingsjava.nio.file.attribute.UserPrincipalNotFoundExceptionweijianzhongwjjava.lang.NullPointerExceptionjava.nio.file.attribute.UserPrincipalNotFoundException--- /dev/loop0 --- ext4Total space: 29979608Used space: 17216488Available space: 11240228Is read only? false--- proc --- procTotal space: 0Used space: 0Available space: 0Is read only? false--- sysfs --- sysfsTotal space: 0Used space: 0Available space: 0Is read only? false--- none --- fusectlTotal space: 0Used space: 0Available space: 0Is read only? false--- none --- debugfsTotal space: 0Used space: 0Available space: 0Is read only? false--- none --- securityfsTotal space: 0Used space: 0Available space: 0Is read only? false--- udev --- devtmpfsTotal space: 4063888Used space: 4Available space: 4063884Is read only? false--- devpts --- devptsTotal space: 0Used space: 0Available space: 0Is read only? false--- tmpfs --- tmpfsTotal space: 1628652Used space: 892Available space: 1627760Is read only? false--- none --- tmpfsTotal space: 5120Used space: 0Available space: 5120Is read only? false--- none --- tmpfsTotal space: 4071628Used space: 380Available space: 4071248Is read only? false--- none --- tmpfsTotal space: 102400Used space: 8Available space: 102392Is read only? false--- /dev/sda6 --- fuseblkTotal space: 164089852Used space: 101256692Available space: 62833160Is read only? false--- binfmt_misc --- binfmt_miscTotal space: 0Used space: 0Available space: 0Is read only? false--- gvfsd-fuse --- fuse.gvfsd-fuseTotal space: 0Used space: 0Available space: 0Is read only? false--- /dev/sda5 --- fuseblkTotal space: 102399704Used space: 81181588Available space: 21218116Is read only? falseThe user defined attributes are supported on: / (rootfs)write user defined file attribute return :3939file.descriptionThis file contains private information!","title":"java 7 NIO2（2） Metadata File Attributes"},{"content":"NetBeans在键盘输入上有许多小秘密，本文描述了如何使用其“代码模板”及“宏”功能来简化输入。 1. 代码模板 工具 -> 选项 -> 编辑器 -> 代码模板，在“语言”下拉框中选“XML”，按“新建”按钮，在“新建代码模板”窗口的“缩写”框中输入“sect”，单击“确定”按钮。“新建代码模板”窗口关闭，并返回“选项”窗口。在该窗口“模板”列表中，已自动选择刚刚输入的“sect”项。在下面的“展开的文本”标签页中，输入 <section>    <title>${cursor}<\/title>    <para><\/para><\/section> 在“描述”标签页中，输入“DocBook Section”。单击“确定”按钮，关闭“选项”窗口。 在NetBeans编辑区域，输入“sect”，再按键盘上的“Tab”键，NetBeans将自动在光标所在的位置生成上面的代码，并将光标定位在title标签的中间。特别方便。 依此类推，可为最常用的DocBook标签添加相应的代码模板。 2. 宏 工具 -> 选项 -> 编辑器 -> 宏，按“新建”按钮，输入宏名称“surround-with-<filename>”,按“确定”按钮。在“宏代码”框中输入： cut-to-clipboard \"<filename>\" paste-from-clipboard \"<\/filename>\" 点击“设置快捷键...”按钮，在键盘上按CTRL + ALT + F键，单击“确定”按钮。再次单击“确定”按钮，关闭“选项”窗口。 在NetBeans编辑区域，使用鼠标刷选一个文件名，如“C:\\Hello.c”，在键盘上按CTRL + ALT + F键，NetBeans将自动将“C:\\Hello.c”转换为： <filename>C:\\Hello.c<\/filename> 上面使用了NetBeans的宏关键字，可参考http://netbeans.org/kb/docs/ide/macro-keywords.html查看完整的关键字。","title":"在NetBeans中使用代码模板及宏功能简化输入"},{"content":"Chart1.Titles[0].Text = sTitle;             if (scharttype == \"Column\")             {                 Chart1.Series[\"Series1\"].ChartType = SeriesChartType.Column;                 Chart1.Series[\"Series2\"].ChartType = SeriesChartType.Line;             }             else             {                 Chart1.Series[\"Series1\"].ChartType = SeriesChartType.Column;                 Chart1.Series[\"Series2\"].ChartType = SeriesChartType.Line;             }             //以下属性可以设定Series1使用Y1轴。Series2使用Y2轴的刻度             Chart1.Series[\"Series1\"].XAxisType = AxisType.Primary;             Chart1.Series[\"Series1\"].YAxisType = AxisType.Primary;             Chart1.Series[\"Series2\"].XAxisType = AxisType.Secondary;             Chart1.Series[\"Series2\"].YAxisType = AxisType.Secondary;","title":"[MSChart] 使用双X,Y轴的C#代码"},{"content":"前面的REST API还要继续改进，因为Ajax调用通常都需要JSON格式的响应，所以修改test.clj文件如下： (ns my-website.rest.test  (:require [noir.response :as response])  (:use [noir.core :only [defpage]]))(defpage \"/rest/:id\" {:keys [id]} (response/json {:userId id})) :require 引入了noir.response, 并且使用response作为别名。 这样在defpage的最后引入了response/json 来生成json格式的http响应。 参考API文档：http://www.webnoir.org/autodoc/1.3.0/noir.response.html#var-json json(json content)Wraps the response in the json content type and generates JSON from the content 浏览器上显示的数据为： {\"userId\":\"freebird\"}并且Chrome中跟踪可以看到Type为application/json 如果这时候关闭应用程序，以后再使用lein run的时候，会看到异常信息： ~/my-website$ lein runException in thread \"main\" java.lang.ExceptionInInitializerError\tat java.lang.Class.forName0(Native Method)\tat java.lang.Class.forName(Class.java:247)\tat clojure.lang.RT.loadClassForName(RT.java:2056)\tat clojure.lang.RT.load(RT.java:419)\tat clojure.lang.RT.load(RT.java:400)\tat clojure.core$load$fn__4890.invoke(core.clj:5415)\tat clojure.core$load.doInvoke(core.clj:5414)\tat clojure.lang.RestFn.invoke(RestFn.java:408)\tat clojure.core$load_one.invoke(core.clj:5227)\tat clojure.core$load_lib.doInvoke(core.clj:5264)\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\tat clojure.core$apply.invoke(core.clj:603)\tat clojure.core$load_libs.doInvoke(core.clj:5298)\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\tat clojure.core$apply.invoke(core.clj:605)\tat clojure.core$use.doInvoke(core.clj:5392)\tat clojure.lang.RestFn.invoke(RestFn.java:436)\tat cheshire.core$loading__4784__auto__.invoke(core.clj:1)\tat cheshire.core__init.load(Unknown Source)\tat cheshire.core__init.<clinit>(Unknown Source)\tat java.lang.Class.forName0(Native Method)\tat java.lang.Class.forName(Class.java:247)\tat clojure.lang.RT.loadClassForName(RT.java:2056)\tat clojure.lang.RT.load(RT.java:419)\tat clojure.lang.RT.load(RT.java:400)\tat clojure.core$load$fn__4890.invoke(core.clj:5415)\tat clojure.core$load.doInvoke(core.clj:5414)\tat clojure.lang.RestFn.invoke(RestFn.java:408)\tat clojure.core$load_one.invoke(core.clj:5227)\tat clojure.core$load_lib.doInvoke(core.clj:5264)\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\tat clojure.core$apply.invoke(core.clj:603)\tat clojure.core$load_libs.doInvoke(core.clj:5298)\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\tat clojure.core$apply.invoke(core.clj:603)\tat clojure.core$require.doInvoke(core.clj:5381)\tat clojure.lang.RestFn.invoke(RestFn.java:421)\tat noir.response$loading__4784__auto__.invoke(response.clj:1)\tat noir.response__init.load(Unknown Source)\tat noir.response__init.<clinit>(Unknown Source)\tat java.lang.Class.forName0(Native Method)\tat java.lang.Class.forName(Class.java:247)\tat clojure.lang.RT.loadClassForName(RT.java:2056)\tat clojure.lang.RT.load(RT.java:419)\tat clojure.lang.RT.load(RT.java:400)\tat clojure.core$load$fn__4890.invoke(core.clj:5415)\tat clojure.core$load.doInvoke(core.clj:5414)\tat clojure.lang.RestFn.invoke(RestFn.java:408)\tat clojure.core$load_one.invoke(core.clj:5227)\tat clojure.core$load_lib.doInvoke(core.clj:5264)\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\tat clojure.core$apply.invoke(core.clj:603)\tat clojure.core$load_libs.doInvoke(core.clj:5298)\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\tat clojure.core$apply.invoke(core.clj:603)\tat clojure.core$require.doInvoke(core.clj:5381)\tat clojure.lang.RestFn.invoke(RestFn.java:408)\tat my_website.rest.test$loading__4784__auto__.invoke(test.clj:1)\tat my_website.rest.test__init.load(Unknown Source)\tat my_website.rest.test__init.<clinit>(Unknown Source)\tat java.lang.Class.forName0(Native Method)\tat java.lang.Class.forName(Class.java:247)\tat clojure.lang.RT.loadClassForName(RT.java:2056)\tat clojure.lang.RT.load(RT.java:419)\tat clojure.lang.RT.load(RT.java:400)\tat clojure.core$load$fn__4890.invoke(core.clj:5415)\tat clojure.core$load.doInvoke(core.clj:5414)\tat clojure.lang.RestFn.invoke(RestFn.java:408)\tat clojure.core$load_one.invoke(core.clj:5227)\tat clojure.core$load_lib.doInvoke(core.clj:5264)\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\tat clojure.core$apply.invoke(core.clj:603)\tat clojure.core$load_libs.doInvoke(core.clj:5298)\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\tat clojure.core$apply.invoke(core.clj:603)\tat clojure.core$require.doInvoke(core.clj:5381)\tat clojure.lang.RestFn.invoke(RestFn.java:408)\tat noir.server$load_views_ns.doInvoke(server.clj:37)\tat clojure.lang.RestFn.invoke(RestFn.java:408)\tat my_website.server__init.load(Unknown Source)\tat my_website.server__init.<clinit>(Unknown Source)\tat java.lang.Class.forName0(Native Method)\tat java.lang.Class.forName(Class.java:247)\tat clojure.lang.RT.loadClassForName(RT.java:2056)\tat clojure.lang.RT.load(RT.java:419)\tat clojure.lang.RT.load(RT.java:400)\tat clojure.core$load$fn__4890.invoke(core.clj:5415)\tat clojure.core$load.doInvoke(core.clj:5414)\tat clojure.lang.RestFn.invoke(RestFn.java:408)\tat clojure.core$load_one.invoke(core.clj:5227)\tat clojure.core$load_lib.doInvoke(core.clj:5264)\tat clojure.lang.RestFn.applyTo(RestFn.java:142)\tat clojure.core$apply.invoke(core.clj:603)\tat clojure.core$load_libs.doInvoke(core.clj:5298)\tat clojure.lang.RestFn.applyTo(RestFn.java:137)\tat clojure.core$apply.invoke(core.clj:603)\tat clojure.core$require.doInvoke(core.clj:5381)\tat clojure.lang.RestFn.invoke(RestFn.java:408)\tat user$eval1.invoke(NO_SOURCE_FILE:1)\tat clojure.lang.Compiler.eval(Compiler.java:6511)\tat clojure.lang.Compiler.eval(Compiler.java:6500)\tat clojure.lang.Compiler.eval(Compiler.java:6477)\tat clojure.core$eval.invoke(core.clj:2797)\tat clojure.main$eval_opt.invoke(main.clj:297)\tat clojure.main$initialize.invoke(main.clj:316)\tat clojure.main$null_opt.invoke(main.clj:349)\tat clojure.main$main.doInvoke(main.clj:427)\tat clojure.lang.RestFn.invoke(RestFn.java:421)\tat clojure.lang.Var.invoke(Var.java:419)\tat clojure.lang.AFn.applyToHelper(AFn.java:163)\tat clojure.lang.Var.applyTo(Var.java:532)\tat clojure.main.main(main.java:37)Caused by: java.lang.ClassNotFoundException: com.fasterxml.jackson.core.JsonFactory\tat java.net.URLClassLoader$1.run(URLClassLoader.java:202)\tat java.security.AccessController.doPrivileged(Native Method)\tat java.net.URLClassLoader.findClass(URLClassLoader.java:190)\tat java.lang.ClassLoader.loadClass(ClassLoader.java:306)\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)\tat java.lang.ClassLoader.loadClass(ClassLoader.java:247)\tat java.lang.Class.forName0(Native Method)\tat java.lang.Class.forName(Class.java:169)\tat cheshire.factory__init.__init0(Unknown Source)\tat cheshire.factory__init.<clinit>(Unknown Source)不清楚lein内部的机制。但是有个办法可以解决。首先运行lein clean 清理工程。 再次运行lein run，会重新编译整个工程。然后一切就好了。","title":"用Clojure编写REST service 三 返回JSON"},{"content":"    有很近没看了，也望的差不多了。贴上代码做个记忆吧。     stack.h #define NULL 0typedef union{   double data;   char symbol;}ElementType;typedef struct{   ElementType *pbuffer;   int max;   int top;}Stack;Stack *InitStack(int n);int Push(Stack *sp,ElementType *pdata);int Pop(Stack *sp,ElementType *pdata);int DestroyStack(Stack *sp);int IsEmpty(Stack *sp);int IsFull(Stack *sp);int TravereStack(Stack *sp,int (*pfn)(ElementType *pdata)); stack.c #include \"stack.h\"#include <malloc.h>#include <stdio.h>#include <string.h>Stack *InitStack(int n){    Stack *sp = NULL;\tsp = (Stack *)malloc(sizeof(Stack));\tif(!sp)\t{\t   return sp;\t}    sp->pbuffer = (ElementType *)malloc(sizeof(ElementType)*n);\tif(!sp->pbuffer)\t{\t   free(sp);\t   sp=NULL;\t   return sp;\t}\tsp->max = n;\tsp->top = -1;    return sp;}int Push(Stack *sp,ElementType *pdata){   if(IsFull(sp))   {       return 0;   }      sp->top++;   //sp->pbuffer[sp->top] = *pdata;   memcpy(sp->pbuffer + sp->top,pdata,sizeof(ElementType));   return 1;}int Pop(Stack *sp,ElementType *pdata){   if(IsEmpty(sp))   {       return 0;   }   *pdata = sp->pbuffer[sp->top];   sp->top--;   return 1;}int DestroyStack(Stack *sp){   if(sp)   {      free(sp->pbuffer);\t  free(sp);\t  return 1;   }   return 0;}int IsEmpty(Stack *sp){   return sp->top == -1;}int IsFull(Stack *sp){   return sp->top == sp->max;}int TravereStack(Stack *sp,int (*pfn)(ElementType *pdata)){   int i =0;   for(i=0;i<sp->top+1;i++)   {      pfn(sp->pbuffer+i);\t   }   printf(\"\\n\");   return 1;} 主要实现的代码： #include \"stack.h\"#include <malloc.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <ctype.h>typedef struct {\tStack *spdata;\tStack *spsymbol;\tint total;}Cal;int SignTab[7][7] = {//       +   -   *    /    (   )    #/* + */  1,  1, -1,  -1,  -1,  1,   1,/* - */  1,  1, -1,  -1,  -1,  1,   1,/* * */  1,  1,  1,   1,  -1,  1,   1,/* / */  1,  1,  1,   1,  -1,  1,   1,/* ( */ -1, -1, -1,  -1,  -1,  0,   2,/* ) */  1,  1,  1,   1,   1,  1,   1,/* # */ -1, -1, -1,  -1,  -1,  2,   0};Cal *InitCal(int n){\tint i =0;    Cal *cal = (Cal *)malloc(sizeof(Cal));\tif(!cal)\t{\t\treturn cal;\t}    \t\tcal->total = n;        cal->spdata = InitStack(cal->total);\tif(!cal->spdata)\t{\t\tfree(cal);\t\treturn cal;\t}\t\tcal->spsymbol = InitStack(cal->total);\tif(!cal->spsymbol)\t{\t\tfree(cal);\t\treturn cal;\t}\t\treturn cal;}char * GetStr(){\tint i =0;\tchar *str = (char *)malloc(sizeof(char)*20);    printf(\"请输入计算表达式：\");\tgets(str);\twhile(*(str+i))\t{        i++;\t}    *(str+i) = '#';\t*(str+i+1)= '\\0';\t    return str;}int IsInt(char *sign){    if(*sign>='0' && *sign<='9')\t{\t\treturn 1;\t}\treturn 0;}int Yanzheng(char * str){    int i =0;\tint j = 0;\tint flag = 0;\tint zuok = 0;\tint youk = 0;        char *sy = \"+-*/()#.0123456789\";    while(*(str+i))\t{       \twhile(*(sy+j))\t\t{\t\t\tif (*(sy+j) == *(str+i))\t\t\t{\t\t\t\tflag = 1;\t\t\t\tbreak;\t\t\t} \t\t\telse\t\t\t{                flag = 0;\t\t\t\t\t\t}\t\t\tj++;\t\t}        \t\t\tj=0;\t\tif (flag)\t\t{\t\t\ti++;\t\t}\t\telse\t\t{\t\t   flag = 0;\t\t   return flag;\t\t  \t\t}\t}\ti =0;\twhile(*(str+i))\t{        if (*(str+i)=='(')        {\t\t\tzuok++;        }\t\tif (*(str+i)==')')\t\t{\t\t\tyouk++;\t\t}        \t\t\tfor (int m =0; m<4;m++)\t\t{\t\t   if (*(str+i)==*(sy+m))\t\t   {\t\t\t   if (IsInt(str+i+1) || *(str+i+1)=='#' || *(str+i+1) == '(' || *(str+i+1) == ')')\t\t\t   {\t\t\t\t   flag = 1;\t\t\t   } \t\t\t   else\t\t\t   {\t\t\t\t   flag = 0;\t\t\t\t   return flag;\t\t\t\t   break;\t\t\t   }\t\t   }\t\t  \t\t}\t\ti++;         \t}\tif (zuok==youk)\t{\t\tflag = 1;\t}\telse\t{\t\tflag = 0;\t}\treturn flag;}int ShowStack(ElementType *pdata){    printf(\"%f \",*pdata);\treturn 1;}void FreeTwoStack(Cal *cal){    if (cal->spdata)    {\t\tfree(cal->spdata);\t\tcal->spdata = 0;    }\tif (cal->spsymbol)\t{\t\tfree(cal->spsymbol);\t\tcal->spsymbol = 0;\t}}int DestroyCal(Cal *cal){    if(cal)\t{\t   FreeTwoStack(cal);\t   free(cal);\t   return 1;\t}\treturn 0;}double SignFun(double *frist,double *last,ElementType *sign){\tswitch(sign->symbol)\t{\t  case '+':   \t    return *frist + *last;\t\tbreak;\t  case '-':   \t    return *frist - *last;\t\tbreak;\t  case '*':   \t    return (*frist) * (*last);\t\tbreak;      case '/':   \t    return (*frist) / (*last);\t\tbreak;\t}\treturn 0;}int SignTabR(char signf,char signl){   int x = 0;   int y = 0;   int i=0;   char str[] = \"+-*/()#\";   for(i=0;i<(int)strlen(str);i++)   {      if(signf==*(str+i))\t  {\t     x = i;\t  }      if(signl==*(str+i))\t  {\t     y = i;\t  }   }      return SignTab[x][y];}int IsNumber(char * str){\treturn ( (*str >= 0x30 && *str <= 0x39) || (*str == '.') ) ? 1 : 0 ;}int\tClaExpress(Cal *cal,char *str){\tint i = 0;\tint k = 0;\tint s = 0;\tchar sf;\tchar sl;\tint tabsign;\t\tdouble data1;\tdouble data2;\tdouble resultfs;  \tchar tmp[50] = {0};\tdouble tmpdata;\tElementType *tmpElem = NULL;//申请的空间太多了。\ttmpElem = (ElementType *)malloc(sizeof(ElementType));\tElementType * signf = NULL; \tsignf = (ElementType *)malloc(sizeof(ElementType));\tElementType * signl = NULL; \tsignl = (ElementType *)malloc(sizeof(ElementType));\tElementType * cdata1 = NULL;\tcdata1 = (ElementType *)malloc(sizeof(ElementType));//必须进行初始化\tElementType * cdata2 = NULL;\tcdata2 = (ElementType *)malloc(sizeof(ElementType));//必须进行初始化\t    while(*(str+i))\t{       switch(IsNumber(str+i))       {\t       case 1:\t\t\t *(tmp+k) = *(str+i);\t\t\t k++;\t\t\t \t\t\t break;\t\t   case 0:\t\t\t                if (k!=0)              {\t\t\t\t  \t\t\t\t  tmpdata  = atof(tmp);\t\t\t\t  \t\t\t\t  tmpElem->data = tmpdata;\t\t\t\t  Push(cal->spdata,tmpElem);              }              \t\t\t \t\t\t  s = 0;\t\t\t  while(*(tmp+s))\t\t\t  {\t\t\t\t  *(tmp+s) = NULL;                  s++;\t\t\t  }\t\t\t  k = 0;\t\t\t  if (k==0)\t\t\t  {\t\t\t\t  tmpElem->symbol = *(str+i);\t\t\t\t  Push(cal->spsymbol,tmpElem);\t\t\t  }\t\t\t  break;       }       \t   while(cal->spsymbol->top>0)\t   {           Pop(cal->spsymbol,signl);\t\t   sl = signl->symbol;\t\t   Pop(cal->spsymbol,signf);\t\t   sf = signf->symbol;\t\t   tabsign = SignTabR(sf,sl);           \t\t   \tswitch(tabsign)\t\t\t{\t\t\tcase -1 : /* -1 入栈 */\t\t\t/*\t解析的同时已经入栈 */\t\t\t\tbreak ;\t\t\tcase 0 :\t/* 0  出栈 */\t\t\t\tPop(cal->spsymbol,signf);\t\t\t\tPop(cal->spsymbol,signf);\t\t\t\t\t\t\tbreak ;\t\t\t\t\tcase 1 :\t/* 1  执行 */\t\t\t    Pop(cal->spdata,cdata2);                data2 = cdata2->data;\t\t\t                Pop(cal->spdata,cdata1);                data1 = cdata1->data;                \t\t\t    resultfs = SignFun(&data1,&data2,signf);\t\t\t\t\t\t\ttmpElem->data = resultfs;\t\t\t\tPush(cal->spdata,tmpElem);\t\t\t\t\t\t\t\t\t\t\ttmpElem->symbol = sl;\t\t\t\tPush(cal->spsymbol,tmpElem);\t\t\t\tbreak;\t\t\t\tcase 2 :\t/* 2  错误 */\t\t\t\tprintf(\"表达式出错！\");\t\t\t\tbreak ;\t\t\t\tdefault :\t\t\t\tbreak ;\t\t\t}\t   }\t   i++;\t}\tPop(cal->spdata,cdata1);\tprintf(\"%f\",cdata1->data);\treturn 1;}int main(){    Cal *cal = InitCal(10);\t    char *str = GetStr();\tif (Yanzheng(str))\t{        ClaExpress(cal,str);\t}\telse\t{\t\tprintf(\"字符串表达式出错！\");\t}\tDestroyCal(cal);\treturn 1;} 仅仅实现了简单的功能，做个参考吧。     ","title":"简单的计算器"},{"content":"C语言提供了几个标准库函数，可以将任意类型(整型、长整型、浮点型等)的数字转换为字符串。以下是用itoa()函数将整数转 换为字符串的一个例子：        atoi     把字符串转换成整型数        itoa     把一整数转换为字符串   [cpp] view plaincopyprint? #include \"stdio.h\"   #include \"ctype.h\"   #include \"stdlib.h\"     /* Converts a character string into an int or long 将一个字符串转化为整数 */  int my_atoi(char s[])  {      int i,n,sign;        for(i=0;isspace(s[i]);i++);   //跳过空白         sign=(s[i]=='-')?-1:1;      if(s[i]=='+'||s[i]==' -')     //跳过符号位           i++;      for(n=0;isdigit(s[i]);i++)          n=10*n+(s[i]-'0');        //将数字字符转换成整形数字       return sign*n;  }    /* Converts an int or long into a character string 将一个整数转化为字符串 */  void my_itoa(int n,char s[])  {     int i,j,sign;      if((sign=n)<0)    //记录符号           n=-n;         //使n成为正数       i=0;      do{         s[i++]=n%10+'0';    //取下一个数字       }while((n/=10)>0);      //循环相除       if(sign<0)          s[i++]='-';      s[i]='\\0';     for(j=i-1;j>=0;j--)        //生成的数字是逆序的，所以要逆序输出           printf(\"%c\",s[j]);  }    void main()  {      int n;      char str[100];     my_itoa(-123,str);      printf(\"\\n\");      printf(\"%d\\n\",my_atoi(\"123\"));      system(\"pause\");  } 原文来自 站长网www.software8.co/","title":"atoi() 与 itoa()函数的内部实现"},{"content":"冒泡排序，是指计算机的一种排序方法，它的时间复杂度为O（n^2），虽然不及堆排序、快速排序的O（nlogn，底数为2），但是有两个优点：1.“编程复杂度”很低，很容易写出代码；2.具有稳定性，这里的稳定性是指原序列中相同元素的相对顺序仍然保持到排序后的序列，而堆排序、快速排序均不具有稳定性。不过，一路、二路归并排序、不平衡二叉树排序的速度均比冒泡排序快，且具有稳定性，但速度不及堆排序、快速排序。冒泡排序是经过n-1趟子排序完成的，第i趟子排序从第1个数至第n-i个数，若第i个数比后一个数大（则升序，小则降序）则交换两数。 （冒泡排序有正向冒泡，也有反向冒泡，原理都一样，只不过在排序的时候，前者是将最小的数前移，后者是将最大的数后移。本文以正向冒泡为主） 冒泡排序的基本概念是：依次比较相邻的两个数，将大数放在前面，小数放在后面。即首先比较第1个和第2个数，将大数放前，小数放后。然后比较第2个数和第3个数，将大数放前，小数放后，如此继续，直至比较最后两个数，将大数放前，小数放后，此时第一趟结束，在最后的数必是所有数中的最小数。重复以上过程，仍从第一对数开始比较（因为可能由于第2个数和第3个数的交换，使得第1个数不再大于第2个数），将大数放前，小数放后，一直比较到最小数前的一对相邻数，将大数放前，小数放后，第二趟结束，在倒数第二个数中得到一个新的最小数。如此下去，直至最终完成排序。 排序过程 　　设想被排序的数组R［1..N］垂直竖立，将每个数据元素看作有重量的气泡，根据轻气泡不能在重气泡之下的原则，从下往上扫描数组R，凡扫描到违反本原则的轻气泡，就使其向上\"漂浮\"，如此反复进行，直至最后任何两个气泡都是轻者在上，重者在下为止。 代码示例： //冒泡排序#include<iostream>using namespace std;void BubbleSort(int *a,int n){\tfor(int i=0;i<n;i++)//从第一个元素开始，不断的缩小待排序的序列\t\tfor(int j=n;j>i;j--)//反向检测，检测是否逆序\t\t\tif(a[j] < a[j-1])//条件判断是否需要逆序\t\t\t\tswap(a[j-1],a[j]);//交换两数}void main(){\tint a[]={44,3,1,4,6,53,5};\tBubbleSort(a,6);\tfor(int i=0;i<7;i++)\t\tcout<<a[i]<<\" \";\tcout<<endl;} 起泡排序中，第i趟起泡中需要执行i-1次比较和交换。因此 i 从0 到 n-1 ，执行的比较操作的次数为: ( n - 1) + ( n - 2 ) + ( n - 3 ) + ( n - 4 ) + ...+ 2 + 1 = n ( n - 1 ) / 2 = O( n ^ 2) . 从排序的执行过程中我们可以看到基本的起泡排序的数据比较次数与输入序列中待排序元素的起始排序有关，但数据的交换次数与各待排序元素的初始位置排列有关，它与逆序的发生有关，最好的情况是可能一次也不交换，最差的情况下，每次比较都需要交换。 我们可以考虑对起泡排序算法的改进。具体的某一个待排序元素序列可能不需要执行n - 1 次趟 排序就能全部排好。为此 ，我们可以再算法中加上一个标记 flag ,用来标示本趟起泡结果是否发生了逆序 和 交换 。如果没有发生交换，则 flag = false ，表示全部的元素都已经排好了，可以进行终止处理，否则继续进行排序。 改进后的代码如下： //冒泡排序#include<iostream>using namespace std;void BubbleSort(int *a,int n){\tbool flag;\tfor(int i=0;i<n;i++)//从第一个元素开始，不断的缩小待排序的序列\t{\tflag = true;\t\tfor(int j=n;j>i;j--)//反向检测，检测是否逆序\t\t\tif(a[j] < a[j-1])//条件判断是否需要逆序\t\t\t{\t\t\t\t\tswap(a[j-1],a[j]);//交换两数\t\t\t\tflag = false;\t\t\t\t\t\t}\t\t\tif(flag == true)\t\t\treturn ;\t}}void main(){\tint a[]={44,3,1,4,6,53,5};\tBubbleSort(a,6);\tfor(int i=0;i<7;i++)\t\tcout<<a[i]<<\" \";\tcout<<endl;}","title":"[置顶] 冒泡排序 知识点小结"},{"content":"    当你刚开始学习perl的时候，写好了程序，准备兴高采烈的等待结果输出时，结果双击后，看到屏幕闪了一下，然后什么都没有了。根本没有机会然你看到输出的结果。 怎么解决这种问题呢？其实各种语言都有这个问题！解决的思路就是让程序输出结果以后，继续等待用户的输出就可以了 也就是在脚本的末端加上这样的两行 print \"press <Enter> to continue...\";<STDIN> 就是这样，","title":"perl基础技巧：避免脚本在windows中闪一下就关闭"},{"content":"强类型与弱类型语言 像C++,C,Java,C#这些主流的编程语言都是强类型语言.而一些脚本语言则是弱类型的,比如vbscript , javascript. 1.型语言简单的理解就是当定义了一个变量之后就会指定一个固定的类型,并对应一个固定的内存块大小.比如有int , double ,long这一个个的类型.并且一旦一个变量被指定为某个类型后就不能被当成其他类型用.除非做转换 在C++中我们经常看到int ,long之类的数值类型之间貌似可以互相通用.实际上是编译器按照实际情况给你隐式的做了下转换.而如果你把指针类型赋值给整数类型的话不符合通常的习惯,所以编译器就不给转了,直接报错. 2.型语言可以简单的理解成没有划分成int,float,char这多么类别.根本没类型的概念.以前我们数学中用变量x,y一样,它就相当于一个代表符号,占位符一样,可以表示任何类型.像javascrip中我们在任何变量前简单的加个var就行.比如var pos = 123;      pos = \"I change\"; 有些脚本语言干脆就不需要用var这样的东东来指定,直接 x = 3.14; y = \"i am god\"; 随便整个标识符放等号左边就是变量了.这样做基于的原理是所有数据在内存中无非都是表示成0101,我想怎么去解释这些01就怎么翻译,才不用你编译器来限制我啊.不过实际上要完全没类型的概念也不行,比如a = 1 + \"3\";怎么去辨别3是当成数字还是字符串.所以弱类型语言背后的解释器肯定会去做些类别判断,做些转换的.只是我们用起来看不到而已了.   弱类型语言使用起来非常灵活,方便.但如果代码一多肯定容易出错.而强类型虽然没那和灵活,但类型安全了嘛.不容易出错.而且编译器也会做类型检查,在编译期间发现一些类型使用不当的地方就给你报错. 弱类型语言由于根本没区分那么多类型.所以自然不存在啥类型转换.强类型语言为了不完全丢掉弱类型语言的灵活性,也允许不同类型之间做些转换.有时会隐式的转换.但最好还是尽量强制的去转换好点.   隐式转换 在隐式类型转换中,C++的判断条件松一点,几乎所有的数值类型之间都可以给你隐式转换了.比如int ,float , char之间都可以互相转,不会去检查啥值溢出或精度损失.而C#隐式转换条件严格很多.只有当没有值溢出且没有精度损失时才给转,不然报错. 比如 double dd =  12.12;         int num = dd; //把dd隐式转换成int类型 这在c++中可以正常转换.但在C#中会报错的.C#中必须要自己去显式转换才行.   强制类型转换(显式转换) 强制类型转换和显式类型转换是一会事,文字游戏,说法不一样而已. 旧式的强制类型转换 C语言中的类型转换方式很简单.例如所float转换成int就是这样 double dd= 12.12; int num = (int) dd; //或者int num = int(dd); 反正就在某个变量前加个类型名,然后用括号括下就可以了. C++中继续兼容了C的用法.但C#只沿用了上面两种用法的前一种,就是int num = (int) dd;但int num = int(dd)这种用法没有再沿用,如果你这样用了编译器会报错的. 旧式用法虽然简单方便,但也有些缺点,比如如果是一连串的表达式中,有很多个括号,这样就不容易看出是类型转换了,可视性较差.而且没有错误处理机制.于是C++和C#都弄出了新的转换方法.   新式强制类型转换方式 C++中有static_cast , dynamic_cast, const_cast, 和reinterpret_cast四种转换方式. 你可能初次瞧到这么多关键字,而且长得这长丑一个,肯定看得非常不顺眼,会觉得还是C语言中加个括号简单方便美观多了. C++这四种转换方式有一个说法(当然真实性我还不确定)是其实是故意弄的样子这么丑而且是4个这么多,目的就是为了让你用的不方便,最后都不想去用.因为强类型语言之所以整出那么多类型出来就是为了让你老实的按规矩用,别闲着没事转来转去.除非特殊情况非用不可才去转换. 1.const_cast 这个转换方式的功能只有一个,就是把const类型转换成非const类型.这种转换只能用这一种方法,其他三种方法用来干事就会出错. 你可能糊涂了,我们定义const的目的就是为了不让修饰那变量,怎么又要转成非const的了.大部分时候我们自然不会闲得蛋痛去做这样的转换,只有一些特殊情况会用到.比如你有这样的指针const char* pc = \"arwen\"; 但是有个函数非要你转个char* 参数进去.比如Fun(char* pc),于是没辙啊,只能把转成非const.于是就这样转 Fun( const_cast<char*> (pc) ); 当然了实际上你要用老式的方法也一样达到目的Fun (  (char*) pc ); 2.reinterpret_cast 它一般用来转换不同类型的指针转换,或者在指针和数值之间转换.例如 int num = 123; int* pNum = &num; char* pChar = \"weiwen\"; pNum = reinterpret_cast<int*>( pChar);  //把char指针转换成int*. int no = reinterpret_cast<int> (pChar);   //把指针转换成整数数字 char* pc = reinterpret_cast<char*> (no);  //把数字转换成char*指针 当然上面的所有转换也可以用老方法 比如(int*) pChar, (int)pChar这样,简单的用个括号就行. 完全等价的. 3.dynamic_cast 一般用于继承间类型的转换.假如类Son 继承自Father; Fun(Father* fa) {    Son* so = dynamic_cast<Son*>( fa ); } 当然如果Father和Son没有继承关系的话,转换的结果就是so得到一个null指针. 同样可以用老方法Son* so = (Son*) fa;但这样如果转不了会报错. 4.static_cast 这种用法是最简单也最容易理解的,因为隐式转换时实际上都调用的它.所以一般认为合理的转换就用它,比如各种数值之间转换.而不合理的转换比如要把char* 类型转换成int*就会出错.同样也可以用老式方法替代了 C#强制类型转换 C#中有个关键字as,如果转换不成功就返回null;这主要用于自定义类型,各种对象之间的转换 比如 Son so = fa as Son;   另外内置类型的转换一般用函数Convert 比如有float类型ff.转成int型 int num = Convert.ToInt32(ff); 如果是把string类型转换成数值类型可用函数Parse 比如int num = int.Parse(\"123\");","title":"C++与C#对比:强制类型转换"},{"content":"1问题的提出 函数是 C语言中的重要概念。利用好函数能够充分利用系统库的功能写出模块独立、易于维护和修改的程序。函数并不是 C 语言独有的概念，其他语言中的方法、过程等本质上都是函数。可见函数在教学中的重要意义。在教学中一般采用画简单的堆栈图的方式描述函数调用，但由于学生对堆栈没有直观认识，难以深入理解，因此教学效果往往并不理想，从而限制了对模块化程序设计思想的理解和应用。 2解决方法 在《微机原理》 课程介绍了堆栈、汇编语言等必要的相关知识之后，通过在高级语言开发环境下反汇编C 语言程序代码，使得学生通过分析汇编代码来理解函数调用中的堆栈变化，可以在实践中理解高级语言和低级语言的底层映射关系，理解函数调用的实质。本文通过在 Visual C++6.0 下反汇编一个 32 位 C语言程序的部分代码来解析解释函数调用的具体过程。 3函数调用过程 函数调用过程主要由参数传递、地址跳转、局部变量分配和赋初值、执行函数体，结果返回等几个步骤组成[1]。 3.1参数传递及函数跳转 参数由实参传递给形参。在底层实现上，即是实参按照函数调用规定压入堆栈。参数传递完成后就通过CALL指令由当前程序跳转到子程序处。 3.2局部变量分配并赋值 函 数的“{”被认为是分配局部变量空间的时机。在汇编层面局部变量分配体现为堆栈中以 EBP 寄存器为基址向低地址端分配的一个连续区域，通过 EBP 寄存器的相对寻址方式来寻址函数内的局部变量。由于堆栈增长的方向是高地址端到低地址端，因此函数中先定义的局部变量地址较大，后定义的变量地址逐渐变小，相邻定义的变量其地址一定相邻[2]。由于全局数据和局部数据定义在不用的数据区而并不与局部变量相邻，根据程序局部性原理，相邻的数据会被缓存，因此对相同的运算，局部变量作为操作数的运算效率就可能高于有全局变量参与的运算。同时，局部变量分配和回收只需要移动堆栈指针ESP，因此效率最高。 3.3寻址函数的参数 参数存放在以 EBP 为基址的高地址端。对参数的访问同样是通过EBP 寄存器相对寻址操作来实现。 3.4执行函数体内的语句 函数内和具体功能相关的语句被转化成一系列汇编语句。 3.5返回值 return 语句将返回值返回到主调函数。在底层，参数是通过 EAX 寄存器或 EDX 寄存器传递给主调函数。 3.6返回主调函数 函数的“}”被解释为函数体已经执行完。遇到“}”时，会将堆栈中的局部变量、程序中压入堆栈的寄存器的值全部弹出，将之前 CALL指令执行时压入堆栈的函数返回地址弹到指令指针寄存器 EIP，从而返回到主调函数。 3.7堆栈平衡 堆栈平衡指的是将函数调用前压入堆栈的参数弹出堆栈，使堆栈恢复到其调用前的状态[3]。由于函数调用完成后，参数就是无用的数据了，因此需要将其移出堆栈。 在 C语言中不需要进行堆栈平衡。而在汇编层面上却根据调用约定来确定由主调函数或是被调函数完成堆栈平衡。 C语言函数调用堆栈常见形式如图 1 所示[4]： 参数由主调函数压入堆栈，CALL 指令将函数返回地址入栈。进入子函数后，需要保存 EBP 原值、分配局部变量空间、保存寄存器初始值。函数内通过“EBP-位移量”方式访问局部变量，通过“EBP+位移量”方式访问参数[5]。 每发生一次函数调用，就会在堆栈中建立一个栈帧，栈帧在函数调用后释放。但是系统的堆栈资源有限，因此如果函数调用（如递归调用）层数过多，则可能发生堆栈溢出错误。 4反汇编代码分析 以下将函数 function 的调用相关代码在VisualC++6.0 Debug模式反汇编，通过对汇编代码的分析揭示函数调用的关键点和细节。完整的 C语言程序代码如图 2 所示： Function(i，&j)语句的反汇编代码如图 3 所示： 先 找到主函数中的局部变量 i，j（其在堆栈中位置为 EBP- 8和 EBP- 4），将其压入堆栈。Visual C/C++的编译器对 C 语言程序的默认函数约定为 _cdecl[6]。此参数入栈约定为自右向左，并且对函数名前加“_”修饰符。先将 j 的地址压入堆栈，后将 i 的值压入堆 栈。通过 call 指令调用函数。从 Call 指令可见 fuction函数编译后加了“_”修饰符。Call 指令执行时自动将函数的返回地址入栈，之后转到 function 定义处开始执行此函数。 对funciton函数的“{”的反汇编结果如图 4 所示： 在函数内，遇到“{”时分配局部空间，并用值“0xCCH”进行初始化。未在定义时初始化的局部变量其初值就与“0xCCH”相关。因此 int 类型变量由于占四个字节，其初值为 - 858993460（0xCCCCC-CCCH）；两个连续的 0xCCH 对应汉字“烫”字，因此当 以字符形式显示函数内未初始化的变量时会显示为“烫烫…”；指针类型变量就指向了地址为 0xCCCC-CCH 的内存。由此在调试模式下能很容易发现未初始化的变量。 堆栈基本的存储单位为四字节，对于小于四字节的数据按四字节对齐方式分配空间。因此 char 类型变量 ch 虽然数据本身需要两个字节，也分配了四个字节空间。array 字节数组分配空间时每个字符占一个字节，不够四个字符时按四字节对齐存放。因此局部变量 空间总数为 40H+4+4×2+4=50H。局部变量 ch 的地址为 EBP- 4，a、b 的地址分别为 EBP- 8 ，EBP- 0CH,array数组的地址为 EBP- 10h。函数左括号右括号间的所有的语句反汇编结果如图 5 所示： 若变量有初值，则反汇编就会为其生成一条 Mov指令为其赋值。对于没有初值的变量其每个字节都为0xCCH。对于字符数组，情况稍微复杂一些。字符串常量“abc”被存放在全局数据区中。当需要引用其值对数组进行初始化时，实际是将全局数据拷贝到堆栈中的 局部数组 array里。由于寄存器是 32 位，每次最多只能赋值 4 个字符，因此对数组赋初值的语句反汇编后可能产生一至多条汇编语句。对数组内容的访通过[ “EBP+ 数组首地址 + 偏移量]的寄存器间址来完成，因此局部数组初始化费时但访问时的效率高。 在函数内访问局部变量和参数通过 [EBP + 位移量 /- 位移量]来完成。函数返回值被放到 EAX 寄存器中供主调函数使用。 可见，在汇编层面上，函数内部并不存储局部变量，局部变量只有当函数调用发生时才会在栈上为函数分配空间。因此当函数调用后返回局部变量的值是错误的。 遇到函数“}”时的操作如图 6 所示： 将寄存器 EDI、ESI、EBX 恢复原值；将 ESP 调回到 EBP 处；将 EBP原值弹出。此时 ESP 指向函数返回地址。执行出栈指令，将函数的返回地址弹入 EIP 寄存器返回到主调函数。此时堆栈中只残留有调用函数时压入的参数还没有清理。 主调函数中的堆栈平衡语句如图 7 所示： 根据 _cdecl 约定，需要由主调函数完成堆栈平衡。主调函数根据压入堆栈的参数的数目 2 和参数大小，利用指令 add ESP，8 将参数全部弹出。此时堆栈就恢复到其调用前的状态。一个完整的函数调用过程完成。  ","title":"利用反汇编手段解析C语言函数"},{"content":"折半插入排序（binary insertion sort）又称二分法插入分序，是对直接插入排序算法的一种改进，由于排序算法过程中，就是不断的依次将元素插入前面已排好序的序列中。由于前半部分为已排好序的数列，这样我们不用按顺序依次寻找插入点，可以采用折半查找的方法来加快寻找插入点的速度。  折半插入排序的基本思想是：设在数据表中有一个元素序列a[0],a[1],……,a[n-1]。其中，a[0],a[1],……,a[i-1]已经排好序。在插入a[1]时，利用折半查找法寻找a[i]的插入位置。 折半搜索比顺序搜索快，所以折半插入排序就平均性能来说是比直接插入排序来的快。它所需要的排序码比较次数与待排序元素的初始位置排列无关，仅依赖元素个数。在插入第 i 个元素时候，需要进过 (log i )+ 1 次排序码比较，才能确定它应该插入的位置。 当 n 较大的时候，总排序码的比较次数比直接插入排序（ 平均 O( n ^ 2)）的要好很多，但比直接插入排序( 最好 O ( n ))最好的情况要来的差。 折半插入排序时间复杂度为 O（ n log n）。 所以在待排序序列接近有序的时候，直接插入排序的排序码的比较次数要比折半排序来的少。 但折半插入排序的元素移动次数是与直接插入排序一样的，仅依赖于元素的初始排列。 另外， 折半插入排序时一种稳定的排序算法（在排序前后相同元素的相对位置没有发生改变）。 代码示例： #include<iostream>using namespace std;void BinaryInsertSort(int *a,int left,int right){\tint tmp ;\tint i,low,high,middle,k;\tfor( i =left+1 ; i<=right ; i++){\t\ttmp = a[i];\t\tlow = left;\t\thigh = i -1;\t\twhile( low <= high ){\t\t\tmiddle = (low + high )/2;\t\t\tif(tmp < a[middle])\t\t\t\thigh = middle -1;\t\t\telse\t\t\t\tlow= middle + 1;\t\t}\t\tfor( k = i-1 ; k >= low ; k--)\t\t\ta[k+1] = a[k];\t\ta[low] = tmp;\t}}void main(){\tint a[]={43,24,54,2,345,3,12,6};\tBinaryInsertSort(a,0,7);\tfor(int i=0;i<8 ;i++)\t\tcout<<a[i]<<\" \";\tcout<<endl;}","title":"[置顶] 折半插入排序"},{"content":"1. 永远不要复制代码 不惜任何代价避免重复的代码。如果一个常用的代码片段出现在了程序中的几个不同地方，重构它，把它放到一个自己的函数里。重复的代码会导致你的同事在读你的代码时产生困惑。而重复的代码如果在一个地方修改，在另外一个地方忘记修改，就会产生到处是bug，它还会使你的代码体积变得臃肿。现代的编程语言提供了很好的方法来解决这些问题，例如，下面这个问题在以前很难解决，而如今使用lambdas却很好实现： [java] view plaincopyprint? /// <summary>  /// 一些函数含有部分重复代码  /// <\/summary>  void OriginalA()  {      DoThingsA();        // unique code        DoThingsB();  }    /// <summary>  /// 另外一个含有部分重复代码的函数  /// <\/summary>  void OriginalB()  {      DoThingsA();        // 没有重复的代码        DoThingsB();  }  /// <summary>/// 一些函数含有部分重复代码/// <\/summary>void OriginalA(){\tDoThingsA();\t// unique code\tDoThingsB();}/// <summary>/// 另外一个含有部分重复代码的函数/// <\/summary>void OriginalB(){\tDoThingsA();\t// 没有重复的代码\tDoThingsB();} 现在我们重构含有部分相同代码的函数，用delegate模式重写它们： [java] view plaincopyprint? /// <summary>  /// Encapsulate shared functionality  /// <\/summary>  /// <param name=\"action\">User defined action<\/param>  void UniqueWrapper(Action action)  {      DoThingsA();        action();        DoThingsB();  }    /// <summary>  /// New implmentation of A  /// <\/summary>  void NewA()  {      UniqueWrapper(() =>      {          // unique code      });  }    /// <summary>  /// New implementation of B  /// <\/summary>  void NewB()  {      UniqueWrapper(() =>      {          // unique code      });  }  /// <summary>/// Encapsulate shared functionality/// <\/summary>/// <param name=\"action\">User defined action<\/param>void UniqueWrapper(Action action){\tDoThingsA();\taction();\tDoThingsB();}/// <summary>/// New implmentation of A/// <\/summary>void NewA(){\tUniqueWrapper(() =>\t{\t\t// unique code\t});}/// <summary>/// New implementation of B/// <\/summary>void NewB(){\tUniqueWrapper(() =>\t{\t\t// unique code\t});} 2. 留意你开始分心的时候 当你发现自己在浏览facebook或微博、而不是在解决问题，这通常是一种你需要短暂休息的信号。离开办公桌，去喝一杯咖啡，或去跟同事聊5分钟。尽管这样做看起来有点反直觉，但长久去看，它会提高你的工作效率。 3. 不要匆忙赶任务而放弃原则 当带着压力去解决一个问题或修改一个bug，你很容易失去自制，发现自己匆匆忙忙，甚至完全忘了一直坚持的重要的测试过程。这通常会导致更多的问题，会让你在老板或同事眼里显得很不专业。 4. 测试你完成的代码 你知道你的代码能做什么，而且试了一下，它确实好用，但你实际上需要充分的验证它。分析所有可能的边界情况，测试在所有可能的条件下它都能如期的工作。如果有参数，传递一些预期范围外的值。传递一个null值。如果可能，让同事看看你的代码，问他们能否弄坏它。单元测试是到达这种目的的常规方法。 5. 代码审查 提交你的代码之前，找个同事一起坐下来，向他解释你做了哪些修改。通常，这样做的过程中你就能发现代码中的错误，而不需要同事说一句话。这比自己审查自己的代码要有效的多得多。 6. 让代码更少 如果你发现写了大量的代码来解决一个简单的问题，你很可能做错了。下面的boolean用法是一个很好的例子： [java] view plaincopyprint? if (numMines > 0)  {     enabled=true;  }  else  {     enabled=false;  }  if (numMines > 0){   enabled=true;}else{   enabled=false;} 这时你应该写成这样： [java] view plaincopyprint? enabled = numMines > 0;  enabled = numMines > 0; 代码越少越好。这会使bug更少，重构可能性更小，出错的几率更小。要适度。可读性同等重要，你可不能这样做而使代码丧失可读性。 7. 为优雅的代码而努力 优雅的代码非常的易读，只用手边很少的代码、让机器做很少的运算就能解决问题。在各种环境中都做到代码优雅是很难的，但经过一段时间的编程，你会对优雅的代码是个什么样子有个初步的感觉。优雅的代码不会通过重构来获得。当你看到优雅的代码是会很高兴。你会为它自豪。例如，下面就是一个我认为是优雅的方式来计算多边形面积的方法： [java] view plaincopyprint? static public double GetConvexPolygonArea(Vector2[] vertices)  {      double area = 0;      for (int i = 0; i < vertices.Length; i++)      {          Vector2 P0 = vertices[i];          Vector2 P1 = vertices[(i + 1) % vertices.Length];            area += P0.Wedge(P1);      }        return area / 2;  }  static public double GetConvexPolygonArea(Vector2[] vertices){\tdouble area = 0;\tfor (int i = 0; i < vertices.Length; i++)\t{\t\tVector2 P0 = vertices[i];\t\tVector2 P1 = vertices[(i + 1) % vertices.Length];\t\tarea += P0.Wedge(P1);\t}\treturn area / 2;} 8. 编写不言自明的代码 勿庸置疑，注释是编程中很重要的一部分，但能够不言自明的代码跟胜一筹，因为它能让你在看代码时就能理解它。函数名变量名要慎重选择，好的变量/方法名字放到语言语义环境中时，不懂编程的人都能看懂。例如： [java] view plaincopyprint? void DamagePlayer(Player player, int damageAmount)  {      if (!player.m_IsInvincible && !player.m_IsDead)      {          player.InflictDamage( damageAmount );      }  }  void DamagePlayer(Player player, int damageAmount){\tif (!player.m_IsInvincible && !player.m_IsDead)\t{\t\tplayer.InflictDamage( damageAmount );\t}} 能自我说明的代码不能代替注释。注释是用来解释“为什么”的，而自我说明的代码是来描述“是什么”的。 9. 不要使用纯数字 直接把数字嵌入代码中是一种恶习，因为无法说明它们是代表什么的。当有重复时更糟糕——相同的数字在代码的多个地方出现。如果只修改了一个，而忘记了其它的。这就导致bug。一定要用一个命名常量来代表你要表达的数字，即使它在代码里只出现一次。 10. 不要做手工劳动 当做一系列动作时，人类总是喜欢犯错误。如果你在做部署工作，并且不是一步能完成的，那你就是在做错事。尽量的让工作能自动化的完成，减少人为错误。当做工作量很大的任务时，这尤其重要。 11. 避免过早优化 当你要去优化一个已经好用的功能代码时，你很有可能会改坏它。优化只能发生在有性能分析报告指示需要优化的时候，通常是在一个项目开发的最后阶段。性能分析之前的优化活动纯属浪费时间，并且会导致bug出现。 好吧，我说是10个，但你却得到了额外赠送的一个！ 这些就是我要说的，我希望它们能帮助你改进编程开发过程。   推荐一个游戏开发者的论坛http://jiushun8.com 游戏开发者之家","title":"10 步让你成为更优秀的程序员"},{"content":"#include <iostream>#include <cstdio>#include <cstring>#include <cstdlib>#define maxn 1000#define T charusing namespace std;typedef struct btnode {    T data;    struct btnode *lchild;    struct btnode *rchild;}btnode;btnode *root = NULL;btnode *temp2 = NULL;int leaf_number = 0;btnode* newnode(T x) {    btnode* p = (btnode* )malloc(sizeof(btnode));    p->data = x;    p->lchild = NULL;    p->rchild = NULL;    return p;}bool insert1(T x) {  //插入节点    btnode *r = NULL, *q = NULL, *p = root;    T k = x;    while(p) {        q = p;        if(k < p->data) {            p = p->lchild;        }        else if(k > p->data) {            p = p->rchild;        }        else {            cout << \"duplicate!\" << endl;            return false;        }    }    r = newnode(x);    if(root) {        if(k < q->data) {            q->lchild = r;        }        else {            q->rchild = r;        }    }    else{        root = r;    }    return true;}void exchange(btnode *bt) {   //交换左右子树。    if(bt) {        exchange(bt->lchild);        exchange(bt->rchild);    }    if(bt == NULL) {        return ;    }    temp2 = bt->lchild;    bt->lchild = bt->rchild;    bt->rchild = temp2;}void midorder(btnode *bt) {    if(bt) {        midorder(bt->lchild);        cout << bt->data << ' ';        midorder(bt->rchild);    }    if(bt == NULL) {        return ;    }}int total(btnode *bt) {  //求节点总数。感觉写的太缀余。    int rnum = 0, lnum = 0;    int num = 0;    if(!bt) {        return 0;    }    if(bt->lchild == NULL && bt->rchild == NULL) {        leaf_number++;        return 1;    }    if(bt->lchild == NULL && bt->rchild != NULL) {       return rnum = total(bt->rchild) + 1;    }    if(bt->lchild != NULL && bt->rchild == NULL) {        return lnum = total(bt->lchild) + 1;    }    if(bt->lchild != NULL && bt->rchild != NULL) {       lnum = total(bt->lchild);       rnum = total(bt->rchild);      return num = lnum + rnum + 1;    }    return 0;//suseless}int height(btnode *t) {  //求树的高度。    int lh = 0, rh = 0;    if(!t) {        return 0;    }    else{        lh = height(t->lchild);        rh = height(t->rchild);        if(lh>rh){            return lh+1;        }        else{            return rh+1;        }    }}void preorder(btnode *bt) {    if(bt == NULL) {        return ;    }    if(bt) {        cout << bt->data << ' ';        preorder(bt->lchild);        preorder(bt->rchild);    }}int main(){    char str[maxn];    int len = 0;    gets(str);    len = strlen(str);    for(int i = 0; i < len; i++) {        insert1(str[i]);    }    btnode *temp = root;    cout << \"preorder:  \";    preorder(temp);    cout << endl;    cout << \"midorder:  \";    midorder(temp);    cout << endl;    exchange(temp);    cout << \"preorder:  \";    preorder(temp);  cout << endl;    cout << \"midorder:  \";    midorder(temp); cout << endl;    int Total = total(temp);    printf(\"The amount of the node: \");    cout << Total << endl;    printf(\"The height of the tree: \");    int heigh = height(temp);    cout << heigh << endl;    printf(\"The leaf of the tree: \");    cout << leaf_number << endl;    return 0;}/******************************************************************最近忙着备考，几乎很少写程序，完美结束考试，全心学习编程。程序仅仅说明道理，如果想完善稍加改动即可！测试数据：5382469170********************************************************************/","title":"二叉搜索树"},{"content":"这个系列的贴子属于日记类型的帖子，现在看可能会比较水，算是我个人的奋斗记录吧，希望将来可以对后来（学习）人有所帮助 个人技术背景：做JAVA开发五年，懂C#基本语法（停留在2.0）工作经验3.5年   ---------------------------------------------------- 2012-12-27 今天先实现了音乐的添加，游戏本身可以播放背景音乐，及打斗声音 其他大部分也基本调通，需要继续努力的是详细了解控件是如何显示与隐藏。或许这几天就彻底调通啦！ 当然了，需要尝试做一款适合触屏的游戏，而不应该有键盘的参与，慢慢来嘛！我想，可以先有键盘（基本移动），然后升级鼠标点击，接着升级自动寻路功能，我想，这应该就是这几天的开发顺序吧   现在发现了个问题，越到晚上，战斗力越强（开发能力），这算是病态吗？ 好吧言归正传，刚刚看了下，刚发布短短7分钟点击率就超过60了，看来大家睡得都很晚啊，感谢大家支持的同时，需要提醒各位朋友的是注意休息啊，我就先睡了，大家也早点休息啊 :）   明日目标： 1.调通并试运行键盘版本，改错，应用语言包实例 2.研究了解触屏的特点 3.掌握触屏的上下左右，实现的移动功能（键盘 + 鼠标 + 触屏）       转载请注明作者：二厶可可肉.cyrusLiu.刘.步云.龙飞...小雪  （好吧有点长） 　  　　　　　　出处：http://blog.csdn.net/cyrusliu/article/details/8444031         今日分享的源码： 简单声音的使用：播放，暂停，停止     先上XAML的代码 \t<StackPanel Grid.Row=\"1\">            <Button Click=\"startMusic_click\" Content=\"开始\" />            <Button Click=\"PauseMusic_click\" Content=\"暂停\" />            <Button Click=\"StopMusic_click\" Content=\"停止\" />            <MediaElement x:Name=\"media\" Source=\"music/小雪，我喜欢你.mp3\" />        <\/StackPanel>   在上面的代码中，有三个按钮，分别是  开始 暂停  停止，对应得有三个Click事件(单击事件)，代码非常简单，功能如下         private void startMusic_click(object sender, RoutedEventArgs e)        {            media.Play();//播放声音        }        private void PauseMusic_click(object sender, RoutedEventArgs e)        {            media.Pause();//暂停        }        private void StopMusic_click(object sender, RoutedEventArgs e)        {            media.Stop();//停止        }   如果先点击播放，再点暂停，那么再点开始的时候是继续播放。 如果点击停止再点击播放，则是从头播放。   其他常用属性 AutoPlay：指定 MediaElement 是否应自动开始播放。默认值为 True。 IsMuted：指定 MediaElement 是否设置为静音。值 True 表示对 MediaElement 设置静音。默认值为 False。 Volume：将 MediaElement 对象的音频音量指定为 0 到 1 之间的值，其中，1 为最大音量。默认值为 0.5。            对技术的狂热是我进步的阶梯，对知识的渴望是我学习的源动力。       鸣谢   师父         二厶可可肉 2012年12月27日         您的支持是我创作的最大动力  ","title":"可可肉的奋斗（第四天）2012-12-27----------音乐功能的使用"},{"content":"概述 单例模式(Singleton Pattern)，创建对象模式之一，单例模式确保一个类只能创建一个实例。单例模式适用于一个系统要求一个类只有一个实例时，比如Swing窗体，只需要一个实例。如果一个类可以同时存在多个实例，那就不需要使用单例模式。单例模式很容易被滥用。下面看一下代理模式的几种实现方式。 实现 实现单例模式要两点，一是不能让外界创建对象，所以需要构造器私有化；二是需要提供得到单例对象的方法。 饿汉模式 /**  * 单例之饿汉模式  */ public class Singleton {    private static Singleton instance =new Singleton();    private Singleton() {}    public static Singleton getInstance() {       return instance;    } } 该模式是类加载的的时候创建好一个静态对象，不管使用不使用，对象已经创建好了，并且是线程安全的。 懒汉模式 /**  * 单例之懒汉  */ public class Singleton {    private static Singleton instance;    private Singleton() {}    public static synchronized Singleton getInstance() {       if(instance ==null) {         instance = new Singleton();       }       return instance;    } } 该模式很懒，不用的时候不会创建对象，只有用的时候才会创建，但在多线程的情况下，需要让方法互斥，才能保证只会创建一个实例，如果不加synchronized，当多个线程同时获取实例时，就有可能创建多个实例。(可以测试一下) 双重锁定 /**  * 双重锁定  */ public class Singleton {    private static Singleton instance;    private Singleton() {}    public static Singleton getInstance() {       if(instance ==null) {         synchronized (Singleton.class) {            if (instance ==null) {               instance =new Singleton();            }         }       }       return instance;    } } 第一个instance == null是判断当前是否为空，如果为空才对创建实例的代码快上互斥锁，第二个instance == null是两个线程互斥了，第一个线程创建完对象，第二个线程直接返回。这种方式是在懒汉模式上的一个进化，避免了无用的互斥开销。这个是在《大话设计模式》上看到的，大话是用的C#，百度一下，这种方式不适用于java，基于java内存模型有时会失效，我没想明白什么时候会失效，明天再研究下。 总结 单例模式由于构造器是私有化的，所以单例的类不能被继承。优缺点分析，饿汉模式，类加载的时候就会创建单例对象，保证了多线程情况下的单例，同时有可能这个单例对象永远也不会被用到；懒汉模式，只有用到单例的时候才会创建对象，不用就不会创建，多线程情况下互斥开销较大。使用哪种情况全屏自己爱好，企业级应用应该不会在这点内存上耗费时间。","title":"单例模式"},{"content":"过程        这次C#语言的学习，是自己目前学过的编程语言中，在学习过程中思路比较清晰的一门语言，下面分享自己的学习过程。        自己在刚开始学习C#语言的时候，没有上来就学，而是，首先制定一个计划，把C#语言的学习当成一个工程来完成，制定每一个阶段的任务和时间。自己制定的计划大致如下图：            制定了学习的每个阶段后，自己就开始学习。对于上图的计划，自己在实施中有时候也很痛苦，主要因为自己每个阶段的验收标准没有制定好，没有一个好的测量该阶段完成的方法。这个问题的存在，使自己有时候有种时间到了，我这个阶段的学习完成了的感觉，或者说，时间快到了，所以，我的进度应该快些，但是，快的没有依据了，快的学不了东西了，就单纯的剩下了赶进度，以至于做了很多的无用功，使自己在时间上和精力上存在着很大的浪费，这个问题是一个很大的问题，自己目前的解决方法是：制定好每个阶段的验收标准。        这一块要说的最后一句就是：计划是用来打破的，不是用来一成不变的执行的。   收获        技术                             之前的有一篇关于技术方面的总结，大家可以看一下： .net的学习总结。                 在学习C#的过程中自己对于面向对象中的思想有了进一步的了解，如下图：                 对于C#中基本知识自己也学习了一些，如下图：                   对于C#语言本身特点的学习现在还有很多不明白的地方，对于这些问题，现打算是在后续的阶段慢慢学习，对此的总结如下图：                     学习方法                学习新的事物时，首先要把这个事物作为一个整体进行学习；然后，再去学习里面的东西，对于里面的东西，我们要先进行分门别类的模块化；然后，再一块一块的击破（没有完全搞懂也没有关系）。   总结        C#的学习可以说告一段落，但是，还没有结束。自己在大面上了解C#，但是，自己在.net framework（可以先忽略语言运行时）上欠缺的还很多，或者说还没有真正的开始！        一句话，两个字：加油!  ","title":"C#的学习总结"},{"content":"itoa()函数的原型为： char *itoa( int value, char *string,int radix); itoa()函数有3个参数：第一个参数是要转换的数字，第二个参数是要写入转换结果的目标字符串，第三个参数是转换数字时所用的基数。在例中，转换基数为10。10：十进制；2：二进制... itoa并不是一个标准的C函数，它是Windows特有的，如果要写跨平台的程序，请用sprintf。 是Windows平台下扩展的，标准库中有sprintf，功能比这个更强，用法跟printf类似： char str[255]; sprintf(str, \"%x\", 100); //将100转为16进制表示的字符串。 下面是一个十进制转八进制的方法： [cpp] view plaincopyprint? #include \"stdio.h\"   #include \"stdlib.h\"     int main(void)  {      int num = 10;      char str[100];      itoa(num, str, 8);      //将整数10转换为八进制保存在str字符数组中       printf(\"%s\\n\", str);      system(\"pause\");      return 0;  }  #include \"stdio.h\" #include \"stdlib.h\" int main(void) {  int num = 10;  char str[100];  itoa(num, str, 8);      //将整数10转换为八进制保存在str字符数组中  printf(\"%s\\n\", str);  system(\"pause\");  return 0; }下面是一个十进制转二进制的方法： [cpp] view plaincopyprint? #include \"stdio.h\"   #include \"stdlib.h\"     int main(void)  {      int num = 15;      char str[100];      int n = atoi(itoa(num, str, 2));   //先把num转换为二进制的字符串，再把该字符串转换为整数       printf(\"%d\\n\",n);      system(\"pause\");      return 0;  }  #include \"stdio.h\" #include \"stdlib.h\" int main(void) {  int num = 15;  char str[100];  int n = atoi(itoa(num, str, 2));   //先把num转换为二进制的字符串，再把该字符串转换为整数  printf(\"%d\\n\",n);  system(\"pause\");  return 0; }itoa()函数的扩展： char *_itoa( int value, char *string, int radix ); char *_i64toa( __int64 value, char *string, int radix ); char * _ui64toa( unsigned _int64 value, char *string, int radix ); wchar_t * _itow( int value, wchar_t *string, int radix ); wchar_t * _i64tow( __int64 value, wchar_t *string, int radix ); wchar_t * _ui64tow( unsigned __int64 value, wchar_t *string, int radix );  程序代码如下： [cpp] view plaincopyprint? #include \"stdio.h\"   #include \"stdlib.h\"     int main(void)  {      char buffer[20];      int i = 3445;      long l = -344115L;      unsigned long ul = 1234567890UL;        _itoa( i, buffer, 10 );      printf( \"String of integer %d (radix 10): %s\\n\", i, buffer );      _itoa( i, buffer, 16 );      printf( \"String of integer %d (radix 16): 0x%s\\n\", i, buffer );      _itoa( i, buffer, 2 );      printf( \"String of integer %d (radix 2): %s\\n\", i, buffer );        _ltoa( l, buffer, 16 );      printf( \"String of long int %ld (radix 16): 0x%s\\n\", l,buffer );        _ultoa( ul, buffer, 16 );      printf( \"String of unsigned long %lu (radix 16): 0x%s\\n\", ul,buffer );        system(\"pause\");      return 0;  } ","title":"atoi() 与 itoa()函数用法"},{"content":"今天在看到网易里的算法导论的公开课，听到老外讲分治法时提到了下算一个数的N次方的可以通过二分思想来实 现，于是便想自己写个代码来实现它。虽然很简单，还是想写在博客中。一是可以加深自己的印象，以后遇到这类问 题时可以马上想到用二分来解决；二是可以方便以后的复习，再次用到的时候可以直接来这找模板。 #include<iostream>using namespace std;int Pow(int x, int n){\tif (n == 1)\t\treturn x;\telse if (n > 1)\t{\t\tint s;\t\tint m = n / 2;\t\ts = Pow (x, m);\t\tif (n % 2 == 0)\t\t\treturn (s * s);\t\telse\t\t\treturn (s * s * x);\t}}int main(){\tint x, n;\twhile (cin >> x >> n)\t{\t\tcout << Pow(x, n) << endl;\t}\treturn 0;}","title":"求X的N次方的二分实现"},{"content":"虚基类 多态继承中，当派生类的部分或全部直接基类又是从另一个共同基类派生而来时这些直接基类中从上一级共同基类继承来的成员就拥有相同的名称。在派生类的对象中，同名数据成员在内存时期拥有多个拷贝，同一个成员函数会有多个映射，出现二义性，这个二义性为间接二义性。 解决的方法是：将共同基类设置为虚基类。 这时从不同的路径继承过来的同名数据成员在内存中就只有一个拷贝，同一个函数名也就只有一个映射。 虚基类的定义如下 Class派生类名： virtual继承方式 基类名 多继承情况下，虚基类关键字的作用范围和继承方式关键字相同，只对紧跟其后的基类起作用。   如下给一个实例     使用虚基类定义  Class Car :virtual public Automobile //小客车类 Class Wagon : virtual public Automobile //小货车类 这时候，从Automobile中不同途径继承来的power，show（） 在SationWago中就只有一个拷贝了 而在C#中，是不允许这样的多继承的，但是允许多接口的实现   ++++++++++++++++++++++++++++++++++++++++++ 虚函数  是C++语言引入的一个很重要的特性，它提供了“动态绑定”机制，正是这一机制使得继承的语义变得相对明晰。对继承体系的使用者而言，此继承体系内部的多样性是“透明的”。它不必关心其继承细节，处理的就是一组对它而言整体行为一致的“对象 特点   基类抽象了通用的数据及操作，就数据而言，如果该数据成员在各派生类中都需要用到，那么就需要将其声明在基类中；就操作而言，如果该操作对各派生类都有意义，无论其语义是否会被修改或扩展，那么就需要将其声明在基类中。 定义方式 Virtual函数类型 函数(形参表） { 函数体； } 联编也可以在运行时进行，成为动态联编。使用虚函数是实现动态联编的基础。要实现动态联编，需要满足三个条件 1 应满足类型兼容规则 2在基类中定义虚函数，并在派生类中重新定义虚函数。 3 要由成员函数或通过指针，引用访问虚函数。   注意：虚函数不能是静态成员函数，也不能是友元函数，因为静态成员函数和友元函数不属于某一个对象   纯虚函数  （抽象类中定义）  是一个在基类中说明的虚函数， 它在该基类中没有定义具体实现，要求各派生类根据实际需要定义函数实现。纯虚函数的作用是为派生类提供一个一致的接口，实现多态的一种方式。 定义方法 Vitual  函数类型函数名(参数表)=0;   ========================= 以上是c++中实现多动态的一些方法。而在c#中是如何实现呢   c# (默认都是Object的派生类） 是用base关键字 ，来引用基类的构造函数的。 通过virtual关键字声明虚基类或（虚方法），也可定义抽象类和抽象方法，然后利用Override，派生类 来重写基类的方法。 开放扩展，关闭修改等原则 抽象类的特性 抽象类是不能实例化 抽象类可包含抽象方法和抽象访问器 不能由Sealed修饰符修改抽象类 抽象方法特性 抽象方法默认是隐士的虚方法 只允许在抽象类中使用抽象方法声明   多态   是利用重载和覆写的方式 详见下图 单击图片外链      ","title":"[置顶] c++与c#中概念的不同理解"},{"content":"由于项目收尾，最近忙着做一些方法的优化，整理了一些分享给大家。 当页面内有许多控件，我们在需要清空其值的时候，一个个清空未免太麻烦。于是写了这么一个方法，可以自定义清空控件的类型，灵活应对业务需求。         /// <summary>重置方法控件类型枚举<\/summary>        /// <remarks>求知域http://www.qqextra.com 2012-12-28<\/remarks>        public enum ReSetType        {            /// <summary>            /// TextBox            /// <\/summary>            TXT,            /// <summary>            /// DropDownList            /// <\/summary>            DDL,            /// <summary>            /// RadioButtonList            /// <\/summary>            RBL,            /// <summary>            /// 全部ReSetType类型            /// <\/summary>            ALL        }        /// <summary>重置控件的值<\/summary>        /// <remarks>求知域http://www.qqextra.com 2012-12-28<\/remarks>        /// <param name=\"control\">this<\/param>        /// <param name=\"rst\">ReSetType.ALL为清空ReSetType枚举中包含的所有控件类型<\/param>        public static void ReSet(Control control, params ReSetType[] rst)        {            bool blTxt = false;            bool blDdl = false;            bool blRbl = false;            foreach (ReSetType type in rst)            {                if (type == ReSetType.ALL)                {                    blTxt = true;                    blDdl = true;                    blRbl = true;                    break;                }                else                    if (type == ReSetType.TXT)                        blTxt = true;                    else if (type == ReSetType.DDL)                        blDdl = true;                    else if (type == ReSetType.RBL)                        blRbl = true;            }            foreach (Control c in control.Controls)            {                //文本框                if (c is TextBox && blTxt == true)                {                    ((TextBox)c).Text = \"\";                }                else                    //下拉列表                    if (c is DropDownList && blDdl == true)                    {                        DropDownList ddl = (DropDownList)c;                        if (ddl.Items.Count > 0)                        {                            ddl.SelectedIndex = 0;                        }                    }                    else                        //单选按钮列表                        if (c is RadioButtonList && blRbl == true)                        {                            ((RadioButtonList)c).SelectedIndex = -1;                        }                        else                            if (c.HasControls())                            {                                //递归                                ReSet(c, rst);                            }            }        }本文原创，转载请注明出处。访问求知域了解更多专业计算机技术。","title":"Asp.net_清空控件值的方法（可指定控件类型）"},{"content":"在yii框架中CHtml类库主要负责协助我们使用优雅的方法生成HTML代码，例如：下拉选择列表框，完整的代码如下： <select name=”provices”>    <option value=”1”>北京<\/option>    <option value=”2” selected=”selected”>上海<\/option>    <option value=”3”>天津<\/option>    <option value=”4”>武汉<\/option><\/select>以上的结构，如果不使用助手，我们可能会使用以下的方法实现： /** Controller: **/$provices = array(\t1 => '北京',\t2 => '上海',\t3 => '天津',\t4 => '武汉');$this->render( 'view', array( 'provices' => $provices, 'selected' => 2 ); /** View **/if ( isset($provices) && $provices ):    echo “<select name=\\”provices\\”>”;    foreach ( $provices as $val => $title ):\t if ( $val != $selected ) {            echo “<option value=\\””, $val, “\\”>”, $title, “<\/option>”;\t}\telse {\t     echo “<option value=\\””, $val, “\\” selected=\\”selected\\”>”, $title, “<\/option>”;\t}    endforeach;    echo “<\/select>”;endif; 如此的代码，不但臃肿而且容易写错，这样的代码还显得不够酷。 /** Controller **/$provices = array(\t1 => '北京',\t2 => '上海',\t3 => '天津',\t4 => '武汉');$this->render( 'view', array( 'provices' => $provices, 'selected' => 2 ); /** View **/echo CHtml::dropDownList( 'provices', $selected, $provices );怎么样？如此一来代码是不是清爽了不了？很酷吧？如果需要自定义id和class属性，还可以写成以下的形式： echo CHtml::dropDownList( 'provices', $selected, $provices, array( 'id' => 'provices', 'class' => 'g-left') ); 程序的完全说明如下： publicstatic string dropDownList(string$name, string $select, array $data, array $htmlOptions=array ( )) $name string 下拉列表的名称 $select string 被选中的值 $data array 用来生成列表选项的数据(值=>显示).你可以使用listData来生这个数据。请参考listOptions来了解这个数据如何生成列表选项。注意，这个方法会自动的将值和标签HTML编码。 $htmlOptions array 附加的HTML属性。除了正常的HTML属性外，一些特殊的属性也是可以的(请参阅clientChange和tag来了解更多详细信息。)此外，下面这些选项也被下拉列表所支持： encode:布尔值，指定是否对值进行编码。默认为true。 prompt:字符串，指定作为第一个列表项的提示文本，它的值是空的。注意，提示文本不会被HTML编码。 empty:字符串，指定空选项的文本，它的值是空的。‘empty’选项也可以是一个值-标签对的数组。每一对都将在一开始渲染为一个列表选项。注意，文本标签不会被HTML编码。 options:数组，每个option标签的指定附加属性。数组的键名必须是option的值，数组的键值是option标签的附加的属性。例如， array( 'value1'=>array('disabled'=>true,'label'=>'value 1'), 'value2'=>array('label'=>'value2'), ); {return} string 生成的下拉列表","title":"使用Yii框架CHtml助手生成城市下拉选择框"},{"content":"说明快速排序法（quick sort）是目前所公认最快的排序方法之一（视解题的对象而定），虽然  快速排序法在最差状况下可以达O(n2)，但是在多数的情况下，快速排序法的效率表现是相当不  错的。  快速排序法的基本精神是在数列中找出适当的轴心，然后将数列一分为二，分别对左边与右边  数列进行排序，而影响快速排序法效率的正是轴心的选择。  这边所介绍的第一个快速排序法版本，是在多数的教科书上所提及的版本，因为它最容易理解，  也最符合轴心分割与左右进行排序的概念，适合对初学者进行讲解。  解法这边所介绍的快速演算如下：将最左边的数设定为轴，并记录其值为s  廻圈处理：  令索引i 从数列左方往右方找，直到找到大于s 的数  令索引j 从数列左右方往左方找，直到找到小于s 的数  如果i >= j，则离开回圈  如果i < j，则交换索引i与j两处的值  将左侧的轴与j 进行交换  对轴左边进行递回  对轴右边进行递回  透过以下演算法，则轴左边的值都会小于s，轴右边的值都会大于s，如此再对轴左右两边进行  递回，就可以对完成排序的目的，例如下面的实例，*表示要交换的数，[]表示轴：  [41] 24 76* 11 45 64 21 69 19 36*  [41] 24 36 11 45* 64 21 69 19* 76  [41] 24 36 11 19 64* 21* 69 45 76  [41] 24 36 11 19 21 64 69 45 76  21 24 36 11 19 [41] 64 69 45 76  在上面的例子中，41左边的值都比它小，而右边的值都比它大，如此左右再进行递回至排序完  成。 随机排序 void Shuffle(int* &pData, int num, int seed) { \tsrand(seed); \tint nTemp; \tfor (int i = 0; i < num; i ++) \t{ \t\tint j = (double) rand() / (RAND_MAX + 1) * num; \t\tnTemp = pData[j]; \t\tpData[j] = pData[i]; \t\tpData[i] = nTemp; \t} } 快速排序 void QuickSort_1(int* &pData, int num) { \tint nBase = pData[0]; \tQuickSort_1_Recursion(pData, nBase, 0, num - 1); \t }  bool QuickSort_1_Recursion(int* &pData, int baseDat, int nStart, int nEnd) { \tbool bGetMax = false; \tbool bGetMin = false; \tint oldEnd = nEnd;  \twhile(nStart < nEnd) \t{ \t\tif (pData[nStart + 1] < baseDat) \t\t{ \t\t\tnStart ++; \t\t} \t\telse \t\t{ \t\t\tbGetMax = true; \t\t}  \t\tif (pData[nEnd - 1] > baseDat) \t\t{ \t\t\tnEnd --; \t\t} \t\telse \t\t{ \t\t\tbGetMin = true; \t\t}  \t\tif (bGetMax && bGetMin) \t\t{ \t\t\tint nTemp; \t\t\tnTemp = pData[nStart]; \t\t\tpData[nStart] = pData[nEnd]; \t\t\tpData[nEnd] = nTemp; \t\t\tbGetMax = false; \t\t\tbGetMin = false; \t\t} \t} \t// 左边序列 \tif (nStart < nEnd) \t{ \t\tQuickSort_1_Recursion(pData,  pData[nStart], nStart, nEnd); \t} \t// 右边序列 \tif (nEnd + 1 < oldEnd) \t{ \t\tQuickSort_1_Recursion(pData, pData[nEnd + 1], nEnd+1, oldEnd); \t} \t \treturn true; }","title":"没有优化的快速排序"},{"content":"算法设计例题：图的m着色（回溯） memory limit: 5000KB    time limit: 2000MS accept: 8    submit: 14 Description 给定无向连通图G和m种不同的颜色。用这些颜色为图G的各顶点着色，每个顶点着一种颜色。是否有一种着色法使G中每条边的2个顶点着不同颜色，求有多少种方法为图可m着色。 Input 输入的第一个为测试样例的个数T （ T < 120 ），接下来有T个测试样例。每个测试样例的第一行是顶点数n、边数M和可用颜色数m（ n <= 10，M < 100，m <= 7 ），接下来M行，每行两个整数u和v，表示顶点u和v之间有一条边相连。（ 1 <= u < v <= n ）。 Output 对应每个测试样例输出两行，第一行格式为\"Case #: W\"，其中'#'表示第几个测试样例（从1开始计），W为可m着色方案数。 Sample Input 1 5 8 5 1 2 1 3 1 4 2 3 2 4 2 5 3 4 4 5 Sample Output Case 1: 360 Author Eapink 解决方法： #include<iostream> using namespace std; #define N 100 int m,n,M,a[N][N],x[N],textNum; int static sum=0; bool ok(int k) { for(int j=1;j<=n;j++) if(a[k][j]&&(x[j]==x[k])) return false; return true; } void backtrack(int t) {   if(t>n)   {  sum++; // for(int i=1;i<=n;i++)  //cout<<x[i]<<\" \";  //cout<<endl;   }   else     for(int i=1;i<=m;i++) { x[t]=i;    if(ok(t)) backtrack(t+1);    x[t]=0; } } int main() {     int i,j,z=1; cin>>textNum;                 //输入测试个数 while(textNum>0) {         cin>>n;                    //输入顶点个数 for(i=1;i<=n;i++) for(j=1;j<=n;j++) a[i][j]=0;         cin>>M>>m;                 //输入边的个数、可用颜色数 for(int k=1;k<=M;k++)      //生成图的邻接矩阵 { cin>>i>>j; a[i][j]=1; a[j][i]=1; } /* for(i=1;i<=n;i++){ for(j=1;j<=n;j++) cout<<a[i][j]<<\" \"; cout<<endl;}*/ for(i=0;i<=n;i++) x[i]=0;         backtrack(1);         cout<<\"Case \"<<z<<\": \"<<sum<<endl;     sum=0; textNum--; z++; } return 0; }","title":"图的m着色问题(回溯)"},{"content":"算法设计例题：最长公共子序列（DP） memory limit: 65536KB    time limit: 500MS accept: 50    submit: 124 Description 一个给定序列的子序列是在该序列中删去若干元素后得到的序列。确切地说，若给定序列 X = { x1，x2，…，xm }，则另一序列Z={ z1，z2，…，zk }，X的子序列是指存在一个严格递增下标序列{ i1，i2，…，ik }，使得对于所有 j = 1，2，…，k ，有 zj = xij 给出两个字符序列X和Y，求出它们的最长公共子序列。 Input 输入的第一行为测试样例的个数T（ T < 40 ），接下来有T个测试样例。每个测试样例的第一行是字符串X，第二行是字符串Y。X和Y只包含大写字母，且长度不大于1000。 Output 对应每个测试样例输出一行，只有一个整数，表示字符串X和字符串Y的最长公共子序列的长度。 Sample Input 2 ABCDE ACE AAABBBCCC AABBCC Sample Output 3 6 Author Eapink & CYL 解决方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include<iostream> #include<string.h> #define N 1000 int dp[N][N];   int max(int a,int b) {     return a>b?a:b; }   int main() {     int i,j,k,len1,len2,textNum;     char s1[N],s2[N];     scanf(\"%d\",&textNum);     for(k=0;k<textNum;k++)     {         scanf(\"%s%s\",s1,s2);         len1=strlen(s1);         len2=strlen(s2);         for(i=1;i<len1;i++)             dp[i][0]=0;         for(j=1;j<len2;j++)             dp[0][j]=0;         for(i=1;i<=len1;i++)             for(j=1;j<=len2;j++)                 if(s1[i-1]==s2[j-1])                     dp[i][j]=dp[i-1][j-1]+1;                 else                     dp[i][j]=max(dp[i-1][j],dp[i][j-1]);         printf(\"%d\\n\",dp[len1][len2]);                                 }         return 0; }","title":"最长公共子序列（DP）"},{"content":"今天，给大家分享我刚做好的可旋转的三维界面效果，不打算过多介绍，可以看看下面几个图片。           其实，如果把这个程序的窗口变成透明，就可以做出QQ 2013的登陆界面动画效果了。 把这个例子运行后，通过键盘上的左，右箭键来控制旋转的方向。   这里的快捷键，我使用了KeyBinding类来设置，另外，自定义了两个命令，分别执行向左转和向右转的动画。     /// <summary>    /// 向前移动    /// <\/summary>    public class ForwCommand : ICommand    {        public bool CanExecute(object parameter)        {            if (parameter == null)            {                return false;            }            return true;        }        public event EventHandler CanExecuteChanged;        public void Execute(object parameter)        {            AxisAngleRotation3D rot = parameter as AxisAngleRotation3D;            DoubleAnimation d = new DoubleAnimation();            d.Duration = new Duration(TimeSpan.FromMilliseconds(800));            d.By = 90d;            rot.BeginAnimation(AxisAngleRotation3D.AngleProperty, d, HandoffBehavior.Compose);        }    }    /// <summary>    /// 向后移动    /// <\/summary>    public class BackCommand : ICommand    {        public bool CanExecute(object parameter)        {            if (parameter == null)            {                return false;            }            return true;        }        public event EventHandler CanExecuteChanged;        public void Execute(object parameter)        {            AxisAngleRotation3D rot = parameter as AxisAngleRotation3D;            DoubleAnimation d = new DoubleAnimation();            d.By = -90d;            d.Duration = new Duration(TimeSpan.FromMilliseconds(800));            rot.BeginAnimation(AxisAngleRotation3D.AngleProperty, d, HandoffBehavior.Compose);        }    } 然后将其应用到主窗口类中。             // 设置快捷键            KeyBinding forwBind = new System.Windows.Input.KeyBinding();            forwBind.Command = new ForwCommand();            forwBind.CommandParameter = ar;            forwBind.Key = System.Windows.Input.Key.Right;            this.InputBindings.Add(forwBind);            KeyBinding backBind = new System.Windows.Input.KeyBinding();            backBind.Command = new BackCommand();            backBind.CommandParameter = ar;            backBind.Key = System.Windows.Input.Key.Left;            this.InputBindings.Add(backBind); 至于UI，就参考源代码中的XAML，主要用到了三维材料。 稍后我把源代码上传到资源区。","title":"带旋转动画的三维界面视图"},{"content":"作用：在调试linux驱动的时候，可以用debugfs来调试，debugfs类似字符设备驱动一样，不需要主设备号次设备号等等。 只需要实现一个file_operations，然后通过debugfs_create_file就可以在debugfs中建立一个文件结点，就像字符设备驱动那样，只需要对这个文件结点进行open就可以进行read、write、ioctl，等等操作，这些操作对应到我们在驱动里为debugfs准备的file_operations 内核启动后会把debugfs文件系统挂载到/sys/kernel/debug目录下，如果没有找到，那么可以手动挂载mount -t debugfs none /data/debug。 如果挂载失败，确认内核是否配置CONFIG_DEBUG_FS 让内核支持DEBUGFS，使能宏CONFIG_DEBUG_FS，在内核配置中选中，一般是在Kernel hacking中： 选择-*- Debug Filesystem 实例 Ath6kl-3.5驱动调试=================================== cd /data/ mkdir debug mount -t debugfs none debug root@android:/data/debug/ieee80211/phy1/ath6kl # ls  cat tgt_stats      对应的下面驱动中的调试 1. 创建文件操作函数 static const struct file_operations fops_tgt_stats = { .read = read_file_tgt_stats, .open = ath6kl_debugfs_open, .owner = THIS_MODULE, .llseek = default_llseek, }; 2.创建文件目录 ar->debugfs_phy = debugfs_create_dir(\"ath6kl\",      ar->wiphy->debugfsdir); if (!ar->debugfs_phy) return -ENOMEM; 注： /* dir in debugfs: ieee80211/<wiphyname> */ struct dentry *debugfsdir; 3.创建读写文件tgt_stats debugfs_create_file(\"tgt_stats\", S_IRUSR, ar->debugfs_phy, ar,     &fops_tgt_stats); 4.实现fops_tgt_stats  static int ath6kl_debugfs_open(struct inode *inode, struct file *file) { file->private_data = inode->i_private; return 0; } static ssize_t read_file_tgt_stats(struct file *file, char __user *user_buf,    size_t count, loff_t *ppos) { struct ath6kl *ar = file->private_data; struct ath6kl_vif *vif; struct target_stats *tgt_stats; char *buf; unsigned int len = 0, buf_len = 1500; int i; long left; ssize_t ret_cnt; vif = ath6kl_vif_first(ar); if (!vif) return -EIO; tgt_stats = &vif->target_stats; buf = kzalloc(buf_len, GFP_KERNEL); if (!buf) { kfree(buf); return -ENOMEM; } if (down_interruptible(&ar->sem)) { kfree(buf); return -EBUSY; } set_bit(STATS_UPDATE_PEND, &vif->flags); if (ath6kl_wmi_get_stats_cmd(ar->wmi, 0)) { up(&ar->sem); kfree(buf); return -EIO; } left = wait_event_interruptible_timeout(ar->event_wq, !test_bit(STATS_UPDATE_PEND, &vif->flags), WMI_TIMEOUT); up(&ar->sem); if (left <= 0) { kfree(buf); return -ETIMEDOUT; } len += scnprintf(buf + len, buf_len - len, \"\\n\"); len += scnprintf(buf + len, buf_len - len, \"%25s\\n\",  \"Target Tx stats\"); len += scnprintf(buf + len, buf_len - len, \"%25s\\n\\n\",  \"=================\"); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"Ucast packets\", tgt_stats->tx_ucast_pkt); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"Bcast packets\", tgt_stats->tx_bcast_pkt); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"Mcast packets\", tgt_stats->tx_mcast_pkt); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"Ucast byte\", tgt_stats->tx_ucast_byte); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"Bcast byte\", tgt_stats->tx_bcast_byte); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"Mcast byte\", tgt_stats->tx_mcast_byte); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"Rts success cnt\", tgt_stats->tx_rts_success_cnt); for (i = 0; i < 4; i++) len += scnprintf(buf + len, buf_len - len,  \"%18s %d %10llu\\n\", \"PER on ac\",  i, tgt_stats->tx_pkt_per_ac[i]); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"Error\", tgt_stats->tx_err); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"Fail count\", tgt_stats->tx_fail_cnt); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"Retry count\", tgt_stats->tx_retry_cnt); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"Multi retry cnt\", tgt_stats->tx_mult_retry_cnt); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"Rts fail cnt\", tgt_stats->tx_rts_fail_cnt); len += scnprintf(buf + len, buf_len - len, \"%25s %10llu\\n\\n\",  \"TKIP counter measure used\",  tgt_stats->tkip_cnter_measures_invoked); len += scnprintf(buf + len, buf_len - len, \"%25s\\n\",  \"Target Rx stats\"); len += scnprintf(buf + len, buf_len - len, \"%25s\\n\",  \"=================\"); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"Ucast packets\", tgt_stats->rx_ucast_pkt); len += scnprintf(buf + len, buf_len - len, \"%20s %10d\\n\",  \"Ucast Rate\", tgt_stats->rx_ucast_rate); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"Bcast packets\", tgt_stats->rx_bcast_pkt); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"Mcast packets\", tgt_stats->rx_mcast_pkt); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"Ucast byte\", tgt_stats->rx_ucast_byte); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"Bcast byte\", tgt_stats->rx_bcast_byte); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"Mcast byte\", tgt_stats->rx_mcast_byte); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"Fragmented pkt\", tgt_stats->rx_frgment_pkt); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"Error\", tgt_stats->rx_err); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"CRC Err\", tgt_stats->rx_crc_err); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"Key chache miss\", tgt_stats->rx_key_cache_miss); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"Decrypt Err\", tgt_stats->rx_decrypt_err); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"Duplicate frame\", tgt_stats->rx_dupl_frame); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"Tkip Mic failure\", tgt_stats->tkip_local_mic_fail); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"TKIP format err\", tgt_stats->tkip_fmt_err); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"CCMP format Err\", tgt_stats->ccmp_fmt_err); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\\n\",  \"CCMP Replay Err\", tgt_stats->ccmp_replays); len += scnprintf(buf + len, buf_len - len, \"%25s\\n\",  \"Misc Target stats\"); len += scnprintf(buf + len, buf_len - len, \"%25s\\n\",  \"=================\"); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"Beacon Miss count\", tgt_stats->cs_bmiss_cnt); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"Num Connects\", tgt_stats->cs_connect_cnt); len += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",  \"Num disconnects\", tgt_stats->cs_discon_cnt); len += scnprintf(buf + len, buf_len - len, \"%20s %10d\\n\",  \"Beacon avg rssi\", tgt_stats->cs_ave_beacon_rssi); len += scnprintf(buf + len, buf_len - len, \"%25s\\n\",  \"Wow stats\"); len += scnprintf(buf + len, buf_len - len, \"%25s\\n\",  \"=================\"); len += scnprintf(buf + len, buf_len - len, \"%20s %10u\\n\",  \"Wow pkt dropped\", tgt_stats->wow_pkt_dropped); len += scnprintf(buf + len, buf_len - len, \"%20s %10u\\n\",  \"Wow evt discarded\", tgt_stats->wow_evt_discarded); len += scnprintf(buf + len, buf_len - len, \"%20s %10u\\n\",  \"Wow host pkt wakeup\", tgt_stats->wow_host_pkt_wakeups); len += scnprintf(buf + len, buf_len - len, \"%20s %10u\\n\",  \"Wow host evt wakeups\", tgt_stats->wow_host_evt_wakeups); if (len > buf_len) len = buf_len; ret_cnt = simple_read_from_buffer(user_buf, count, ppos, buf, len); kfree(buf); return ret_cnt; }","title":"[置顶] Linux 内核调试之3 debugfs（以atheros wifi驱动分析）"},{"content":"vector看成数组，list看成链表，具体的内部存储方法可以参考stl 数据定义 #include <map> #include <vector> #include <list>  using namespace std;  typedef map<int, byte*> ByteMap; ByteMap  testMap; typedef\tvector<int>\t\tIntVec; IntVec   testVec; typedef list<int>\t\tIntList; IntList\t testList; 遍历删除vector \tIntVec::iterator iter = testVec.begin(); \tfor (; iter != testVec.end();) \t{ \t\titer = testVec.erase(iter); \t} 遍历删除list \tIntList::iterator iter = testList.begin(); \tfor (; iter != testList.end(); ) \t{ \t\t//testList.erase(iter++); //可行 \t\titer = testList.erase(iter); \t} 初始化map \tint nMem = 80; \tint nNum = 4; \tbyte** by = new byte*[nNum]; \tfor (int i = 0; i< nNum; i++) \t{ \t\tby[i] = new byte[nMem]; \t\tmemset(by[i], i, nMem); \t\ttestMap[i] = by[i]; \t} 遍历删除map \tByteMap::iterator iter = testMap.begin(); \twhile(iter != testMap.end()) \t{ \t\tbyte* pb = (*iter).second; \t\tif (pb) \t\t{ \t\t\tdelete []pb; \t\t\tpb = NULL; \t\t} \t\t//testMap.erase(iter++);//都可以 \t\titer = testMap.erase(iter); \t} 注明： testMap.erase(iter++)可以 改成testMap.erase(iter); iter++就不行，会在 \t\titerator operator++(int) \t\t\t{\t// postincrement \t\t\titerator _Tmp = *this; \t\t\t++*this; \t\t\treturn (_Tmp); \t\t\t} 崩溃。 大概前者会在++之前给iter建立一个缓存对象，之后再在此基础之上++，而后者erase之后iter就没有实际意义了。如下。 iter = (-17891602,0xfeeefeee <错误的指针>) 二维数组上级指针的内存释放，下级指针已经在map中释放了 \tif (by) \t{ \t\tdelete []by; \t\tby = NULL; \t}","title":"stl的vector，map，list删除元素"},{"content":"1、定义结构体 class vacation //jiao { public: AnsiString vname; AnsiString vdate; int status; };   2、定义vector  std::vector<vacation*>    m_vacationDate; 3、读取  vacation *pTemp=NULL;    pTemp = new vacation();    if (NULL == pTemp)    {     return false;    }    for (std::vector<vacation *>::iterator it=m_vacationDate.begin();it<m_vacationDate.end();++it)    {        pTemp=*it;        AnsiString  aDate1=pTemp->vdate;  } 4、放数据 vacation *pVacation=NULL;             pVacation = new vacation();             if (NULL == pVacation)             {               return false;             }  pVacation->vdate=FormatDateTime(\"yyyy-mm-dd\",startdate);  m_vacationDate.push_back(pVacation);","title":"bcb vector使用"},{"content":"'''      Author: liupengfei    Function: count lines of code in a folder iterativelyShell-format: cmd [dir]   Attention: default file encode is utf8 and default file type is java-source-file. But users can customize this script by just modifing global variables.'''import sysimport osimport codecsfrom _pyio import opentotalCount = 0;fileType = '.java'descLineBegin = '//'descBlockBegin = r'/**'descBlockEnd = r'*/'fileEncode = 'utf-8'def main():    DIR = os.getcwd()    if len(sys.argv) >= 2:        DIR = sys.argv[1]    if os.path.exists(DIR) and os.path.isdir(DIR):        print('target directory is %s' % DIR)        countDir(DIR)        print('total code line is %d' % totalCount)    else:        print('target should be a directory!')def isFileType(file):    return len(fileType) + file.find(fileType) == len(file)def countDir(DIR):    for file in os.listdir(DIR):        absPath = DIR + os.path.sep + file;        if os.path.exists(absPath):            if os.path.isdir(absPath):                countDir(absPath)            elif isFileType(absPath):                try:                    countFile(absPath)                except UnicodeDecodeError:                    print(                        '''encode of %s is different, whichis not supported in this version!'''                        )def countFile(file):    global totalCount    localCount = 0    isInBlockNow = False    f = codecs.open(file, 'r', fileEncode);    for line in f:        if (not isInBlockNow) and line.find(descLineBegin) == 0:            pass;        elif (not isInBlockNow) and line.find(descBlockBegin) >= 0:            if line.find(descBlockBegin) > 0:                localCount += 1            isInBlockNow = True;        elif isInBlockNow and line.find(descBlockEnd) >= 0:            if line.find(descBlockEnd) + len(descBlockEnd) < len(line):                localCount += 1            isInBlockNow = False;        elif (not isInBlockNow) and len(line.replace('\\\\s+', '')) > 0:            localCount += 1    f.close()    totalCount += localCount    print('%s : %d' % (file, localCount))if __name__ == '__main__':    main();","title":"python实现的代码行数统计（纯代码）"},{"content":" 　　JSON(全称为JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript语法标准的一个子集。 JSON采用完全独立于语言的文本格式，可以很容易在各种网络、平台和程序之间传输。JSON的语法很简单，易于人阅读和编写，同时也易于机器解析和生成。 JSON与XML的比较 ◆可读性 　　JSON和XML的可读性相比较而言，由于XML提供辅助的标签，更加适合人阅读和理解。 ◆文件大小与传输 　　XML允许使用方便的标签，所以文件尺寸是要比JSON大的。而且JSON源于Javascript，所以天生的主战场是Javascript与网络，在这里，JSON有着XML无法赶超的优势。 JSON语法 1. JSON 语法是 JavaScript 对象表示法语法的子集。 数据在名称/值对中：名称是字符串，使用双引号表示。值可以是：数字（整数或浮点数），字符串（在双引号中）,数组（在方括号中）,对象（在花括号中），true/false/null。 数据由逗号分隔： 花括号保存对象：对象可以包含各种数据，包括数组。 方括号保存数组：数字可以包含对象。 例如： {     \"employees\": [         {             \"firstName\": \"Bill\",             \"lastName\": \"Gates\"         },         {             \"firstName\": \"George\",             \"lastName\": \"Bush\"         }     ] } 2. 如果JSON中含有转义字符，则需要转义。例如文件路径中需要使用\"\\\\\"而不是\"\\\"。例如：{ \"file\":\"C:\\\\a.txt\"}。   .NET操作JSON 　　JSON文件读入到内存中就是字符串，.NET操作JSON就是生成与解析JSON字符串。操作JSON通常有以下几种方式： 1. 原始方式：自己按照JSON的语法格式，写代码直接操作JSON字符串。如非必要，应该很少人会走这条路，从头再来的。 2. 通用方式：这种方式是使用开源的类库Newtonsoft.Json(下载地址http://json.codeplex.com/)。下载后加入工程就能用。通常可以使用JObject, JsonReader, JsonWriter处理。这种方式最通用，也最灵活，可以随时修改不爽的地方。 (1)使用JsonReader读Json字符串： string jsonText = @\"{\"\"input\"\" : \"\"value\"\", \"\"output\"\" : \"\"result\"\"}\"; JsonReader reader = new JsonTextReader(new StringReader(jsonText)); while (reader.Read()) {     Console.WriteLine(reader.TokenType + \"\\t\\t\" + reader.ValueType + \"\\t\\t\" + reader.Value); } (2)使用JsonWriter写字符串： StringWriter sw = new StringWriter(); JsonWriter writer = new JsonTextWriter(sw); writer.WriteStartObject(); writer.WritePropertyName(\"input\"); writer.WriteValue(\"value\"); writer.WritePropertyName(\"output\"); writer.WriteValue(\"result\"); writer.WriteEndObject(); writer.Flush(); string jsonText = sw.GetStringBuilder().ToString(); Console.WriteLine(jsonText); (3)使用JObject读写字符串： JObject jo = JObject.Parse(jsonText); string[] values = jo.Properties().Select(item => item.Value.ToString()).ToArray(); (4)使用JsonSerializer读写对象(基于JsonWriter与JsonReader):  Project p = new Project() { Input = \"stone\", Output = \"gold\" }; JsonSerializer serializer = new JsonSerializer(); StringWriter sw = new StringWriter(); serializer.Serialize(new JsonTextWriter(sw), p); Console.WriteLine(sw.GetStringBuilder().ToString()); StringReader sr = new StringReader(@\"{\"\"Input\"\":\"\"stone\"\", \"\"Output\"\":\"\"gold\"\"}\"); Project p1 = (Project)serializer.Deserialize(new JsonTextReader(sr), typeof(Project)); Console.WriteLine(p1.Input + \"=>\" + p1.Output); 　　上面的代码都是基于下面这个Project类定义： class Project {     public string Input { get; set; }     public string Output { get; set; } } 　　此外，如果上面的JsonTextReader等类编译不过的话，说明是我们自己修改过的类，换成你们自己的相关类就可以了，不影响使用。 3. 内置方式：使用.NET Framework 3.5/4.0中提供的System.Web.Script.Serialization命名空间下的JavaScriptSerializer类进行对象的序列化与反序列化，很直接。  Project p = new Project() { Input = \"stone\", Output = \"gold\" };  JavaScriptSerializer serializer = new JavaScriptSerializer();  var json = serializer.Serialize(p);  Console.WriteLine(json);  var p1 = serializer.Deserialize<Project>(json);  Console.WriteLine(p1.Input + \"=>\" + p1.Output);  Console.WriteLine(ReferenceEquals(p,p1)); 　　注意：如果使用的是VS2010，则要求当前的工程的Target Framework要改成.Net Framework 4，不能使用Client Profile。当然这个System.Web.Extensions.dll主要是Web使用的，直接在Console工程中用感觉有点浪费资源。 　　此外，从最后一句也可以看到，序列化与反序列化是深拷贝的一种典型的实现方式。 4. 契约方式：使用System.Runtime.Serialization.dll提供的DataContractJsonSerializer或者 JsonReaderWriterFactory实现。 Project p = new Project() { Input = \"stone\", Output = \"gold\" }; DataContractJsonSerializer serializer = new DataContractJsonSerializer(p.GetType()); string jsonText; using (MemoryStream stream = new MemoryStream()) {     serializer.WriteObject(stream, p);     jsonText = Encoding.UTF8.GetString(stream.ToArray());     Console.WriteLine(jsonText); } using (MemoryStream ms = new MemoryStream(Encoding.UTF8.GetBytes(jsonText))) {     DataContractJsonSerializer serializer1 = new DataContractJsonSerializer(typeof(Project));     Project p1 = (Project)serializer1.ReadObject(ms);     Console.WriteLine(p1.Input + \"=>\" + p1.Output); } 　　这里要注意，这里的Project类和成员要加相关的Attribute： [DataContract] class Project {     [DataMember]     public string Input { get; set; }     [DataMember]     public string Output { get; set; } } 实用参考： JSON验证工具：http://jsonlint.com/ JSON简明教程：http://www.w3school.com.cn/json/ Newtonsoft.Json类库下载：http://json.codeplex.com/","title":"C#处理Json文件"},{"content":"今天突然遇到一个问题，就是加了hibernate 框架的项目在启动的时候，特别慢，竟然达到了4分多钟，查来查去，看到我的bean类里*.hbm.xml，有这样的写法： <?xml version=\"1.0\"?> <!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"> …… 然后我换成了： <?xml version=\"1.0\"?> <!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\"> …… 这样启动的时候就不慢了。 归结原因是因为hiberante版本问题，在高版本的用上面的可以，在低版本的用上面的，在不联网的时候就会报错，联网时启动特别慢。 当你在浏览器里访问：http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd  这个时时，它会下载一个dtd的文件。 原文来自 站长网www.software8.co/","title":"关于加了hibernate 框架的项目启动特别慢的问题"},{"content":"    以前在LINUX环境下，想输入密码（关闭回显）时都是用getpass函数，今天无意中看到手册上说：This function is obsolete.  Do not use it.      那我就自己实现一个类似的功能吧（功能相同，原理不同） 程序的思路很简单：关闭回显，读取输入，恢复设置。 上代码： #include <stdio.h>#include <stdlib.h>#include <termios.h>#include <string.h>#define MAXLEN 256//参数dest是目标字符串, maxlen是最大长度，//如果输入超过了最大长度，则密码将会被截断//成功返回0，否则返回－1int new_getpass(char *dest, int maxlen){\tstruct termios oldflags, newflags;\tint len;\t//设置终端为不回显模式 \ttcgetattr(fileno(stdin), &oldflags);\tnewflags = oldflags;\tnewflags.c_lflag &= ~ECHO;\tnewflags.c_lflag |= ECHONL;\tif (tcsetattr(fileno(stdin), TCSANOW, &newflags) != 0)\t{\t\tperror(\"tcsetattr\");\t\treturn -1;\t}\t//获取来自键盘的输入\tfgets(dest, maxlen, stdin);\tlen = strlen(dest);\tif( len > maxlen-1 )\t\tlen = maxlen - 1;\tdest[len-1] = 0;\t//恢复原来的终端设置\tif (tcsetattr(fileno(stdin), TCSANOW, &oldflags) != 0)\t{\t\tperror(\"tcsetattr\");\t\treturn -1;\t}\treturn 0;}int main(){\tchar password[MAXLEN];\tprintf(\"Enter password: \");\tnew_getpass(password, MAXLEN);\tprintf(\"You password is: %s\\n\", password);\treturn 0;}","title":"LINUX：用C语言来模拟密码输入"},{"content":"http://java.chinaitlab.com/line/373702.html eg.继承Thread public class MyThread_1 extends Thread { public void run() { //some code } }  当使用继承创建线程，这样启动线程： new MyThread_1().start()  eg.实现Runnable接口 public class MyThread_2 implements Runnable { public void run() { //some code } } 当使用实现接口创建线程，这样启动线程： new Thread(new MyThread_2()).start()   例子： 1、实现Runnable接口的多线程例子 /**  * 实现Runnable接口的类  *  * @author leizhimin 2008-9-13 18:12:10  */  public class DoSomething implements Runnable {      private String name;      public DoSomething(String name) {          this.name = name;      }      public void run() {          for (int i = 0; i < 5; i++) {              for (long k = 0; k < 100000000; k++) ;              System.out.println(name + \": \" + i);          }      }  } public class TestRunnable {      public static void main(String[] args) {          DoSomething ds1 = new DoSomething(\"阿三\");          DoSomething ds2 = new DoSomething(\"李四\");          Thread t1 = new Thread(ds1);          Thread t2 = new Thread(ds2);          t1.start();          t2.start();      }  } 执行结果： 李四: 0  阿三: 0  李四: 1  阿三: 1  李四: 2  李四: 3  阿三: 2  李四: 4  阿三: 3  阿三: 4  2、继承Thread类实现的多线程例子 /**  * 测试扩展Thread类实现的多线程程序  *  * @author leizhimin 2008-9-13 18:22:13  */  public class TestThread extends Thread{      public TestThread(String name) {          super(name);      }      public void run() {          for(int i = 0;i<5;i++){              for(long k= 0; k <100000000;k++);              System.out.println(this.getName()+\" :\"+i);          }      }      public static void main(String[] args) {          Thread t1 = new TestThread(\"阿三\");          Thread t2 = new TestThread(\"李四\");          t1.start();          t2.start();      }  } 执行结果： 阿三 :0  李四 :0  阿三 :1  李四 :1  阿三 :2  李四 :2  阿三 :3  阿三 :4  李四 :3  李四 :4 ","title":"Java线程：创建与启动"},{"content":"HttpFileCollection files = System.Web.HttpContext.Current.Request.Files;  string url = System.Web.HttpContext.Current.Server.MapPath(\"/File/\" + gfilename + filenameext);     就是在前面加上【System.Web.HttpContext.Current.】","title":"Asp.net中提示【当前上下文中不存在名称“Request“或\"Server\"】解决方法！"},{"content":"目的        根据之前《Innodb存储引擎查询输出分析》中对Innodb查询输出的逻辑处理过程的分析和测试，对Innodb的输出有了深入的了解。然而在阅读了《MySQL技术内幕--SQL编程》中P91设计的测试，并通过跟该书作者进行沟通交流。对查询输出进行补充，弥补之前没有考虑周全的地方。 测试设计        该测试主要依据《MySQL技术内幕--SQL编程》P91页设计的测试。首先对设计进行测试；然后做相应的调整，进行进一步的测试。在此，将该设计再次描述如下。        表结构的设计如下所示：  CREATE TABLE animals( id INT PRIMARY KEY, name VARCHAR(30), UNIQUE KEY(name) ) ENGINE=INNODB;         测试数据设计如下所示：  INSERT INTO animals SELECT 1, 'Tiger'; INSERT INTO animals SELECT 2, 'Dog'; INSERT INTO animals SELECT 3, 'Cat';         测试的查询语句如下所示：  SELECT * FROM animals;         调整测试的数据表，具体如下所示：  ALTER TABLE animals ADD COLUMN age INT;         调整后的数据表进行同样的查询语句进行测试。 测试        在给出输出查询结果之前，非常有必要首先给出查询的查询计划。因为对照查询计划，可以从查询结果中得到导致该现象的原因。        查询语句explain select * from animals;查询计划如下所示：  id select_type table type possible_keys key key_len ref rows Extra 1 SIMPLE animals index NULL name 93 NULL 3 Using index          从查询计划来看，该查询使用了索引，索引为name字段的unique索引。具体为什么使用unique索引，将在之后的内容中详细从源码的逻辑处理介绍MySQL索引选择的原则。        查询结果与书中给出的结果一致。如下所示：  id name 3 Cat 2 Dog 1 Tiger         通过结果来看，确实没有按照id进行顺序输出，当然结果也是按照id有序输出的，但这只能是设计的巧合。而参照查询计划来看查询输出的结果，可以发现实际的输出顺序是按照name有序输出的。原因就是MySQL虽然是全表查询，但是查询优化器找到了unique索引，认为查询字段通过索引查找的效率要远远高于全表扫描。因此，查询计划是索引查询。由于unique索引是辅助索引，所以输出结果按照辅助索引的键值进行输出的。当然本书作者测试情况比较特殊，而没有从普遍情况到特殊情况的全面描述，导致了读者的误解。至少我跟我的同事误解了该问题的解释。        为了进一步对该问题进行研究和测试，对表进行调整，添加一个字段，改变当前的查询计划，然后对比测试。        同样，首先给出查询计划，同样的查询语句，查询计划如下所示：  id select_type table type possible_keys key key_len ref rows Extra 1 SIMPLE animals ALL NULL NULL NULL NULL 3           从查询计划可以看出，查询类型为全表扫描，没有通过索引进行查询。        查询结果如下所示  id name 1 Tiger 2 Dog 3 Cat         从查询结果来看，查询输出以id主键顺序输出。这仍然符合《Innodb存储引擎查询输出分析》中的逻辑分析和测试的过程。 结论        通过以上测试和对比，《Innodb存储引擎查询输出分析》中的测试仅仅对普遍的全表扫描进行的测试和描述，而没有考虑特殊的查询。而《MySQL技术内幕--SQL编程》中的测试正好从特殊的情况，认为查询输出不一定按照主键输出的。        因此，查询输出的规则依赖于查询语句的类型。如果查询进行全表扫描或者使用主键索引的方式进行查询，那么查询输出按照主键的顺序进行输出；如果查询使用辅助索引进行查询，那么查询输出按照辅助索引的键值顺序进行输出。 参考 1、《Innodb存储引擎查询输出分析》 2、《MySQL技术内幕--SQL编程》","title":"Innodb存储引擎查询输出分析--补充"},{"content":"              全心全意为人民服务的思想，最早是毛泽东在纪念张思德同志的追悼会上提出来的。在这里，我们将之引用到编程上，意义何在呢？       似乎，在编程过程中，尽量减少Bug的出现，实现程序的正常运转，美化界面等是其关键所在。但是，使用应用程序的主体是广大的人民群众，因此，“全心全意为人民服务”的理念便成了“一切从您的基本利益出发，全心全意为您着想”。这一点，IT行业的巨头——微软就做的非常好。       拿Onenote来说，这是微软一款小有名气的笔记本软件。它模仿我们平时记笔记的笔记本功能，并配有搜索功能，是可以将图片、文字、录音、录像等全部整合起来的智能笔记本，当然还有它的自动保存功能，这些都无一不体现着微软的创作理念。当然，我们这篇文章的目的并不是吹捧微软的产品有多nice，我想说明的是，一款好的产品，源于它好的品质。人性化的操作，给人一种贴心、舒适的感觉的同时，更大的效益是会吸引更多的客户使用。不知道你发现没有，在产品和客户之间，似乎有一种外在的东西在其中搭桥、牵线。对，这其中起着衔接作用的，就是这种全心全意为人民服务的理念。       在做学生管理系统的时候，我并没有将这种思想重视起来，甚至脑子里根本没有这种想法。这或许也是千千万万程序员的弊病所在。同样是努力，同样是专注于同一领域，为什么别人可以把东西做的这么好？用赵本山小品的话说，“为什么差距就这么大呢？”，我们是否也该想一想？承认技术这一块，可能是造成差距的原因，但是除此之外呢？假设技术持于同一水平线，为什么还是有好坏优劣之分呢？是不是我们的脑子中，没有将这种理念足够的重视起来呢？       在学生管理系统验收的时候，我们自己简单的看看，并没有发现什么错误。等到师傅给我们验收的时候，才知道问题之所在。就拿学籍管理这一块来说，里面有一个输入学生出生日期和入学日期，需要手动输入，而且年份、月份、日期之间还要加“-”。想想都麻烦，为何不加一个下拉菜单，一点击所有的日期都出来了，避免了手动输入的繁琐。可是我们在做程序的时候，却根本没有想到这些，更没有深入的思考。如何能将“全心全意为人民服务”理念自如的运用到我们的程序中，是不是我们每个程序员该思考的问题呢？       最后，想说一句话，照搬前年流行的那句话，“我们敲的不是代码，是思想”","title":"为何要在编程中始终体现“全心全意为人民服务”的思想"},{"content":"一、概述 在传统的编程概念中，过程是由程序员在本地编译完成，并只能局限在本地运行的一段代码，也即其主程序和过程之间的运行关系是本地调用关系。因此这种结构在网络日益发展的今天已无法适应实际需求。总而言之，传统过程调用模式无法充分利用网络上其他主机的资源（如CPU、 Memory等），也无法提高代码在实体间的共享程度，使得主机资源大量浪费。 而本文要介绍的RPC编程，正是很好地解决了传统过程所存在的一系列弊端。通过RPC我们可以充分利用非共享内存的多处理器环境（例如通过局域网连接的多台工作站）,这样可以简便地将你的应用分布在多台工作站上，应用程序就像运行在一个多处理器的计算机上一样。你可以方便的实现过程代码共享，提高系统资源的利用率，也可以将以大量数值处理的操作放在处理能力较强的系统上运行，从而减轻前端机的负担。 二、RPC的结构原理及其调用机制 如前所述RPC其实也是一种C/S的编程模式，有点类似C/S Socket 编程模式，但要比它更高一层。当我们在建立RPC服务以后，客户端的调用参数通过底层的RPC传输通道，可以是UDP，也可以是TCP（也即TI-RPC —无关性传输），并根据传输前所提供的目的地址及RPC上层应用程序号转至相应的RPC Application Porgramme Server ，且此时的客户端处于等待状态，直至收到应答或Time Out超时信号。具体的流程图如图1。当服务器端获得了请求消息，则会根据注册RPC时告诉RPC系统的例程入口地址，执行相应的操作，并将结果返回至客户端。 当一次RPC调用结束后，相应线程发送相应的信号，客户端程序才会继续运行。 当然，一台服务主机上可以有多个远程过程提供服务，那么如何来表示一个唯一存在的远程过程呢？一个远程过程是有三个要素来唯一确定的：程序号、版本号和过程号。程序号是用来区别一组相关的并且具有唯一过程号的远程过程。一个程序可以有一个或几个不同的版本，而每个版本的程序都包含一系列能被远程调用的过程，通过版本的引入，使得不同版本下的RPC能同时提供服务。每个版本都包含有许多可供远程调用的过程，每个过程则有其唯一标示的过程号。 三、基于RPC的应用系统开发 通过以上对RPC原理的简介后，我们再来继续讨论如何来开发基于RPC的应用系统。一般而言在开发RPC时，我们通常分为三个步骤： a、定义说明客户/服务器的通信协议。 这里所说的通信协议是指定义服务过程的名称、调用参数的数据类型和返回参数的数据类型，还包括底层传输类型（可以是 UDP或TCP），当然也可以由RPC底层函数自动选择连接类型建立TI-RPC。最简单的协议生成的方法是采用协议编译工具，常用的有Rpcgen，我会在后面实例中详细描述其使用方法。 b、开发客户端程序。 c、开发服务器端程序。 开发客户端和服务器端的程序时，RPC提供了我们不同层次的开发例程调用接口。不同层次的接口提供了对RPC不同程度控制。一般可分为5个等级的编程接口，接下来我们分别讨论一下各层所提供的功能函数。 1、简单层例程 简单层是面向普通RPC应用，为了快速开发RPC应用服务而设计的，他提供了如下功能函数。 函数名 功能描述 Rpc_reg( ) 在一特定类型的传输层上注册某个过程，来作为提供服务的RPC程序 Rpc_call( ) 远程调用在指定主机上指定的过程 Rpc_Broadcast( ) 向指定类型的所有传输端口上广播一个远程过程调用请求 2、高层例程 在这一层，程序需要在发出调用请求前先创建一个客户端句柄，或是在侦听请求前先建立一个服务器端句柄。程序在该层可以自由的将自己的应用绑在所有的传输端口上，它提供了如下功能函数。 函数名 功能描述 Clnt_create( ) 程序通过这个功能调用，告诉底层RPC服务器的位置及其传输类型 Clnt_create_timed( ) 定义每次尝试连接的超时最大时间 Svc_create( ) 在指定类型的传输端口上建立服务器句柄，告诉底层RPC事件过程的相应入口地址 Clnt_call() 向服务器端发出一个RPC调用请求 3、中间层例程 中间层向程序提供更为详细的RPC控制接口,而这一层的代码变得更为复杂，但运行也更为有效，它提供了如下功能函数。 函数名 功能描述 Clnt_tp_create( ) 在指定的传输端口上建立客户端句柄 Clnt_tp_create_timed( ) 定义最大传输时延 Svc_tp_creaet( ) 在指定的传输端口上建立服务句柄 Clnt_call( ) 向服务器端发出RPC调用请求 4、专家层例程 这层提供了更多的一系列与传输相关的功能调用，它提供了如下功能函数。 函数名 功能描述 Clnt_tli_create( ) 在指定的传输端口上建立客户端句柄 Svc_tli_create( ) 在指定的传输端口上建立服务句柄 Rpcb_set( ) 通过调用rpcbind将RPC服务和网络地址做映射 Rpcb_unset( ) 删除rpcb_set( ) 所建的映射关系 Rpcb_getaddr( ) 调用rpcbind来犯会指定RPC服务所对应的传输地址 Svc_reg( ) 将指定的程序和版本号与相应的时间例程建起关联 Svc_ureg( ) 删除有svc_reg( ) 所建的关联 Clnt_call( ) 客户端向指定的服务器端发起RPC请求 5、底层例程 该层提供了所有对传输选项进行控制的调用接口，它提供了如下功能函数。 函数名 功能描述 Clnt_dg_create( ) 采用无连接方式向远程过程在客户端建立客户句柄 Svc_dg_create( ) 采用无连接方式建立服务句柄 Clnt_vc_create( ) 采用面向连接的方式建立客户句柄 Svc_vc_create( ) 采用面向连接的方式建立RPC服务句柄 Clnt_call( ) 客户端向服务器端发送调用请求 ............引用文字未尽，详细请参见 http://www.yuanma.org/data/2006/0918/article_1560.htm 关于“RPC语言” RPC语言也是一种专门的编程语言，当然这里我们不需要知道太多，只需要能看懂下面这种基本结构就行了： program TESTPROG {    version VERSION {      string TEST(string) = 1;    } = 1; } = 87654321; 这里TESTPROG和VERSION是两个变量，用于标识一个单独的RPC接口。这被RPC服务程序，比如portmap用到，我们可以不用关心，变量名字也是随便取的。但取值要在你的系统中是唯一的。 “string TEST(string) = 1;”这一行说明有两个函数test_VERSION和test_VERSION_svc，这里由于VERSION变量为1，所以函数名为test_1和test_1_svc，这两个函数用于在服务器端和客户端实现调用，即： 在客户端调用test_1函数，服务器端调用test_1_svc函数处理并返回。 函数的类型是string，RPC语言中string即C里面的一个字符串。所以上述函数有一个字符串作为参数传递，同时要返回字符串。即： char ** test_1(char **argp, CLIENT *clnt) 和 char **test_1_svc(char **argp, struct svc_req *rqstp) 同理，如果声明是这样的： program RDICTPROG  /* name of remote program ( not used ) */ {     version RDICTVERS  /* declaration of version ( see below ) */     {         int INITW ( void )     = 1;  /* first procedure in this program */         int INSERTW ( string ) = 2;  /* second procedure in this program */         int DELETEW ( string ) = 3;  /* third procedure in this program */         int LOOKUPW ( string ) = 4;  /* fourth procedure in this program */     } = 1;  /* definition of the program version */ } = 0x30090949;  /* remote program number ( must be unique ) */ 则说明这个RPC中有四个函数可用，即客户端可以调用initw_1、insertw_1、deletew_1、lookupw_1四个函数来向服务端发送消息，服务端可以用initw_1_svc、insertw_1_svc、deletew_1_svc、lookupw_1_svc四个函数来处理请求并返回结果。 原任务 假设现在有这样一个程序，源代码如下： /* dict.c -- main, initw, nextin, insertw, deletew, lookupw */ #include <stdio.h> #include <string.h> #include <stdlib.h> #include <ctype.h> #define MAXWORD 50        /* maximum length of a command or word */ #define DICTSIZ 100        /* maximum number of entries in dictionary. */ char dict[DICTSIZ][MAXWORD + 1];    /* storage for a dictionary of words */ int nwords = 0;            /* number of words in the dictionary */ /* 函数原型 */ int nextin(char *cmd, char *word); int initw(void); int insertw(const char *word); int deletew(const char *word); int lookupw(const char *word); /* ------------------------------------------------------------------ * main -- insert, delete, or lookup words in a dictionary as specified * ------------------------------------------------------------------ */ int main(int argc, char *argv[]) {     char word[MAXWORD + 1];    /* space to hold word from input line */     char cmd;     int wordlen;        /* length of input word */     printf(\"Please input:\\n\");     while (1) {     wordlen = nextin(&cmd, word);     if (wordlen < 0) {         exit(0);     }     switch (cmd) {     case 'I':        /* 初始化 */         initw();         printf(\"Dictionary initialized to empty.\\n\");         break;     case 'i':        /* 插入 */         insertw(word);         printf(\"%s inserted.\\n\", word);         break;     case 'd':        /* 删除 */         if (deletew(word)) {         printf(\"%s deleted.\\n\", word);         } else {         printf(\"%s not found.\\n\", word);         }         break;     case 'l':        /* 查询 */         if (lookupw(word)) {         printf(\"%s was found.\\n\", word);         } else {         printf(\"%s was not found.\\n\", word);         }         break;     case 'q':        /* 退出 */         printf(\"Program quits.\\n\");         exit(0);         break;     default:        /* 非法输入 */         printf(\"command %c invalid.\\n\", cmd);         break;     }            /* end of switch */     }                /* end of while */     return 0; }                /* end of main */ /* ------------------------------------------------------------------ * nextin -- read a command and(possibly) a word from the next input line * ------------------------------------------------------------------ */ int nextin(char *cmd, char *word) {     int i, ch;     ch = getc(stdin);     while (isspace(ch)) {     ch = getc(stdin);     }                /* end of while */     if (ch == EOF) {     return (-1);     }     *cmd = (char) ch;     ch = getc(stdin);     while (isspace(ch)) {     ch = getc(stdin);     }                /* end of while */     if (ch == EOF) {     return (-1);     }     if (ch == '\\n') {     return (0);     }     i = 0;     while (!isspace(ch)) {     if (++i > MAXWORD) {         printf(\"error: word too long.\\n\");         exit(1);     }     *word++ = ch;     ch = getc(stdin);     }                /* end of while */     *word = '\\0';        /* 原来的代码这里有问题 */     return i; }                /* end of nextin */ /* ------------------------------------------------------------------ * initw -- initialize the dictionary to contain no words at all * ------------------------------------------------------------------ */ int initw(void) {     nwords = 0;     return 1; }                /* end of initw */ /* ------------------------------------------------------------------ * insertw -- insert a word in the dictionary * ------------------------------------------------------------------ */ int insertw(const char *word) {     strcpy(dict[nwords], word);     nwords++;     return (nwords); }                /* end of insertw */ /* ------------------------------------------------------------------ * deletew -- delete a word from the dictionary * ------------------------------------------------------------------ */ int deletew(const char *word) {     int i;     for (i = 0; i < nwords; i++) {     if (strcmp(word, dict[i]) == 0) {         nwords--;         strcpy(dict[i], dict[nwords]);         return (1);     }     }                /* end of for */     return (0); }                /* end of deletew */ /* ------------------------------------------------------------------ * lookupw -- look up a word in the dictionary * ------------------------------------------------------------------ */ int lookupw(const char *word) {     int i;     for (i = 0; i < nwords; i++) {     if (strcmp(word, dict[i]) == 0) {         return (1);     }     }                /* end of for */     return (0); }                /* end of lookupw */ 这是一个简单的字典程序，即程序运行起来以后维护着一个字典库，用户可以向里面添加词语，也可以查询或删除词语。 当然，这个程序只能在同一台主机上运行。程序整个运行过程中，只需要完成如下几个步骤： A、接受用户输入； B、分析用户输入决定是否进行下面的步骤：     1、初始化数据库；     2、向数据库添加词语；     3、查询或删除词语 任务分解 大家可以想到，对于一个大型系统，比如需要有很多人维护这个系统的数据。象上面这样独立的程序就不适用了，需要做成分布式系统： 即一个服务器维护着数据库，任何客户端都可以接受用户请求，客户端分析用户命令后提交给服务器去处理。 所以我们可能会把程序分成两部分： 客户端：接受用户输入，并判断用户输入内容的正确性，向服务器提交数据，等服务器返回消息 服务器端：维护数据，接受客户端命令并执行后返回结果。 所以我们把上面这个程序分解成下面两部分： /* dict1.c -- main, nextin */ #include <stdio.h> #include <stdlib.h> #define MAXWORD 50        /* maximum length of a command or word */ /* ------------------------------------------------------------------ * main -- insert, delete, or lookup words in a dictionary as specified * ------------------------------------------------------------------ */ int main(int argc, char *argv[]) {     char word[MAXWORD + 1];    /* space to hold word from input line */     char cmd;     int wordlen;        /* length of input word */     printf(\"Please input:\\n\");     while (1) {     wordlen = nextin(&cmd, word);     if (wordlen < 0) {         exit(0);     }     switch (cmd) {     case 'I':        /* 初始化 */         initw();         printf(\"Dictionary initialized to empty.\\n\");         break;     case 'i':        /* 插入 */         insertw(word);         printf(\"%s inserted.\\n\", word);         break;     case 'd':        /* 删除 */         if (deletew(word)) {         printf(\"%s deleted.\\n\", word);         } else {         printf(\"%s not found.\\n\", word);         }         break;     case 'l':        /* 查询 */         if (lookupw(word)) {         printf(\"%s was found.\\n\", word);         } else {         printf(\"%s was not found.\\n\", word);         }         break;     case 'q':        /* 退出 */         printf(\"Program quits.\\n\");         exit(0);         break;     default:        /* 非法输入 */         printf(\"command %c invalid.\\n\", cmd);         break;     }            /* end of switch */     }                /* end of while */     return 0; }                /* end of main */ /* ------------------------------------------------------------------ * nextin -- read a command and(possibly) a word from the next input line * ------------------------------------------------------------------ */ int nextin(char *cmd, char *word) {     int i, ch;     ch = getc(stdin);     while (isspace(ch)) {     ch = getc(stdin);     }                /* end of while */     if (ch == EOF) {     return (-1);     }     *cmd = (char) ch;     ch = getc(stdin);     while (isspace(ch)) {     ch = getc(stdin);     }                /* end of while */     if (ch == EOF) {     return (-1);     }     if (ch == '\\n') {     return (0);     }     i = 0;     while (!isspace(ch)) {     if (++i > MAXWORD) {         printf(\"error: word too long.\\n\");         exit(1);     }     *word++ = ch;     ch = getc(stdin);     }                /* end of while */     *word = '\\0';     return i; }                /* end of nextin */ 和 /* dict2.c -- initw, insertw, deletew, lookupw */ #include <string.h> #define MAXWORD 50        /* maximum length of a command or word */ #define DICTSIZ 100        /* maximum number of entries in dictionary. */ char dict[DICTSIZ][MAXWORD + 1];    /* storage for a dictionary of words */ int nwords = 0;            /* number of words in the dictionary */ /* ------------------------------------------------------------------ * initw -- initialize the dictionary to contain no words at all * ------------------------------------------------------------------ */ int initw(void) {     nwords = 0;     return 1; }                /* end of initw */ /* ------------------------------------------------------------------ * insertw -- insert a word in the dictionary * ------------------------------------------------------------------ */ int insertw(const char *word) {     strcpy(dict[nwords], word);     nwords++;     return (nwords); }                /* end of insertw */ /* ------------------------------------------------------------------ * deletew -- delete a word from the dictionary * ------------------------------------------------------------------ */ int deletew(const char *word) {     int i;     for (i = 0; i < nwords; i++) {     if (strcmp(word, dict[i]) == 0) {         nwords--;         strcpy(dict[i], dict[nwords]);         return (1);     }     }                /* end of for */     return (0); }                /* end of deletew */ /* ------------------------------------------------------------------ * lookupw -- look up a word in the dictionary * ------------------------------------------------------------------ */ int lookupw(const char *word) {     int i;     for (i = 0; i < nwords; i++) {     if (strcmp(word, dict[i]) == 0) {         return (1);     }     }                /* end of for */     return (0); }                /* end of lookupw */ 这两部分代码只是在功能上实现了分离，显然实现通讯的部分还没有，下面我们利用RPC来快速实现通讯。 利用RPC实现分布式系统 首先，建立一个RPC源文件，源代码rdict.x如下： /* rdict.x */ /* RPC declarations for dictionary program */ const MAXWORD = 10;   /* maximum length of a command or word */ const DICTSIZ = 3;  /* number of entries in dictionary */ struct example      /* unused structure declared here to */ {     int  exfield1;  /* illustrate how rpcgen builds XDR */     char exfield2;  /* routines to convert structures */ }; /* ------------------------------------------------------------------ * RDICTPROG -- remote program that provides insert, delete, and lookup * ------------------------------------------------------------------ */ program RDICTPROG  /* name of remote program ( not used ) */ {     version RDICTVERS  /* declaration of version ( see below ) */     {         int INITW ( void )     = 1;  /* first procedure in this program */         int INSERTW ( string ) = 2;  /* second procedure in this program */         int DELETEW ( string ) = 3;  /* third procedure in this program */         int LOOKUPW ( string ) = 4;  /* fourth procedure in this program */     } = 1;  /* definition of the program version */ } = 0x30090949;  /* remote program number ( must be unique ) */ 然后用下列命令产生服务器端函数rdict_srv_func.c： rpcgen -Ss -o rdict_srv_func.c rdict.x 然后用下列命令产生客户端程序rdict_client.c： rpcgen -Sc -o rdict_client.c rdict.x /************关于本文档******************************************** *filename: 我是这样学习Linux下C语言编程的-利用RPC快速实现分布式系统 *purpose: 说明如何利用RPC快速进行客户端-服务器端C-S结构编程 *wrote by: zhoulifa(zhoulifa@163.com) 周立发(http://zhoulifa.bokee.com) Linux爱好者 Linux知识传播者 SOHO族 开发者 最擅长C语言 *date time:2007-02-27 19:20 *Note: 任何人可以任意复制代码并运用这些文档，当然包括你的商业用途 * 但请遵循GPL *Thanks to: *                Ubuntu 本程序在Ubuntu 6.10系统上测试完全正常 *                Google.com 我通过google搜索并参考了RPC编程相关的许多文章 *               网络安全焦点(www.xfocus.net) 我主要借鉴了此文 http://www.xfocus.net/articles/200009/10.html *Hope:希望越来越多的人贡献自己的力量，为科学技术发展出力 * 科技站在巨人的肩膀上进步更快！感谢有开源前辈的贡献！ *********************************************************************/ 然后用下列命令产生Makefile：  rpcgen -Sm rdict.x > Makefile Makefile文件原内容如下： # This is a template Makefile generated by rpcgen # Parameters CLIENT = rdict_client SERVER = rdict_server SOURCES_CLNT.c = SOURCES_CLNT.h = SOURCES_SVC.c = SOURCES_SVC.h = SOURCES.x = rdict.x TARGETS_SVC.c = rdict_svc.c   rdict_xdr.c TARGETS_CLNT.c = rdict_clnt.c   rdict_xdr.c TARGETS = rdict.h rdict_xdr.c rdict_clnt.c rdict_svc.c    OBJECTS_CLNT = $(SOURCES_CLNT.c:%.c=%.o) $(TARGETS_CLNT.c:%.c=%.o) OBJECTS_SVC = $(SOURCES_SVC.c:%.c=%.o) $(TARGETS_SVC.c:%.c=%.o) # Compiler flags CFLAGS += -g LDLIBS += -lnsl RPCGENFLAGS = # Targets all : $(CLIENT) $(SERVER) $(TARGETS) : $(SOURCES.x)         rpcgen $(RPCGENFLAGS) $(SOURCES.x) $(OBJECTS_CLNT) : $(SOURCES_CLNT.c) $(SOURCES_CLNT.h) $(TARGETS_CLNT.c) $(OBJECTS_SVC) : $(SOURCES_SVC.c) $(SOURCES_SVC.h) $(TARGETS_SVC.c) $(CLIENT) : $(OBJECTS_CLNT)         $(LINK.c) -o $(CLIENT) $(OBJECTS_CLNT) $(LDLIBS) $(SERVER) : $(OBJECTS_SVC)         $(LINK.c) -o $(SERVER) $(OBJECTS_SVC) $(LDLIBS)  clean:          $(RM) core $(TARGETS) $(OBJECTS_CLNT) $(OBJECTS_SVC) $(CLIENT) $(SERVER) 动手修改Makefile，修改后内容如下： # This is a template Makefile generated by rpcgen # Parameters CLIENT = rdict_client SERVER = rdict_server SOURCES_CLNT.c = SOURCES_CLNT.h = SOURCES_SVC.c = SOURCES_SVC.h = SOURCES.x = rdict.x TARGETS_SVC.c = rdict_svc.c   rdict_xdr.c rdict_srv_func.c TARGETS_CLNT.c = rdict_clnt.c   rdict_xdr.c rdict_client.c TARGETS = rdict.h rdict_xdr.c rdict_clnt.c rdict_svc.c OBJECTS_CLNT = $(SOURCES_CLNT.c:%.c=%.o) $(TARGETS_CLNT.c:%.c=%.o) OBJECTS_SVC = $(SOURCES_SVC.c:%.c=%.o) $(TARGETS_SVC.c:%.c=%.o) # Compiler flags CFLAGS += -g LDLIBS += -lnsl RPCGENFLAGS = # Targets all : $(CLIENT) $(SERVER) $(TARGETS) : $(SOURCES.x)         rpcgen $(RPCGENFLAGS) $(SOURCES.x) $(OBJECTS_CLNT) : $(SOURCES_CLNT.c) $(SOURCES_CLNT.h) $(TARGETS_CLNT.c) $(OBJECTS_SVC) : $(SOURCES_SVC.c) $(SOURCES_SVC.h) $(TARGETS_SVC.c) $(CLIENT) : $(OBJECTS_CLNT)         $(LINK.c) -o $(CLIENT) $(OBJECTS_CLNT) $(LDLIBS) $(SERVER) : $(OBJECTS_SVC)         $(LINK.c) -o $(SERVER) $(OBJECTS_SVC) $(LDLIBS) clean:          $(RM) core $(TARGETS) $(OBJECTS_CLNT) $(OBJECTS_SVC) $(CLIENT) $(SERVER) *~ 修改客户端源代码rdict_client.c，把接受用户输入并分析用户输入内容的部分加到程序中来。修改后的代码为： /*  * This is sample code generated by rpcgen.  * These are only templates and you can use them  * as a guideline for developing your own functions.  */ #include \"rdict.h\" /* ------------------------------------------------------------------ * nextin -- read a command and(possibly) a word from the next input line * ------------------------------------------------------------------ */ int nextin(char *cmd, char *word) {     int i, ch;     ch = getc(stdin);     while (isspace(ch)) {     ch = getc(stdin);     }                /* end of while */     if (ch == EOF) {     return (-1);     }     *cmd = (char) ch;     ch = getc(stdin);     while (isspace(ch)) {     ch = getc(stdin);     }                /* end of while */     if (ch == EOF) {     return (-1);     }     if (ch == '\\n') {     return (0);     }     i = 0;     while (!isspace(ch)) {     if (++i > MAXWORD) {         printf(\"error: word too long.\\n\");         exit(1);     }     *word++ = ch;     ch = getc(stdin);     }                /* end of while */     *word = '\\0';     return i; }                /* end of nextin */ void rdictprog_1(char *host) {     CLIENT *clnt;     int *result_1;     char *initw_1_arg;     int *result_2;     char *insertw_1_arg;     int *result_3;     char *deletew_1_arg;     int *result_4;     char *lookupw_1_arg; #ifndef    DEBUG     clnt = clnt_create(host, RDICTPROG, RDICTVERS, \"udp\");     if (clnt == NULL) {     clnt_pcreateerror(host);     exit(1);     } #endif                /* DEBUG */     char word[MAXWORD + 1];    /* space to hold word from input line */     char cmd;     int wordlen;        /* length of input word */     while (1) {     printf(\"\\nPlease input:\");     wordlen = nextin(&cmd, word);     if (wordlen < 0) {         exit(0);     }     /* printf(\"\\nYour cmd is:%c, your word is:%s\\n\", cmd, word); */     switch (cmd) {     case 'I':        /* 初始化 */         result_1 = initw_1((void *) &initw_1_arg, clnt);         /* printf(\"\\nYour result is:%d\\n\", *result_1); */         if (result_1 == (int *) NULL)         clnt_perror(clnt, \"call failed\");         else         if(*result_1 ==0) printf(\"Dictionary initialized to empty.\\n\");         else printf(\"Dictionary have already initialized.\\n\");         break;     case 'i':        /* 插入 */         insertw_1_arg = word;         result_2 = insertw_1(&insertw_1_arg, clnt);         /* printf(\"\\nYour result is:%d, your string is:%s(%d)\\n\", *result_2, insertw_1_arg, strlen(insertw_1_arg)); */         if (result_2 == (int *) NULL)         clnt_perror(clnt, \"call failed\");         else         printf(\"%s inserted.\\n\", word);         break;     case 'd':        /* 删除 */         deletew_1_arg = word;         result_3 = deletew_1(&deletew_1_arg, clnt);         /* printf(\"\\nYour result is:%d, your string is:%s(%d)\\n\", *result_3, deletew_1_arg, strlen(deletew_1_arg)); */         if (result_3 == (int *) NULL)         clnt_perror(clnt, \"call failed\");         else         printf(\"%s deleted.\\n\", word);         break;     case 'l':        /* 查询 */         lookupw_1_arg = word;         result_4 = lookupw_1(&lookupw_1_arg, clnt);         /* printf(\"\\nYour result is:%d, your string is:%s(%d)\\n\", *result_4, lookupw_1_arg, strlen(lookupw_1_arg)); */         if (result_4 == (int *) NULL)         clnt_perror(clnt, \"call failed\");         else         if(*result_4 ==0) printf(\"%s found.\\n\", word);         else printf(\"%s not found.\\n\", word);         break;     case 'q':        /* 退出 */         printf(\"Program quits.\\n\");         exit(0);         break;     default:        /* 非法输入 */         printf(\"Command %c(%s) invalid.\\n\", cmd, word);         break;     }            /* end of switch */     }                /* end of while */ #ifndef    DEBUG     clnt_destroy(clnt); #endif                /* DEBUG */ } int main(int argc, char *argv[]) {     char *host;     if (argc < 2) {     printf(\"usage: %s server_host\\n\", argv[0]);     exit(1);     }     host = argv[1];     rdictprog_1(host);     exit(0); } 同时修改服务器端代码rdict_srv_func.c，修改后内容为： /*  * This is sample code generated by rpcgen.  * These are only templates and you can use them  * as a guideline for developing your own functions.  */ #include \"rdict.h\" char dict[DICTSIZ][MAXWORD + 1];    /* storage for a dictionary of words */ int nwords = 0;            /* number of words in the dictionary */ char init_bool = 0; int initw(void) {     if(init_bool) return 1;     nwords = 0;     init_bool = 1;     return 0; }                /* end of initw */ /* ------------------------------------------------------------------ * insertw -- insert a word in the dictionary * ------------------------------------------------------------------ */ int insertw(const char *word) {     strcpy(dict[nwords%DICTSIZ], word);     nwords++;     return (nwords); }                /* end of insertw */ /* ------------------------------------------------------------------ * deletew -- delete a word from the dictionary * ------------------------------------------------------------------ */ int deletew(const char *word) {     int i;     for (i = 0; i < nwords; i++) {     if (strcmp(word, dict[i]) == 0) {         nwords--;         strcpy(dict[i], dict[nwords]);         return (1);     }     }                /* end of for */     return (0); }                /* end of deletew */ /* ------------------------------------------------------------------ * lookupw -- look up a word in the dictionary * ------------------------------------------------------------------ */ int lookupw(const char *word) {     int i;     for (i = 0; i < nwords; i++) {     if (strcmp(word, dict[i]) == 0) {         return 0;     }     }                /* end of for */     return 1; }                /* end of lookupw */ int *initw_1_svc(void *argp, struct svc_req *rqstp) {     static int result;     /*      * insert server code here      */     result = initw();     return &result; } int *insertw_1_svc(char **argp, struct svc_req *rqstp) {     static int result;     /*      * insert server code here      */     result = insertw(*argp);     return &result; } int *deletew_1_svc(char **argp, struct svc_req *rqstp) {     static int result;     /*      * insert server code here      */     result = deletew(*argp);     return &result; } int *lookupw_1_svc(char **argp, struct svc_req *rqstp) {     static int result;     /*      * insert server code here      */     result = lookupw(*argp);     return &result; } 至此，程序做好了。输入一个make命令就可以生成test_server和test_client这两个可执行程序了。 在一台机器上运行./test_server程序，在另外的客户机上运行./test_client server_ip就可以了。这里server_ip是运行着test_server程序的主机的IP地址。","title":"我是这样学习Linux下C语言编程的-利用RPC快速实现分布式系统"},{"content":"编写C#多线程应用程序非常得容易，即使对于那些从没有编写C#多线程应用程序的初学者，只需遵循以下这些简单的步骤就可以实现目的。 定义名称空间 在。NET中，多线程功能是在System.Threading名称空间中定义的。因此，在使用任何线程类之前，必须定义 System.Threading名称空间。定义方法如下： 1.using System.Threading； 启动线程 System.threading名称空间中的Thread类代表一个线程对象，用这个类对象可以创建新的线程，删除、暂停和恢复线程。下面的代码使用Thread类创建一个新的线程，然后启动这个线程： 1.thread = new Thread（new ThreadStart（ WriteData ））；  2.thread.Start（）； 其中WriteData是这个线程要执行的一个函数，代码如下： 1.protected void WriteData（）  2.{  3.string str ；  4.for （ int i = 0； i<=10000； i++ ）  5.{  6.str = \"Secondary Thread\" + i.ToString（）；  7.Console.WriteLine（listView1.ListItems.Count， str， 0， new string[]{\"\"} ）；  8.Update（）；  9.}  10.} 杀死线程 Thread类的Abort方法用于永久地杀死一个线程。但是请注意，在调用Abort方法前一定要判断线程是否还激活，也就是判断thread.IsAlive的值： 1.if （ thread.IsAlive ）  2.{  3.thread.Abort（）；  4.} 暂停线程 Thread.Sleep方法用于将一个线程暂停一段时间，代码如下： 1.thread.Sleep（）； 设置线程的优先权 我们可以使用Thread类的ThreadPriority属性设置线程的优先权。线程优先权的取值范围是Normal、AboveNormal、BelowNormal、Highest或者Lowest.请看下面的设置代码： 1.thread.Priority = ThreadPriority.Highest； 延迟线程 Thread类的Suspend方法可以延迟一个线程。线程被延迟到调用Resume方法为止。 1.if （thread.ThreadState = ThreadState.Running ）  2.{  3.thread.Suspend（）；  4.} 恢复被延迟的线程 调用Resume方法可以恢复一个被延迟的线程。如果线程没有被延迟，Resume方法就是无效的。以上介绍编写C#多线程应用程序 1.if （thread.ThreadState = ThreadState.Suspended ）  2.{  3.thread.Resume（）；  4.} 引用通告地址: http://www.10is.cn/trackback.php?tbID=46&extra=4974aa  ","title":"c# thread 编程"},{"content":"最近经常有人在论坛，或群里询问，也想报一些java编程培训班，但是想问一下怎么样学习java最快！ 其实，编程的学习正好体现了一句老话：欲速则不达。 今天想给大家谈一下我的对java学习个人的一些见解，和学习的初衷。 前言 《站长》杂志方谈蔡文胜：一名站长最宝贵的品质应该是什么？ 回：热情和学习，有这两点才能做。热情不是冲动，要持续耐心做一个事情才能成功。学习不只是看书，问个专家就可以，要有学习方法和总结能力。 1 爱好。    这个是动力，如果你不爱Java,不爱计算机，而是喜爱游戏，娱乐或者其他的，你不适合做程序员。 如果你能在电脑前，一坐就是4-5个小时，你能为了学习而阅读英文的资料，那么你至少对编程是热爱的，具备了程序员的潜质。 2 学会取舍，用到什么就学什么    编程路上知识点甚多，你能掌握的永远是很少的一部分，新的技术不断出现，你难道能跟上？ 相反，编程思想确是相对稳定的。    对于新手，到书店找一本入门的书，用最快的速度读一遍，不要超过3天。 记住，你不需要理解，因为你理解不了，你只需要对那些东西有个大概的意识，噢噢噢，好像有那么几页有这个东西，能达到这个效果就非常不错了。千万不要一开始从第一章就仔细的看，那没用。    看完之后，找你最感兴趣的部分看，如果看不懂哪些内容，就去翻其他部分，然后马上返回。这部分看懂后，马上开机训练。    对于已经有经验的人，新知识你可以看看他的介绍，Release Note 或则一些评论性文章，然后看看自己手头有没有合适的工作可以用到，如果用不到，停止继续研究，如果能用到，则深入的看一遍他的文档，方法和前面一样，不能太细。看完后，如果能运用，则开机尝试，并仔细的阅读即将使用到的部分。 有网友问：怎么选入门的书？  我回答  书店，搜索，    Java 入门  你能看到一大堆，随便一本，看！记得不要买！！！  入门书差不多！不要太细的看。  换一本，加深印象  回家，电脑上实践，或者找电子版的书！  转天再去。 上 Java学习方法的一点个人见解-下 如果想更深入的学习 《JAVA语言程序设计》或《JAVA从入门到精通》这两本书开始学，等你编程有感觉的时候也可以回看一下。  《JAVA读书笔记》这本书，因为讲的代码很多，也很容易看懂，涉及到面也到位。是你学习技术巩固的好书，学完后就看看]《JAVA编程思想》这本书，找找一个自己写的代码跟书上的代码有什么不一样。如果要向java web方向发展也要吧看看 [ray]《Java web从入门到精通》学完再到《Struts2.0入门到精通》这样你差不多就把代码给学完了。 4 认识自己    不是每个程序员都能做到CTO,CEO的，金字塔的顶部的空间是很少的。由于家庭环境和个人性格不同，而高层领导的强项并不是在技术，而是在沟通和管理。也许你不服，也许你不甘心，但事实如此，只有付出更多的努力，才有可能往塔尖靠近，注意是有可能，不是一定。 5 学会总结    知识如果不用，就会被逐渐淡忘，当你需要的时候，如何能用最短的时间回复呢？那就是记笔记。 blog很好，写在笔记本上也行，写在一个word文件里面也好。总之，以你能很快的能找到为准。 6 身体是本钱    不多说了，大家都清楚。但会不自觉的违反这一条。呵呵！ 7 正确理解学习过程    初学时，就是死记硬背，你只需要知道应该怎么样就可以了。    有一定经验后，你就需要知道，还能怎么样？    熟悉后，你应该知道为什么要这样？如果不这样会怎么样    精通，这个东西适合吗？如何选择呢？   初学：动手    掌握：动手又动脑    熟悉：动脑又动手    精通：动脑 8  学会正确的查找问题答案的方法      一搜二问三看看  1.先搜搜，坚信 你绝对不是第一个遇到这个问题的人  先到 google/baidu 搜索 选好关键字  2.到论坛或者群里面发问  3.学会平时积累，到处看看，经常有意外收获。 n月前的难题可以轻松解决。  4.你的问题一定要有经过你思考了的。不要直接要全部代码和答案的那种。 至少我鄙视他们。没有人会花费那么多时间提供一个整套方案，就算付费的也得谈谈价钱，不合适的也不做。  比如：  我要做一个学生学籍管理系统，请提供思路和详细的解释，最好有源代码，100分送上  请问如何学好Java啊？我要学啥啊？  老师让明天交作业，哪位大哥给一份答案啊？  领导让做个库存管理软件 让我写需要 应该怎么写呢? 大家帮帮我啊？ 9 增加你的实战经验    你可以没做过，但一定要认真思考过    你可能没做过什么像样的项目，至少你自己这么认为。其实不然，你做过的的项目虽然看上去小，但你可以遵循这样的目标来完善 1.去目标用户那里调研，了解真实的需求,不要停留在想象程度  2.单机版改成多用户版  3.C/S版增加B/S版，反之亦然  4.使用正式的数据库，而不是Access  5.完善你的程序，直到有人愿意出钱买你的程序(1元也算)，因为这代表着他是一个真正能用的，能满足实际需求的程序了  6.去看看别人的项目代码，好多开源的项目。看看人家是怎么解决同样的问题的。 不是原创，只是想跟多朋友看到本文http://www.bcwhy.com/thread-14049-1-1.html Java学习方法的一点个人见解-完整版！","title":"Java学习方法的一点个人见解-完整版！"},{"content":"谈一谈网络编程学习经验 giantchen@gmail.com blog.csdn.net/Solstice PDF 版下载：https://github.com/downloads/chenshuo/documents/LearningNetworkProgramming.pdf 本文谈一谈我在学习网络编程方面的一些个人经验。“网络编程”这个术语的范围很广，本文指用Sockets API开发基于TCP/IP的网络应用程序，具体定义见“网络编程的各种任务角色”一节。 受限于本人的经历和经验，这篇文章的适应范围是： · x86-64 Linux服务端网络编程，直接或间接使用 Sockets API · 公司内网。不一定是局域网，但总体位于公司防火墙之内，环境可控 本文可能不适合： · PC客户端网络编程，程序运行在客户的PC上，环境多变且不可控 · Windows网络编程 · 面向公网的服务程序 · 高性能网络服务器 本文分两个部分： 1. 网络编程的一些胡思乱想，谈谈我对这一领域的认识 2. 几本必看的书，基本上还是W. Richard Stevents那几本 另外，本文没有特别说明时均暗指TCP协议，“连接”是“TCP连接”，“服务端”是“TCP服务端”。 网络编程的一些胡思乱想 以下胡乱列出我对网络编程的一些想法，前后无关联。 网络编程是什么？ 网络编程是什么？是熟练使用Sockets API吗？说实话，在实际项目里我只用过两次Sockets API，其他时候都是使用封装好的网络库。 第一次是2005年在学校做一个羽毛球赛场计分系统：我用C# 编写运行在PC机上的软件，负责比分的显示；再用C# 写了运行在PDA上的计分界面，记分员拿着PDA记录比分；这两部分程序通过 TCP协议相互通信。这其实是个简单的分布式系统，体育馆有不止一片场地，每个场地都有一名拿PDA的记分员，每个场地都有两台显示比分的PC机（显示器是42吋平板电视，放在场地的对角，这样两边看台的观众都能看到比分）。这两台PC机功能不完全一样，一台只负责显示当前比分，另一台还要负责与PDA通信，并更新数据库里的比分信息。此外，还有一台PC机负责周期性地从数据库读出全部7片场地的比分，显示在体育馆墙上的大屏幕上。这台PC上还运行着一个程序，负责生成比分数据的静态页面，通过FTP上传发布到某门户网站的体育频道。系统中还有一个录入赛程（参赛队，运动员，出场顺序等）数据库的程序，运行在数据库服务器上。算下来整个系统有十来个程序，运行在二十多台设备（PC和PDA）上，还要考虑可靠性。将来有机会把这个小系统仔细讲一讲，挺有意思的。 这是我第一次写实际项目中的网络程序，当时写下来的感觉是像写命令行与用户交互的程序：程序在命令行输出一句提示语，等待客户输入一句话，然后处理客户输入，再输出下一句提示语，如此循环。只不过这里的“客户”不是人，而是另一个程序。在建立好TCP连接之后，双方的程序都是read/write循环（为求简单，我用的是blocking读写），直到有一方断开连接。 第二次是2010年编写muduo网络库，我再次拿起了Sockets API，写了一个基于Reactor模式的C++ 网络库。写这个库的目的之一就是想让日常的网络编程从Sockets API的琐碎细节中解脱出来，让程序员专注于业务逻辑，把时间用在刀刃上。Muduo 网络库的示例代码包含了几十个网络程序，这些示例程序都没有直接使用Sockets API。 在此之外，无论是实习还是工作，虽然我写的程序都会通过TCP协议与其他程序打交道，但我没有直接使用过Sockets API。对于TCP网络编程，我认为核心是处理“三个半事件”，见《Muduo 网络编程示例之零：前言》中的“TCP 网络编程本质论”。程序员的主要工作是在事件处理函数中实现业务逻辑，而不是和Sockets API较劲。 这里还是没有说清楚“网络编程”是什么，请继续阅读后文“网络编程的各种任务角色”。 学习网络编程有用吗？ 以上说的是比较底层的网络编程，程序代码直接面对从TCP或UDP收到的数据以及构造数据包发出去。在实际工作中，另一种常见 的情况是通过各种 client library 来与服务端打交道，或者在现成的框架中填空来实现server，或者采用更上层的通信方式。比如用libmemcached与memcached打交道，使用libpq来与PostgreSQL 打交道，编写Servlet来响应http请求，使用某种RPC与其他进程通信，等等。这些情况都会发生网络通信，但不一定算作“网络编程”。如果你的工作是前面列举的这些，学习TCP/IP网络编程还有用吗？ 我认为还是有必要学一学，至少在troubleshooting 的时候有用。无论如何，这些library或framework都会调用底层的Sockets API来实现网络功能。当你的程序遇到一个线上问题，如果你熟悉Sockets API，那么从strace不难发现程序卡在哪里，尽管可能你没有直接调用这些Sockets API。另外，熟悉TCP/IP协议、会用tcpdump也大大有助于分析解决线上网络服务问题。 在什么平台上学习网络编程？ 对于服务端网络编程，我建议在Linux上学习。 如果在10年前，这个问题的答案或许是FreeBSD，因为FreeBSD根正苗红，在2000年那一次互联网浪潮中扮演了重要角色，是很多公司首选的免费服务器操作系统。2000年那会儿Linux还远未成熟，连epoll都还没有实现。（FreeBSD在2001年发布4.1版，加入了kqueue，从此C10k不是问题。） 10年后的今天，事情起了变化，Linux成为了市场份额最大的服务器操作系统(http://en.wikipedia.org/wiki/Usage_share_of_operating_systems)。在Linux这种大众系统上学网络编程，遇到什么问题会比较容易解决。因为用的人多，你遇到的问题别人多半也遇到过；同样因为用的人多，如果真的有什么内核bug，很快就会得到修复，至少有work around的办法。如果用别的系统，可能一个问题发到论坛上半个月都不会有人理。从内核源码的风格看，FreeBSD更干净整洁，注释到位，但是无奈它的市场份额远不如Linux，学习Linux是更好的技术投资。 可移植性重要吗？ 写网络程序要不要考虑移植性？这取决于项目需要，如果贵公司做的程序要卖给其他公司，而对方可能使用Windows、Linux、FreeBSD、Solaris、AIX、HP-UX等等操作系统，这时候考虑移植性。如果编写公司内部的服务器上用的网络程序，那么大可只关注一个平台，比如Linux。因为编写和维护可移植的网络程序的代价相当高，平台间的差异可能远比想象中大，即便是POSIX系统之间也有不小的差异（比如Linux没有SO_NOSIGPIPE选项），错误的返回码也大不一样。 我就不打算把muduo往Windows或其他操作系统移植。如果需要编写可移植的网络程序，我宁愿用libevent或者Java Netty这样现成的库，把脏活累活留给别人。 网络编程的各种任务角色 计算机网络是个 big topic，涉及很多人物和角色，既有开发人员，也有运维人员。比方说：公司内部两台机器之间 ping 不通，通常由网络运维人员解决，看看是布线有问题还是路由器设置不对；两台机器能ping通，但是程序连不上，经检查是本机防火墙设置有问题，通常由系统管理员解决；两台机器能连上，但是丢包很严重，发现是网卡或者交换机的网口故障，由硬件维修人员解决；两台机器的程序能连上，但是偶尔发过去的请求得不到响应，通常是程序bug，应该由开发人员解决。 本文主要关心开发人员这一角色。下面简单列出一些我能想到的跟网络打交道的编程任务，其中前三项是面向网络本身，后面几项是在计算机网络之上构建信息系统。 1. 开发网络设备，编写防火墙、交换机、路由器的固件 firmware 2. 开发或移植网卡的驱动 3. 移植或维护TCP/IP协议栈（特别是在嵌入式系统上） 4. 开发或维护标准的网络协议程序，HTTP、FTP、DNS、SMTP、POP3、NFS 5. 开发标准网络协议的“附加品”，比如HAProxy、squid、varnish等web load balancer 6. 开发标准或非标准网络服务的客户端库，比如ZooKeeper客户端库，memcached客户端库 7. 开发与公司业务直接相关的网络服务程序，比如即时聊天软件的后台服务器，网游服务器，金融交易系统，互联网企业用的分布式海量存储，微博发帖的内部广播通知，等等 8. 客户端程序中涉及网络的部分，比如邮件客户端中与 POP3、SMTP通信的部分，以及网游的客户端程序中与服务器通信的部分 本文所指的“网络编程”专指第7项，即在TCP/IP协议之上开发业务软件。 面向业务的网络编程的特点 跟开发通用的网络程序不同，开发面向公司业务的专用网络程序有其特点： · 业务逻辑比较复杂，而且时常变化 如果写一个HTTP服务器，在大致实现HTTP /1.1标准之后，程序的主体功能一般不会有太大的变化，程序员会把时间放在性能调优和bug修复上。而开发针对公司业务的专用程序时，功能说明书（spec）很可能不如HTTP/1.1标准那么细致明确。更重要的是，程序是快速演化的。以即时聊天工具的后台服务器为例，可能第一版只支持在线聊天；几个月之后发布第二版，支持离线消息；又过了几个月，第三版支持隐身聊天；随后，第四版支持上传头像；如此等等。这要求程序员能快速响应新的业务需求，公司才能保持竞争力。 · 不一定需要遵循公认的通信协议标准 比方说网游服务器就没什么协议标准，反正客户端和服务端都是本公司开发，如果发现目前的协议设计有问题，两边一起改了就是了。 · 程序结构没有定论 对于高并发大吞吐的标准网络服务，一般采用单线程事件驱动的方式开发，比如HAProxy、lighttpd等都是这个模式。但是对于专用的业务系统，其业务逻辑比较复杂，占用较多的CPU资源，这种单线程事件驱动方式不见得能发挥现在多核处理器的优势。这留给程序员比较大的自由发挥空间，做好了横扫千军，做烂了一败涂地。 · 性能评判的标准不同 如果开发httpd这样的通用服务，必然会和开源的Nginx、lighttpd等高性能服务器比较，程序员要投入相当的精力去优化程序，才能在市场上占有一席之地。而面向业务的专用网络程序不一定有开源的实现以供对比性能，程序员通常更加注重功能的稳定性与开发的便捷性。性能只要一代比一代强即可。 · 网络编程起到支撑作用，但不处于主导地位 程序员的主要工作是实现业务逻辑，而不只是实现网络通信协议。这要求程序员深入理解业务。程序的性能瓶颈不一定在网络上，瓶颈有可能是CPU、Disk IO、数据库等等，这时优化网络方面的代码并不能提高整体性能。只有对所在的领域有深入的了解，明白各种因素的权衡(trade-off)，才能做出一些有针对性的优化。 几个术语 互联网上的很多口水战是由对同一术语的不同理解引起的，比我写的《多线程服务器的适用场合》就曾经人被说是“挂羊头卖狗肉”，因为这篇文章中举的 master例子“根本就算不上是个网络服务器。因为它的瓶颈根本就跟网络无关。” · 网络服务器 “网络服务器”这个术语确实含义模糊，到底指硬件还是软件？到底是服务于网络本身的机器（交换机、路由器、防火墙、NAT），还是利用网络为其他人或程序提供服务的机器（打印服务器、文件服务器、邮件服务器）。每个人根据自己熟悉的领域，可能会有不同的解读。比方说或许有人认为只有支持高并发高吞吐的才算是网络服务器。 为了避免无谓的争执，我只用“网络服务程序”或者“网络应用程序”这种含义明确的术语。“开发网络服务程序”通常不会造成误解。 · 客户端？服务端？ 在TCP网络编程里边，客户端和服务端很容易区分，主动发起连接的是客户端，被动接受连接的是服务端。当然，这个“客户端”本身也可能是个后台服务程序，HTTP Proxy对HTTP Server来说就是个客户端。 · 客户端编程？服务端编程？ 但是“服务端编程”和“客户端编程”就不那么好区分。比如 Web crawler，它会主动发起大量连接，扮演的是HTTP客户端的角色，但似乎应该归入“服务端编程”。又比如写一个 HTTP proxy，它既会扮演服务端——被动接受 web browser 发起的连接，也会扮演客户端——主动向 HTTP server 发起连接，它究竟算服务端还是客户端？我猜大多数人会把它归入服务端编程。 那么究竟如何定义“服务端编程”？ 服务端编程需要处理大量并发连接？也许是，也许不是。比如云风在一篇介绍网游服务器的博客http://blog.codingnow.com/2006/04/iocp_kqueue_epoll.html中就谈到，网游中用到的“连接服务器”需要处理大量连接，而“逻辑服务器”只有一个外部连接。那么开发这种网游“逻辑服务器”算服务端编程还是客户端编程呢？ 我认为，“服务端网络编程”指的是编写没有用户界面的长期运行的网络程序，程序默默地运行在一台服务器上，通过网络与其他程序打交道，而不必和人打交道。与之对应的是客户端网络程序，要么是短时间运行，比如wget；要么是有用户界面（无论是字符界面还是图形界面）。本文主要谈服务端网络编程。 7x24重要吗？内存碎片可怕吗？ 一谈到服务端网络编程，有人立刻会提出7x24运行的要求。对于某些网络设备而言，这是合理的需求，比如交换机、路由器。对于开发商业系统，我认为要求程序7x24运行通常是系统设计上考虑不周。具体见《分布式系统的工程化开发方法》第20页起。重要的不是7x24，而是在程序不必做到7x24的情况下也能达到足够高的可用性。一个考虑周到的系统应该允许每个进程都能随时重启，这样才能在廉价的服务器硬件上做到高可用性。 既然不要求7x24，那么也不必害怕内存碎片，理由如下： · 64-bit系统的地址空间足够大，不会出现没有足够的连续空间这种情况。 · 现在的内存分配器（malloc及其第三方实现）今非昔比，除了memcached这种纯以内存为卖点的程序需要自己设计分配器之外，其他网络程序大可使用系统自带的malloc或者某个第三方实现。 · Linux Kernel也大量用到了动态内存分配。既然操作系统内核都不怕动态分配内存造成碎片，应用程序为什么要害怕？ · 内存碎片如何度量？有没有什么工具能为当前进程的内存碎片状况评个分？如果不能比较两种方案的内存碎片程度，谈何优化？ 有人为了避免内存碎片，不使用STL容器，也不敢new/delete，这算是premature optimization还是因噎废食呢？ 协议设计是网络编程的核心 对于专用的业务系统，协议设计是核心任务，决定了系统的开发难度与可靠性，但是这个领域还没有形成大家公认的设计流程。 系统中哪个程序发起连接，哪个程序接受连接？如果写标准的网络服务，那么这不是问题，按RFC来就行了。自己设计业务系统，有没有章法可循？以网游为例，到底是连接服务器主动连接逻辑服务器，还是逻辑服务器主动连接“连接服务器”？似乎没有定论，两种做法都行。一般可以按照“依赖->被依赖”的关系来设计发起连接的方向。 比新建连接难的是关闭连接。在传统的网络服务中（特别是短连接服务），不少是服务端主动关闭连接，比如daytime、HTTP/1.0。也有少部分是客户端主动关闭连接，通常是些长连接服务，比如 echo、chargen等。我们自己的业务系统该如何设计连接关闭协议呢？ 服务端主动关闭连接的缺点之一是会多占用服务器资源。服务端主动关闭连接之后会进入TIME_WAIT状态，在一段时间之内hold住一些内核资源。如果并发访问量很高，这会影响服务端的处理能力。这似乎暗示我们应该把协议设计为客户端主动关闭，让TIME_WAIT状态分散到多台客户机器上，化整为零。 这又有另外的问题：客户端赖着不走怎么办？会不会造成拒绝服务攻击？或许有一个二者结合的方案：客户端在收到响应之后就应该主动关闭，这样把 TIME_WAIT 留在客户端。服务端有一个定时器，如果客户端若干秒钟之内没有主动断开，就踢掉它。这样善意的客户端会把TIME_WAIT留给自己，buggy的客户端会把 TIME_WAIT留给服务端。或者干脆使用长连接协议，这样避免频繁创建销毁连接。 比连接的建立与断开更重要的是设计消息协议。消息格式很好办，XML、JSON、Protobuf都是很好的选择；难的是消息内容。一个消息应该包含哪些内容？多个程序相互通信如何避免race condition（见《分布式系统的工程化开发方法》p.16的例子）？系统的全局状态该如何跃迁？可惜这方面可供参考的例子不多，也没有太多通用的指导原则，我知道的只有30年前提出的end-to-end principle和happens-before relationship。只能从实践中慢慢积累了。 网络编程的三个层次 侯捷先生在《漫談程序員與編程》中讲到 STL 运用的三个档次：“會用STL，是一種檔次。對STL原理有所了解，又是一個檔次。追蹤過STL源碼，又是一個檔次。第三種檔次的人用起 STL 來，虎虎生風之勢絕非第一檔次的人能夠望其項背。” 我认为网络编程也可以分为三个层次： 1. 读过教程和文档 2. 熟悉本系统TCP/IP协议栈的脾气 3. 自己写过一个简单的TCP/IP stack 第一个层次是基本要求，读过《Unix网络编程》这样的编程教材，读过《TCP/IP详解》基本理解TCP/IP协议，读过本系统的manpage。这个层次可以编写一些基本的网络程序，完成常见的任务。但网络编程不是照猫画虎这么简单，若是按照manpage的功能描述就能编写产品级的网络程序，那人生就太幸福了。 第二个层次，熟悉本系统的TCP/IP协议栈参数设置与优化是开发高性能网络程序的必备条件。摸透协议栈的脾气还能解决工作中遇到的比较复杂的网络问题。拿Linux的TCP/IP协议栈来说： · 有可能出现自连接（见《学之者生，用之者死——ACE历史与简评》举的三个硬伤），程序应该有所准备。 · Linux的内核会有bug，比如某种TCP拥塞控制算法曾经出现TCP window clamping（窗口箝位）bug，导致吞吐量暴跌，可以选用其他拥塞控制算法来绕开(work around)这个问题。 这些阴暗角落在manpage里没有描述，要通过其他渠道了解。 编写可靠的网络程序的关键是熟悉各种场景下的error code（文件描述符用完了如何？本地ephemeral port暂时用完，不能发起新连接怎么办？服务端新建并发连接太快，backlog用完了，客户端connect会返回什么错误？），有的在manpage里有描述，有的要通过实践或阅读源码获得。 第三个层次，通过自己写一个简单的TCP/IP协议栈，能大大加深对TCP/IP的理解，更能明白TCP为什么要这么设计，有哪些因素制约，每一步操作的代价是什么，写起网络程序来更是成竹在胸。 其实实现TCP/IP只需要操作系统提供三个接口函数：一个函数，两个回调函数。分别是：send_packet()、on_receive_packet()、on_timer()。多年前有一篇文章《使用libnet与libpcap构造TCP/IP协议软件》介绍了在用户态实现TCP/IP的方法。lwIP也是很好的借鉴对象。 如果有时间，我打算自己写一个Mini/Tiny/Toy/Trivial/Yet-Another TCP/IP。我准备换一个思路，用TUN/TAP设备在用户态实现一个能与本机点对点通信的TCP/IP协议栈，这样那三个接口函数就表现为我最熟悉的文件读写。在用户态实现的好处是便于调试，协议栈做成静态库，与应用程序链接到一起（库的接口不必是标准的Sockets API）。做完这一版，还可以继续发挥，用FTDI的USB-SPI接口芯片连接ENC28J60适配器，做一个真正独立于操作系统的TCP/IP stack。如果只实现最基本的IP、ICMP Echo、TCP的话，代码应能控制在3000行以内；也可以实现UDP，如果应用程序需要用到DNS的话。 最主要的三个例子 我认为TCP网络编程有三个例子最值得学习研究，分别是echo、chat、proxy，都是长连接协议。 Echo的作用：熟悉服务端被动接受新连接、收发数据、被动处理连接断开。每个连接是独立服务的，连接之间没有关联。在消息内容方面Echo有一些变种：比如做成一问一答的方式，收到的请求和发送响应的内容不一样，这时候要考虑打包与拆包格式的设计，进一步还可以写简单的HTTP服务。 Chat的作用：连接之间的数据有交流，从a收到的数据要发给b。这样对连接管理提出的更高的要求：如何用一个程序同时处理多个连接？fork() per connection似乎是不行的。如何防止串话？b有可能随时断开连接，而新建立的连接c可能恰好复用了b的文件描述符，那么a会不会错误地把消息发给c？ Proxy的作用：连接的管理更加复杂：既要被动接受连接，也要主动发起连接，既要主动关闭连接，也要被动关闭连接。还要考虑两边速度不匹配，见《Muduo 网络编程示例之十：socks4a 代理服务器》。 这三个例子功能简单，突出了TCP网络编程中的重点问题，挨着做一遍基本就能达到层次一的要求。 TCP的可靠性有多高？ TCP是“面向连接的、可靠的、字节流传输协议”，这里的“可靠”究竟是什么意思？《Effective TCP/IP Programming》第9条说：Realize That TCP Is a Reliable Protocol, Not an Infallible Protocol，那么TCP在哪种情况下会出错？这里说的“出错”指的是收到的数据与发送的数据不一致，而不是数据不可达。 我在《一种自动反射消息类型的 Google Protobuf 网络传输方案》中设计了带check sum的消息格式，很多人表示不理解，认为是多余的。IP header里边有check sum，TCP header也有check sum，链路层以太网还有CRC32校验，那么为什么还需要在应用层做校验？什么情况下TCP传送的数据会出错？ IP header和TCP header的check sum是一种非常弱的16-bit check sum算法，把数据当成反码表示的16-bit integers，再加到一起。这种checksum算法能检出一些简单的错误，而对某些错误无能为力，由于是简单的加法，遇到“和”不变的情况就无法检查出错误（比如交换两个16-bit整数，加法满足交换律，结果不变）。以太网的CRC32比较强，但它只能保证同一个网段上的通信不会出错（两台机器的网线插到同一个交换机上，这时候以太网的CRC是有用的）。但是，如果两台机器之间经过了多级路由器呢？ 上图中Client向Server发了一个TCP segment，这个segment先被封装成一个IP packet，再被封装成ethernet frame，发送到路由器（图中消息a）。Router收到ethernet frame (b)，转发到另一个网段(c)，最后Server收到d，通知应用程序。Ethernet CRC能保证a和b相同，c和d相同；TCP header check sum的强度不足以保证收发payload的内容一样。另外，如果把Router换成NAT，那么NAT自己会构造c（替换掉源地址），这时候a和d的payload不能用tcp header checksum校验。 路由器可能出现硬件故障，比方说它的内存故障（或偶然错误）导致收发IP报文出现多bit的反转或双字节交换，这个反转如果发生在payload区，那么无法用链路层、网络层、传输层的check sum查出来，只能通过应用层的check sum来检测。这个现象在开发的时候不会遇到，因为开发用的几台机器很可能都连到同一个交换机，ethernet CRC能防止错误。开发和测试的时候数据量不大，错误很难发生。之后大规模部署到生产环境，网络环境复杂，这时候出个错就让人措手不及。有一篇论文《When the CRC and TCP checksum disagree》分析了这个问题。另外《The Limitations of the Ethernet CRC and TCP/IP checksums for error detection》(http://noahdavids.org/self_published/CRC_and_checksum.html)也值得一读。 这个情况真的会发生吗？会的，Amazon S3 在2008年7月就遇到过，单bit反转导致了一次严重线上事故，所以他们吸取教训加了 check sum。见http://status.aws.amazon.com/s3-20080720.html 另外一个例证：下载大文件的时候一般都会附上MD5，这除了有安全方面的考虑（防止篡改），也说明应用层应该自己设法校验数据的正确性。这是end-to-end principle的一个例证。 三本必看的书 谈到Unix编程和网络编程，W. Richard Stevens 是个绕不开的人物，他生前写了6本书，APUE、两卷UNP、三卷TCP/IP。有四本与网络编程直接相关。UNP第二卷其实跟网络编程关系不大，是APUE在多线程和进程间通信(IPC)方面的补充。很多人把TCP/IP一二三卷作为整体推荐，其实这三本书用处不同，应该区别对待。 这里谈到的几本书都没有超出孟岩在《TCP/IP 网络编程之四书五经》中的推荐，说明网络编程这一领域已经相对成熟稳定。 · 《TCP/IP Illustrated, Vol. 1: The Protocols》中文名《TCP/IP 详解》，以下简称 TCPv1。 TCPv1 是一本奇书。 这本书迄今至少被三百多篇学术论文引用过http://portal.acm.org/citation.cfm?id=161724。一本学术专著被论文引用算不上出奇，难得的是一本写给程序员看的技术书能被学术论文引用几百次，我不知道还有哪本技术书能做到这一点。 TCPv1 堪称 TCP/IP领域的圣经。作者 W. Richard Stevens 不是 TCP/IP 协议的发明人，他从使用者（程序员）的角度，以 tcpdump 为工具，对 TCP 协议抽丝剥茧娓娓道来（第17~24章），让人叹服。恐怕 TCP 协议的设计者也难以讲解得如此出色，至少不会像他这么耐心细致地画几百幅收发 package 的时序图。 TCP作为一个可靠的传输层协议，其核心有三点： 1. Positive acknowledgement with retransmission 2. Flow control using sliding window（包括Nagle 算法等） 3. Congestion control（包括slow start、congestion avoidance、fast retransmit等） 第一点已经足以满足“可靠性”要求（为什么？）；第二点是为了提高吞吐量，充分利用链路层带宽；第三点是防止过载造成丢包。换言之，第二点是避免发得太慢，第三点是避免发得太快，二者相互制约。从反馈控制的角度看，TCP像是一个自适应的节流阀，根据管道的拥堵情况自动调整阀门的流量。 TCP的 flow control 有一个问题，每个TCP connection是彼此独立的，保存有自己的状态变量；一个程序如果同时开启多个连接，或者操作系统中运行多个网络程序，这些连接似乎不知道他人的存在，缺少对网卡带宽的统筹安排。（或许现代的操作系统已经解决了这个问题？） TCPv1 唯一的不足是它出版太早了，1993 年至今网络技术发展了几代。链路层方面，当年主流的 10Mbit 网卡和集线器早已经被淘汰；100Mbit 以太网也没什么企业在用了，交换机(switch)也已经全面取代了集线器(hub)；服务器机房以 1Gbit 网络为主，有些场合甚至用上了 10Gbit 以太网。另外，无线网的普及也让TCP flow control面临新挑战；原来设计TCP的时候，人们认为丢包通常是拥塞造成的，这时应该放慢发送速度，减轻拥塞；而在无线网中，丢包可能是信号太弱造成的，这时反而应该快速重试，以保证性能。网络层方面变化不大，IPv6 雷声大雨点小。传输层方面，由于链路层带宽大增，TCP window scale option 被普遍使用，另外 TCP timestamps option 和 TCP selective ack option 也很常用。由于这些因素，在现在的 Linux 机器上运行 tcpdump 观察 TCP 协议，程序输出会与原书有些不同。 一个好消息：TCPv1将于今年10月（2011年）推出第二版，Amazon 的预定页面是：http://www.amazon.com/gp/product/0321336313，让我们拭目以待。 · 《Unix Network Programming, Vol. 1: Networking API》第二版或第三版（这两版的副标题稍有不同，第三版去掉了 XTI），以下统称 UNP，如果需要会以 UNP2e、UNP3e 细分。 UNP是Sockets API的权威指南，但是网络编程远不是使用那十几个Sockets API那么简单，作者 W. Richard Stevens深刻地认识到这一点，他在UNP2e的前言中写到：http://www.kohala.com/start/preface.unpv12e.html I have found when teaching network programming that about 80% of all network programming problems have nothing to do with network programming, per se. That is, the problems are not with the API functions such as accept and select, but the problems arise from a lack of understanding of the underlying network protocols. For example, I have found that once a student understands TCP's three-way handshake and four-packet connection termination, many network programming problems are immediately understood. 搞网络编程，一定要熟悉TCP/IP协议及其外在表现（比如打开和关闭Nagle算法对收发包的影响），不然出点意料之外的情况就摸不着头脑了。我不知道为什么UNP3e在前言中去掉了这段至关重要的话。 另外值得一提的是，UNP中文版翻译得相当好，译者杨继张先生是真懂网络编程的。 UNP很详细，面面俱到，UDP、TCP、IPv4、IPv6都讲到了。要说有什么缺点的话，就是太详细了，重点不够突出。我十分赞同孟岩说的 “（孟岩）我主张，在具备基础之后，学习任何新东西，都要抓住主线，突出重点。对于关键理论的学习，要集中精力，速战速决。而旁枝末节和非本质性的知识内容，完全可以留给实践去零敲碎打。 “原因是这样的，任何一个高级的知识内容，其中都只有一小部分是有思想创新、有重大影响的，而其它很多东西都是琐碎的、非本质的。因此，集中学习时必须把握住真正重要那部分，把其它东西留给实践。对于重点知识，只有集中学习其理论，才能确保体系性、连贯性、正确性，而对于那些旁枝末节，只有边干边学能够让你了解它们的真实价值是大是小，才能让你留下更生动的印象。如果你把精力用错了地方，比如用集中大块的时间来学习那些本来只需要查查手册就可以明白的小技巧，而对于真正重要的、思想性东西放在平时零敲碎打，那么肯定是事倍功半，甚至适得其反。 “因此我对于市面上绝大部分开发类图书都不满——它们基本上都是面向知识体系本身的，而不是面向读者的。总是把相关的所有知识细节都放在一堆，然后一堆一堆攒起来变成一本书。反映在内容上，就是毫无重点地平铺直叙，不分轻重地陈述细节，往往在第三章以前就用无聊的细节谋杀了读者的热情。为什么当年侯捷先生的《深入浅出MFC》和 Scott Meyers 的Effective C++ 能够成为经典？就在于这两本书抓住了各自领域中的主干，提纲挈领，纲举目张，一下子打通读者的任督二脉。可惜这样的书太少，就算是已故 Richard Stevens 和当今 Jeffrey Richter 的书，也只是在体系性和深入性上高人一头，并不是面向读者的书。” 什么是旁枝末节呢？拿以太网来说，CRC32如何计算就是“旁枝末节”。网络程序员要明白check sum的作用，知道为什么需要check sum，至于具体怎么算CRC就不需要程序员操心。这部分通常是由网卡硬件完成的，在发包的时候由硬件填充CRC，在收包的时候网卡自动丢弃CRC不合格的包。如果代码里边确实要用到CRC计算，调用通用的zlib就行，也不用自己实现。 UNP就像给了你一堆做菜的原料（各种Sockets 函数的用法），常用和不常用的都给了（Out-of-Band Data、Signal-Driven IO 等等），要靠读者自己设法取舍组合，做出一盘大菜来。在第一遍读的时候，我建议只读那些基本且重要的章节；另外那些次要的内容可略作了解，即便跳过不读也无妨。UNP是一本操作性很强的书，读这本这本书一定要上机练习。 另外，UNP举的两个例子（菜谱）太简单，daytime和echo一个是短连接协议，一个是长连接无格式协议，不足以覆盖基本的网络开发场景（比如 TCP封包与拆包、多连接之间交换数据）。我估计 W. Richard Stevens 原打算在 UNP第三卷中讲解一些实际的例子，只可惜他英年早逝，我等无福阅读。 UNP是一本偏重Unix传统的书，这本书写作的时候服务端还不需要处理成千上万的连接，也没有现在那么多网络攻击。书中重点介绍的以accept()+fork()来处理并发连接的方式在现在看来已经有点吃力，这本书的代码也没有特别防范恶意攻击。如果工作涉及这些方面，需要再进一步学习专门的知识（C10k问题，安全编程）。 TCPv1和UNP应该先看哪本？我不知道。我自己是先看的TCPv1，花了大约半学期时间，然后再读UNP2e和APUE。 · 《Effective TCP/IP Programming》 第三本书我犹豫了很久，不知道该推荐哪本，还有哪本书能与 W. Richard Stevens 的这两本比肩吗？W. Richard Stevens 为技术书籍的写作树立了难以逾越的标杆，他是一位伟大的技术作家。没能看到他写完 UNP 第三卷实在是人生的遗憾。 《Effective TCP/IP Programming》这本书属于专家经验总结类，初看时觉得收获很大，工作一段时间再看也能有新的发现。比如第6 条“TCP是一个字节流协议”，看过这一条就不会去研究所谓的“TCP粘包问题”。我手头这本电力社2001年的中文版翻译尚可，但是很狗血的是把参考文献去掉了，正文中引用的文章资料根本查不到名字。人邮2011年重新翻译出版的版本有参考文献。 其他值得一看的书 以下两本都不易读，需要相当的基础。 · 《TCP/IP Illustrated, Vol. 2: The Implementation》以下简称 TCPv2 1200页的大部头，详细讲解了4.4BSD的完整TCP/IP协议栈，注释了15,000行C源码。这本书啃下来不容易，如果时间不充裕，我认为没必要啃完，应用层的网络程序员选其中与工作相关的部分来阅读即可。 这本书第一作者是Gary Wright，从叙述风格和内容组织上是典型的“面向知识体系本身”，先讲mbuf，再从链路层一路往上、以太网、IP网络层、ICMP、IP多播、IGMP、IP路由、多播路由、Sockets系统调用、ARP等等。到了正文内容3/4的地方才开始讲TCP。面面俱到、主次不明。 对于主要使用TCP的程序员，我认为TCPv2一大半内容可以跳过不看，比如路由表、IGMP等等（开发网络设备的人可能更关心这些内容）。在工作中大可以把IP视为host-to-host的协议，把“IP packet如何送达对方机器”的细节视为黑盒子，这不会影响对TCP的理解和运用，因为网络协议是分层的。这样精简下来，需要看的只有三四百页，四五千行代码，大大减轻了负担。 这本书直接呈现高质量的工业级操作系统源码，读起来有难度，读懂它甚至要有“不求甚解的能力”。其一，代码只能看，不能上机运行，也不能改动试验。其二，与操作系统其他部分紧密关联。比如TCP/IP stack下接网卡驱动、软中断；上承inode转发来的系统调用操作；中间还要与平级的进程文件描述符管理子系统打交道；如果要把每一部分都弄清楚，把持不住就迷失主题了。其三，一些历史包袱让代码变复杂晦涩。比如BSD在80年代初需要在只有4M内存的VAX上实现TCP/IP，内存方面捉襟见肘，这才发明了mbuf结构，代码也增加了不少偶发复杂度（buffer不连续的处理）。 读这套TCP/IP书切忌胶柱鼓瑟，这套书以4.4BSD为底，其描述的行为（特别是与timer相关的行为）与现在的Linux TCP/IP有不小的出入，用书本上的知识直接套用到生产环境的Linux系统可能会造成不小的误解和困扰。（TCPv3不重要，可以成套买来收藏，不读亦可。） · 《Pattern-Oriented Software Architecture Volume 2: Patterns for Concurrent and Networked Objects》以下简称POSA2 这本书总结了开发并发网络服务程序的模式，是对UNP很好的补充。UNP中的代码往往把业务逻辑和Sockets API调用混在一起，代码固然短小精悍，但是这种编码风格恐怕不适合开发大型的网络程序。POSA2强调模块化，网络通信交给library/framework去做，程序员写代码只关注业务逻辑，这是非常重要的思想。阅读这本书对于深入理解常用的event-driven网络库（libevent、Java Netty、Java Mina、Perl POE、Python Twisted等等）也很有帮助，因为这些库都是依照这本书的思想编写的。 POSA2的代码是示意性的，思想很好，细节不佳。其C++ 代码没有充分考虑资源的自动化管理(RAII)，如果直接按照书中介绍的方式去实现网络库，那么会给使用者造成不小的负担与陷阱。换言之，照他说的做，而不是照他做的学。 不值一看的书 Douglas Comer 教授名气很大，著作等身，但是他写的网络方面的书不值一读，味同嚼蜡。网络编程与 TCP/IP 方面，有W. Richard Stevens 的书扛鼎；计算机网络原理方面，有Kurose的“自顶向下”和Peterson的“系统”打旗，没其他人什么事儿。顺便一提，Tanenbaum的操作系统教材是最好的之一（嗯，之二，因为他写了两本：“现代”和“设计与实现”），不过他的计算机网络和体系结构教材的地位比不上他的操作系统书的地位。体系结构方面，Patterson 和 Hennessy二人合作的两本书是最好的，近年来崭露头角的《深入理解计算机系统》也非常好；当然，侧重点不同。 谈一谈网络编程学习经验 giantchen@gmail.com blog.csdn.net/Solstice PDF 版下载：https://github.com/downloads/chenshuo/documents/LearningNetworkProgramming.pdf 本文谈一谈我在学习网络编程方面的一些个人经验。“网络编程”这个术语的范围很广，本文指用Sockets API开发基于TCP/IP的网络应用程序，具体定义见“网络编程的各种任务角色”一节。 受限于本人的经历和经验，这篇文章的适应范围是： · x86-64 Linux服务端网络编程，直接或间接使用 Sockets API · 公司内网。不一定是局域网，但总体位于公司防火墙之内，环境可控 本文可能不适合： · PC客户端网络编程，程序运行在客户的PC上，环境多变且不可控 · Windows网络编程 · 面向公网的服务程序 · 高性能网络服务器 本文分两个部分： 1. 网络编程的一些胡思乱想，谈谈我对这一领域的认识 2. 几本必看的书，基本上还是W. Richard Stevents那几本 另外，本文没有特别说明时均暗指TCP协议，“连接”是“TCP连接”，“服务端”是“TCP服务端”。 网络编程的一些胡思乱想 以下胡乱列出我对网络编程的一些想法，前后无关联。 网络编程是什么？ 网络编程是什么？是熟练使用Sockets API吗？说实话，在实际项目里我只用过两次Sockets API，其他时候都是使用封装好的网络库。 第一次是2005年在学校做一个羽毛球赛场计分系统：我用C# 编写运行在PC机上的软件，负责比分的显示；再用C# 写了运行在PDA上的计分界面，记分员拿着PDA记录比分；这两部分程序通过 TCP协议相互通信。这其实是个简单的分布式系统，体育馆有不止一片场地，每个场地都有一名拿PDA的记分员，每个场地都有两台显示比分的PC机（显示器是42吋平板电视，放在场地的对角，这样两边看台的观众都能看到比分）。这两台PC机功能不完全一样，一台只负责显示当前比分，另一台还要负责与PDA通信，并更新数据库里的比分信息。此外，还有一台PC机负责周期性地从数据库读出全部7片场地的比分，显示在体育馆墙上的大屏幕上。这台PC上还运行着一个程序，负责生成比分数据的静态页面，通过FTP上传发布到某门户网站的体育频道。系统中还有一个录入赛程（参赛队，运动员，出场顺序等）数据库的程序，运行在数据库服务器上。算下来整个系统有十来个程序，运行在二十多台设备（PC和PDA）上，还要考虑可靠性。将来有机会把这个小系统仔细讲一讲，挺有意思的。 这是我第一次写实际项目中的网络程序，当时写下来的感觉是像写命令行与用户交互的程序：程序在命令行输出一句提示语，等待客户输入一句话，然后处理客户输入，再输出下一句提示语，如此循环。只不过这里的“客户”不是人，而是另一个程序。在建立好TCP连接之后，双方的程序都是read/write循环（为求简单，我用的是blocking读写），直到有一方断开连接。 第二次是2010年编写muduo网络库，我再次拿起了Sockets API，写了一个基于Reactor模式的C++ 网络库。写这个库的目的之一就是想让日常的网络编程从Sockets API的琐碎细节中解脱出来，让程序员专注于业务逻辑，把时间用在刀刃上。Muduo 网络库的示例代码包含了几十个网络程序，这些示例程序都没有直接使用Sockets API。 在此之外，无论是实习还是工作，虽然我写的程序都会通过TCP协议与其他程序打交道，但我没有直接使用过Sockets API。对于TCP网络编程，我认为核心是处理“三个半事件”，见《Muduo 网络编程示例之零：前言》中的“TCP 网络编程本质论”。程序员的主要工作是在事件处理函数中实现业务逻辑，而不是和Sockets API较劲。 这里还是没有说清楚“网络编程”是什么，请继续阅读后文“网络编程的各种任务角色”。 学习网络编程有用吗？ 以上说的是比较底层的网络编程，程序代码直接面对从TCP或UDP收到的数据以及构造数据包发出去。在实际工作中，另一种常见 的情况是通过各种 client library 来与服务端打交道，或者在现成的框架中填空来实现server，或者采用更上层的通信方式。比如用libmemcached与memcached打交道，使用libpq来与PostgreSQL 打交道，编写Servlet来响应http请求，使用某种RPC与其他进程通信，等等。这些情况都会发生网络通信，但不一定算作“网络编程”。如果你的工作是前面列举的这些，学习TCP/IP网络编程还有用吗？ 我认为还是有必要学一学，至少在troubleshooting 的时候有用。无论如何，这些library或framework都会调用底层的Sockets API来实现网络功能。当你的程序遇到一个线上问题，如果你熟悉Sockets API，那么从strace不难发现程序卡在哪里，尽管可能你没有直接调用这些Sockets API。另外，熟悉TCP/IP协议、会用tcpdump也大大有助于分析解决线上网络服务问题。 在什么平台上学习网络编程？ 对于服务端网络编程，我建议在Linux上学习。 如果在10年前，这个问题的答案或许是FreeBSD，因为FreeBSD根正苗红，在2000年那一次互联网浪潮中扮演了重要角色，是很多公司首选的免费服务器操作系统。2000年那会儿Linux还远未成熟，连epoll都还没有实现。（FreeBSD在2001年发布4.1版，加入了kqueue，从此C10k不是问题。） 10年后的今天，事情起了变化，Linux成为了市场份额最大的服务器操作系统(http://en.wikipedia.org/wiki/Usage_share_of_operating_systems)。在Linux这种大众系统上学网络编程，遇到什么问题会比较容易解决。因为用的人多，你遇到的问题别人多半也遇到过；同样因为用的人多，如果真的有什么内核bug，很快就会得到修复，至少有work around的办法。如果用别的系统，可能一个问题发到论坛上半个月都不会有人理。从内核源码的风格看，FreeBSD更干净整洁，注释到位，但是无奈它的市场份额远不如Linux，学习Linux是更好的技术投资。 可移植性重要吗？ 写网络程序要不要考虑移植性？这取决于项目需要，如果贵公司做的程序要卖给其他公司，而对方可能使用Windows、Linux、FreeBSD、Solaris、AIX、HP-UX等等操作系统，这时候考虑移植性。如果编写公司内部的服务器上用的网络程序，那么大可只关注一个平台，比如Linux。因为编写和维护可移植的网络程序的代价相当高，平台间的差异可能远比想象中大，即便是POSIX系统之间也有不小的差异（比如Linux没有SO_NOSIGPIPE选项），错误的返回码也大不一样。 我就不打算把muduo往Windows或其他操作系统移植。如果需要编写可移植的网络程序，我宁愿用libevent或者Java Netty这样现成的库，把脏活累活留给别人。 网络编程的各种任务角色 计算机网络是个 big topic，涉及很多人物和角色，既有开发人员，也有运维人员。比方说：公司内部两台机器之间 ping 不通，通常由网络运维人员解决，看看是布线有问题还是路由器设置不对；两台机器能ping通，但是程序连不上，经检查是本机防火墙设置有问题，通常由系统管理员解决；两台机器能连上，但是丢包很严重，发现是网卡或者交换机的网口故障，由硬件维修人员解决；两台机器的程序能连上，但是偶尔发过去的请求得不到响应，通常是程序bug，应该由开发人员解决。 本文主要关心开发人员这一角色。下面简单列出一些我能想到的跟网络打交道的编程任务，其中前三项是面向网络本身，后面几项是在计算机网络之上构建信息系统。 1. 开发网络设备，编写防火墙、交换机、路由器的固件 firmware 2. 开发或移植网卡的驱动 3. 移植或维护TCP/IP协议栈（特别是在嵌入式系统上） 4. 开发或维护标准的网络协议程序，HTTP、FTP、DNS、SMTP、POP3、NFS 5. 开发标准网络协议的“附加品”，比如HAProxy、squid、varnish等web load balancer 6. 开发标准或非标准网络服务的客户端库，比如ZooKeeper客户端库，memcached客户端库 7. 开发与公司业务直接相关的网络服务程序，比如即时聊天软件的后台服务器，网游服务器，金融交易系统，互联网企业用的分布式海量存储，微博发帖的内部广播通知，等等 8. 客户端程序中涉及网络的部分，比如邮件客户端中与 POP3、SMTP通信的部分，以及网游的客户端程序中与服务器通信的部分 本文所指的“网络编程”专指第7项，即在TCP/IP协议之上开发业务软件。 面向业务的网络编程的特点 跟开发通用的网络程序不同，开发面向公司业务的专用网络程序有其特点： · 业务逻辑比较复杂，而且时常变化 如果写一个HTTP服务器，在大致实现HTTP /1.1标准之后，程序的主体功能一般不会有太大的变化，程序员会把时间放在性能调优和bug修复上。而开发针对公司业务的专用程序时，功能说明书（spec）很可能不如HTTP/1.1标准那么细致明确。更重要的是，程序是快速演化的。以即时聊天工具的后台服务器为例，可能第一版只支持在线聊天；几个月之后发布第二版，支持离线消息；又过了几个月，第三版支持隐身聊天；随后，第四版支持上传头像；如此等等。这要求程序员能快速响应新的业务需求，公司才能保持竞争力。 · 不一定需要遵循公认的通信协议标准 比方说网游服务器就没什么协议标准，反正客户端和服务端都是本公司开发，如果发现目前的协议设计有问题，两边一起改了就是了。 · 程序结构没有定论 对于高并发大吞吐的标准网络服务，一般采用单线程事件驱动的方式开发，比如HAProxy、lighttpd等都是这个模式。但是对于专用的业务系统，其业务逻辑比较复杂，占用较多的CPU资源，这种单线程事件驱动方式不见得能发挥现在多核处理器的优势。这留给程序员比较大的自由发挥空间，做好了横扫千军，做烂了一败涂地。 · 性能评判的标准不同 如果开发httpd这样的通用服务，必然会和开源的Nginx、lighttpd等高性能服务器比较，程序员要投入相当的精力去优化程序，才能在市场上占有一席之地。而面向业务的专用网络程序不一定有开源的实现以供对比性能，程序员通常更加注重功能的稳定性与开发的便捷性。性能只要一代比一代强即可。 · 网络编程起到支撑作用，但不处于主导地位 程序员的主要工作是实现业务逻辑，而不只是实现网络通信协议。这要求程序员深入理解业务。程序的性能瓶颈不一定在网络上，瓶颈有可能是CPU、Disk IO、数据库等等，这时优化网络方面的代码并不能提高整体性能。只有对所在的领域有深入的了解，明白各种因素的权衡(trade-off)，才能做出一些有针对性的优化。 几个术语 互联网上的很多口水战是由对同一术语的不同理解引起的，比我写的《多线程服务器的适用场合》就曾经人被说是“挂羊头卖狗肉”，因为这篇文章中举的 master例子“根本就算不上是个网络服务器。因为它的瓶颈根本就跟网络无关。” · 网络服务器 “网络服务器”这个术语确实含义模糊，到底指硬件还是软件？到底是服务于网络本身的机器（交换机、路由器、防火墙、NAT），还是利用网络为其他人或程序提供服务的机器（打印服务器、文件服务器、邮件服务器）。每个人根据自己熟悉的领域，可能会有不同的解读。比方说或许有人认为只有支持高并发高吞吐的才算是网络服务器。 为了避免无谓的争执，我只用“网络服务程序”或者“网络应用程序”这种含义明确的术语。“开发网络服务程序”通常不会造成误解。 · 客户端？服务端？ 在TCP网络编程里边，客户端和服务端很容易区分，主动发起连接的是客户端，被动接受连接的是服务端。当然，这个“客户端”本身也可能是个后台服务程序，HTTP Proxy对HTTP Server来说就是个客户端。 · 客户端编程？服务端编程？ 但是“服务端编程”和“客户端编程”就不那么好区分。比如 Web crawler，它会主动发起大量连接，扮演的是HTTP客户端的角色，但似乎应该归入“服务端编程”。又比如写一个 HTTP proxy，它既会扮演服务端——被动接受 web browser 发起的连接，也会扮演客户端——主动向 HTTP server 发起连接，它究竟算服务端还是客户端？我猜大多数人会把它归入服务端编程。 那么究竟如何定义“服务端编程”？ 服务端编程需要处理大量并发连接？也许是，也许不是。比如云风在一篇介绍网游服务器的博客http://blog.codingnow.com/2006/04/iocp_kqueue_epoll.html中就谈到，网游中用到的“连接服务器”需要处理大量连接，而“逻辑服务器”只有一个外部连接。那么开发这种网游“逻辑服务器”算服务端编程还是客户端编程呢？ 我认为，“服务端网络编程”指的是编写没有用户界面的长期运行的网络程序，程序默默地运行在一台服务器上，通过网络与其他程序打交道，而不必和人打交道。与之对应的是客户端网络程序，要么是短时间运行，比如wget；要么是有用户界面（无论是字符界面还是图形界面）。本文主要谈服务端网络编程。 7x24重要吗？内存碎片可怕吗？ 一谈到服务端网络编程，有人立刻会提出7x24运行的要求。对于某些网络设备而言，这是合理的需求，比如交换机、路由器。对于开发商业系统，我认为要求程序7x24运行通常是系统设计上考虑不周。具体见《分布式系统的工程化开发方法》第20页起。重要的不是7x24，而是在程序不必做到7x24的情况下也能达到足够高的可用性。一个考虑周到的系统应该允许每个进程都能随时重启，这样才能在廉价的服务器硬件上做到高可用性。 既然不要求7x24，那么也不必害怕内存碎片，理由如下： · 64-bit系统的地址空间足够大，不会出现没有足够的连续空间这种情况。 · 现在的内存分配器（malloc及其第三方实现）今非昔比，除了memcached这种纯以内存为卖点的程序需要自己设计分配器之外，其他网络程序大可使用系统自带的malloc或者某个第三方实现。 · Linux Kernel也大量用到了动态内存分配。既然操作系统内核都不怕动态分配内存造成碎片，应用程序为什么要害怕？ · 内存碎片如何度量？有没有什么工具能为当前进程的内存碎片状况评个分？如果不能比较两种方案的内存碎片程度，谈何优化？ 有人为了避免内存碎片，不使用STL容器，也不敢new/delete，这算是premature optimization还是因噎废食呢？ 协议设计是网络编程的核心 对于专用的业务系统，协议设计是核心任务，决定了系统的开发难度与可靠性，但是这个领域还没有形成大家公认的设计流程。 系统中哪个程序发起连接，哪个程序接受连接？如果写标准的网络服务，那么这不是问题，按RFC来就行了。自己设计业务系统，有没有章法可循？以网游为例，到底是连接服务器主动连接逻辑服务器，还是逻辑服务器主动连接“连接服务器”？似乎没有定论，两种做法都行。一般可以按照“依赖->被依赖”的关系来设计发起连接的方向。 比新建连接难的是关闭连接。在传统的网络服务中（特别是短连接服务），不少是服务端主动关闭连接，比如daytime、HTTP/1.0。也有少部分是客户端主动关闭连接，通常是些长连接服务，比如 echo、chargen等。我们自己的业务系统该如何设计连接关闭协议呢？ 服务端主动关闭连接的缺点之一是会多占用服务器资源。服务端主动关闭连接之后会进入TIME_WAIT状态，在一段时间之内hold住一些内核资源。如果并发访问量很高，这会影响服务端的处理能力。这似乎暗示我们应该把协议设计为客户端主动关闭，让TIME_WAIT状态分散到多台客户机器上，化整为零。 这又有另外的问题：客户端赖着不走怎么办？会不会造成拒绝服务攻击？或许有一个二者结合的方案：客户端在收到响应之后就应该主动关闭，这样把 TIME_WAIT 留在客户端。服务端有一个定时器，如果客户端若干秒钟之内没有主动断开，就踢掉它。这样善意的客户端会把TIME_WAIT留给自己，buggy的客户端会把 TIME_WAIT留给服务端。或者干脆使用长连接协议，这样避免频繁创建销毁连接。 比连接的建立与断开更重要的是设计消息协议。消息格式很好办，XML、JSON、Protobuf都是很好的选择；难的是消息内容。一个消息应该包含哪些内容？多个程序相互通信如何避免race condition（见《分布式系统的工程化开发方法》p.16的例子）？系统的全局状态该如何跃迁？可惜这方面可供参考的例子不多，也没有太多通用的指导原则，我知道的只有30年前提出的end-to-end principle和happens-before relationship。只能从实践中慢慢积累了。 网络编程的三个层次 侯捷先生在《漫談程序員與編程》中讲到 STL 运用的三个档次：“會用STL，是一種檔次。對STL原理有所了解，又是一個檔次。追蹤過STL源碼，又是一個檔次。第三種檔次的人用起 STL 來，虎虎生風之勢絕非第一檔次的人能夠望其項背。” 我认为网络编程也可以分为三个层次： 1. 读过教程和文档 2. 熟悉本系统TCP/IP协议栈的脾气 3. 自己写过一个简单的TCP/IP stack 第一个层次是基本要求，读过《Unix网络编程》这样的编程教材，读过《TCP/IP详解》基本理解TCP/IP协议，读过本系统的manpage。这个层次可以编写一些基本的网络程序，完成常见的任务。但网络编程不是照猫画虎这么简单，若是按照manpage的功能描述就能编写产品级的网络程序，那人生就太幸福了。 第二个层次，熟悉本系统的TCP/IP协议栈参数设置与优化是开发高性能网络程序的必备条件。摸透协议栈的脾气还能解决工作中遇到的比较复杂的网络问题。拿Linux的TCP/IP协议栈来说： · 有可能出现自连接（见《学之者生，用之者死——ACE历史与简评》举的三个硬伤），程序应该有所准备。 · Linux的内核会有bug，比如某种TCP拥塞控制算法曾经出现TCP window clamping（窗口箝位）bug，导致吞吐量暴跌，可以选用其他拥塞控制算法来绕开(work around)这个问题。 这些阴暗角落在manpage里没有描述，要通过其他渠道了解。 编写可靠的网络程序的关键是熟悉各种场景下的error code（文件描述符用完了如何？本地ephemeral port暂时用完，不能发起新连接怎么办？服务端新建并发连接太快，backlog用完了，客户端connect会返回什么错误？），有的在manpage里有描述，有的要通过实践或阅读源码获得。 第三个层次，通过自己写一个简单的TCP/IP协议栈，能大大加深对TCP/IP的理解，更能明白TCP为什么要这么设计，有哪些因素制约，每一步操作的代价是什么，写起网络程序来更是成竹在胸。 其实实现TCP/IP只需要操作系统提供三个接口函数：一个函数，两个回调函数。分别是：send_packet()、on_receive_packet()、on_timer()。多年前有一篇文章《使用libnet与libpcap构造TCP/IP协议软件》介绍了在用户态实现TCP/IP的方法。lwIP也是很好的借鉴对象。 如果有时间，我打算自己写一个Mini/Tiny/Toy/Trivial/Yet-Another TCP/IP。我准备换一个思路，用TUN/TAP设备在用户态实现一个能与本机点对点通信的TCP/IP协议栈，这样那三个接口函数就表现为我最熟悉的文件读写。在用户态实现的好处是便于调试，协议栈做成静态库，与应用程序链接到一起（库的接口不必是标准的Sockets API）。做完这一版，还可以继续发挥，用FTDI的USB-SPI接口芯片连接ENC28J60适配器，做一个真正独立于操作系统的TCP/IP stack。如果只实现最基本的IP、ICMP Echo、TCP的话，代码应能控制在3000行以内；也可以实现UDP，如果应用程序需要用到DNS的话。 最主要的三个例子 我认为TCP网络编程有三个例子最值得学习研究，分别是echo、chat、proxy，都是长连接协议。 Echo的作用：熟悉服务端被动接受新连接、收发数据、被动处理连接断开。每个连接是独立服务的，连接之间没有关联。在消息内容方面Echo有一些变种：比如做成一问一答的方式，收到的请求和发送响应的内容不一样，这时候要考虑打包与拆包格式的设计，进一步还可以写简单的HTTP服务。 Chat的作用：连接之间的数据有交流，从a收到的数据要发给b。这样对连接管理提出的更高的要求：如何用一个程序同时处理多个连接？fork() per connection似乎是不行的。如何防止串话？b有可能随时断开连接，而新建立的连接c可能恰好复用了b的文件描述符，那么a会不会错误地把消息发给c？ Proxy的作用：连接的管理更加复杂：既要被动接受连接，也要主动发起连接，既要主动关闭连接，也要被动关闭连接。还要考虑两边速度不匹配，见《Muduo 网络编程示例之十：socks4a 代理服务器》。 这三个例子功能简单，突出了TCP网络编程中的重点问题，挨着做一遍基本就能达到层次一的要求。 TCP的可靠性有多高？ TCP是“面向连接的、可靠的、字节流传输协议”，这里的“可靠”究竟是什么意思？《Effective TCP/IP Programming》第9条说：Realize That TCP Is a Reliable Protocol, Not an Infallible Protocol，那么TCP在哪种情况下会出错？这里说的“出错”指的是收到的数据与发送的数据不一致，而不是数据不可达。 我在《一种自动反射消息类型的 Google Protobuf 网络传输方案》中设计了带check sum的消息格式，很多人表示不理解，认为是多余的。IP header里边有check sum，TCP header也有check sum，链路层以太网还有CRC32校验，那么为什么还需要在应用层做校验？什么情况下TCP传送的数据会出错？ IP header和TCP header的check sum是一种非常弱的16-bit check sum算法，把数据当成反码表示的16-bit integers，再加到一起。这种checksum算法能检出一些简单的错误，而对某些错误无能为力，由于是简单的加法，遇到“和”不变的情况就无法检查出错误（比如交换两个16-bit整数，加法满足交换律，结果不变）。以太网的CRC32比较强，但它只能保证同一个网段上的通信不会出错（两台机器的网线插到同一个交换机上，这时候以太网的CRC是有用的）。但是，如果两台机器之间经过了多级路由器呢？ 上图中Client向Server发了一个TCP segment，这个segment先被封装成一个IP packet，再被封装成ethernet frame，发送到路由器（图中消息a）。Router收到ethernet frame (b)，转发到另一个网段(c)，最后Server收到d，通知应用程序。Ethernet CRC能保证a和b相同，c和d相同；TCP header check sum的强度不足以保证收发payload的内容一样。另外，如果把Router换成NAT，那么NAT自己会构造c（替换掉源地址），这时候a和d的payload不能用tcp header checksum校验。 路由器可能出现硬件故障，比方说它的内存故障（或偶然错误）导致收发IP报文出现多bit的反转或双字节交换，这个反转如果发生在payload区，那么无法用链路层、网络层、传输层的check sum查出来，只能通过应用层的check sum来检测。这个现象在开发的时候不会遇到，因为开发用的几台机器很可能都连到同一个交换机，ethernet CRC能防止错误。开发和测试的时候数据量不大，错误很难发生。之后大规模部署到生产环境，网络环境复杂，这时候出个错就让人措手不及。有一篇论文《When the CRC and TCP checksum disagree》分析了这个问题。另外《The Limitations of the Ethernet CRC and TCP/IP checksums for error detection》(http://noahdavids.org/self_published/CRC_and_checksum.html)也值得一读。 这个情况真的会发生吗？会的，Amazon S3 在2008年7月就遇到过，单bit反转导致了一次严重线上事故，所以他们吸取教训加了 check sum。见http://status.aws.amazon.com/s3-20080720.html 另外一个例证：下载大文件的时候一般都会附上MD5，这除了有安全方面的考虑（防止篡改），也说明应用层应该自己设法校验数据的正确性。这是end-to-end principle的一个例证。 三本必看的书 谈到Unix编程和网络编程，W. Richard Stevens 是个绕不开的人物，他生前写了6本书，APUE、两卷UNP、三卷TCP/IP。有四本与网络编程直接相关。UNP第二卷其实跟网络编程关系不大，是APUE在多线程和进程间通信(IPC)方面的补充。很多人把TCP/IP一二三卷作为整体推荐，其实这三本书用处不同，应该区别对待。 这里谈到的几本书都没有超出孟岩在《TCP/IP 网络编程之四书五经》中的推荐，说明网络编程这一领域已经相对成熟稳定。 · 《TCP/IP Illustrated, Vol. 1: The Protocols》中文名《TCP/IP 详解》，以下简称 TCPv1。 TCPv1 是一本奇书。 这本书迄今至少被三百多篇学术论文引用过http://portal.acm.org/citation.cfm?id=161724。一本学术专著被论文引用算不上出奇，难得的是一本写给程序员看的技术书能被学术论文引用几百次，我不知道还有哪本技术书能做到这一点。 TCPv1 堪称 TCP/IP领域的圣经。作者 W. Richard Stevens 不是 TCP/IP 协议的发明人，他从使用者（程序员）的角度，以 tcpdump 为工具，对 TCP 协议抽丝剥茧娓娓道来（第17~24章），让人叹服。恐怕 TCP 协议的设计者也难以讲解得如此出色，至少不会像他这么耐心细致地画几百幅收发 package 的时序图。 TCP作为一个可靠的传输层协议，其核心有三点： 1. Positive acknowledgement with retransmission 2. Flow control using sliding window（包括Nagle 算法等） 3. Congestion control（包括slow start、congestion avoidance、fast retransmit等） 第一点已经足以满足“可靠性”要求（为什么？）；第二点是为了提高吞吐量，充分利用链路层带宽；第三点是防止过载造成丢包。换言之，第二点是避免发得太慢，第三点是避免发得太快，二者相互制约。从反馈控制的角度看，TCP像是一个自适应的节流阀，根据管道的拥堵情况自动调整阀门的流量。 TCP的 flow control 有一个问题，每个TCP connection是彼此独立的，保存有自己的状态变量；一个程序如果同时开启多个连接，或者操作系统中运行多个网络程序，这些连接似乎不知道他人的存在，缺少对网卡带宽的统筹安排。（或许现代的操作系统已经解决了这个问题？） TCPv1 唯一的不足是它出版太早了，1993 年至今网络技术发展了几代。链路层方面，当年主流的 10Mbit 网卡和集线器早已经被淘汰；100Mbit 以太网也没什么企业在用了，交换机(switch)也已经全面取代了集线器(hub)；服务器机房以 1Gbit 网络为主，有些场合甚至用上了 10Gbit 以太网。另外，无线网的普及也让TCP flow control面临新挑战；原来设计TCP的时候，人们认为丢包通常是拥塞造成的，这时应该放慢发送速度，减轻拥塞；而在无线网中，丢包可能是信号太弱造成的，这时反而应该快速重试，以保证性能。网络层方面变化不大，IPv6 雷声大雨点小。传输层方面，由于链路层带宽大增，TCP window scale option 被普遍使用，另外 TCP timestamps option 和 TCP selective ack option 也很常用。由于这些因素，在现在的 Linux 机器上运行 tcpdump 观察 TCP 协议，程序输出会与原书有些不同。 一个好消息：TCPv1将于今年10月（2011年）推出第二版，Amazon 的预定页面是：http://www.amazon.com/gp/product/0321336313，让我们拭目以待。 · 《Unix Network Programming, Vol. 1: Networking API》第二版或第三版（这两版的副标题稍有不同，第三版去掉了 XTI），以下统称 UNP，如果需要会以 UNP2e、UNP3e 细分。 UNP是Sockets API的权威指南，但是网络编程远不是使用那十几个Sockets API那么简单，作者 W. Richard Stevens深刻地认识到这一点，他在UNP2e的前言中写到：http://www.kohala.com/start/preface.unpv12e.html I have found when teaching network programming that about 80% of all network programming problems have nothing to do with network programming, per se. That is, the problems are not with the API functions such as accept and select, but the problems arise from a lack of understanding of the underlying network protocols. For example, I have found that once a student understands TCP's three-way handshake and four-packet connection termination, many network programming problems are immediately understood. 搞网络编程，一定要熟悉TCP/IP协议及其外在表现（比如打开和关闭Nagle算法对收发包的影响），不然出点意料之外的情况就摸不着头脑了。我不知道为什么UNP3e在前言中去掉了这段至关重要的话。 另外值得一提的是，UNP中文版翻译得相当好，译者杨继张先生是真懂网络编程的。 UNP很详细，面面俱到，UDP、TCP、IPv4、IPv6都讲到了。要说有什么缺点的话，就是太详细了，重点不够突出。我十分赞同孟岩说的 “（孟岩）我主张，在具备基础之后，学习任何新东西，都要抓住主线，突出重点。对于关键理论的学习，要集中精力，速战速决。而旁枝末节和非本质性的知识内容，完全可以留给实践去零敲碎打。 “原因是这样的，任何一个高级的知识内容，其中都只有一小部分是有思想创新、有重大影响的，而其它很多东西都是琐碎的、非本质的。因此，集中学习时必须把握住真正重要那部分，把其它东西留给实践。对于重点知识，只有集中学习其理论，才能确保体系性、连贯性、正确性，而对于那些旁枝末节，只有边干边学能够让你了解它们的真实价值是大是小，才能让你留下更生动的印象。如果你把精力用错了地方，比如用集中大块的时间来学习那些本来只需要查查手册就可以明白的小技巧，而对于真正重要的、思想性东西放在平时零敲碎打，那么肯定是事倍功半，甚至适得其反。 “因此我对于市面上绝大部分开发类图书都不满——它们基本上都是面向知识体系本身的，而不是面向读者的。总是把相关的所有知识细节都放在一堆，然后一堆一堆攒起来变成一本书。反映在内容上，就是毫无重点地平铺直叙，不分轻重地陈述细节，往往在第三章以前就用无聊的细节谋杀了读者的热情。为什么当年侯捷先生的《深入浅出MFC》和 Scott Meyers 的Effective C++ 能够成为经典？就在于这两本书抓住了各自领域中的主干，提纲挈领，纲举目张，一下子打通读者的任督二脉。可惜这样的书太少，就算是已故 Richard Stevens 和当今 Jeffrey Richter 的书，也只是在体系性和深入性上高人一头，并不是面向读者的书。” 什么是旁枝末节呢？拿以太网来说，CRC32如何计算就是“旁枝末节”。网络程序员要明白check sum的作用，知道为什么需要check sum，至于具体怎么算CRC就不需要程序员操心。这部分通常是由网卡硬件完成的，在发包的时候由硬件填充CRC，在收包的时候网卡自动丢弃CRC不合格的包。如果代码里边确实要用到CRC计算，调用通用的zlib就行，也不用自己实现。 UNP就像给了你一堆做菜的原料（各种Sockets 函数的用法），常用和不常用的都给了（Out-of-Band Data、Signal-Driven IO 等等），要靠读者自己设法取舍组合，做出一盘大菜来。在第一遍读的时候，我建议只读那些基本且重要的章节；另外那些次要的内容可略作了解，即便跳过不读也无妨。UNP是一本操作性很强的书，读这本这本书一定要上机练习。 另外，UNP举的两个例子（菜谱）太简单，daytime和echo一个是短连接协议，一个是长连接无格式协议，不足以覆盖基本的网络开发场景（比如 TCP封包与拆包、多连接之间交换数据）。我估计 W. Richard Stevens 原打算在 UNP第三卷中讲解一些实际的例子，只可惜他英年早逝，我等无福阅读。 UNP是一本偏重Unix传统的书，这本书写作的时候服务端还不需要处理成千上万的连接，也没有现在那么多网络攻击。书中重点介绍的以accept()+fork()来处理并发连接的方式在现在看来已经有点吃力，这本书的代码也没有特别防范恶意攻击。如果工作涉及这些方面，需要再进一步学习专门的知识（C10k问题，安全编程）。 TCPv1和UNP应该先看哪本？我不知道。我自己是先看的TCPv1，花了大约半学期时间，然后再读UNP2e和APUE。 · 《Effective TCP/IP Programming》 第三本书我犹豫了很久，不知道该推荐哪本，还有哪本书能与 W. Richard Stevens 的这两本比肩吗？W. Richard Stevens 为技术书籍的写作树立了难以逾越的标杆，他是一位伟大的技术作家。没能看到他写完 UNP 第三卷实在是人生的遗憾。 《Effective TCP/IP Programming》这本书属于专家经验总结类，初看时觉得收获很大，工作一段时间再看也能有新的发现。比如第6 条“TCP是一个字节流协议”，看过这一条就不会去研究所谓的“TCP粘包问题”。我手头这本电力社2001年的中文版翻译尚可，但是很狗血的是把参考文献去掉了，正文中引用的文章资料根本查不到名字。人邮2011年重新翻译出版的版本有参考文献。 其他值得一看的书 以下两本都不易读，需要相当的基础。 · 《TCP/IP Illustrated, Vol. 2: The Implementation》以下简称 TCPv2 1200页的大部头，详细讲解了4.4BSD的完整TCP/IP协议栈，注释了15,000行C源码。这本书啃下来不容易，如果时间不充裕，我认为没必要啃完，应用层的网络程序员选其中与工作相关的部分来阅读即可。 这本书第一作者是Gary Wright，从叙述风格和内容组织上是典型的“面向知识体系本身”，先讲mbuf，再从链路层一路往上、以太网、IP网络层、ICMP、IP多播、IGMP、IP路由、多播路由、Sockets系统调用、ARP等等。到了正文内容3/4的地方才开始讲TCP。面面俱到、主次不明。 对于主要使用TCP的程序员，我认为TCPv2一大半内容可以跳过不看，比如路由表、IGMP等等（开发网络设备的人可能更关心这些内容）。在工作中大可以把IP视为host-to-host的协议，把“IP packet如何送达对方机器”的细节视为黑盒子，这不会影响对TCP的理解和运用，因为网络协议是分层的。这样精简下来，需要看的只有三四百页，四五千行代码，大大减轻了负担。 这本书直接呈现高质量的工业级操作系统源码，读起来有难度，读懂它甚至要有“不求甚解的能力”。其一，代码只能看，不能上机运行，也不能改动试验。其二，与操作系统其他部分紧密关联。比如TCP/IP stack下接网卡驱动、软中断；上承inode转发来的系统调用操作；中间还要与平级的进程文件描述符管理子系统打交道；如果要把每一部分都弄清楚，把持不住就迷失主题了。其三，一些历史包袱让代码变复杂晦涩。比如BSD在80年代初需要在只有4M内存的VAX上实现TCP/IP，内存方面捉襟见肘，这才发明了mbuf结构，代码也增加了不少偶发复杂度（buffer不连续的处理）。 读这套TCP/IP书切忌胶柱鼓瑟，这套书以4.4BSD为底，其描述的行为（特别是与timer相关的行为）与现在的Linux TCP/IP有不小的出入，用书本上的知识直接套用到生产环境的Linux系统可能会造成不小的误解和困扰。（TCPv3不重要，可以成套买来收藏，不读亦可。） · 《Pattern-Oriented Software Architecture Volume 2: Patterns for Concurrent and Networked Objects》以下简称POSA2 这本书总结了开发并发网络服务程序的模式，是对UNP很好的补充。UNP中的代码往往把业务逻辑和Sockets API调用混在一起，代码固然短小精悍，但是这种编码风格恐怕不适合开发大型的网络程序。POSA2强调模块化，网络通信交给library/framework去做，程序员写代码只关注业务逻辑，这是非常重要的思想。阅读这本书对于深入理解常用的event-driven网络库（libevent、Java Netty、Java Mina、Perl POE、Python Twisted等等）也很有帮助，因为这些库都是依照这本书的思想编写的。 POSA2的代码是示意性的，思想很好，细节不佳。其C++ 代码没有充分考虑资源的自动化管理(RAII)，如果直接按照书中介绍的方式去实现网络库，那么会给使用者造成不小的负担与陷阱。换言之，照他说的做，而不是照他做的学。 不值一看的书 Douglas Comer 教授名气很大，著作等身，但是他写的网络方面的书不值一读，味同嚼蜡。网络编程与 TCP/IP 方面，有W. Richard Stevens 的书扛鼎；计算机网络原理方面，有Kurose的“自顶向下”和Peterson的“系统”打旗，没其他人什么事儿。顺便一提，Tanenbaum的操作系统教材是最好的之一（嗯，之二，因为他写了两本：“现代”和“设计与实现”），不过他的计算机网络和体系结构教材的地位比不上他的操作系统书的地位。体系结构方面，Patterson 和 Hennessy二人合作的两本书是最好的，近年来崭露头角的《深入理解计算机系统》也非常好；当然，侧重点不同。","title":"谈一谈网络编程学习经验"},{"content":"驱动编程：http://blog.csdn.net/fudan_abc/?viewmode=contents 应用编程：http://www.eefocus.com/html/09-11/26160910394Yba.shtml Linux内核源代码下载：http://www.kernel.org/","title":"学习linux编程的资源汇总"},{"content":"前端页面：  Html代码   <HTML>    <HEAD>     <TITLE>远程数据源的组合框示例<\/TITLE>     <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">     <link rel=\"stylesheet\" type=\"text/css\" href=\"extjs4/resources/css/ext-all.css\" />     <script type=\"text/javascript\" src=\"extjs4/bootstrap.js\"><\/script>     <script type=\"text/javascript\" src=\"extjs4/ext-lang-zh_CN.js\"><\/script>     <script type=\"text/javascript\">       Ext.onReady(function(){           //创建数据模型           Ext.regModel('BookInfo', {               fields: [{name: 'bookName'}]           });           //定义组合框中显示的数据源           var bookStore = Ext.create('Ext.data.Store',{               model : 'BookInfo',               proxy: {                   type: 'ajax',//Ext.data.AjaxProxy                   url : 'bookSearchServer.jsp',                   reader: new Ext.data.ArrayReader({model : 'BookInfo'})               }           });           //创建表单           Ext.create('Ext.form.Panel',{               title:'Ext.form.field.ComboBox远程数据源示例',               frame : true,               height:100,               width:270,               renderTo: Ext.getBody(),               bodyPadding: 5,               defaults:{//统一设置表单字段默认属性                   labelSeparator :'：',//分隔符                   labelWidth : 70,//标签宽度                   width : 200,//字段宽度                   labelAlign : 'left'//标签对齐方式               },               items:[{                   xtype : 'combo',                   fieldLabel:'书籍列表',                   listConfig : {                       loadingText : '正在加载书籍信息',//加载数据时显示的提示信息                       emptyText : '未找到匹配值',//当值不在列表是的提示信息                       maxHeight : 100//设置下拉列表的最大高度为60像素                   },                   allQuery:'allbook',//查询全部信息的查询字符串                   minChars : 3,//下拉列表框自动选择前用户需要输入的最小字符数量                   queryDelay : 300,//查询延迟时间                   queryParam : 'searchbook',//查询的名字                   triggerAction: 'all',//单击触发按钮显示全部数据                   store : bookStore,//设置数据源                   displayField:'bookName',//定义要显示的字段                   valueField:'bookName',//定义值字段                   queryMode: 'remote'//远程模式               }]           });       });     <\/script>    <\/HEAD>    <BODY STYLE=\"margin: 10px\">    <\/BODY>   <\/HTML>   JSP代码：  Jsp代码   <%@ page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\"%>   <%   String bookName = request.getParameter(\"searchbook\");   String jav = \"['java编程思想'],['java入门'],['javascript程序设计']\";   String cpp = \"['c++编程思想'],['c++入门'],['c++程序设计']\";   String php = \"['php程序设计'],['php入门'],['php从入门到精通']\";   String books = \"\";   if(bookName.equals(\"allbook\")){       books = \"[\"+jav+\",\"+cpp+\",\"+php+\"]\";       response.getWriter().write(books);       return;   }else{       bookName = bookName.substring(0,3);//取查询字符串的前3个字符       System.out.println(bookName);          if(bookName.equals(\"jav\")){           books = \"[\"+jav+\"]\";       }else if(bookName.equals(\"c++\")){           books = \"[\"+cpp+\"]\";       }else if(bookName.equals(\"php\")){           books = \"[\"+php+\"]\";       }else{           books = \"[['没有数据']]\";       }       response.getWriter().write(books);   }   %>  ","title":"ExtJS4学习笔记三－－远程访问数据源示例"},{"content":"源代码：http://download.csdn.net/detail/nuptboyzhb/4169959 基于TCP/IP协议的网络编程 TCP/IP，主要是API（Application Programming Interface，应用编程接口） 定义变量——获得WINSOCK版本——加载WINSOCK库——初始化——创建套接字 ——设置套接字选项——关闭套接字——卸载WINSOCK库——释放所有资源 整个程序架构分为两大部分，服务器端客户端。 服务器SOCKET程序流程： socket()→bind()→listen→accept()→recv()/send()→closesocket() 客户端： socket→bind()→connect()→send()/recv()→closesocket()   编程举例： 约定发送消息的格式为如下结构体： typedef struct {          int ID;          char data[255]; }TcpMessage; 应用程序的头文件如下： #include <winsock2.h> #pragma comment(lib,\"ws2_32\") #include <stdio.h> 端口号为：4500 服务器端： 1、  初始化：          WSADATA wsaData;     WORD sockVersion = MAKEWORD(2, 2);          if(WSAStartup(sockVersion, &wsaData) != 0)                    return 0; 2、  创建套接字：          SOCKET sListen = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);          if(sListen == INVALID_SOCKET) { printf(\"socket error\\n\"); return 0; } 3、  使套接字和本地地址绑定 // 在sockaddr_in结构中装入地址信息          sockaddr_in sin;          sin.sin_family = AF_INET;          sin.sin_port = htons(4500); // htons函数将主机的无符号短整形数转换成网络          //字节顺序          sin.sin_addr.S_un.S_addr = INADDR_ANY; if(bind(sListen, (LPSOCKADDR)&sin, sizeof(sin)) == SOCKET_ERROR)          {                    printf(\" bind error \\n\");                    closesocket(sListen);                    return 0;          } 4、监听端口          if(listen(sListen, 5) == SOCKET_ERROR)          {                    printf(\"listen error\\n\");                    closesocket(sListen);                    return 0;          } 5、等待接受连接，（如无连接，一直等待） SOCKET sClient;//用于保存accept返回的套接字 sClient = accept(sListen,0,0);//accept函数调用失败则继续等待连接。 if(sClient == INVALID_SOCKET) {                             printf(\"accept() error\");          } 6、用第5步中accept函数返回的套接字进行收发通信  6.1、接收：（如果没有接到，会等待!）       TcpMessagerevData;//定义接收消息的结构体变量       int ret=recv(sClient,(char *)&revData,sizeof(revData),0);       if(ret>0)//说明，收到字节       {          switch (revData.ID)//对不同的ID，可以有不同的反应 {    case 1:    …….. case 2: …….. } }  6.2、发送：       TcpMessage sendData;            memset((char*)&sendData,0,sizeof(sendData));//初始化为0       sendData.ID=1;//为ID成员变量赋值       strcpy(sendData.data,\"\\r\\n..要发送的字符信息 \");       if(send(sClient,(char*)&sendData,sizeof(sendData),0)==SOCKET_ERROR)            {                    char error[10];                    int errorcode=WSAGetLastError();                    itoa(errorcode,error,10);                    MessageBox(NULL,error,\"发送失败，错误码为：\",MB_OK);                    printf(\"send error!\");            } 7、关闭          closesocket(sClient);//由accept生成的套接字          closesocket(sListen);//服务端套接字          WSACleanup(); 客户端 1、   初始化 WSADATA wsaData; WORD sockVersion = MAKEWORD(2, 2);        if(WSAStartup(sockVersion, &wsaData) != 0)                         return 0; 2、   创建套接字 SOCKET sClient = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);           if(sClient == INVALID_SOCKET)           {                    printf(\"socket error\\n\");                    return 0;        } 3、   使套接字和本地地址绑定 // 在sockaddr_in结构中装入服务器端地址信息           sockaddr_in servAddr;           servAddr.sin_family = AF_INET;           servAddr.sin_port = htons(4500);// htons函数将主机的无符号短整形数转换成网络           //字节顺序,4500端口为要连接服务器端的端口        servAddr.sin_addr.S_un.S_addr =inet_addr(\"127.0.0.1\");//服务器端ip 4、   连接服务器           if(connect(sClient,(sockaddr*)&servAddr,sizeof(servAddr))==SOCKET_ERROR)           {                    printf(\"connect error\\n\");                    closesocket(sClient);                    return 0;        } //注意，要先把服务器打开，否则连接失败 5、   收发通信 用send和recv函数，这一点和服务器端一样 6、   关闭 closesocket(sClient);//客户端只有一个连接套接字           WSACleanup(); 源代码：http://download.csdn.net/detail/nuptboyzhb/4169959 基于TCP/IP协议的网络编程 TCP/IP，主要是API（Application Programming Interface，应用编程接口） 定义变量——获得WINSOCK版本——加载WINSOCK库——初始化——创建套接字 ——设置套接字选项——关闭套接字——卸载WINSOCK库——释放所有资源 整个程序架构分为两大部分，服务器端客户端。 服务器SOCKET程序流程： socket()→bind()→listen→accept()→recv()/send()→closesocket() 客户端： socket→bind()→connect()→send()/recv()→closesocket()   编程举例： 约定发送消息的格式为如下结构体： typedef struct {          int ID;          char data[255]; }TcpMessage; 应用程序的头文件如下： #include <winsock2.h> #pragma comment(lib,\"ws2_32\") #include <stdio.h> 端口号为：4500 服务器端： 1、  初始化：          WSADATA wsaData;     WORD sockVersion = MAKEWORD(2, 2);          if(WSAStartup(sockVersion, &wsaData) != 0)                    return 0; 2、  创建套接字：          SOCKET sListen = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);          if(sListen == INVALID_SOCKET) { printf(\"socket error\\n\"); return 0; } 3、  使套接字和本地地址绑定 // 在sockaddr_in结构中装入地址信息          sockaddr_in sin;          sin.sin_family = AF_INET;          sin.sin_port = htons(4500); // htons函数将主机的无符号短整形数转换成网络          //字节顺序          sin.sin_addr.S_un.S_addr = INADDR_ANY; if(bind(sListen, (LPSOCKADDR)&sin, sizeof(sin)) == SOCKET_ERROR)          {                    printf(\" bind error \\n\");                    closesocket(sListen);                    return 0;          } 4、监听端口          if(listen(sListen, 5) == SOCKET_ERROR)          {                    printf(\"listen error\\n\");                    closesocket(sListen);                    return 0;          } 5、等待接受连接，（如无连接，一直等待） SOCKET sClient;//用于保存accept返回的套接字 sClient = accept(sListen,0,0);//accept函数调用失败则继续等待连接。 if(sClient == INVALID_SOCKET) {                             printf(\"accept() error\");          } 6、用第5步中accept函数返回的套接字进行收发通信  6.1、接收：（如果没有接到，会等待!）       TcpMessagerevData;//定义接收消息的结构体变量       int ret=recv(sClient,(char *)&revData,sizeof(revData),0);       if(ret>0)//说明，收到字节       {          switch (revData.ID)//对不同的ID，可以有不同的反应 {    case 1:    …….. case 2: …….. } }  6.2、发送：       TcpMessage sendData;            memset((char*)&sendData,0,sizeof(sendData));//初始化为0       sendData.ID=1;//为ID成员变量赋值       strcpy(sendData.data,\"\\r\\n..要发送的字符信息 \");       if(send(sClient,(char*)&sendData,sizeof(sendData),0)==SOCKET_ERROR)            {                    char error[10];                    int errorcode=WSAGetLastError();                    itoa(errorcode,error,10);                    MessageBox(NULL,error,\"发送失败，错误码为：\",MB_OK);                    printf(\"send error!\");            } 7、关闭          closesocket(sClient);//由accept生成的套接字          closesocket(sListen);//服务端套接字          WSACleanup(); 客户端 1、   初始化 WSADATA wsaData; WORD sockVersion = MAKEWORD(2, 2);        if(WSAStartup(sockVersion, &wsaData) != 0)                         return 0; 2、   创建套接字 SOCKET sClient = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);           if(sClient == INVALID_SOCKET)           {                    printf(\"socket error\\n\");                    return 0;        } 3、   使套接字和本地地址绑定 // 在sockaddr_in结构中装入服务器端地址信息           sockaddr_in servAddr;           servAddr.sin_family = AF_INET;           servAddr.sin_port = htons(4500);// htons函数将主机的无符号短整形数转换成网络           //字节顺序,4500端口为要连接服务器端的端口        servAddr.sin_addr.S_un.S_addr =inet_addr(\"127.0.0.1\");//服务器端ip 4、   连接服务器           if(connect(sClient,(sockaddr*)&servAddr,sizeof(servAddr))==SOCKET_ERROR)           {                    printf(\"connect error\\n\");                    closesocket(sClient);                    return 0;        } //注意，要先把服务器打开，否则连接失败 5、   收发通信 用send和recv函数，这一点和服务器端一样 6、   关闭 closesocket(sClient);//客户端只有一个连接套接字           WSACleanup();","title":"基于TCP/IP协议的C++网络编程（API函数版）"},{"content":"Rob Pike，目前谷歌公司最著名的软件工程师之一，曾是贝尔实验室 Unix 开发团队成员，Plan9 操作系统开发的主要领导人，Inferno 操作系统开发的主要领导人。他是缔造 Go 语言和 Limbo 语言的核心人物。下面是他分享给大家他在贝尔实验室工作的一段经历，这段经历改变了他对 bug 调试的思想认识。 　　Job 的主要工作经历： 　　我在贝尔实验室工作了很多年。我在计算机科学研究中心，你会很诧异，这是个很小的实验室，但这里却创造了 Unix，我来到这里工作的时候 Unix 已经发布了第七版。从 2002 年起我来到谷歌工作，主要开发一些系统基础架构。 　　最主要的成就： 　　我最为人所知的应该是我和 Brian Kernighan (Unix 开发组的重要成员)合著的两本书：《The Unix Programming Environment》 和 《程序设计实践(The Practice of Programming)》 (30年后的今天仍在印刷出版！)，影响范围最广的一件事应该是我和 Ken Thompson 共同开发完成了 UTF-8 编码格式。在其它方面，诸如计算机图形，操作系统，软件开发工具等上也做了大量的工作，最近在给谷歌开发 Go 编程语言。 　　使用最多的编程语言： 　　长久以来，C语言是我编程的选择，但在我的编程生涯里，我使用过很多种语言。而目前我开发d 东西基本上都是用 Go 语言，这是我见过的最高效的一种编程语言，它在我的工具箱里已经完全取代了C语言的位置。 　　忠告： 　　在我加入贝尔实验室一年多后，我开始和 Ken Thompson 一起在开发一个针对由 Gerard Holzmann 设计的很小的图形化交换语言的即时编译器上做结对编程。我打字比较快，所以我坐在电脑前，Ken 站在我身后看我编程。我们开发的很快，但经常会遇到问题，而且可以看出来出错了 —— 毕竟这是一个图形化的编程语言。当程序出错时，我本能的一头扎进问题，检查报错跟踪信息，添加调试打印语句，启动调试器，等等，但 Ken 只是站在那思考，完全不理会我也不查看我们写的出问题的代码。一段时间后我发现一个规律，Ken 经常会比我先找到问题出在什么地方，而且会突然的喊一嗓子，“我知道什么地方的问题了。”每次他的判断都很准确。我认识到，Ken 已经在脑海里构建了代码的模型，当有问题出现时，那是他脑子里的模型出了问题。在思考为什么会发生这些错误时，他能凭直觉找到模型中什么地方不对或发现写的代码跟这个模式什么地方有出入。 　　Ken 教会了我一个极其重要的习惯：纠错前先思考。如果你一头扎进问题中，你可能只解决了当前出现问题的代码，但如果你先思考这个错误，这个 bug 是怎么引入的？你通常发现和纠正一个更高层次的问题，进而改进了系统设计，防止了更多 bug 的出现。 　　我认识到这种编程思考模式非常的重要。有些人痴迷于一行行的、使用各种工具来调试所有的东西。但我现在相信，思考 —— 不看代码的思考 —— 是最好的调试途径，因为它能让你开发出更好的软件。","title":"Rob Pike：最有价值的编程忠告"},{"content":"为什么要进行shell编程 　　在Linux系统中，虽然有各种各样的图形化接口工具，但是shell仍然是一个非常灵活的工具。Shell不仅仅是命令的收集，而且是一门非常棒的编程语言。您可以通过使用shell使大量的任务自动化，shell特别擅长系统管理任务，尤其适合那些易用性、可维护性和便携性比效率更重要的任务。 　　下面，让我们一起来看看shell是如何工作的： 建立一个脚本 　　Linux中有好多中不同的shell，但是通常我们使用bash (bourne again shell) 进行shell编程，因为bash是免费的并且很容易使用。所以在本文中笔者所提供的脚本都是使用bash（但是在大多数情况下，这些脚本同样可以在bash的大姐，bourne shell中运行）。 　　如同其他语言一样，通过我们使用任意一种文字编辑器，比如nedit、kedit、emacs、vi 　　等来编写我们的shell程序。 　　程序必须以下面的行开始（必须方在文件的第一行）： #!/bin/sh 　　符号#!用来告诉系统它后面的参数是用来执行该文件的程序。在这个例子中我们使用/bin/sh来执行程序。 　　当编辑好脚本时，如果要执行该脚本，还必须使其可执行。 　　要使脚本可执行： chmod +x filename 　　然后，您可以通过输入： ./filename 来执行您的脚本。 注释 　　在进行shell编程时，以#开头的句子表示注释，直到这一行的结束。我们真诚地建议您在程序中使用注释。如果您使用了注释，那么即使相当长的时间内没有使用该脚本，您也能在很短的时间内明白该脚本的作用及工作原理。 变量 　　在其他编程语言中您必须使用变量。在shell编程中，所有的变量都由字符串组成，并且您不需要对变量进行声明。要赋值给一个变量，您可以这样写： 变量名=值(注意，等号左右不能有空格) 　　取出变量值可以加一个美元符号（$）在变量前面： #!/bin/sh #对变量赋值： a=\"hello world\" # 现在打印变量a的内容： echo \"A is:\" echo $a 　　在您的编辑器中输入以上内容，然后将其保存为一个文件first。之后执行chmod +x first 　　使其可执行，最后输入./first执行该脚本。 　　这个脚本将会输出： A is: hello world 　有时候变量名很容易与其他文字混淆，比如： num=2 echo \"this is the $numnd\" 　　这并不会打印出\"this is the 2nd\"，而仅仅打印\"this is the \"，因为shell会去搜索变量numnd的值，但是这个变量时没有值的。可以使用花括号来告诉shell我们要打印的是num变量： num=2 echo \"this is the ${num}nd\" 　　这将打印： this is the 2nd 　　有许多变量是系统自动设定的，这将在后面使用这些变量时进行讨论。 　　如果您需要处理数学表达式，那么您需要使用诸如eXPr等程序（见下面）。 　　除了一般的仅在程序内有效的shell变量以外，还有环境变量。由export关键字处理过的变量叫做环境变量。我们不对环境变量进行讨论，因为通常情况下仅仅在登录脚本中使用环境变量。 Shell命令和流程控制 　　在shell脚本中可以使用三类命令： 1)Unix 命令: 　　虽然在shell脚本中可以使用任意的unix命令，但是还是由一些相对更常用的命令。这些命令通常是用来进行文件和文字操作的。 常用命令语法及功能 　　echo \"some text\": 将文字内容打印在屏幕上 　　ls: 文件列表 　　wc –l filewc -w filewc -c file: 计算文件行数计算文件中的单词数计算文件中的字符数 　　cp sourcefile destfile: 文件拷贝 　　mv oldname newname : 重命名文件或移动文件 　　rm file: 删除文件 　　grep 'pattern' file: 在文件内搜索字符串比如：grep 'searchstring' file.txt 　　cut -b colnum file: 指定欲显示的文件内容范围，并将它们输出到标准输出设备比如：输出每行第5个到第9个字符cut -b5-9 file.txt千万不要和cat命令混淆，这是两个完全不同的命令 　　cat file.txt: 输出文件内容到标准输出设备（屏幕）上 　　file somefile: 得到文件类型 　　read var: 提示用户输入，并将输入赋值给变量 　　sort file.txt: 对file.txt文件中的行进行排序 　　uniq: 删除文本文件中出现的行列比如： sort file.txt uniq 　　expr: 进行数学运算Example: add 2 and 3expr 2 \"+\" 3 　　find: 搜索文件比如：根据文件名搜索find . -name filename -print 　　tee: 将数据输出到标准输出设备(屏幕) 和文件比如：somecommand tee outfile 　　basename file: 返回不包含路径的文件名比如： basename /bin/tux将返回 tux 　　dirname file: 返回文件所在路径比如：dirname /bin/tux将返回 /bin 　　head file: 打印文本文件开头几行 　　tail file : 打印文本文件末尾几行 　　sed: Sed是一个基本的查找替换程序。可以从标准输入（比如命令管道）读入文本，并将结果输出到标准输出（屏幕）。该命令采用正则表达式（见参考）进行搜索。不要和shell中的通配符相混淆。比如：将linuxfocus 替换为 LinuxFocus ：cat text.file sed 's/linuxfocus/LinuxFocus/' > newtext.file 　　awk: awk 用来从文本文件中提取字段。缺省地，字段分割符是空格，可以使用-F指定其他分割符。cat file.txt awk -F, '{print $1 \",\" $3 }'这里我们使用，作为字段分割符，同时打印第一个和第三个字段。如果该文件内容如下： Adam Bor, 34, IndiaKerry Miller, 22, USA命令输出结果为：Adam Bor, IndiaKerry Miller, USA 2) 概念: 管道, 重定向和 backtick 　　这些不是系统命令，但是他们真的很重要。 　　管道 () 将一个命令的输出作为另外一个命令的输入。 grep \"hello\" file.txt wc -l 　　在file.txt中搜索包含有”hello”的行并计算其行数。 　　在这里grep命令的输出作为wc命令的输入。当然您可以使用多个命令。 　　重定向：将命令的结果输出到文件，而不是标准输出（屏幕）。 　　> 写入文件并覆盖旧文件 　　>> 加到文件的尾部，保留旧文件内容。 反短斜线 　　使用反短斜线可以将一个命令的输出作为另外一个命令的一个命令行参数。 　　命令： find . -mtime -1 -type f -print 　　用来查找过去24小时（-mtime –2则表示过去48小时）内修改过的文件。如果您想将所有查找到的文件打一个包，则可以使用以下脚本： #!/bin/sh # The ticks are backticks (`) not normal quotes ('): tar -zcvf lastmod.tar.gz `find . -mtime -1 -type f -print` 　　3) 流程控制 　　\"if\" 表达式 如果条件为真则执行then后面的部分： if ....; then 　 .... elif ....; then 　 .... else 　 .... fi 　　大多数情况下，可以使用测试命令来对条件进行测试。比如可以比较字符串、判断文件是否存在及是否可读等等… 　　通常用\" [ ] \"来表示条件测试。注意这里的空格很重要。要确保方括号的空格。 [ -f \"somefile\" ] ：判断是否是一个文件 [ -x \"/bin/ls\" ] ：判断/bin/ls是否存在并有可执行权限 [ -n \"$var\" ] ：判断$var变量是否有值 [ \"$a\" = \"$b\" ] ：判断$a和$b是否相等 　　执行man test可以查看所有测试表达式可以比较和判断的类型。 　　直接执行以下脚本： #!/bin/sh if [ \"$SHELL\" = \"/bin/bash\" ]; then 　echo \"your login shell is the bash (bourne again shell)\" else 　echo \"your login shell is not bash but $SHELL\" fi 　　变量$SHELL包含了登录shell的名称，我们和/bin/bash进行了比较。 快捷操作符 　　熟悉C语言的朋友可能会很喜欢下面的表达式： [ -f \"/etc/shadow\" ] && echo \"This computer uses shadow passwors\" 这里 && 就是一个快捷操作符，如果左边的表达式为真则执行右边的语句。您也可以认为是逻辑运算中的与操作。上例中表示如果/etc/shadow文件存在则打印” This computer uses shadow passwors”。同样或操作()在shell编程中也是可用的。这里有个例子： #!/bin/sh mailfolder=/var/spool/mail/james [ -r \"$mailfolder\" ]' '{ echo \"Can not read $mailfolder\" ; exit 1; } echo \"$mailfolder has mail from:\" grep \"^From \" $mailfolder 　　该脚本首先判断mailfolder是否可读。如果可读则打印该文件中的\"From\" 一行。如果不可读则或操作生效，打印错误信息后脚本退出。这里有个问题，那就是我们必须有两个命令： 　　-打印错误信息 　　-退出程序 　　我们使用花括号以匿名函数的形式将两个命令放到一起作为一个命令使用。一般函数将在下文提及。 　　不用与和或操作符，我们也可以用if表达式作任何事情，但是使用与或操作符会更便利很多。 　　case表达式可以用来匹配一个给定的字符串，而不是数字。 case ... in ...) do something here ;; esac   　　让我们看一个例子。 file命令可以辨别出一个给定文件的文件类型，比如： file lf.gz 　　这将返回： lf.gz: gzip compressed data, deflated, original filename, last modified: Mon Aug 27 23:09:18 2001, os: Unix   　　我们利用这一点写了一个叫做smartzip的脚本，该脚本可以自动解压bzip2, gzip 和zip 类型的压缩文件： #!/bin/sh ftype=`file \"$1\"` case \"$ftype\" in \"$1: Zip archive\"*) 　　unzip \"$1\" ;; \"$1: gzip compressed\"*) 　　gunzip \"$1\" ;; \"$1: bzip2 compressed\"*) 　　bunzip2 \"$1\" ;; *) error \"File $1 can not be uncompressed with smartzip\";; esac   　　您可能注意到我们在这里使用了一个特殊的变量$1。该变量包含了传递给该程序的第一个参数值。也就是说，当我们运行： smartzip articles.zip $1 就是字符串 articles.zip 　　select 表达式是一种bash的扩展应用，尤其擅长于交互式使用。用户可以从一组不同的值中进行选择。 select var in ... ; do 　break done .... now $var can be used .... 下面是一个例子： #!/bin/sh echo \"What is your favourite OS?\" select var in \"Linux\" \"Gnu Hurd\" \"Free BSD\" \"Other\"; do 　　　　break done echo \"You have selected $var\" 　　下面是该脚本运行的结果： What is your favourite OS? 1) Linux 2) Gnu Hurd 3) Free BSD 4) Other #? 1 You have selected Linux 　　您也可以在shell中使用如下的loop表达式： while ...; do .... done 　　while-loop 将运行直到表达式测试为真。will run while the expression that we test for is true. 关键字\"break\" 用来跳出循环。而关键字”continue”用来不执行余下的部分而直接跳到下一个循环。 　　for-loop表达式查看一个字符串列表 (字符串用空格分隔) 然后将其赋给一个变量： for var in ....; do 　.... done   　　在下面的例子中，将分别打印ABC到屏幕上： #!/bin/sh for var in A B C ; do 　echo \"var is $var\" done   　　下面是一个更为有用的脚本showrpm，其功能是打印一些RPM包的统计信息： #!/bin/sh # list a content summary of a number of RPM packages # USAGE: showrpm rpmfile1 rpmfile2 ... # EXAMPLE: showrpm /cdrom/RedHat/RPMS/*.rpm for rpmpackage in $*; do 　if [ -r \"$rpmpackage\" ];then 　　echo \"=============== $rpmpackage ==============\" 　　rpm -qi -p $rpmpackage 　else 　　echo \"ERROR: cannot read file $rpmpackage\" 　fi done   　　这里出现了第二个特殊的变量$*，该变量包含了所有输入的命令行参数值。如果您运行showrpm openssh.rpm w3m.rpm webgrep.rpm 　　此时 $* 包含了 3 个字符串，即openssh.rpm, w3m.rpm and webgrep.rpm. 引号 　　在向程序传递任何参数之前，程序会扩展通配符和变量。这里所谓扩展的意思是程序会把通配符（比如*）替换成合适的文件名，它变量替换成变量值。为了防止程序作这种替换，您可以使用引号：让我们来看一个例子，假设在当前目录下有一些文件，两个jpg文件， mail.jpg 和tux.jpg。 #!/bin/sh echo *.jpg 这将打印出\"mail.jpg tux.jpg\"的结果。 　　引号 (单引号和双引号) 将防止这种通配符扩展： #!/bin/sh echo \"*.jpg\" echo '*.jpg'   　　这将打印\"*.jpg\" 两次。 　　单引号更严格一些。它可以防止任何变量扩展。双引号可以防止通配符扩展但允许变量扩展。 #!/bin/sh echo $SHELL echo \"$SHELL\" echo '$SHELL'   　　运行结果为： /bin/bash /bin/bash $SHELL 　　最后，还有一种防止这种扩展的方法，那就是使用转义字符——反斜杆： echo *.jpg echo $SHELL 　　这将输出： *.jpg $SHELL Here documents 　　当要将几行文字传递给一个命令时，here documents（译者注：目前还没有见到过对该词适合的翻译）一种不错的方法。对每个脚本写一段帮助性的文字是很有用的，此时如果我们四有那个here documents就不必用echo函数一行行输出。 一个 \"Here document\" 以 << 开头，后面接上一个字符串，这个字符串还必须出现在here document的末尾。下面是一个例子，在该例子中，我们对多个文件进行重命名，并且使用here documents打印帮助： #!/bin/sh # we have less than 3 arguments. Print the help text: if [ $# -lt 3 ] ; then cat < ren -- renames a number of files using sed regular expressions USAGE: ren 'regexp' 'replacement' files... EXAMPLE: rename all *.HTM files in *.html: 　ren 'HTM$' 'html' *.HTM HELP 　exit 0 fi OLD=\"$1\" NEW=\"$2\" # The shift command removes one argument from the list of # command line arguments. shift shift # $* contains now all the files: for file in $*; do 　　if [ -f \"$file\" ] ; then 　　　newfile=`echo \"$file\" sed \"s/${OLD}/${NEW}/g\"` 　　　if [ -f \"$newfile\" ]; then 　　　　echo \"ERROR: $newfile exists already\" 　　　else 　　　　echo \"renaming $file to $newfile ...\" 　　　　mv \"$file\" \"$newfile\" fi 　　fi done   　　这是一个复杂一些的例子。让我们详细讨论一下。第一个if表达式判断输入命令行参数是否小于3个 (特殊变量$# 表示包含参数的个数) 。如果输入参数小于3个，则将帮助文字传递给cat命令，然后由cat命令将其打印在屏幕上。打印帮助文字后程序退出。 如果输入参数等于或大于3个，我们就将第一个参数赋值给变量OLD，第二个参数赋值给变量NEW。下一步，我们使用shift命令将第一个和第二个参数从参数列表中删除，这样原来的第三个参数就成为参数列表$*的第一个参数。然后我们开始循环，命令行参数列表被一个接一个地被赋值给变量$file。接着我们判断该文件是否存在，如果存在则通过sed命令搜索和替换来产生新的文件名。然后将反短斜线内命令结果赋值给newfile。这样我们就达到了我们的目的：得到了旧文件名和新文件名。然后使用mv命令进行重命名。 函数 　　如果您写了一些稍微复杂一些的程序，您就会发现在程序中可能在几个地方使用了相同的代码，并且您也会发现，如果我们使用了函数，会方便很多。一个函数是这个样子的： functionname() { # inside the body $1 is the first argument given to the function # $2 the second ... body } 　　您需要在每个程序的开始对函数进行声明。 　　下面是一个叫做xtitlebar的脚本，使用这个脚本您可以改变终端窗口的名称。这里使用了一个叫做help的函数。正如您可以看到的那样，这个定义的函数被使用了两次。 #!/bin/sh # vim: set sw=4 ts=4 et: help() { 　　cat < xtitlebar -- change the name of an xterm, gnome-terminal or kde konsole USAGE: xtitlebar [-h] \"string_for_titelbar\" OPTIONS: -h help text EXAMPLE: xtitlebar \"cvs\" HELP 　　exit 0 } # in case of error or if -h is given we call the function help: [ -z \"$1\" ] && help [ \"$1\" = \"-h\" ] && help # send the escape sequence to change the xterm titelbar: echo -e \"33]0;$107\" #   　　在脚本中提供帮助是一种很好的编程习惯，这样方便其他用户（和您）使用和理解脚本。 命令行参数 　　我们已经见过$* 和 $1, $2 ... $9 等特殊变量，这些特殊变量包含了用户从命令行输入的参数。迄今为止，我们仅仅了解了一些简单的命令行语法（比如一些强制性的参数和查看帮助的-h选项）。但是在编写更复杂的程序时，您可能会发现您需要更多的自定义的选项。通常的惯例是在所有可选的参数之前加一个减号，后面再加上参数值 (比如文件名)。 　　有好多方法可以实现对输入参数的分析，但是下面的使用case表达式的例子无遗是一个不错的方法。 #!/bin/sh help() { 　cat < This is a generic command line parser demo. USAGE EXAMPLE: cmdparser -l hello -f -- -somefile1 somefile2 HELP 　exit 0 } while [ -n \"$1\" ]; do case $1 in 　　-h) help;shift 1;; # function help is called 　　-f) opt_f=1;shift 1;; # variable opt_f is set 　　-l) opt_l=$2;shift 2;; # -l takes an argument -> shift by 2 　　--) shift;break;; # end of options 　　-*) echo \"error: no sUCh option $1. -h for help\";exit 1;; 　　*) break;; esac done echo \"opt_f is $opt_f\" echo \"opt_l is $opt_l\" echo \"first arg is $1\" echo \"2nd arg is $2\"   　　您可以这样运行该脚本： cmdparser -l hello -f -- -somefile1 somefile2 　　返回的结果是： opt_f is 1 opt_l is hello first arg is -somefile1 2nd arg is somefile2   　　这个脚本是如何工作的呢？脚本首先在所有输入命令行参数中进行循环，将输入参数与case表达式进行比较，如果匹配则设置一个变量并且移除该参数。根据unix系统的惯例，首先输入的应该是包含减号的参数。 实例 　　一般编程步骤 　　现在我们来讨论编写一个脚本的一般步骤。任何优秀的脚本都应该具有帮助和输入参数。并且写一个伪脚本（framework.sh），该脚本包含了大多数脚本都需要的框架结构，是一个非常不错的主意。这时候，在写一个新的脚本时我们只需要执行一下copy命令： cp framework.sh myscript 　　然后再插入自己的函数。 　　让我们再看两个例子： 　　二进制到十进制的转换 　　脚本 b2d 将二进制数 (比如 1101) 转换为相应的十进制数。这也是一个用expr命令进行数学运算的例子： #!/bin/sh # vim: set sw=4 ts=4 et: help() { 　cat < b2h -- convert binary to decimal USAGE: b2h [-h] binarynum OPTIONS: -h help text EXAMPLE: b2h 111010 will return 58 HELP 　exit 0 } error() { 　　# print an error and exit 　　echo \"$1\" 　　exit 1 } lastchar() { 　　# return the last character of a string in $rval 　　if [ -z \"$1\" ]; then 　　　　# empty string 　　　　rval=\"\" 　　　　return 　　fi 　　# wc puts some space behind the output this is why we need sed: 　　numofchar=`echo -n \"$1\" wc -c sed 's/ //g' ` 　　# now cut out the last char 　　rval=`echo -n \"$1\" cut -b $numofchar` } chop() { 　　# remove the last character in string and return it in $rval 　　if [ -z \"$1\" ]; then 　　　　# empty string 　　　　rval=\"\" 　　　　return 　　fi 　　# wc puts some space behind the output this is why we need sed: 　　numofchar=`echo -n \"$1\" wc -c sed 's/ //g' ` 　　if [ \"$numofchar\" = \"1\" ]; then 　　　　# only one char in string 　　　　rval=\"\" 　　　　return 　　fi 　　numofcharminus1=`expr $numofchar \"-\" 1` 　　# now cut all but the last char: 　　rval=`echo -n \"$1\" cut -b 0-${numofcharminus1}` } while [ -n \"$1\" ]; do case $1 in 　　-h) help;shift 1;; # function help is called 　　--) shift;break;; # end of options 　　-*) error \"error: no such option $1. -h for help\";; 　　*) break;; esac done # The main program sum=0 weight=1 # one arg must be given: [ -z \"$1\" ] && help binnum=\"$1\" binnumorig=\"$1\" while [ -n \"$binnum\" ]; do 　　lastchar \"$binnum\" 　　if [ \"$rval\" = \"1\" ]; then 　　　　sum=`expr \"$weight\" \"+\" \"$sum\"` 　　fi 　　# remove the last position in $binnum 　　chop \"$binnum\" 　　binnum=\"$rval\" 　　weight=`expr \"$weight\" \"*\" 2` done echo \"binary $binnumorig is decimal $sum\" #   　　该脚本使用的算法是利用十进制和二进制数权值 (1,2,4,8,16,..)，比如二进制\"10\"可以这样转换成十进制： 0 * 1 + 1 * 2 = 2 　　为了得到单个的二进制数我们是用了lastchar 函数。该函数使用wc –c计算字符个数，然后使用cut命令取出末尾一个字符。Chop函数的功能则是移除最后一个字符。 　　文件循环程序 　　或许您是想将所有发出的邮件保存到一个文件中的人们中的一员，但是在过了几个月以后，这个文件可能会变得很大以至于使对该文件的访问速度变慢。下面的脚本rotatefile 可以解决这个问题。这个脚本可以重命名邮件保存文件（假设为outmail）为outmail.1，而对于outmail.1就变成了outmail.2 等等等等... #!/bin/sh # vim: set sw=4 ts=4 et: ver=\"0.1\" help() { 　　cat < rotatefile -- rotate the file name USAGE: rotatefile [-h] filename OPTIONS: -h help text EXAMPLE: rotatefile out This will e.g rename out.2 to out.3, out.1 to out.2, out to out.1 and create an empty out-file The max number is 10 version $ver HELP 　　exit 0 } error() { 　　echo \"$1\" 　　exit 1 } while [ -n \"$1\" ]; do case $1 in 　　-h) help;shift 1;; 　　--) break;; 　　-*) echo \"error: no such option $1. -h for help\";exit 1;; 　　*) break;; esac done # input check: if [ -z \"$1\" ] ; then error \"ERROR: you must specify a file, use -h for help\" fi filen=\"$1\" # rename any .1 , .2 etc file: for n in 9 8 7 6 5 4 3 2 1; do 　　if [ -f \"$filen.$n\" ]; then 　　　　p=`expr $n + 1` 　　　　echo \"mv $filen.$n $filen.$p\" 　　　　mv $filen.$n $filen.$p 　　fi done # rename the original file: if [ -f \"$filen\" ]; then 　　echo \"mv $filen $filen.1\" mv $filen $filen.1 fi echo touch $filen touch $filen   　　这个脚本是如何工作的呢？在检测用户提供了一个文件名以后，我们进行一个9到1的循环。文件9被命名为10，文件8重命名为9等等。循环完成之后，我们将原始文件命名为文件1同时建立一个与原始文件同名的空文件。 调试 　　最简单的调试命令当然是使用echo命令。您可以使用echo在任何怀疑出错的地方打印任何变量值。这也是绝大多数的shell程序员要花费80%的时间来调试程序的原因。Shell程序的好处在于不需要重新编译，插入一个echo命令也不需要多少时间。 　　shell也有一个真实的调试模式。如果在脚本\"strangescript\" 中有错误，您可以这样来进行调试： sh -x strangescript 　　这将执行该脚本并显示所有变量的值。 　　shell还有一个不需要执行脚本只是检查语法的模式。可以这样使用： sh -n your_script 　　这将返回所有语法错误。 　　我们希望您现在可以开始写您自己的shell脚本，希望您玩得开心。","title":"shell脚本入门"},{"content":"问题分析 Problem Analyse 递推题 Algorithm Analyse 比起以前做过的递推题，这一题算比较麻烦的了(当然，原因是我没有想到 好的方法，如果你有更方便的方法，欢迎提供大家一起学习)。 如果没有任何条件限制，A、B、C、D组成长度为n的字符串，其个数应该为:4n。 因为有了A、C需要出现偶数次的要求，就出现合法和不合法的不同分组。 在不合法的组里，又有 1.A出现奇数次、C出现偶数次； 2.C出现奇数次、A出现偶数次； 3.A出现奇数次、C出现奇数次； 三种情况。 我们用数组 f[n][0]保存长度为n，合法的字符串的个数。 f[n][1]保存长度为n，仅A出现奇数次的字符串的个数。 f[n][2]保存长度为n，仅C出现奇数次的字符串的个数。 f[n][3]保存长度为n，A、C出现奇数次的字符串的个数。 f[n][0] 长度为n-1的合法字符串在末尾加上一个B或者D，都可以变成长度为n的合法字符串。 长度为n-1的仅A出现奇数次的字符串再在末尾加上一个A，也可以变成合法字符串。 长度为n-1的仅C出现奇数次的字符串再在末尾加上一个C，也可以变成合法字符串。 所以，f[n][0] = 2 × f[n-1][0] + f[n-1][1] + f[n-1][2]; f[n][1] 长度为n-1的合法字符串在末尾加上A，都可以变成长度为n的仅A出现奇数次的字符串。 长度为n-1的仅A出现奇数次的字符串再在末尾加上一个B或者D，也可以变成仅A出现奇数次的字 符串。 长度为n-1的A、C出现奇数次的字符串再在末尾加上一个C，也可以变成仅A出现奇数次的字符串 。 所以，f[n][1] = 2 × f[n-1][1] + f[n-1][0] + f[n-1][3]; f[n][2] 长度为n-1的合法字符串在末尾加上C，都可以变成长度为n的仅C出现奇数次的字符串。 长度为n-1的仅C出现奇数次的字符串再在末尾加上一个B或者D，也可以变成仅C出现奇数次的字 符串。 长度为n-1的A、C出现奇数次的字符串再在末尾加上一个A，也可以变成仅C出现奇数次的字符串 。 所以，f[n][2] = 2 × f[n-1][2] + f[n-1][0] + f[n-1][3]; f[n][3] 长度为n-1的A、C出现奇数次的字符串在末尾加上一B或者D，都可以变成长度为n的A、C出现奇数 次的字符串。 长度为n-1的仅A出现奇数次的字符串再在末尾加上一个C，也可以变成A、C出现奇数次的字符串 。 长度为n-1的仅C出现奇数次的字符串再在末尾加上一个A，也可以变成A、C出现奇数次的字符串 。 所以，f[n][3] = 2 × f[n-1][3] + f[n-1][1] + f[n-1][2]; 综上所述，我们得到: f[n][0] = 2 × f[n-1][0] + f[n-1][1] + f[n-1][2]; ① f[n][1] = 2 × f[n-1][1] + f[n-1][0] + f[n-1][3]; ② f[n][2] = 2 × f[n-1][2] + f[n-1][0] + f[n-1][3]; ③ f[n][3] = 2 × f[n-1][3] + f[n-1][1] + f[n-1][2]; ④ f[1][0] = 2 f[1][1] = 1 f[1][2] = 1 f[1][3] = 0 /**** 搞出这个我就很哈皮的去敲快速幂了。。。然而大牛。。。 ****/ 发现f[1][1]与f[1][2]初始状态相同，而且以后迭代方程也相同，所以f[n][1] = f[n][2] 又有f[n][0] + f[n][3] = f[n][1] + f[n][2] ∵f[n][0] + f[n][1] + f[n][2] + f[n][3] = 4^n ∴f[n][0] + f[n][3] = f[n][1] + f[n][2] = 2 × 4^(n-1) ∴f[n-1][1] + f[n-1][2] = 2 × 4^(n-2) ∴f[n][0] = 2 × f[n-1][0] + f[n-1][1] + f[n-1][2] = 2 × f[n-1][0] + 2 × 4^(n-2) 我们得到: f[n][0] = 2 × f[n-1][0] + 2^(2n-3) f[n-1][0] = 2 × f[n-2][0] + 2^(2n-5) ┋ f[n-m][0] = 2 × f[n-m-1][0] + 2^(2n-2m-3) ┋ f[2][0] = 2 × f[1][0] + 2^1 f[1][0] = 2 开始一层层往下迭代: f[n][0] = 2 × f[n-1][0] + 2^(2n-3) = 2^2 × f[n-2][0] + 2^(2n-4) + 2^(2n-3) ┋ = 2^m × f[n-m][0] + 2^(2(n-m)-1+m-1) + … + 2^(2n-3) = 2^(n-1) × f[1][0] + 2^(n-1) + 2^n +… + 2^(2n-3) f[1][0] = 2; ∴f[n][0] = 2^n + 2^(n-1) + 2^n +… + 2^(2n-3) = 2^(2n-2) + 2^(n-1) 算法实现 Programing 公式得到了:f(n) = 2^(2n-2) + 2^(n-1) 但就这样直接编程那是不可能实现的，因为n的范围1≤N<=2^64 怎么的范围，是不能求出f(n)的。所以还得找其他规律。 因为题目只要求输出最后2位数，我们依次输出2的n的最后两位看看… 2^0  1 2^1  2 2^2  4 2^3  8 2^4  16 2^5  32 2^6  64 2^7  28 2^8  56 2^9  12 2^10  24 2^11  48 2^12  96 2^13  92 2^14  84 2^15  68 2^16  36 2^17  72 2^18  44 2^19  88 2^20  76 2^21  52 2^22  4 到了2^22时，末尾2位又变成4，与2^2一样，这时候就进入了一个循环了(每20个一次循环)。 所以，结果只能是这22个中的一个。只有n=0 和 n=1是需要特殊考虑的。其他n就等于2(n-2) %20 + 2的值了。   #include <iostream>using namespace std;int p2[30] = {1};int po(__int64 x){\tif (x>1) x = (x - 2)% 20 + 2;\tif (x<0) return 1;\treturn p2[x];}int main(){\tfor (int i=1;i<24;++i) p2[i] = (p2[i-1]<<1) % 100;\tint t;\twhile (scanf(\"%d\", &t), t)\t{\t\tfor (int i=1;i<=t;++i)\t\t{\t\t\t__int64 n, a;\t\t\tscanf(\"%I64d\", &n);\t\t\ta = po(2*n-2) + po(n-1);\t\t\tprintf(\"Case %d: %d\\n\", i, a%100);\t\t}\t\tprintf(\"\\n\");\t}\treturn 0;}                ","title":"hdu 2065 红色病毒"},{"content":"每次需要输入输出这样的基本操作时，都需要#include <stdio.h>，并且这种情况比比皆是，那么C语言为什么不自动包含像输入输出这样基本的语句呢？ 一个答案是并非所有的程序都要用到I/O（输入/输出）包，例如在C语言非常流行的嵌入式编程领域中。而C语言的一个基本设计原则是避免不必要的成分。 顺便说一句，#include甚至不是C语言的语句！ 第一列中的#符号表明这一行是在编译器接手之前由C预处理器处理的语句。","title":"为什么不内置输入输出语句？"},{"content":"1.把所有变量放在一起，可以让读者更容易掌握程序的内容。如果您赋予变量有意义的名字（例如用taxrate代替r）将会更好地达到这个目的。如果名字不能表达清楚，可以用注释解释变量所代表的意思。通过这种方式使程序更易读是良好编程的基本技巧之一。 2.在您开始编写程序之前，考虑一下需要声明的变量会促使您做一些计划工作。程序需要在开始得到什么信息？到底想让程序得出什么结果？表示数据的最好方式是什么？ 3.声明变量可以帮助避免程序中出现一类很难发现的细微错误，即变量名的错误拼写。例如，假设在某种语言中缺少变量声明，而您写了一个语句：  RADIUS1 = 20.4;  并且在程序的另一个地方错误地键入了：  CIRCUM = 6.28 * RADIUSl;  无意地用字母l代替了数字1.那么这种语言将创建一个新的变量RADIUSl，并且使用它可能有的任何值（可能是零，也可能是垃圾数据）。CIRCUM将被赋予一个错误值，您可能需要花费大量的时间试图找出原因。在C语言中这种情况不会发生（除非您非常不明智地声明了两个如此相似的变量名），因为当没有被声明过的RADIUSl出现时，编译器将会提出警告。 4.如果您没有声明所有变量，将不能编译您的C程序。如果前面的三个原因还不足以打动您，这个原因总可以让您认真地考虑一下了。  ","title":"为什么必须对变量进行声明？"},{"content":" /*===========================================================  主题:指针数组(也叫Iliffe向量,display向量,是一种强大的编程技巧)  内容:  1.你在程序中看到一个array[i][j]时,你不知道它的声明形式,它可是以  下任何一种形式  int array[4][5]   ;int型的二维数组  int *array[4] ;   4个int型的Iliffe向量  int **array   ;   int型的指针的指针  int (*array)[5];  int型的大小为5的数组的指针  因为作为左值的数组名都被译成指针,所以以上所有的原型都正确  (array[i][j]被解释为*(*(array+i)+j)  所以不要以为使用array[i][j]形式的地方,他的声明一定是一个二维数组。  2.指针数组的用途:(存贮各行长度不一的表;传递一个字符串数组)   锯齿形字符串数组:   声明一个字符串数组并根据需要分配内存,这样可以大大节省空间  3.以下是函数调用中实参和形参的对应关系  实参        匹配的形参  数组的数组   char a[4][5];       char(*c)[5] ;数组的指针  指针数组   char *a[5];    char **c; 指针的指针  数组指针(行指针)  char (*c)[5];     char (*c)[5];  指针的指针     Char  **c;   char  **c;  (上面暗示着在特定的上下文中数组将改写成指针)  ============================================================*/ #include <stdio.h> #include <stdlib.h> void fun1(char **m) {     printf(\"第1个测试的值为:%c/n\",m[2][3]); } void fun2(char (*m)[10]) {     printf(\"第2个测试的值为:%c/n\",m[2][2]); } void main() {  /*验证上面第三条所说的对应关系*/    char *p[10] = {\"father\",          \"mother\",          \"brother\",          \"sister\"};    fun1(p);    char **q = p;    fun1(q);     //实际验证中,发现形参可以是'char  **c'和'char *c[k](k为任何值)'两种形式    char str[4][10] = {\"father\",\"mother\",\"brother\",\"sister\"};    fun2(str);    char (*str1)[10] = str;  //第二维对应相等    fun2(str1); //执行这个调用时,形参必需是'char (*c)[10]'这个形式,第二维维数不能改 } 程序运行结果为: 第1个测试的值为:t 第2个测试的值为:o","title":"指针数组"},{"content":"----------- android培训、java培训、java学习型技术博客、期待与您交流！ ------------ day11,包package,异常..以及面向对象的重点总结 一.package 1.定义包 在代码的第一条语句使用package关键字定义包名, 包名全部小写, 用\".\"分隔 2.编译运行 编译: javac -d 目录 源文件名 运行: java 包名.类名 3.访问不同包中的类 一个类如果想被其他包中的类使用, 需要在class前面加上public.  类一旦加上public, 必须和文件名同名. 在源代码中直接使用类名形式访问一个类, 默认是找相同包中的类. 如果想访问不同包中的类, 需要在类名前面加上包名. 4.导入包 每次使用其他包中的类都加包名很麻烦, 我们可以使用import关键字导入包, 这样每次使用的时候直接用类名即可. 导入类名: 无论当前包中是否有要找的类, 都去导入的包中找 导入*:    如果当前包中有同名的类, 就在当前包中找, 当前包中没有同名类, 才去导入包中找 5.有包类和无包类的访问 无包的类能不能访问有包的类: 能 有包的类能不能访问无包的类: 不能. 因为不写导入是找同包的类, 并且无包的类无法导入.   * 6.总结: 以后写类都加上包 类前用public修饰, 和文件名同名 导入包用类名方式 编译时加上-d 运行时加上包名 二.jar 1.打jar包 jar cvf jar文件名 文件夹名 文件夹名 2.运行jar包 修改jar文件中的META-INF文件夹中的MANIFEST.MF文件, 添加Main-Class:配置, 指定一个类作为jar文件运行时要找的类 (例：Main-Class: com.baidu.Person) 3.使用jar包中的类 将jar包的绝对路径配置到classpath中, 即可使用其中的类 三.异常 1.什么是异常 异常是程序运行过程中抛出的一些错误, 一旦出现异常, 下面的代码将不再执行.   * 2.异常的分类 Exception和Error有一个共同的父类Throwable, 代表在程序中可以被抛出的对象. Error: 由虚拟机抛出的一些严重的错误, 程序中无法处理. Exception除了RuntimeException: 编译时异常, 编译时必须捕捉或声明. RuntimeException及其子类: 运行时异常, 编译时可以不处理. 3.抛出异常 使用throw关键字可以抛出一个异常对象 抛出一个异常可以通知当前方法的调用者   * 4.处理异常 在运行一段有可能出现异常的代码时, 我们可以对其进行处理, 处理方式有两种 声明: 在当前方法签名最后使用throws关键字声明有可能出现的异常, 方法中调用其他方法如果出现异常, 当前方法中断, 将异常抛出  捕捉: 将有可能出现异常的代码放在try代码块中, 后面跟上catch代码块, 捕捉有可能出现的异常, 如果try中代码出现异常, 就会执行catch代码   * 5.finally finally用来和try配合使用, 只要执行了try中的代码, 就一定会执行finally, 除非使用System.exit(0)退出Java虚拟机 finally中也可以再使用try {} finally{} 代码块, 用来执行多条必须执行的语句   * 6.重写方法时抛出异常问题 子类重写父类方法时, 不能抛出父类没有声明的异常 7.处理多个异常 可以使用throws关键字声明抛出多个异常, 多个异常之间用\",\"分隔 可以将有可能出现异常的代码放在try中, 后面跟上多个catch, 捕捉不同的异常. 注意: 捕捉时父类不能写在子类的上面 8.自定义异常 如果我么希望抛出一个自己定义的异常对象, 那么可以声明一个类继承Exception或者RuntimeException 这样我们自定义类的对象就可以使用throw关键字抛出了 四.面向对象必须会的知识点 1.封装:  会写get和set方法 2.构造函数: 会用构造函数给成员变量赋值 知道什么时候会自动生成构造函数 会用this()调用其他构造函数 3.静态: 了解静态变量和普通变量的区别 了解静态方法和普通方法的区别 4.继承: 会使用子类继承父类 会在子类构造函数中调用父类构造函数 会使用强转 会重写父类方法 5.Object类 会写toString()方法 会写equals()方法(简单实现) 6.多态 明白多态的原理(榨汁机的例子) 7.抽象类和接口 理解抽象类和接口的区别 8.内部类 理解内部类和普通类的区别 会使用匿名内部类 9.package 会定义包 会导入包 会编译运行带包的类 package day11;import java.io.*;import java.sql.*;class MultiExceptionDemo {\t\tpublic static void main(String[] args) {\t\ttry {\t\t\tfun(0);\t\t} catch(FileNotFoundException e) {\t\t\tSystem.out.println(\"出现了 FileNotFoundException\");\t\t} catch(Exception e) {\t\t\tSystem.out.println(\"出现了 Exception\");\t\t} \t}\t\t\tpublic static void fun(int i) throws FileNotFoundException, ClassNotFoundException, SQLException {\t\tswitch(i) {\t\t\tcase 0:\t\t\t\tthrow new FileNotFoundException();\t\t\tcase 1:\t\t\t\tthrow new ClassNotFoundException();\t\t\t\tcase 2:\t\t\t\tthrow new SQLException();\t\t\tdefault:\t\t\t\tSystem.out.println(\"执行成功, 没抛异常!\");\t\t}\t}\t}day12,  .创建线程!!!线程方法,同步,通信 一.创建线程 *** 1.继承Thread 定义类继承Thread类 重写Thread类的run()方法 创建该类对象 调用start()方法即可开启新线程, 新线程会自动执行run()方法 *** 2.实现Runnable 定义类实现Runnable接口 实现Runnable接口的run()方法 创建自定义Runnable对象 创建Thread对象, 将Runnable对象传入Thread类的构造函数 调用start()方法即可开启新线程, 新线程会自动执行Runnable的run()方法 3.使用匿名内部类 new Thread(){public void run(){}}.start(); new Thread(new Runnable(){public void run(){}}).start(); 二.线程常用方法 1.currentThread 静态方法, 获取当前的线程对象 2.getName, setName 获取和设置线程的名字 3.sleep 静态方法, 控制当前线程休眠指定毫秒 4.setDaemon 设置指定线程为守护线程, 守护线程不会单独运行 5.join 当前线程暂停, 等待指定线程执行完毕后再继续 三.同步 1.什么是同步 在多线程并发访问同一资源时, 有可能出现线程安全问题.  为了解决这种问题, 我们就可以使用同步技术. 将多个线程访问资源的代码进行同步.   * 2.同步代码块 将需要同步的代码放在 synchronized(){} 代码块中, 在小括号this中指定锁对象 多段使用相同锁的同步代码块, 同一时间只能执行一个, 必须等待一个执行结束后其他的才能继续执行   * 3.同步方法 如果整个方法内的代码都需要同步, 可以在方法前加上synchronized修饰 只有在同一个类中的几个方法可以使用同步方法的形式进行同步, 如果不同类中的几个方法想要同步, 必须使用同步代码块 因为同步方法默认使用this作为锁对象     4.死锁 多线程并发执行时, 如果多段同步代码嵌套使用, 有可能互相冲突产生死锁, 导致程序阻塞. 在编程的过程中尽量不要将同步代码嵌套使用, 避免产生死锁. 四.通信 1.什么是通信 在多线程并发执行的时候, 可以使用wait()和notify()方法在多个线程间互相通信 2.怎么使用 通信的代码必须写在同步代码中, 必须使用锁对象来调用wait()和notify() wait()方法可以控制当前线程等待, 直到其他线程调用notify()或者notifyAll()方法才被唤醒 package day12;class ThreadDemo2 {\t\tpublic static void main(String[] args) {\t\tSystem.out.println(\"主线程开始\");\t\t\t\t// 创建自定义的Runnable, 创建Thread对象将Runnable传入, 调用Thread的start(). 开启新线程, 新线程就会执行Runnable的run()方法\t\tMyRunnable mr = new MyRunnable();\t\tThread t = new Thread(mr);\t\tt.start();\t\t// 开新线程找run()方法, Thread类的run()方法判断有没有传Runnable, 传了就执行Runnable的run()\t\t\t\tfor (int i = 1; i <= 100; i++)\t\t\tSystem.out.println(\"A \" + i);\t\t\t\tSystem.out.println(\"主线程结束\");\t}\t\t}// 定义类实现Runnable接口class MyRunnable implements Runnable {\t\t// 重写run()方法\tpublic void run() {\t\t// 将新线程要做的事写在run()方法中\t\tfor (int i = 1; i <= 100; i++)\t\t\tSystem.out.println(\"B \" + i);\t}\t} ----------------------- android培训、java培训、java学习型技术博客、期待与您交流！ ---------------------- 详情请查看：http://edu.csdn.net/heima","title":"黑马程序员_JAVA编程基础小结(4)-package,Exception,new Thread()"},{"content":"在编程中使用typedef目的一般有两个，1).给变量一个易记且意义明确的新名字，2).简化一些比较复杂的类型声明。 1. typedef 与struct的问题 Eg.请更改下列程序的错误. typedef struct tagNode {      char *pItem;      pNode pNext; } *pNode; 答案与分析： 新结构建立的过程中遇到了pNext域的声明，类型是pNode，要知道pNode表示的是类型的新名字， 那么在类型本身还没有建立完成的时候，这个类型的新名字也还不存在，也就是 说这个时候编译器根本不认识pNode。 解决这个问题的方法有多种： 1)、 typedef struct tagNode {      char *pItem;      struct tagNode *pNext; } *pNode; 2)、 typedef struct tagNode *pNode; struct tagNode {      char *pItem;      pNode pNext; }; 注意：在这个例子中，你用typedef给一个还未完全声明的类型起新名字。C语言编译器支持这种做法。 3)、规范做法： struct tagNode {      char *pItem;      struct tagNode *pNext; }; typedef struct tagNode *pNode; 2. typedef VS. #define Eg.有下面两种定义pStr数据类型的方法，两者有什么不同？哪一种更好一点？ typedef char* pStr; #define pStr char*; 答案与分析： 通常讲，typedef要比#define要好，特别是在有指针的场合。请看例子： typedef char* pStr1; #define pStr2 char * pStr1 s1, s2; pStr2 s3, s4; 在上述的变量定义中，s1、s2、s3都被定义为char *，而s4则定义成了char，不是我们所预期的指针变量， 根本原因就在于#define只是简单的字符串替换而typedef则是为一个类型起新名字。 上例中define语句必须写成 pStr2 s3, *s4; 这这样才能正常执行。 /* --------------------------------------------------------------------------*/ 问题： 下面的代码中编译器会报一个错误，你知道是哪个语句错了吗？ typedef char * pStr; char string[4] = \"abc\"; const char *p1 = string; const pStr p2 = string; p1++; p2++;","title":"typedef问题"},{"content":"在Win32下以下程序的输出结果是( ) A 10 10  ，B 12 12   ，C 13 13  ，D11 13                       main(  )  {  int  a=12,b=12;  printf(\"%d%d\\n\",a--,++a);   }  答案： VC和gcc下，结果都是 13,12  解析： C标准中并未规定函数参数压栈顺序，但VC和gcc默认都是从右至左压栈。同时，编译器也提供了各种函数调用约定。如在VC中， 若在编译时加入命令行参数_cdecl，则显式使函数参数从右至左压栈，_fascall使程序在可能的情况下使用寄存器传递参数。程序员可以使用这些约定来更改参数调用的顺序。对于此题，printf的后两个参数是表达式，因此压栈前要计算表达式的值。对于++a，它先将a+1，再返回加1后的a并入栈，此时a值为13；对于a--，它先将a赋给一个临时变量，再将a加1，再将临时变量返回并入栈，此时临时变量值为13，a值为12。再将格式字符串入栈。这时，栈内变量情况从栈顶到栈低依次为： 格式字符串， 临时变量：值为13， a：值为12。因此printf输出为13, 12。  说明：   这类问题牵涉到函数参数压栈顺序，往往都和编译器实现相关，实际应用中应尽量避免此类写法。而在一条语句中使用多个自增表达式的结果也不确定，应该少用。     “对于++a，它先将a+1，再返回加1后的a并入栈，此时a值为13；对于a--，它先将a赋给一个临时变量，再将a加1，再将临时变量返回并入栈，此时临时变量值为13，a值为12。再将格式字符串入栈。” 这块描述的不够准确，看了下生成的汇编，重新解释下： 1、计算++a：此时a的值变为13，这时不会将a入栈而是紧接着进行下一步计算； mov  eax, DWORD PTR _a$[ebp] add  eax, 1 mov  DWORD PTR _a$[ebp], eax 2、紧接着计算a--：这里会先将a的值赋给一个临时变量DWORD PTR tv68[ebp]，然后将a减1，此时a的值DWORD PTR _a$[ebp]为12，临时变量DWORD PTR tv68[ebp]的值为13； mov  ecx, DWORD PTR _a$[ebp] mov  DWORD PTR tv68[ebp], ecx mov  edx, DWORD PTR _a$[ebp] sub  edx, 1 mov  DWORD PTR _a$[ebp], edx 3、进行入栈操作：先将a的值DWORD PTR _a$[ebp]入栈，接着将上一步临时变量DWORD PTR tv68[ebp]入栈，然后是字符串入栈，栈顶到栈底依次为：字符串、13、12； mov  eax, DWORD PTR _a$[ebp] push eax mov  ecx, DWORD PTR tv68[ebp] push ecx 这个问题给我的收获是： 1、程序里的表达式并不一定像我们想当然的顺序执行的； 2、不要试图用这种方式去编程，可读性差且结果难以确定； 3、VS里可选的函数调用方式有三种：__cdecl、__fastcall、__stdcall，而默认是__cdecl即函数参数从右至左入栈，而printf的函数原型显式指定为__cdecl：    int __cdecl printf (const char *format, ...)  ","title":"函数参数压栈顺序"},{"content":"    写在前面：三个周之前，我突然想写一个远程升级的程序。那个时候我只是大概知道IAP的意思是在应用编程，但怎么编，我还一无所知。我给自己定下一个个阶段目标，从最基础的代码一点点写起，解决一个又一个的问题。三个周之后，我用自己设计的方法实验了50多次，无一例升级失败。 三个周来，遇到了很多的不解、困惑，甚至是想放弃，但我现在想说的是：很多未知的困难会挡在我们面前，我们会感觉毫无头绪甚至觉得毫无出路忍不住要放弃，但多坚持一下，那些困难不但能烟消云散还能带给我们进步。 本设计是基于LPC2114和Keil MDK（V4.10），但所有支持IAP的处理器都可借鉴本方案，重要的是思想，而不是用什么。 0 引言 在应用编程(IAP)技术为系统在线升级和远程升级提供了良好的解决方案，也为数据存储和现场固件的升级都带来了极大的灵活性。通常可利用芯片的串行口接到计算机的RS232口、通过现有的Internet或、无线网络或者其他通信方式很方便地实现在线以及远程升级和维护。 本文以NXP的LPC2114 ARM微处理器为平台，以Keil MDK为开发工具，阐述IAP的原理、Flash的划分、分散加载机制、中断重映射以及在线升级的实现方案及其优化。本方案使用多种校验技术，最大限度的保障传输数据的正确性；使用bootloader机制，即使因意外事件（断电，编程Flash失败等）造成升级失败后，程序也能返回到升级前的状态。 1 LPC2114的Flash规划 1.1 扇区描述 LPC2114共有128KB片内Flash，共分为16个扇区，分别为0扇区～15扇区，每个扇区为8KB存储空间。其中第15扇区出厂时被固化为Boot Block区，控制复位后的初始化操作，并提供实现Flash 编程的方法。所以用户可用的Flash空间只有120KB。IAP程序固化于Boot Block中，IAP操作是以扇区为单位，并占用片内RAM的高32字节。下表列出LPC2114器件所包含的扇区数和存储器地址. 表1.1 LPC2114 Flash 器件中的扇区 1.2 Flash的扇区划分 本设计将Flash划分为四个区，扇区0存放跳转程序和升级引导程序（Bootloader）。分站上电后执行跳转程序，跳转到用户程序处。用户程序运行过程中，如果接收到升级指令，会从用户程序跳转到引导程序区（Bootloader），接收新程序数据包，完成Flash编程并跳转到新程序区执行程序。扇区1～扇区7为程序存储低区；扇区8～扇区13为程序存储高区；扇区14存放当前程序运行区域标志，如果当前程序运行在高区，该标志区的最低四个字节为0x00010000，如果当前程序运行在低区，该标志区的最低四个字节为0x00008000。 2 IAP的原理与软件设计 2.1 IAP的原理 IAP函数是固化在微处理器内部flash上的一些函数代码，最终的用户程序可以直接通过调用这些函数来对内部flash进行擦除和编程操作。LPC2114微处理器的内部flash有一个块称为Boot Block，位于flash的顶端，可供调用的IAP函数就位于该块中。上电后Boot Block被映射到内部地址空间的顶端，同样IAP函数人口地址也被映射到地址0x7ffffff0处。用户可通过跳转到该地址来调用相应的lAP函数。 2.2 IAP 命令 对于在应用编程来说，应当通过寄存器r0 中的字指针指向存储器(RAM)包含的命令代码和参数来调用IAP 程序。IAP 命令的结果返回到寄存器r1 所指向的返回表。用户可通过传递寄存器r0 和r1 中的相同指针重用命令表来得到结果。参数表应当大到足够保存所有的结果以防结果的数目大于参数的数目。参数传递见图2-1。参数和结果的数目根据IAP命令而有所不同。参数的最大数目为5，由“将RAM 内容复制到Flash”命令传递。结果的最大数目为2，由“扇区查空”命令返回。命令处理程序在接收到一个未定义的命令时发送状态代码INVALID_COMMAND。IAP 程序是thumb 代码，位于地址0x7FFFFFF0。 图2-1 IAP的参数传递 表2-1描述了IAP的命令。 表2-1 IAP 命令汇总 IAP命令 命令代码 描述 准备编程扇区 50 该命令必须在执行“将 RAM 内容复制到Flash”或“擦除扇区”命令之前执行。这两个命令的成功执行会导致相关的扇区再次被保护。该命令不能用于boot 扇区。要准备单个扇区，可将起始和结束扇区号设置为相同值。 将RAM内容复制到Flash 51 该命令用于编程 Flash 存储器。受影响的扇区应当先通过调用“准备写操作的扇区”命令准备。当成功执行复制命令后，扇区将自动受到保护。该命令不能写boot 扇区。 擦除扇区 52 该命令用于擦除片内 Flash 存储器的一个或多个扇区。boot 扇区不能由该命令擦除。要擦除单个扇区可将起始和结束扇区号设定为相同值。 扇区查空 53 该命令用于对片内 Flash 存储器的一个或多个扇区进行查空。要查空单个扇区可将起始和结束扇区号设定为相同值。 读器件ID 54 该命令用于读取器件的 ID 号。 读Boot版本 55 该命令用于读取 boot 代码版本号。 IAP比较 56 该命令用来比较两个地址单元的存储器内容。当源或目标地址包含从地址0 开始的前64字节中的任意一个时，比较的结果不一定正确。前64 字节重新映射到Flash boot 扇区。 2.3 IAP 编程函数接口 IAP 功能可用下面的C 代码来调用。 定义 IAP 程序的入口地址。由于IAP 地址的第0 位是1，因此，当程序计数器转移到该地址时会引起Thumb 指令集的变化。 #define IAP_LOCATION 0x7ffffff1 定义数据结构或指针，将IAP 命令表和结果表传递给IAP 函数 unsigned long command[5]; unsigned long result[2]; 定义函数类型指针，函数包含2 个参数，无返回值。注意：IAP 将函数结果和R1 中的表格基址一同返回。 typedef void (*IAP) (unsigned int [ ] , unsigned int [ ]); IAP iap_entry; 设置函数指针 iap_entry=(IAP) IAP_LOCATION; 使用下面的语句来调用IAP。 iap_entry (command , result); Flash 存储器在写或擦除操作过程中不可被访问。执行Flash 写/擦除操作的IAP 命令 使用片内RAM 顶端的32 个字节空间。如果应用程序中允许IAP 编程，那么用户程序不应 使用该空间。 3 LPC2114升级实现过程 由于在升级程序软件设计中，分散加载机制、中断向量的重映射、软中断等的实现还与所使用的编译器紧密相关，因此，本文结合Keil MDK（V4.10）编译工具，来详细阐述升级程序的实现过程。 3.1 总体思路 分站上电后，首先运行位于Flash 0x000～0x3FF中的跳转程序。跳转程序会读取位于14扇区的当前程序运行标志，如果该扇区的最低四个字节为0x00010000，表示当前程序运行在高区，跳转程序会跳转到Flash的0x00010000处执行用户程序；如果该标志区的最低四个字节为0x00008000，表示当前程序运行在低区，跳转程序会跳转到Flash的0x00002000处执行用户程序。用户程序正常执行后，会按照设计进行正常的程序采集、数据处理传送。当接收到升级命令后，用户程序会跳转到Flash的0x00000400处的Bootloader处进行升级的一些操作。当升级成功后，Bootloader程序更新当前程序运行区标志，程序跳转到新程序处运行，如果升级不成功，返回升级前的程序。 流程图如下所示： 3.2 跳转程序的设计 跳转程序是分站上电后最先运行的程序，根据当前程序运行区标志，跳转到相应的用户程序区执行。本段程序占用Flash的最低1K字节空间，与Bootloader同在第0扇区。 跳转程序的启动代码仅初始化堆栈，不使用PLL和存储加速功能。代码1描述了跳转程序的主要启动代码。 ; Enter User Mode and set its Stack Pointer MSR CPSR_c, #Mode_USR MOV SP, R0 SUB SL, SP, #USR_Stack_Size ; Enter the C code IMPORT __main LDR R0, =__main BX R0 代码1：跳转程序启动代码 当跳转程序确定要跳转到高区用户程序或者低区用户程序后，使用函数指针跳转到0x00010000处（高区用户函数入口地址）或0x00002000处（低区用户函数入口地址）。 定义函数指针： void (*UserProgram)() ; 指定入口地址： UserProgram = (void (*)()) (0x00010000)； UserProgram = (void (*)()) (0x00002000)； 实现跳转： (*UserProgram)() ； 要将用户代码精确定位到Flash的0x00010000处（高区用户函数入口地址）或0x00002000处（低区用户函数入口地址），需要使用编译器的分散加载机制，将在Bootloader中详细描述实现过程。 另外，跳转程序还在烧录代码的同时初始化当前程序运行区标志，即对Flash的0x0001C000地址处写入0x00008000，表示当前用户程序在低区。主要使用了编译器的__at关键字：精确定位变量。需要注意的是，使用该关键字必须包含头文件absacc.h。 const uint32 x __at(0x0001C000)=0x00008000; //初始化用户程序标志区,默认运行低区 3.3 升级程序Bootloader的设计 升级程序的好坏，在很大程度上取决于Bootloader设计的好坏。 一个优秀的IAP升级Bootloader，必须做好升级中出现故障等异常的处理。保证系统不会崩溃，即使升级失败，也能返回升级前的程序。 Ø 有升级指令，进行初始化工作（串口、定时器、看门狗） Ø 接收升级数据包，检测帧头、长度、帧号、数据区校验，最大程度的保证升级数据的完整性、正确性。 Ø 实时检测接收状态，10 S内没有接收到数据或接收到的数据包都是错的，则退出升级，返回原程序。 Ø 接收的数据按照512字节一组写入Flash，写入后再读出与原数据进行对比校验，校验成功后，本次编程Flash成功。允许连续3次编程Flash，三次都不成功，退出升级程序，执行原程序。 Ø 升级成功后，更新当前程序运行区标志，跳转到新程序，同时原程序保存。 本设计的Bootload位于Flash的0x400开始的扇区0存储区内，使用分散加载机制，将程序的入口地址定位到0x00000400处。当用户程序接收到升级指令后，就会使用函数指针跳转到这个入口处。 3.3.1 使用IAP 图3-1 描述了使用IAP编程Flash所必须的步骤。 3.3.1.1 定义系统参数 在使用IAP前，需要定义一些系统参数，比如系统时钟、IAP中断入口、输入输出缓存。 #define IAP_CLK 11059200UL #define IAP_LOCATION 0x7FFFFFF1 typedef void(*IAP)(uint32 [],uint32 []); //定义函数类型指针 IAP iap_entry=(IAP)IAP_LOCATION; //设置函数指针 unsigned long command[5] = {0,0,0,0,0}; unsigned long result[2]= {0,0}; 代码3-1：定义系统参数 3.3.1.2 选择扇区 在任何擦除和编程Flash之前，必须选中扇区，可以选中一个或多个。 /****************************************************************** * 名称：SelSector() * 功能：IAP操作扇区选择，命令代码50。 * 入口参数：sec1 起始扇区 * sec2 终止扇区 * 出口参数：IAP返回值(paramout缓冲区) CMD_SUCCESS,BUSY,INVALID_SECTOR *********************************************************************/ void SelSector(uint8 sec1, uint8 sec2) { paramin[0] = IAP_SELSECTOR; // 设置命令字 paramin[1] = sec1; // 设置参数 paramin[2] = sec2; iap_entry(paramin, paramout); // 调用IAP服务程序 } 代码3-2 选择扇区 3.3.1.3 擦除扇区 在编程Flash前必须执行擦除操作，如果某个扇区已经擦除，就不需要再次擦除。可以一次擦除一个或多个扇区。 /****************************************************************** * 名称：EraseSector() * 功能：扇区擦除，命令代码52。 * 入口参数：sec1 起始扇区 * sec2 终止扇区 * 出口参数：IAP返回值(paramout缓冲区) CMD_SUCCESS,BUSY,INVALID_SECTOR ************************************************************************/ void EraseSector(uint8 sec1, uint8 sec2) { paramin[0] = IAP_ERASESECTOR; // 设置命令字 paramin[1] = sec1; // 设置参数 paramin[2] = sec2; paramin[3] = Fosc/1000; // 当不使用PLL功能时，Fcclk=Fosc iap_entry(paramin, paramout); // 调用IAP服务程序 代码3-3 擦除扇区 3.3.1.4 编程扇区 通过这个过程，数据可以从RAM中编程到片内Flash中。 注： 1. 数据只能从片内SRAM编程到片内Flash。 2. 片内Flash的地址必须512字节对齐。 3. 片内RAM应位于局部总线，即USB或以太网的SRAM不可以使用。 4. 每一次编程字节应该是512、1024、4096、8192中的一个。 /********************************************************************* * 名称：RamToFlash() * 功能：复制RAM的数据到FLASH，命令代码51。 * 入口参数：dst 目标地址，即FLASH起始地址。以512字节为分界 * src 源地址，即RAM地址。地址必须字对齐 * no 复制字节个数，为512/1024/4096/8192 * 出口参数：IAP返回值(paramout缓冲区) CMD_SUCCESS,SRC_ADDR_ERROR,DST_ADDR_ERROR, SRC_ADDR_NOT_MAPPED,DST_ADDR_NOT_MAPPED,COUNT_ERROR,BUSY,未选择扇区 ********************************************************************/ void RamToFlash(uint32 dst, uint32 src, uint32 no) { paramin[0] = IAP_RAMTOFLASH; // 设置命令字 paramin[1] = dst; // 设置参数 paramin[2] = src; paramin[3] = no; paramin[4] = Fosc/1000; // 当不使用PLL功能时，Fcclk=Fosc iap_entry(paramin, paramout); // 调用IAP服务程序 } 代码3-4 编程扇区 3.3.1.5 比较数据 通过这个函数，可以检查写入Flash中的数据和RAM中的是否相同。 注意源地址、目标地址和字节数必须是4的倍数。可使用Keil MDK提供的关键字__align(n) 来指定n字节对齐。 /******************************************************************** * 名称：Compare() * 功能：校验数据，命令代码56。 * 入口参数：dst 目标地址，即RAM/FLASH起始地址。地址必须字对齐 * src 源地址，即FLASH/RAM地址。地址必须字对齐 * no 复制字节个数，必须能被4整除 * 出口参数：IAP返回值(paramout缓冲区) CMD_SUCCESS,COMPARE_ERROR,ADDR_ERROR ******************************************************************/ void Compare(uint32 dst, uint32 src, uint32 no) { paramin[0] = IAP_COMPARE; // 设置命令字 paramin[1] = dst; // 设置参数 paramin[2] = src; paramin[3] = no; iap_entry(paramin, paramout); // 调用IAP服务程序 代码3-5 比较数据 3.3.2 IAP编程期间的中断管理 LPC2114片上Flash在擦除/编程期间绝不可被中断打断。但Bootloader中定时和串口接收又使用了中断，因此必须在擦除/编程之前禁止总中断，待操作完成后再使能总中断。Bootloader运行在用户模式下，不具有禁止/使能中断的权力，所以在本设计中使用软中断禁止/使能总中断。Keil MDK提供了关键字__svc来触发软中断。 软中断函数声明： __svc(0x00) void EnableIrq(void); //使能中断,软中断0 __svc(0x01) void DisableIrq(void); //禁止中断,软中断1 软中断函数代码： /* ********************************************************************* * 功 能:禁止中断 * 描 述:利用软中断实现在用户模式下调用函数关中断 *********************************************************************/ void DisableIrqFunc(void) { int temp; __asm { MRS temp,SPSR ORR temp,temp,#0x80 MSR SPSR_c,temp } } /* ******************************************************************** * 功 能:使能中断 * 描 述:利用软中断实现在用户模式下调用函数开中断 ******************************************************************** */ void EnableIrqFunc(void) { int temp; __asm { MRS temp,SPSR BIC temp,temp,#0x80 MSR SPSR_c,temp } } 代码3-6 禁止/使能总中断 更改启动代码，挂接软中断入口： ;软中断入口 EXPORT SWI_Handler extern EnableIrq1 extern DisableIrq1 SWI_Handler STMFD SP!, {R0,R12,LR} ；入栈 LDR R0, [LR,#-4] ；取软中断指令，软中断号就包含其中 BIC R0,R0,#0xFF000000 CMP R0,#0 ；判断是否软中断0 BLEQ EnableIrqFunc BLNE DisableIrqFunc LDMFD SP!,{R0,R12,PC}^ 代码3-7 挂接软中断入口 在程序中,如果想禁止中断,只需使用DisableIrq()；若是能中断，只需使用EnableIrq()。 3.3.3 使用分散加载机制精确定位入口地址 应用程序接收到升级指令后，会跳转到0x00000400处执行Bootloader升级程序。因此Bootloader程序的入口地址必须精确定位到0x00000400处。这可以使用Keil MDK提供的分散加载机制来完成。 分散加载代码见代码3-8. ; ************************************************************* ; *** Scatter-Loading Description File generated by uVision *** ; ************************************************************* LR_IROM1 0x00000400 0x00001C00 { ; load region size_region ER_IROM1 0x00000400 0x00001C00 { ; load address = execution address *.o (RESET, +First) *(InRoot$$Sections) .ANY (+RO) } RW_IRAM1 0x40000040 0x00003FA0 { ; RW data .ANY (+RW +ZI) } } 代码3-8 分散加载代码 这段代码显示出Bootloader程序从0x00000400处开始执行，最多占用0x1C00字节的Flash空间。另外，该程序的RAM从0x40000040开始，长度为0x3FA0个字节。这样RAM的低64字节保留给中断向量映射使用，高32字节保留给IAP编程使用。 3.3.4 中断向量的重映射 Bootloader的起始地址位于0x00000400，中断向量也从这一地址开始存储。但默认情况下ARM发生异常时，会跳转到0x00000000处的64字节中断向量区域执行相应操作，所以为了使Bootloader能相应中断，必须将位于0x00000400开始的64字节中断向量表重映射到RAM的低区。LPC2114使用向寄存器MEMMAP写入0x02来完成这一过程。 代码3-9 描述了中断向量重映射的过程。 ; Copy Exception Vectors to Internal RAM --------------------------------------- ADR R8, Vectors ; 源地址 LDR R9, =RAM_BASE ; 目标地址，这里是0x40000000 LDMIA R8!, {R0-R7} ; 装载向量表 STMIA R9!, {R0-R7} ; 存储向量表 LDMIA R8!, {R0-R7} ; 装载处理程序地址 STMIA R9!, {R0-R7} ; 存储处理程序地址 ; Memory Mapping (when Interrupt Vectors are in RAM) MEMMAP EQU 0xE01FC040 ; Memory Mapping Control IF :DEF:REMAP LDR R0, =MEMMAP IF :DEF:EXTMEM_MODE MOV R1, #3 ELIF :DEF:RAM_MODE MOV R1, #2 ELSE MOV R1, #1 ENDIF STR R1, [R0] ENDIF 代码3-9 中断向量重映射 由于Keil MDK提供的启动代码中使用条件编译指令，所以，要想正确的执行中断向量重映射，还需要在Keil MDK编译器工程设置Options for target“你的工程目标名”下的Asm标签中找到Define编辑框，在编辑框中键入“REMAP RAM_MODE”。如图3-2所示 图3-2 注意：在擦除/编程Flash的时候还应该禁止PLL、存储器加速模块。 3.4 用户程序的设计 用户程序运行在高区（扇区8～13）或者低区（扇区1～7），用于实现数据的采集、处理和上传等等，用户程序除本身功能的要求外，还需要注意： Ø 使用分散加载机制，将程序入口精确定位到0x00010000（高区）或0x00008000（低区）。 Ø 进行中断向量重映射，映射到RAM最底处。 4 通讯协议与上位机软件 4.1 Intel的hex格式 Intel hex文件是记录文本行的ASCII文本文件，在Intel HEX文件中，每一行是一个HEX记录，由十六进制数组成的机器码或者数据常量。一个数据记录以一个回车和一个换行结束。 一个Intel HEX文件可以包含任意多的十六进制记录,每条记录有五个域,下面是一个记录的格式. : LL AAAA TT [DD...] CC 每一组字母是独立的一域,每一个字母是一个十六进制数字,每一域至少由两个十六进制数字组成,下面是字节的描述. :冒号 是每一条Intel HEX记录的开始 LL 是这条记录的长度域,他表示数据(dd)的字节数目. AAAA 是地址域,他表示数据的起始地址 TT 这个域表示这条HEX记录的类型,他有可能是下面这几种类型 00 ----数据记录 01 ----文件结束记录 02 ----扩展段地址记录 04 ----扩展线性地址记录 DD 是数据域,表示一个字节的数据,一个记录可能有多个数据字节,字节数目可以查看LL域的说明。 CC 是效验和域,表示记录的效验和,计算方法是将本条记录冒号开始的所有字母（包括校验字节）相加之后等于0x00。 一个Intel HEX文件必须有一个文件结束记录,这个记录的类型域必须是01, 一个EOF记录总是这样: :00000001FF 00是记录中数据字节的数目 0000这个地址对于EOF记录来说无任何意义 01记录类型是01(文件结束记录标示) 4.2 对上位机软件的要求 Ø 上位机具备解析重组Intel HEX文件的能力. Ø 上位机软件应能识别分站发来的应答信号并做出正确的响应。 Ø 上位机应能够检验代码的完整性。 Ø 上位机能根据分站发出的程序所在高区或低区标志，自动判别当前升级程序是否和升级区域相对应。 5 实验数据 为验证升级程序的稳定性，对分站进行重上电、复位、远程升级等一些列实验，实验记录及如下。 1. 测试程序跳转功能.程序在上电或复位之后，应顺利跳转到用户程序。 2. 测试Bootloader（一）。上位机发送升级命令但不发送升级数据包，程序应能进入Bootloader并发送当前程序所在的区域（高区或者低区代号），10S后程序应跳转到用户程序。 3.测试Bootloader（二）。上位机发送升级命令，发送升级数据包，但发送到一半时停止发送。程序在10S后应能跳转到用户程序区。 4.测试Bootloader（三）。上位机发送升级命令，发送升级数据包，但发送中途给分站断电，重新上电后，应还能执行原来的程序。 5.测试Bootloader（四）。上位机发送升级命令，发送完成升级数据包。程序应能接收升级数据包并编程Flash，完成用户程序的更新，更新用户程序后，跳转到新的用户程序。 6.总结 本次升级方案虽然是以LPC2114为基础的，但任何具有IAP功能的单片机、ARM都可使用本设计方案。 设计的重点在于如何保证升级的安全性，分站采取了一些列校验、超时处理以及看门狗等措施，一是保障升级数据包的正确传送，二是即使升级失败也能退回原升级程序。上位机的校验措施需相关部门配合。从实验数据来看，进行了几十次的远程升级，未有一例失败，安全性能可以得到保证。 7.参考文献： 1. 周立功等 ARM微控制器基础与实战（第二版） 北京航空航天大学出版社 2005 2. LPC2114/2124/2212/2214 使用指南.Pdf 广州周立功单片机发展有限公司 3. 韦文祥 朱志杰 车琳娜 郭宝泉 基于LPC21 24的一个远程系统软件升级方案 单片机与嵌入式系统应用 2006第三期 4. 许文杰 丁志冈 张 泉基于ARM 处理器的IAP设计及应用 计算机应用与软件 2009第3期 5. 姜晓梅 李祥和 任朝荣 姚明基于ARM的IAP在线及远程升级技术 计算机应用 2008第二期 6. RealView 编译工具-编译器参考指南.pdf ARM Limited 2009.3 7. RealView Compilation Tools（连接器用户指南）.pdf ARM Limited 2009.3 8. RealView 编译工具-编译器用户指南.pdf ARM Limited 2009.1 9. RealView 编译工具-链接器参考指南.pdf ARM Limited 2008.9 10. Intel HEX文件格式 11. LPC2000 secondary bootloader for code update using IAP NXP Semiconductors 2009.5.26   后记：分散加载文件，软中断，中断向量表重映射，变量对齐，精确定位变量等等这些东西的详细讲解在我的参考资料上都能找的到，发现问题并能解决它，是件很美妙的事情，所以我没打算也没时间详细写这些东西的用法。 需要说的是，我在设计的时候走了一个弯路，现在想想还觉得挺可笑。我以为上面讲的东西要在一个工程里面实现才好，这样才能生成一个.hex可烧录文件，可以一次性的将用户程序、Bootloader程序烧写进处理器，我想弯了。正确的做法是建四个工程：跳转程序、Bootloader、用户低区程序、用户高区程序。如果你懂了.hex文件的格式，就完全可以将跳转程序、Bootloader和用户低区程序（或者跳转程序、Bootloader和用户高区程序）这三个工程生成的.hex文件合成一个。灵活多变的处理问题，这是我最大的收获。 后记的后记: 很多同学看完后都希望得到源码,这种心情我是理解的,最初的时候我也希望有一套别人的源码的,毕竟这样可以进行的快点.所以我将一个远程升级的例子放在下面的链接里,大家想看看的就去下载吧,这个不是我产品中用到的,因为我的代码毕竟是含有公司的一些信息.如果我最近有时间,会把其中的英文文档翻译一下的. 链接:http://download.csdn.net/detail/zhzht19861011/3618966     写在前面：三个周之前，我突然想写一个远程升级的程序。那个时候我只是大概知道IAP的意思是在应用编程，但怎么编，我还一无所知。我给自己定下一个个阶段目标，从最基础的代码一点点写起，解决一个又一个的问题。三个周之后，我用自己设计的方法实验了50多次，无一例升级失败。 三个周来，遇到了很多的不解、困惑，甚至是想放弃，但我现在想说的是：很多未知的困难会挡在我们面前，我们会感觉毫无头绪甚至觉得毫无出路忍不住要放弃，但多坚持一下，那些困难不但能烟消云散还能带给我们进步。 本设计是基于LPC2114和Keil MDK（V4.10），但所有支持IAP的处理器都可借鉴本方案，重要的是思想，而不是用什么。 0 引言 在应用编程(IAP)技术为系统在线升级和远程升级提供了良好的解决方案，也为数据存储和现场固件的升级都带来了极大的灵活性。通常可利用芯片的串行口接到计算机的RS232口、通过现有的Internet或、无线网络或者其他通信方式很方便地实现在线以及远程升级和维护。 本文以NXP的LPC2114 ARM微处理器为平台，以Keil MDK为开发工具，阐述IAP的原理、Flash的划分、分散加载机制、中断重映射以及在线升级的实现方案及其优化。本方案使用多种校验技术，最大限度的保障传输数据的正确性；使用bootloader机制，即使因意外事件（断电，编程Flash失败等）造成升级失败后，程序也能返回到升级前的状态。 1 LPC2114的Flash规划 1.1 扇区描述 LPC2114共有128KB片内Flash，共分为16个扇区，分别为0扇区～15扇区，每个扇区为8KB存储空间。其中第15扇区出厂时被固化为Boot Block区，控制复位后的初始化操作，并提供实现Flash 编程的方法。所以用户可用的Flash空间只有120KB。IAP程序固化于Boot Block中，IAP操作是以扇区为单位，并占用片内RAM的高32字节。下表列出LPC2114器件所包含的扇区数和存储器地址. 表1.1 LPC2114 Flash 器件中的扇区 1.2 Flash的扇区划分 本设计将Flash划分为四个区，扇区0存放跳转程序和升级引导程序（Bootloader）。分站上电后执行跳转程序，跳转到用户程序处。用户程序运行过程中，如果接收到升级指令，会从用户程序跳转到引导程序区（Bootloader），接收新程序数据包，完成Flash编程并跳转到新程序区执行程序。扇区1～扇区7为程序存储低区；扇区8～扇区13为程序存储高区；扇区14存放当前程序运行区域标志，如果当前程序运行在高区，该标志区的最低四个字节为0x00010000，如果当前程序运行在低区，该标志区的最低四个字节为0x00008000。 2 IAP的原理与软件设计 2.1 IAP的原理 IAP函数是固化在微处理器内部flash上的一些函数代码，最终的用户程序可以直接通过调用这些函数来对内部flash进行擦除和编程操作。LPC2114微处理器的内部flash有一个块称为Boot Block，位于flash的顶端，可供调用的IAP函数就位于该块中。上电后Boot Block被映射到内部地址空间的顶端，同样IAP函数人口地址也被映射到地址0x7ffffff0处。用户可通过跳转到该地址来调用相应的lAP函数。 2.2 IAP 命令 对于在应用编程来说，应当通过寄存器r0 中的字指针指向存储器(RAM)包含的命令代码和参数来调用IAP 程序。IAP 命令的结果返回到寄存器r1 所指向的返回表。用户可通过传递寄存器r0 和r1 中的相同指针重用命令表来得到结果。参数表应当大到足够保存所有的结果以防结果的数目大于参数的数目。参数传递见图2-1。参数和结果的数目根据IAP命令而有所不同。参数的最大数目为5，由“将RAM 内容复制到Flash”命令传递。结果的最大数目为2，由“扇区查空”命令返回。命令处理程序在接收到一个未定义的命令时发送状态代码INVALID_COMMAND。IAP 程序是thumb 代码，位于地址0x7FFFFFF0。 图2-1 IAP的参数传递 表2-1描述了IAP的命令。 表2-1 IAP 命令汇总 IAP命令 命令代码 描述 准备编程扇区 50 该命令必须在执行“将 RAM 内容复制到Flash”或“擦除扇区”命令之前执行。这两个命令的成功执行会导致相关的扇区再次被保护。该命令不能用于boot 扇区。要准备单个扇区，可将起始和结束扇区号设置为相同值。 将RAM内容复制到Flash 51 该命令用于编程 Flash 存储器。受影响的扇区应当先通过调用“准备写操作的扇区”命令准备。当成功执行复制命令后，扇区将自动受到保护。该命令不能写boot 扇区。 擦除扇区 52 该命令用于擦除片内 Flash 存储器的一个或多个扇区。boot 扇区不能由该命令擦除。要擦除单个扇区可将起始和结束扇区号设定为相同值。 扇区查空 53 该命令用于对片内 Flash 存储器的一个或多个扇区进行查空。要查空单个扇区可将起始和结束扇区号设定为相同值。 读器件ID 54 该命令用于读取器件的 ID 号。 读Boot版本 55 该命令用于读取 boot 代码版本号。 IAP比较 56 该命令用来比较两个地址单元的存储器内容。当源或目标地址包含从地址0 开始的前64字节中的任意一个时，比较的结果不一定正确。前64 字节重新映射到Flash boot 扇区。 2.3 IAP 编程函数接口 IAP 功能可用下面的C 代码来调用。 定义 IAP 程序的入口地址。由于IAP 地址的第0 位是1，因此，当程序计数器转移到该地址时会引起Thumb 指令集的变化。 #define IAP_LOCATION 0x7ffffff1 定义数据结构或指针，将IAP 命令表和结果表传递给IAP 函数 unsigned long command[5]; unsigned long result[2]; 定义函数类型指针，函数包含2 个参数，无返回值。注意：IAP 将函数结果和R1 中的表格基址一同返回。 typedef void (*IAP) (unsigned int [ ] , unsigned int [ ]); IAP iap_entry; 设置函数指针 iap_entry=(IAP) IAP_LOCATION; 使用下面的语句来调用IAP。 iap_entry (command , result); Flash 存储器在写或擦除操作过程中不可被访问。执行Flash 写/擦除操作的IAP 命令 使用片内RAM 顶端的32 个字节空间。如果应用程序中允许IAP 编程，那么用户程序不应 使用该空间。 3 LPC2114升级实现过程 由于在升级程序软件设计中，分散加载机制、中断向量的重映射、软中断等的实现还与所使用的编译器紧密相关，因此，本文结合Keil MDK（V4.10）编译工具，来详细阐述升级程序的实现过程。 3.1 总体思路 分站上电后，首先运行位于Flash 0x000～0x3FF中的跳转程序。跳转程序会读取位于14扇区的当前程序运行标志，如果该扇区的最低四个字节为0x00010000，表示当前程序运行在高区，跳转程序会跳转到Flash的0x00010000处执行用户程序；如果该标志区的最低四个字节为0x00008000，表示当前程序运行在低区，跳转程序会跳转到Flash的0x00002000处执行用户程序。用户程序正常执行后，会按照设计进行正常的程序采集、数据处理传送。当接收到升级命令后，用户程序会跳转到Flash的0x00000400处的Bootloader处进行升级的一些操作。当升级成功后，Bootloader程序更新当前程序运行区标志，程序跳转到新程序处运行，如果升级不成功，返回升级前的程序。 流程图如下所示： 3.2 跳转程序的设计 跳转程序是分站上电后最先运行的程序，根据当前程序运行区标志，跳转到相应的用户程序区执行。本段程序占用Flash的最低1K字节空间，与Bootloader同在第0扇区。 跳转程序的启动代码仅初始化堆栈，不使用PLL和存储加速功能。代码1描述了跳转程序的主要启动代码。 ; Enter User Mode and set its Stack Pointer MSR CPSR_c, #Mode_USR MOV SP, R0 SUB SL, SP, #USR_Stack_Size ; Enter the C code IMPORT __main LDR R0, =__main BX R0 代码1：跳转程序启动代码 当跳转程序确定要跳转到高区用户程序或者低区用户程序后，使用函数指针跳转到0x00010000处（高区用户函数入口地址）或0x00002000处（低区用户函数入口地址）。 定义函数指针： void (*UserProgram)() ; 指定入口地址： UserProgram = (void (*)()) (0x00010000)； UserProgram = (void (*)()) (0x00002000)； 实现跳转： (*UserProgram)() ； 要将用户代码精确定位到Flash的0x00010000处（高区用户函数入口地址）或0x00002000处（低区用户函数入口地址），需要使用编译器的分散加载机制，将在Bootloader中详细描述实现过程。 另外，跳转程序还在烧录代码的同时初始化当前程序运行区标志，即对Flash的0x0001C000地址处写入0x00008000，表示当前用户程序在低区。主要使用了编译器的__at关键字：精确定位变量。需要注意的是，使用该关键字必须包含头文件absacc.h。 const uint32 x __at(0x0001C000)=0x00008000; //初始化用户程序标志区,默认运行低区 3.3 升级程序Bootloader的设计 升级程序的好坏，在很大程度上取决于Bootloader设计的好坏。 一个优秀的IAP升级Bootloader，必须做好升级中出现故障等异常的处理。保证系统不会崩溃，即使升级失败，也能返回升级前的程序。 Ø 有升级指令，进行初始化工作（串口、定时器、看门狗） Ø 接收升级数据包，检测帧头、长度、帧号、数据区校验，最大程度的保证升级数据的完整性、正确性。 Ø 实时检测接收状态，10 S内没有接收到数据或接收到的数据包都是错的，则退出升级，返回原程序。 Ø 接收的数据按照512字节一组写入Flash，写入后再读出与原数据进行对比校验，校验成功后，本次编程Flash成功。允许连续3次编程Flash，三次都不成功，退出升级程序，执行原程序。 Ø 升级成功后，更新当前程序运行区标志，跳转到新程序，同时原程序保存。 本设计的Bootload位于Flash的0x400开始的扇区0存储区内，使用分散加载机制，将程序的入口地址定位到0x00000400处。当用户程序接收到升级指令后，就会使用函数指针跳转到这个入口处。 3.3.1 使用IAP 图3-1 描述了使用IAP编程Flash所必须的步骤。 3.3.1.1 定义系统参数 在使用IAP前，需要定义一些系统参数，比如系统时钟、IAP中断入口、输入输出缓存。 #define IAP_CLK 11059200UL #define IAP_LOCATION 0x7FFFFFF1 typedef void(*IAP)(uint32 [],uint32 []); //定义函数类型指针 IAP iap_entry=(IAP)IAP_LOCATION; //设置函数指针 unsigned long command[5] = {0,0,0,0,0}; unsigned long result[2]= {0,0}; 代码3-1：定义系统参数 3.3.1.2 选择扇区 在任何擦除和编程Flash之前，必须选中扇区，可以选中一个或多个。 /****************************************************************** * 名称：SelSector() * 功能：IAP操作扇区选择，命令代码50。 * 入口参数：sec1 起始扇区 * sec2 终止扇区 * 出口参数：IAP返回值(paramout缓冲区) CMD_SUCCESS,BUSY,INVALID_SECTOR *********************************************************************/ void SelSector(uint8 sec1, uint8 sec2) { paramin[0] = IAP_SELSECTOR; // 设置命令字 paramin[1] = sec1; // 设置参数 paramin[2] = sec2; iap_entry(paramin, paramout); // 调用IAP服务程序 } 代码3-2 选择扇区 3.3.1.3 擦除扇区 在编程Flash前必须执行擦除操作，如果某个扇区已经擦除，就不需要再次擦除。可以一次擦除一个或多个扇区。 /****************************************************************** * 名称：EraseSector() * 功能：扇区擦除，命令代码52。 * 入口参数：sec1 起始扇区 * sec2 终止扇区 * 出口参数：IAP返回值(paramout缓冲区) CMD_SUCCESS,BUSY,INVALID_SECTOR ************************************************************************/ void EraseSector(uint8 sec1, uint8 sec2) { paramin[0] = IAP_ERASESECTOR; // 设置命令字 paramin[1] = sec1; // 设置参数 paramin[2] = sec2; paramin[3] = Fosc/1000; // 当不使用PLL功能时，Fcclk=Fosc iap_entry(paramin, paramout); // 调用IAP服务程序 代码3-3 擦除扇区 3.3.1.4 编程扇区 通过这个过程，数据可以从RAM中编程到片内Flash中。 注： 1. 数据只能从片内SRAM编程到片内Flash。 2. 片内Flash的地址必须512字节对齐。 3. 片内RAM应位于局部总线，即USB或以太网的SRAM不可以使用。 4. 每一次编程字节应该是512、1024、4096、8192中的一个。 /********************************************************************* * 名称：RamToFlash() * 功能：复制RAM的数据到FLASH，命令代码51。 * 入口参数：dst 目标地址，即FLASH起始地址。以512字节为分界 * src 源地址，即RAM地址。地址必须字对齐 * no 复制字节个数，为512/1024/4096/8192 * 出口参数：IAP返回值(paramout缓冲区) CMD_SUCCESS,SRC_ADDR_ERROR,DST_ADDR_ERROR, SRC_ADDR_NOT_MAPPED,DST_ADDR_NOT_MAPPED,COUNT_ERROR,BUSY,未选择扇区 ********************************************************************/ void RamToFlash(uint32 dst, uint32 src, uint32 no) { paramin[0] = IAP_RAMTOFLASH; // 设置命令字 paramin[1] = dst; // 设置参数 paramin[2] = src; paramin[3] = no; paramin[4] = Fosc/1000; // 当不使用PLL功能时，Fcclk=Fosc iap_entry(paramin, paramout); // 调用IAP服务程序 } 代码3-4 编程扇区 3.3.1.5 比较数据 通过这个函数，可以检查写入Flash中的数据和RAM中的是否相同。 注意源地址、目标地址和字节数必须是4的倍数。可使用Keil MDK提供的关键字__align(n) 来指定n字节对齐。 /******************************************************************** * 名称：Compare() * 功能：校验数据，命令代码56。 * 入口参数：dst 目标地址，即RAM/FLASH起始地址。地址必须字对齐 * src 源地址，即FLASH/RAM地址。地址必须字对齐 * no 复制字节个数，必须能被4整除 * 出口参数：IAP返回值(paramout缓冲区) CMD_SUCCESS,COMPARE_ERROR,ADDR_ERROR ******************************************************************/ void Compare(uint32 dst, uint32 src, uint32 no) { paramin[0] = IAP_COMPARE; // 设置命令字 paramin[1] = dst; // 设置参数 paramin[2] = src; paramin[3] = no; iap_entry(paramin, paramout); // 调用IAP服务程序 代码3-5 比较数据 3.3.2 IAP编程期间的中断管理 LPC2114片上Flash在擦除/编程期间绝不可被中断打断。但Bootloader中定时和串口接收又使用了中断，因此必须在擦除/编程之前禁止总中断，待操作完成后再使能总中断。Bootloader运行在用户模式下，不具有禁止/使能中断的权力，所以在本设计中使用软中断禁止/使能总中断。Keil MDK提供了关键字__svc来触发软中断。 软中断函数声明： __svc(0x00) void EnableIrq(void); //使能中断,软中断0 __svc(0x01) void DisableIrq(void); //禁止中断,软中断1 软中断函数代码： /* ********************************************************************* * 功 能:禁止中断 * 描 述:利用软中断实现在用户模式下调用函数关中断 *********************************************************************/ void DisableIrqFunc(void) { int temp; __asm { MRS temp,SPSR ORR temp,temp,#0x80 MSR SPSR_c,temp } } /* ******************************************************************** * 功 能:使能中断 * 描 述:利用软中断实现在用户模式下调用函数开中断 ******************************************************************** */ void EnableIrqFunc(void) { int temp; __asm { MRS temp,SPSR BIC temp,temp,#0x80 MSR SPSR_c,temp } } 代码3-6 禁止/使能总中断 更改启动代码，挂接软中断入口： ;软中断入口 EXPORT SWI_Handler extern EnableIrq1 extern DisableIrq1 SWI_Handler STMFD SP!, {R0,R12,LR} ；入栈 LDR R0, [LR,#-4] ；取软中断指令，软中断号就包含其中 BIC R0,R0,#0xFF000000 CMP R0,#0 ；判断是否软中断0 BLEQ EnableIrqFunc BLNE DisableIrqFunc LDMFD SP!,{R0,R12,PC}^ 代码3-7 挂接软中断入口 在程序中,如果想禁止中断,只需使用DisableIrq()；若是能中断，只需使用EnableIrq()。 3.3.3 使用分散加载机制精确定位入口地址 应用程序接收到升级指令后，会跳转到0x00000400处执行Bootloader升级程序。因此Bootloader程序的入口地址必须精确定位到0x00000400处。这可以使用Keil MDK提供的分散加载机制来完成。 分散加载代码见代码3-8. ; ************************************************************* ; *** Scatter-Loading Description File generated by uVision *** ; ************************************************************* LR_IROM1 0x00000400 0x00001C00 { ; load region size_region ER_IROM1 0x00000400 0x00001C00 { ; load address = execution address *.o (RESET, +First) *(InRoot$$Sections) .ANY (+RO) } RW_IRAM1 0x40000040 0x00003FA0 { ; RW data .ANY (+RW +ZI) } } 代码3-8 分散加载代码 这段代码显示出Bootloader程序从0x00000400处开始执行，最多占用0x1C00字节的Flash空间。另外，该程序的RAM从0x40000040开始，长度为0x3FA0个字节。这样RAM的低64字节保留给中断向量映射使用，高32字节保留给IAP编程使用。 3.3.4 中断向量的重映射 Bootloader的起始地址位于0x00000400，中断向量也从这一地址开始存储。但默认情况下ARM发生异常时，会跳转到0x00000000处的64字节中断向量区域执行相应操作，所以为了使Bootloader能相应中断，必须将位于0x00000400开始的64字节中断向量表重映射到RAM的低区。LPC2114使用向寄存器MEMMAP写入0x02来完成这一过程。 代码3-9 描述了中断向量重映射的过程。 ; Copy Exception Vectors to Internal RAM --------------------------------------- ADR R8, Vectors ; 源地址 LDR R9, =RAM_BASE ; 目标地址，这里是0x40000000 LDMIA R8!, {R0-R7} ; 装载向量表 STMIA R9!, {R0-R7} ; 存储向量表 LDMIA R8!, {R0-R7} ; 装载处理程序地址 STMIA R9!, {R0-R7} ; 存储处理程序地址 ; Memory Mapping (when Interrupt Vectors are in RAM) MEMMAP EQU 0xE01FC040 ; Memory Mapping Control IF :DEF:REMAP LDR R0, =MEMMAP IF :DEF:EXTMEM_MODE MOV R1, #3 ELIF :DEF:RAM_MODE MOV R1, #2 ELSE MOV R1, #1 ENDIF STR R1, [R0] ENDIF 代码3-9 中断向量重映射 由于Keil MDK提供的启动代码中使用条件编译指令，所以，要想正确的执行中断向量重映射，还需要在Keil MDK编译器工程设置Options for target“你的工程目标名”下的Asm标签中找到Define编辑框，在编辑框中键入“REMAP RAM_MODE”。如图3-2所示 图3-2 注意：在擦除/编程Flash的时候还应该禁止PLL、存储器加速模块。 3.4 用户程序的设计 用户程序运行在高区（扇区8～13）或者低区（扇区1～7），用于实现数据的采集、处理和上传等等，用户程序除本身功能的要求外，还需要注意： Ø 使用分散加载机制，将程序入口精确定位到0x00010000（高区）或0x00008000（低区）。 Ø 进行中断向量重映射，映射到RAM最底处。 4 通讯协议与上位机软件 4.1 Intel的hex格式 Intel hex文件是记录文本行的ASCII文本文件，在Intel HEX文件中，每一行是一个HEX记录，由十六进制数组成的机器码或者数据常量。一个数据记录以一个回车和一个换行结束。 一个Intel HEX文件可以包含任意多的十六进制记录,每条记录有五个域,下面是一个记录的格式. : LL AAAA TT [DD...] CC 每一组字母是独立的一域,每一个字母是一个十六进制数字,每一域至少由两个十六进制数字组成,下面是字节的描述. :冒号 是每一条Intel HEX记录的开始 LL 是这条记录的长度域,他表示数据(dd)的字节数目. AAAA 是地址域,他表示数据的起始地址 TT 这个域表示这条HEX记录的类型,他有可能是下面这几种类型 00 ----数据记录 01 ----文件结束记录 02 ----扩展段地址记录 04 ----扩展线性地址记录 DD 是数据域,表示一个字节的数据,一个记录可能有多个数据字节,字节数目可以查看LL域的说明。 CC 是效验和域,表示记录的效验和,计算方法是将本条记录冒号开始的所有字母（包括校验字节）相加之后等于0x00。 一个Intel HEX文件必须有一个文件结束记录,这个记录的类型域必须是01, 一个EOF记录总是这样: :00000001FF 00是记录中数据字节的数目 0000这个地址对于EOF记录来说无任何意义 01记录类型是01(文件结束记录标示) 4.2 对上位机软件的要求 Ø 上位机具备解析重组Intel HEX文件的能力. Ø 上位机软件应能识别分站发来的应答信号并做出正确的响应。 Ø 上位机应能够检验代码的完整性。 Ø 上位机能根据分站发出的程序所在高区或低区标志，自动判别当前升级程序是否和升级区域相对应。 5 实验数据 为验证升级程序的稳定性，对分站进行重上电、复位、远程升级等一些列实验，实验记录及如下。 1. 测试程序跳转功能.程序在上电或复位之后，应顺利跳转到用户程序。 2. 测试Bootloader（一）。上位机发送升级命令但不发送升级数据包，程序应能进入Bootloader并发送当前程序所在的区域（高区或者低区代号），10S后程序应跳转到用户程序。 3.测试Bootloader（二）。上位机发送升级命令，发送升级数据包，但发送到一半时停止发送。程序在10S后应能跳转到用户程序区。 4.测试Bootloader（三）。上位机发送升级命令，发送升级数据包，但发送中途给分站断电，重新上电后，应还能执行原来的程序。 5.测试Bootloader（四）。上位机发送升级命令，发送完成升级数据包。程序应能接收升级数据包并编程Flash，完成用户程序的更新，更新用户程序后，跳转到新的用户程序。 6.总结 本次升级方案虽然是以LPC2114为基础的，但任何具有IAP功能的单片机、ARM都可使用本设计方案。 设计的重点在于如何保证升级的安全性，分站采取了一些列校验、超时处理以及看门狗等措施，一是保障升级数据包的正确传送，二是即使升级失败也能退回原升级程序。上位机的校验措施需相关部门配合。从实验数据来看，进行了几十次的远程升级，未有一例失败，安全性能可以得到保证。 7.参考文献： 1. 周立功等 ARM微控制器基础与实战（第二版） 北京航空航天大学出版社 2005 2. LPC2114/2124/2212/2214 使用指南.Pdf 广州周立功单片机发展有限公司 3. 韦文祥 朱志杰 车琳娜 郭宝泉 基于LPC21 24的一个远程系统软件升级方案 单片机与嵌入式系统应用 2006第三期 4. 许文杰 丁志冈 张 泉基于ARM 处理器的IAP设计及应用 计算机应用与软件 2009第3期 5. 姜晓梅 李祥和 任朝荣 姚明基于ARM的IAP在线及远程升级技术 计算机应用 2008第二期 6. RealView 编译工具-编译器参考指南.pdf ARM Limited 2009.3 7. RealView Compilation Tools（连接器用户指南）.pdf ARM Limited 2009.3 8. RealView 编译工具-编译器用户指南.pdf ARM Limited 2009.1 9. RealView 编译工具-链接器参考指南.pdf ARM Limited 2008.9 10. Intel HEX文件格式 11. LPC2000 secondary bootloader for code update using IAP NXP Semiconductors 2009.5.26   后记：分散加载文件，软中断，中断向量表重映射，变量对齐，精确定位变量等等这些东西的详细讲解在我的参考资料上都能找的到，发现问题并能解决它，是件很美妙的事情，所以我没打算也没时间详细写这些东西的用法。 需要说的是，我在设计的时候走了一个弯路，现在想想还觉得挺可笑。我以为上面讲的东西要在一个工程里面实现才好，这样才能生成一个.hex可烧录文件，可以一次性的将用户程序、Bootloader程序烧写进处理器，我想弯了。正确的做法是建四个工程：跳转程序、Bootloader、用户低区程序、用户高区程序。如果你懂了.hex文件的格式，就完全可以将跳转程序、Bootloader和用户低区程序（或者跳转程序、Bootloader和用户高区程序）这三个工程生成的.hex文件合成一个。灵活多变的处理问题，这是我最大的收获。 后记的后记: 很多同学看完后都希望得到源码,这种心情我是理解的,最初的时候我也希望有一套别人的源码的,毕竟这样可以进行的快点.所以我将一个远程升级的例子放在下面的链接里,大家想看看的就去下载吧,这个不是我产品中用到的,因为我的代码毕竟是含有公司的一些信息.如果我最近有时间,会把其中的英文文档翻译一下的. 链接:http://download.csdn.net/detail/zhzht19861011/3618966","title":"IAP升级 说明"},{"content":"-潘宏 -2012年12月 -本人水平有限，疏忽错误在所难免，还请各位高手不吝赐教 -email: popyy@netease.com -weibo.com/panhong101 任何一款游戏产品，都需要在几种界面之间进行转换：logo、trailer、main menu、in-game、settings menu等等，并且会在这些转换之间处理资源问题。对于实现这样的转换，不同的游戏做法有所差异，但基本上会实现一个游戏状态机系统。状态机系统在游戏开发中根深蒂固，以至于该系统应该是游戏引擎不可或缺的一个核心部件。 简单游戏状态机结构 状态机的实现方法有很多。相对简单的有switch-case方法，它通过对游戏状态进行枚举化来进行选择判断。下面的示例代码展示了这一点： enum GameState{\tGAME_STATE_LOGO = 0,\tGAME_STATE_TRAILER,\tGAME_STATE_MAIN_MENU,\tGAME_STATE_INGAME,\tGAME_STATE_SETTINGS_MENU,};void gameCycle( int gameState ){\tswitch( gameState )\t{\t\tcase GAME_STATE_LOGO: {...}\t\tcase GAME_STATE_TRAILER: {...}\t\tcase GAME_STATE_MAIN_MENU: {...}\t\tcase GAME_STATE_INGAME: {...}\t\tcase GAME_STATE_SETTINGS_MENU: {...}\t}} 这就是一个相当简单的游戏状态机系统，实现起来很直接、简洁。我们在几年前的一个java引擎中就使用了这样的一个状态机系统（当然，实际代码要比这复杂一些，但结构是这样的）。它表现得很好，能够满足大多数的需求——有好几个商业游戏都使用了这个结构。 可是，在那之后，我们在一个新的C++引擎中，却放弃了这种方法。我们的理由主要有以下几点： 1）该方法不是OO的，我们的引擎是完全OO的。 2）该系统难以维护——所有的状态判断都在gameCycle的switch-case中，我们每增加或者修改一个状态，都需要在enum和gameCycle中增加新的代码，这会导致大量的重新编译。 3）大量的状态逻辑被集中到了switch-case中，导致代码臃肿，难以维护。 4）我们希望把每一个game state逻辑交给一个工程师来编写，这让我们很难做到。 5）“switch-case在OO中是一种‘坏味道’”思潮影响。 考虑到上面的几个原因，我们开始探索新的实现方式，然后，我们就有了一个新的、基于多态性的游戏状态机系统。 状态机基本结构设计 该系统的一个基本结构如下所示： State manager就是状态管理器（后面简称manger），它聚合并管理多个game state（后面简称state）。注意，Manager只聚合state的基类指针，而state拥有自己的类体系。因此，manager通过多态的方式处理各种state。 该方法实际上实际上是一种state模式（如果对该模式感兴趣，请参考GoF的《设计模式》）。这里StateMgr相当于该模式的Context类，而GameState相当于该模式的State类。 我们的类初步设计如下： class GameState{public:\tvirtual ~GameState() {}\tvirtual void cycle() = 0;\tvirtual void draw( GraphicsContext& g ) = 0;};class StateMgr{public:\tvoid addState( GameState* state )\t{\t\tm_states.push_back( state );\t}\t\tvoid cycle()\t{\t\tm_curState->cycle();\t}\tvoid draw( GraphicsContext& g )\t{\t\tm_curState->draw( g );\t}\tprivate:\tstd::set< GameState* >\t\tm_states;\tGameState*\t\t\t\tm_curState;}; 从代码中可以很容易看出该系统的工作原理。 GameState是state的base class，提供了GameState::cycle和GameState::draw两个方法，分别处逻辑更新和渲染两种工作。该base class是抽象的——只允许完成具体工作的derived class进行实例化。 StateMgr就是manger类，它通过m_states保存所有状态，并对当前状态m_curState进行更新和渲染。StateMgr::addState方法用语增加新的游戏状态。 我们看GameState的具体类的一个例子： class GameState_Logo : public GameState{public:\tGameState_Logo()\t{\t\tInit m_logoImage and m_logoPos...\t}\tvirtual void cycle()\t{\t\tif( m_logoPos is not identical to the screen center )\t\t{\t\t\tmake m_logoPos close to the screen center...\t\t}\t}\tvirtual void draw( GraphicsContext& g )\t{\t\tdraw m_logoImage at m_logoPos...\t}private:\tImage*\t\tm_logoImage;\tPoint2D\t\tm_logoPos;}; 上面的类处理进入游戏之后的logo界面。GameState_Logo的ctor初始化logo图片和位置这两个成员。GameState_Logo::cycle将logo的位置逐帧移动到屏幕中心。GameState_Logo::draw则在当前位置画出logo图片。 基本结构就是这样，简单吧！对于游戏不同状态的编写，基本上就是对不同的GameState子类进行实现。一个典型的游戏状态体系如下所示： 这样一个结构设计的好处是什么呢？ 1）StateMgr只依赖GameState，和GameState的derived class没有耦合。 2）增加任何一个新的state，都不会影响manager，不会导致额外的重新编译。 3）state模式的全部优势。 4）该方法是完全OO的。 坏处呢？ 1）使用了virtual function抽象，增加了间接层开销。 2）增加了大量的类源文件，实现起来不够紧凑。 现在，我们已经有了基本的结构。接下来要做的，就是在这些state之间进行转换。 游戏状态转换设计 游戏中的状态转换都会形成一个树形结构——游戏状态树。下图就是一个典型的游戏状态树： 在游戏中，某个时刻只有当前state在运行。因此，游戏将会在树上进行状态转换。比如我们刚刚进入游戏之后，会进入logo界面，然后转到trailer界面，接下来是主菜单，这几步都是不可逆的。然后玩家可以选择in-game（进入游戏）、credits（制作团队介绍）和settings（设置）这三个状态，并且可以从这三个状态返回主菜单状态。在in-game状态下可以进入pause menu（暂停菜单）并返回。 此外，我们有时候需要在一种状态下显示另一种状态。比如在pause menu中显示暂停选项的时候仍然显示游戏背景（用某种颜色的全屏幕半透明矩形覆盖使其暗化，并且游戏逻辑此时不会更新），如下图所示： 这意味着给state增加一个parent pointer会很方便： class GameState{// ...as abovepublic:\tvoid setParent( GameState* state ) { m_parent = state; }\tGameState* getParent() { return m_parent; }private:\tGameState*\t\tm_parent;}; 这样，我们可以这样实现pause menu的draw方法： void GameState_PauseMenu::draw( GraphicsContext& g ){\tm_parent->draw( g );\tdraw the transparent mask layer...\tdraw pause menu items...} 我们首先渲染parent，对于pause menu状态来说，它的parent就是in-game状态。然后渲染半透明覆盖层。最后渲染pause menu的选项。 此外，parent pointer对于状态的转换也是非常方便的。 为了能够方便地操纵游戏状态在状态树上进行转换，我们扩展manager类： class StateMgr{// ...as abovepublic:\tenum StateOP\t{\t\tSTATE_OP_PUSH = 0,\t\tSTATE_OP_POP,\t};\tpublic:\tvoid changeState( GameState* newState, int op )\t{\t\tif( op == STATE_OP_PUSH )\t\t{\t\t\tnewState->setParent( m_curState );\t\t\tm_curState = newState;\t\t}\t\telse if( op == STATE_OP_POP )\t\t{\t\t\tm_curState = m_curParent->getParent();\t\t}\t}}; 我们增加了state操作方法StateMgr::changeState并通过两个操作类型：push和pop，可以很方便地在状态树上移动，如下图所示： Loading状态 以上设计有一个很大的问题，你能看出来吗？似乎所有的state同时存在，这将导致大量的资源存在于内存中。就算是当进入到main menu状态之后，我们再也无法返回trailer或者logo状态，它们的资源也还驻留在内存里。因此，我们需要把这些状态划分阶段（phase），只让当前一个phase内的所有state留在内存里。当游戏从一个phase转到另一个phase的时候，会释放旧phase资源，然后载入新phase资源。这通过一个叫做GameState_Loading的类来实现。在释放旧资源和载入新资源的过程中，GameState_Loading将接管局面，并显示载入进度界面。我们先把目前的状态树划分phase如下： 整个状态树被划分为4个phase： logo(logo) trailer(trailer) main menu(main menu, credits, settings menu) in-game(in-game, pause menu) 括号里面的就是该phase所包含的状态，会在一个loading过程中全部驻留内存。每一个phase实际上都形成一个子树，通过一个stack结构和上面的push、pop操作进行转换。我们扩展上面的类如下： class GameState{// ...as abovepublic:\tint getStateOP() const { return m_stateOP; }\tint getNextPhase() const { return m_phaseToLoad; }protected:\tint m_stateOP;\tint m_phaseToLoad;};class GameState_Loading : public GameState{public:\tenum Phase\t{\t\tPHASE_LOGO = 0,\t\tPHASE_TRAILER,\t\tPHASE_MAIN_MENU,\t\tPHASE_INGAME,\t};public:\tvoid setNextPhase( int phase ) { m_phaseToLoad = phase; }\tGameState* getNextState() { return m_nextState; }\tvirtual void cycle()\t{\t\tfree the old phase...\t\tinit the new phase frame by frame...\t\tsave the new states to StateMgr::m_states...\t\tif( initialization is completed )\t\t{\t\t\tm_nextState = default state of the phase\t\t\tm_stateOP = StateMgr::STATE_OP_NEW_STACK;\t\t}\t}\tvirtual void draw( GraphicsContext& g )\t{\t\tdraw the progress interface...\t}private:\tint m_phaseToLoad;\tGameState* m_nextState;};class StateMgr{// ...as abovepublic:\tenum StateOP\t{\t\tSTATE_OP_NONE = -1,\t\tSTATE_OP_PUSH = 0,\t\tSTATE_OP_POP,\t\tSTATE_OP_LOAD,\t\tSTATE_OP_NEW_STACK,\t};public:\tvoid cycle()\t{\t\t// ...as above\t\tleaveFrame();\t}private:\tvoid leaveFrame()\t{\t\tif( m_curState->getStateOP() != STATE_OP_NONE )\t\t{\t\t\tif( m_curState->getStateOP() == STATE_OP_LOAD )\t\t\t{\t\t\t\tGameState_Loading* state = new GameState_Loading;\t\t\t\tstate->setNextPhase( m_curState->getNextPhase() );\t\t\t\tm_curState  = state;\t\t\t}\t\t\telse if( m_curState->getStateOP() == STATE_OP_NEW_STACK )\t\t\t{\t\t\t\tGameState_Loading* state = static_cast< GameState_Loading*>( m_curState );\t\t\t\tchangeState( state->getNextState(), STATE_OP_PUSH );\t\t\t\tdelete state;\t\t\t}\t\t}\t}}; GameState_Loading类处理所有的状态转换工作，这当然包括旧资源释放和新资源初始化，同时绘制loading界面。 StateMgr新增了两个操作方式。StateMgr::STATE_OP_LOAD就是开始建立一个新的phase，也就是从旧phase进入loading状态，然后进行资源载入和新phase中各个state的建立等工作，这些工作在GameState_Loading::cycle中逐帧完成。StateMgr::STATE_OP_NEW_STACK表示从当前loading状态进入到新建立的phase的默认state中。 StateMgr::cycle方法中新增加调用一个新加入的方法StateMgr::leaveFrame。该方法用于在离开当前帧的时候做一些事情。在这里我们主要处理state转换。 GameState增加了两个成员，m_stateOP用于告诉StateMgr是否需要转换到另一个phase，默认值是StateMgr::STATE_OP_NONE——什么也不做。m_phaseToLoad告诉StateMgr它要转换到哪一个phase。这些phase都定义在GameState_Loading中。比如在logo状态中需要转换到trailer状态，我们可以在GameState_Logo::cycle中写： m_stateOP = StateMgr::STATE_OP_LOAD; m_phaseToLoad = GameState_Loading::PHASE_TRAILER; StateMgr::leaveFrame就会建立一个loading状态来进行状态转换。当GameState_Loading::cycle完成了初始化，它就会通过StateMgr::STATE_OP_NEW_STACK让流程进入新的phase的默认state中，正如上面代码所示。 （我在程序中使用了一些伪码来避免陷入过多细节，目的是更好的表达出这个结构的思路。如果你非常需要了解该系统的具体实现，可以和我联系） 改进方向 好了！我们已经完成了该系统的基本框架。读者完全可以根据该框架实现一个自己的游戏状态机，并取得良好的运行效果。但我还是要说，这和真正游戏中使用的工程级别代码比，还差一些！下面我会指出一些设计上的改进和扩展，让该系统更容易在游戏产品中使用。感兴趣的读者可以自行实现。 1 给GameState加上自定义“构造函数”和“析构函数” 如果能给state增加方法： GameState::onActive GameState::onUnactive 会让很多事情事半功倍，且可以得到良好的结构和健壮性。 在StateMgr::changeState中进行state转换（push和pop）的时候， 给即将停止的state调用onUnactive，给即将运行的state调用onActive，可以给这些state一个机会做一些构造和析构工作（比如释放和申请一些小资源，或重新初始化一些数据等等）。我们的代码就强烈地依赖这些方便的小方法。 2 增加state之间的界面过渡 很多游戏在界面过渡之间都使用了一些特效，最常见的就是淡入淡出效果。令人兴奋的是，通过上面的状态机系统增加这样的过渡效果非常方便。比如我们自己设计了一个叫做FullScreenEffect的基类，通过设计不同的子类来完成不同的过渡效果。 提示：在StateMgr里面合成该类的一个实例，然后在StateMgr::cycle和StateMgr::draw中调用FullScreenEffect::cycle和FullScreenEffect::draw方法，并通过一些标志来禁止和启动StateMgr::m_curState的更新和渲染。 3 通过事件分发系统进行状态改变通知 通过我们之前介绍的事件分发系统（http://blog.csdn.net/popy007/article/details/8242787）来通知系统进行state转换是个很不错的设计思路！ 4 把StateMgr写成一个singleton StateMgr应该只有一个且可以被方便地访问，写成一个singleton吧！（关于singleton模式，可以参考GoF的著作） 5 给loading状态增加一个资源载入管理器 在loading状态中，我们有时候需要画出当前的进度比例，这个比例如何计算出呢？很多游戏用的是假数据——只体现一个递增的效果。但还有些用的是真实数据，对于真实数据来说，该机制和你游戏的资源管理系统有很大关系，这里我提供一个简单思路。 我们将需要载入或申请的所有资源进行分类，比如： 字符串 纹理 关卡数据 逻辑脚本 缓存 自定义回调函数 ... 给这些资源定义一个通用的结构，并用一个ID来区分。然后这些资源就有了一个统一的表示结构，比如 struct Res; 然后建立一个（你喜欢的任何容器都可以） std::list< Res > 把所有要载入的资源全部放到这个list中，之后list.size()就是你要载入的所有资源数。在loading状态里面，每帧只处理一个Res。处理完毕后，就从这个list中把该Res删除。在这个过程中，你就可以知道当前的载入进度了。这个方法的好处在于避免了资源加载过程中多线程的使用。 总结 以上我们设计并实现了一个基本的游戏状态机系统——它很清晰、简洁，并有很强的扩展性。它基于state模式，提供了易于维护的系统结构。当然，该系统还有很大的提升空间，这完全取决于开发者的积累。 该系统已经在多个实际项目中使用，并获得了不错的效果。希望开发者能够从中得到设计灵感。","title":"一个多态性的游戏状态机系统"},{"content":"1、添加 int ComboBox_AddString(  HWND hwndCtl,                                 //窗口句柄  LPCTSTR lpsz                                   //需要添加的内容 ); 两者的区别就在第二个参数上：一个可以加入内容到指定的位置，一个不行。   2、确定目前选项的索引：  int ComboBox_GetCurSel( HWND hwndCtl                                //唯一的参数是控件的句柄，而返回值是在句柄上显示字符串的索引号‘； ); Cur:CurrentSel:Selection 返回值是当前项的编号，从 0开始 。 得到的不是 “ 北京市 ” 这样的字符串 ， 而是索引 （ 编号 ） 如果没有项目被选中，那么从函数中传回的 iIndex 值为 CB_ERR 。做一个例子 3、删除项： int ComboBox_DeleteString( HWND hwndCtl ,                           //控件的句柄， int index                                         //你要删除的索引号（有点像数组中总括号的数，也是从零开始）， ); 返还值是删除后还剩几个字符串的个数； 4、得到某项的值 int GetLBText(    int nIndex,                      //包含要复制的列表框中字符串的从零开始的索引。    LPTSTR lpszText         //指向是接收该字符串的缓冲区。缓冲区必须有该字符串和一个终止null字符足够的空间。 ) const; void GetLBText(    int nIndex,    CString& rString        //rString对CString 的引用。 ) const;  返回值：长度(以字节为单位)的字符串，不包括终止null字符。如果nIndex 不指定一个有效的索引，则返回值是CB_ERR。 备注：该成员函数的第二个窗体包含项目的文本加载一CString 对象。 示例： CString str1, str2; int n; for (int i = 0; i < m_pComboBox->GetCount(); i++) {    n = m_pComboBox->GetLBTextLen(i);    m_pComboBox->GetLBText(i, str1.GetBuffer(n));    str1.ReleaseBuffer();    str2.Format(_T(\"item %d: %s\\r\\n\"), i, str1.GetBuffer(0));    AFXDUMP(str2); }  ","title":"ComboBox系列的API函数"},{"content":"MSDN的定义： int wsprintf( LPTSTR lpOut,                                     //输出缓冲区，最大的字节为1024 LPCTSTR lpFmt,                                 //设置字符串的格式，是整数呢还是。。  ...);                                                          //\".....\"表示需要输出的参数，数目不限   功能：将数字转化为字符串。 例子： int x=6; LPTSTR szBuffer=new TCHAR[1024]; wsprintf(szBuffer,“%d“,x); MessageBox(NULL,szBuffer,““,MB_OK);      ","title":"wsprintf()函数的使用"},{"content":"         1、    itoa   ：                  功 能:把一整数转换为字符串 　　用 法:char *itoa(int value, char *string, int radix); 　　详细解释:itoa是英文integer to array(将int整型数转化为一个字符串,并将值保存在数组string中)的缩写.其中value为要转化的整数, radix是基数的意思,即先将value转化为radix进制的数,之后在保存在string中. 　　程序例: 　　#include <stdlib.h> 　　#include <stdio.h> 　　int main() 　　{ 　　int number = 123456; 　　int char string[25]; 　　int itoa(number, string, 10); 　　int printf(\"integer = %d string = %s\\n\", number, string); 　　int return 0; 　　}     2、atoi：               功能：将字符串转化为整型数据。              int atoi(const char *nptr)          从数字或者符号时开始转换，到遇到非数字或者字符串结束时结束，并将结果返回。         程序：         #include<iostream.h>             #include <stdlib.h>         void mian()        {         char s1[]=\"123\";         char s2[]=\"345\";         int s3=0;         s3=atoi(s1)+atoi(s2);         cout<<s3<<endl;         }         ","title":"itoa 和 atoi 的用法和区别"},{"content":"             这几天在做JSP最后大作业时遇到一个小编程问题，值得反思很多。               问题：MySql数据库操作              测试执行时问题报这样的错 ：com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '?,?)' at line 1            一开始以为是版本问题，上网查了一些也多热指版本问题（问题原因不一样，提示一样），然后换了几个包，还是不行。最后步步排除实在找不到了，随便点了几个函数声明，原来错是这样的：PreparedStatement类中有execute（）方法，是无参数的，其父类Statement也有execute（str）但是为有参数的。去了上图中sql参数就可以运行了。         是这种很错误，基础很不扎实。看了看一些网页，也有类似的错误。除了错误本身外，发现了很多要去反醒的。        一开始在机房做的时候老师给的例子就是上述用法，大家都遇到了这个问题。但是也有些同学没有这个问题。老师下来调了两次，也没有找到解决方法。自己就想：额，这个问题不是我自己编程的问题，等老师去解决吧。犯错一：完全依靠他人。         自己做的时候，也不去管那个问题，觉得这是只是学期终的考查案例，老师不会去细查的，就拖。错误二：对自己不负责。 编程学技术这本身就要求很强的自学能力，有问题为不应该完全依赖别人。解决问题的本身就是一个学习过程，没有问题的编程有吗？完全指望别人去解决问题的，能走多远？         大学了，什么事要对自己负责，这就大三了，更是要对自己的一切学会负责：有问题就要去解决，不能逃避。否则的话，就要享受“被动负责”。         牢记：要会自学，对自己负责。","title":"[置顶] 问题总结error in your SQL syntax"},{"content":"你应当如何学习C++(以及编程)(rev#1)   By 刘未鹏(pongba) C++的罗浮宫(http://blog.csdn.net/pongba)   Javascript是世界上最受误解的语言，其实C++何尝不是。坊间流传的错误的C++学习方法一抓就是一大把。我自己在学习C++的过程中也走了许多弯路，浪费了不少时间。   为什么会存在这么多错误认识？原因主要有三个，一是C++语言的细节太多。二是一些著名的C++书籍总在（不管有意还是无意）暗示语言细节的重要性和有趣。三是现代C++库的开发哲学必须用到一些犄角旮旯的语言细节（但注意，是库设计，不是日常编程）。这些共同塑造了C++社群的整体心态和哲学。   单是第一条还未必能够成气候，其它语言的细节也不少（尽管比起C++起来还是小巫见大巫），就拿javascript来说，作用域规则，名字查找，closure，for/in，这些都是细节，而且其中还有违反直觉的。但许多动态语言的程序员的理念我猜大约是学到哪用到哪罢。但C++就不一样了，学C++之人有一种类似于被暗示的潜在心态，就是一定要先把语言核心基本上吃透了才能下手写出漂亮的程序。这首先就错了。这个意识形成的原因在第二点，C++书籍。市面上的C++书籍不计其数，但有一个共同的缺点，就是讲语言细节的书太多——《C++ gotchas》，《Effective C++》，《More Effective C++》，但无可厚非的是，C++是这样一门语言：要拿它满足现代编程理念的需求，尤其是C++库开发的需求，还必须得关注语言细节，乃至于在C++中利用语言细节已经成了一门学问。比如C++模板在设计之初根本没有想到模板元编程这回事，更没想到C++模板系统是图灵完备的，这也就导致了《Modern C++ Design》和《C++ Template Metaprogramming》的惊世骇俗。这些技术的出现为什么惊世骇俗，打个比方，就好比是一块大家都认为已经熟悉无比，再无秘密可言的土地上，突然某天有人挖到原来地下还蕴藏着最丰富的石油。在这之前的C++虽然也有一些细节，但也还算容易掌握，那可是C++程序员们的happy old times，因为C++的一切都一览无余，everything is figured out。然而《Modern C++ Design》的出世告诉人们，“瞧，还有多少细节你们没有掌握啊。”于是C++程序员们久违的激情被重燃起来，奋不顾身的踏入细节的沼泽中。尤其是，模板编程将C++的细节进一步挖掘到了极致——我们干嘛关心涉及类对象的隐式转换的优先级高低？看看boost::is_base_of就可以知道有多诡异了。但最大的问题还在于，对于这些细节的关注还真有它合适的理由：我们要开发现代模板库，要开发active library，就必须动用模板编程技术，要动用模板编程技术，就必须利用语言的犄角旮旯，enable_if，type_traits，甚至连早就古井无波的C宏也在乱世中重生，看看boost::preprocessor有多诡异就知道了，连C宏的图灵完备性（预编译期的）都被挖掘出来了。为什么要做这些？好玩？标榜？都不是，开发库的实际需求。但这也正是最大的悲哀了。在boost里面因实际需求而动用语言细节最终居然能神奇的完成任务的最好教材就是boost::foreach，这个小设施对语言细节的发掘达到了惊天地泣鬼神的地步，不信你先试着自己去看看它的源代码，再看看作者介绍它的文章吧。而boost::typeof也不甘其后——C++语言里面有太多被“发现”而不是被“发明”的技术。难道最初无意设置这些语言规则的家伙们都是oracles？   因为没有variadic templates，人们用宏加上缺省模板参数来实现类似效果。因为没有concepts，人们用模板加上析构函数的细节来完成类似工作。因为没有typeof，人们用模板元编程和宏加上无尽的细节来实现目标… C++开发者们的DIY精神不可谓不强。   然而，如果仅仅是因为要开发优秀的库，那么涉及这些细节都还是情有可原的，至少在C++09出现并且编译器厂商跟上之前，这些都还能说是不得已而为之。但我们广大的C++程序员呢？大众是容易被误导的，我也曾经是。以为掌握了更多的语言细节就更牛，但实际却是那些语言细节十有八九是平时编程用都用不到的。C++中众多的细节虽然在库设计者手里面有其用武之地，但普通程序员则根本无需过多关注，尤其是没有实际动机的关注。一般性的编码实践准则，以及基本的编程能力和基本功，乃至基本的程序设计理论以及算法设计。才是真正需要花时间掌握的东西。   学习最佳编码实践比学习C++更重要。看优秀的代码也比埋头用差劲的编码方式写垃圾代码要有效。直接、清晰、明了、KISS地表达意图比玩编码花招要重要…   避免去过问任何语言细节，除非必要。这个必要是指在实际编程当中遇到问题，这样就算需要过问细节，也是最省事的，懒惰者原则嘛。一个掌握了基本的编程理念并有较强学习能力的程序员在用一门陌生的语言编程时就算拿着那本语言的圣经从索引翻起也可以编出合格的程序来。十年学会编程不是指对每门语言都得十年，那一辈子才能学几门语言哪，如果按字母顺序学的话一辈子都别指望学到Ruby了；十年学习编程更不是指先把语言特性从粗到细全都吃透才敢下手编程，在实践中提高才是最重要的。   至于这种抠语言细节的哲学为何能在社群里面呈野火燎原之势，就是一个心理学的问题了。想像人们在论坛上讨论问题时，一个对语言把握很细致的人肯定能够得到更多的佩服，而由于论坛上的问题大多是小问题，所以解决实际问题的真正能力并不能得到显现，也就是说，知识型的人能够得到更多佩服，后者便成为动力和仿效的砝码。然而真正的编程能力是与语言细节没关系的，熟练运用一门语言能够帮你最佳表达你的意图，但熟练运用一门语言绝不意味着要把它的边边角角全都记住。懂得一些常识，有了编程的基本直觉，遇到一些细节错误的时候再去查书，是最节省时间的办法。   C++的书，Bjarne的圣经《The C++ Programming Language》是高屋建瓴的。《大规模C++程序设计》是挺务实的。《Accelerated C++》是最佳入门的。《C++ Templates》是仅作参考的。《C++ Template Metaprogramming》是精力过剩者可以玩一玩的，普通程序员碰都别碰的。《ISO.IEC C++ Standard 14882》不是拿来读的。Bjarne最近在做C++的教育，新书是绝对可以期待的。   P.S. 关于如何学习编程，g9的blog上有许多精彩的文章：这里，这里，这里，这里… 实际上，我建议你去把g9老大的blog翻个底朝天 :P   再P.S. 书单？我是遑于给出一个类似《C++初学者必读》这种书单的。C++的书不计其数，被公认的好书也不胜枚举。只不过有些书容易给初学者造成一种错觉，就是“学习C++就应该是这个样子的”。比如有朋友提到的《高质量C/C++编程》，这本书有价值，但不适合初学者，初学者读这样的书容易一叶障目不见泰山。实际上，正确的态度是，细节是必要的。但细节是次要的。其实学习编程我觉得应该最先学习如何用伪码表达思想呢，君不见《Introduction to Algorithm》里面的代码？《TAOCP》中的代码？哦，对了它们是自己建立的语言，但这种仅教学目的的语言的目的就是为了避免让写程序的人一开始就忘了写程序是为了完成功能，以为写程序就是和语言细节作斗争了。Bjarne说程序的正确性最重要，boost的编码标准里面也将正确性列在性能前面。   此外，一旦建立了正确的学习编程的理念，其实什么书（只要不是太垃圾的）都有些用处。都当成参考书，用的时候从目录或索引翻，基本就对了。   再再P.S. myan老大和g9老大都给出了许多精彩的见解。我不得不再加上一个P.S。具体我就不摘录了，如果你读到这里，请务必往下看他们的评论。转载者别忘了转载他们的评论:-)   许多朋友都问我同一个问题，到底要不要学习C++。其实这个问题问得很没有意义。“学C++”和“不学C++”这个二分法是没意义的，为什么？因为这个问题很表面，甚至很浮躁。重要的不是你掌握的语言，而是你掌握的能力，借用myan老大的话，“重要的是这个磨练过程，而不是结果，要的是你粗壮的腿，而不是你身上背的那袋盐巴。”。此外学习C++的意义其实真的是醉翁之意不在酒，像C/C++这种系统级语言，在学习的过程中必须要涉及到一些底层知识，如内存管理、编译连接系统、汇编语言、硬件体系结构等等等等知识（注意，这不包括过分犄角旮旯的语言枝节）。这些东西也就是所谓的内功了（其实最最重要的内功还是长期学习所磨练出来的自学能力）。对此大嘴Joel在《Joel On Software》里面提到的漏洞抽象定律阐述得就非常漂亮。   所以，答案是，让你成为高手的并不是你掌握什么语言，精通C++未必就能让你成为高手，不精通C++也未必就能让你成为低手。我想大家都不会怀疑g9老大如果要抄起C++做一个项目的话会比大多数自认熟练C++的人要做得漂亮。所以关键的不是语言这个表层的东西，而是底下的本质矛盾。当然，不是说那就什么语言都不要学了，按照一种曹操的逻辑，“天下语言，唯imperative与declarative耳”。C++是前者里面最复杂的一种，支持最广泛的编程范式。借用当初数学系入学大会上一个老师的话，“你数学都学了，还有什么不能学的呢？”。学语言是一个途径，如果你把它用来磨练自己，可以。如果你把它用来作为学习系统底层知识的钥匙，可以。如果你把它用来作为学习如何编写优秀的代码，如何组织大型的程序，如何进行抽象设计，可以。如果掉书袋，光啃细节，我认为不可以（除非你必须要用到细节，像boost库的coder们）。   然后再借用一下g9老大的《银弹和我们的职业》中的话：   银弹和我们的职业发展有什么相干？很简单：我们得把时间用于学习解决本质困难。新技术给高手带来方便。菜鸟们却不用指望被新技术拯救。沿用以前的比喻， 一流的摄影师不会因为相机的更新换代而丢掉饭碗，反而可能借助先进技术留下传世佳作。因为摄影的本质困难，还是摄影师的艺术感觉。热门技术也就等于相机。 不停追新，学习这个框架，那个软件，好比成天钻研不同相机的说明书。而热门技术后的来龙去脉，才好比摄影技术。为什么推出这个框架？它解决了什么其它框架 不能解决的问题？它在哪里适用？它在哪里不适用？它用了什么新的设计？它改进了哪些旧的设计？Why is forever. 和 朋友聊天时提到Steve McConnell的《Professional Software Development》里面引了一个调查，说软件开发技术的半衰期20年。也就是说20年后我们现在知识里一半的东西过时。相当不坏。朋友打趣道：“应 该说20年后IT界一半的技术过时，我们学的过时技术远远超过这个比例。具体到某人，很可能5年他就废了”。话虽悲观，但可见选择学习内容的重要性。学习 本质技艺（技术迟早过时，技艺却常用长新）还有一好处，就是不用看着自己心爱的技术受到挑战的时候干嚎。C/C++过时就过时了呗，只要有其它的系统编程 语言。Java倒了就倒了呗，未必我不能用.NET？Ruby昙花一现又如何。如果用得不爽，换到其它动态语言就是了。J2EE被废了又怎样？未必我们就 做不出分布系统了？这里还举了更多的例子。   一句话，只有人是真正的银弹。职业发展的目标，就是把自己变成银弹。那时候，你就不再是人，而是人弹。   最后就以我在Bjarne的众多访谈当中摘录的一些关于如何学习C++（以及编程）的看法结束吧（没空逐段翻译了，只将其中我觉得最重要的几段译了一下，当然，其它也很重要，这些段落是在Bjarne的所有采访稿中摘抄出来的，所以强烈建议都过目一下）：   I suspect that people think too little about what they want to build, too little about what would make it correct, and too much about \"efficiency\" and following fashions of programming style. The key questions are always: \"what do I want to do?\" and \"how do I know that I have done if?\". Strategies for testing enters into my concerns from well before I write the firat line of code, and that despite my view that you have to write code very early - rather than wait until a design is complete. 译：我感觉人们过多关注了所谓“效率”以及跟随编程风格的潮流，却严重忽视了本不该被忽视的问题，如“我究竟想要构建什么样的系统”、“怎样才能使它正确”。最关键的问题永远是：“我究竟想要做什么？”和“如何才能知道我的系统是否已经完成了呢？”就拿我来说吧，我会在编写第一行代码之前就考虑测试方案，而且这还是在我关于应当早于设计完成之前就进行编码的观点的前提之下。   Obviously, C++ is very complex. Obviously, people get lost. However, most peple get lost when they get diverted into becoming language lawyers rather than getting lost when they have a clear idea of what they want to express and simply look at C++ language features to see how to express it. Once you know data absreaction, class hierarchies (object-oriented programming), and parameterization with types (generic programming) in a fairly general way, the C++ language features fall in place. 译：诚然，C++非常复杂。诚然，人们迷失其中了。然而问题是，大多数人不是因为首先对自己想要表达什么有了清晰的认识只不过在去C++语言中搜寻合适的语言特性时迷失的，相反，大多数人是在不觉成为语言律师的路上迷失在细节的丛林中的。事实是，只需对数据抽象、类体系结构（OOP）以及参数化类型（GP）有一个相当一般层面的了解，C++纷繁的语言特性也就清晰起来了。   Well, I don't think I made such a trade-off. I want elegant and efficient code. Sometimes I get it. These dichotomies (between efficiency versus correctness, efficiency versus programmer time, efficiency versus high-level, et cetera.) are bogus.   I think the real problem is that \"we\" (that is, we software developers) are in a permanent state of emergency, grasping at straws to get our work done. We perform many minor miracles through trial and error, excessive use of brute force, and lots and lots of testing, but--so often--it's not enough.   Software developers have become adept at the difficult art of building reasonably reliable systems out of unreliable parts. The snag is that often we do not know exactly how we did it: a system just \"sort of evolved\" into something minimally acceptable. Personally, I prefer to know when a system will work, and why it will.   There are more useful systems developed in languages deemed awful than in languages praised for being beautiful--many more. The purpose of a programming language is to help build good systems, where \"good\" can be defined in many ways. My brief definition is, correct, maintainable, and adequately fast. Aesthetics matter, but first and foremost a language must be useful; it must allow real-world programmers to express real-world ideas succinctly and affordably.   I'm sure that for every programmer that dislikes C++, there is one who likes it. However, a friend of mine went to a conference where the keynote speaker asked the audience to indicate by show of hands, one, how many people disliked C++, and two, how many people had written a C++ program. There were twice as many people in the first group than the second. Expressing dislike of something you don't know is usually known as prejudice. Also, complainers are always louder and more certain than proponents--reasonable people acknowledge flaws. I think I know more about the problems with C++ than just about anyone, but I also know how to avoid them and how to use C++'s strengths.   In any case, I don't think it is true that the programming languages are so difficult to learn. For example, every first-year university biology textbook contains more details and deeper theory than even an expert-level programming-language book. Most applications involve standards, operating systems, libraries, and tools that far exceed modern programming languages in complexity. What is difficult is the appreciation of the underlying techniques and their application to real-world problems. Obviously, most current languages have many parts that are unnecessarily complex, but the degree of those complexities compared to some ideal minimum is often exaggerated.   We need relatively complex language to deal with absolutely complex problems. I note that English is arguably the largest and most complex language in the world (measured in number of words and idioms), but also one of the most successful.   C++ provides a nice, extended case study in the evolutionary approach. C compatibility has been far harder to maintain than I or anyone else expected. Part of the reason is that C has kept evolving, partially guided by people who insist that C++ compatibility is neither necessary nor good for C. Another reason-- probably even more important--is that organizations prefer interfaces that are in the C/C++ subset so that they can support both languages with a single effort. This leads to a constant pressure on users not to use the most powerful C++ features and to myths about why they should be used \"carefully,\" \"infrequently,\" or \"by experts only.\" That, combined with backwards-looking teaching of C++, has led to many failures to reap the potential benefits of C++ as a high-level language with powerful abstraction mechanisms.   The question is how deeply integrated into the application those system dependencies are. I prefer the application to be designed conceptually in isolation from the underlying system, with an explicitly defined interface to \"the outer world,\" and then integrated through a thin layer of interface code.   Had I had a chance to name the style of programming I like best, it would have been \"class-oriented programming\", but then I'm not particularly good at finding snappy names. The school of thought that I belong to - rooted in Simula and related design philosophies - emphasizes the role of compile-time checking and flexible (static) type systems. Reasoning about the behavior of a program has to be rooted in the (static) structure of the source code. The focus should be on guarantees, invariant, etc. which are closely tied to that static structure. This is the only way I know to effectively deal with correctness. Testing is essential but cannot be systematic and complete without a good internal program structure - simple-minded blackbox testing of any significant system is infeasible because of the exponential explosion of states.   So, I recommend people to think in terms of class invariants, exception handling guarantees, highly structured resource management, etc. I should add that I intensely dislike debugging (as ah hoc and unsystematic) and strongly prefer reasoning about source code and systematic testing.   Pros: flexibility, generality, performance, portability, good tool support, available on more platforms than any competitor except C, access to hardware and system resources, good availability of programmers and designers. Cons: complexity, sub-optimal use caused by poor teaching and myths.   分享到： 上一篇：Blog外挂之：文章置顶 下一篇：八卦一下g9的八卦 查看评论 158楼 flower312 2012-11-19 15:12发表 [回复] [引用] [举报] 为什么自己在大学时代没有看到你的这篇文章。。 157楼 xifeidi 2012-04-14 17:53发表 [回复] [引用] [举报] 受益匪浅。 156楼 wangbinhh 2012-04-05 17:35发表 [回复] [引用] [举报] 没怎么看懂，但是评论很精彩，呵呵呵！ 155楼 C学童 2012-02-27 22:30发表 [回复] [引用] [举报] 看了，很有感触，一个C++爱好者，希望能得到指教，相互交流。QQ：467279165 154楼 jmxiaocai 2012-02-03 17:03发表 [回复] [引用] [举报] 爸爸，看的一头雾水！ 153楼 zc200711158 2012-01-19 11:06发表 [回复] [引用] [举报] 妈妈，太深奥，看不懂！ 152楼 owen_ccc 2011-12-07 00:57发表 [回复] [引用] [举报] 看完后很有启发性，对我有很大帮助。支持！ 继续关注！ 151楼 renjunyangluyao 2011-12-02 15:12发表 [回复] [引用] [举报] 引用“sail2011”的评论：回复匿名用户：你也好意思写出来啊，这道题不是你这样做的。。。。 你妈才不是这么做的，你自己懂不懂啊，你个傻叉！！ 去扫大街吧！！！ Re: lwtzz521 2012-01-20 15:01发表 [回复] [引用] [举报] 回复renjunyangluyao：这题，它真不是这么做的。 Re: sail2011 2011-12-02 18:08发表 [回复] [引用] [举报] 回复renjunyangluyao：可怜。。。。。。。。。。。。。。 150楼 smallmuou 2011-10-31 11:15发表 [回复] [引用] [举报] 很不错的贴，很支持先修内功，再修外功，就好比张无忌，但现实中，先修内功在练外功，是不现实而且也不一定能达到最好效果，其实在现实中 只有是：内功——》外功——》内功——》外功，这样不断的反复，才是最好的；只有在实际中体会才最有感触； 149楼 家有2亩地 2011-09-26 09:45发表 [回复] [引用] [举报] 现在在在学 属于刚入门 但只看书 感觉学不进去 148楼 大厨师 2011-08-21 20:14发表 [回复] [引用] [举报] 经典之极 147楼 huangzhenliang9999 2011-05-29 02:38发表 [回复] [引用] [举报] 我们MFC都没教 146楼 freezezdj 2011-05-11 16:47发表 [回复] [引用] [举报] 哎，当年在学校 C++ == 0，就开始MFC了[e06]！ 145楼 huang2009love 2011-03-17 20:35发表 [回复] [引用] [举报] [e01] 144楼 luqinlive 2011-03-06 11:56发表 [回复] [引用] [举报] [e01]留名以便日后再看 143楼 lbd2008 2010-12-03 10:04发表 [回复] [引用] [举报] [e01]C++学习的导航贴！ 142楼 lingjingqiu 2010-06-08 23:42发表 [回复] [引用] [举报] 前面的哥们儿都说了很多了，我也有进8年的C++学习和使用经验了。C++一大问题在语言设计上。 为什么C++的语言细节可以极大的改善库的能力？我觉得这个是首先需要考虑的问题。很少会有人用Java这样的语言实现神出鬼没的语法效果。很大程度上，这是语言在设计的时候，就不鼓励且不允许的。 而C++不同。语法分析期图灵完备的宏，语义分析器图灵完备的模板，再加上各种编译期间查找、推导并暴露出的信息，导致了C++的语言标准无形之中在鼓励库跨越运行时的能力范围向编译期和元编程的能力方向延拓。 这一特性也导致可能在元编程期间的少量代码，会节省代码编写期间的大量工作，也会使得代码编写更加简洁、直观、方言化。难道追求简洁也是C++ User的罪过？显然不是。君不见Java的配置驱动，也做得是同样的工作？让编程元编程化。 只不过可悲的是，C++对元编程的支持高不成低不就，才导致了大量的人去挖掘语言细节来实现typeof和auto这些原本应该是编译器直接提供的东西。这才是C++的悲哀。 141楼 匿名用户 2010-04-18 17:32发表 [回复] [引用] [举报] [e01][e01][e01][e01][e01][e01][e01][e01][e01][e01][e01][e01][e01][e01][e01][e01][e01][e01][e01][e01][e01] 140楼 匿名用户 2010-04-18 17:31发表 [回复] [引用] [举报] [e01] 139楼 匿名用户 2010-04-03 20:34发表 [回复] [引用] [举报] [e02][e02][e02][e02][e02][e02] 138楼 taelle 2010-02-28 15:44发表 [回复] [引用] [举报] [e01][e01][e01][e01] 137楼 匿名用户 2010-02-22 18:35发表 [回复] [引用] [举报] [e01] 程序设计是讲天赋的，比如对指针的理解等，所以强烈建议比较笨的人还是放弃吧。不要看到别人工资高就跟风，下面是道智力题： 不会做的人还是去扫马路吧，学人家当程序员。笑死掉。 题：一个天平，12个大小，外观相同的球，一个球的重量与其他的不同，称3次。找出来？ Re: u03013106 2012-11-13 08:23发表 [回复] [引用] [举报] 回复匿名用户：呵呵，这个玩意高中就做过了，其实很是经典 不过程序员，也有很多种是吧？ 有需要研发的，有需要板砖的~ 尤其是在国内嘛 Re: newcomer101 2011-11-21 16:44发表 [回复] [引用] [举报] 回复匿名用户：照你这说法，全国几十亿人口都要去扫地了。 Re: u03013106 2012-11-13 08:21发表 [回复] [引用] [举报] 回复newcomer101：呵呵，哥们儿太激进了 一个人有一个看法，自己心里知道咋回事儿就得了 不用做什么口舌之争 Re: kolecenter 2011-11-17 13:25发表 [回复] [引用] [举报] 回复匿名用户：另外说一句，别老拿指针说事儿，要是编译器就没这玩意，你指个屁呀，人家给你下个套你钻进去了还好意思说别人没钻进去的本事，，，，，真够逗的~工具终究是工具，别拿它当产品对待，OK？否则，你去开发一种新硬件，和新语言啊？那才叫产品。 Re: kolecenter 2011-11-17 13:21发表 [回复] [引用] [举报] 回复匿名用户：一看就没对这个职业有很深理解吧？程序员并不需要多么高智商和天赋，一般人就成，天赋高了未必就好。无非就是先做哪个再做哪个的问题。你看看现实就明白了，搞程序的大多数都是大中专生，因为不需要什么高深理论，需要什么理论了你去找相关方面的专业人士，那至少也得博士，至于理论对不对你也没那水平分析出来，搞程序的就是人家把理论给你写出来，你去实现就成了，还要个狗屁天赋啊。就你那道题，你说说看，它用在哪段程序上了？ Re: u03013106 2012-11-13 08:26发表 [回复] [引用] [举报] 回复kolecenter：呵呵，哥们说的对 确实职业走向还跟个人的性格等等有关系 太聪明的人，往往很难专注地做一件事儿吧 这个时代，感觉只要坚持，就会成功 我毕业5，6年了 之前就是吃亏了，干的东西太杂，一年一换 最近几个月又到了C++，打算好好地学习一下了 Re: 匿名用户 2010-05-20 03:03发表 [回复] [引用] [举报] 回复 匿名用户：你别问那些弱智的问题好吧. 6-6 3-3 1-1=1 这题已经回答你了.能看出意思吗?你看不出`你才真的是笑话`笨的人不一定学不会.只要肯努力! Re: sail2011 2011-10-10 10:03发表 [回复] [引用] [举报] 回复匿名用户：你也好意思写出来啊，这道题不是你这样做的。。。。 Re: 枫中畅游 2012-06-01 13:02发表 [回复] [引用] [举报] 8 4 2 。。。回复sail2011： 136楼 G_cofa 2010-01-31 21:05发表 [回复] [引用] [举报] 嗯，好，多实践才是王道，设计非常重要。 Re: agui_zkoop 2011-10-20 19:09发表 [回复] [引用] [举报] 回复G_cofa：你用的是激将法吧，想激激我们这些笨人的 135楼 fghfghfghfgjj 2010-01-28 15:01发表 [回复] [引用] [举报] [e02][e01][e01][e03] 134楼 zengcan 2010-01-06 09:46发表 [回复] [引用] [举报] 感觉《高。。。》这本书就是C++中必须要注意的。少bug。也许我们不改研究太多的细节，别人告诉我们这个问题应该这么处理，很多人承认这样是好的，那么我们遵守就行了。 133楼 zengcan 2010-01-06 09:01发表 [回复] [引用] [举报] 只能说一个字，好[e03][e03] 思想是王道! 132楼 L_Nan 2010-01-04 23:18发表 [回复] [引用] [举报] 这篇文章太好了，我刚开始学习编程就太注重细节了，现在才知道。细节是次要的，思想才是首要的。语言是拿来用的，是把我们的思维想法用语言来实现。----------------------这大学的课程真应该改一下，大学来的第一门课就应该了解到这些.........................[e08] 131楼 super_chris 2009-12-27 14:45发表 [回复] [引用] [举报] 醍醐灌顶，重要的是思想，是能被抽象出来的东西。 130楼 showpower_1984 2009-12-06 21:15发表 [回复] [引用] [举报] 读了这篇文章还是受益匪浅的，眼看就要毕业了，得好好地进行一下系统的复习了，为以后的工作打好基础~~ 129楼 wwj_wwj 2009-11-08 14:45发表 [回复] [引用] [举报] 其实还是中国的古代哲学比较管用 128楼 yymtvqqqq 2009-10-29 23:40发表 [回复] [引用] [举报] 太精彩了 ！！！ 发人深醒啊 127楼 quinear 2009-07-16 12:24发表 [回复] [引用] [举报] 受益匪浅，只恨没早点看到，我现在的状况基本就算是初学者（以前学的忘得差不多了）想从实践之路出发，在实践过程中参考具体细节，请LZ及各位前辈推荐本偏重实践的书，最好是小程序也有，大程序也顾及到的那种。谢谢了！ 126楼 yang513936184 2009-03-12 10:36发表 [回复] [引用] [举报] 看了大哥哥的文章颇有感触！我是名刚入大学软件工程的学生，上学期学校开了们C，是在VC环境下调试的，当时就感觉很吃力，这学期来又开C#，感觉一样的吃 力，个人感觉学校开课有点问题，看了各位大哥的评论更有这种感觉，各位所说的基础的东西不是学校不开，而是现在没开，而我个人看来，想投入学习c++，但我不想马上就拿起语言开始，想先了解些基础的原理结构后才开始投入学习，不知道这种感觉吗?还有即使投入C++，其他的东西我想还是得学的，但我若投入学习C++肯定和学校的教学错位，可能会学习混乱，真不知道该不该这样做？同时这里希望大哥指点下如何从基础入门，正如大家所说的在学校时间才是最多的，现在大学容易让人颓废，只有确定方向才能走得踏实，所以非常想请大哥指点下基础入门C++，谢谢！ 125楼 floatingfly 2009-02-03 18:00发表 [回复] [引用] [举报] 啊哈哈,不错,我这一段时间一真在想怎么继续我的C++之路,没想到,看了你的文章,总算想清楚了. 呵呵,现在的我还是别在纠缠语言的细节了,够用就行了, 124楼 alldnf 2008-12-23 13:13发表 [回复] [引用] [举报] 虽接触c++只能说有些时日，却也感觉到了这条歧路。 语言只是一种被利用，交流的方式。其背后隐藏的思想才是本质。至于背后到底是什么？事实上从这个问题开始，你已开始去发现她背后隐藏的东西。 123楼 finuxchen 2008-12-12 17:22发表 [回复] [引用] [举报] 很有感触。。留个脚印，方便以后看 122楼 zjfhgdx 2008-10-31 15:56发表 [回复] [引用] [举报] 好! 121楼 yjuufgef 2008-10-18 03:21发表 [回复] [引用] [举报] 获益匪浅 以后常来学习 120楼 lily604 2008-10-17 16:32发表 [回复] [引用] [举报] 这贴太牛，决定隔一段时间再来看一下 119楼 WWIPOP 2008-07-21 23:11发表 [回复] [引用] [举报] 好文章，我可以转载下你篇好东东吗？ 118楼 mujker 2008-06-06 03:23发表 [回复] [引用] [举报] 我只是一名刚毕业的中专生,现在正在迷茫,不知道以后的路该怎么走.我知道我欠缺的很多很多?你的文章给了我很大的动力,如果你能看到我的留言,希望大哥哥能指点指点我! mujker@163.com QQ:8857732 117楼 raof01 2008-04-08 21:35发表 [回复] [引用] [举报] 该抠细节时抠细节，该高屋建瓴时高屋建瓴。如果你是一个coder或者programmer，很多时候你既是画蓝图的，也是垒砖块的那个人。 116楼 raof01 2008-04-08 21:21发表 [回复] [引用] [举报] 学习计算机语言跟学习人类自然语言一样，你不必成为语言专家就可以写出漂亮的文章，情节曲折离奇的小说，……太多太多，数不清。 还是那句话：“思考方式决定一切”。 就C++而言，至少，你要学会《The C++ programming language》 115楼 杨淮生 2008-03-11 09:51发表 [回复] [引用] [举报] 但C++就不一样了，学C++之人有一种类似于被暗示的潜在心态，就是一定要先把语言核心基本上吃透了才能下手写出漂亮的程序。 回想当时学C++时的心态，真的是这样。作者真是有心，佩服。 114楼 firefox1 2008-01-29 23:03发表 [回复] [引用] [举报] 最近我在学习上很迷茫，看了你的文章后有所启发，非常感谢！ 113楼 undefined 2008-01-15 20:48发表 [回复] [引用] [举报] 读了这篇文章也只能从战略上把握学习语言的方法。但从战术上才需思考。比如刚开始时我们可以不抓语言的细节，主要是我用什么思想，怎么构造出一个模块，为什么这么构造，有什么优点等待吧。期待楼主发一篇类似的文章... 112楼 GameMonkey 2007-11-30 17:53发表 [回复] [引用] [举报] 不错，受益非浅， 111楼 菜鳥 2007-11-25 15:37发表 [回复] [引用] [举报] 看了那么多文章，感觸最深就是這篇，沒想到原來自己是那么渺小。看來以后真是要花更多力氣投入了。。 110楼 初学者 2007-11-16 11:25发表 [回复] [引用] [举报] 1。一定要做你喜欢的事情。 2。找个适合自己的学习方法。 3。不注重细节的人，必定失败。过分注重的细节的人，难成大事。 4。实践建立在获得了一定的理论知识之后，否则就是空中楼阁。 5。实践与学习应该构成闭环控制系统。 109楼 xtyyumi301 2007-10-16 16:45发表 [回复] [引用] [举报] 倾向于LZ，学C++过来的，深有体会。 孟岩说的是态度问题，LZ说的是方向问题。 108楼 从容的生活 2007-10-15 08:28发表 [回复] [引用] [举报] 牛神？我现在的偶像啊！大哥以后指点下小弟啊！ 107楼 stzxxx 2007-10-06 15:56发表 [回复] [引用] [举报] 奶奶的原来你这么牛！ 怎么就没有人介绍给我呢！！！！！ 106楼 xenix 2007-09-14 01:34发表 [回复] [引用] [举报] 咱也来添添乱: 《更好的C++——给C++使用者的D语言简介》 http://oldrev.javaeye.com/blog/123677 105楼 gussing 2007-09-12 09:36发表 [回复] [引用] [举报] 这个博客，牛到一定程度了。。。 我怎么没早发现此地？ 104楼 chengzi31 2007-07-30 15:49发表 [回复] [引用] [举报] 以前，我很鄙视那些对细节不了解，又振振有词的人。现在发现说，还真的不得不这样啊。毕竟人的精力是有限的！缺啥补啥啊。真的没办法，什么都掌握了，再去做。 103楼 zteer 2007-07-27 17:02发表 [回复] [引用] [举报] 完全是来学习的，虽然读了软件专业，可是惭愧的很，啥也没学好，现在觉出来原来学的好多基础知识的用处 102楼 palxex 2007-07-17 18:53发表 [回复] [引用] [举报] 刘老师这篇文章应该是针对相对高明、对计算机的本质已经有了相当理解的人写的，让大家不要钻到牛角尖里。而孟岩老师的发言则更针对入门者的学习路径，两者受众不同。其实，本来也没有办法找到一个放之四海而皆准的法子，能让所有人从他们不同的水准、看法、角度，都能接受并从中获益的。 无论如何，浮躁都是大忌。 我本人是从计算机底层进入学习的，对计算机的认识，我想还算可以。但算法就比较弱，而FP乃至更基本的计算理论如图灵机等等，几乎算是文盲。刘老师的blog上每篇都有大堆我看不懂的东西就是明证。大学期间的数学学得比较荒废——另外，学校开课我肯定是有问题的，离散就那么一小本儿还只学了一半，感觉学到的跟计算机相差巨远，连联系都无从寻找。能否请各位示下，像我这种情况的，应该如何提高自己？ PS.BS一下CSDN blog的验证码……第十三次发送。 Re: pongba 2007-07-18 16:14发表 [回复] [引用] [举报] 很简单啊，缺什么补什么，看书，领悟，进步。 101楼 Kid 2007-07-07 18:45发表 [回复] [引用] [举报] 中国真正喜欢计算机的很少，拿我们计算机学院来说，大部分都为了分数，平时都在游戏...... 100楼 shuise 2007-07-06 15:26发表 [回复] [引用] [举报] 《算法导论》比较常用的部分已经看过了，这本书属于综合性制的书籍，也就是其理论不如Robert Sedgewick（我看的《图算法》）深刻，但是翻译此书的作者林琦不太敬业，有些错误，而有些地方看不懂，很可能是翻译的问题。但是，这本书理论性直达本质，很是精采。同时遗憾的是，此书c++代码不如他的弟子MARK ALLEN WEISS好，这位弟子代码质量很高，可是除了关于快速排序一章之外，理论比不RobertSedgewick深刻。 99楼 pongba 2007-07-06 11:59发表 [回复] [引用] [举报] shuise: <blockquote> 学习数据结构的<b><i>最快的<\/i><\/b>、具体的方法是什么？我现在准备把stl/loki/boost那些很精彩的代码打印下来研读，我觉得这就很锻炼人。 <\/blockquote> 没有“最快”的。在学习上，走捷径的想法本来就是错误的。 可以看看《Introduction to Algorithm》，eMule上也有作者的教学视频下，很精彩。 如果还没有准备好看TAOCP的话。 STL的数据结构实现是<b>实现技术<\/b>，并非理论。建议先把理论掌握牢靠再去看实现。 98楼 liu_chulong 2007-07-06 10:11发表 [回复] [引用] [举报] 我走了很多弯路 虽然现在快大四了，但我还是很努力地补课 我觉得学习是要讲究方法，但不能只站在一定高度去学，就像你在游泳池里游得很轻松，在游泳池里游泳有好几年的经验，总结了很多方法，但你还是要去大湖大海去试一试的 97楼 shuise 2007-07-06 06:46发表 [回复] [引用] [举报] 再问：学习数据结构的最快的、具体的方法是什么？我现在准备把stl/loki/boost那些很精彩的代码打印下来研读，我觉得这就很锻炼人。 96楼 shuise 2007-07-06 06:43发表 [回复] [引用] [举报] 请问：封装可不可以认为是对过程的封装？？？？ 95楼 xshh4975 2007-06-26 22:48发表 [回复] [引用] [举报] 谢了。 也是，语言这东西的确，只有你站到了一定的高度才能看的更深吧。 可能就是因为我底层的知识不牢靠，感觉学什么的模模糊糊，似懂非懂。 但就是一个VC真的要打那么多的基础吗，不是有人也说，咱不是编译器，干吗要知道工作原理呐，只要会用不就行了吗？ 嘿嘿，可能咱有点急功近利了，我其实也不算是计算机专业的，所以有些东西搞的也不太明白。 不管怎么样，还是谢谢大哥对小弟的指点。 94楼 pongba 2007-06-26 09:59发表 [回复] [引用] [举报] to xshh4975: 感觉你的问题主要是基础不牢靠。 语言是上层建筑，如果下层根基打不好就来学语言，终究还是不稳当的。汇编、数据结构与算法、计算机系体结构这些大一的基础课程，不知道学了多少呢。如果没有的话还是先把《深入理解计算机系统》之类的书拿来翻一翻为好。 93楼 xshh4975 2007-06-25 23:07发表 [回复] [引用] [举报] 楼主和各位大侠说的感觉都挺有道理（俺是刚刚迈入VC大观园的刘姥姥），一切都很新奇，都很神秘，都很模糊！ 想来各位大侠都是此中高手，虽然各自“武功”不同，但肯定都是无数次经验教训的总结，对我们这些刚入道的后辈都有很大帮助。 看了这么多，越看越汗颜：高手都说学语言要下苦工夫，可咱这些年在学校电脑接触的可不少，用来学习的可不多。眼瞅这就毕业的人了，还是一窍不通！！ 前一阵子受一位老师的“感化”下定决心血拼VC，今天搞了半天MFC头晕脑涨上网闲逛看到了这篇帖子，很有感觉，顺便借此机会请教请教。前面那位仁兄说OS和Win32没学成就不要碰VC，我正好就是这种情况，是不是要“从头收拾旧山河”？ 新手泣留，望回！！！ 92楼 rulary 2007-06-25 15:17发表 [回复] [引用] [举报] 席地而坐 91楼 cxz7531 2007-06-25 13:39发表 [回复] [引用] [举报] 作者说的很好。 “你数学都学了,还有什么不能学的”这句话完全错误。 数学的思维跟面向对象编程的思维是不同。数学好不仅对OO编程无帮助，反而构成思维的障碍。数学是一种过程式思维，而OO编程则是对象式的思维。 在很多公司里都能发现：数学好的编不好程序，编程高手数学很烂 90楼 cynic1982 2007-06-24 18:55发表 [回复] [引用] [举报] 受益非浅！ 要有自己的方法！ 89楼 guest0708 2007-06-24 15:11发表 [回复] [引用] [举报] 也写不出一本像样的书. 88楼 guest0708 2007-06-24 15:10发表 [回复] [引用] [举报] 绝对支持myan,不知他的大名? 看看你们说说这些东西,就知道你们的水平了.还这么多人支持楼主,无知呀!唉,所以中国出不了大师. 87楼 lds2227 2007-06-24 12:43发表 [回复] [引用] [举报] 好东东啊 我看了c++ template 确实被细节给淹没了 看不下去了 好帖大家顶一顶 86楼 zouxinfox 2007-06-23 21:34发表 [回复] [引用] [举报] 楼上的这样说就不对了，本来争论就无所谓对错。 85楼 lmeng 2007-06-22 20:02发表 [回复] [引用] [举报] 这样的文章忽悠学生还可以 84楼 yang8761681 2007-06-22 16:32发表 [回复] [引用] [举报] 说得好,受益很深!谢谢老师的指点 83楼 julong88 2007-06-22 14:11发表 [回复] [引用] [举报] 看到如此好文！ 顶！ 82楼 bp0604 2007-06-22 11:26发表 [回复] [引用] [举报] myan老大说的一些话我很支持, 我还是觉得C好, C++搞得真是太复杂, 而让人望而生畏. 刘老大最后说的 \"认识自己并走一条最适合自己的路。这是最重要的\" 我很支持. 81楼 pongba 2007-06-22 10:51发表 [回复] [引用] [举报] ttreport: 你说的没错，这就是为什么我在文章开头说我自己也曾走了不少弯路，浪费了不少时间的原因。也是写这篇文章的初衷。 不过后来看大伙的意见，倾向于认为即便走弯路，也是很大的锻炼。药的是好身板（在走弯路中得到），不是那点技术储备。 不管怎样，作自己的判断，认识自己并走一条最适合自己的路。这是最重要的。 80楼 ttreport 2007-06-21 22:54发表 [回复] [引用] [举报] 真可笑，你博客里的东西大多就是鼓吹c++那些学院派东西 79楼 linkilike 2007-06-21 20:27发表 [回复] [引用] [举报] 刚才看了全文和评论，深有体会。在大学时，我们学校开完c语言，然后开了一些像os，编译原理，汇编语言等等。当时真的不知道学那些有什么用，到了学完以后，慢慢感觉到受益菲浅，现在我也是在学c＋＋，但是还没有深入的学习，学之前一直在想c++和c除了一个是面向对象和面向过程的，还有什么差别呢？因为时间原因一直没有深入的学习c＋＋，最近看了一些c＋＋内容，感觉有很大的区别，需要花大量的时间去深入的分析，当然你也会在这期间获得研究的兴趣。这是我的体会。 78楼 neocooler 2007-06-21 20:08发表 [回复] [引用] [举报] 看完了全文和所有的评论，我越发的感觉自己和神的差距，我大一了，看了之后感觉受益非浅！我感觉有许多话都是肺腑之言，里面藏着很多辛酸！语言组织的也非常好！真的很佩服！ 77楼 晨星 2007-06-21 18:45发表 [回复] [引用] [举报] 呵呵，向孟老师刘老师致敬。 不过还是更偏向于同意孟岩老师的观点。：P 至于论坛里的情况，我个人觉得没有必要去做过多的分析和争论了。因为这个跟C++语言本身关系并不是很大，问题没有那么复杂的，相反，非常简单，就是因为“并非所有的问题都适合在论坛里讨论”。论坛里可能还是灌水更适合一些，能讨论语言细节的好帖子已属难得了。而那些乐衷于解决“实际问题”，动辄把自己项目中的成百上千行代码帖到论坛里来让别人找问题的帖子，我是从来不看的。绝对不是说这种问题不好，而是说它不适合在论坛这种环境中讨论。不知道别人怎样的，我个人是只有工作累了的时候才会泡泡论坛。：P 76楼 vcnewer 2007-06-21 17:27发表 [回复] [引用] [举报] 同意myan 老大 当然 任务驱动的学习也不错，呵 75楼 kiseigo 2007-06-21 16:50发表 [回复] [引用] [举报] 说的好！！！真是太多的书在暗示细节的重要和有趣了！比如《Thinking in C++》呢？《C++编程思想》可以评论一下这本吗？ 我觉得《高质量C++/c编程指南》并没有强调语言的细节，只是强调编程风格的统一，和容易犯的指针，内存，if 等错误。 74楼 kofts 2007-06-21 12:27发表 [回复] [引用] [举报] 受教了。干了一年的开发，说实话学的有点半生不熟的；对于自己接下来应该继续学习哪方面的知识自己心里都没有想法，甚至连自己是否会把这么职业继续下去都没有什么深入的想法；但是心里有一直想着的就是把编程这个东西学好，哪怕是当作自己的一个爱好消遣。看了诸位牛人的发言有很多的感触啊，实际应用与理论技术，相辅相成；无需争论太多，嗨，继续自己的学习之路吧。 73楼 lzj123 2007-06-21 09:08发表 [回复] [引用] [举报] 为什么老有21天精通XX之类的书呢？ 72楼 CaiKanXP 2007-06-10 17:52发表 [回复] [引用] [举报] 钻研细节是吃饱撑着的人干的，中国现在还是发展中国家，富人还是少数，所以大家没事别去钻研细节。 71楼 snailjava 2007-06-08 16:39发表 [回复] [引用] [举报] 喜欢，不错的文章:) 不过BJ不喜欢的马克思的原因是马克思只考虑大众，不考虑到个人了：） 70楼 campuspuzzle 2007-05-26 15:24发表 [回复] [引用] [举报] to irons : 照你说的,干嘛把化学家排除?难道化学家就比数学家和物理学家智商低啊?行业不同不具有可比性,就跟体育运动一样,如果跨栏能跑过刘翔的不多,但论跑100米,比刘翔跑得快的多的是.争论这些没啥意义,如果自己真的是喜欢计算机这个行当,那就扎扎实实在这个行当做点事情，我们国家现在即没在计算机理论上也没在实践上做出什么象样的东西,成天讨论这些所谓的方法,等有一大批人能把CPU,OS,compiler,dbms玩弄于股掌,再来讨论这些方法，哪个时候的体会才有说服力,当下该做的是把没搞清楚的搞清楚.别用着D版,清谈方法. 69楼 irons 2007-05-26 00:20发表 [回复] [引用] [举报] to:campuspuzzle 呵呵,只要数学家,物理学家(撇开化学,我讨厌它)愿意,就肯定能成为计算机科学家. 我们老师总提示我们:你们出去以后不要自以为是,不要觉得能写程序,架构软件就了不起. (我只是就事论事,不是抬高谁贬低谁,正所谓社会分工不同) 68楼 irons 2007-05-26 00:11发表 [回复] [引用] [举报] to:YYLFYY 同感. \"C++ Builder中拖放控件做个画图程序更有用\"&lt;-笑! to:longtrue 的确,我也几头抓过 没办法啊,C++学的再好,公司还是先问你:精通VC6.0么?等等.........有的公司总想招聘的人当天下午就能干事. ----------------------------------------------- 恭喜 这里快成聊天室了. 67楼 irons 2007-05-25 23:52发表 [回复] [引用] [举报] 孟岩的话确实说得好 努力学了一门东西,学会思考举一反三后,能力就高了.什么WIN32的消息循环模式,MFC的封装,QT的信号和槽,JAVA的事件监听等都容易掌握了(但,且这些都是变数),也正如文章所说:具体这些中的细节我的确很多不知道,我也没多去钻研(但真正开发中就可得一定要弄懂哈);而是把时间花再C++中了.即便现在才知道C++/CLI(类比大哥所说的局部最优),但我想不会太难了. 我不后悔钻到语言中去.唯一遗憾的是:***,没能考入数学专业,无时无刻不存在心中的梦啊,我现在大字都在想 --------------------------------------------- 我都不好意思了,回复这么多,哎,实在是忍不住啊.HOHO 66楼 irons 2007-05-25 23:21发表 [回复] [引用] [举报] 一大哥说:我从来不看游戏编程之类的书. ----------------------------------- 我前段时间写了个文章,说我把那些语言看透了,说具体的语言和库的学习还没有学习数学好.(我承认后面这句话偏激了) 而遭到一个打击我自信的回复:楼主C++学精通了?我推测楼主看的C++书的顺序是:(略,他说的一点不错)C++ Templates看懂了多少?设计新思维又懂了多少?Loki库理解多少?楼主记住,C++入门需要五年. ---------------------------------- 老大们知道所谓的C++入门需要五年怎么来的呢? 65楼 irons 2007-05-25 23:12发表 [回复] [引用] [举报] # myan 发表于2007-05-16 22:08:22 IP: 222.131.240.* 太对了 我就只忍不住赞同下哈,没有我再需要补充的话了. 64楼 irons 2007-05-25 22:32发表 [回复] [引用] [举报] 一般性的编码实践准则，以及基本的编程能力和基本功，乃至基本的程序设计理论以及算法设计。才是真正需要花时间掌握的东西。 对啊,对于活在程序员上的程序员的我们来讲,更该去思考如何构建优秀应用程序.而这些并不要求非常高的c++技巧和机制. 那些机制只在第一类程序员来讲才更显得重要.:我说的是更哈. 63楼 irons 2007-05-25 22:29发表 [回复] [引用] [举报] 文章说得好 我还没看完,先回复了再说: c++的潜在心态就是挖语言的特性和技巧,不断的挖,而不是去学习QT,MFC之类的界面编程. 这点我是体会最深的了!!!!!!!!!! 也难怪有同学鄙视我学习c++这么久都没弄出他用java简单地就能做出的界面程序和数据库等网络程序. \"哭\"啊,俺C++里没网络没数据库等等.... 但是:花大量时间去挖去思维,对后来写应用程序的帮助很大,因为很多讲语言机制的书中都有抽象出应用程序的开发,只不过没给你提供组件类和方法调用而已. 62楼 infinitude_CN 2007-05-23 16:49发表 [回复] [引用] [举报] 实际上，这取决于每一个人自己的判断。 而这样的价值观分歧，从更本质看，原因大概就在于计算机科学本身就是个畸形的东西，一个建立在曾经的工具之上的科学。 61楼 infinitude_CN 2007-05-23 16:47发表 [回复] [引用] [举报] 如果是知识，那恐怕的确应该好好地学习，毕竟这里面包含的思想已经是“内功”的一部分了。 60楼 infinitude_CN 2007-05-23 16:46发表 [回复] [引用] [举报] 如果是工具，那么pongba说得对，我们应该抱着使用它的态度去学习，将仅有一份的时间拿来学习更可以算得上“内功”的知识。 59楼 infinitude_CN 2007-05-23 16:45发表 [回复] [引用] [举报] 这争论的根底，仿佛就是语言乃至计算机乃至关于计算机的一切究竟是工具还是知识？ 58楼 infinitude_CN 2007-05-23 16:43发表 [回复] [引用] [举报] 说两句愚见： 这个坑挖得很大。大到了能够引出价值观争论的地步了。 57楼 infinitude_CN 2007-05-23 16:41发表 [回复] [引用] [举报] 文字愈发大师化了……很好很好啊。 56楼 VBSpine 2007-05-23 10:14发表 [回复] [引用] [举报] 看了akirya的评论，突然也想写写自己学程序的一些经历和感想。 上学时候，本人的学校还可以，但专业和计算机毫不相干，自然也就没有同学和老师可以探讨。宿舍里唯一的一台就机器只有每天早上5：00-6：00是不打游戏的时间，这个时间就是我上机练习程序唯一的机会。 刚学的时候，也在想，程序设计学了到底是干什么的，但没人告诉我答案。后来发现了VB，为了追求快速的成就感，就用VB做各种Windows程序；至于学C语言的理由很简单，当时英语很差，VB的关键字和语句都很长，我一开始是把int分成三个字母来记的方式学的，所以看到C的语句那么简短，自然就爆发出强烈的学习欲望，然而C也并不好学，一段段痛苦的过程也让自己经常在想，为了业余爱好累成这样，真的有必要吗？ 最初，完全是目标的驱动，看到什么漂亮的界面和有意思的功能，就去模仿实现，完全没有什么章法，需要什么具体的知识，再去查找就是，曾经在私活迫在眉睫的状态下，一天一夜时间初步掌握了ADO，但这种日子持续下去，觉得没有什么实质性的进步，用VB写了一些小程序之后，也发现重复劳动越来越多，C语言也学的乱七八糟，全是黑乎乎的控制台，听人说数据结构是学程序的必备，于是抓了几本书乱看一气，后来一次偶然的机会，帮学校的几个师妹师弟参加一个比赛的时候涉及到了排序和其他的一点数据结构知识，奋战了两天一夜之后，突然发现自己开窍了，于是，看起了数据结构，操作系统，离散数学之类。。。。。。。 现在回头看看以前的那些事情，觉得程序设计语言终归是实现某些目的的方式，程序语言最初设计应该就是为了方便人来自定义和扩展计算机的功能的，对一些事情的规划和设计，还有有关平台和业务与原理性的知识（比如做网络程序时的TCPIP协议）才是首要的问题，其实那个时候更多的苦闷往往不是查不到程序语言的细节，而是有关平台内部知识的匮乏和把现实转化为程序的能力。 所以，现在推荐给好多比自己更初的初学者，一般都是这样双线并行的套路：1，操作系统，汇编，计算机网络，数据结构；2，某个具体的程序语言 说的有点乱，大家理解。 55楼 akirya 2007-05-23 09:27发表 [回复] [引用] [举报] 今天看了myan pongba老大的评论,感受颇深,我也写写我的学习经历吧.上学的时候拼命的学习C/C++以及其他语言但就是不知道这些能做什么,如何去做这个能用的程序相信这些对现在的学生来说是很普遍的问题.后来在毕业前的半年偶然看到了看雪的破解指南,那时候才一下子吸引过去了,如饥似渴的学习,要破解一个软件,需要了解很多操作系统的相关知识,语言的原理.就在那段时间给我打下了坚实的编程基础.相信这段时间也就是myan老大说的练习内功的阶段.虽说工作前我什么都没有做过,但我确实搞了几个简单的逆向工程.后来的工作就是写C++觉得C++来说也过如此,当然最初的工作并没有接触到STL模板元之类的东西.后来因为工作原因,主要去用ATL写COM,ATL太难懂了,又是钻研了很久.直到某一天忽然和之前学的知识融合了.在回过头来看,之前的基础必不可少.我相信基础是非常重要,基础差的话写几年程序也不会提高多少,顶多算是一个速成版的程序员.只能做表面的活,深一点的就做不了了.所以我认为,在学校的时候学好操作系统、数据结构、汇编语言绝对是练内功。 54楼 jsxxxly 2007-05-22 22:40发表 [回复] [引用] [举报] 楼上的，我说OS不复杂，指的是理论，不是细节。即使是细节，对于内核，也没有到不能学的地步。从学习的角度讲，学习计算机与学习数学、物理、化学是没有什么区别的，都是学习。你以为计算机是什么？技术的成分多于科学？仅仅会门编程语言在那儿比比划划就以为自己会计算机了？要是满世界都是你这样的，只懂技术不懂理论的，计算机早就停滞发展了。我拿计算机和数学比，那是抬举他，你是不是只认为全世界只有计算机才有用啊？ 53楼 jsxxxly 2007-05-22 22:33发表 [回复] [引用] [举报] 楼上的，我说OS不复杂，指的是理论，不是细节。即使是细节，对于内核，也没有到不能学的地步。从学习的角度讲，学习计算机与学习数学、物理、化学是没有什么区别的，都是学习。你以为计算机是什么？技术的成分多于科学？仅仅会门编程语言在那儿比比划划就以为自己会计算机了？要是满世界都是你这样的，只懂技术不懂理论的，计算机早就停滞发展了。我拿计算机和数学比，那是抬举他，你是不是只认为全世界只有计算机才有用啊？ 52楼 campuspuzzle 2007-05-22 21:17发表 [回复] [引用] [举报] 请问楼上的OS不复杂,什么东西复杂啊?你个人从那得出的OS不复杂的结论的? 计算机不仅是门科学也是门技术,甚至技术的成分多于科学,计算机的学习本质上和数学、物理、化学的学习也没什么太大区别?照你的逻辑,只要数学家、物理学家、化学家愿意,都可以成为计算机科学家,是吗?我怎么总觉得在中国有这么多奇谈怪论呢? 51楼 jsxxxly 2007-05-22 21:02发表 [回复] [引用] [举报] 用到什么学什么固然好，但这样学的知识不扎实，有些基础知识还是需要系统学习的。对于编程语言，个人认为至少有一门应该系统学习过。 学习一门编程语言到一定程度够用就可以了（什么程度够用只有自己最清楚），一个劲儿往下死抠也没什么意思。其实很多编程语言大同小异，学了这个又学那个真的是一件无聊的事情，太没有挑战性了。 对于pongda的说法，我认为是对的，掌握了一门语言的基本用法之后，其他细节的学习可以采用任务驱动的方式，但前提是掌握了基本用法。 很佩服myan大哥，过来人就是不一样，境界要更高一些。也许有一天，当你研究过了os,compiler,tcp/ip，会发现《计算机程序设计艺术》或者数学也许才是最有用的。个人觉得os并不是想象的那么难，因为冯.诺伊曼模型本身并不复杂。 计算机是一门科学，是需要学习的，这在本质上和学习数学、物理、化学也没什么太大区别，只是做实验相对方便一点而已，请不要天天围着实验工具这个话题讨论好吗？ 50楼 yshuise 2007-05-22 19:44发表 [回复] [引用] [举报] 细节分为两种：一种是语言细节。 一种是技术细节（比如算法细节）。 如果不重视语言细节，不能编程这是必然的。但是，可以临时查阅参考资料或是google一下。 对于技术细节（算法或是尤理论衍生出的思维模式）那可是一切的核心，是超越语言。也许工作的时候可以“copy\"，但是能力是不能“copy”的。试想一下，能不能进行理论研究？能不能像高手一样搞个发明？其实，中国还不断的重复知识——这几乎是弱者变成强者的有效路径。而检验我们成为强者没有的方式：便是看我们能否独立的创造。 49楼 wong 2007-05-22 13:35发表 [回复] [引用] [举报] 看到pongba和myan有不同的意见: 1.pongba的意思是在学习的过程中不要死抠着语言的细节不放,而应该在本质的,通用的,一般性的东西上面下功夫. 2.myan的意思是不要仅仅停留在某一技术的表面,而应该了解其本质和原理,做一些深入的探究. 其实二者的本意是一致的,都是要鼓励大家多学习本质的,通用的,一般性的东西.唯一的不同是pongba希望大家不要抠着语言细节,myan希望大家不要永远停留在表面. 48楼 akirya 2007-05-22 13:18发表 [回复] [引用] [举报] C++些节的东西太多了,一般人是无法掌握这么多的细节,高层次的技术. 但一个团队中如果有一个这样的语言专家存在,那么将对整个项目组来说是一个福音. 47楼 liuquanle 2007-05-22 13:00发表 [回复] [引用] [举报] 居然发现孟大哥在这样的文章中评论如此之多，由此可见这文章是很有影响力的。 46楼 shelok 2007-05-22 10:42发表 [回复] [引用] [举报] 你数学都学了,还有什么不能学的,这句话精辟; 45楼 anranhouse 2007-05-22 09:47发表 [回复] [引用] [举报] c++玄，学C++的人玄之又玄。都是没事自我折磨的变态。 44楼 TianChong 2007-05-22 03:44发表 [回复] [引用] [举报] 一定要将C++顶起来!!!!!!!!!!!现在C++没有得到新手的重视,很可惜!就算要学其它的语言,也建议一定要好好学学C++. 43楼 turingbook 2007-05-21 23:24发表 [回复] [引用] [举报] 其实比较一下《C++ Primer》第4版和第3版的内容（新版篇幅少了几百页），读一读比较新出的《C++编程规范》、《C++必知必会》、《Accelerated C++》，就能感觉到C++大佬们这几年来对于C++如何使用、如何学习和如何教授的转变了。 如果你还在学校学习，请向你的C++老师推荐《C++ Primer》第4版和《C++编程规范》这两本书。C++语言如此丰富，招数如此之多，知道哪些是更有效的也许比全面掌握更为重要。 42楼 jinhao7773 2007-05-21 21:37发表 [回复] [引用] [举报] 这是我见过所有评论C++的文章中最令我感到茅塞顿开的一篇 41楼 Memory_jy 2007-05-21 19:10发表 [回复] [引用] [举报] 受益匪浅 真的学到了很多方法 40楼 poscard 2007-05-21 14:12发表 [回复] [引用] [举报] 有道理。 在我见过牛人之前，总是想多了解些“知识”，见到真正的牛人后，发现差别在于思维方式、编程的习惯和做事的技巧上。而不是技巧知道的多或少。 39楼 hanxing_c 2007-05-21 10:30发表 [回复] [引用] [举报] 好好学学 38楼 longtrue 2007-05-20 17:16发表 [回复] [引用] [举报] 分析得很深刻，一说到这样的问题，肯定就会有很多参与的。时间只有一份，学底层东西花很长时间都未必能做出像样的东西，这时一般人都会有点浮躁；从一堆控件里搭积木般地做出个系统来，久了也会感觉根基浅。我有时会两样交替着学，总感觉时间不够用，人也够累的。 37楼 fantasydragon2 2007-05-19 15:45发表 [回复] [引用] [举报] 牛人啊，不得不佩服 36楼 campuspuzzle 2007-05-18 16:49发表 [回复] [引用] [举报] 大家都上过大学,一年级的高等数学,数学专业的学的内容跟非数学专业的相比很不一样,要艰深的多，为啥?因为别人是专业的,尽管数学专业的毕业后能成为数学家的很少,可能专门从事数学的也是很少的比例,但别人数学专业是不会降低要求的,为什么到了计算机专业这里就有这么多说法呢?既然是个专业就有相应的要求,无论你毕业后是搞高层的应用,还是搞底层的开发,甚至不从事计算机的行当,你都应该受到应有的专业训练,达到专业的要求,现在的要求已经很低很低罗,几乎低到了专业和业余界限不明显的地步,不知道怎么就还有那么多说法? 35楼 cnzhangzhen 2007-05-18 02:39发表 [回复] [引用] [举报] 转了一圈回来一看，各路老大毕至阿。 1 不仅仅是软件业，各个行业可能都需要不同层次的人才。我们固然不喜欢走出的都是只会if else的软件蓝领，但是个个超脱牛比也未必见得好事。不管是纵向深入，还是横向发展。我们都在遵循一个金字塔式的构成。关键是在合适的岗位要做到合格，具备胜任（或者只需要胜任）的能力。在这个基础上讨论才有意义--技术的挖掘是没有尽头的，未鹏在思考是否在细节上浪费了时间，孟岩说的是对那些没有具备基本合格功力从业者的忧虑，并无矛盾。 2 对于编程，我肤浅的以为，云风的认识应该是较具有说服力的，毕竟在一线干了这么多年。记得以前讨论过“编程的能力”，那么，我想，就像骑自行车一样，大家都会骑，但是未必都要去成为专业的自行车运动员--能骑就行，当然，爱好者越多越好。那些不会骑的，或者佯装骑行数年的，固然值得忧虑。正确的软件思维方式，正确的开发流程认识前提下，对语言的热爱只是肯德基和麦当劳对中国人的区别--随你爷高兴。 3 从学习编程的能力上来说，C++是一门需要苦行僧精神的语言。我十分推荐用python来入门，别忘了，我们编程，我们写软件，说到底也是为了自动化地做事罢了。从这个意义上说，我曾经的吃饱喝足的蠢猪leader倒也不错，.bat写得很好。 4 顺道赞一下未鹏这次挖的坑阿，大家跳啊。 -- www.cnzhangzhen.com 34楼 YYLFYY 2007-05-17 21:34发表 [回复] [引用] [举报] 个人觉得myan老大和pongba老大说的都是正确的，外功与内功，知识和技能，本来就是见仁见智的问题（有些像前段时间金旭亮老师和yuanfeng老大的观点） 我个人很喜欢往细节底层里钻，喜欢《C++ Primer》，喜欢看Lippman把深藏在水下的东西都翻出来展示给大家看，也非常的固执的认为，没有掌握OS和Win32之前，绝对不要碰VC或者BC。 有时间也很迷茫，因为学了那么久，现在也不能写个像样的东西出来。pongba老大说的细节问题反应在论坛上，myan老大说的务实问题反应在学校里，的确是这样。 学校里，没有人会在乎你懂得重载函数的解析过程，或者是说清楚指向函数指针数组的指针这些杂七杂八的东西。“什么？你用Dephi做了一个航空管理系统！”“这个在线答题系统是你用Java设计的？！牛！”通常是这么回事。一方面，企业对于项目经验的要求；另一方面，是学生自己“学以致用”的思想，两者结合，就出现了myan老大说的那种“中国的学生不是太务虚，而是太务实”的观点。是啊，学了没有用的东西，谁会去学。“学OS能写操作系统吗？”“学编译能写Complier吗？”不能，所以还不如学学如何在C++ Builder中拖放控件做个画图程序更有用。 论坛上就不同了，高手低手汇聚一堂，能写航空管理系统算啥，能写虚拟机的人都多得数不过来。当然，能说清楚类模板的名字解析的人就很少了。能开发项目，能写底层，但要是给一张大学C++试卷，能难说能不能及格。细节出于此，在网络上，大家都喜欢把语言的底层机制翻来覆去的玩耍。 我想myan老大考虑的是，工作后不像在大学里，有足够的时间能系统的学习细节和底层，所以偏重于强调大学期间修炼内功。pongba老大从C++学习来分析程序设计的学习之路，强调不要死抠细节，毕竟编程不是单纯的语言控制。两位老大都说得在理。 33楼 bladesun 2007-05-17 20:22发表 [回复] [引用] [举报] myan老大认为下功夫的这个过程最重要，而对于方向选择问题只能求得局部最优。 既然这样，在C++的学习方法上，我觉得lz的方法应该算得上是局部最优的。 这么说来，二者是不矛盾的。呵呵！ 32楼 campuspuzzle 2007-05-17 17:06发表 [回复] [引用] [举报] 赞同myan的说的,计算机专业的熟悉c后就应该赶快去学习和研究OS,compiler,tcp/ip,dbms,最好能深入到代码的程度,而不是只知道点概念泛泛而谈,至于c++如果有时间能成为语言律师也行哦,最重要的是能沉下心来,坚持多年,在坚持的过程中提升能力.现在这样的学生太少,不说本科生,研究生里也不多见,多数人都醉心于java,.net,但很少有对java .net VM有兴趣的. 31楼 universee 2007-05-17 15:49发表 [回复] [引用] [举报] 太极语言之父强烈反对此篇文章，我想孟岩老大也是强烈反对的，只是不好说出而已，在这里也替孟岩老大表示强烈反对。不知孟岩老大意下如何。 ……………… 工作太忙，现在没时间多说，等以后有空了写篇文章。 30楼 清风雨 2007-05-17 12:01发表 [回复] [引用] [举报] 好文啊！说真的，看其中部分，让人热血沸腾。^_^ 很想转载连接! 呵呵。 下面有点个人观点： 关于细节，还是应该适度关注。可以适度的拉伸深度和广度（原来还有这一手嘛，所以也算得上广度）。我以前是很不怎么习惯模版的，但实际上现在基本天天和模版交互。而且真正用时，经常会考虑我是改用vector还是string还是deque。 我一直觉得能力，并不等于知识；知识不能转化为能力，或多或少沦为有书呆子嫌疑。但现在发现很多时候缺乏论证的资料数据。体现出信息、内容的缺乏，也是就知识缺乏。 在大学时想办法实现复杂的算法，觉得那也是编程；逐渐就发现编程不等于软件，而我们要做的并不是编程，而是软件。—— 其实，我觉得对于算法的强调，一定程度导致了所谓国内程序员不错，但软件很糟。 29楼 startday 2007-05-17 10:35发表 [回复] [引用] [举报] myan老大这句话很实在： 重要的是这个磨练过程，而不是结果，要的是你粗壮的腿，而不是你身上背的那袋盐巴。 初学者迷茫是学什么？学哪门语言？学这个语言的哪些细节？细节研究到什么程度？是能做出考试题就够了？是能做出面试题就够了？是能回答论坛上的问题就够了？怎么学？死啃书？啃哪些书？去实习？怎么找实习？找哪方面的实习？等等等等，时间往往在犹豫在松懈的时候滑过去了。 所以非常认同myan老大说的，重要的是过程，是不是坚持了，是不是专注了，是不是做到局部最优了。 28楼 jq0123 2007-05-17 10:23发表 [回复] [引用] [举报] C++语言的制定者就是神啊！ 上帝造了天地人，就有了万物，其中还有C++。 然后C++就成了上帝，开始创造一切。 27楼 startday 2007-05-17 10:20发表 [回复] [引用] [举报] 非常想知道， 刘老大现在做什么工作呢？或者还在读书？ g9老大现在做什么工作呢？或者还在读书？ myan老大现在做什么工作呢？或者还在读书？ 26楼 chechezhu 2007-05-17 10:12发表 [回复] [引用] [举报] 可以建立“C++目录学”，平时只背书皮儿，用的时候查内容，哈哈 25楼 myan 2007-05-17 09:59发表 [回复] [引用] [举报] 我曾经问过一个美国大学的教授，是一项国际大学生编程大赛的主席，那些编程大赛的题目究竟对实际软件开发有什么用？他说，其实他们也知道不太有用，但是第一只有这个形式的东西搞比赛容易操作，真正有用的东西没法比赛，第二，重要的是选手参与这个比赛的过程，要想取得最好的成绩，往往要花几年时间，做几千题，几千道跟实际软件开发没太多关系的题。最后证明，在这个大赛中取得好成绩的，以后在工作中大多数也能取得好成绩。你说这个弯子绕的大不大，这个时间花得冤不冤？ 最后，其实这些话是写给你的，也是写给我自己的。10年前的这个时候，正好是我已经熟练掌握了C，开始雄心勃勃地向C++主峰发起进攻的时候。今天如果能够让我年轻10岁，回到大学里重新选择，我可能不会选择深入研究C++，而是把C学透了，就去研究OS、Compiler、TCP/IP。但是当年我看不到这些，只能看到C++。我后悔吗？不太后悔。人只能在一种局限性与另一种局限性之中选择，走了那条路，今天就会后悔别的事情。如今我对IT这个产业链有所了解之后，更觉得世界之大，岂是一人一时所能逆料。所以全局最优是可望不可及的，个人所能做的，只是追求局部最优而已，然后让命运的大浪把你送上高峰或者拍入深渊。比如，你以为出国读书，一定是好？你以为被一流大公司高薪聘请，一定是妙？你以为你在学生阶段写出一个软件，搞得天下闻名，万人敬仰，就一定有好结局？真的不一定啊。但是不一定，是不是我们就可以吊儿郎当，游手好闲？当然不是。全局最优不可期盼，但局部最优一定要努力争取，要按照自己定的路线去踏踏实实的努力，取得尽可能好的成果。所以，你要想做个好的语言律师，就踏踏实实下功夫去做吧，没什么不对的。还是那句话，下足功夫，练出一副好身板，比什么都重要。如果说后悔，我从不后悔技术路线的选择，只是后悔那时候下得功夫还是不够，还是拿出太多的时间去看电视，吃烧烤了。 Re: 阿波 2011-07-26 09:31发表 [回复] [引用] [举报] 回复myan：个人很同意孟老师的观点。 无论何时何地，做何种工作，都要恒久学习，尤其软件开发，要恒久学习内功，就像张无忌，阴差阳错地接受了有18个level的九阳神功，从此内功变得无比深厚，再学乾坤大挪移时就很快了，最后在学习太极时居然是在和别人打斗的过程中听张三丰口授当场学习的。其他的武功如圣火令神功、少林龙爪手、崆峒七伤拳、武当长拳、武当梯云纵等，是在学会九阳神功和乾坤大挪移之后触类旁通的，拿过来就能用。（这里的触类旁通是重点。） 这说明了什么？——说明内功、心法的重要。 （另：阅读金庸先生的书或看金庸先生的电视剧，不仅可以学习武林豪杰的仁义勇德，还可以学习一些做人、做工作、学习的道理。——这才是核心竞争力。一个人有了核心竞争力，到哪里都能很快上手。） 关于张无忌可参考：http://baike.baidu.com/view/22957.htm 关于笔者可参考：http://blog.csdn.net/livelylittlefish, http://www.abo321.org。 谢谢。 Re: 匿名用户 2010-06-15 22:38发表 [回复] [引用] [举报] 回复 myan： [e06] 真知灼见啊，当年在学校就是这么给c++细节“折磨”过来的，强烈推荐给学生们。 Re: C云 2010-05-16 23:49发表 [回复] [引用] [举报] 回复 myan：经典名言。感慨深刻，多谢多谢！ 24楼 myan 2007-05-17 09:57发表 [回复] [引用] [举报] to pongba: 你的基本观点我当然是赞同，相信每个从细节走出来的人都会赞同。问题在于对于初学者（当然主要是学生），怎么走合适。你说： “时间只有一份。对于中国的学生，尤其如此。” 事实上，任何工作了几年的人都能感觉到，学生阶段是最有时间的，工作了以后就没时间了。所以如果要走弯路，要琢磨一点语言细节，要做一点吃饱了撑的事情，练一点内功，最好在学生阶段走。当然，你觉得，如果在学生阶段都不走弯路，那岂不是更好？看上去当然更好，但是走弯路是不是真的可以避免，那条路是不是弯路，你指的路是不是就那么直，不那么好说的。特别是在你人生不同的阶段，你会对自己的过去有不同的看法和评价。我的观点就是，总体上讲，弯路是不可避免的，走弯路也不全是坏事，甚至在年轻的时候多走弯路，可能是太好太好的事情了。你以为的直路，说不定到头来是更大的弯路。人生的事情很难说清楚，最不用后悔的是受磨砺，最不用担心的是没机会。 至于那条“直路”，对于学生来说还挺令人向往的，可等到工作阶段，你立刻就能体会到是个什么感觉了。每天都被任务驱动着，根本不用自己费力去找“pragmatic”方式，每天都是街头喋血，连回去练练扎马步、丹田气的机会不多。到时候别说语言细节，就是一些必要的应用数学、算法理论之类的东西，也只能见缝插针学一点，囫囵吞枣，解决问题就好。实际上未鹏你是中国学生里的一个异数，你在学生阶段踏踏实实搞了一些“语言律师”的东西，因此现在有所反思，觉得自己应该早点街头肉搏，而且现在你去街头肉搏，最多已开始有点不适应，一旦适应之后，你就够厉害，因为你内功厚。但是大多数学生，他们一开始的学习方式就是你所倡导的“pragmatic”街头喋血。但是他们的结果，不是写出Notes规则引擎，不是开发出联众，而是搞了多年ASP，不知道HTTP原理；学了三年.NET，但就是理解不了异步编程模型，一碰到BeginInvoke就发怵；写了两年MFC程序，不理解Windows事件模型，一遇到问题就只能抓瞎。我这些说法都不是凭空说的，背后都有我身边的实际例子。如果你把视野放的足够大，你就会认识到，中国的学生不是太务虚，而是太务实，不是太不实用主义，而是太实用主义了。所以我觉得你的这个呼吁，对于一小部分人来说是合适的，对于绝大多数人来说是不适用的。 当然，工作当中需要了解的细节也是有的，比如做国际化的人，需要对字符编码的问题滚瓜烂熟，搞Windows向Linux移植的人，需要对Windows内部钩子的实现、Linux/X系统内部事件机制了然于心；搞WinCE开发，需要对微软ActiveSync的一些编程接口非常熟练。这些细节，或者说特定领域的知识技术，没有具体的应用背景和支撑环境，是不可能学进去的。因此现在大公司招高校毕业生，普遍比较理性，知道学生没有那个环境和条件搞pragmatic，一般都是不要求的。就看你基础打得扎实不扎实，有没有钻研精神。重要的是这个磨练过程，而不是结果，要的是你粗壮的腿，而不是你身上背的那袋盐巴。 我曾经问过一个美国大学的教授，是一项国际大学生编程大赛的主席，那些编程大赛的题目究竟对实际软件开发有什么用？他说，其实他们也知道不太有用，但是第一只有这个形式的东西搞比赛容易操作，真正有用的东西没法比赛，第二，重要的是选手参与这个比赛的过程，要想取得最好的成绩，往往要花几年时间，做几千题，几千道跟实际软件开发没太多关系的题。最后证明，在这个大赛中取得好成绩的，以后在工作中大多 23楼 tom_c 2007-05-17 09:41发表 [回复] [引用] [举报] 楼主写得真是\"一语惊醒梦中人\"啊 22楼 onemonth 2007-05-17 09:39发表 [回复] [引用] [举报] 细节决定成败。普遍意义上讲，对细节掌握越多（是掌握），水平自然越高，这个没有疑议，至于在代码中用不用它，是另一回事情。如果只是掌握常用法，也就限制了自己的眼界，水平自然提不高。就像我们都会说中文，但是只有对中文细节掌握得多的人才是语言学家，这两者是泾渭分明的。如果想提高自己的水平，还是得掌握语言的细节。 “避免去过问任何语言细节，除非必要。” “熟练运用一门语言绝不意味着要把它的边边角角全都记住。懂得一些常识，有了编程的基本直觉，遇到一些细节错误的时候再去查书，是最节省时间的办法。” ----------------------------------------------------- 联系这两段话，我以为楼主的意思是说，平时不需要去了解细节。但是不知道有没有“不去知道这些细节”的意思。如果有这个意思，那就有问题了。如果平时不多看看细节，也就是说不知道有这些东西的存在，你怎么知道要查书？怎么知道能这样作？我见过一些c++程序员，就是这样的例子。 同时，楼主又说， “一个对语言把握很细致的人肯定能够得到更多的佩服，而由于论坛上的问题大多是小问题，所以解决实际问题的真正能力并不能得到显现” 其实这个和语言是同样的，只是解决实际问题时，关注的是相关问题域的细节而已。作为程序员，作的事情就是把实际问题用c++表达出来，那么对两者的细节都需要了解。当然，这个话的前提是：自己想成为一个牛人。我想，任何人都想自己是头牛的。 那么怎样理解BS教主的话，“实际上，正确的态度是，细节是必要的。但细节是次要的。”呢？我以为，首先是因为他已经很牛了，对相关的东西已经烂熟（不是指什么都记住，而是说能一下知道哪里找到需要的东西）。现在他关心的领域已经改变了，细节也转移到相关的领域了。看看教主写的c++演化这个书，就知道在设计c++的时候，对细节是多么的关注。因为这个时候，他关注的领域是c++。 21楼 liangshi 2007-05-17 09:09发表 [回复] [引用] [举报] BJ说过，C++是可以伴随你成长的语言。侯捷说过，正确的观念重于一切。 学习C++还是要找一本阐述“正确C++观念”的好书，然后在实践中循序渐进。目前的大学教育，由C导入C++，实际上走了很大的弯路。不传达boost::shared_ptr胜过原生指针、不传达vector&lt;int&gt;胜过new int[10]的教学是C++发展的重要问题之一。 C++09在标准库和语言上都有很大的发展。如何合理的使用、配合concept机制，如何高效的使用新一代标准库，是摆在所有C++开发者和学习者面前的新问题。也是C++教学者、传播者应该立即着手准备的课题。似乎侯捷老师、荣耀老师都有一些新动向？ 20楼 chinux265 2007-05-17 08:59发表 [回复] [引用] [举报] 有一定的道理. 19楼 Eric Wong 2007-05-17 08:10发表 [回复] [引用] [举报] 另外我觉得大环境也是个问题，你去企业应聘，跟人家说你会C++，人家会问你会不会VC，会不会Win32，说不懂，企业还不一定理你！ 18楼 Eric Wong 2007-05-16 23:10发表 [回复] [引用] [举报] 好文！ 中国的程序员所处的环境，语言被过份强调，而其它很多一样重要的东西却被忽略了。 推荐C++的学习方法：任务驱动方法！ 17楼 g9 2007-05-16 23:04发表 [回复] [引用] [举报] 说到实战派和学院派，这篇文章的类比很有意思：http://www.lambdassociates.org/Blog/hackers.htm。实战派的好比街头打架出身，讲究招招见血。学院派的好比武馆出身，搞不好就成了只讲究\"寸止\"，被泰国人打得满地找牙的艺术派空手道。一般来说街头喋血的老大们可以轻松干掉武馆的毕业生。但能够开宗立派，睥睨武林的，还是骑墙派：既深研武道，又身经百战。嘿嘿，有点跑题了。 16楼 g9 2007-05-16 22:47发表 [回复] [引用] [举报] 看得俺激动啊，都想重新开始看C++了。刘老大为了让我们航海，又让我们领略了大海的壮丽哈。:-) 15楼 疯狂明仔 2007-05-16 22:39发表 [回复] [引用] [举报] 同感,, 个掌握了基本的编程理念并有较强学习能力的程序员在用一门陌生的语言编程时就算拿着那本语言的圣经从索引翻起也可以编出合格的程序来。十年学会编程不是指对每门语言都得十年，那一辈子才能学几门语言哪，如果按字母顺序学的话一辈子都别指望学到Ruby了；十年学习编程更不是指先把语言特性从粗到细全都吃透才敢下手编程，在实践中提高才是最重要的。 看来都是实战派人士 14楼 pongba 2007-05-16 22:23发表 [回复] [引用] [举报] myan老大提到： <blockquote> 所以我觉得，多绕点弯路其实没关系，力气还是长在了自己身上。关键还是要踏踏实实下功夫搞。如果让我回答“应当如何学习C++”这个问题，我只有一句话可说，那就是：“下足功夫”。 <\/blockquote> myan老大所说的下足工夫当然是无可厚非的。做任何事都是这样，不下足工夫不可能认识到一些东西。 但真正的问题是工夫是花在刀刃上还是刀背上。是下足工夫做语言律师还是下足工夫搞实践。 时间只有一份。对于中国的学生，尤其如此。C++的细节庞杂无比，C++的书籍满天飞，光是下足功夫学习语言核心都不知道要多久。由于时间只有一份，所以就没时间去学习更重要的编程基本功、解决实际问题的能力、算法，等等。后者同样可以达到锻炼乃至是更强的锻炼。所以，光是要下足功夫其实是避开了真正的问题。 我自己也经历了myan老大的这个过程。我的看法跟myan不一样。我认为时间是宝贵的，所以工夫自然要下，但真正的问题是，往什么地方下。 g9老大提到： <blockquote> Damien Katz重写Notes公式引擎的前还不懂C++, 读了一半《C++ Programming Language》就后就上手了。鲍岳桥他们开发联众前也不懂Win32，但还是一边查手册一边把联众开发出来。那是可还不能用Google满世界找资料。 <\/blockquote> 这种下功夫的方式我非常认同。窃以为这才是真正pragmatic的方式，一来用实践驱动学习有干劲，而来不容易堕入为学习而学习从而迷失的地步，三来这非常锻炼人解决实际问题的能力。四来这样的学习是最“经济”，效率最高的。 13楼 myan 2007-05-16 22:08发表 [回复] [引用] [举报] 我想每一个曾经深入研究那些细节的人，或迟或早都还是会走出来的。2000年我开始研究STL，后来到Loki，再后来一点点Boost，也曾经以为细节掌握越多、语法规则运用越熟练、奇思妙想越多，就是水平越高。当年曾经跟一个朋友在论坛里斗编程，他写一个Python程序，我写一个C++程序，看谁简洁。写实际产品的时候，不用上STL、Design Patterns就亏心得睡不着觉。我把boost::mempool/smart pointer给剖离出来，移植在Windows CE 3.0平台上。当时的eVC3仅具有初步的模板支持能力，要做大量的代码修改剪裁工作。后来的结果是，内存分配比WinCE CRT的malloc加速85倍，当时高兴的不得了。那种感觉，今天回想起来恍如隔世。 可是到了03年初，就已经发现这个路子有问题。程序毕竟是以用为本，而真正有用的程序，反而在编码上往往是质朴的，强在对领域知识的理解和创新上，对用户需求的把握和体现上。从那时开始，我的思想发生了一个痛苦的嬗变。在认识到自己过去所想有问题的同时，也进入了一种迷茫状态，丧失了对一切语言和技术细节的学习兴趣。什么.NET，Java，POSIX，Compiler, Web，SOA，好玩的东西就那么一小撮，大部分细节是索然无味的，甚至面目可憎。这个状态持续了将近两年，才随着对Python、Ruby的了解而逐渐过去。 现在回过头来反思，当年拼命研究那些细节，固然是进入误区，但是何尝又不是一段历练。现在C++社群的大牛们纷纷提出要改造C++教学路径，这个我当然是支持了。现在的C++学习者可以不用绕弯路，可以直接用那些高层抽象工具解决问题，不用再苦苦理解什么函数重载决议的规则，不用为内存的高效利用而发愁，对于做具体项目来说当然幸福，但是对他们的技术成长就一定是好事吗？恐怕也未必。少了一份磨难，也就少了一份成熟。 所以我觉得，多绕点弯路其实没关系，力气还是长在了自己身上。关键还是要踏踏实实下功夫搞。如果让我回答“应当如何学习C++”这个问题，我只有一句话可说，那就是：“下足功夫”。 12楼 g9yuayon 2007-05-16 22:05发表 [回复] [引用] [举报] 这篇写得真不错。收藏了。Damien Katz重写Notes公式引擎的前还不懂C++, 读了一半《C++ Programming Language》就后就上手了。鲍岳桥他们开发联众前也不懂Win32，但还是一边查手册一边把联众开发出来。那是可还不能用Google满世界找资料。 Re: yuezhiren 2011-11-20 11:32发表 [回复] [引用] [举报] 回复g9yuayon： g9 老大能否写一篇文章剖析一下这种现象.十分敬佩这一类人的勇气.但是我觉得对于这一类人,最可怕的不是不懂C++写出来Notes公式引擎,不是开发联众前也不懂Win32.而是写出来的Notes公式引擎不断向正确的方向前进,随着用户规模的不断扩大,联众的程序也随着能够不断的扩大,优化.可以用来隐喻一下的就是人的肢体,从小到大这种成长的能力.我认为这种能力是最可怕的. 11楼 dounking 2007-05-16 20:55发表 [回复] [引用] [举报] 关键还是看应用领域，能用其他语言开发的都尽量别选c++。毕竟纯粹从开发效率上来讲，要找出一个比c++还低的语言现在还真是不容易:) 不过话又说回来，那些“必须”用c++来解决的问题，细节问题关键时候还是显得很重要，这也是c++的强项。 10楼 chengmeng 2007-05-16 20:06发表 [回复] [引用] [举报] 好文章。我觉得C++社区的理念最近几年的确在慢慢改变，开始强调语言的易用易学了。我自己也曾经想好好念念C++ Primer，但里面大量的细节实在让我看不下去。 9楼 googol 2007-05-16 18:58发表 [回复] [引用] [举报] 好文！我顶！Re上十大！！（有点太激动了） 最近很喜欢用python写东西，那种简洁灵动的感觉真好。 8楼 angel_smile 2007-05-16 18:57发表 [回复] [引用] [举报] 有启发了 也看看《高质量C++编程指南》去 7楼 leonchenjian 2007-05-16 18:15发表 [回复] [引用] [举报] 文章真的很不错，我转到我们学校的论坛里了，不好意思，先斩后奏了，不会惩罚我吧.. 6楼 zuroc 2007-05-16 17:42发表 [回复] [引用] [举报] 写到太好了 5楼 pongba 2007-05-16 17:09发表 [回复] [引用] [举报] 呵呵，《CC2》我在文章里面链接到了。没注意到？是的，我的确认为CC2才属于入门好书。 4楼 cnzhangzhen 2007-05-16 16:09发表 [回复] [引用] [举报] pp兄所言不虚！ 从这个角度，我想不该是 高 ，而应该是类似于 code complete这样的书才是指导如我等一般程序员的 入门好书。 3楼 turingbook 2007-05-16 16:07发表 [回复] [引用] [举报] 好文章。 没有提到我们出的《C++ Primer》（http://www.dearbook.com.cn/book/92394）？学C++应该由此开始。 2楼 pongba 2007-05-16 15:30发表 [回复] [引用] [举报] HumanChao wrote: <blockquote> 这么好的帖子怎么没人支持一下呢.我感觉那本《高质量C++编程指南》道是挺实在，只有100页，用点心2个小时就可以读完。公司每进一名新员工我都会介绍此书。 <\/blockquote> 《高》是一本有用的书，我也读过。但不应该用来影响初学者的编程哲学。许多人读《高》这样的书都容易形成一种感觉，就是细节非常重要。 实际上，正确的态度是，细节是必要的。但细节是次要的。 1楼 Humanchao 2007-05-16 15:13发表 [回复] [引用] [举报] 这么好的帖子怎么没人支持一下呢.我感觉那本《高质量C++编程指南》道是挺实在，只有100页，用点心2个小时就可以读完。公司每进一名新员工我都会介绍此书。 你应当如何学习C++(以及编程)(rev#1)   By 刘未鹏(pongba) C++的罗浮宫(http://blog.csdn.net/pongba)   Javascript是世界上最受误解的语言，其实C++何尝不是。坊间流传的错误的C++学习方法一抓就是一大把。我自己在学习C++的过程中也走了许多弯路，浪费了不少时间。   为什么会存在这么多错误认识？原因主要有三个，一是C++语言的细节太多。二是一些著名的C++书籍总在（不管有意还是无意）暗示语言细节的重要性和有趣。三是现代C++库的开发哲学必须用到一些犄角旮旯的语言细节（但注意，是库设计，不是日常编程）。这些共同塑造了C++社群的整体心态和哲学。   单是第一条还未必能够成气候，其它语言的细节也不少（尽管比起C++起来还是小巫见大巫），就拿javascript来说，作用域规则，名字查找，closure，for/in，这些都是细节，而且其中还有违反直觉的。但许多动态语言的程序员的理念我猜大约是学到哪用到哪罢。但C++就不一样了，学C++之人有一种类似于被暗示的潜在心态，就是一定要先把语言核心基本上吃透了才能下手写出漂亮的程序。这首先就错了。这个意识形成的原因在第二点，C++书籍。市面上的C++书籍不计其数，但有一个共同的缺点，就是讲语言细节的书太多——《C++ gotchas》，《Effective C++》，《More Effective C++》，但无可厚非的是，C++是这样一门语言：要拿它满足现代编程理念的需求，尤其是C++库开发的需求，还必须得关注语言细节，乃至于在C++中利用语言细节已经成了一门学问。比如C++模板在设计之初根本没有想到模板元编程这回事，更没想到C++模板系统是图灵完备的，这也就导致了《Modern C++ Design》和《C++ Template Metaprogramming》的惊世骇俗。这些技术的出现为什么惊世骇俗，打个比方，就好比是一块大家都认为已经熟悉无比，再无秘密可言的土地上，突然某天有人挖到原来地下还蕴藏着最丰富的石油。在这之前的C++虽然也有一些细节，但也还算容易掌握，那可是C++程序员们的happy old times，因为C++的一切都一览无余，everything is figured out。然而《Modern C++ Design》的出世告诉人们，“瞧，还有多少细节你们没有掌握啊。”于是C++程序员们久违的激情被重燃起来，奋不顾身的踏入细节的沼泽中。尤其是，模板编程将C++的细节进一步挖掘到了极致——我们干嘛关心涉及类对象的隐式转换的优先级高低？看看boost::is_base_of就可以知道有多诡异了。但最大的问题还在于，对于这些细节的关注还真有它合适的理由：我们要开发现代模板库，要开发active library，就必须动用模板编程技术，要动用模板编程技术，就必须利用语言的犄角旮旯，enable_if，type_traits，甚至连早就古井无波的C宏也在乱世中重生，看看boost::preprocessor有多诡异就知道了，连C宏的图灵完备性（预编译期的）都被挖掘出来了。为什么要做这些？好玩？标榜？都不是，开发库的实际需求。但这也正是最大的悲哀了。在boost里面因实际需求而动用语言细节最终居然能神奇的完成任务的最好教材就是boost::foreach，这个小设施对语言细节的发掘达到了惊天地泣鬼神的地步，不信你先试着自己去看看它的源代码，再看看作者介绍它的文章吧。而boost::typeof也不甘其后——C++语言里面有太多被“发现”而不是被“发明”的技术。难道最初无意设置这些语言规则的家伙们都是oracles？   因为没有variadic templates，人们用宏加上缺省模板参数来实现类似效果。因为没有concepts，人们用模板加上析构函数的细节来完成类似工作。因为没有typeof，人们用模板元编程和宏加上无尽的细节来实现目标… C++开发者们的DIY精神不可谓不强。   然而，如果仅仅是因为要开发优秀的库，那么涉及这些细节都还是情有可原的，至少在C++09出现并且编译器厂商跟上之前，这些都还能说是不得已而为之。但我们广大的C++程序员呢？大众是容易被误导的，我也曾经是。以为掌握了更多的语言细节就更牛，但实际却是那些语言细节十有八九是平时编程用都用不到的。C++中众多的细节虽然在库设计者手里面有其用武之地，但普通程序员则根本无需过多关注，尤其是没有实际动机的关注。一般性的编码实践准则，以及基本的编程能力和基本功，乃至基本的程序设计理论以及算法设计。才是真正需要花时间掌握的东西。   学习最佳编码实践比学习C++更重要。看优秀的代码也比埋头用差劲的编码方式写垃圾代码要有效。直接、清晰、明了、KISS地表达意图比玩编码花招要重要…   避免去过问任何语言细节，除非必要。这个必要是指在实际编程当中遇到问题，这样就算需要过问细节，也是最省事的，懒惰者原则嘛。一个掌握了基本的编程理念并有较强学习能力的程序员在用一门陌生的语言编程时就算拿着那本语言的圣经从索引翻起也可以编出合格的程序来。十年学会编程不是指对每门语言都得十年，那一辈子才能学几门语言哪，如果按字母顺序学的话一辈子都别指望学到Ruby了；十年学习编程更不是指先把语言特性从粗到细全都吃透才敢下手编程，在实践中提高才是最重要的。   至于这种抠语言细节的哲学为何能在社群里面呈野火燎原之势，就是一个心理学的问题了。想像人们在论坛上讨论问题时，一个对语言把握很细致的人肯定能够得到更多的佩服，而由于论坛上的问题大多是小问题，所以解决实际问题的真正能力并不能得到显现，也就是说，知识型的人能够得到更多佩服，后者便成为动力和仿效的砝码。然而真正的编程能力是与语言细节没关系的，熟练运用一门语言能够帮你最佳表达你的意图，但熟练运用一门语言绝不意味着要把它的边边角角全都记住。懂得一些常识，有了编程的基本直觉，遇到一些细节错误的时候再去查书，是最节省时间的办法。   C++的书，Bjarne的圣经《The C++ Programming Language》是高屋建瓴的。《大规模C++程序设计》是挺务实的。《Accelerated C++》是最佳入门的。《C++ Templates》是仅作参考的。《C++ Template Metaprogramming》是精力过剩者可以玩一玩的，普通程序员碰都别碰的。《ISO.IEC C++ Standard 14882》不是拿来读的。Bjarne最近在做C++的教育，新书是绝对可以期待的。   P.S. 关于如何学习编程，g9的blog上有许多精彩的文章：这里，这里，这里，这里… 实际上，我建议你去把g9老大的blog翻个底朝天 :P   再P.S. 书单？我是遑于给出一个类似《C++初学者必读》这种书单的。C++的书不计其数，被公认的好书也不胜枚举。只不过有些书容易给初学者造成一种错觉，就是“学习C++就应该是这个样子的”。比如有朋友提到的《高质量C/C++编程》，这本书有价值，但不适合初学者，初学者读这样的书容易一叶障目不见泰山。实际上，正确的态度是，细节是必要的。但细节是次要的。其实学习编程我觉得应该最先学习如何用伪码表达思想呢，君不见《Introduction to Algorithm》里面的代码？《TAOCP》中的代码？哦，对了它们是自己建立的语言，但这种仅教学目的的语言的目的就是为了避免让写程序的人一开始就忘了写程序是为了完成功能，以为写程序就是和语言细节作斗争了。Bjarne说程序的正确性最重要，boost的编码标准里面也将正确性列在性能前面。   此外，一旦建立了正确的学习编程的理念，其实什么书（只要不是太垃圾的）都有些用处。都当成参考书，用的时候从目录或索引翻，基本就对了。   再再P.S. myan老大和g9老大都给出了许多精彩的见解。我不得不再加上一个P.S。具体我就不摘录了，如果你读到这里，请务必往下看他们的评论。转载者别忘了转载他们的评论:-)   许多朋友都问我同一个问题，到底要不要学习C++。其实这个问题问得很没有意义。“学C++”和“不学C++”这个二分法是没意义的，为什么？因为这个问题很表面，甚至很浮躁。重要的不是你掌握的语言，而是你掌握的能力，借用myan老大的话，“重要的是这个磨练过程，而不是结果，要的是你粗壮的腿，而不是你身上背的那袋盐巴。”。此外学习C++的意义其实真的是醉翁之意不在酒，像C/C++这种系统级语言，在学习的过程中必须要涉及到一些底层知识，如内存管理、编译连接系统、汇编语言、硬件体系结构等等等等知识（注意，这不包括过分犄角旮旯的语言枝节）。这些东西也就是所谓的内功了（其实最最重要的内功还是长期学习所磨练出来的自学能力）。对此大嘴Joel在《Joel On Software》里面提到的漏洞抽象定律阐述得就非常漂亮。   所以，答案是，让你成为高手的并不是你掌握什么语言，精通C++未必就能让你成为高手，不精通C++也未必就能让你成为低手。我想大家都不会怀疑g9老大如果要抄起C++做一个项目的话会比大多数自认熟练C++的人要做得漂亮。所以关键的不是语言这个表层的东西，而是底下的本质矛盾。当然，不是说那就什么语言都不要学了，按照一种曹操的逻辑，“天下语言，唯imperative与declarative耳”。C++是前者里面最复杂的一种，支持最广泛的编程范式。借用当初数学系入学大会上一个老师的话，“你数学都学了，还有什么不能学的呢？”。学语言是一个途径，如果你把它用来磨练自己，可以。如果你把它用来作为学习系统底层知识的钥匙，可以。如果你把它用来作为学习如何编写优秀的代码，如何组织大型的程序，如何进行抽象设计，可以。如果掉书袋，光啃细节，我认为不可以（除非你必须要用到细节，像boost库的coder们）。   然后再借用一下g9老大的《银弹和我们的职业》中的话：   银弹和我们的职业发展有什么相干？很简单：我们得把时间用于学习解决本质困难。新技术给高手带来方便。菜鸟们却不用指望被新技术拯救。沿用以前的比喻， 一流的摄影师不会因为相机的更新换代而丢掉饭碗，反而可能借助先进技术留下传世佳作。因为摄影的本质困难，还是摄影师的艺术感觉。热门技术也就等于相机。 不停追新，学习这个框架，那个软件，好比成天钻研不同相机的说明书。而热门技术后的来龙去脉，才好比摄影技术。为什么推出这个框架？它解决了什么其它框架 不能解决的问题？它在哪里适用？它在哪里不适用？它用了什么新的设计？它改进了哪些旧的设计？Why is forever. 和 朋友聊天时提到Steve McConnell的《Professional Software Development》里面引了一个调查，说软件开发技术的半衰期20年。也就是说20年后我们现在知识里一半的东西过时。相当不坏。朋友打趣道：“应 该说20年后IT界一半的技术过时，我们学的过时技术远远超过这个比例。具体到某人，很可能5年他就废了”。话虽悲观，但可见选择学习内容的重要性。学习 本质技艺（技术迟早过时，技艺却常用长新）还有一好处，就是不用看着自己心爱的技术受到挑战的时候干嚎。C/C++过时就过时了呗，只要有其它的系统编程 语言。Java倒了就倒了呗，未必我不能用.NET？Ruby昙花一现又如何。如果用得不爽，换到其它动态语言就是了。J2EE被废了又怎样？未必我们就 做不出分布系统了？这里还举了更多的例子。   一句话，只有人是真正的银弹。职业发展的目标，就是把自己变成银弹。那时候，你就不再是人，而是人弹。   最后就以我在Bjarne的众多访谈当中摘录的一些关于如何学习C++（以及编程）的看法结束吧（没空逐段翻译了，只将其中我觉得最重要的几段译了一下，当然，其它也很重要，这些段落是在Bjarne的所有采访稿中摘抄出来的，所以强烈建议都过目一下）：   I suspect that people think too little about what they want to build, too little about what would make it correct, and too much about \"efficiency\" and following fashions of programming style. The key questions are always: \"what do I want to do?\" and \"how do I know that I have done if?\". Strategies for testing enters into my concerns from well before I write the firat line of code, and that despite my view that you have to write code very early - rather than wait until a design is complete. 译：我感觉人们过多关注了所谓“效率”以及跟随编程风格的潮流，却严重忽视了本不该被忽视的问题，如“我究竟想要构建什么样的系统”、“怎样才能使它正确”。最关键的问题永远是：“我究竟想要做什么？”和“如何才能知道我的系统是否已经完成了呢？”就拿我来说吧，我会在编写第一行代码之前就考虑测试方案，而且这还是在我关于应当早于设计完成之前就进行编码的观点的前提之下。   Obviously, C++ is very complex. Obviously, people get lost. However, most peple get lost when they get diverted into becoming language lawyers rather than getting lost when they have a clear idea of what they want to express and simply look at C++ language features to see how to express it. Once you know data absreaction, class hierarchies (object-oriented programming), and parameterization with types (generic programming) in a fairly general way, the C++ language features fall in place. 译：诚然，C++非常复杂。诚然，人们迷失其中了。然而问题是，大多数人不是因为首先对自己想要表达什么有了清晰的认识只不过在去C++语言中搜寻合适的语言特性时迷失的，相反，大多数人是在不觉成为语言律师的路上迷失在细节的丛林中的。事实是，只需对数据抽象、类体系结构（OOP）以及参数化类型（GP）有一个相当一般层面的了解，C++纷繁的语言特性也就清晰起来了。   Well, I don't think I made such a trade-off. I want elegant and efficient code. Sometimes I get it. These dichotomies (between efficiency versus correctness, efficiency versus programmer time, efficiency versus high-level, et cetera.) are bogus.   I think the real problem is that \"we\" (that is, we software developers) are in a permanent state of emergency, grasping at straws to get our work done. We perform many minor miracles through trial and error, excessive use of brute force, and lots and lots of testing, but--so often--it's not enough.   Software developers have become adept at the difficult art of building reasonably reliable systems out of unreliable parts. The snag is that often we do not know exactly how we did it: a system just \"sort of evolved\" into something minimally acceptable. Personally, I prefer to know when a system will work, and why it will.   There are more useful systems developed in languages deemed awful than in languages praised for being beautiful--many more. The purpose of a programming language is to help build good systems, where \"good\" can be defined in many ways. My brief definition is, correct, maintainable, and adequately fast. Aesthetics matter, but first and foremost a language must be useful; it must allow real-world programmers to express real-world ideas succinctly and affordably.   I'm sure that for every programmer that dislikes C++, there is one who likes it. However, a friend of mine went to a conference where the keynote speaker asked the audience to indicate by show of hands, one, how many people disliked C++, and two, how many people had written a C++ program. There were twice as many people in the first group than the second. Expressing dislike of something you don't know is usually known as prejudice. Also, complainers are always louder and more certain than proponents--reasonable people acknowledge flaws. I think I know more about the problems with C++ than just about anyone, but I also know how to avoid them and how to use C++'s strengths.   In any case, I don't think it is true that the programming languages are so difficult to learn. For example, every first-year university biology textbook contains more details and deeper theory than even an expert-level programming-language book. Most applications involve standards, operating systems, libraries, and tools that far exceed modern programming languages in complexity. What is difficult is the appreciation of the underlying techniques and their application to real-world problems. Obviously, most current languages have many parts that are unnecessarily complex, but the degree of those complexities compared to some ideal minimum is often exaggerated.   We need relatively complex language to deal with absolutely complex problems. I note that English is arguably the largest and most complex language in the world (measured in number of words and idioms), but also one of the most successful.   C++ provides a nice, extended case study in the evolutionary approach. C compatibility has been far harder to maintain than I or anyone else expected. Part of the reason is that C has kept evolving, partially guided by people who insist that C++ compatibility is neither necessary nor good for C. Another reason-- probably even more important--is that organizations prefer interfaces that are in the C/C++ subset so that they can support both languages with a single effort. This leads to a constant pressure on users not to use the most powerful C++ features and to myths about why they should be used \"carefully,\" \"infrequently,\" or \"by experts only.\" That, combined with backwards-looking teaching of C++, has led to many failures to reap the potential benefits of C++ as a high-level language with powerful abstraction mechanisms.   The question is how deeply integrated into the application those system dependencies are. I prefer the application to be designed conceptually in isolation from the underlying system, with an explicitly defined interface to \"the outer world,\" and then integrated through a thin layer of interface code.   Had I had a chance to name the style of programming I like best, it would have been \"class-oriented programming\", but then I'm not particularly good at finding snappy names. The school of thought that I belong to - rooted in Simula and related design philosophies - emphasizes the role of compile-time checking and flexible (static) type systems. Reasoning about the behavior of a program has to be rooted in the (static) structure of the source code. The focus should be on guarantees, invariant, etc. which are closely tied to that static structure. This is the only way I know to effectively deal with correctness. Testing is essential but cannot be systematic and complete without a good internal program structure - simple-minded blackbox testing of any significant system is infeasible because of the exponential explosion of states.   So, I recommend people to think in terms of class invariants, exception handling guarantees, highly structured resource management, etc. I should add that I intensely dislike debugging (as ah hoc and unsystematic) and strongly prefer reasoning about source code and systematic testing.   Pros: flexibility, generality, performance, portability, good tool support, available on more platforms than any competitor except C, access to hardware and system resources, good availability of programmers and designers. Cons: complexity, sub-optimal use caused by poor teaching and myths.  ","title":"你应当如何学习C++(以及编程)(rev#1)"},{"content":"题目： static void Main(string[] args){            if(/* Implement */)            {                Console.Write(\"Hello\");            }            else            {                Console.Write(\"World!\");            }}要求输出： HelloWorld！ 答案：  //常规类：在if输出Hello并返回False，接着输出else            //一，委托            if (((Func<bool>)delegate { Console.Write(\"Hello\"); return false; }).Invoke())                Console.Write(\"Hello\");            else                Console.Write(\" World!\");            //二，委托之Lamada            if (new Func<bool>(() => { Console.Write(\"Hello\"); return false; }).Invoke())                Console.Write(\"Hello\");            else                Console.Write(\" World!\");            //三，is表达式            if (Console.Write(\"Hello\") is object)                Console.Write(\"Hello\");            else                Console.Write(\" World!\");            //四， using System.Linq;            if ((args = new string[1] { \"Hello\" }).Length > 0 &&                args.Any(s => { Console.Write(s); return false; }))                Console.Write(\"Hello\");            else                Console.Write(\" World!\");            //五，- -！            if (Convert.ToBoolean(Type.GetType(\"System.Console\").GetMethod(\"Write\", new Type[] { System.Type.GetType(\"System.String\") }).Invoke(null, new string[] { \"Hello\" })))                Console.Write(\"Hello\");            else                Console.Write(\" World!\"); //第归类：先输出if分支，再输出else分支           //六，参数控制Main函数调用-delegate            if (args == null ? true : ((Func<bool>)delegate { Main(null); return false; }).Invoke())                Console.Write(\"Hello\");            else                Console.Write(\"Word!\");            //参数控制调用Main函数-delegate            if (args.Length != 0 ? true : ((Func<bool>)delegate { Main(new string[] { \"a\" }); return false; }).Invoke())                Console.Write(\"Hello\");            else                Console.Write(\"World!\");                        //七，参数控制Main函数调用-Lamada            if (args == null ? true : new Func<bool>(() => { Main(null); return false; }).Invoke())                Console.Write(\"Hello\");            else                Console.Write(\"Word!\");                       //八，递归之is表达式            if (args==null ? true : Main(null) is object )            {                Console.Write(\"Hello\");            }            else            {                Console.Write(\"World!\");            }                      // 九，超人：||运算符特性（当条件为True时不再计算后边表达式）控制递归            if (args == null || Main(null) is object)                Console.Write(\"Hello\");            else                Console.Write(\" World!\"); //非人类（十，十一）            if (true) Console.Write(\"Hello\"); if (false)            {                Console.Write(\"Hello\");            }            else            {                Console.Write(\"World!\");            }            if (true) Console.Write(\"Hello World!\");            else if (false)            {                Console.Write(\"Hello\");            }            else            {                Console.Write(\" World!\");            }","title":"printf 'Hello world'!"},{"content":"例1：        char  acm[30]=\"1,2,3,4,5,6,7,8,9,0\";        sizeof(acm)=30                           //计算数组所占空间的大小，为30        strlen(acm)=10                           //计算字符串的长度，为10        sizeof()计算的是数组所占的内存空间的大小，strlen()计算的是字符串的长度。 例2：        int  acm[30]=\"1,2,3,4,5,6,7,8,9,0\";         sizeof(acm)=120                       //30 * 4=120 ,因为定义的是int型，每个值占用4字节。        strlen(acm)=    ***  报错            //strlen()的参数只能是char*,且必须是以”\\0”结尾的。      3、strlen()是函数，sizeof()是数组。    4、sizeof可以用类型做参数，strlen只能用char*做参数，且必须是以”\\0”结尾的。sizeof还可以用函数做参数  。      5、大部分编译程序在编译的时候就把sizeof计算过了，是类型或是变量的长度。这就是sizeof(x)可以用来定义数组位数的原因。但是strlen的结果要在运行的时候才能计算出来，用来计算字符串的长度，而不是类型占内存的大小。           char str[20]=”0123456789”;           int a=strlen(satr); //a=10;             int b=sizeof(str); //b=20        程序：       TCHAR str1[256];                TCHAR str2[256];       GetDlgItemText(hwnd,IDC_EDIT1,str1,sizeof(str1));       GetDlgItemText(hwnd,IDC_EDIT2,str2,sizeof(str2));       int i1=atoi(str1);       int i2=atoi(str2);       int i3=0;       HWND hwndComboOp=GetDlgItem(hwnd,IDC_COMBOOP);       int curIndex=ComboBox_GetCurSel(hwndComboOp);    ","title":"sizeof和strlen的区别"},{"content":"1.单一职责原则： 定义：单一职责原则，就一个类而言，应该仅有一个引起它变化的原因！ 单一职责就是一个类负责一种职责，比如，在面向对象的计算器中，每一个计算的方式就有一个对应的计算类。这个计算方式的业务都在这个类中，而其他的计算跟这个类无关。 我的例子也许不是非常的恰当，再例如，三层架构，就是对各种逻辑的封装，如果一个类承担的封装。BLL的职责是业务逻辑，DAL的职责是数据访问，UI的职责就是界面显示！ 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏，软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。如果你能够想到多于一个的动机去改变一个类，那么这个雷就具有多于一个的职责 编程时，我们就是要在类的职责分离上多思考，做到单一职责，这样你的代码才是真正的易维护、易扩展、易复用、灵活多样。 2.开放-封闭原则。 开放封闭原则，是说软件实体（如类、模块、函数等等）应该可以扩展，但是不可以修改。 我们经常会想，怎么样的设计才能面对需求的改变却可以保持相对稳定，从而使得系统可以在第一个版本以后不断推出新的版本呢？开放封闭原则给了我们答案！即对扩展开放，对修改封闭！就像我们在WCF中的服务一样，同一个服务，怎么做到后期的服务兼容前期的服务呢，那就是多扩展。在原来处理的基础上增加扩展处理，如果是早期版本则扩展处理不会执行。 还例如：播放器的软件，对于解码的扩展开放，那么如果要增加其他编码的解码功能，只需要增加实现此功能的类就可以。而不用修改软件其他的部分 无论模块式多么的‘封闭’，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化 [引用内容] 面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有代码--这就是开放封闭原则的精神 开放封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。然而，对于应用程序中的每个部分都可以的进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。 3.依赖倒转原则。 程序设计中，高层模块不应该依赖于低层模块，两个都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖抽象。这个大家都懂的，多态就是为了完成抽象。 比如，接口应该定义在高层模块，实现应该在低层模块。这样实现依赖接口，以三层为例：在DAL层中写具体的实现，依赖接口，BLL层调用接口也依赖接口，而BLL和DAL不互相依赖。 依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有依赖关系都是终止于抽象类或者接口，拿酒是面向对象的设计，反之那就是过程话的设计了。     以上是我在学习设计模式中抽取出来的笔记。举例全是我自己的理解。 看完了，有用就点下“顶”吧！！！","title":"[设计模式]学习设计模式之二（原则1）"},{"content":"------- android培训、java培训、期待与您交流！ ----------         某一夜，一人在群里发了一个多线程的问题，在下热心肠的为他做解答，带他一步一步的去理解程序中的每一步表达什么意思。哪知道，天有不测风云，讲到后来，我自己也被绕进去了。对wait（）和notify（）方法理解的不透彻，然后对于计算机在执行这些线程的时候会发生切换这一点没有充分考虑，搞得自己灰头土脸，铩羽而归。那一夜，多线程你伤害了我！        于是乎，我又回去完整了看了一遍老毕关于多线程的知识，然后自己总结了一些东西，还有自己经常会搞错和遗忘的知识，把这些东西纪录下来，以备以后的不时之需。          关于多线程最基本的就是要建立线程，下面就是两种建立线程的方法： 1、继承Thread类 2、实现Runnable接口       最好使用第二种方法，第一种方法会出现单继承的弊端，第二种方法有两个好处：A、就是避免了单继承。B、用Runnable建立线程，只要建立一个本类的实例对象，并根据这个对象建立多个线程，就实现了资源的共享。 示例代码： class riji01 {  public static void main(String[] args)  {   ThreadTest tt = new ThreadTest();//只需建立一个实例对象即可   Thread t1 = new Thread(tt);   Thread t2 = new Thread(tt); .....  } } class ThreadTest implements Runnable {  private int tickets = 100;//用Runnable接口可以让这100张票给多个线程使用  public void run(){   .....  } }         第二个知识点就是关于线程的状态（如下图）：         在这里要引起注意的是，当wait（）方法被唤醒的时候，千万不要以为他就可以直接往下执行了，而是进入了阻塞状态，与其他在等待的线程一起抢夺执行权，sleep（）也同理。        锁，即监听器在多线程里是相当重要的一块，那如何去发现哪些代码是需要用锁的呢？这里用一下毕老师的三明确： 1、明确哪些代码是多线程代码 2、明确共享数据 3、明确多线程代码中哪些语句是操作共享数据的 示例代码： （public synchronized void set(String name,String sex)  {   if(this.flag)    try {this.wait();} catch (InterruptedException e) {}   //必须要在监视器里用wait（）方法   this.name = name;   this.sex = sex;   flag = true;   this.notify();   //必须要在监视器里用notify（）方法  }）       对于synchronized的语句，用我自己的话理解一下。当线程执行到这个同步函数时，会判断这个锁的标志位，如果是1，表示可以进入，线程进入以后，标志位变成0，把门关上了。在执行同步函数里面的代码时，一定要记住：CPU时刻都可能去执行其他的进程，所以不要想当然的以为进入同步函数了，就会一路执行下去，自认为这一点在多线程里非常重要。当同步函数执行完了，锁就被释放，标志位变回1。  这里总结几点： 1、同步函数中用的锁是this，即谁调用，这把锁就是谁的。 2、静态函数的锁是Class对象，因为静态函数不需要建立实例对象，直接可以被本类调用。 3、通过查看API文档，发现了wait（）和notify（）方法都需要在synchronized代码块或函数里，即必须拥有对象的监听器。        关于“线程间通信——生产者和消费者”的例子中，有一点要引起注意，那就是有多个生产者和多个消费者的情况。在调用wait（）方法时，需要用while进行循环判断，而不是用if只进行一次判断，而且需要用到notifyAll()方法对多个等待的线程全部唤醒。        最后总结一下其他的小知识点： 1、join（）和yield（）方法就是一对小冤家，join（）很霸蛮，他让自己强制运行，其他人只能干瞪眼。而yield（）确实一个谦逊的小伙子，他会暂停自己的线程，让其他的线程先运行。 2、setDaemon（）是用来设置后台线程的，换句话说，一个线程对另外一个线程有依赖关系，若一个线程的生命周期结束了，另外一个线程继续运行没有意义，就可以设置另外那个线程为后台。","title":"（黑马程序员—日记1）多线程——那一夜，你伤害了我"},{"content":"下面要说的是我在成为一名程序员的道路上做的几件事情。写在这里除了要让自己铭记在心外，我还希望它能对别人有些用处。 1. 建立一个博客 这是我后来才认识到的事，其实应该很早就去做。如果你是跟我类似的情况，你应该尽早开通一个博客——尽管还不知道该写什么。注册一个域名，买一个空间。你会惊奇的发现有很多可写的东西。你可以记录下你成为一名程序员的过程，或写一下你感兴趣的技术方面的东西。我一直以为没什么好写的，可当真正思考这些问题时，却发现有很多值得写的。最重要的事情是开始去做。 2. 开发一些东西 开发什么并不重要。选一种编程语言，任何一种都行，开始干。你不必去花大量的时间来决定应该使用什么语言。直接开始学一种语言，事实上最重要的是学习编程语言的基础知识，而不是劳神费力的去选择一种“最好的编程语言”。我选择的是PHP。因为它是一种被广泛使用的语言，在网上有大量的学习范例，我已经通过搭建一个WordPress网站而熟练的掌握了它。没有丝毫的遗憾。它使我学到了很多基础知识。我还学习了其它语言吗？当然，我后来涉猎了很多脚本语言，我要在下一个项目上试试Ruby。编程语言不断的在变化，不要只盯着一个不放。 3. 注册你的GitHub帐户 我已经在Bitbucket上有了一个代码库。我最初选择注册Bitbucket是因为它能提供5个免费的私有库。后来我决定在GitHub上注册。事实上，我丝毫没有拖延，看看我的成果吧。 4. 向开源项目捐赠代码 我早该如此做了。我起初低估了做这种事情的重要性，说老实话，我现在仍需要进一步重视。向开源项目捐赠代码，这是一种很好的学习别人如何编程的方法，并且能把自己的代码公开。我今晚的就要去列一个准备去参与的开源项目的清单。 5. 热心参与 这也是我需要改进的方面。我应该到stackoverflow网站上去回答更多的问题，在一些博客，科技网站上分享自己的东西。去那些网站，让大家看到你。不在网上露面，就相当于待在屋里不出门却想找一份做巴黎导游的工作。 重复做第2，4和5点 其它一些事情 很明显，每一个有志向的程序员都应该每天阅读Hacker News和其它开发/科技/编程类的博客文章。 我打听到了不少的技术讨论会。这周末我准备去参加一个。我会把那里的情况写出来。 我在这里并没有提读书。我喜欢阅读，但我们没有买任何的关于web开发的书籍。这是我个人的做法。我相信很多人都会建议首先买一本书看看。 找一些能和你讨论你的web开发/技术/编程想法的人和群体。如果我做了更多的第5项，我可能找到了更多的这样的人。 好了，这就是我要说的。这些就是在过去的一年里我成为一个程序员的成长之路上做到事情。如果有人觉得在这个清单里我还应该加入什么，请给我留言。我永远都希望听到新的观点。","title":"一些学习编程过程中有必要做的事"},{"content":"MSDN定义: BOOL WINAPI SetDlgItemText(     HWND hDlg,                                    //包含的控件的对话框里句柄      int nIDDlgItem,                                //需要设置标题和文本的控件的ID       LPCTSTR lpString                       //字符串指针，包含需要设置的文本和标题 ); 函数的功能：设置对话框中控件的文本和标题。 例： itoa(str33, str3, 10); SetDlgItemText ( hwnd , IDC_EDIT3 , str3) ; 其中str33为int型的数字，str3为字符串指针。 第一句代码作用：用itoa函数将int型的数字str33转化为字符串，并且将字符串放到str3指针指向的区域。 str3为字符串指针，里面包含着文本内容。 第二句代码作用就是将str3的内容显示到ID为IDC_EDIT3的控件。    ","title":"SetDlgItemText()用法"},{"content":"（其中有几条觉得写的不够贴切，所以删了，发了余下的部分） 把C++当成一门新的语言学习； 看《Thinking In C++》，不要看《C++变成死相》； 看《The C++ Programming Language》和《Inside The C++ Object Model》,不要因为他们很难而我们自己是初学者所以就不看； 不要被VC、BCB、BC、MC、TC等词汇所迷惑——他们都是集成开发环境，而我们要学的是一门语言； 不要放过任何一个看上去很简单的小编程问题——他们往往并不那么简单，或者可以引伸出很多知识点； 会用Visual C++，并不说明你会C++； 学class并不难，template、STL、generic programming也不过如此——难的是长期坚持实践和不遗余力的博览群书； 如果不是天才的话，想学编程就不要想玩游戏——你以为你做到了，其实你的C++水平并没有和你通关的能力一起变高——其实可以时刻记住：学C++是为了编游戏的； 看Visual C++的书，是学不了C++语言的；  把时髦的技术挂在嘴边，还不如把过时的技术记在心里； 学习编程最好的方法之一就是阅读源代码； 在任何时刻都不要认为自己手中的书已经足够了； 请阅读《The Standard C++ Bible》(中文版：标准C++宝典)，掌握C++标准； 看得懂的书，请仔细看；看不懂的书，请硬着头皮看； 别指望看第一遍书就能记住和掌握什么——请看第二遍、第三遍； 请看《Effective C++》和《More Effective C++》以及《Exceptional C++》； 不要停留在集成开发环境的摇篮上，要学会控制集成开发环境，还要学会用命令行方式处理程序； 和别人一起讨论有意义的C++知识点，而不是争吵XX行不行或者YY与ZZ哪个好； 请看《程序设计实践》，并严格的按照其要求去做； 不要因为C和C++中有一些语法和关键字看上去相同，就认为它们的意义和作用完全一样； C++绝不是所谓的C的“扩充”——如果C++一开始就起名叫Z语言，你一定不会把C和Z语言联系得那么紧密； 请不要认为学过XX语言再改学C++会有什么问题——你只不过又在学一门全新的语言而已； 读完了《Inside The C++ Object Model》以后再来认定自己是不是已经学会了C++； 学习编程的秘诀是：编程，编程，再编程； 请留意下列书籍：《C++面向对象高效编程（C++ Effective Object-Oriented Software Construction）》《面向对象软件构造(Object-Oriented Software Construction)》《设计模式（Design Patterns）》《The Art of Computer Programming》； 请把书上的程序例子亲手输入到电脑上实践，即使配套光盘中有源代码； 把在书中看到的有意义的例子扩充； 请重视C++中的异常处理技术，并将其切实的运用到自己的程序中； 经常回顾自己以前写过的程序，并尝试重写，把自己学到的新知识运用进去； 不要漏掉书中任何一个练习题——请全部做完并记录下解题思路； C++语言和C++的集成开发环境要同时学习和掌握； 既然决定了学C++,就请坚持学下去，因为学习程序设计语言的目的是掌握程序设计技术，而程序设计技术是跨语言的； 就让C++语言的各种平台和开发环境去激烈的竞争吧，我们要以学习C++语言本身为主； 当你写C++程序写到一半却发现自己用的方法很拙劣时，请不要马上停手；请尽快将余下的部分粗略的完成以保证这个设计的完整性，然后分析自己的错误并重新设计和编写（参见43）； 别心急，设计C++的class确实不容易；自己程序中的class和自己的class设计水平是在不断的编程实践中完善和发展的； 决不要因为程序“很小”就不遵循某些你不熟练的规则——好习惯是培养出来的，而不是一次记住的； 每学到一个C++难点的时候，尝试着对别人讲解这个知识点并让他理解——你能讲清楚才说明你真的理解了； 记录下在和别人交流时发现的自己忽视或不理解的知识点； 请不断的对自己写的程序提出更高的要求,哪怕你的程序版本号会变成Version 100.XX； 保存好你写过的所有的程序——那是你最好的积累之一； 请不要做浮躁的人； 请热爱C++!","title":"学习C++的50条忠告 （自勉）"},{"content":"//转载请注明出处：http://blog.csdn.net/KuGames 谢谢。欢迎去我的个人网站：KuGames.Net 【首先感谢“提问的艺术”带来的灵感】 文/Sε√ēη（KuGames）  每次在逛论坛看贴吧玩知道的时候，总能看到很多人提问题的方法千奇百怪。我就一直很想写个文章来表态一下，提问也是一门学问！初学者怎么去提问？要注意提问的方法！要懂得提问的艺术！写下这篇文章旨在帮助你更快地解决问题，让你获取你想要的答案。当提出一个技术问题时，你能得到怎样的回答？这取决于挖出答案的难度， 同样取决于你提问的方法。本文旨在帮助你提高发问的技巧，以获取你最想要的答案。 第一点，也是最重要的一点！别问应该自己解决的问题！ 就是自己的问题自己先尝试解决！不要遇到什么问题就马上问！ 在提问之前，你可以先尝试从以下途径里寻找答案：    1.查阅使用说明书(例如假设你是VS用户，可以通过MSDN)，试着自己寻找答案。如果找不到再选择问别人，如果自己解决了也会对这个问题更有印象，下次再遇到的时候也许你就能马上想起解决方案了。   2.在FAQ(即\"常见问题解答\")或帮助文件里找答案    3.在网上搜索，注意关键字的选择，不要盲目把一整段代码或错误直接就拷贝到搜索引擎里，要有针对性 4.向你身边精于此道的朋友求解。 当然有些人就是碍于面子不肯向认识的朋友询问。也懒于自己动手去寻找答案，于是自己还没有思考的情况下就直接发帖求助了。 举个简单的例子，我曾看过这样的一个问题“代码运行不了，请大侠帮我查查” 其他代码省略，例子只需要这一句： int main() {    xxxxx; ) 你看到错在哪了吗？ 提问者问这个代码哪出错了，我真想不明白，就算你没发现main函数结尾是')'而不是'}',那么编译器错误提示总该有吧！！！你看了编译器的提示信息了吗？你发张帖子的时间早就够你把')'改成'}'改一百遍了！ 首先，我就极力反感这种一点都不独立思考的人！当你提出问题的时候，首先要说明在此之前你做了些什么。这也能帮你树立你的形象：你不是一个妄图不劳而获的乞讨者，不愿浪费别人的时间。如果提问者能从答案中学到东西，我们更乐于回答你的问题。 第二点，这是问题最严重的一点！ 有些人，二话不说，帖子一上来，直接贴一个几百上千行的代码。等一大堆代码贴完后，就直接附上一句“代码错误，请各位大侠大哥帮我查查”等等。。。 代码出错很正常，没有错误，就不会进步！可是遇到这种情况，作为一个合格的程序员，我们首先要做的不是求助,而是去查错，怎么查？ 你先根据编译器提示的错误，以及在哪错了，然后再到相应位置检查代码，如果实在找不出，你起码知道大概哪一块错了吧？你总有自己的一点想法和理解吧？你总要描述一下你想干嘛然后实现不了吧？ 就像你去看病，到了医院，医生问你怎么了，你说不舒服，他问你哪不舒服，你也不说，直接让他来一个全身大检查。你是闲着没事，想烧钱烧时间吗？ 所以，在你实在无法通过编译器找出问题原因的时候，请你要做好周全的思考。准备好你的问题，做好描述和分析，以及锁定某一小块的出错点，代码要工整，注意缩进和注释，要有好的代码习惯。草率的发问只能得到草率的回答，甚至根本得不到任何答案。越表现出在寻求帮助前为解决问题付出的努力，你越能得到实质性的帮助。   另一方面，表明你愿意在找答案的过程中做点什么，是一个非常好的开端。“谁能给点提示？”、“我这个例子里缺了什么？”以及“我应该检查什么地方？”比“请把确切的过程贴出来”更容易得到答复。因为你显得只要有人指点正确的方向，你就有完成它的能力和决心。 第三点，问题的题目一定要先写清楚，相信大家也见过下面的几种提问方式：     ①.C++初学者的求助。。。     ②.请各位大侠帮帮忙啊     ③.搞不懂啊，求解释。。。     ④.一个简单的C++问题     ⑤.本人菜鸟一个，想求助各位大虾！ 还有很多很多，我就不一一举例了。说了这些并不是要针对谁，只是举例分析我们常见的一些提问的症结。 大家看了这些后有何感想？这些题目给我的感觉就是敷衍人，你说连题目都没明确表达出自己想说什么，还谈如何提问？ 如果你以以上类似情况问问题，只能让我们感觉你对回答问题者的不尊重！互相学习，也顺便互相交个朋友，我希望大家都能互相尊重，珍惜大家的时间，这样问题也能圆满解决，何乐而不为呢？  使用含义丰富，描述准确的标题。大约50字以内的主题标题是抓住资深专家注意力的黄金时机。别用喋喋不休的“帮帮忙”（更别说“救命啊！”这样让人反感的话）来浪费机会。不要妄想用你的痛苦程度来打动我们，别用空格代替问题的描述，哪怕是极其简短的描述。 大家再看看下面的几个问题：     ①.堆和自由存储区有什么区别？     ②.关于指针和引用的问题，请帮帮忙！     ③.提个小问题，有关MFC下多线程的     ④.如何将输出对齐     ⑤.关于内存泄露的问题求助！谢谢各位帮忙！ 这几个首先就把大概问题给表述出来了。也许有人会问，“都不知道错在哪，怎么写得出大概的问题？”但是，你可以把你代码的目的描述出来，这也是好的。就比如第④个。而第⑤个不光写出了问题大概，还附带“谢谢各位帮忙”，简简单单一句话，却体现了提问者对回答者的尊重与感激。 如果你有很多问题无法解决，礼貌将会增加你得到有用答案的机会。    问题解决后，加个简短说明并记得感谢提供帮助的朋友。   问题解决后，要跟帖说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在帖吧引起了广泛关注，应该在那里贴一个补充说明。补充说明不必很长或是很深入，简单的一句“原来是××出了问题！谢谢大家！尤其是××××，感谢你们耐心的回答！”比什么也不说要强。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇学术论文更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。这种补充有助于所有提供过帮助的人从中得到满足感。这种感觉对于那些你向他们求助的导师或者专家而言，是非常重要的。问题久拖未决会让人灰心；好人有好报，满足他们的渴望，你会在下次贴出新问题时尝到甜头。 第四点，口气过于嚣张，问题让人无语。 不知道大家有没有被下面这种问题雷倒过，不是大家不想帮你，是你的问题没法让大家回答。 比如：     ①.求MFC教程和教材        需要代码，还要详细注解！可以发送到我邮箱×××        我用的是VS2008，所以请用2008版的教材给我！谢谢！        题目就这么简简单单几句话。        估计这样提问的口气，就没有几个人愿意回答了，你是在提问还是在提要求，大虾们还要为你服务不成？     ②.c++新人求助啊，大一作业        …………（问题描述）…………        一直以来，大家都说了，不要问作业，不帮你们是对你们负责。你应该自己完成，遇到问题再来询问！     ③.还有就是喊着编译器报错，然后一没给代码，二没给截图，怎么回答？ 以上三个问题也基本反映了提问的一些问题，不要问作业，问问题的语气不要求你有多柔和，但也不能反客为主，并且作为提问者，题目首先得让大家弄懂。 最后，就是那些被讨论烂了的话题，比如么学好C++？学C++看哪些书好？学哪门语言好？这类问题个人觉得没有太多必要讨论，当然问了也无伤大雅。偶尔讨论交流还可以，但是希望提问者对于这类问题自己百度谷歌，因为这种问题永远没有一个正确的答案，也永远没有讨论结束的一天！ 最后总结下：对于提问问题，首先要百度，谷歌，可以在网上查到的，就先去查，如果查到了还无法解决，再去提问；其次，提问时，要注意上面我说的几点问题 。 相信提问时注意了这三个问题，一般问题都可以圆满解决的。 转到我自己的贴吧去了，欢迎去：http://tieba.baidu.com/kugames 原帖地址是我之前的博客：http://blog.csdn.net/seven807173440/article/details/6820075 现在搬到这个。","title":"初学者怎么去提问？要注意提问的方法"},{"content":"//转载请注明出处：http://blog.csdn.net/KuGames 谢谢。欢迎去我的个人网站：KuGames.Net 一、养成良好的学习习惯 程序设计的入门学习并不难，但却是一个十分重要的过程，因为程序设计思想就是在这时形成的，良好的程序设计习惯也在这个阶段养成。 二、学习程序设计要注重理解一些重要的概念 程序设计本身并不复杂，翻开一本程序设计学习的书籍，看到的无非就是变量，函数，条件语句，循环语句等概念。但要真正能进行程序设计，需要深入理解这些概念。因此，在程序入门阶段还是应该重视概念的学习。 三、自己动手编写程序 程序设计入门阶段要经常自己动手编写程序，亲自动手进行程序设计是创造性思维应用的体现，是培养逻辑思维的好方法。因此一定要多动手编写程序，而且要从小程序开发开始，逐渐提高开发程序的规模。 四、阅读，借签别人设计的好程序 多看别人设计好的程序代码，包括教材上的例题程序。在读懂别人程序后，要想他为什么这么设计 能不能将程序修改完成更多的功能 则可以学到别人优秀的东西，帮助自己提高自身水平。 五、程序设计学习的重点 重点放在思路，算法，编程构思和程序实现上。 语句只是表达工具，要求在学习过程中积极思考，尽量当堂学懂，并做到灵活应用。学会利用计算机编程手段分析问题和解决问题。 六、养成良好的编程习惯 强调可读性;变量要加注释。 程序构思要有说明。 学会如何调试程序。 对运行结果要做正确与否的分析。 原帖地址是我之前的博客：http://blog.csdn.net/seven807173440/article/details/6816868 现在搬到这个。","title":"送给入门初学者的6条建议"},{"content":"//转载请注明出处：http://blog.csdn.net/KuGames 谢谢。欢迎去我的个人网站：KuGames.Net (1).不要死记硬背语法：程序开发的语法、规范特别多，不可能全记下来，只要知道有这么一个功能即可，需要的时候再翻书或查找帮助。这样省时省力，可以将更多的时间和精力用在技术的提高上。 (2).多动手，多练习：死读书是成不了编程高手的！只有多练习，多上机编写程序，才能在实践中提高对编程的认识。 (3).遇到问题，首先尝试自己解决：如果你一遇到问题就立刻找别人问帮忙，你的技术永远不会提高。自己先尽力解决，加深对问题的理解，实在不行再寻求帮助，那样不但你对这个问题的印象更深刻，你也会更加珍惜这份来之不易的解答！ (4).多用百度谷歌：网络是个大知识库，是最好的老师，你遇到的问题说不定别人也遇到过，多去搜索一下吧！ (5).多阅读别人的源代码：要看懂别人的设计思想，不断融为己用！ 天下事有难易乎？ 不为，则易者亦难矣； 为之，则难者亦易矣！ 原帖地址是我之前的博客：http://blog.csdn.net/seven807173440/article/details/6826728 现在搬到这个。","title":"学习编程需要注意的几点"},{"content":"在学习C语言的时候，基本的输入输出是非常重要的，因为我们时常要接收用户的输入，而且时常要将结果输出到屏幕，因此非常有必要注重地学习一下。 最常用的两个基本IO函数莫过于 printf()  和 scanf() 了，下面首先来详细地介绍一下它们。来看第一个示例代码： //example1.c#include <stdio.h>int main(void){        char a1 = 'A';        int a2 = 100;        float a3 = 3.14;        printf(\"a1=%c, a2=%d, a3=%f\\n\", a1, a2, a3);        short int a4 = 10;        long int a5 = 20;        long long int a6 = 30;        printf(\"a4=%hd, a5=%ld, a6=%lld\\n\", a4, a5, a6);}在上面的代码中，第8行和第13行就是将各种不同的数据类型打印出来，这里，%c  %d  %f  %hd  %ld  %lld 这些称之为 格式控制符，其实，printf 和 scanf 函数之所以称为格式化IO函数，就是因为它们可以根据不同的格式控制符来处理各种类型的数据。 简单地讲，%d 用来表示 十进制 有符号 整型。%c 表示 字符。%f 表示浮点型数据。具体的所有的格式控制符的详细解释，请看下面的代码： //example2.c#include <stdio.h>int main(void){        char a1 = 'A';        printf(\"%c\", a1); // c就是character字符的意思        short a2 = 10;        printf(\"%hd\", a2); // h就是half一半的意思，表示a2是“半个”整型        int a3 = 100;        printf(\"%d\", a3); // d就是decimal十进制的意思        long a4 = 100;        printf(\"%ld\", a4); // l就是long的意思，表示a4是一个长整型        long long a5 = 100;        printf(\"%lld\", a5); // ll就是long long的意思，表示a4是一个长长整型        float f1 = 1.0;        printf(\"%f\", f1); // f就是float的意思，表示f1是一个单精度浮点型                double f2 = 1.0;        printf(\"%lf\", f2);        long double f3 = 1.0;        printf(\"%Lf\", f3); // 注意下，长双精度不是 %llf ，而是 %Lf        return 0;}下面来看看 scanf()  ，这个函数是用来接收用户输入的，比 printf() 要考虑的更多一点，但是他们的格式控制符是一致的，也就是说，对于example2.c 里面看到的所有在 printf() 函数中使用的 格式控制符，在 scanf() 函数中完全适用，具体而言，scanf() 函数的用法如下： /example3.c#include <stdio.h>int main(void){        char a1;        scanf(\"%c\", &a1); // 将用户输入的一个字符，放置在a1里        scanf(\"%hhd\", &a1); // 将用户输入的一个数值，放置在a1里        short a2;        scanf(\"%hd\", &a2); // 将用户输入的一个短整型，放置在a2里        int a3;        scanf(\"%d\", &a3); // 将用户输入的一个整型，放置在a3里        long a4;        scanf(\"%ld\", &a4); // 将用户输入的一个长整型，放置在a4里        long long a5;        scanf(\"%lld\", &a5);  // 将用户输入的一个长整型，放置在a5里        float f1;        scanf(\"%f\", &f1);  // 将用户输入的一个单精度浮点数，放置在f1里        double f2;        scanf(\"%lf\", f2);  // 将用户输入的一个双精度浮点数，放置在f2里        long double f3;        scanf(\"%Lf\", f3);   // 将用户输入的一个长双精度浮点数，放置在f3里        return 0;}值得注意的是第 6、7行。我在《LINUX-C成长之路（二）》中讲过，char 型其实就是整型，特点是单字节整型，因此 a1 其实就是用来存储一个整数的，这时，当用户从键盘按下“9” 这个按键的时候，你的程序究竟是要存储一个字符 '9' 呢？ 还是要存储一个数字 9 呢？ 注意字符 '9' 跟数字 9 是不同的，如果是字符 '9' 的话，我们内存中存储的实际上市它所对应的ASCII码值，也就是57， 如果是数字 9 ，那就是在内存中直接存储 9 。 所以，第6行是将用户的输入当成是字符，此时a1将会存储用户输入的字符的ASCII码值。 第7行是将用户的输入当成数字，而且要将这个数字放置在单字节变量 a1 里面，因此第 7 行的格式控制符是 %hhd  ，前面的 hh 表示 half  half ，也就是一半的一半的整型，也就是单字节整型。 下面，研究一下一个很重要的问题：对于 scanf() 而言，假如你要用户输入一个整数，或者输入一个浮点数，但是用户很调皮，偏不输入一个规规矩矩的你想要的数据，你的程序会如何呢？ 是立即就罢工甚至爆炸呢？ 还是有足够的智能来处理这些小顽皮的捣蛋呢？请看下面的例子： //example4.c#include <stdio.h>int main(void){        printf(\"请输入一个0-127之间的整数\\n\");        char c;        scanf(\"%hhd\", &c);        printf(\"这个数对应的字符是： %c\\n\", c);        return 0;}在example4.c 中，如果用户规规矩矩地输入你所要求的 0-127之间的 ASCII码值，程序当然可以顺利运行，打印出其对应的字符，但问题是假如用户输入诸如：  abcd 或者 80.5 或者 80abcd 或者 abcd80  ， 但example4.c 遇到这样的输入的时候，它是无能为力的。因为它没有任何的输入确认的判断。 首先我们要知道一个事情，就是scanf() 这个函数的返回值，事实上，scanf() 这个函数的返回值代表了其正确地得到了用户输入的数据的个数，举个例子就明白了，就如有这个一段代码： int a, b, c;int n;n = scanf(\"%d%d%d\", &a, &b, &c);那么用户的输入分别是： 1，依次输入 100  200  300 2，依次输入 100  abc  300 3，依次输入 abc  200  300 n 的结果，则分别是 3， 1， 0.  当用户是第一种情况的时候，100,200和300都正确地被赋值到了a，b和c3个变量中。因此scanf正确得到了 3 个值，所以返回3. 第二种情况，scanf 只能正确地得到 100 这个数据并将其赋值给 a，但是后面的 abc 不是一个整数，因此被 scanf 拒绝，且 scanf 此时立即返回 1，代表正确得到了1 个值。在第三种情况下，用户一来就输入了 abc，scanf() 函数发现状况不妙，后面的 200,300 都不被理睬，返回了一个 0 ，代表啥也没得到，啥也没赋值。 关键是：那些没有被正确匹配并且赋值的输入，到哪儿去了？ 比如第二种情况下的 abc 和 300， 第三种情况下的 200 和300，它们会自动消失吗？ 答案是否定的。事实上，这些用户输入的数据并非直接了当地传递给了程序中的变量，而是先由标准IO库函数“暂管”起来，将它们放在一个缓冲区中，然后，scanf() 函数从这个缓冲区中逐个地拿取数据，当数据的类型匹配时，就继续拿取，当数据的类型不匹配时，则立即停止拿取数据，并返回已经拿取的数据个数。 因此上面的第一种情况是：将100，200和300都拿取过来，分别赋值给a，b和c，然后返回一个3，代表 scanf() 从缓冲区中正确拿取了3个数据。 第二种情况是：将 100 拿取过来，赋值给a，然后碰到 abc 不符合要求，因此立即停止拿取数据，并返回 1， 代表拿了一个数据。注意，此时 abc 和 300 并未消失，而是残留在缓冲区中。 第三种情况是：一开始就遇到 abc，不符合格式要求，因此 sacnf() 立即返回一个 0 ，代表啥也没拿到。同理，此时用户输入的 abc，200 和 300 并未消失，也残留在缓冲区中。 知道了这个道理，我们在要求用户再次输入数据的时候，就要注意了，因为上次格式不匹配的数据会残留在缓冲区中，请看下面的错误的代码： //example5.cint main(void){        printf(\"请输入一个整数\\n\");        int n, ret;        while(1)        {                ret = scanf(\"%d\", &n);                if(ret != 1)                        printf(\"格式不对，请再输一遍!\\n\");                else                         break;        }        printf(\"你输入的数是： %d \\n\", n);}这个代码，原意是想让用户输入一个整数，然后将其输出，如果输入的不是整数，就要求用户再输入一遍。可惜这是一段错误的代码，因为假如用户输入了一个 字母 a，这个 字母将会残留在缓冲区中，影响用户的下一次输入，也就是说，不管用户再次输入什么，scanf() 函数永远会先读到那个 a，因此就变成死循环了。正确的代码如下： //example5.cint main(void){        printf(\"请输入一个整数\\n\");        int n, ret;        while(1)        {                ret = scanf(\"%d\", &n);                if(ret != 1)                {                        while(getchar() != '\\n'); // 用 getchar() 清空非法字符                        printf(\"格式不对，请再输一遍!\\n\");                }                else                         break;        }        printf(\"你输入的数是： %d \\n\", n);}其中，我们增加了第 15 行，这是一个空循环，循环条件是 getchar() != '\\n' ，这句话的意思是，用getchar() 这个函数去缓冲区拿取数据，每次拿去一个字符，只要不是回车符 '\\n' ，就继续循环，直到拿到回车符为止。 为什么是回车符呢？ 因为用户再输入的时候，最后一定是按了一下回车键来结束输入的（本质原因是标准输入流是行缓冲类型的），因此在缓冲区中的数据一定是以 回车符 '\\n' 作为结尾的，当我们用 getchar() 获取到回车符时，就表示缓冲区就被我们清空了！ ","title":"LINUX-C成长之路（三）：基本IO函数操作"},{"content":"msdn的定义： HWND GetDlgItem(                                  HWND hDlg,                               //窗口的句柄 int nIDDlgItem                              //某个控件的ID ); 功能:获取某个控件的句柄 例子： HWND hwndComboOp=GetDlgItem(hwnd,IDC_COMBOOP);          //获取ID为IDC_COMBOOP的控件的句柄    int curIndex=ComboBox_GetCurSel(hwndComboOp);                     //将获取到的句柄赋值给curIndex    switch(curIndex)    {        case 0:     {      i3=i1+i2;     }     break;     case 1:     {      i3=i1-i2;     }     break;     case 2:     {      i3=i1*i2;     }     break;     case 3:     {      i3=i1/i2;     }     break;","title":"GetDlgItem()函数的使用"},{"content":"We think that the best approach a team can take is to use empirical feedback to learn about the system and its use, and then apply that learning back to the system. A team needs repeated cycles of activity. In each cycle it adds new features and gets feedback about the quantity and quality of the work already done. The team members split the work into time boxes, within which they analyze, design, implement, and deploy as many features as they can.Deploying completed work to some kind of environment at each cycle is critical.Every time a team deploys, its members have an opportunity to check their assumptions against reality. They can measure how much progress they’re really making, detect and correct any errors, and adapt the current plan in response to what they’ve learned. Without deployment, the feedback is not complete. In our work, we apply feedback cycles at every level of development, organizing projects as a system of nested loops ranging from seconds to months, such as: pair programming, unit tests, acceptance tests, daily meetings, iterations, releases, and so on. Each loop exposes the team’s output to empirical feedback so that the team can discover and correct any errors or misconceptions. The nested feedback loops reinforce each other; if a discrepancy slips through an inner loop,there is a good chance an outer loop will catch it.Each feedback loop addresses different aspects of the system and development process. The inner loops are more focused on the technical detail: what a unit of code does, whether it integrates with the rest of the system. The outer loops are more focused on the organization and the team: whether the application serves its users’ needs, whether the team is as effective as it could be.The sooner we can get feedback about any aspect of the project, the better. Many teams in large organizations can release every few weeks. Some teams release every few days, or even hours, which gives them an order of magnitude increase in opportunities to receive and respond to feedback from real users.","title":"极限编程"},{"content":"An Exe file, or a file with the \".exe\" extension, is a type of executable file commonly used with Windows operating systems. The Exe file is one of the most useful files in Windows, as it is commonly used to install or run programs. Nearly all installers will be packaged as executables, and many small software programs (such as the games included with Windows) run entirely out of Exe files. If you need to package a program or a script for distribution or installation, you will need to learn how to make an Exe file yourself. Fortunately, Windows comes with a built-in utility for packaging executables, and using it is fairly simple... 1 1.Run the iExpress application in Windows. IExpress is a utility that is included with Windows, and it provides an easy way to package your program as an executable. To run the program, press the \"Start\" button and then click \"Run.\" In the dialog box, type \"iexpress.exe\" and press the Enter key. If you use Windows Vista, you can just press the \"Start\" button and begin typing \"iexpress,\" and the program's icon will appear in the search results. 2.Specify that you want to create a new executable. When the iExpress program launches, you will be asked to choose between opening an existing executable or creating a new one. Choose to create a new one by selecting the radio button that reads, \"Create new self extraction directive file.\"   3.Specify the type of executable package you want to create. The next screen will ask you to choose between 3 options for the action that should be taken when a user opens your Exe file. The first is to extract the files and then run an additional command (for instance, to make changes to the registry). The second is to extract the files only (this is the recommended option). The third option is only applicable for distributing Active-X controls. 4.Give your installer package a title. The next screen will ask you to specify the title for your executable package. This is not the filename for the Exe file; this is the title that will appear across the top of all windows opened by the installer.   5.Choose a confirmation prompt for your Exe file if desired. The next screen in iExpress will allow you to specify a text prompt given to the user upon opening the executable. If you don't wish to provide a prompt, check the radio button that reads \"No prompt.\"     6.Specify the license agreement governing the use of your executable. The next screen will allow you to choose a license agreement for your software. The installer will inform the user that the agreement you pick governs the use of the software. To display a license agreement, type the agreement into a plain text file (using the \".txt\" extension) and attach it after selecting the radio button reading, \"Display a license.\" 7.Select the files that your Exe file will install on the user's computer. The next screen will allow you to choose the files that your executable should install; you can select as many or as few as needed. Add a file by clicking the \"Add\" button and then navigating to the file's location on your hard drive. You will be able to see the files you've added in the iExpress window. 8.Specify the executable's filename. The next screen will ask you to specify the filename for the Exe file; remember it must end with the \".exe\" extension. This screen also includes a check box for either hiding or showing the full extraction process to the user. 9.Create the executable. Click the \"OK\" button on the final iExpress screen to compile the Exe file and save it in the location you specified. You can test the executable by double-clicking on it to extract the files. 10.Another way to create EXE is ExeScript utility. Just make a simple BAT or VBS script and convert to EXE.      ","title":"How to Make an Exe File"},{"content":"使用一种特殊的编程语言、编程很牛，单单靠这个并不能说一名程序员/开发者就是优秀程序员/开发者。快速发展的开发环境使得这个行业比我今天看到的任何一个行业都要发展迅速，这既有积极的一面也有消极的一面：今天的程序员/开发者有很多编程语言、开发工具和开发平台可选，但是建立一个安全、可扩展的环境却变得难了很多；硬件和软件正日新月异地变得更加复杂，但现在学习新技术比过去要难太多了。 以下是优秀程序员应当具备的品质： 语言和工具（Languages and Tools:） 任何程序员/开发者需要具备的第一个技能就是，能够用编程语言工作并会使用与之相关的主要开发工具，包括：工具、IDEs, web 框架, messaging APIs。 程序设计方法（Programming Paradigm:） 举例来说，很好地理解面向对象，这对使用强制式语言(Imperative Language也称过程式语言)写出可维护的代码至关重要。在企业开发中你会遇到各种不同的问题，理解多种程序设计方法并知道何时使用，将使这些问题迎刃而解。 领域专长的知识（Domain Specific Knowledge:） 如果想编写系统来解决特定领域内的问题，那么拥有该领域的专长知识将非常重要。尽管许多这样的知识是由项目的商业分析员（Business Analyst）来获悉，但如果开发者也能获取，那么跟用户的交流将会更加容易，而且更能够理解他们的专业词汇。 人际关系（People Skills：） 软件开发中最重要的技能之一就是能够与其他开发者一起高效工作——同事、质量/商业分析员（Quality/Business Analysts），客户，用户，很多很多……如果你能够很好地处理这些关系，那么成功的大路也离你不远矣。 解决问题（Problem Solving：） 有能力解决那些没有明显解决方法的问题，这一点在软件开发中很重要。当把你的应用配置到JBoss或者通过一个测试找到一个棘手bug的时候，理智地编程将成为调试一个类路径(class path)问题。 沟通能力（Good Communication skills：） 在软件世界中，人们通常认为好的沟通能力就是流利地说话，事实上这远不是。这指的是：你能够多么有效地与其他人交流。作为一名优秀的开发者，你应当能够很好地表达你的想法，很好地听，以及很好地掌控你与他人沟通的过程。 读书（Read Books：） 读大量书将了解很多不同的技术，读书使你对一种技术有了快速、直接的视角。通常你应当选择知名学者的书，他们推崇实践和用技术解决问题的多种方法。在这个过程中，你将学到很多并逐渐形成自己的方法。没准哪天你也就能出书了呢。 实践、实践再实践（Practice, Practice and Practice） 许多开发者拥有大量理论知识，他们饱览书籍和技术资料。然而，怎样运用这些知识却让他们望而却步。这是因为他们缺乏实践。你工作的效率和效力只能通过你实践中编写代码来获得。唯一能使你成为优秀开发者的方法就是实践、实践再实践。 遵循范例和最好的实践（Follow Patterns and Best Practices :） 范例和实践反映了技术指导、常见技术问题和基于真实事件的实践。学习的过程是循序渐进的，但是一劳永逸。这会节省你非常多的时间和精力，让你的工作更加有效。遵循一本“代码编程指南”（Code Design Guideline），经常使用代码分析工具将检测和分析你的代码。 讨论/小组沟通（Discussion/Newsgroup:） 参加开发社区会提高你的领导能力以及贡献感，二者都是成功的必需品。在社区内参加一场含量较高的技术讨论将使你充满成就感，而且会增长你的知识，因为其中的智者会查看和评点你的解决方法，你也会查看和评点他们的。而且这个过程教会你接纳并感激别人的建议。如果她/他做出了积极的贡献，不要忘了赞扬和鼓励（'pat someone on the back'）。 网络和数据库知识（Knowledge of Networking and Databases:） 有人也许不赞成这点，但是一个优秀的开发者应当知道网络和数据库的基本东西。而且在思考解决方法的时候，不要忘记将二者考虑在内。拥有二者的知识，能够帮你写出更好的代码并节省你很多时间。 博客、写文章（Blog/ Write Articles:） 我们中有谁能够记住每件事？我不能，所以我把他们记下来。当我需要的时候，可以回头翻阅参考。除此之外，我可以借此从读者那里获得反馈，让我对同样的问题收获更多的方法。我已经获悉了许多与我工作有关的反馈，虽然有好有坏，但我会一一验证，这个过程也让我受益匪浅。 KISS 不要想歪了，这里的KISS不是你想的那样，是指让应用/方法直短、简单（Keep Implementations/Approaches Short and Simple的简写）。不要使用行话来让事情更加复杂，因为人们很难理解它们。最好的方法是简化你的设计并避免过度设计（over-engineering）的东西。 像测试者一样思考（Think as a Tester:） 开发者和测试者，来自两个不同阵营的两类人群，随时准备同彼此较量。我发现二者的合作将产生非常好的结果。既不会损害开发者的利益也不会损害测试者的利益。实际上，长期来看，像测试者一样思考有利于减少你代码的bug，而且会形成很好的编程习惯和思维。 坚持一致是游戏规则（Consistency is the name of the game:） 你是否经常跳槽或者被你的薪水所打击？如果是，那么静坐下来放松下并重新规划。好好想想不要让你的决定天马行空，为了不断向前，你需要一个坚实的决定并坚持不懈。 参加技术研讨会/大事件（Attend technology seminars and events:） 如果你所在的城市有技术研讨会，一定要抽出时间参加。大部分的研讨会是免费的，而且会提供新技术的重要信息。 万家通吃还是一门独大？（Jack of all or Master of One?:） 嗯……这个问题不好回答。在现在的环境下，你必须掌握一种以上的技术。尽管这不容易，但是好的开发者还是能够做到。其中的关键就在于适应性：如果你精于某种技术，那么给以机会你将较容易地在短期内掌握一种新技术。你不妨试试，多掌握一种技术可以让你在使用中对比、选择。 停止抱怨（Stop complaining：） 是否软件没有做成，是否测试人员给你检查出一堆bug？许多开发者的本能反应是抵制情绪进而非常抵制这种情况。由于这种情绪是自然反应未经控制，所以它不可取。静心分析为什么软件失败、为什么有如此多bug，这是一个学习的经历将使你未来的工作受益良多。 最后，请记住你不是要永远做个程序员。所以一旦你自我满足并觉得自己是个优秀的程序员，你就得重新规划你自己（re-program yourself）。扩展你的兴趣。开发只是这个过程的一部分，了解用户和商业实际上是一种艺术，每个人应当以此为目标并努力掌握它。","title":"18条提升程序员水平的建议"}]