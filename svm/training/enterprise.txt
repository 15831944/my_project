[{"content":"CUID(Globally Unique IDentifier) Partition Table(GPT)是一种新的分区形式，也是UEFI协议的一部分，用全局唯一标识符对设备进行标识。在很多方面与MBR有很大差别，也有很多优点。 要理解GPT，首先要清除MBR及其缺点。 每一种分区形式，分区数由分区表占用空间的总长度和单条分区存储信息占用空间来决定。 主根记录： MBR分区表以以下形式在第一个扇区中存储了一个硬盘的分区信息： 在硬盘驱动器中的位置 代码含义 第一个440字节 由BIOS锁存的MBR启动代码 441 ～ 446字节 MBR盘标识 447 ～ 510 字节 主和扩展分区的真实分区表信息 511 ～ 512 字节 MBR启动标识 0xAA55 主分区的入口信息限制为64字节，一个扩展分区（An extended partition is simply a primary partition in the MBR which acts like a container for other partitions called logical partitions. So one is limited to either 4 primary partitions, or 3 primary and 1 extended partitions with many logical partitions inside it.） MBR问题： 1、只能定义四个主分区或三个主分区 + 1 个扩展分区。如果你定义了3个主分区和一个扩展分区后，还有空闲空间，不能通过建立新的分区来使用空闲空间； 2、在扩展分区内，逻辑分区的元数据存放在一个链表结构中，如果一个链接丢失，在这个元数据后的所有逻辑分区将会丢失。 3、MBR仅支持一个字节的分区类型码，会导致很多冲突； 4、MBR用32位逻辑块寻址值（LBA values)存储分区扇区信息.LBA 长度为512字节扇区大小将磁盘的最大寻址长度限制在2TiB。如果使用了MBR，则超过2TiB的空间不能进行分区定义。 GUID分区表： GUID分区表（GPT）使用GUIDS（或在LINUX中使用UUIDS）来定义分区和它的类型，。GPT内容如下： 在硬盘控制器中的位置 目的 磁盘的第一个逻辑扇区或第一个512字节 保护MBR-与MBR相像，只是64字节区域包含一个单个0XEE类型的主分区入口，这个入口支持>2TiB的空间，分区大小高达2TiB 磁盘的第二个逻辑扇区或下一个512字节 主GPT头-包含唯一磁盘GUID，主分区表地址，分区表中可能入口数，本身和主分区表的CRC32校验，第二个（或备份）GPT头地址 16KiB（缺省）紧跟在磁盘的第二个逻辑扇区后 主GPT表-128个分区入口（默认，可以更多），每个入口占128字节。扇区号以64位LBA进行存储，并且每个分区有一个分区类型GUID和一个唯一的分区GUID。 16KiB（默认） 在磁盘最后一个逻辑扇区前 第二个GPT表-跟主表的每个字节都相同。这个表主要用于当主分区表破坏时对主分区表进行恢复 磁盘的最后一个逻辑扇区或最后512字节 第二个GPT头-包含唯一的磁盘GUID，第二个分区表的地址，分区表中所有入口数，本身和第二个分区表的CRC32校验，主GPT头地址。这个GPT头可以在主头损坏时用于恢复GPT头进行恢复。 GPT优点 1、使用GUIDS（UUIDS）来标识分区类型--没有冲突； 2、提供一个唯一的磁盘GUID和为每一个分区提供一个唯一的分区GUID--一个好的与引用分区或磁盘的文件系统无关的方式。 3、任意数量的分区-依赖于为分区表分配的空间-无需分扩展和逻辑分区。GPT表默认情况下可以定义128个分区。如果用户想定应更多的分区，需要为分区表分配更多的空间（gdisk 支持这种特性）； 4、使用64位LBA存储扇区号--最大可寻址2ZiB空间； 5、在磁盘最后存储了GPT头和分区表用于在主分区信息遭到破坏时进行恢复； 6、对GPT头和分区表进行CRC32校验，来探测错误或灾难。 内核支持 通过内核配置中的CONFIG_EFI_PARTITION选项来使能内核中对GPT的支持（需要EFI分区（despite the name efi partition)）。这个选项只能编译进内核，而不能编译成模块。即使只需要支持GPT磁盘数据存储而不是用于启动，也需要将这个选项编译进内核。 引导器支持 UEFI系统： 所有的UEFI引导器都支持GPT磁盘，GPT是UEFI协议的一部分，并强制实现。 BIOS系统： 1、GRUB（2）：需要2MiB“BIOS启动分区“（requires a 2 MiB \"BIOS Boot Partition\" (EF02 type code in gdisk and bios_grub flag in GNU Parted) in BIOS systems to embed its core.img file due to lack of post-MBR embed gap in GPT disks. Runtime GPT support in GRUB(2) is provided by the part_gpt module. See GRUB#GPT_specific_instructions for more information）; 2、syslinux:(requires the partition containing /boot/syslinux/ldlinux.sys (irrespective whether /boot is a separate partition or not) to be marked as \"Legacy BIOS Bootable\" GPT attribute (legacy_boot flag in GNU Parted) to identify the partition containing the Syslinux boot files by its 440-byte MBR boot code gptmbr.bin. See Syslinux#GUID_Partition_Table_aka_GPT for more information. It is equivalent to \"boot\" flag in MBR disks.) 3、传统GRUB：（present in the AUR as grub-legacy, does not support GPT disks. Fedora's heavily patched GRUB Legacy fork grub-legacy-fedora-git contains GPT patches from Intel (tested in Fedora, not tested in Arch).） 分区工具： GPT fdisk 是一个用于编辑GPT磁盘的文本模式工具集，sgdisk 和 cgdisk 相当于util-linux 的fdisk。 GNU Parted GNU Parted >= 3.0支持对GPT的操作。 英文： https://wiki.archlinux.org/index.php/GUID_Partition_Table#Convert_from_MBR_to_GPT_without_data_loss","title":"启动机制一： GPT"},{"content":"       说东汉末年，有三个不法分子，拉杆扯旗，要争夺天下仅有的一个皇帝宝座（单例模式），其中一个叫刘备的人在一个叫桃园的地方和关羽张飞拜了把子，组团开始抢地盘（组合模式），有天夜里几个人一合计“听说这年头抢地盘都得有个军师，改天咱们哥几个也找个人吧。”其他二人一直同意，刘关张三人开始走遍大江南北找“军师”。          就在这一天，刘关张三人来到了一个叫“卧龙岗”的地方，听说一个叫诸葛亮的人挺厉害，哥几个兴高采烈去找此人，但是今天好不巧啊，人不在，哥几个只好让书童代他们表达自己的意思“若先生肯入伙，黄金大大滴有！”（代理模式），如此三次，刘关张三人才见到传说中的“亮”！刘备让二弟和三弟在门外把风，自己和亮在屋里密谋大计！          亮说，想抢地盘，必须得这样，然后这样，最后就有三分之一的地盘是你的了！（建造者模式）刘和亮谈完话。两人勾肩搭背回到自己地盘，刘备说“以后亮就是咱们的军师，让它发号施令吧”，亮在一盘偷这乐了！亮说“张飞啊！你最能干，你去训练新兵吧”实际亮心里想“让你偷我的饼干吃！看你怎么办！我不管你怎么弄，最后我只要结果，哈哈”（简单工厂模式）          到了第二天，关羽去找张飞喝酒，看见张飞在那皱着眉头，知道他在为练兵的事发愁，两人开出在一起合计起来，关羽说“三弟啊！这新兵刚来，你得非开对待啊，有以前务农的，以前盖房的，以前打铁的等等，你得逐个击破啊（工厂方法模式）好好想想怎么弄啊！“          几日过后，亮来视察，夸奖张飞”飞弟弟啊！不错嘛，新兵来自五湖四海，但是现在我只看见两种兵，步兵和骑兵！（抽象工厂模式）不错不错…………诶……诶！你怎么又偷吃我的饼干！站住……“          又到了一年春天，刘备在院子里正叹气啊，亮来到身边问起，备说”有一个叫曹操的小子，仗着自己是高富帅，在北方的地盘那个大啊！让人羡慕啊，该满足了吧，谁知道人家惦记起咱们的地盘了呢！哎，愁啊……“亮笑笑，摸着胡子说”咱们东边有个叫孙权的孩子，打小和曹操有仇，咱们联合他吧“备觉得好极了，亮带着备的诚意直奔东吴！（桥接模式）临走时留给备三个锦囊，并说遇到不能过去的砍再打开（策略模式）！           先放下刘关张，单说说曹操，这个高富帅领着八十万大军直奔南方准备去抢地盘，结果到了地界发现自己好吃亏啊！人家这都是大江大河，咱们北方没打过这种仗啊！曹口出狂言“接口不对啊！”这时有个神仙姐姐托梦给曹，让他将船连成一片打造新世纪航母！（适配器模式）曹醒后大笑！！！           第二天，曹画了图纸，让所有的船三个一组，结成新世纪航母（模版模式），曹操规定，大军用船期间，船只在“起航”，“停泊”，“航行”三个状态下进行不同的组合！（状态模式），并组织先头部队深入敌营打探情况，回来报告给所有将军！共同研究对策！（观察者模式）曹军士气大增，大有抢光地盘的势头！        再回到蜀国，说道亮出使吴国，舌战群雄，最终达成一致对外的协议（外观模式），协议如下：吴蜀联盟集团下设吴国，蜀国！吴国出人，出船，蜀国负责拉外援，借东风，借箭！（职责链模式）！        话说亮接到借箭的任务后很郁闷，三十万只箭啊！愁死亮了啊！亮一遍惆怅，一边邀请吴国一个叫鲁肃的参谋一起喝酒，他们商量好找时间一起乘船去江边散心，量出主意，为了增加诗意，船上用草人装饰。所有船都蒙上草皮（装饰者模式），大家心里都明白，亮有阴谋，但是都在猜测，亮怕自己的阴谋泄露，每天晚上逐个点查自己的亲信（迭代器模式）        到了去江边那一天，亮在船头发号施令“米苗苗，都铎”！又说了一句“呼呼呀，可乐”众人一头雾水，只有他的亲信听得懂，因为亮说的是密语，得进过密码翻译才能成功！（解释器模式）并制成密码本，拓印至军中（原型模式）而且他们都已经商量好，亮发布命令，士兵甲传递命令，士兵乙保存命令密码，其他士兵执行命令！（命令模式），众人都不知道亮的阴谋！都在猜测……亮说我会根据当时访问船的人得多少，决定船怎么走，大家注意我的口令啊！（访问者模式）        船到了江心，亮命人擂鼓，呐喊，引来曹操大军，曹见江中有雾，害怕是埋伏，只准射箭！亮见曹操这样大喜啊！亮发布命令，同一时刻，每条船保证只有没有被射到箭的地方朝向大军，只有一条船擂鼓就行！（享元模式）        曹操思考一会觉得不对，正要整军出击，突然，天空一片黑暗……        只听到有人喊道“停电了，没保存记录啊，还得重新玩，悲哀啊……”（备忘录模式）   本故事纯属虚构！如若和某位大神的文章重叠，纯属巧合！故事和模式有些配合地很生硬，请大家斧正！","title":"[置顶] 设计模式初探（五）——二三模式一锅煮"},{"content":"         struts是一个最基本的最经典的框架。整合了servlet和jsp的优点。他的整体结构和执行流程可以通过下面这幅图清晰的展现出来。          即，当用户在web端发送了请求，请求通过actionServlet读取struts-config.xml配置文件信息，然后通过Action发送给底层进行处理，处理完毕后由Action继续发送返回值，最后通过actionservlet根据返回值再次读取配置文件，返回到对应的页面，最后返回客户端。            struts对咱们常说的MVC做了具体的实现。ActionServlet和Action对应的部分相当于咱们MVC中的C，也就是控制层，它主要是控制基本的url分发，表单数据和转向信息等内容，负责和底层的业务逻辑等内容打交道。jsp和web客户端相当于咱们的v层，主要是页面展示部分。m主要是指包括业务逻辑层在内的和数据库打交道的部分。struts在MVC的基础上根据J2EE的特性进行了部分扩展。            struts中用到了很多的组件：            struts中添加了内部状态模型，这些模型主要是由ActionForm 来表示，只能供Action使用，而不供业务逻辑层和dao层使用，主要为了封装页面数据。           ActionServlet做了中央控制器，主要负责url分发等工作内容，当前端传来的请求到达ActionServlet，他可以制定具体的执行Action，在具体的实现中主要是通过一组对象ActionMapping实现的。           通过 ActionForward组件，我们可以通过简单的配置来实现我们的界面之间的跳转。           Struts在显示层增加了标签库，使界面的开发更加方便。           Struts中最重要的一个组成部分是它的配置文件，通过web.xml可以配置对应的web-config.xml，web-config.xml可以将我们以上组件结合起来进行使用。对于一个简单的程序，我们可以仅仅配置一个web-config.xml。对于大的系统，我们可以配置多个web-config.xml来分别对应我们的底层。方便管理和开发。          以上是对struts的基本的了解。相信在以后做项目的过程中还会有更深入的理解。         ","title":"struts初识"},{"content":"一、建造者模式 将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。   建造模式的出现 引子 借用书上的例子，那炒菜（西红柿鸡蛋）来说，我们需要的原材料有：鸡蛋，西红柿；基本调料：油，盐/糖，葱花。 每次我们都需要重复这样的操作，可悲的是，尽管调料，材料都很少，厨师还是会出现忘记加盐，或者葱花的情况。怎么办？ 为了解决这个问题，我们来分析一下，这些东西都是做菜不可缺少的东西，我们可以给这个菜制定一个流程，每次都按照这个流程去做，这样就不会忘记。 当然有的人胃口比较重，需要多加盐，有的人喜欢吃甜的，那我们就需要加一样调料：糖。针对这些具体的细节要求，我们需要有在做菜前有一个说明，告诉厨师多加盐，或者放糖，不放盐。   把这个模式放到编程的世界就是建造者模式。   来类比一下： 生活 西红柿流程 说明 加盐西红柿 加糖西红柿 建造者模式 建造者 指挥者 建造者子类1 建造者子类2   建造者模式把一个对象的基本构建给造出来，然后根据修饰细节的不同再进行扩展创建。 注意： 1、所有的扩展子类都必须实现父类——保证建造的初衷不变。 2、子类的扩展时对父类的细节修饰——不是实质改变   二、类图 从图中可以看出，具体的实现是CreateeBuilder来完成的，而CreateBulider之间具体的不同又是依赖现实生活中的东西Things来体现的。","title":"建造者模式——创建型模式之三"},{"content":"问题 在开发中，我们经常可能要递归构建树状的组合结构。 当你发现需求中是体现部分与整体层次的结构时，以及你希望用户可以忽略组合对象与当个对象的不同，统一的使用组合结构中的所有对象时，应该考虑用组合模式。 composite组合模式 将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和组合对象的使用具有一致性。   component部件：为组合中的对象声明接口，声明了类共有接口的缺省行为。声明一个接口函数用于访问和管理Component的子部件 composite组合：定义有枝节点行为，用来存储子部件，在component接口中实现与子部件有关的操作，Add，Remove等 leaf叶子：在组合模式中表示叶节点对象，叶节点没有子节点 Component模式是为解决组件之间的递归组合提供了解决的办法,它主要分为两个派生类,其中的Leaf是叶子结点,也就是不含有子组件的结点,而Composite是含有子组件的类.举一个例子来说明这个模式,在UI的设计中,最基本的控件是诸如Button,Edit这样的控件,相当于是这里的Leaf组件,而比较复杂的控件比如List则可也看做是由这些基本的组件组合起来的控件,相当于这里的Composite,它们之间有一些行为含义是相同的,比如在控件上作一个点击,移动操作等等的,这些都可以定义为抽象基类中的接口虚函数,由各个派生类去实现之,这些都会有的行为就是这里的Operation函数,而添加,删除等进行组件组合的操作只有非叶子结点才可能有,所以虚拟基类中只是提供接口而且默认的实现是什么都不做. composite组合模式比较容易理解，想到composite组合模式就应该想到树形结构图。组合体内这些对象都有共同接口，当组合体一个对象的方法被调用执行时，composite将遍历(iterator)整个树形结构，寻找同样包含这个方法的对象并调用执行。可以用牵一动百来形容。所以composite组合模式使用到了Iterator模式，和Chain Of Responsibility模式类似。 小demo composite.h /********************************************************************\tcreated:\t2006/07/20\tfilename: \tComposite.h\tauthor:\t\t李创                http://www.cppblog.com/converse/\tpurpose:\tComposite模式的演示代码*********************************************************************/#ifndef COMPOSITE_H#define COMPOSITE_H#include <string>#include <list>using namespace std;// 组合中的抽象基类class Component{private:    string m_strName;public:\tComponent(string paramName){m_strName=paramName;}\tvirtual ~Component(){}    \t// 纯虚函数,只提供接口,没有默认的实现\tvirtual void Operation() = 0;\t// 虚函数,提供接口,有默认的实现就是什么都不做    virtual void Add(Component* pChild){}//添加一个子部件    virtual void Remove(Component* pChild){}//删除一个子部件    virtual Component* GetChild(int nIndex){return NULL;}//获取子部件的指针};// 派生自Component,是其中的叶子组件的基类class Leaf  : public Component{public:    Leaf(string strParam):Component(strParam){}\tvirtual ~Leaf(){}\tvirtual void Operation();};// 派生自Component,是其中的含有子件的组件的基类class Composite\t: public Component{public:    Composite(string strParam):Component(strParam){}\tvirtual ~Composite();\tvirtual void Operation();\tvirtual void Add(Component* pChild);\tvirtual void Remove(Component* pChild);\tvirtual Component* GetChild(int nIndex);private:\t// 采用list容器去保存子组件\tstd::list<Component*>\tm_ListOfComponent;};#endif   composite.cpp /********************************************************************\tcreated:\t2006/07/20\tfilename: \tComposite.cpp\tauthor:\t\t李创                http://www.cppblog.com/converse/\tpurpose:\tComposite模式的演示代码*********************************************************************/#include \"Composite.h\"#include <iostream>#include <algorithm>  /*-------------------------------------------------------------------\tLeaf成员函数的实现-------------------------------------------------------------------*/void Leaf::Operation(){    static int a=0;    a=a++;\tstd::cout << \"Operation by leaf\\n\"<<a<<endl;}/*-------------------------------------------------------------------\tComposite成员函数的实现-------------------------------------------------------------------*/Composite::~Composite(){\tstd::list<Component*>::iterator iter1, iter2, temp;\tfor (iter1  = m_ListOfComponent.begin(), iter2 = m_ListOfComponent.end();\t\t iter1 != iter2;\t\t )\t{\t\ttemp = iter1;\t\t++iter1;\t\tdelete (*temp);\t}}void Composite::Add(Component* pChild){\tm_ListOfComponent.push_back(pChild);}void Composite::Remove(Component* pChild){\tstd::list<Component*>::iterator iter;\titer = find(m_ListOfComponent.begin(), m_ListOfComponent.end(), pChild);\tif (m_ListOfComponent.end() != iter)\t{\t\tm_ListOfComponent.erase(iter);\t}}Component* Composite::GetChild(int nIndex){\tif (nIndex <= 0 || nIndex > m_ListOfComponent.size())\t\treturn NULL;\tstd::list<Component*>::iterator iter1, iter2;\tint i;\tfor (i = 1, iter1  = m_ListOfComponent.begin(), iter2 = m_ListOfComponent.end();\t\titer1 != iter2;\t\t++iter1, ++i)\t{\t\tif (i == nIndex)\t\t\tbreak;\t}\treturn *iter1;}void Composite::Operation(){\tstd::cout << \"Operation by Composite\\n\";\tstd::list<Component*>::iterator iter1, iter2;\tfor (iter1  = m_ListOfComponent.begin(), iter2 = m_ListOfComponent.end();\t\titer1 != iter2;\t\t++iter1)\t{\t\t(*iter1)->Operation();\t}}   main.cpp #include \"Composite.h\"#include <stdlib.h> int main(){ \tComposite* pComposite = new Composite(\"Compostie\");\tpComposite->Add(new Leaf(\"leaf1\"));\tpComposite->Add(new Leaf(\"leaf2\"));\tpComposite->Operation();\tpComposite->GetChild(2)->Operation();    delete pComposite;    Composite* myComposite = new Composite(\"myCompostie\");    myComposite->Add(new Leaf(\"leaf3\"));    delete myComposite;\tsystem(\"pause\");\treturn 0;} 好处： 1.使客户端调用简单，客户端可以一致的使用组合结构或单个对象，用户就不必关心自己处理的是单个对象还是整个组合结构，这就简化了客户端代码 2.更容易在组合体内加入对象部件。客户端不必因为加入了新的对象部件二更改代码。 如何使用composite？ 首先定义一个接口或抽象类，这是设计模式的通用方式，其他设计模式对接口内部定义限制不多，composite却有个规定，那就是要在接口内部定义一个用于访问和管理composite组合体对象们(或称部件component)。","title":"[设计模式]Composite组合模式"},{"content":"当我想去了解组合模式的时候，网上搜一下，有很多优秀的文章，但很多人都在直接给出了组合模式的UML图，然后就去讲解什么是组合，组合有什么优缺点。 我承认他们也许讲的很好，但我并没有一下子就能理解了组合模式，也不了解文章所说的优缺点；结合自己的感受，所以在这里，我想 把书上看到的UML类图变化，和大家分享一下，看看组合模式是怎么一步一步演变出来的。这样，以后开发就知道自己在做哪一步了， 该怎么去调整自己的项目结构。   案例：公司的人事管理，就是领导与被领导。。。     根据这个人事图，最先设计的UML图是：   呵呵，如果让你来看这个UML图，你会吐槽点什么呢？有没有发现，接口里有好多方法重复了呢？有没有觉得这样的设计很烂。。。。 所以，改进是必须的：      改进版的UML看起来很不错额，最起码干掉了一个IRoot接口，你看多牛逼，整个类图看起来简洁很多而且方法也不重复 了，很有成就感是不是，但仔细看看，真的改好了吗？仔细look。。。   现在我们能理解了吧，上一个类图中 ILeaf接口中的getInfo（）方法有重大的嫌疑，你再回去仔细瞧瞧； 那现在这个类图行了吗？   这个时候我们的理解一下接口的作用了， 接口的作用：定义共性，凡是其他接口有的，另一个接口就没必要重复了。 所以，你还得仔细想想，有没有哪些是功能上重复了的。。。。。     对的，上一图中ICop中getInfo（）是不是和IBranch中的getSubordinateInfo（）功能上重复了，所以还得改，最终才有这个版本的类图。 也许你已经发现，怎么和文章中的第一个图那么相似呢？ 对的，这个就是组合模式图了，也就是说，如果你把自己的项目优化优化，也许不知不觉中就在使用了组合模式。   好吧，现在理解了什么是组合模式没？没的话，就多看几遍类图吧，代码就不上了，网上一搜还是有很多的，其实，我也没怎么看代码，只是看了好几遍这几个UML图，自己去慢慢品味的。。。。   好吧，我也留下笔记好了，说说官方的组合模式：   组合模式的几个角色： 抽象构件（Component）：定义参加组合的对象的共有方法和属性，可以定义一些默认的行为或属性，比如getInfo 叶子构件（Leaf）：叶子对象，其下没有分支。 树枝构件（Composit）：树枝对象，它的作用是组合树枝节点和叶子节点。   组合的适用场合： 1. 你想表示对象的部分-整体层次结构。 2. 你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。   优点： 1. 组合模式可以很容易的增加新的构件。 2. 使用组合模式可以使客户端变的很容易设计，因为客户端可以对组合和叶节点一视同仁。 缺点： 1. 使用组合模式后，控制树枝构件的类型不太容易。 2. 用继承的方法来增加新的行为很困难。         PS：如果不太明白组合是什么，可以先了解一下组合与继承","title":"组合模式（Composite Pattern ）"},{"content":"从数据访问程序看设计模式之工厂模式、抽象工厂模式           问题描述：我公司做好了一个项目，是给一家企业做的电子商务网站，用的是SQL Server数据库。         （1）最基本的数据访问程序          类图如下：   程序的代码如下： User类：用于类，假设只有ID和Name两个字段。 class User    {        private int _id;        public int ID        {            get { return _id; }            set { _id = value; }        }        private string _name;        public string Name        {            get { return _name; }            set { _name = value; }        }    } SqlserverUser类——用于操作表，假设只有“新增用户”和“得到用户方法”。   class SqlserverUser    {        public void Insert(User user)        {            Console.WriteLine(\"在Sqlserver中给User表增加一条记录\");        }        public User GetUser(int id)        {            Console.WriteLine(\"在Sqlserver中根据ID得到User表一条记录\");            return null;        }    } 客户端代码： static void Main(string[] args)        {            User user = new User();            SqlserverUser su = new SqlserverUser();            su.Insert(user);            su.GetUser(1);            Console.Read();        } 这是开始写的程序代码，非常的简单。但是它的缺点也很明显。 如果我公司又接到另一家企业类似需求的项目，但这家公司要求用Access数据库，不能用SQL Server数据库。 上面的程序由于Sqlserver su=new SqlserverUser()使得su这个对象被框死在SQL Server上了，缺少了灵活性，所以不能换数据库。   那如何改进呢？如果用“工厂方法模式”来封装new SqlserverUser()所造成的变化，会不会更好呢？ （2）用工厂方法模式访问数据程序          类图如下： （3）用“抽象工程模式”的数据访问程序           类图如下：           优点：         缺点： （4）用简单工厂来改进抽象工厂 （5）用反射+抽象工厂的数据访问程序：         类如如下：  （6）用反射+配置文件实现数据访问程序：           具体代码见《大话设计模式》（程杰著）之抽象工厂的部分。           在这里我要说明的一点是本文的“用简单工厂来改进抽象工厂”的图和大话课本的略有不同，课本这张图和用了反射的图是一样的。个人对有反射和无反射的图加以了区分。         上述的各图表示了一个数据访问程序的改进过程的全部类图演变过程，是个人对这个数据访问程序的个人理解，不知道理解的是否完全正确，还请高手指教。    ","title":"从数据访问程序看设计模式之工厂模式、抽象工厂模式"},{"content":"         Hibernate  是一个对象关系映射框架，不过主要针对轻量级的对象，使得我们对底层的操作附加了编程的思想。          hibernate中映射对象需要用到几个重要的接口。                        Session接口，负责和数据库打交道。          SessionFactory接口，主要负责初始化Hibernate。          Transaction接口，负责事务的相关管理。         Query和Criteria接口，负责各种数据库的查询。             Hibernate通过核心接口主要是进行映射，所以hibernate里面最重要的是映射关系：具体是现是通过hbm.xml文件和实体进行映射，进而生成表。            hibernate中的映射关系包括：一对一，一对多，多对一，多对多。同时以上四中对应关系还有单双向之分。同时还包括集成映射和符合主键的映射关系。           这些映射关系主要是通过hbm.xml文件中的标签进行设置。当然hbm.xml文件还有更多的属性来反应我们的映射关系和其他设置。比如设置主键等。          当然了，hibernate还有更多的内容需要我们深入的去研究。视频完成后会有更详细的介绍。 ","title":"hibernate初识"},{"content":"ActiveMQ集群：网络连接模式(network connector)详解 kimmking@163.com 2012-12-26 网络连接模式(network connector) 针对海量消息所要求的横向扩展性和系统的高可用性，ActiveMQ提供了网络连接模式的集群功能。简单的说，就是通过把多个不同的broker实例连接在一起，作为一个整体对外提供服务，从而提高整体对外的消息服务能力。通过这种方式连接在一起的broker实例之间，可以共享队列和消费者列表，从而达到分布式队列的目的。 拓扑结构 几种不同的ActiveMQ部署拓扑结构（嵌入、主从复制、网络连接）： 配置示例 在activemq.xml的broker节点内添加： <networkConnectors>       <networkConnectoruri=\"static:(tcp://localhost:62001)\"/> <\/networkConnectors> uri也可以使用其他两种方式： 1.          multicast://default 2.          masterslave:(tcp://host1:61616,tcp://host2:61616,tcp://..) 其中masterslave方式的第一个url需要是master，其他是slave。 一个broker的实例内可以配置多个networkConnector，如果有两个以上的networkConnector指向同一个broker，则需要显式的指定name。 静态URI配置 使用静态URI方式可以指定多个URL，networkConnector将连接到每一个broker。 <networkConnectors>       <networkConnector uri=\"static:(tcp://host1:61616,tcp://host2:61616,tcp://..)\"/> <\/networkConnectors> URI的几个属性： 属性 默认值 描述 initialReconnectDelay 1000 重连之前等待的时间(ms) (如果useExponentialBackOff为 false) maxReconnectDelay 30000 重连之前等待的最大时间(ms) useExponentialBackOff true 每次重连失败时是否增大等待时间 backOffMultiplier 2 增大等待时间的系数 networkConnector配置 配置参数 属性 默认值 描述 name bridge 名称 dynamicOnly false 如果为true, 持久订阅被激活时才创建对应的网路持久订阅。默认是启动时激活。 decreaseNetworkConsumerPriority false 如果为true，网络的消费者优先级降低为-5。如果为false，则默认跟本地消费者一样为0. networkTTL 1 消息和订阅在网络上通过的broker数量 conduitSubscriptions true 多个网络消费者是否被当做一个消费者来对待。 excludedDestinations empty 不通过网络转发的destination dynamicallyIncludedDestinations empty 通过网络转发的destinations，注意空列表代表所有的都转发。 staticallyIncludedDestinations empty 匹配的都将通过网络转发-即使没有对应的消费者 duplex false 如果为true，则既可消费又可生产消息到网络broker prefetchSize 1000 设置网络消费者的prefetch size参数。必须大于0，因为网络消费者不能自己轮询消息。 suppressDuplicateQueueSubscriptions false (从5.3版本开始) 如果为true, 重复的订阅关系一产生即被阻止。 bridgeTempDestinations true 是否广播advisory messages来创建临时destination。 alwaysSyncSend false (从 5.6版本开始) 如果为true，非持久化消息也将使用request/reply方式代替oneway方式发送到远程broker。 staticBridge false (从5.6版本开始) 如果为true，只有staticallyIncludedDestinations中配置的destination可以被处理。 networkConnector的实现原理是基于ActiveMQ的公告消息（AdvisoryMessage）机制的（参见此处）。当broker2通过networkConnector、duplex方式指向broker1时，发生了什么呢？ 假定broker1已经启动，这时候broker2开始启动。 1.         broker2先启动自己的connector 2.         然后使用一个vm的connector，创建一个connection，把自己作为一个client，连接到broker1。 3.         通过订阅Advisory Message，拿到相互的Consumer与相应的Queue列表。 至此，双方建立关系。 然后通过broker1的转发，broker1上的消费者，就可以消费broker2的queue上的消息。这个过程可以看做一个消息被消费了两次，broker1作为消费者，消费掉broker2上的消息，broker1再作为broker，把消息投递给实际的消费者。 管道订阅(conduit subscription) conduitSubscriptions选择决定网络消费者在所有消费者中的比重。假如有2个同一个远程的broker1上的网络消费者和一个broker2的本地消费者。 1.        conduitSubscriptions为true，则2个网络消费者只相当于一个消费者，broker1仅仅在broker2上注册了一个消费者。这时往broker2上发送300个消息，2个网络消费者各接收到75个消息，一个本地消费者接收到150 消息。 2.        conduitSubscriptions为false，则3个消费者平分所有消息，broker1在broker2上将注册了两个消费者。这时往broker2上发送300个消息，2个网络消费者和本地消费者一样，各接收到100个消息。 双向网络连接(duplex networkConnector) 默认NetworkConnector在需要转发消息时是单向连接的。当duplex=true时，就变成了双向连接，这时配置在broker2端的指向broker1的duplex networkConnector，相当于即配置了 broker2到broker1的网络连接，也配置了broker1到broker2的网络连接。（就是说不管broker1同意与否，都被绑架了。）当然，仅仅在broker1上配置也有同样的效果。 注意：可以在两个broker间建立两个以上的双向网络连接来增加吞吐量或对主题\\队列分区，只需要指定他们使用不同的name即可。 指定和限制Destination 通过NetworkConnector共享的destination太多，传输的Advisory Message就会变的非常多，系统的拓扑结构将变得非常复杂，所有才有多种方式来限制这些destination配置： 1.        dynamicallyIncludedDestinations ü  这里匹配到的destination，在需要时将被转发 2.        excludedDestinations ü  这里匹配到的destination，将不会被转发 3.        staticallyIncludedDestinations ü  如果指定了staticBridge为true，则只有这里匹配的destination可以被转发。此时本地broker完全被其他broker代理。并且本broker不会订阅其他broker上的AdvisoryMessage，也不会获取任何远程consumer信息。 这几个配置可以使用通配符，比如“>”，详见wildcard。 示例代码： <networkConnectors>       <networkConnector uri=\"static:(tcp://localhost:61617)\"          name=\"bridge\"          conduitSubscriptions=\"true\"          decreaseNetworkConsumerPriority=\"false\">          <dynamicallyIncludedDestinations>                    <queue physicalName=\"include.test.foo\"/>                    <topic physicalName=\"include.test.bar\"/>          <\/dynamicallyIncludedDestinations>          <excludedDestinations>                    <queue physicalName=\"exclude.test.foo\"/>                    <topic physicalName=\"exclude.test.bar\"/>          <\/excludedDestinations>         <staticallyIncludedDestinations>                    <queue physicalName=\"always.include.queue\"/>                    <topic physicalName=\"always.include.topic\"/>          <\/staticallyIncludedDestinations>       <\/networkConnector>     <\/networkConnectors> 此外，从5.6版本起，可以在networkConnector上设置destinationFilter来指定感兴趣的Advisory Message将被传播。 <networkConnector uri=\"static:(tcp://host)\" destinationFilter=\"Queue.include.test.foo,ActiveMQ.Advisory.Consumer.Topic.include.test.bar\">   <dynamicallyIncludedDestinations>     <queue physicalName=\"include.test.foo\"/>     <topic physicalName=\"include.test.bar\"/>   <\/dynamicallyIncludedDestinations> <\/networkConnector> 被卡住的消息 一个很有意思的场景是，broker1和broker2通过networkConnector连接。一些个consumers连接到broker1，消费broker2上的消息。消息先被broker1从broker2上消费掉，然后转发给这些consumers。不幸的是转发部分消息的时候broker1重启了，这些consumers发现broker1连接失败，通过failover连接到broker2上去了，但是有一部分他们还没有消费的消息被broker2已经分发到了broker1上去了。这些消息，就好像是消失了，除非有消费者重新连接到broker1上来消费。怎么办呢？ 办法就是从5.6版本destinationPolicy上新增的选项replayWhenNoConsumers。这个选项使得broker1上有需要转发的消息但是没有消费者时，把消息回流到它原始的broker。同时把enableAudit设置为false，为了防止消息回流后被当做重复消息而不被分发。 <destinationPolicy>       <policyMap>         <policyEntries>           <policyEntry queue=\"TEST.>\" >             <conditionalNetworkBridgeFilterFactory replayWhenNoConsumers=\"true\" enableAudit=\"false\"/>           <\/policyEntry>         <\/policyEntries>       <\/policyMap>     <\/destinationPolicy> 更详细的讨论见这里： http://tmielke.blogspot.de/2012/03/i-have-messages-on-queue-but-they-dont.html 其他说明 1.        NetworkConnector基于AdvisoryMessage机制，如果broker的advisorySupport选型被禁用，则NetworkConnector将不起作用。 2.        用作转发的broker中入列出列这些统计信息只记录其转发的数据。 3.        用作转发的broker中无法看到远程broker的相同队列中的数据（browse消息列表为空，queuesize为0）。 使用示例 下载ActiveMQ 5.7版本，其中带了包含static network connector的例子。 即配置文件activemq-static-network-broker1.xml和activemq-static-network-broker2.xml。 他们分别使用端口 tcp://localhost:61616和tcp://localhost:61618 static network connector在第二个文件里。 分别使用这两个配置文件启动两个broker实例（先启动broker1，再启动broker2）。 在broker2的控制台看到： INFO | Establishing network connection fromvm://static-broker2?async=false&network=true to tcp://localhost:61616  INFO |Connector vm://static-broker2 Started  INFO |Network Connector DiscoveryNetworkConnector:NC:BrokerService[static-broker2]Started  INFO |Apache ActiveMQ 5.7.0 (static-broker2, ID:kimmking-2270-1356502079016-0:1)started  INFO |For help or more information please see: http://activemq.apache.org  INFO |Network connection between vm://static-broker2#0 andtcp://localhost/127.0.0.1:61616 @2271(static-broker1) has been established. 在broker1的控制台看到： INFO | Network connection betweenvm://static-broker1#0 and tcp:///127.0.0.1:1710@61616 (static-broker2) has beenestablished. 在命令行输入jconsole，然后分别通过下列url连接jmx控制台来管理broker： ü  service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi ü  service:jmx:rmi:///jndi/rmi://localhost:1100/jmxrmi 也可以再这两个xml中配置jetty来使用web控制台查看和管理。 然后可以通过代码在两个broker中通过static network connector存取消息。 测试代码： package org.qsoft.activemq.test;import java.util.concurrent.atomic.AtomicInteger;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.MessageListener;import javax.jms.MessageProducer;import javax.jms.Queue;import javax.jms.QueueConnection;import javax.jms.QueueConnectionFactory;import javax.jms.QueueReceiver;import javax.jms.QueueSession;import javax.jms.Session;import javax.jms.TextMessage;import org.apache.activemq.ActiveMQConnectionFactory;import org.apache.activemq.command.ActiveMQQueue;public class TestReceiver {\t/**\t * @param args\t */\tpublic static void main(String[] args) {\t\ttry {\t\t\t// init connection factory with activemq\t\t\tQueueConnectionFactory factoryA = new ActiveMQConnectionFactory(\"tcp://127.0.0.1:61616\");\t\t\t// specify the destination\t\t\tQueue queueB = new ActiveMQQueue(\"kk.b\");\t\t\t// create connection,session,consumer and receive message\t\t\tQueueConnection connA = factoryA.createQueueConnection();\t\t\tconnA.start();\t\t\t\t\t\t// first receiver on broker1\t\t\tQueueSession sessionA1 = connA.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);\t\t\tQueueReceiver receiverA1 = sessionA1.createReceiver(queueB);\t\t\tfinal AtomicInteger aint1 = new AtomicInteger(0);\t\t\tMessageListener listenerA1 = new MessageListener(){\t\t\t\tpublic void onMessage(Message message) {\t\t\t\t\ttry {\t\t\t\t\t\tSystem.out.println(aint1.incrementAndGet()+\" => A1 receive from kk.b: \" + ((TextMessage)message).getText());\t\t\t\t\t} catch (JMSException e) {\t\t\t\t\t\te.printStackTrace();\t\t\t\t\t}\t\t\t\t}};\t\t\treceiverA1.setMessageListener(listenerA1 );\t\t\t\t\t\t// second receiver on broker1\t\t\tQueueSession sessionA2 = connA.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);\t\t\tQueueReceiver receiverA2 = sessionA2.createReceiver(queueB);\t\t\tfinal AtomicInteger aint2 = new AtomicInteger(0);\t\t\tMessageListener listenerA2 = new MessageListener(){\t\t\t\tpublic void onMessage(Message message) {\t\t\t\t\ttry {\t\t\t\t\t\tSystem.out.println(aint2.incrementAndGet()+\" => A2 receive from kk.b: \" + ((TextMessage)message).getText());\t\t\t\t\t} catch (JMSException e) {\t\t\t\t\t\te.printStackTrace();\t\t\t\t\t}\t\t\t\t}};\t\t\treceiverA2.setMessageListener(listenerA2 );\t\t\t\t\t\t// a fake one on broker1\t\t\tQueueReceiver receiverA3 = sessionA2.createReceiver(queueB);\t\t\tfinal AtomicInteger aint3 = new AtomicInteger(0);\t\t\tMessageListener listenerA3 = new MessageListener(){\t\t\t\tpublic void onMessage(Message message) {\t\t\t\t\ttry {\t\t\t\t\t\tSystem.out.println(aint3.incrementAndGet()+\" => A3 receive from kk.b: \" + ((TextMessage)message).getText());\t\t\t\t\t} catch (JMSException e) {\t\t\t\t\t\te.printStackTrace();\t\t\t\t\t}\t\t\t\t}};\t\t\treceiverA3.setMessageListener(listenerA3 );\t\t\t\t\t\tQueueConnectionFactory factoryB = new ActiveMQConnectionFactory(\"tcp://127.0.0.1:61618\");\t\t\tQueue queueB1 = new ActiveMQQueue(\"kk.b\");\t\t\tQueueConnection connB = factoryB.createQueueConnection();\t\t\tconnB.start();\t\t\t\t\t\t// one receiver on broker2\t\t\tQueueSession sessionB1 = connB.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);\t\t\tQueueReceiver receiverB1 = sessionB1.createReceiver(queueB);\t\t\tfinal AtomicInteger bint1 = new AtomicInteger(0);\t\t\tMessageListener listenerB1 = new MessageListener(){\t\t\t\tpublic void onMessage(Message message) {\t\t\t\t\ttry {\t\t\t\t\t\tSystem.out.println(bint1.incrementAndGet()+\" => B1 receive from kk.b: \" + ((TextMessage)message).getText());\t\t\t\t\t} catch (JMSException e) {\t\t\t\t\t\te.printStackTrace();\t\t\t\t\t}\t\t\t\t}};\t\t\t\treceiverB1.setMessageListener(listenerB1 );\t\t\t\t\t\t// producer  on broker2\t\t\tQueueSession sessionBp = connB.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);\t\t\tMessageProducer producer = sessionBp.createProducer(queueB1);\t\t\tint index = 0;\t\t\twhile(index++<300){\t\t\t\tTextMessage message = sessionBp.createTextMessage(index + \" from kk.b on broker2\");\t\t\t\tproducer.send(message);\t\t\t}\t\t\t\t\t\t\t\t} catch (Exception e) {\t\t\te.printStackTrace();\t\t\tSystem.exit(1);\t\t}\t}}","title":"ActiveMQ集群：网络连接模式(network connector)详解"},{"content":"一，首先hibernate中对象的状态有三种：瞬态、游离态和持久态，三种状态转化的方法都是通过session来调用，瞬态到持久态的方法有save（）、saveOrUpdate（）、get（）、load（）；持久态到瞬态的方法有delete（）；游离态到持久态的方法有update（）、saveOrUpdate（）、lock（）；持久态到游离态的方法有：session.close（）、session.evict（）、session.clear（）。 二，Hibernate的状态 　　hibernate的各种保存方式的区(save,persist,update,saveOrUpdte,merge,flush,lock)及 对象的三种状态 　　hibernate的保存 　　hibernate对于对象的保存提供了太多的方法，他们之间有很多不同，这里细说一下，以便区别。 　　一、预备知识 　　在所有之前，说明一下，对于hibernate，它的对象有三种状态，transient、persistent、detached 　　下边是常见的翻译办法： 　　transient：瞬时态或者临时态 　　(new DeptPo(1,”行政部”,20,”行政相关”)，该po的实例和session没有关联，该po的实例处于transient) 　　persistent：持久化状态 　　(和数据库中记录想影射的Po实例，它的状态是persistent, 通过get和load等得到的对象都是persistent) 　　detached：脱管状态或者游离态 　　(1)当通过get或load方法得到的po对象它们都处于persistent,但如果执行delete(po)时(但不能执行事务),该 po状态就处于detached, (表示和session脱离关联),因delete而变成游离态可以通过save或saveOrUpdate()变成持久态 　　(2)当把session关闭时，session缓存中的persistent的po对象也变成detached 　　因关闭session而变成游离态的可以通过lock、save、update变成持久态 　　持久态实例可以通过调用 delete()变成脱管状态。 　　通过get()或load()方法得到的实例都是持久化状态的。 　　脱管状态的实例可以通过调用lock()或者replicate()进行持久化。 　　save()和persist()将会引发SQL的INSERT，delete()会引发SQLDELETE， 　　而update()或merge()会引发SQL UPDATE。对持久化(persistent)实例的修改在刷新提交的时候会被检测到，它也会引起SQL UPDATE。 　　saveOrUpdate()或者replicate()会引发SQLINSERT或者UPDATE 　　二、save 和update区别 　　把这一对放在第一位的原因是因为这一对是最常用的。 　　save的作用是把一个新的对象保存 　　update是把一个脱管状态的对象或自由态对象(一定要和一个记录对应)更新到数据库 　　三、update 和saveOrUpdate区别 　　这个是比较好理解的，顾名思义，saveOrUpdate基本上就是合成了save和update,而update只是update;引用hibernate reference中的一段话来解释他们的使用场合和区别 　　通常下面的场景会使用update()或saveOrUpdate()： 　　程序在第一个session中加载对象,接着把session关闭 　　该对象被传递到表现层 　　对象发生了一些改动 　　该对象被返回到业务逻辑层最终到持久层 　　程序创建第二session调用第二个session的update()方法持久这些改动 　　saveOrUpdate(po)做下面的事: 　　如果该po对象已经在本session中持久化了，在本session中执行saveOrUpdate不做任何事 　　如果savaOrUpdate(新po)与另一个与本session关联的po对象拥有相同的持久化标识(identifier)，抛出一个异常 　　org.hibernate.NonUniqueObjectException: a different object with the same identifier value was already associated with the session: [org.itfuture.www.po.Xtyhb#5] 　　saveOrUpdate如果对象没有持久化标识(identifier)属性，对其调用save() ，否则update() 这个对象 　　四、persist和save区别 　　这个是最迷离的一对，表面上看起来使用哪个都行，在hibernate reference文档中也没有明确的区分他们. 　　这里给出一个明确的区分。(可以跟进src看一下，虽然实现步骤类似，但是还是有细微的差别) 　　主要内容区别： 　　1，persist把一个瞬态的实例持久化，但是并\"不保证\"标识符(identifier主键对应的属性)被立刻填入到持久化实例中，标识符的填入可能被推迟到flush的时候。 　　2，save, 把一个瞬态的实例持久化标识符，及时的产生,它要返回标识符，所以它会立即执行Sql insert 　　五、saveOrUpdate,merge和update区别 　　比较update和merge 　　update的作用上边说了，这里说一下merge的 　　如果session中存在相同持久化标识(identifier)的实例，用用户给出的对象覆盖session已有的持久实例 　　(1)当我们使用update的时候，执行完成后，会抛出异常 　　(2)但当我们使用merge的时候，把处理自由态的po对象A的属性copy到session当中处于持久态的po的属性中，执行完成后原来是持久状态还是持久态，而我们提供的A还是自由态 　　六、flush和update区别 　　这两个的区别好理解 　　update操作的是在自由态或脱管状态(因session的关闭而处于脱管状态)的对象//updateSQL 　　而flush是操作的在持久状态的对象。 　　默认情况下，一个持久状态的对象的改动(包含set容器)是不需要update的，只要你更改了对象的值，等待hibernate flush就自动更新或保存到数据库了。hibernate flush发生在以下几种情况中： 　　1， 调用某些查询的和手动flush(),session的关闭、SessionFactory关闭结合 　　get()一个对象，把对象的属性进行改变,把资源关闭。 　　2，transaction commit的时候(包含了flush) 　　七、lock和update区别 　　update是把一个已经更改过的脱管状态的对象变成持久状态 　　lock是把一个没有更改过的脱管状态的对象变成持久状态(针对的是因Session的关闭而处于脱管状态的po对象(2)，不能针对因delete而处于脱管状态的po对象) 　　对应更改一个记录的内容，两个的操作不同： 　　update的操作步骤是： 　　(1)属性改动后的脱管的对象的修改->调用update 　　lock的操作步骤是： 　　(2)调用lock把未修改的对象从脱管状态变成持久状态-->更改持久状态的对象的内容-->等待flush或者手动flush 　　八、clear和evcit的区别 　　clear完整的清除session缓存 　　evcit(obj)把某个持久化对象从session的缓存中清空。 　　session.lock(xtyhb,LockMode.NONE);//表示直接到缓存中去找变成持久态的对象 　　session.lock(xtyhb,LockMode.READ);//先通过ID读数据库该记录的ID看是否有该记录，如果有接着到缓存中去找变成持久态的对象     在Hibernate中，对象有三种状态：临时状态、持久状态和游离状态。 也叫：瞬时态(Transient)、持久态(Persistent)、脱管态(Detached)。处于持久态的对象也称为PO(Persistence Object)，瞬时对象和脱管对象也称为VO（Value Object）。 临 时状态：当new一个实体对象后，这个对象处于临时状态，即这个对象只是一个保存临时数据的内存区域，如果没有变量引用这个对象，则会被jre垃圾回收机 制回收。这个对象所保存的数据与数据库没有任何关系，除非通过Session的save或者SaveOrUpdate把临时对象与数据库关联，并把数据插 入或者更新到数据库，这个对象才转换为持久对象。 例如：Emp e=new Emp();    //创建临时对象           e.setEmpno((long) 8888);           e.setEName(\"mike\");           ...           EmpDAO d=new EmpDAO();           d.save(e);      //持久化           ... 持久状态:持久化对象的实例在数据库中有对应的记录，并拥有一个持久化表示（ID）。对持久化对象进行delete操作后，数据库中对应的记录将被删除，那么持久化对象与数据库记录不再存在对应关系，持久化对象变成临时状态。     持久化对象被修改变更后，不会马上同步到数据库，知道数据库事务提交。在同步之前，持久化对象是脏的（Dirty）。 例如：           Emp e=new Emp(); //创建了临时的对象           EmpDAO edao= new empDAO();           e=edao.findbyEmpno((long) 7786);    //使对象与数据库记录对应，从而持久化           e.setEname(\"新的名字\");                     //修改了持久化对象，使之处于 Dirty           ......           edao.saveorupdate(e);                      //保存，但是仍然 Dirty           tran.commit();                                     //提交，实现与数据库同步，不再Dirty           ...... 游离状态：当Session进行了Close、Clear或者evict后，持久化对象虽然拥有持久化标识符和与数据库对应记录一致的值，但是因为 会话已经消失，对象不在持久化管理之内，所以处于游离状态（也叫：脱管状态）。游离状态的对象与临时状态对象是十分相似的，只是它还含有持久化标识。 瞬时态         由new命令开辟内存空间的java对象，        eg. Person person = new Person(\"xxx\", \"xx\");         如果没有变量对该对象进行引用，它将被java虚拟机回收。          瞬时对象在内存孤立存在，它是携带信息的载体，不和数据库的数据有任何关联关系，在Hibernate中，可通过session的save()或 saveOrUpdate()方法将瞬时对象与数据库相关联，并将数据对应的插入数据库中，此时该瞬时对象转变成持久化对象。 持久态         处于该状态的对象在数据库中具有对应的记录，并拥有一个持久化标识。如果是用hibernate的delete()方法，对应的持久对象就变成瞬时对象，因数据库中的对应数据已被删除，该对象不再与数据库的记录关联。        当一个session执行close()或clear()、evict()之后，持久对象变成脱管对象，此时持久对象会变成脱管对象，此时该对象虽然具有数据库识别值，但它已不在HIbernate持久层的管理之下。        持久对象具有如下特点：         1. 和session实例关联；        2. 在数据库中有与之关联的记录。 脱管态         当与某持久对象关联的session被关闭后，该持久对象转变为脱管对象。当脱管对象被重新关联到session上时，并再次转变成持久对象。        脱管对象拥有数据库的识别值，可通过update()、saveOrUpdate()等方法，转变成持久对象。        脱管对象具有如下特点：        1. 本质上与瞬时对象相同，在没有任何变量引用它时，JVM会在适当的时候将它回收；         2.   比瞬时对象多了一个数据库记录标识值。  ","title":"关于hibernate中对象的三种状态分析"},{"content":"一，Spring为Hibernate的DAO提供工具类：HibernateDaoSupport。该类主要提供了两个方法： public final HibernateTemplate getHibernateTemplate() ； public final void setSessionFactory(SessionFactory sessionFactory) ； 其中，setSessionFactory方法接收来自Spring的applicationContext的依赖注入，接收了配置在Spring 中的SessionFactory实例，getHibernateTemplate方法用来利用刚才的SessionFactory生成Session， 再生成HibernateTemplate来完成数据库的访问。 典型的继承HibernateDaoSupport的DAO代码如下： public class UserDAOImpl extends HibernateDaoSupport implements UserDAO{ public void save(Users transientInstance) { log.debug(\"saving Users instance\"); try { getHibernateTemplate().save(transientInstance); log.debug(\"save successful\"); } catch (RuntimeException re) { log.error(\"save failed\", re); throw re;       }   } ……………… } 实 际上，DAO的实现依然借助了HibernateTemplate的模板访问方式，只是，HibernateDaoSupport将依赖注入 SessionFactory的工作已经完成，获取HibernateTemplate的工作也已经完成。注意，这种方法须在Spring的配置文件中配 置SessionFactory。 在继承HibrnateDaoSupport的DAO实现里，Hibernate Session的管理完全不需要Hibernate代码打开，而由Spring来管理。Spring会根据实际的操作，采用“每次事务打开一次 session”的策略，自动提高数据库访问的性能。 二，HibernateDaoSupport的优缺点： 编写Dao类的时候尽量不要使用Hiberenate和Spring对Hibernate的支持： 现在我们在编写DAO的时候普遍都是直接继承spring对hibernate的封装类HibernateDaoSupport， 然后使用该类提供的诸如saveOrUpdate(), saveOrUpdateCopy(), find()等等。另外，在使用excute()方法实现一些更复杂的hibernate功能的时候还会使用hibernate的类，诸如Query, Session, Type等。这样直接使用spring和hibernate的类存在的问题在于，你的代码将不得不依赖与spring和hibernate的某个版本。比 如说，现在hibernate3出来了，改动挺大，实际上最要命的是包结构，hibernate2的包结构是net.sf.hibernate.*，然而 hibernate3是org.hibernate.*。同样，spring为了支持hibernate3，包名也改为 org.springframework.orm.hibernate3.*。假如，你现在新开发一个项目，这没什么关系，如果是升级一个项目问题就来 了。如果你希望将你的一个项目从hibernate2升级为hibernate3，你不得不修改DAO中所有对hibernate和spring- hibernate的引用。如果你的代码中出现hibernate2与hibernate3不兼容的方法和类，比如saveOrUpdateCopy( )（在hibernate3中已经没有了）,你还将不得不改写。那么你可能会说，我不会这样升级。如果你的软件生命周期有好多年，hibernate升级到 4，升级到5，你还是依然使用hibernate2？如果你以这种方式开发一个平台，你能要求所有使用你平台的软件项目都只能使用hibernate2？ 更进一步说，我现在开发一个产品，今后的客户将是成千上万。经过1、2年我需要升级了，这时我的升级包有几十M，几乎把所有的DAO都换了个遍，这样的升级无异于重装。 分析原因:是我们项目中的DAO依赖于hibernate和spring，因为我们对它们的使用是继承，是一种很强的关联，就是一种依赖. 解决方案一:我们只需要稍微进行一些调整，就可以解决这个问题，那就是不使用直接继承，而使用接口进行分离。可以使用Fa鏰de模式，先建立一个叫 BasicDao的基础类，从名称我们可以看出，它是所有DAO的基础类，实现DAO操作所需的所有诸如save()、delete()、load()、 query()等方法，除了一些基本的方法，诸如翻页查询、getCount、解析查询条件形成HQL语句等功能也在这里实现，但是不要使用与 hibernate或spring有关的任何方法和类。同时，BasicDao调用一个叫DaoSupport的接口，DaoSupport的接口则是提 供持久化所需的基本方法，最原始的元素。然后，我为DaoSupport接口提供各种不同的实现，比如hibernate2的实现 DaoSupportHibernateImp、hibernate3的实现DaoSupportHibernate3Imp，整个结构如下图所示。 BasicDao可以使用hibernate或spring提供的方法，但是不是直接使用，而是通过调用DaoSupport的实现类来使用。然而 BasicDao到底是使用的那个实现类，我们通过spring的IoC，通过配置文件来决定到底使用哪个实现。同时，BasicDao也不要使用诸如 SpringContext的类来实现IoC，而是通过建立setDaoSupport()和getDaoSupport()方法，然后在spring配 置文件中建立引用。","title":"HibernateDaoSupport详解（增删改查时Dao常用）"},{"content":"1.实例化bean的三种方法: （1） 构造器 <!-- 体验1 --> <bean id=\"personService\" class=\"com.persia.PersonServiceBean\"> <!-- index 代表方法的参数序号，由0开始，基本的类型Type可以不声明--> <constructor-arg index=\"0\" value=\"构造注入的name\" /> <constructor-arg index=\"1\" type=\"com.persia.IDaoBean\" ref=\"personDao\"/> <\/bean> 对应类 public PersonServiceBean(String name, IDaoBean personDao) { this.name = name; this.personDao = personDao; } <!-- 体现2--> <bean id=\"personDao\" class=\"cn.itcast.dao.impl.PersonDaoBean\" /> <bean id=\"personServiceBean\" class=\"cn.itcast.service.impl.PersonServiceBean\"   lazy-init=\"true\" init-method=\"init\" destroy-method=\"destory\">   <!-- ref属性对应id personDao值  name属性对应接口的getter方法名称-->   <property name=\"personDao\" ref=\"personDao\" /> <!-- 体验3 --> <!-- 注入属性值 -->   <property name=\"name\" value=\"123\"/>   <!-- Set的注入 -->   <property name=\"sets\">    <set>     <value>sets：第一个值<\/value>     <value>sets：第二个值<\/value>     <value>sets：第三个值<\/value>    <\/set>   <\/property>   <!-- List的注入 -->   <property name=\"lists\">    <list>     <value>lists：第一个值<\/value>     <value>lists：第二个值<\/value>     <value>lists：第三个值<\/value>    <\/list>   <\/property>   <!-- Properties的注入 -->   <property name=\"properties\">    <props>     <prop key=\"props-key1\">：第一个值<\/prop>     <prop key=\"props-key2\">：第二个值<\/prop>     <prop key=\"props-key3\">：第三个值<\/prop>    <\/props>   <\/property>   <!-- Map的注入 -->   <property name=\"maps\">    <map>     <entry key=\"maps-key1\" value=\"：第一个值\" />     <entry key=\"maps-key2\" value=\"：第二个值\" />     <entry key=\"maps-key3\" value=\"：第三个值\" />    <\/map>   <\/property> <\/bean> （2） 静态工厂： <!-- 静态工厂获取bean --> <bean id=\"personService2\" class=\"com.persia.PersonServiceBeanFactory\" factory-method=\"createInstance\"/> 对应类 public static PersonServiceBean createInstance(){ return new PersonServiceBean(); } （3） 实例工厂： 没有静态方法，因此配置时，先实例化工厂，在实例化需要的bean。 <!-- 实例工厂获取bean，先实例化工厂再实例化bean--> <bean id=\"fac\" class=\"com.persia.PersonServiceBeanInsFactory\"/> <bean id=\"personService3\" factory-bean=\"fac\" factory-method=\"createInstance\"/> 对应类 public PersonServiceBean createInstance(){ return new PersonServiceBean(); } 2. bean的作用域 默认情况为单例方式：scope=”singleton” singleton 单实例作用域，这是Spring容器默认的作用域，使用singleton作用域生成的是单实例，在整个Bean容器中仅保留一个实例对象供所有调用者共享引用。单例模式对于那些无会话状态的Bean（如辅助工具类、DAO组件、业务逻辑组件等）是最理想的选择。 prototype 原型模式，这是多实例作用域，针对每次不同的请求，Bean容器均会生成一个全新的Bean实例以供调用者使用。prototype作用域非常适用于那些需要保持会话状态的Bean实例，有一点值得注意的就是，Spring不能对一个prototype Bean的整个生命周期负责，容器在初始化、装配好一个prototype实例后，将它交给客户端，随后就对该prototype实例不闻不问了。因此，客户端要负责prototype实例的生命周期管理。 request 针对每次HTTP请求，Spring容器会根据Bean的定义创建一个全新的Bean实例， 且该Bean实例仅在当前HTTP request内有效，因此可以根据需要放心地更改所建实例的内部状态， 而其他请求中根据Bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。 当处理请求结束，request作用域的Bean实例将被销毁。该作用域仅在基于web的Spring ApplicationContext情形下有效。 session 针对某个HTTP Session，Spring容器会根据Bean定义创建一个全新的Bean实例，且该Bean实例仅在当前HTTP Session内有效。 与request作用域一样，我们可以根据需要放心地更改所创建实例的内部状态，而别的HTTP Session中根据Bean定义创建的实例， 将不会看到这些特定于某个HTTP Session的状态变化。 当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的Bean实例也会被废弃掉。该作用域仅在基于Web的Spring ApplicationContext情形下有效。 global session global session作用域类似于标准的HTTP Session作用域，不过它仅仅在基于portlet的Web应用中才有意义。portlet规范定义了全局Session的概念，它被所有构成某个portlet Web应用的各种不同的portlet所共享。在global session作用域中定义的Bean被限定于全局portlet Session的生命周期范围内。如果我们是在编写一个标准的基于Servlet的Web应用，并且定义了一个或多个具有global session作用域的Bean，系统会使用标准的HTTP Session作用域，并且不会引起任何错误。该作用域仅在基于Web的Spring ApplicationContext情形下有效。 3. bean的生命周期 （1）什么时候实例化？ 对于单例的形式，在容器实例化的时候对bean进行实例化的。 ApplicationContext ctx=new ClassPathXmlApplicationContext(new String[]{\"applicationContext.xml\"}); 单实例可以通过lazy-init=”true”，在getBean时进行实例化。 在beans里面default-lazy-init=”true”对所有bean进行延迟处理。 对于prototype，则是在getBean的时候被实例化的。 （2）在bean被实例化之后执行资源操作等方法： Init-method=”” （3）在bean销毁之前执行的方法： Destroy-method=”” 什么时候被销毁？随着spring容器被关闭时被销毁。 调用spring容器的close方法来正常关闭。以前是随着应用程序执行完而关闭。 在Spring装载配置文件后，Spring工厂实例化完成，开始处理 （1）使用默认构造方法或指定构造参数进行Bean实例化。 （2）根据property标签的配置调用Bean实例中的相关set方法完成属性的赋值。 （3）如果Bean实现了BeanNameAware接口，则调用setBeanName()方法传入当前Bean的ID。 （4）如果Bean实现了BeanFactoryAware接口，则调用setBeanFactory()方法传入当前工厂实例的引用。 （5）如果Bean实现了ApplicationContextAware接口，则调用setApplicationContext()方法传入当前ApplicationContext实例的引用。 （6）如果有BeanPostProcessor与当前Bean关联，则与之关联的对象的postProcess- BeforeInitialzation()方法将被调用。 （7）如果在配置文件中配置Bean时设置了init-method属性，则调用该属性指定的初始化方法。 （8）如果有BeanPostProcessor与当前Bean关联，则与之关联的对象的postProcess- AfterInitialzation()方法将被调用。 （9）Bean实例化完成，处于待用状态，可以被正常使用了。 （10）当Spring容器关闭时，如果Bean实现了DisposableBean接口，则destroy()方法将被调用。 （11）如果在配置文件中配置Bean时设置了destroy-method属性，则调用该属性指定的方法进行销毁前的一些处理。 （12）Bean实例被正常销毁。","title":"Spring三种实例化Bean的方法"},{"content":"        也许我们并没有一起学习编程，但是我们一起学习过设计模式，拥有最多模式的行为型设计模式，让我有种错觉，不是模式为问题而生，好像问题为模式而生，当初的Gof是怎样的机遇，总结设计模式呢？        行为型模式：行为型模式设计到算法和对象间的职责分配，不仅描述对象或类的模式，还描述它们之间的通信方式，刻划了运行时难以跟踪的复杂的控制流，它们将你的注意力从控制流转移到对象间的关系上来。行为型类模式采用继承机制在类间分派行为，例如Template Method 和Interpreter；行为对象模式使用对象复合而不是继承。一些行为对象模式描述了一组相互对等的对象如何相互协作以完成其中任何一个对象都单独无法完成的任务，如Mediator、Chain of Responsibility、Strategy；其它的行为对象模式常将行为封装封装在一个对象中，并将请求指派给它。             网上的解释总是让人很挠头，我自己的理解是行为就是说几个对象的行为该怎么配合，怎么设计，从骨架，到血肉，到创建，行为就是运动，控制流说的就是这个吧，行为型模式不仅仅描述控制流，还阐述他们之间的关系，行为型模式帮助我们更好地控制几个类的运行表现！         老样子具体的例子书上很多，咱们杂这里稍稍说点不同的东西。   我们该怎么应用设计模式呢？ 个人想象的步骤：   1，要有“坏味道”的代码，分析其不足。 2，预选几个模式进行纠正。 3，对比找出最佳方案。 4，总结这类问题的模式选择 5，逐步完善和改进   例子： interface Ifactory    {        IUser CreatUser();        IDepartment CreatDepartment();      //创建sql的工厂    class SqlserverFactory : Ifactory    {        public IUser CreatUser()        {            return new Sqlseruser();        }        public IDepartment CreatDepartment()        {             return new SqlserDepartment() ;        }    }    创建access的工厂    class AccessFactory : Ifactory    {        public IUser CreatUser()        {            return new Accessuser ();        }    \tpublic IDepartment CreatDepartment()        {            return new AccessDepartment ();        }    } 客户端知道的类太多了   优化：       class DateAccess    {        private static readonly string db = \"Sqlserver\";        //private static readonly string db = \"Access\";        public static IUser CreatUser()        {            IUser result = null;            switch (db)            {                 case \"Sqlserver\":                    result = new Sqlseruser();                    break;                case \"Access\":                    result = new AccessUser();                    break;            }            return result;        }            public static IDepartment  CreatDepartment()        {            IDepartment  result = null;            switch (db)            {                case \"Sqlserver\":                    result = new SqlserDepartment ();                    break;                case \"Access\":                    result = new AccessDepartment ();                    break;            }            return result;        }     有选择，用反射及配置文件优化：   //反射优化抽象工厂    //根据配置文件选择创建查询方式    class DateAccess    {        private static readonly string AssemblyName = \"shujuku\";        //利用配置文件:1,添加引用system.configuration ; 2, using system.configuration         //读取配置文件app.config里的DB        private static readonly string db = ConfigurationManager.AppSettings[\"DB\"];        //private static readonly string db = \"Sqlserver\";        //静态函数创建用户表        public static IUser CreateUser()        {            string classname = AssemblyName + \".\" + db + \"User\";            return (IUser)Assembly.Load(AssemblyName).CreateInstance(classname);        }        //静态函数创建表        public static IDepartment  CreateDepartment()        {            string classname = AssemblyName + \".\" + db + \"Department\";            return (IDepartment )Assembly.Load(AssemblyName).CreateInstance(classname);        }    }          设计模式，是为了解决问题，但是肯定不是所有的问题都可以用他们解决，所以在现实中，设计模式提供了一种解决方案，编程的时候要有针对性，要面向现实，不能面向设计模式编程！         编程之路其修远兮，吾将上下而求索！    ","title":"[置顶] 设计模式初探（四）——行为：问题为设计而生"},{"content":"<!-- 批量提交上限 ,事务以20条记录为限--> <prop key=\"hibernate.jdbc.batch_size\">20<\/prop> <bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\" destroy-method=\"close\"> <!-- 以下配置都是使用 jdbc.properties 属性文件中的配置，而之所以可以这样写，就是因为有 属性占位符配置的原因 --> <property name=\"driverClass\" value=\"${jdbc.driverClassName}\"/> <property name=\"jdbcUrl\" value=\"${jdbc.url}\"/> <property name=\"user\" value=\"${jdbc.username}\"/> <property name=\"password\" value=\"${jdbc.password}\"/> <!-- 连接池维持的最小的连接个数 --> <property name=\"minPoolSize\" value=\"5\"/> <!-- 连接池维持的最大的连接个数 --> <property name=\"maxPoolSize\" value=\"20\"/> <!-- 最大空闲时间, 当某个连接在这个时间内没活动后将从池中移除，前提是池中至少多于最少的连接数: minPoolSize --> <property name=\"maxIdleTime\" value=\"1800\"/> <!-- 为加强准备语句的执行性能，此参数指定被缓存的 PreparedStatement 的个数 --> <property name=\"maxStatements\" value=\"50\"/> <\/bean> Hibernate 会话厂 SessionFactory Session 就是用于每次与数据库会话的，因此需要： 数据库的配置参数，这些参数就是 上面的数据源指定的! 因此我们只需引用即可： ref=\"dataSource\"； 实体映射配置 hibernate.cfg.xml 配置 结果缓存配置(这里使用的是开源的 ehcache) <!-- Hibernate SessionFactory --> <bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate3.LocalSessionFactoryBean\"> <!-- 引用前面定义的数据源 --> <property name=\"dataSource\" ref=\"dataSource\"/> <!-- 所有实体映射文件列表, 所有的 hbm.xml 文件 --> <property name=\"mappingResources\"> <list> <value>org/springframework/samples/jpetstore/domain/Account.hbm.xml<\/value> <value>org/springframework/samples/jpetstore/domain/Banner.hbm.xml<\/value> <value>org/springframework/samples/jpetstore/domain/Category.hbm.xml<\/value> <value>org/springframework/samples/jpetstore/domain/Inventory.hbm.xml<\/value> <value>org/springframework/samples/jpetstore/domain/Item.hbm.xml<\/value> <value>org/springframework/samples/jpetstore/domain/LineItem.hbm.xml<\/value> <value>org/springframework/samples/jpetstore/domain/Order.hbm.xml<\/value> <value>org/springframework/samples/jpetstore/domain/Product.hbm.xml<\/value> <value>org/springframework/samples/jpetstore/domain/Supplier.hbm.xml<\/value> <\/list> <\/property> <!-- 传统上的 hibernate.cfg.xml 文件的参数放在这里 --> <property name=\"hibernateProperties\"> <props> <!-- 指定数据库方言 --> <prop key=\"hibernate.dialect\">${hibernate.dialect} <\/prop> <!-- 是否在日志中输出所有Hibernate与数据库交互的SQL语句 --> <prop key=\"hibernate.show_sql\">true<\/prop> <!-- 是否在日志中输出的SQL 语句格式化成易读形式 --> <prop key=\"hibernate.format_sql\">true<\/prop> <!-- 是否显示统计形式，一般在测试阶段使用 --> <prop key=\"hibernate.generate_statistics\">true<\/prop> <!-- 对于级联查询，一次性获取的级联深度， @todo 需进一步研究 --> <prop key=\"hibernate.max_fetch_depth\">2<\/prop> <!-- Fetch Size 是设定JDBC的Statement读取数据的时候每次从数据库中取出的记录条数，一般设置为30、50、100。 Oracle数据库的JDBC驱动默认的Fetch Size=15，设置Fetch Size设置为：30、50，性能会有明显提升，如果继续增大， 超出100，性能提升不明显，反而会消耗内存。 --> <prop key=\"hibernate.jdbc.fatch_size\">100<\/prop> <!-- 不必等到累计到50个SQL之后才执行.只要事务commit后,不管缓存中有多少条sql语句都要执行. hibernate.jdbc.batch_size参数只是设定一次最多可以提交多少sql语句的上限,提高sql语句的执行效率 --> <prop key=\"hibernate.jdbc.batch_size\">50<\/prop> <!-- (1)create 在每次SesstionFactory 构建时(一般是应用重启时，或者伴随着应用服务器重启时)，先将之前数据库中的所有数据全 部清空，后紧跟着根据所有的hbm.xml 映射文件重新创建新的数据库表 (2)create-drop 除了create 的所有含义之外，在每次应用的退出前，将进行一次数据空清空。因此这个配置将有两次清空操作， 一次是退出，一次是启动时。 (3)update 如果在开发阶段理发了实体对象的映射文件(hbm.xml) 的定义后，此配置将后台的数据库表进行更新(如增加表的列) (4)validate 用于校验现有的表与现有的配置是否一致。 --> <prop key=\"hibernate.hbm2ddl.auto\">update<\/prop> <!-- 见下面的解释 --> <prop key=\"hibernate.hbm2ddl.auto\">update<\/prop> <!--结果缓存配置：- 将ehcache.xml 置于 classpath 中- 如果不设置“查询缓存”， 那么hibernate只会缓存使用load()方法获得的单个持久化对象，如果想缓存使用findall()、 list()、 Iterator()、createCriteria()、createQuery()等方法获得的数据结果集的话，就需要设置 hibernate.cache.use_query_cache true 才行- 在Hbm文件中添加<cache usage=\"read-only\"/>- 如果需要“查询缓存”，还需要在使用Query或Criteria()时设置其setCacheable(true);属性--> <prop key=\"hibernate.cache.use_query_cache\">true<\/prop> <prop key=\"hibernate.cache.provider_class\">org.hibernate.cache.EhCacheProvider<\/prop> <\/props> <\/property> <!-- 为解决 merge()方法语义的歧义 @todo 以后进一步解析或者你可以看一下相应的文档 --> <property name=\"eventListeners\"> <map><entry key=\"merge\"> <bean class=\"org.springframework.orm.hibernate3.support.IdTransferringMergeEventListener\"/> <\/entry><\/map> <\/property> <\/bean>","title":"hibernate属性详解"},{"content":"何为交互(图)?           当我看到这个词的时候,第一个在我脑海里浮现的问题是\"什么是交互?\".在我看了交互这个词的百度解释后,理解   如下.交互类似于我们家里的驴拉磨,好好的磨在那里是不会动的.只有驴做出了拉磨这个动作后.这个\"驴拉磨\"过程才能   够完全的实现.这样一个过程就称之为交互.一般在计算机世界里出现的较多.        说完了交互,我们来说说交互图.交互图是对一个用例事件流程进行建模,在某些时候可以单独使用.显示的是一个交 互,一组对象和它们之间的关系构成.其中有这样一些内容:需要什么对象、在这些对象之间相互发送的消息又是怎样 的、哪一个角色来开始这个消息的和消息在这个过程中是如何来发送的。 分类       交互图分为顺序图(序列图)与协作图   顺序图      描述消息事件顺序.显示对个对象之间的动作.   内容   1）对象          类的实例，具有特定的属性和操作。在交互图中，属性展示了对象的信息和状态，操作展示了对象的行为和   功能。    2）生命线                                  如图对象下面那条虚线即为该对象的生命线.表示该对象的生命周期,即存在的时间.                           “X”标记表明生命的结束.                                             虚线上的窄条表示该对象正在执行的操作,长度即表示该操作的时间.  3）消息          表示一个对象到另一个对象的信息传递或者多个对象的信息传递.即对象之间、参与者之间、对象与参与者 之间的通信方式。可以是信息的传递,也可以是协作调用.分为两种,可以使发送者向接受者发送消息,也可以使调用者 向被调用者调用协作. 表示方法 用消息线（消息图标）表示。一个对象到另一个对象的消息用跨越对象生命线的一条消息线表示出来，包 括反身消息。 如图三种表示消息的方法 –消息线本身 –消息线加消息编号 –消息线加消息编号加消息名  示例 协作图       强调对象和接受者之间的动态结构关系.   构成          对象                         消息                    链        链是关联的实例，当一个类与另一个类之间有关联时，这两个类的实例之间就有链，一个对象就能向另一个对象 发送消息。所以链是对象间的发送消息的路径。 示例 利用Rational rose 顺序图与协作图之间的转换              顺序图转换为协作图                1、从sequence框图创建collaboration框图：                2、打开sequence框图；                3、选择Browse> Create collaboration Diagram；或者，直接按下F5键；       从协作图转换成顺序图               1、从collaboration框图创建sequence框图：               2、打开collaboration框图；               3、选择Browse> Create Sequence Diagram；或者，直接按下F5键；","title":"浅谈UML之交互图"},{"content":"说到包图，我们先来了解一下包 1.什么是包？          包可直接理解为命名空间，文件夹，是用来组织图形的封装 2.包的作用？ 逻辑上把一个复杂的图模块化 组织源代码 3.什么时候会用到包？        在面向对象软件开发的视角中，类显然是构建整个系统的基本构造块。但是对于庞大的应用系统而言，其包含的类将是成百上千，再加上其间存在着的关联关系、多重性等，必然是大大超出了人们可以处理的复杂度。这也就是引入了“包”这种分组事物构造块。 4.包的命名        每个包都必须有一个与其它包相区别的名称 5.包的符号                  6.包中的元素        在包中可以拥有各种其它元素，包括类、接口、构件、节点、协作、用例，甚至是其它包或图        注意：若包被撤销，则其中的元素也会随之被撤销了 7.包的可见性 用“+”来表示“public”，对所有包是可视的 用“#”来表示“protected”，只能对该包的子包是可视的  用“-”来表示“private”，对外包是不可视的 8.包图绘制原则   最小化包之间的依赖，最小化每个包中的public、protected元素的个数，最大化每个包中private元素个数 在建模时应该避免包之间的循环依赖，也就是不能够包含相互依赖的情况，对于这种情况应进行分析： 测试时应以包为测试单位 尽量把概念和含以上相近的元素包含在一个包中 9.包与包之间的关系 依赖：是指一个元素的定义的改变会引起另一个元素发生相应的改变，包的依赖联系同样用一条虚线表示，虚线箭头从依赖包指向被依赖包         注意：标有{global}的包叫通用包，表示系统的所有其他包都依赖于该包 泛化：表达事物的一般和特殊的关系。如果两个包之间有泛化联系，意指其中的特殊性包必须遵循一般性包的接口。{abstract}表明它定义了一个接口 10.UML包图使用说明 对成组元素建模 每个包都应该是在概念、语义上相互接近的元素组成； 对每个包找出应标记为公共的元素，但应尽可能地少； 一般使用默认的《use》构造型，在映射到编程时考虑明确《import》构造型； 考虑采用泛化来对特殊包进行建模。 在表示这种模型时，注意只标明对每个包都起核心作用的元素；另外也可以标识每个包的文档标记值，以使其更加清晰 对体系结构建模        对体系结构进行建模（程序分层），是UML包图更有意义的一个用途。体系结构是一个软件系统的核心逻辑结构       常用的体系结构模式包括分层、MVC、管道、黑板、微内核等，而在应用软件中，分层和MVC        包图是保持系统构架简明清晰的工具。可以这么说，如果不能将整个系统的类图压缩到一张A4纸上，就应该使用包图。","title":"UML—包图"},{"content":"Asterisk社区还真够活跃，刚刚在Asterisk 增加了 webrtc, ICE等新技术的支持，这不，又要在Asterik 12中替换其原有的SIP 协议栈，对Asterisk 内部了解的人都知道，其现有SIP协议栈有诸多弊端，导致其已经很难维护，以下是其现有SIP协议栈的缺点： 1. 整个SIP协议的实现代码不是一个以协议栈方式组织的，全部代码在一个文件 chan_sip.c中，没有SIP协议分层的概念，导致添加一个传输层的支持 要在整个源码里面各种找。 2. 改一个bug往往导致新的bug出现，原因是其代码抽象很差，一个标志位可能用在多个地方来标识某个特性，稍有疏忽，就会导致一个新的BUG。 终于 asterisk向第三方SIP协议栈招手，在流行的SIP协议栈 pjsip, reprocate, sofia-sip中选择了 pjsip. asterisk-scf也是用的这个协议栈，但遗憾的是asterisk-scf项目 中途夭折了。。 采用新SIP协议栈将实现如下功能： Transports (all IPv4 and IPv6) UDP TCP TLS Websocket Digest authentication Media sessions Basic phone calls Call transfer Audio/video capability negotiation (to include T.38 negotiation) Direct media Session timers Party Identity Registration Registrar for incoming registrations Client registration (i.e. outgoing registration) Subscriptions Presence Dialog-info Message-summary Call-completion Messaging Out-of-call messaging  ","title":"asterisk 终于要替换SIP协议栈了"},{"content":"软件项目管理系统-项目管理-模块定义-开发内容","title":"软件项目管理系统-项目管理-模块定义-开发内容"},{"content":"0.序      本文章不是单单讲述Nginx 在nginx.c中main函数中的函数，而是将其进一步延伸，一直到达Nginx的Master进程等待外部信号，Worker进程等待Http请求。我尽可能全面的讲述，但是其中肯定有很多细节不能讲到，但我依旧会将更多的参考文章列出。      这篇文章，我参考和学习了诸多Nginx大牛们的博客。之后也会在参考文章中列出。      1.Nginx整个流程分析     1）Main函数的初始化：详见文章nginx启动之main函数     2）Nginx中与信号处理相关的部分:详见文章     3）Master进程初始化分析：ngx_master_process_cycle 。在ngx_master_process_cycle中nginx在sigsuspend函数中等待信号的到来。 详见文章1：Nginx进程管理之 ngx_master_process_cycle分析     4）Worker进程初始化分析：ngx_worker_process_cycle 详见Nginx源码分析-事件循环修改版。worker进程在经历ngx_worker_process_init后，进入ngx_process_events_and_timers函数进行处理，该函数是worker子进程处理的核心，也是事件处理的核心。 整个总的流程如下所示： 从上面的启动流程总分析图中，我们可以看到 在ngx_master_process_cycle中在无限for循环中通过sigsuspend等待信号。关于sigsuspend对于信号的处理，详见文章xxx 在ngx_worker_process_cycle中在ngx_process_events_and_timers函数实际上是ngx_epoll_process_event函数中通过epoll_wait等待Http请求的到来。 也就是在启动过程全部进行完毕以后，Nginx进入了如下的情况。","title":"文章1：Nginx启动过程分析"},{"content":"本文主要是nginx启动过程中关于main函数部分的初始化。 1）ngx_get_options：获得运行时的一些选项。   -g ngx_conf_params                                                运行命令 执行完ngx_get_options后，全局变量 ./nginx -c /usr/local/nginx/conf/nginx.conf u_char* ngx_conf_file = \" /usr/local/nginx/conf/nginx.conf\" $./nginx -s stop   u_char * ngx_signal = \"stop\" $./nginx -s reload   u_char * ngx_signal = \"reload\"  $./nginx -t -c /usr/local/nginx/conf/nginx.conf   $./nginx -h    ngx_show_version = 1   ngx_show_help = 1; $./nginx -V ngx_show_version = 1; ngx_show_configure = 1; $./nginx -p /usr/local/nginx ngx_prefix = /usr/local/nginx 。 ngx_prefix指定Nginx工作目录。其error.log及nginx.conf都会在该目录下被找到。 ngx_prefix会在多处使用：1）ngx_log_init中2）在ngx_process_options中会其ngx_prefix的取值赋值给ngx_cycle的conf_prefix和prefix成员变量。 2）ngx_process_options： 用来将ngx_get_options中获得这些参数取值赋值到ngx_cycle中。包括：ngx_cycle中的conf_prefix,prefix,conf_file,conf_param,log->log_level等。 3)全局变量 volatile ngx_cycle_t * ngx_cycle处理。            ngx_cycle = &init_cycle; 4）ngx_save_argv将argc 和*argv[]的信息保存到ngx_argv和ngx_argc中，其中argv数组的每个元素会对应的保存到ngx_argv数组中。这算是一个备份存储，方便以后master进程做热代码替换之用。 $./nginx -p /usr/local/nginx 则ngx_argv数组保存argv中信息，ngx_argc保存argc信息。则ngx_argc = 3   ngx_argv[0] = /usr/local/nginx/sbin/nginx  ngx_argv[1]=-p ngx_argv[2]=/usr/local/nginx 5)ngx_os_init进行系统的一些初始化工作。      获得ngx_pagesize，ngx_ncpu，ngx_max_sockets，ngx_inherited_nonblocking等信息。 6）ngx_add_inherited_sockets。 将继承的套接字添加到ngx_cycle的listening array中。但是啥是继承套接字啊 不知道了~~参考文章nginx源码分析—处理继承的sockets and 运行和控制 Nginx - 命令行参数和信号 继承套接字用于程序的热启动。 7）这个for循环非常重要， 因为它确定了每个module在ngx_module数组中的位置。ngx_module_t中index指示这个module在ngx_module数组中的位置。nginx在编译的时候会生成一个目录objs,该目录下有一个文件ngx_modules.c，该文件中 有ngx_module[]数组。比如ngx_core_module的index为0.  ngx_max_module = 0;     for (i = 0; ngx_modules[i]; i++) {         ngx_modules[i]->index = ngx_max_module++;     } 8）ngx_init_cycle(&init_cycle); 这是初始化过程中非常重要的一个初始化函数。  cycle = ngx_init_cycle(&init_cycle);  ngx_cycle = cycle; ngx_init_cycle主要做了以下工作，利用old_cycle创建一个新的new_cycle。 1）将old_cycle中成员变量赋值给new_cycle的成员变量 2）为new_cycle中的一些成员变量分配空间 3）依次调用NGX_CORE_MODULE模块的create_conf钩子函数， 4）调用ngx_conf_param和ngx_conf_parse函数解析，将配置文件nginx.conf中关于CORE模块的指令存入相应的变量中。 5）打开cycle_open_files中文件 6）创建共享内存区 7）操作监听套接字。非常关键的一步。 8）调用每个模块的init_module钩子函数 9）关闭和删除old_cycle中的一些成员。 主要就是做了这么几件事情：（1）CORE模块配置的文件的解析，将其存入程序的相应变量中（2）创建共享内存区 （3）监听套接字的处理 （4）调用每个模块的init_module函数 9）ngx_signal_process  主要是处理来自于$./nginx -s xxx的参数。详见文章2：Nginx与信号相关的内容 首先：从存放pid的文件中读取pid 然后关闭文件 其次：进入ngx_os_signal_process           遍历signal数组，找到匹配的信号并通过kill 将信号传递给进程，让进程根据信号做相应处理。kill并不是杀死的意思，kill是传递信号的意思。 if (ngx_signal) {         return ngx_signal_process(cycle, ngx_signal);     } 10）ngx_init_signal函数 通过sigaction函数设置signal数组中与指定信号相关联的处理动作。这儿详见文章2：nginx中与信号相关的内容 11)ngx_daemon函数      对于没有继承套接字并且配置文件中daemon on;时，调用ngx_daemon，创建守护进程。这儿是创建守护进程的标准做法。在APUE中有说明。 12）ngx_create_pidfile函数  13）ngx_process 的获取在main函数中 if (ccf->master && ngx_process == NGX_PROCESS_SINGLE) {         ngx_process = NGX_PROCESS_MASTER;     } 最后根据ngx_process是单进程还是多进程，分别调用不同的cycle if (ngx_process == NGX_PROCESS_SINGLE) {         ngx_single_process_cycle(cycle);     } else {         ngx_master_process_cycle(cycle);     }            参考文章 http://www.alidata.org/archives/1092            http://www.alidata.org/archives/1148                 http://blog.csdn.net/livelylittlefish/article/details/7243718            http://blog.csdn.net/livelylittlefish/article/details/7247080 ","title":"文章2：nginx启动过程之main函数"},{"content":"0.序 一概述： 二、启动时， 三、信号初始化 四、启动后的操作 五、几个小问题 0.序      要想学好Nginx中与信号有关的内容，就必须对Linux下信号相当熟悉。因此，在学习Nginx这部分的时候最好重温一下APUE chapter 10 信号。 一概述：      Nginx中使用信号来控制Nginx停止、平滑重启，Nginx支持以下几种信号：      1）TERM，INT快速关闭                             SIGINT SIGTERM 即：NGX_TERMINATE_SIGNAL and SIGINT      2）QUIT 从容关闭                                      SIGQUIT 即 NGX_SHUTDOWN_SIGNAL      3）HUP 平滑重启，重新加载配置文件           SIGHUP 即NGX_RECONFIGURE_SIGNAL      4）USR1 重新打开日志文件，在切割日志时用途较大 SIGUSR1 即NGX_REOPEN_SIGNAL      5）USR2 平滑升级可执行程序                                 SIGUSR2 即NGX_CHANGEBIN_SIGNAL      6）WINCH 从容关闭工作进程                                             即NGX_NOACCEPT_SIGNAL 二、启动时， 1.启动时，如果为./nginx -s xxxx则ngx_signal就会获得取值   全局变量ngx_signal获得取值在ngx_get_options函数中获得  if (ngx_signal) {         return ngx_signal_process(cycle, ngx_signal);     } ngx_signal_process： 首先：从存放pid的文件中读取pid 然后关闭文件 其次：进入ngx_os_signal_process           遍历signal数组，找到匹配的信号并通过kill 杀死进程 三、信号初始化      ngx_init_signals 函数的主要作用：通过sigaction函数设置signal数组中与指定信号相关联的处理动作。 signals数组如下所示：只是列举了一部分 ngx_signal_t  signals[] = {     { ngx_signal_value(NGX_RECONFIGURE_SIGNAL),       \"SIG\" ngx_value(NGX_RECONFIGURE_SIGNAL),       \"reload\",       ngx_signal_handler }, ............................     { 0, NULL, \"\", NULL } }; 关于这部分内容详见1）nginx源码分析—信号初始化                               2）参见APUE p261 10.14 sigaction函数 ngx_int_t ngx_init_signals(ngx_log_t *log) {     ngx_signal_t      *sig;     struct sigaction   sa;     for (sig = signals; sig->signo != 0; sig++) {         ngx_memzero(&sa, sizeof(struct sigaction));         sa.sa_handler = sig->handler;         sigemptyset(&sa.sa_mask);         if (sigaction(sig->signo, &sa, NULL) == -1) { /*设定每个SIGXXX的信号处理程序*/             ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,                           \"sigaction(%s) failed\", sig->signame);             return NGX_ERROR;         }     }     return NGX_OK; } 四、启动后的操作 .启动以后，如果要停止或者平滑重启，命令为$./nginx -s stop / reload     在master进程中的cycle函数ngx_master_process_cycle中 关于这部分内容 要参考APUE p256 10.11 信号集 1）设置信号集set  2) 通过sigsuspend函数等待信号到来，当收到./nginx -s stop 命令时，sigsuspend就会被触发。  sigsuspend(&set); 3）之后向子进程发出相关信号。这部分内容就是master进程与worker进程的通信。 将ngx_master_process_cycle中内容提炼处理  sigemptyset(&set);/*信号集清空，必须操作*/ /*向信号集中添加要阻塞的信号*/  sigaddset(&set, SIGCHLD);     sigaddset(&set, SIGALRM);     sigaddset(&set, SIGIO);     sigaddset(&set, SIGINT);     sigaddset(&set, ngx_signal_value(NGX_RECONFIGURE_SIGNAL));     sigaddset(&set, ngx_signal_value(NGX_REOPEN_SIGNAL));     sigaddset(&set, ngx_signal_value(NGX_NOACCEPT_SIGNAL));     sigaddset(&set, ngx_signal_value(NGX_TERMINATE_SIGNAL));     sigaddset(&set, ngx_signal_value(NGX_SHUTDOWN_SIGNAL));     sigaddset(&set, ngx_signal_value(NGX_CHANGEBIN_SIGNAL)); /*将信号集中的信号添加到信号屏蔽字中*/ sigprocmask(SIG_BLOCK, &set, NULL); /*清空信号集，供sigsuspend使用*/ sigemptyset(&set);  sigsuspend(&set);/*等到信号到来。当有信号到来时，解除信号的阻塞，进程暂停 在进程暂停过程中会执行信号处理函数，在signals数组中有设置。比如reload其处理函数为ngx_signal_handler 。当执行完信号处理函数ngx_signal_handler后，进程继续运行，继续执行sigsuspend下面的代码*/ 接下来master进程将“陷入”死循环中守护着worker进程，担当起伟大的幕后工作。 在master cycle中调用了sigsuspend()，因而将master进程挂起，等待信号的产生 主要过程就是：这些都是标准的信号处理的过程。 【收到信号】， 【调用信号处理函数（在初始化过程中注册了）】， 【设置对应的全局变量】， 【sigsuspend函数返回，判断各个全局变量的值并采取相应的动作】 五、几个小问题:来自于文章 nginx源码分析—信号初始化 5.1ngx_signal_value宏是如何得到整数的信号值signo的？  举个例子，NGX_RECONFIGURE_SIGNAL=HUP，因此ngx_signal_value(NGX_RECONFIGURE_SIGNAL)=SIGHUP。 从上述signals数组可以看出，SIGHUP的signo=1，name为\"reload\"。那么，这个1是在哪里定义的？ ——这很容易能想到kernel源代码。果期不然，在#include <signal.h> #define SIGHUP          1 #define SIGINT          2 #define SIGQUIT          3 #define SIGILL          4 #define SIGTRAP          5 #define SIGABRT          6 #define SIGIOT          6 #define SIGBUS          7 #define SIGFPE          8 ......................... 参考文章： http://blog.csdn.net/livelylittlefish/article/details/7308100 ","title":"文章3:Nginx中与信号有关的内容"},{"content":"文章内容 0.序 1.概述： 2.几个变量的作用 3.ngx_process_events_and_timers结构图 4.ngx_process_events_and_timers函数详解 5.分析Nginx对accept事件的处理 6.小结  0.序：  本文学习了阿里巴巴大牛们Nginx源码分析-事件循环的文章，并对于里面内容进行了更为详尽的分析。并且参考了众多网上文章http://bollaxu.iteye.com/blog/855457 1.概述：        事件循环这个概念貌似在windows编程中提得更多，Linux程序却很少提及这个概念。本文所提及的事件循环其实就是worker cycle，由于此处将关注的不再是worker进程，而是worker进程在循环过程中关于事件处理的环节，因此就盗用了事件循环这个概念。在具体看代码前，先看一下这个“循环”的概貌：      根据文章1总体概述，我们可以看到ngx_process_events_and_timers函数之前，进行了很多初始化操作。接下来只是分析事件驱动的核心ngx_process_events_and_timers函数，当然这也是worker进程的核心。 2.几个变量的作用 首先说明几个变量的作用      1）ngx_accept_mutex_held：表示进程当前是否持有锁      2）ngx_accept_mutex_delay：当获得锁失败后，再次去请求锁的间隔时间，这个时间在配置文件中设置      3）NGX_POST_EVENTS标记：设置了这个标记就说明当socket有数据被唤醒时，不会马上accept或者读取，而是将这个事件保存起来，然后当我们释放锁以后，才会进行accept或者读取这个句柄。      4）ngx_posted_accept_events:ngx_event_t数组，暂存epoll从监听套接口wait到的accept事件。该数组不为空，就表示有accept事件发生。      5）ngx_posted_events：ngx_event_t数组，暂存进程中非accept事件。      6）ngx_use_accept_mutex：代表是否使用accept互斥体。默认是使用，accept_mutex off;指令关闭。 accept mutex的作用就是避免惊群，同时实现负载均衡。在配置文件中可以配置。      7）ngx_accept_disabled ：用于实现进程关于连接的基本负载均衡。ngx_accept_disabled变量在ngx_event_accept函数中计算。 如果ngx_accept_disabled大于了0，就表示该进程接受的 连接过多，因此就放弃一次争抢accept mutex的机会，同时将 自己减1。然后，继续处理已有连接上的事件。Nginx就借用 此变量实现了进程关于连接的基本负载均衡。      8）ngx_shmtx_t中成员变量fd：进程间共享的文件句柄。通过这个fd来控制进程的互斥。这部分内容在nginx中锁的设计以及惊群的处理有详细说明。      9）dalta：对epoll wait事件的耗时统计，存在毫秒级的耗时就对所有事件的timer进行检查；如果time out就从timer rbtree中删除到期的timer，同时调用相应事件的handler函数完成处理。 3.ngx_process_events_and_timers结构图 4.ngx_process_events_and_timers函数详解 void ngx_process_events_and_timers( ngx_cycle_t *cycle) {     ngx_uint_t  flags;     ngx_msec_t  timer, delta;     if (ngx_timer_resolution) {         timer = NGX_TIMER_INFINITE;         flags = 0;     } else {         timer = ngx_event_find_timer();         flags = NGX_UPDATE_TIME; #if (NGX_THREADS)         if (timer == NGX_TIMER_INFINITE || timer > 500) {             timer = 500;         } #endif     }     if (ngx_use_accept_mutex) {  /*默认使用accept mutex*/         if (ngx_accept_disabled > 0) {/*用于进程中连接的基本负载均衡*/             ngx_accept_disabled--;         } else {             if (ngx_trylock_accept_mutex(cycle) == NGX_ERROR) {/*尝试去获取锁，这部分内容在文章9Nginx中accept互斥锁中有详细讲述*/                 return;             }             if (ngx_accept_mutex_held) { /*ngx_accept_mutex_held=1，表示当前进程持有锁，那么所有接收到的accept事件都不会马上处理，而是被保存到ngx_posted_accept_events数组中*/                 flags |= NGX_POST_EVENTS;             } else { /*ngx_accept_mutex_held=0，表示当前进程没有持有锁，那么就设置等待时间，之后继续去抢锁。*/                 if (timer == NGX_TIMER_INFINITE                     || timer > ngx_accept_mutex_delay)                 {                     timer = ngx_accept_mutex_delay;                 }             }         }     }     delta = ngx_current_msec; /*epoll开始wait事件了,ngx_process_events的具体实现是对应到 epoll模块中的ngx_epoll_process_events函数。单独分析epoll 模块的时候，再具体看看。 */     (void) ngx_process_events(cycle, timer, flags);     delta = ngx_current_msec - delta;     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle-> log, 0,                    \"timer delta: %M\", delta); /*ngx_posted_accept_events：有accept事件被暂存在ngx_posted_accept_events数组中，那么ngx_event_process_posted就处理该数组中的事件 ngx_event_process_posted处理流程：遍历整个数组，先从事件队列中删除事件，然后执行该事件的handler。 */     if (ngx_posted_accept_events) {         ngx_event_process_posted(cycle, &ngx_posted_accept_events);     } /*处理完所有accept事件后，如果拥有锁的话，就赶紧释放了，其他进程等着抢呢*/     if (ngx_accept_mutex_held) {         ngx_shmtx_unlock(&ngx_accept_mutex);     }     if (delta) { /*每次该函数都不断的从红黑树中取出时间值最小的，查看他们是否已经超时，然后执行他们的函数，直到取出的节点的时间没有超时为止*/         ngx_event_expire_timers();     }     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle-> log, 0,                    \"posted events %p\", ngx_posted_events); /*处理普通事件（连接上获得的读写事件）队列上的所有事件， 因为每个事件都有自己的handler方法，该怎么处理事件就 依赖于事件的具体handler了。 */     if (ngx_posted_events) {         if (ngx_threaded) {             ngx_wakeup_worker_thread(cycle);         } else {             ngx_event_process_posted(cycle, &ngx_posted_events);         }     } } /*为何是在ngx_event_process_posted之后才释放锁呢，*/ 这儿解释一下：非常感谢C/C++ 航天灰机的帮助 ngx_event_process_posted(cycle,&ngx_posted_accept_events)中调用ngx_event_accept函数调用ls->handler即ngx_http_init_connection  if (rev->ready) {        /* the deferred accept(), rtsig, aio, iocp */        if (ngx_use_accept_mutex) {            ngx_post_event(rev, &ngx_posted_events);/*这儿将所有的非accept事件都放入ngx_posted_events数组中，不继续往下执行，等待释放锁以后才继续执行*/            return;        }        ngx_http_init_request(rev);        return;    } ngx_process_events_and_timers一做完工作，就又回到了事件循环中去了，上图示；但会很快又会回到事件处理中来。 5.分析Nginx对accept事件的处理      在上面的讲述中，ngx_http_init_connection函数对于accept的事件会放入ngx_posted_events数组中。在ngx_process_events_and_timers函数中通过   ngx_event_process_posted(cycle, &ngx_posted_events);执行accept事件的处理函数。其处理函数时ngx_event_accept函数，位于src/event/ngx_event_accept.c。  代码分析如下： void ngx_event_accept( ngx_event_t *ev) {     socklen_t          socklen;     ngx_err_t          err;     ngx_log_t         *log;     ngx_uint_t         level;     ngx_socket_t       s;     ngx_event_t       *rev, *wev;     ngx_listening_t   *ls;     ngx_connection_t  *c, *lc;     ngx_event_conf_t  *ecf;     u_char             sa[NGX_SOCKADDRLEN]; .................................................................................     lc = ev ->data ;     ls = lc-> listening ;     ev ->ready = 0; .................................................................................      do {         socklen = NGX_SOCKADDRLEN;         s = accept(lc->fd, ( struct sockaddr *) sa, &socklen);    /*accept一个新的连接*/ ................................................................................. /*accept到一个新的连接后，就重新计算ngx_accept_disabled的值 ngx_accept_disabled已经提及过了，它主要用来做负载均衡之用。 这里，我们能够看到它的求值方式是“总连接数的八分之一，减去 剩余的连接数”。总连接数是指每个进程设定的最大连接数，这个数字 可以在配置文件中指定。由此处的计算方式，可以看出：每个进程accept 到总连接数的7/8后，ngx_accept_disabled就大于0了，连接也就 超载了。 */         ngx_accept_disabled = ngx_cycle-> connection_n / 8                               - ngx_cycle-> free_connection_n ;         c = ngx_get_connection(s, ev-> log); .................................................................................         c-> pool = ngx_create_pool(ls->pool_size , ev ->log );         if (c->pool == NULL) {             ngx_close_accepted_connection(c);             return ;         }         c-> sockaddr = ngx_palloc(c->pool , socklen);         if (c->sockaddr == NULL) {             ngx_close_accepted_connection(c);             return ;         }         ngx_memcpy(c-> sockaddr , sa, socklen);         log = ngx_palloc(c-> pool , sizeof ( ngx_log_t));         if (log == NULL) {             ngx_close_accepted_connection(c);             return ;         }         /* set a blocking mode for aio and non-blocking mode for others */         if (ngx_inherited_nonblocking) {             if (ngx_event_flags & NGX_USE_AIO_EVENT) {                 if (ngx_blocking(s) == -1) {                     ngx_log_error(NGX_LOG_ALERT, ev-> log, ngx_socket_errno,                                   ngx_blocking_n \" failed\" );                     ngx_close_accepted_connection(c);                     return ;                 }             }         } else {/*我们使用的epoll模型，在这里设置连接为nonblocking*/             if (!(ngx_event_flags & (NGX_USE_AIO_EVENT|NGX_USE_RTSIG_EVENT))) {                 if (ngx_nonblocking(s) == -1) {                     ngx_log_error(NGX_LOG_ALERT, ev-> log, ngx_socket_errno,                                   ngx_nonblocking_n \" failed\" );                     ngx_close_accepted_connection(c);                     return ;                 }             }         }         *log = ls-> log ; /*初始化新连接*/         c-> recv = ngx_recv;         c-> send = ngx_send;         c-> recv_chain = ngx_recv_chain;         c-> send_chain = ngx_send_chain;         c-> log = log;         c-> pool ->log = log;         c-> socklen = socklen;         c-> listening = ls;         c-> local_sockaddr = ls->sockaddr ;         c-> unexpected_eof = 1; /*这里的listen handler很重要，它将完成新连接的最后初始化工作 同时将accept到的新连接放入epoll中；挂在这个handler上的函数 就是ngx_http_init_connection(位于src/http/ngx_http_request.c中)； 这个函数放在分析http模块的时候再看吧。 */         ls-> handler (c);         if (ngx_event_flags & NGX_USE_KQUEUE_EVENT) {             ev-> available--;         }     } while ( ev-> available); } 6.小结  来自于http://bollaxu.iteye.com/blog/855457  对于下面红色的语句有些不理解 //Debug追踪 下面，以单进程和多进程处理一个http请求为例，分析一下事件处理的流程。我用nginx里面已有的ngx_log_debugX()来插入事件处理的主要函数ngx_epoll_process_events()和ngx_event_process_posted()。在编译的时候，需要加上\"--with-debug\"参数。并指定nginx.conf里面的\"error_log   logs/debug.log  debug_core | debug_event | debug_http;\"。重新启动nginx。 单进程(work_processes 1)： 1. 在初始化即ngx_worker_process_init()中调用两次ngx_epoll_add_event()。第一次是在ngx_event_process_init()里面，即给每个监听的端口(在我的例子里只监听80端口)添加一个NGX_READ_EVENT事件；第二次是ngx_add_channel_event()，即给进程间通行的socketpair添加NGX_READ_EVENT事件。 2. 不断调用ngx_epoll_process_events()函数，探测监听的事件是否发生。如果此时有一个http请求进来，就会触发epoll的事件。由于之前每个监听的端口已经设置handler是ngx_event_accept()，这样，就会在ngx_epoll_process_events()里面调用rev->handler(rev)，即调用ngx_event_accept()。在这个函数里，accept()被调用，即接收请求并为其分配一个新的连接，初始化这个新连接，并调用listening socket的handler，即ls->handler(c)。因为ls->handler在http_block()（读取配置之后）里面已经设置了(ls->handler = ngx_http_init_connection;)，那么就会调用ngx_http_init_connection()。而在这个函数里，又会添加一个读事件，并设置其处理钩子是ngx_http_init_request()。 3. epoll触发新的事件调用ngx_http_init_request()，并继续http请求处理的每一个环节。(如process request line，process headers，各个phase等) 4. 最后client关闭了连接(我用的是Linux下的curl)。调用了ngx_http_finalize_request() => ngx_http_finalize_connection() => ngx_http_set_keepalive()。ngx_http_set_keepalive()函数设置事件的处理函数是ngx_http_keepalive_handler()，并调用ngx_post_event()把它添加到ngx_posted_events队列里。然后ngx_event_process_posted()函数就会一一处理并删除队列里所有的事件。在ngx_http_keepalive_handler()函数里，调用ngx_http_close_connection() => ngx_close_connection() => ngx_del_conn(c,NGX_CLOSE_EVENT)。ngx_del_conn()即ngx_epoll_del_connection()，即把这个处理请求的connection从epoll监听的事件列表中删除。 多进程(我设置了work_processes 2)：和单进程不同，单进程设置epoll timer为-1，即没有事件就一直阻塞在那里，直到监听的端口收到请求。而多进程则不同，每个进程会设置一个epoll_wait()的timeout，去轮番尝试获取在监听端口接受请求的权利，如果没有事件就去处理其它的事件，如果获得了就阻塞(*直到有任意事件发生) 1. 在ngx_event_process_init()里面，只会调用ngx_add_channel_event()给进程间通信的socketpair添加事件，而不给http监听的端口添加事件(为了保证不会有多个工作进程来同时接受请求)。而每个进程被fork()之后，父进程(master process)都会调用ngx_pass_open_channel() => ngx_write_channel()  => sendmsg()来通知所有已经存在的进程(这会触发接收方的事件，调用ngx_channel_handler()函数) 2. 在ngx_process_events_and_timers()里，用一个锁来同步所有的进程ngx_trylock_accept_mutex()，并只有一个进程能够得到ngx_accept_mutex这个锁。得到这个锁的进程会调用ngx_enable_accept_events()添加一个监听端口的事件。 3. 在ngx_epoll_process_events()里，调用了ngx_locked_post_event()添加了一个读事件到accept queue(即ngx_posted_accept_events)，然后在ngx_event_process_posted()里面处理，即调用ngx_event_accept()，并添加一个读事件(后面和单进程是一样的)。在处理完ngx_posted_accept_events队列里面的所有accept事件之后，ngx_accept_mutex这个锁也会被释放，即把接受请求的权利让给其它的进程。 *在多进程的模式下，每当有新的子进程启动的时候，父进程(master process)都会向其余所有进程的socketpair channel广播新的子进程的channel。这样，就会导致之前获取监听端口权限(即ngx_accept_mutex)的进程触发epoll事件，从而释放ngx_accept_mutex，虽然这个是发生在初始化阶段(之后子进程间一般不通信)，一般不会产生两个或多个进程同时在epoll添加监听端口事件的情况。但是在理论上，这样的设计可能会导致系统的bug(比如有人通过给子进程发送信号的办法来实现一些特殊的功能时，就有可能让其中一个进程放弃ngx_accept_mutex，而另外某一个进程在之后先于它再次获取到ngx_accept_mutex)。","title":"文章5：Nginx源码分析--事件循环"},{"content":"pthread_once()函数详解 在多线程环境中，有些事仅需要执行一次。通常当初始化应用程序时，可以比较容易地将其放在main函数中。但当你写一个库时，就不能在main里面初始化了，你可以用静态初始化，但使用一次初始化（pthread_once）会比较容易些。 int pthread_once(pthread_once_t *once_control, void (*init_routine) (void))； 功能：本函数使用初值为PTHREAD_ONCE_INIT的once_control变量保证init_routine()函数在本进程执行序列中仅执行一次。 在多线程编程环境下，尽管pthread_once()调用会出现在多个线程中，init_routine()函数仅执行一次，究竟在哪个线程中执行是不定的，是由内核调度来决定。 Linux Threads使用互斥锁和条件变量保证由pthread_once()指定的函数执行且仅执行一次，而once_control表示是否执行过。 如果once_control的初值不是PTHREAD_ONCE_INIT（Linux Threads定义为0），pthread_once() 的行为就会不正常。 在LinuxThreads中，实际\"一次性函数\"的执行状态有三种：NEVER（0）、IN_PROGRESS（1）、DONE （2），如果once初值设为1，则由于所有pthread_once()都必须等待其中一个激发\"已执行一次\"信号，因此所有pthread_once ()都会陷入永久的等待中；如果设为2，则表示该函数已执行过一次，从而所有pthread_once()都会立即返回0。 　　","title":"pthread_once()函数详解"},{"content":"一、原型模式 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。   用实例来说话：我要发简历，自己写了一份模板，然后复制了N 份。如下： //模板：class Resume{Private string name;Public  Resume (string name){This.name=name;}}//客户端：Static void Main(string[] args){Resume a=new Resume(\"大鸟\");Resume b=new Resume(\"大鸟\");Resume b=new Resume(\"大鸟\");}   如果现在我想改，那就得把N份全改了，本来只是改动一点，却需要很长时间，没效率，真是费力不讨好的工作。   原型模式可以改变这种低级费力的工作。   原型模式其实就是从一个对象在创建灵位一个可定制的对象，而且不需知道任何创建的细节。在原型模式通过克隆Clone来实现对象之间的这种定制。 区别：以前的复制是每个对象都去实例化类，现在的克隆，是只实例化一个对象，然后通过这个对象传递给其他对象。 具体如下： class Resume{Private string name;Public  Resume (string name){This.name=name;}//模板中增加克隆方法Public object Clone(){Return (Object)this.MemberwiseClone();}}  Static void Main(string[] args){Resume a=new Resume(\"大鸟\");Resume b=（Resume）a.clone();Resume c=（Resume）a.clone();}   Clone方法时将当前对象的非静态字段复制到该新对象，如果字段是值类型，则对该字段执行逐位复制。如果字段是引用类型，则复制引用但不复制引用的对象。 有人有问了，那我要向实现将引用的对象也克隆过来怎么办？ 上边的方法在模板中添加Clone 是一种浅复制，还有一种深复制，可以解决克隆引用对象的问题。 深复制 深复制需要增加三步： 1、让引用的类也继承系统的克隆类Icloneable，在类中添加克隆方法。 2、在调用类中，增加以被调用类为参数的私用构造函数，结果返回被调用类克隆方法，从而实现克隆。 3、在调用类的克隆方法中，调用私用构造方法，让引用克隆完成。 假如工作经历类为要调用的类： 1、让工作经历类继承接口 Class WorkExperience :Icloneable{//增加克隆方法Public Object Clone(){Return (Object) this.MemberwiseClone();}} 2、在简历类中增加私有构造函数 Private Resume(WorkExperience work){This.work=(WorkExperience)work.Clone();}   3、修改简历类中的克隆方法。 public Object Clone(){Resume obj=new Resume(this.work); ……}    二、类图    ","title":"原型模式——创建型设计模式四"},{"content":"概念：        抽象工厂模式（Abstract Factory），提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。        上面这段话，我到现在还是不怎么明白。分析：首先抽象工厂是提供一个接口，什么样的接口？创建对象的接口。创建什么对象？一系列相关或相互依赖的对象。而且创建了这个接口之后，不需要指定这个接口的具体的类。还是不明白？         百度百科是这么说的：抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。根据LSP原则，任何接受父类型的地方，都应当能够接受子类型。因此，实际上系统所需要的，仅仅是类型与这些抽象产品角色相同的一些实例，而不是这些抽象产品的实例。换言之，也就是这些抽象产品的具体子类的实例。工厂类负责创建抽象产品的具体子类的实例。 UML类图：        从左到右，从上到下，依次是：客户端，客户端关联抽象工厂，抽象产品A，抽象产品B。然后抽象产品A，有两个具体子类：具体产品1类和具体产品2类（他们的实例化对象就是我们要创建的产品对象）。同理，抽象产品B。最后就是，抽象工厂，以及他的2个具体工厂。他们都有两个方法，用来创建具体的产品。 代码：        分析：还是汽车的例子。由于生意越做越大，所以要扩展行业。决定，工厂不只生产汽车，还生产汽车运动服装。（这只是为了说明汽车类和服装类不是同一种产品，真实的工厂是不会一边生产汽车，还生产衣服的）。        运动服装（SportsWear），两种牌子的宝马牌（BMWwear）和奔驰牌子（Benzwear）。其实衣服的牌子也可以完全和汽车没有关系。本来我打算用的是耐克（NIKE）和阿迪达斯（Adidas），但是后来写代码的时候，是在奔驰工厂或宝马工厂中的创建服饰，我就觉得在奔驰工厂中生产耐克，额~，觉得有些问题，就把耐克改成了奔驰服装，这样理解也方法。奔驰工厂生产的东西，带上标识，汽车就是奔驰汽车，衣服就是奔驰衣服，手机就是奔驰手机。 不过现在想想耐克其实也是可以的吧，大不了我说明下奔驰工厂生产的服装就是叫耐克服装也没什么，不过我代码已完成就不该了。 UML类图:        为了简化问题，所有的产品类都只有一个方法，Show。然后工厂类增加一个方法CreateSportsWear，返回值是ISportsWear类型。   代码： Namespace CarAbstractFactory{    class Program   {        static void Main(string[] args)        {            //最后，客户端修改下,首先要实例化具体工厂.            //然后具体工厂创建具体的车,           //具体的车创建完成了,自己展示下.            Factory factory;            ICar car; //客户端是通过他们的抽象接口(ICar)操纵实例            //比较部分,开始            factory = new BenzFactory();                car=factory.CreateCar();//产品的具体类(Benz)名也被具体工厂(BenzFactory)的实现(factory)分离,（Benz）没有出现在客户端中            car.Show();          //比较部分,结束            //然后是具体工厂创建具体的服饰，然后具体服饰显示下，表明创建是成功的            ISportsWear benzsports =factory.CreateSportsWear();           benzsports.Show();           //为了体现抽象工厂的易于交换产品系统的优点。我把代码修改了一下，可以比较客户端两段代码，           //两段代码只有new的对象不一样,其他都一样,所以要修改是非常方便的。            factory = new BMWFactory();          car = factory.CreateCar();          car.Show();          //同理            ISportsWear bmwsports =factory.CreateSportsWear();          bmwsports.Show();                    Console.Read();        }    }    //首先还是抽象产品角色，汽车接口（产品角色都没变,不管抽象产品还是具体产品）    interface ICar    {        void Show();    }    //然后是两个具体产品角色，宝马和奔驰,他们都要实现ICar接口    class BMW:ICar    {        public void Show()        {            //内容很简单，只是输出一句话              Console.WriteLine(\"一辆宝马诞生了！！！\");        }    }    //Benz类    class Benz:ICar    {        public void Show()        {           Console.WriteLine(\"我是一辆奔驰！！！\");        }    }    //增加一个抽象产品系列,运动服装类    interface ISportsWear    {        void Show();//只有这个方法,显示    }    //接着具体的运动服装产品类    class BMWwear : ISportsWear    {        //实现接口的方法        public void Show()        {            Console.WriteLine(\"宝马服饰\");        }   }    //奔驰服饰    class Benzwear : ISportsWear    {       public void Show()        {            //这个效果和\"Benzwear服饰\"是一样的.            Console.WriteLine(\"{0}服饰 \",this.GetType().Name);        }    }    //然后要增加工厂类的方法,增加CreateSportsWear方法,   //抽象工厂的名字从CarFactory改为Factory，因为现在不只是生产车子。    abstract class Factory    {        //是个抽象方法,修改了下这个方法,原来是CarCreate,改成了CreateCar(我类图是这么写的)        public abstract ICar CreateCar();        //增加抽象方法,子类要实现        public abstract ISportsWearCreateSportsWear();    }    //新开的两个工厂    //宝马工厂    class BMWFactory : Factory    {        //实现父类的抽象方法        public override ICar CreateCar()        {            //CreateCar方法，它就是实例化个宝马类,也就是子类决定实例化哪一个类.类的实例延迟到子类.            return new BMW();        }        public override ISportsWearCreateSportsWear()        {            //创建一种衣服,宝马服装            return new BMWwear();       }    }    //奔驰工厂,同宝马工厂    class BenzFactory :Factory    {       public override ICar CreateCar()        {            return new Benz();        }        //和上面的相比,方法名一样,参数一样的,但是因为对象不一样,所以返回的结果不一样,是多态.       public override ISportsWear CreateSportsWear()        {            //创建一种衣服,宝马服装            return new Benzwear();        }    } } 运行结果：        抽象工厂的优点是，易于交换产品系列，如我客户端中表示的，变换工厂只需要修改一个地方就可以。第二个优点是，让具体的创建实例过程和客户端分离，客户端是通过他们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户端中。        但是他的缺点，如果我要在生产别的东西。比如我要增加一个生产家具的类，那么我就要增加一个家具的抽象类，两个具体的家具类，一个奔驰家具类和一个宝马家具类。然后还要增加方法CreateFurniture，就要更改Factory，BenzFactory和BMWFactory。要改三个类，太糟糕了。        其实就上面的修改三个类，我觉得已经违背了开发-封闭原则，但是好像没有谁说这是修改，而是说这是扩展。我只好往这上面凑，觉得他们是增加了一个方法，而没有修改其他的地方，所以算是扩展。        可以用简单工厂来改进抽象工厂，简单工厂就是把3个工厂类又简化成一个工厂类，然后具体要实例化那个产品类，肯定要有switch…case或if语句来选择。而使用switch…case或if语句不好，因为分支判断会耦合性高，然后使用反射来去除switch或if，解除分支判断带来的耦合。        反射代码我就不写了。","title":"抽象工厂模式"},{"content":"当我们使用“new”时我们就是在针对实现编程，这会使代码缺乏弹性。当然我们不可能避免在Java中使用new，真正需要考虑的是系统可能面对的“改变”。我们需要尽量隔离掉可能发生改变的部分。针对实现编程时，我们的代码中涉及到太多具体类，以后只要我们的系统需要改变，我们就不得不修改大量代码；而针对接口编程可以使得我们的代码更灵活，因为它涉及到的不是具体对象，而是一类对象。 一个设计应该“对扩展开放，对修改关闭”。有时我们需要把创建对象的动作封装起来，这就是工厂（factory）模式。工厂处理创建对象的细节。在本章的例子里，我们需要根据情况创建不同类型的Pizza，如果直接写成： PizzaStore类中public Pizza orderPizza(String type) {Pizza pizza;if (type.equals(\"cheese\")) {pizza = new CheesePizza();} else if (type.equals(\"pepperoni\")) {pizza = new PepperoniPizza();} else if (type.equals(\"clam\")) {pizza = new ClamPizza();} else if (type.equals(\"veggie\")) {pizza = new VeggiePizza();}pizza.prepare();pizza.bake();pizza.cut();pizza.box();return pizza;} 以后每当有新的pizza出现我们都不得不修改此处代码。使用“简单工厂”模式，我们创建PizzaFactory类并实现createPizza（String Type）方法创建并返回相应的pizza。现在，我们将上面代码中的if-else块换为pizza = factory.createPizza(type);即可。 乍一看上去好像我们只是把代码换了个位置，并无实际意义，但是要知道PizzaFactory不只是用在orderPizza这一方法中，所有其他涉及到pizza对象使用的地方都可以使用PizzaFactory，以后如果有新的pizza种类加入只需修改createPizza方法即可。 注意：有时人们使用静态方法的方式实现简单的工厂，这样做的缺点在于不能使用继承改变创建方法的行为。 上面只是一个小例子，我们称之为“简单工厂”模式。书中提到的另外两种工厂模式为： 工厂方法模式（Factory Method Pattern） 现在考虑有PizzaStore有一些子类（加盟店），他们有可能对pizza的做法进行一些改良，即createPizza方法需要升级。工厂方法的做法是，在基类中建立一个形为abstract Product factoryMethod(String type); 的方法，作为工厂方法，负责创建对象，子类可以通过改写这一方法来改变创建对象的具体过程。 所有工厂模式都是为了封装对象的创建，工厂方法模式让子类来决定如何创建对象，来达到封装的目的。 工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。基类中的其他类可以自由使用这一方法而不用考虑它到底返回的是怎样的对象。如何返回要根据子类的实现。（多态） “简单工厂”把全部的事情在一个地方处理完，而“工厂方法”创建了一个框架，让子类决定如何实现。 抽象工厂模式：提供一个接口，用于创建一个对象家族，而无需指定具体类。 工厂方法只涉及到创建一个对象的情况，有时我们需要一族对象，比如书中的例子：原料家族。制作pizza需要很多原料，每个都需要一个工厂方法。这时我们把所有涉及到创建对象的方法集合到一起成为一个接口。使用者针对这个接口编程，而接口由具体的类来实现。这样一来我们可以根据情况把相应的实现此接口的类传递给使用者。 另外书中还提到一些设计原则。 依赖倒置原则（Dependency Inversion Principle）：要尽量依赖抽象，不要依赖具体类。 几点原则（根据情况）： 变量不要持有具体类的引用，使用工厂。 不要让类派生自具体类，这样就会依赖具体类。 不要覆盖基类中的方法，否则说明这个基类并不是一个适合被继承的对象。","title":"HeadFirst 设计模式笔记（四）—— 工厂模式"},{"content":"Portal-Basic Java Web应用开发框架（简称 Portal-Basic）是一套功能完备的高性能Full-Stack Web应用开发框架，内置稳定高效的MVC基础架构和DAO框架（已内置Hibernate、MyBatis和JDBC支持），集成 Action拦截、Form Bean / Dao Bean / Spring Bean装配、国际化、文件上传下载和缓存等基础Web应用组件，提供高度灵活的纯 Jsp/Servlet API 编程模型，完美整合 Spring，支持Action Convention“零配置”，能快速开发传统风格和RESTful风格的Web应用程序，文档和代码清晰完善，非常容易学习。 　　Portal-Basic 源码、示例及文档资源：请访问 google code 项目 ^_* Portal-Basic在设计之初就充分注重功能、性能与使用体验。Portal-Basic主要特点： 1) 功能全面：内置稳定高效的MVC基础架构和DAO框架，支持Action拦截、Form Bean / Dao Bean / Spring Bean装配和声明式事务，提供国际化、文件上传下载、缓存和页面静态化等常用Web组件，能满足绝大部分Web应用的需要。 2) 高度扩展：Portal-Basic通过的plug-in机制可以灵活扩展，Portal-Basic发布包中自带的portal-basic-ext-rest和portal-basic-ext-spring均以插件的形式提供，用户可根据需要加载或卸载这些插件。应用程序开发者也可以根据实际需要编写自定义插件来扩展Portal-Basic。 3) 强大的整合能力：Portal-Basic是一个Full-Stack框架，同时也是一个开放式框架，可以以非常简单的方式整合第三方组件。本开发手册会详细阐述如何在Portal-Basic中整合FreeMarker、Velocity、UrlRewrite、EHCache-Web、Spring、Hibernate和MyBaits等常用框架和组件。 4) 高性能：性能要求是Portal-Basic的硬性指标，从每个模块的设计到每行代码的实现都力求简洁高效。另外，Portal-Basic并没有对JSP/Servet API进行过多封装，开发者仍然使用JSP/Servet API开发应用程序，没有过多的迂回，性能得到保证。 5) 优秀的使用体验：Portal-Basic的设计目标之一是提供良好的开发体验，尽量减少应用程序开发者的工作，API的设计力求简单、完整、明确。同时，Portal-Basic为应用开发提供了大量Util工具，用来处理应用程序开发过程中通常会遇到的一般性问题，进一步减少应用程序开发者的工作负担。 6) 平缓的学习曲线：平缓的学习曲线：学习使用Portal-Basic只需掌握一定的Core Java与JSP/Servlet知识，本开发手册会循序渐进阐述每个知识点，每个知识点都会结合完整的示例进行讲述，知识点之间前后呼应，确保学习者在学习时温故知新，融会贯通。 7) 完善的技术支持：除了提供完善的开发手册和示例代码以外，还提供博客和QQ群用于解答使用Portal-Basic过程中碰到的所有问题。接下来，将计划建设一个Portal-Basic技术论坛。 Portal-Basic 3.0.1 更新： 1、增加 Action Convention，支持“Action 零配置”： 1) 根据 Action 请求的地址信息自动加载 Action，并调用相应的入口方法处理请求 2) 根据 Action 请求的地址信息和 Action Result 自动组合出输出页面的地址并转发 3) 通过 @Result/@Results 和 @ExceptionMapping/@ExceptionMappings 注解自定义 Result 和 Exception 处理策略 2、增加 REST 支持： 1) 增加 REST 插件包 portal-basic-ext-rest-3.0.1.jar 用于支持 REST 2) portal-basic-ext 通过 com.bruce.ext.rest.RestDispatcher 过滤器把 REST 请求转换为 Action 请求 3) portal-basic-ext 提供 com.bruce.ext.rest.RestActionSupport 作为处理 REST 请求的 Action 基类 4) Action 的 REST 请求处理方法通过声明 @Get/@Post/@Put/@Delete 注解来匹配 REST 地址格式，并注入参数 5) 内置 Rails-style REST 标准方法 6) 同时支持 HTML/XML/JSON 三种视图格式，应用程序也可以扩展自己的视图格式 7) portal-basic-ext 与 Action Convention 结合使用能实现“零配置”处理 REST 请求  ","title":"Portal-Basic Java Web 应用开发框架：应用篇（十三） —— REST Convention"},{"content":"一。出事之前的情况：      联想E430，win764，分区（C,E,F,G） 二。折腾：      希望在机器装ubuntu12.10     1.ubuntu官网下载ubuntu 12.10做面板amd64的ios镜像，下载了磁盘镜像引导工具easyBCD     2.在win7下 ，计算机->管理->磁盘管理，将E盘分出32G格式为FAT32命名为D(用ios引导安装的临时盘)     3.解压ubuntu12.10的iso文件到FAT32的D盘根目录，将vmlinuz和initrd.lz拷贝到D盘根目录，目录结构如下   4.安装easyBCD   5.重启电脑，选中easyBCD启动。指定*****，进行ubuntu的安装工作（此下省略一万字）。       经过一阵折腾，双系统打工搞成，全部正常！   以下操作注意了（画蛇添足之举！！！） 安理说，之前为在win7下硬盘安装ubuntu而临时格式化分出来的32G的FAT32的D盘现在 是可以释放掉，给win7回收利用的。所以我重新进入win7，将D盘格式化删除以后释放掉了，然后再格式化为NTFS还给了win7.   重新启动，发现两个系统全部不能进去！！！！（瞬间眼前一黑，天塌下来了！公司的项目，很多文件材料都在里面！！！）     机器停在了grub secure模式： 个人觉得可能的原因：    现在的启动点有三个：             1.win7；2.做引导用的D盘中的linux；3.正常安装linux后的启动；   现在删掉第二个盘块后启动时找不到第二种启动文件，系统一放进一步操作导致文件损坏，所以进入grub secure模式。                 经过一阵尝试：      set root=(hd0,msdos9)      set prefix=(hd0,msdos9)/grub      insmod /grub/i386-pc/normal.mod        =>进入了另外一中模式，字体变白了      normal 进入到了系统选择界面，这个时候的症状是 1.ubuntu可以正常启动 2.win7系统进不去，蓝屏后重启，回到grub secure   在ubuntu下连上网，装了boot repair 重启后的症状是： 1.系统不再进入grub secure,而是直接进入系统选择界面 2.ubuntu可以正常启动 3.win7依旧蓝屏后自动重启，进入系统选择界面   接下来的操作看好了：（一下操作是得搜音客听书网同仁帮助，感激之情无于言表） 按F2进入bois，找到advanced，里面有个IDE模式设置；选择Compatible（有些是disable，不要选择AHCI或者enhanced就行了）。保存后启动就正常了。 （设置ide compatible的具体操作如下：在bios中将硬盘模式设置为ide兼容模式（别说你不会哦，百度有教程）。A. 开机按F1键进入主板设置  B. 进入Config菜单  C. 进入Serial ATA (SATA)）   个人觉得由于ubuntu和win7支持的启动模式不一样，毕竟ubuntuFAT32,而win7是NTFS。现在ubuntu是主设置成了主启动点。这种情况下读取并启动win7读入的肯定都是乱码。所以在bios里面设置了兼容模式！！！   大功告成，整个世界焕然一新，双系统，释放掉了临时的FAT32分区。  ","title":"Win7 Ubuntu12.10双系统问题，及解决的心酸历程，分享给大家，给大家指一条救亡之道"},{"content":"工作流审批平台-审批功能","title":"工作流审批平台-审批功能"},{"content":"问题 如果一个应用程序使用了大量的对象，二这些对象造成了很大的存储开销就应该考虑应用享元模式。 Flyweight享元模式 运用共享技术有效地支持大量细粒度的对象(对于C++来说就是共用一个内存块啦，对象指针指向同一个地方)。 FlyweightFactory享元工厂：用来创建并管理Flyweight对象。它主要是用来确保合理地共享Flyweight，当用户请求一个Flyweight时，FlyweightFactory对象提供一个已创建的实例或创建一个(如果不存在)。 Flyweight：所有具体享元类的超类或接口，通过这个接口，Flyweight可以接受并作用于外部状态。 ConcreteFlyweight：继承Flyweight超类或实现Flyweight接口，并为内部状态增加存储空间 UnshareConcreteFlyweight：指那些不需要共享的Flyweight子类。因为Flyweight接口共享成为可能，但它并不强制共享。 Flyweight模式中有一个类似Factory模式的对象构造工厂FlyweightFactory，当客户程序员(Client)需要一个对象时候就会向FlyweightFactory发出请求对象的消息GetFlyweight()消息，FlyweightFactory拥有一个管理，存储对象的”仓库”(或者叫对象池,list实现)，GetFlyweight()消息会遍历对象池中的对象，如果已经存在则直接返回给Client，否则创建一个新的对象返回给Client。当然可能也有不想被共享的对象(UnshareConcreteFlyweight)。 小demo Flyweight.h /********************************************************************\tcreated:\t2006/07/26\tfilename: \tFlyWeight.h\tauthor:\t\t李创                http://www.cppblog.com/converse/\tpurpose:\tFlyWeight模式的演示代码*********************************************************************/#ifndef FLYWEIGHT_H#define FLYWEIGHT_H#include <string>#include <list>typedef std::string STATE;class Flyweight{public:\tvirtual ~Flyweight(){}    inline STATE GetIntrinsicState(){return m_State;}\tvirtual void Operation(STATE& ExtrinsicState) = 0;protected:\tFlyweight(const STATE& state) : m_State(state)\t{}private:\tSTATE m_State;};class FlyweightFactory{public:\tFlyweightFactory(){}\t~FlyweightFactory();\tFlyweight* GetFlyweight(const STATE& key);private:\tstd::list<Flyweight*>\tm_listFlyweight;};class ConcreateFlyweight : public Flyweight{public:\tConcreateFlyweight(const STATE& state) : Flyweight(state)\t{}\tvirtual ~ConcreateFlyweight(){}\tvirtual void Operation(STATE& ExtrinsicState);};#endif Flyweight.cpp /********************************************************************\tcreated:\t2006/07/26\tfilename: \tFlyWeight.cpp\tauthor:\t\t李创                http://www.cppblog.com/converse/\tpurpose:\tFlyWeight模式的演示代码*********************************************************************/#include \"FlyWeight.h\"#include <iostream> FlyweightFactory::~FlyweightFactory(){     std::list<Flyweight*>::iterator iter1,iter2,temp;    for (iter1=m_listFlyweight.begin(),iter2=m_listFlyweight.end();iter1!=iter2;iter1++)    {        temp=iter1;         delete(*temp);    }    m_listFlyweight.clear();}Flyweight* FlyweightFactory::GetFlyweight(const STATE& key){     std::list<Flyweight*>::iterator iter1;    for (iter1=m_listFlyweight.begin();iter1!=m_listFlyweight.end();++iter1)    {        if ((*iter1)->GetIntrinsicState()==key)        {            std::cout<<\"The Flyweight:\"<<key<<\"already exits\"<<std::endl;            return (*iter1);        }    }    std::cout<<\"create a new flyweight:\"<<key<<std::endl;    Flyweight* flyweight=new ConcreateFlyweight(key);    m_listFlyweight.push_back(flyweight);    return flyweight;}void ConcreateFlyweight::Operation(STATE& ExtrinsicState){    std::cout<<\"ConcreateFlyweight: 內蘊[\"<<GetIntrinsicState()<<\"]外蘊[\"<<ExtrinsicState<<\"]\"<<std::endl;} main.cpp #include \"FlyWeight.h\"int main(){\tFlyweightFactory flyweightfactory;\tflyweightfactory.GetFlyweight(\"hello\");\tflyweightfactory.GetFlyweight(\"world\");\tflyweightfactory.GetFlyweight(\"hello\");\tsystem(\"pause\");\treturn 0;}  代码分析： 使用list链表来保存这些可以被共享的对象，需要使用的时候就到链表中查询是不是已经存在了，如果不存在就初始化一个，然后返回这个对象的指针。 Flyweight模式和Factory模式也经常混用。 在State模式和Strategy模式中会产生很多的对象，因此我们可以通过Flyweight模式来解决这个问题。  ","title":"[设计模式]Flyweight享元模式"},{"content":"问题 在面向对象系统的设计和开发过程中，对象间的交互和通信时最为常见的情况，因为对象间的交互本身就是一种通信。在系统比较小的时候，可能对象间的通信不是很多，对象也比较少，我们可以直接硬编码到各个对象的方法中。但是当系统规模变大，对象的量变引起系统复杂度的急剧增加，对象间的通信业变得越来越复杂，这时我们就要提供一个专门处理对象间交互和通信的类，这个中介者就是Mediator模式。Mediator模式提供将对象间的交互和通讯封装在一个类中，各个对象间的通信不必显示去声明和引用，大大降低了系统的复杂性能(了解一个对象总比深入熟悉n个对象要好)。另外Mediator模式还带来了系统对象间的松耦合。 中介者模式 中介者模式：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而降低耦合，而且可以独立地改变它们之间的交互 Mediator：抽象中介者，定义了同事对象之间向对方发生消息的接口 Colleague：抽象同事，定义了中介者对象到同事对象的接口 ConcreteMediator：具体中介者，实现抽象类的方法，它需要知道所有具体同事类，并从具体同事接收消息，向具体同事对象发出命令 ConcreteColleague：具体同事，每个具体同事只知道自己的行为，而不了解其他同事类的情况，但它们却都认识中介者对象 小demo mediator.h #pragma once#include <string>#include <iostream>using namespace std;class Colleague;//抽象中介者类，定义了同事对象到中介者对象的接口class Mediator{public:    virtual void Send(string msg,Colleague* col)=0;};//抽象同事类class Colleague{protected:    Mediator* mediator;public:    Colleague(Mediator* temp)    {        mediator=temp;    }};//同事A，//每个具体同事只知道自己的行为，而不了解其他同事类的情况，但它们却都认识中介者对象class ColleagueA : public Colleague{public:    ColleagueA(Mediator* temp) : Colleague(temp){}    void Send(string strMsg)    {        mediator->Send(strMsg,this);    }    void Notify(string strMsg)    {        cout<<\"同事A获得了消息：\"<<strMsg<<endl;    }};//同事Bclass ColleagueB : public Colleague{public:    ColleagueB(Mediator* temp) : Colleague(temp){}    void Send(string strMsg)    {        mediator->Send(strMsg,this);    }    void Notify(string strMsg)    {        cout<<\"同事B获得了消息：\"<<strMsg<<endl;    }};//具体中介者类，实现抽象类的方法//它需要自导所有具体同事类，并从具体同事接收消息，向具体同事对象发出命令class ConcreteMediator : public Mediator{private:    ColleagueA* colA;    ColleagueB* colB;public:    void InitColleage(ColleagueA* tempA,ColleagueB* tempB)    {        colA=tempA;        colB=tempB;    }    virtual void Send(string msg,Colleague* col)    {        if (col==colA)        {            colB->Notify(msg);        }        else        {            colA->Notify(msg);        }    }};   main.cpp  #include \"Mediator.h\"#include <windows.h>int main(){    ConcreteMediator* mediator=new ConcreteMediator();    //让同事认识中介者    ColleagueA* colA=new ColleagueA(mediator);    ColleagueB* colB=new ColleagueB(mediator);    //让中介者认识具体的同事    mediator->InitColleage(colA,colB);        colA->Send(\"吃饭了吗？\");    colB->Send(\"还没吃，你请吗？\");    system(\"pause\");    return 0;}   注意到，两个Colleague对象并不知道他交互的对象，并且也不是显示地处理交互过程，这一切都是通过Mediator对象来完成的。 Mediator模式还有一个很显著特点就是将控制集中，集中的优点就是便于管理，也正式符号了OO设计中的每个类的职责要单一和集中的原则。","title":"[设计模式]Mediator中介者模式"},{"content":"pthread_key_t和pthread_key_create()详解 下面说一下线程中特有的线程存储， Thread Specific Data 。线程存储有什么用了？他是什么意思了？大家都知道，在多线程程序中，所有线程共享程序中的变量。现在有一全局变量，所有线程都可以使用它，改变它的值。而如果每个线程希望能单独拥有它，那么就需要使用线程存储了。表面上看起来这是一个全局变量，所有线程都可以使用它，而它的值在每一个线程中又是单独存储的。这就是线程存储的意义。 下面说一下线程存储的具体用法。 1. 创建一个类型为 pthread_key_t 类型的变量。 2. 调用 pthread_key_create() 来创建该变量。该函数有两个参数，第一个参数就是上面声明的 pthread_key_t 变量，第二个参数是一个清理函数，用来在线程释放该线程存储的时候被调用。该函数指针可以设成 NULL ，这样系统将调用默认的清理函数。 3. 当线程中需要存储特殊值的时候，可以调用 pthread_setspcific() 。该函数有两个参数，第一个为前面声明的 pthread_key_t 变量，第二个为 void* 变量，这样你可以存储任何类型的值。 4. 如果需要取出所存储的值，调用 pthread_getspecific() 。该函数的参数为前面提到的 pthread_key_t 变量，该函数返回 void * 类型的值。 下面是前面提到的函数的原型： int pthread_setspecific(pthread_key_t key, const void *value); void *pthread_getspecific(pthread_key_t key); int pthread_key_create(pthread_key_t *key, void (*destructor)(void*)); 下面是一个如何使用线程存储的例子： #include <malloc.h>#include <pthread.h>#include <stdio.h>/* The key used to associate a log file pointer with each thread. */static pthread_key_t thread_log_key;/* Write MESSAGE to the log file for the current thread. */void write_to_thread_log (const char* message){\tFILE* thread_log = (FILE*) pthread_getspecific (thread_log_key);\tfprintf (thread_log, “%s\\n”, message);}/* Close the log file pointer THREAD_LOG. */void close_thread_log (void* thread_log){\tfclose ((FILE*) thread_log);\t}void* thread_function (void* args){\tchar thread_log_filename[20];\tFILE* thread_log;\t/* Generate the filename for this thread’s log file. */\tsprintf (thread_log_filename, “thread%d.log”, (int) pthread_self ());\t/* Open the log file. */\tthread_log = fopen (thread_log_filename, “w”);\t/* Store the file pointer in thread-specific data under thread_log_key. */\tpthread_setspecific (thread_log_key, thread_log);\twrite_to_thread_log (“Thread starting.”);\t/* Do work here... */\treturn NULL;}int main (){\tint i;\tpthread_t threads[5];\t/* Create a key to associate thread log file pointers in\tthread-specific data. Use close_thread_log to clean up the file\tpointers. */\tpthread_key_create (&thread_log_key, close_thread_log);\t/* Create threads to do the work. */\tfor (i = 0; i < 5; ++i)\t\tpthread_create (&(threads[i]), NULL, thread_function, NULL);\t/* Wait for all threads to finish. */\tfor (i = 0; i < 5; ++i)\t\tpthread_join (threads[i], NULL);\treturn 0;}  最后说一下线程的本质。 其实在Linux 中，新建的线程并不是在原先的进程中，而是系统通过一个系统调用clone() 。该系统copy 了一个和原先进程完全一样的进程，并在这个进程中执行线程函数。不过这个copy 过程和fork 不一样。copy 后的进程和原先的进程共享了所有的变量，运行环境（clone的实现是可以指定新进程与老进程之间的共享关系，100%共享就表示创建了一个线程）。这样，原先进程中的变量变动在copy 后的进程中便能体现出来。","title":"pthread_key_t和pthread_key_create()详解"},{"content":"0.序 本文是对接下来一系列文章的综述。接下来一系列文章讲述了Nginx作为一款Linux下的软件时其运行的原理。说直白一点，本系列文章讲述的是Nginx软件在接收Http请求之前所做的所有工作。 1.本系列文章内容 本系列文章将包括以下内容 文章1：Nginx启动流程分析：讲述了Nginx启动的流程.非常详尽的启动流程，一直讲到Master进程等待信号和Worker进程等待Http请求。 文章2：详细讲述了启动过程中main函数中的相关过程。 文章3：讲述了Nginx中与信号相关的内容。这部分内容对于理解Nginx中master进程如何接受来自于管理员的信号由重大帮助。为了能够很好地理解文章2中的内容。必须阅读基础文章1：APUE chap10 信号 文章4：必须讲述Master进程中内容。这部分内容与文章0有些重复，但是这篇文章中讲述了调试的方法，还是可以看看的。 文章5：必须讲讲worker进程的内容，实际上就是讲讲ngx_worker_process_cycle中内容。 要阅读这篇文章，还是需要很多基础知识：1）epoll事件 2）互斥体。 如果阅读这篇文章觉得费力，可以先阅读接下来的几篇文章，然后再返回头阅读这篇文章。 文章6：Nginx中的Epoll事件处理机制 必须讲讲Nginx中的事件处理机制。在Nginx中默认采用epoll事件处理机制。 如果觉得这篇文章读起来也费力，那么就需要学习Epoll事件处理机制的原理。请参考事件处理机制之epoll 文章7：必须讲讲Worker进程是如何被创建的。这儿牵涉到的是如何创建进程，在文章1中有说明，因此只需要去阅读基础文章3：进程基础之fork函数和基础文章4：进程详细描述.其实这部分关于进程的内容还需要仔细阅读APUE进行学习。系统的学习永远是最重要的。 文章8：必须讲讲Master进程如何与Worker进程进行通信的。这部分非常重要。这部分还需要进一步学习和总结。 阅读这篇文章，也必须熟悉进程通信相关内容。需要参考基础文章5：APUE chap15 进程间通信 和 基础文章6：APUE chap17 高级进程间通信 以及基础文章7：chap15 进程通信之管道 补充。 文章9：Nginx accept互斥锁。这部分主要是为了讲讲Nginx的accept互斥体。这篇文章需要学习文件锁方面的内容。参考基础文章2：APUE chap14 高级I/O 备注：实际上这儿还欠着两篇比较重要的文章 文章1：讲述Nginx中如何添加事件。如何为监听套接字分配connections数组，如何添加到epoll句柄中，又是如何调用的 文章2：进程通信。","title":"文章0：Nginx整体分析"},{"content":"0.序 1.为什么要采用epoll事件处理机制呢？也就是Epoll的优点。 2.epoll事件处理机制有两种触发方式：ET和LT。有何区别？ 3.epoll相关函数    1）epoll_create函数    2）epoll_ctl函数    3）epoll_wait函数 4.程序 5.小结 6.参考文章 0.序      写了一篇文章是关于事件处理机制之epoll的，但是有点过于冗余，这次将里面的核心内容精简下来。我一直都认为，写博客一方面是为了让他人有一个更快捷的学习方式，更重要的一方面是可以让你对所学知识有一个更加深刻的认识。 1.为什么要采用epoll事件处理机制呢？也就是Epoll的优点。      一句话，并发性高。因为select和poll事件处理机制都是采用轮询IO的方式。采用轮询IO是最耗时的操作之一。      可以参考文章epoll为什么这么快       <1>支持一个进程打开大数目的socket描述符(FD)      select 最不能忍受的是一个进程所打开的FD是有一定限制的，由FD_SETSIZE设置，默认值是2048。对于那些需要支持的上万连接数目的IM服务器来说显 然太少了。这时候你一是可以选择修改这个宏然后重新编译内核，不过资料也同时指出这样会带来网络效率的下降，二是可以选择多进程的解决方案(传统的 Apache方案)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完 美的方案。不过 epoll则没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。      <2>IO效率不随FD数目增加而线性下降      传统的select/poll另一个致命弱点就是当你拥有一个很大的socket集合，不过由于网络延时，任一时间只有部分的socket是\"活跃\"的， 但是select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。但是epoll不存在这个问题，它只会对\"活跃\"的socket进行 操作---这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。那么，只有\"活跃\"的socket才会主动的去调用 callback函数，其他idle状态socket则不会，在这点上，epoll实现了一个\"伪\"AIO，因为这时候推动力在os内核。在一些 benchmark中，如果所有的socket基本上都是活跃的---比如一个高速LAN环境，epoll并不比select/poll有什么效率，相 反，如果过多使用epoll_ctl,效率相比还有稍微的下降。但是一旦使用idle connections模拟WAN环境,epoll的效率就远在select/poll之上了。      <3>使用mmap加速内核与用户空间的消息传递。      这点实际上涉及到epoll的具体实现了。无论是select,poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存拷贝就 很重要，在这点上，epoll是通过内核于用户空间mmap同一块内存实现的。而如果你想我一样从2.5内核就关注epoll的话，一定不会忘记手工 mmap这一步的      <4>内核微调      这一点其实不算epoll的优点了，而是整个linux平台的优点。也许你可以怀疑linux平台，但是你无法回避linux平台赋予你微调内核的能力。 比如，内核TCP/IP协议栈使用内存池管理sk_buff结构，那么可以在运行时期动态调整这个内存pool(skb_head_pool)的大小 --- 通过echo XXXX>/proc/sys/net/core/hot_list_length完成。再比如listen函数的第2个参数(TCP完成3次握手 的数据包队列长度)，也可以根据你平台内存大小动态调整。更甚至在一个数据包面数目巨大但同时每个数据包本身大小却很小的特殊系统上尝试最新的NAPI网 卡驱动架构。       2.epoll事件处理机制有两种触发方式：ET和LT。有何区别？      ET：Edge Trigger；LT：Level Trigger。      作为一名通信专业的学生，当然不能把所学的通信方面的知识忘记了呀，那咱就用信号方面的东西讲讲水平触发和边缘触发。 3.epoll相关函数 1）epoll_create函数 NAME        epoll_create, epoll_create1 - open an epoll file descriptor SYNOPSIS        #include <sys/epoll.h>        int epoll_create(int size);        int epoll_create1(int flags); DESCRIPTION        epoll_create() creates an epoll \"instance\", requesting the kernel to        allocate an event backing store dimensioned  for  size  descriptors.        The  size  is  not  the maximum size of the backing store but just a        hint to the kernel  about  how  to  dimension  internal  structures.        (Nowadays, size is ignored; see NOTES below.)        epoll_create()  returns a file descriptor referring to the new epoll        instance.  This file descriptor is used for all the subsequent calls        to  the epoll interface.  When no longer required, the file descrip‐        tor returned by epoll_create() should be closed by  using  close。 epoll_create()创建一个epoll句柄，内核会分配一个空间用来存放你想关注的文件描述符上是否发生以及发生了什么事件。 epoll_create()返回一个代指新epoll句柄的fd。这个fd作为epoll的接口，会在接下来的所有epoll调用中使用这个fd。 2）epoll_ctl函数 NAME        epoll_ctl - control interface for an epoll descriptor SYNOPSIS        #include <sys/epoll.h>        int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); DESCRIPTION        This  system  call  performs  control  operations on the epoll instance  referred to by the file descriptor epfd.  1）int op  It requests that  the  operation op be performed for the target file descriptor fd. epoll_ctl执行在epfd代表的epoll句柄上的控制操作。操作op将会在目标文件描述符fd上进行操作。        Valid values for the op argument are :        EPOLL_CTL_ADD               Register  the  target  file  descriptor fd on the epoll instance               referred to by the file descriptor epfd and associate the  event               event with the internal file linked to fd. EPOLL_CTL_ADD：将目标文件描述符fd注册到epoll句柄上，并使事件类型event与文件描述符fd相关联。        EPOLL_CTL_MOD               Change  the event event associated with the target file descrip‐               tor fd. EPOLL_CTL_MOD：改变目标文件描述符fd的事件类型。        EPOLL_CTL_DEL               Remove (deregister) the target file descriptor fd from the epoll               instance  referred  to by epfd.  The event is ignored and can be               NULL (but see BUGS below). EPOLL_CTL_DEL：从epoll句柄epfd中删除目标文件描述符fd。fd对应的事件将会被忽略。 2）struct epoll_event *event The event argument describes the object linked to the  file  descriptor fd.  与文件描述符fd相对应的事件类型event，其结构体如下：  The struct epoll_event is defined as :            typedef union epoll_data {                void        *ptr;                int          fd;                __uint32_t   u32;                __uint64_t   u64;            } epoll_data_t;            struct epoll_event {                __uint32_t   events;      /* Epoll events */                epoll_data_t data;        /* User data variable */            };        The  events  member is a bit set composed using the following available event types:     常用的事件类型:  EPOLLIN ：表示对应的文件描述符可以读；  EPOLLOUT：表示对应的文件描述符可以写；  EPOLLPRI：表示对应的文件描述符有紧急的数据可读  EPOLLERR：表示对应的文件描述符发生错误；  EPOLLHUP：表示对应的文件描述符被挂断；  EPOLLET：表示对应的文件描述符有事件发生；   3）举例说明其使用方式 struct epoll_event ev;  //设置与要处理的事件相关的文件描述符  ev.data.fd=listenfd;  //设置要处理的事件类型  ev.events=EPOLLIN|EPOLLET;  //注册epoll事件  epoll_ctl(epfd,EPOLL_CTL_ADD,listenfd,&ev);  3）epoll_wait函数   epoll_wait,  epoll_pwait  -  wait  for an I/O event on an epoll file  descriptor 作用：等待在epoll 文件描述符上的一个I/O事件。 SYNOPSIS        #include <sys/epoll.h>        int epoll_wait(int epfd, struct epoll_event *events,                       int maxevents, int timeout); DESCRIPTION        The epoll_wait() system call waits for events on the epoll instance referred to by the file descriptor epfd.  The memory area pointed to by events will contain the events that will be available for the caller.  Up to maxevents are returned by epoll_wait().  The maxevents argument must be greater than zero.        epoll_wait系统调用等待epoll句柄中events事件。由events指向的内存区域包含了对于调用者而言可选的事件，即如果注册在epoll句柄上的fd的事件发生，那么就会将发生的fd以及事件类型放入events数组中。当到了最大事件maxevents时，epoll_wait会返回。maxevents必须大于0.        The call waits for a maximum time of timeout milliseconds.  Specifying a timeout of -1 makes epoll_wait() wait  indefinitely,  while  specifying  a  timeout    equal to zero makes epoll_wait() to return immediately even if no events are available (return code equal to zero).        该系统调用epoll_wait等待timeout ms。如果timeout=-1，则是无限等待；如果timeout=0，即使没有事件可供选择，epoll_wait也会立即返回。 The struct epoll_event is defined as :            typedef union epoll_data {                void    *ptr;                int      fd;                uint32_t u32;                uint64_t u64;            } epoll_data_t;            struct epoll_event {                uint32_t     events;    /* Epoll events */                epoll_data_t data;      /* User data variable */            };        The  data of each returned structure will contain the same data the user set with an epoll_ctl(2) (EPOLL_CTL_ADD,EPOLL_CTL_MOD) while the events member will  contain the returned event bit field. 注意：epoll_wait会将注册在epfd上的已经发生事件的fd的事件类型清空，所以如果下一个循环还要关注这个fd的话，就必须通过epoll_ctl(epfd,EPOLL_CTL_MOD,xx,xxxx)来重新设置fd的事件类型。这时不用EPOLL_CTL_ADD，因为fd没有被清空，只是事件类型被清空。 4.程序 /* ** 这是服务器端程序 **本程序来自于http://www.cppblog.com/converse/archive/2008/04/29/48482.html ** 本程序为采用 Epoll事件的简单程序实现。我添加了#define ET 1 如果#define ET 0 ，那么epoll采用LT触发，如果#define ET 1，那么采用ET触发 ** 采用LT触发时，只要还有数据留在buffer中 ,server就会继续得到通知 */ #define ET 0 #include <string.h> #include <stdlib.h> #include <sys/socket.h> #include <sys/epoll.h> #include <netinet/in.h> #include <arpa/inet.h> #include <fcntl.h> #include <unistd.h> #include <stdio.h> #include <errno.h> #define MAXLINE 5 #define OPEN_MAX 100 #define LISTENQ 20 #define SERV_PORT 5000 #define INFTIM 1000 void setnonblocking(int sock) {     int opts;     opts=fcntl(sock,F_GETFL);     if(opts<0)     {         perror( \"fcntl(sock,GETFL)\");         exit(1);     }     opts = opts|O_NONBLOCK;     if(fcntl(sock,F_SETFL,opts)<0)     {         perror( \"fcntl(sock,SETFL,opts)\" );         exit(1);     }   } int main() {     int i, maxi, listenfd, connfd, sockfd,epfd,nfds;     ssize_t n;     char line[MAXLINE];     socklen_t clilen ;     //声明epoll_event 结构体的变量 ,ev用于注册事件,数组用于回传要处理的事件     struct epoll_event ev,events[20];     //生成用于处理accept的 epoll专用的文件描述符     epfd=epoll_create(256);     struct sockaddr_in clientaddr;     struct sockaddr_in serveraddr;     listenfd = socket(AF_INET, SOCK_STREAM, 0);     //把socket 设置为非阻塞方式 #if ET     setnonblocking(listenfd); #endif     //设置与要处理的事件相关的文件描述符     ev.data.fd=listenfd;     //设置要处理的事件类型 #if ET       ev.events=EPOLLIN|EPOLLET; #else       ev.events=EPOLLIN; #endif     //注册epoll 事件     epoll_ctl(epfd,EPOLL_CTL_ADD,listenfd,&ev);     memset(&serveraddr,0, sizeof(serveraddr));     serveraddr.sin_family = AF_INET;    // char *local_addr=\"127.0.0.1\";    // inet_aton(local_addr,&(serveraddr.sin_addr));//htons(SERV_PORT);     serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);     serveraddr.sin_port=htons(SERV_PORT);     bind(listenfd,( struct sockaddr *)&serveraddr, sizeof (serveraddr));     listen(listenfd, LISTENQ);     maxi = 0;     clilen = sizeof(struct sockaddr);     for ( ; ; ) {         //等待epoll 事件的发生         nfds=epoll_wait(epfd,events,20,500);         //处理所发生的所有事件             for(i=0;i<nfds;++i)         {             if(events[i].data.fd==listenfd)             {                 printf( \"001\\n\");                 connfd = accept(listenfd,( struct sockaddr *)&clientaddr, &clilen);                 if(connfd<0){                     perror( \"connfd<0\");                     exit(1);                 }                 //setnonblocking(connfd);                 char *str = inet_ntoa(clientaddr.sin_addr);                 printf( \"accapt a connection from %s\\n\" ,str);                 //设置用于读操作的文件描述符                 ev.data.fd=connfd;                 //设置用于注册的读操作事件 #if ET                 ev.events=EPOLLIN|EPOLLET; #else                 ev.events=EPOLLIN; #endif                 //注册ev                 epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&ev);             }             else if (events[i].events&EPOLLIN)             {                              printf( \"EPOLLIN\\n\");                 if ( (sockfd = events[i].data.fd) < 0)                     continue;                 if ( (n = read(sockfd, line, MAXLINE)) < 0) {                     if (errno == ECONNRESET) {                         close(sockfd);                         events[i].data.fd = -1;                     } else                         printf( \"error\\n\");                 } else if (n == 0) {                     close(sockfd);                     events[i].data.fd = -1;                 }                 line[n] = '\\0';                 printf( \"read %s\\n\",line);                 //设置用于写操作的文件描述符                 ev.data.fd=sockfd;                 //设置用于注册的写操作事件 #if ET                ev.events=EPOLLOUT|EPOLLET; #else                          ev.events=EPOLLOUT; #endif                //修改sockfd 上要处理的事件为 EPOLLOUT                 //epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&ev);/*注意，如果将这一行的注释去掉，那么程序就会将要处理的事件修改为读，那么就会进入002进行处理*/             }             else if (events[i].events&EPOLLOUT)             {                 printf( \"002\\n\");                    sockfd = events[i].data.fd;                 write(sockfd, line, n);                 //设置用于读操作的文件描述符                 ev.data.fd=sockfd;                 //设置用于注测的读操作事件 #if ET                     ev.events=EPOLLIN|EPOLLET; #else                             ev.events=EPOLLIN;                #endif //修改sockfd 上要处理的事件为 EPOLIN                 epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&ev);             }         }     }     return 0; }  //epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&ev);/*注意，如果将这一行的注释去掉，那么程序就会将要处理的事件修改为读，那么就会进入002进行处理*/其结果如下所示 /* ** 这是客户端端程序文件名： epoll_io_client.perl ** perl参考http://www.phpchina.com/resource/manual/perl/perl5-1.htm **  执行方法： $chmod +x epoll_io_client.perl就可以执行了：$./epoll_io_client.perl。 注：你的程序的第一行必须为#!/usr/local/bin/perl（perl所在位置） */ #!/usr/bin/perl use IO::Socket; my $host = \"127.0.0.1\"; my $port = 5000; my $socket = IO::Socket::INET->new(\"$host:$port\") or die \"create socket error $@\"; my $msg_out = \"1234567890\"; print $socket $msg_out; print \"now send over, go to sleep\\n\"; #sleep(5); print \"5 second gone send another line\\n\"; #print $socket $msg_out; while (1) {     sleep(1); } 5.小结 单进程的用法： int epfd = epoll_create(int size);        函数作用：用来创建Epoll事件的句柄。官方解释：它其实是在内核申请一空间，用来存放你想关注的socket fd上是否发生以及发生了什么事件。size就是你在这个epoll fd上能关注的最大socket fd数。        我对于该函数的作用的理解：就是创建一个用于Epoll事件的句柄，类似文件句柄 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)         函数作用：用来添加或者修改事件。        这里面重要的参数是struct epoll_event * event 和int fd。int fd 就是Epoll要处理的fd。struct epoll_event * event则是设置了Epoll对fd的处理方式。 int epoll_wait(int epfd,struct epoll_event * events,int maxevents,int timeout)        函数作用：该函数用于轮询I/O事件的发生。对于epoll_ctl中设置的I/O fd进行处理。      参数说明：epfd：已经经过epoll_create创建和epoll_ctl设置。这里面存放着要处理的fd。                       struct epoll_event * events:这个数组用来存放发生的fd和事件类型。其中的取值都是由epoll_ctl中注册的已经发生的fd和其对应的事件类型。                       maxevents：每次能处理的事件数       注意：每次执行完epoll_wait函数都会将int epfd中注册的int fd清除，因此还需要重新设置int fd 和 struct epoll_event *event，并且使用epoll_ctl重新添加或者修改事件。 单个epoll并不能解决所有问题，特别是你的每个操作都比较费时的时候，因为epoll是串行处理的。 所以你还是有必要建立线程池来发挥更大的效能。 线程池的用法：           本人对线程池不懂，但是可以从这篇文章中看到epoll的用法：一个简短的epoll服务器示例, 监听5000个端口, 使用线程池 从本例子中可以看到： 1）int epfd中不仅仅可以添加一个fd，可以添加多个fd，也就是epoll可以用来处理多个fd。 2）整个流程为 socket-----> bind -----> listen ----->创建epfd = epoll_create() ------------> 将socket产生的fd放入epfd中 epoll_add(epfd,EPOLL_CTL_ADD,fd,&ev)------------------------------->for(;;){  epoll_wait(epfd,events,20,time_value); .....} 6.参考文章 https://www.chenyajun.com/2008/11/14/814  http://hi.baidu.com/seraphsky/item/a4d7f3b4d9f3f541ba0e129a  http://www.cppblog.com/converse/archive/2008/10/12/63836.html epoll为什么这么快 http://www.cppblog.com/converse/archive/2008/10/13/63928.aspx epoll相关资料整理 http://hi.baidu.com/jackbillow/item/de083d7cff28593f7044230d epoll的ET和LT模式 http://hi.baidu.com/mgqw864/item/c2464168f75f23166895e696 accept:invalid argument http://hi.baidu.com/linglux/item/f0101993b391dedb1b49df3f 一个简短的epoll服务器示例, 监听5000个端口, 使用线程池 http://hi.baidu.com/ym012/item/449b0c260d168acaa4275a49 好文章","title":"事件处理机制之epoll"},{"content":"引言 工作需要前端工程师在测试环境测试，但是前端工程师大多不用LINUX，调试起来我这种兼职运维的就是一个苦逼了，因此搭建一个FTP服务器方便前端工程师部署调试自己的代码 搭建proftpd服务器 安装proftpd sudo apt-get install proftpd 配置proftpd vim /etc/proftpd/proftpd.conf # This is a basic ProFTPD configuration file (rename it to # 'proftpd.conf' for actual use.  It establishes a single server# and a single anonymous login.  It assumes that you have a user/group# \"nobody\" and \"ftp\" for normal operation and anon.ServerName\t\t\t\"HAO GEEK TEAM\"ServerIdent \t\t\ton\t\"Welcome To Hao Geek!\"ServerType\t\t\tstandaloneDefaultAddress\t\t\t192.168.1.***SocketBindTight\t\t\ton# Port 21 is the standard FTP port.Port\t\t\t\t21# Umask 022 is a good standard umask to prevent new dirs and files# from being group and world writable.Umask\t\t\t\t022# To prevent DoS attacks, set the maximum number of child processes# to 30.  If you need to allow more than 30 concurrent connections# at once, simply increase this value.  Note that this ONLY works# in standalone mode, in inetd mode you should use an inetd server# that allows you to limit maximum number of processes per service# (such as xinetd).MaxInstances\t\t\t30# Set the user and group under which the server will run.User\t\t\t\twww-dataGroup\t\t\t\twww-data# To cause every FTP user to be \"jailed\" (chrooted) into their home# directory, uncomment this line.DefaultRoot /srv/www/test/AllowOverwrite\t\tyes# Normally, we want files to be overwriteable.<Directory /srv/www/test/test1><Limit WRITE>AllowUser wangzhengyiDenyAll<\/Limit><\/Directory># 设置客户端认证方式，通过文件认证AuthOrder                               mod_auth_file.c mod_auth_unix.c# 指定文件认证的passwd文件AuthUserFile   /etc/proftpd/ftp.passwd# 指定文件认证的group文件AuthGroupFile  /etc/proftpd/ftp.group# 认证帐号不需要有有效的shellRequireValidShell    off# 设置每秒接受的连接请求个数，防止DoS攻击MaxConnectionRate       5# 最大的连接上的client的数量MaxClients   20 \"Sorry,the maximum number of allowed users (%m) are already connected. \"# 允许端点续传AllowStoreRestart   on#关闭dns反向解析UseReverseDNS offIdentLookups off ftpasswd创建访问用户 sudo ftpasswd --passwd --file=/etc/proftpd/ftp.passwd --name=wangzhengyi --uid=33 --shell=/bin/false --home=/home/nohome每个参数的定义可以man一下，如果你完全抄袭我的，那我只能说你运维做的太傻逼了，动动脑子想想自己的需求还是很必要的！ 重启proftpd服务器 sudo  /etc/init.d/proftpd  restart","title":"Ubuntu搭建proftpd服务器"},{"content":"Upload.aspx: <%@ LANGUAGE='JAVASCRIPT' %> <!-- #include file = \"../adojvs.inc\"--> <!-- #include file = \"../conn.inc\"--> <% // 执行SQL语句 //2012-12-6 Gu Laicheng function RunSQL(MySQL) {  var ret=\"\";  var rs1 = Server.CreateObject(\"ADODB.Recordset\");  rs1.CursorType = adOpenKeyset;  rs1.LockType = adLockBatchOptimistic; // Response.Write(\"<br/>\" + MySQL + \"\");  try {   rs1.Open(MySQL,conn);  }  catch (ex) {   var ErrStr,ErrStr0,ErrStr1=\"==>\"+new Date()+\"<br/>\";   ErrStr0 = \"Error:\"+ex+\"<br/>\"+MySQL;   var o = conn.Errors;   for (var i=0;i<o.Count;i++)   {    ErrStr1 += o.Item(i).Number + \":\" + o.Item(i).Description+\", \"+o.Item(i).SQLState+\";\"+o.Item(i).Source ;   }   ErrStr =ErrStr0+\"<br/>\"+ErrStr1;   o.Clear();   Response.Write(\"<br/>\" + ErrStr + \"\");  }     if(rs1.State==1)  {   if (!(rs1.BOF && rs1.EOF))   {    ret = rs1(0).value;   }   rs1.Close();  }  return ret; } var Class = {    create: function() {        return function(n) {            this.initialize.apply(this, arguments);       }    } } var TABLE = Class.create(); TABLE.prototype = {  initialize:function(TabName){   this.TabName = TabName;   this.Fields=[];   this.FieldCount = 0;   this.values=[];   this.types=[];   this.MySQL=\"\";   this.flag;  },  F:function(s)  {   var a=s.split(\",\");   for(var i=1;i<a.length;i++)   {    this.Fields[i-1]=a[i];   }   this.FieldCount = a.length-1;  },  V:function(s)  {   var a=s.split(\",\");   this.flag=a[0];   for(var i=1;i<a.length;i++)   {    this.values[i-1]=a[i];   }   if(a[0]==1) this.Replace();   if(a[0]==2) this.Insert();   if(a[0]==3) this.Update();   if(a[0]==4) this.Delete();  },  Replace:function()  {   if(this.values[0]==0)    this.Insert();   else    this.Update();  },  Insert:function()  {   var fs=\"\",vs=\"\";   var j=0; //i,j可能并不同步，有些列值可能为空，表示不插入其值,要保证sql的语法正确   for(var i=0;i<this.FieldCount;i++)   {    if(this.values[i] == \"NULL\") continue;    if(j == 0)    {     fs += this.Fields[i];     vs += \"'\"+this.values[i]+\"'\";    } else    {     fs += \",\"+this.Fields[i];     vs += \",'\"+this.values[i]+\"'\";    }    j++;   }   this.MySQL=\"insert into \"+this.TabName+\" (\"+fs+\") values (\"+vs+\")\";  },  Update:function()  {   this.MySQL=\"update \"+this.TabName+\" set \";   for(var i=1;i<this.FieldCount;i++)   {    if(this.values[i] == \"NULL\")    {     if(i != 1) this.MySQL += \",\";     this.MySQL += this.Fields[i]+\"=null \";    } else    {     if(i != 1) this.MySQL += \",\";     this.MySQL += this.Fields[i]+\"='\"+this.values[i]+\"'\";    }   }   this.MySQL += \" where \"+this.Fields[0]+\"='\"+this.values[0]+\"'\";  },  Delete:function()  {   this.MySQL=\"delete from \"+this.TabName+\" where \";   var j=0; //i,j可能并不同步，有些列值可能为空，表示不以其为条件,要保证sql的语法正确   for(var i=0;i<this.FieldCount;i++)   {    if(this.values[i]==\"\") continue;    if(this.values[i] == \"NULL\")    {     if(j != 0) this.MySQL += \" and \";     this.MySQL += this.Fields[i]+\" is null \";    } else    {     if(j != 0) this.MySQL += \" and \";     this.MySQL += this.Fields[i]+\"='\"+this.values[i]+\"'\";    }    j++;   }  } };  var fso, ts, s;  var ForReading = 1, ForWriting = 2;  var name;// = \"c:\\\\web\\\\yafulwisad\\\\t\\\\t.csv\";  name = Server.MapPath(\"t.csv\");  var fso = new ActiveXObject(\"Scripting.FileSystemObject\");  if (fso.FileExists(name))  {   Response.Write(\" 文件 \"+name+\" 存在！\");   ts = fso.OpenTextFile(name, ForReading, true); //  ts.SkipLine();     var data=new TABLE(Request.QueryString(\"a\")+\"\");   s = ts.ReadLine();   data.F(s);   Response.Write(\"<br/>\"+data.FieldCount);   Response.Write(\"<br/>\" + s.replace(/,/g,\"\\t\") + \"\");   Response.Write(\"<br/>\" + data.Fields + \"\");   while (!ts.AtEndOfStream)   {    s = ts.ReadLine(); //   Response.Write(\"<br/>\" + s.replace(/,/g,\"\\t\") + \"\");    data.V(s);    Response.Write(\"<br/>\" + data.MySQL + \"\");    RunSQL(data.MySQL);   }   ts.Close();  }  else  {   Response.Write(\" 文件 \"+name+\" 不存在，请核对后查询！\");  } %>","title":"asp.net 通过后台Javascript 上传表数据"},{"content":"在过去的一周，由于客户的需要，将我以前用django写的网站部署到windows上并做了相应压力测试，该项目原来写的时候目标是linux，部署到windows修改的比较多的地方就是和文件路径相关的地方了，所有直接拼接路径的地方都改成os.path.join，然后基本就能跑起来了。 软件所需大部分包在windows下都能安装，但gunicorn和uwsgi在window下不能安装，所以只好放弃原来的部署方式。在window下一共尝试过nginx + fcgi, nginx + scgi, nginx + gevent + wsgi三种部署方式。性能测试上fcgi和gevent相差无几， scgi略高，但scgi(flup) 和python logging模块不兼容，使得程序无法写日志，这点无法接受。 而gevent启动没有一个好的管理方式，最后选定使用fcgi部署。 由于在windows上无法使用prefork启动fcgi，所以在8核cpu机器上启动了8个fcgi进程，然后用nginx做转发。每个进程启动方式如下： python manage.py runfcgi protocol=fcgi method=threaded maxspare=40 host=127.0.0.1 port=xxxx fcgi的一些参数： maxspare: 在启动时就初始话这个多个 thread/process， 测试下来，能微微提高一点性能 minspare: 最小空闲 thread/process maxrequests: 每个thread/process 在处理了这么多请求之后就会被销毁， 防止内存泄漏 maxchild: 能产生最多的 thread/子进程 好了，部署方式确定了，下面就是调优了 mysql： 使用了msyql，使用了innodb general_log=0 #general 会影响一些性能 innodb_flush_log_at_trx_commit=2 #这条对性能影响很大， 为1时是每次commit都实时保存到硬盘，最安全， 为0时是一秒一次把commit添加到日志，然后写到硬盘， 最快， 为2时是每次commit都添加到日志，然后一秒一次保存到硬盘，性能和安全折中。（由于系统原因，1秒并不能保证是真正意义上的1秒） 对于安全， 值为1时最安全，mysql和系统崩溃都不会丢失数据， 为0时任一崩溃都有可能丢失最后1，2秒的数据，为2时只有在系统崩溃时才可能丢失最后1，2秒数据。 max_connect_errors=100000 #在linux下，这个值我也没设过，在window下发现这个值默认为10，即某个主机在10次链接错误之后就不允许该主机再次链接了，必须flush hosts之后才可以。这导致我测试的时候出现一旦某个用户出错之后所有测试都立马出错了， shit， 改大点。 innodb_buffer_pool_size=128M #测试的时候，我的数据集不大，这个值对我影响不大，而且，window下改的太大mysql有可能启动不起来。该值默认是为0，稍微改大点。 windows: windows xp, 2003都有tcp链接数限制 修改注册表中下面两项： HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\tcpip\\Parameters\\TcpTimedWaitDelay to 30  and HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\tcpip\\Parameters\\MaxUserPort to 65534  然后重启系统 TIME_WAIT状态：在测试会发现有很多处于TIME_WAIT状态的tcp连接， 在关闭tcp连接时，调用close的一端进入TIME_WAIT状态，然后等待对方的ACK之后才能关闭这个连接，TIME_WAIT时间长度是2*MSL（MSL:最大分段生存时间）， 在TIME_WAIT状态下，这个端口都不可被重用，通过修改住册表修改这个值，有人说这个值改为0也没有关系，只会降低一些服务器稳定性。 nginx： nginx在window下可设置的东西不多，和fastcig的某些需要设置一下  fastcgi_buffer_size 8k;  fastcgi_buffers 256 8k; 这两个值可以稍微设大点，在负载大的情况下， 值小了会出现502错误。只要nginx error log没有“an upstream response is buffered to a temporary file\"错误就可以了。 ps。nginx在window下现在还属于beta，存在不少问题，只能有一个工作进程，使用select模型，不能突破1024个文件描述符限制。程序：其实上面的调优的性能的提升加在一起都比如程序架构和本身性能的调优。由于这次测试只有一台机器，架构上的扩展性很小，只能从程序本身找一些性能提升点。缓存：对性能提升非常厉害，一个缓存的页面和一个动态生成的页面性能差距在几百倍以上，所以有可能缓存的页面最好都缓存。另本地缓存优于memcache，因为memcahce要用到tcp连接。orm： 我的程序使用了django model orm， 发现其对性能还是有一定影响的。我的一个主要页面，使用orm时平均响应时间是200ms，而我改写该页面，全部使用sql来处理时，响应时间能达到40ms以下。不过这也要在开发效率上做个权衡。 that all. 本次调优到此为止。","title":"Django 网站windows部署及调优"},{"content":"frameset曾经是构建多栏目网页的标准技术，被广泛使用，但是近年来已进越来越少见到它的踪影。在网上搜索一下，这个词更多的是与邪恶、如何代替、缺点这些主题联系在一起。frameset真的邪恶吗？ 各种文章提到的缺点主要有以下几条： 1.      （尽管互联网技术飞速发展了这么多年）仍然存在少数浏览器不支持frameset。 除非是想建立像Google这样的网站和有信心和责任感让全世界的网民都访问到你所建的网站，否则这条理由在一级风力下也很难站得住脚。 2.      frameset不利于屏幕阅读器（就是为视觉障碍者阅读网页的软件）运行。 不得不说，西方的网页设计者的人权意识值得我们学习。当他们在倡导构建一个无障碍的互联网世界时，在考虑如何为色盲和视觉障碍的用户提供便利的时候，我们的网站还到处是闪闪发光、四处漂移的小图片。 3.      frameset不利于将某个frame里的页面加为书签。 这一点是比较接近于大多数用户需求的考虑。所以像MSDN这样的网站都已经弃用frameset，而使用其它技术来实现目录和内容网页的同步。 至于frameset的优点，也就是发明它的初衷，当然是将不同的网页组合到一个屏幕中，使得整个页面中负责不同功能的部分能够被分开设计、组合使用，方便整个系统的统一布局，减少浏览器和服务器之间的流量。 这些优点仍然有效，之所以出现取代frameset的潮流，就是因为出现了同样能够实现这些功能的新的开发技术。frameset可以看作是前端的模块化、组件化，随着Web开发的不断复杂，出现了服务器端的模块化、组件化的技术，比如ASP.NET和JSF。分别属于.NET和Java两大阵营的这两种技术都大大简化和方便了开发中的界面设计，通过自定义控件和模板页等技术，在服务器端实现了网页各个功能部分的组合复用。 基于JSF的XPages技术也可以通过自定义控件来实现以上目的，并且在最早随8.5.3的升级包推出的新Teamroom模版就是使用自定义控件来完成页面的布局。不过我仍然认为在每个页面上都预先叠放几层控件来实现统一布局，不仅增加了设计的复杂程度（特别是当在自定义控件内部进行编辑和设计还很不方便的情况下），而且加大了浏览器和服务器之间的流量。 综合以上的讨论，frameset仍然有存在的理由。唯一比较现实的影响是否采用它因素就是所开发的应用中的各个页面是否有被加为书签的必要。在Teamroom中，视图中的每一个文档都在当前窗口中打开，而如果采用《16. 如何在XPages中实现onload效果及在新窗口中打开视图链接》里的方案，每一个文档仍然有独立的地址，可以加为书签。剩下受影响的就是一级和二级菜单转到的各个frames里的不同页面。如果有需要，也仍然可以借助前端技术提供用户添加书签的功能并且在单个frame中的页面加载时打开整个frameset。 如果决定采用frameset，就会发现传统的Notes帧结构集（frameset）不能将XPage添加为某个帧的内容。而一个XPage在被传向浏览器时也会自动转换成为包含<head>和<body>标签的页面。为了构造一个frameset，只有在传统的Notes page设计元素中添加Pass-through的HTML。就像下面这个样例： <frameset frameborder=\"1\" rows=\"60,81%\"><frame frameborder=\"0\" name=\"top\" src=\" top.xsp\"><frameset frameborder=\"1\" cols=\"20%,80%\"><frame frameborder=\"0\" name=\"left\" src=\" navigator.xsp\"><frame frameborder=\"0\" name=\"right\" src=\" viewAttendance.xsp\"><\/frameset><\/frameset>","title":"18. frameset邪恶吗"},{"content":"问题 Observer模式应该可以说是应用最多，影响最广的模式之一，因为Observer的一个实例Model/View/Control(MVC)结构在系统开发架构设计中有着很重要的地位和意义，MVC实现了业务逻辑和表示层的解耦。在MFC中，Doc/View(文档视图结构)提供了实现MVC的框架结构。还有在事件处理系统中也经常用到。 将一个系统分割成一系列相互协作的类有一个很不好的副作用，就是需要维护相关对象间的一致性。我们不希望为了维护一致性而使各类紧密耦合，这样会给维护，扩展和重用带来不便。 Observer模式要解决的问题为：建立一个一(Subject)对多(Observer)的依赖关系，并且做到\"一\"变化的时候，依赖这个\"一\"的多也能够同步改变。最常见的一个例子就是：对同一组数据进行统计分析时候，我们希望能够提供多种形式的表示(表格统计显示，柱状图统计显示，百分比统计显示)。这些表示都依赖于同一组数据，我们当然需要当数据改变的时候，所有的统计显示都能够同时改变。Observer模式就是解决这种一对多的依赖关系(耦合关系)的问题。 观察者模式 观察者模式又叫做发布-订阅(Publish/Subscribe)模式，目标就是通知的发布者，观察者则是通知的订阅者(接受通知)。 定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。   抽象主题(Subject):它把所有观察者对象的引用保存到一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加，删除观察者对象，并且提供了观察者同步的操作(Notify). 具体主题(ConcreteSubject):将有关状态引入具体观察者对象；在具体主题内部状态改变时，给所有登记过的观察者发出通知。 抽象观察者(Observer)：为所有具体观察者定义一个接口，在得到主题通知时更新自己。 具体观察者(ConcreteObserver):实现抽象观察者角色所要求的更新接口，以便使本身的主题状态协调。 Observer模式实现的要点是： 1.一般Subject类都是采用链表等容器来存放Observer对象 2.抽取出Observer对象的一些公共属性形成Observer基类，而Subject中保存的则是Observer类对象的指针，这样就使Subject和具体的Observer实现了解耦，也就是Subject不需要去关心到底是哪个Observer对放进了自己的容器中。  小demo Observer.h /********************************************************************\tcreated:\t2006/07/20\tfilename: \tObserver.h\tauthor:\t\t李创                http://www.cppblog.com/converse/\tpurpose:\tObserver模式的演示代码*********************************************************************/#ifndef OBSERVER_H#define OBSERVER_H#include <list>typedef int STATE;class Observer;// Subject抽象基类,只需要知道Observer基类的声明就可以了，可以译为主题或抽象通知者。//实现观察者模式的形式其实就是\"注册——通知——注销\"class Subject{public:\tSubject() : m_nSubjectState(-1){}\tvirtual ~Subject();\tvoid Notify();\t\t\t\t\t\t\t// 通知所有观察者对象\tvoid Attach(Observer *pObserver);\t\t// 新增一个观察者对象\tvoid Detach(Observer *pObserver);\t\t// 删除一个观察者对象\t// 虚函数,提供默认的实现,派生类可以自己实现来覆盖基类的实现\tvirtual void\tSetState(STATE nState)=0;\t// 设置状态\tvirtual STATE\tGetState()=0;\t\t// 得到状态protected:\tSTATE m_nSubjectState;\t\t\t\t\t// 模拟保存Subject状态的变量\tstd::list<Observer*>\tm_ListObserver;\t// 保存Observer指针的链表}; //Observe类，抽象观察者，为所有的具体观察者定义一个接口，在得到主题通知时更新自己。这个接口叫做更新接口。更新接口通常包含一个Update()方法，这个方法叫做更新方法class Observer{public:\tObserver() : m_nObserverState(-1){}\tvirtual ~Observer(){}\t// 纯虚函数,各个派生类可能有不同的实现\t// 通知Observer状态发生了变化\tvirtual void Update(Subject* pSubject) = 0;protected:\tSTATE m_nObserverState;\t\t\t\t\t// 模拟保存Observer状态的变量};// ConcreateSubject类,派生在Subject类，叫做具体主题或具体通知者class ConcreateSubject\t: public Subject{public:\tConcreateSubject() : Subject(){}\tvirtual ~ConcreateSubject(){}\t// 派生类自己实现来覆盖基类的实现,是成对出现的，由Subject来设置状态，由Observer来得到改变的状态\tvirtual void\tSetState(STATE nState);\t// 设置状态\tvirtual STATE\tGetState();\t\t// 得到状态};// ConcreateObserver类派生自Observerclass ConcreateObserver : public Observer {public: \tConcreateObserver():Observer(){}\tConcreateObserver(Subject* sub);//使用其构造函数，省去了在其外部调用sub->Attach\tvirtual ~ConcreateObserver(){}\t// 虚函数,实现基类提供的接口\tvirtual void Update(Subject* pSubject);};#endif   Observer.cpp /********************************************************************\tcreated:\t2006/07/20\tfilename: \tObserver.cpp\tauthor:\t\t李创                http://www.cppblog.com/converse/\tpurpose:\tObserver模式的演示代码*********************************************************************/#include \"Observer.h\"#include <iostream>#include <algorithm>/* --------------------------------------------------------------------|\tSubject类成员函数的实现  ----------------------------------------------------------------------*/void Subject::Attach(Observer *pObserver){\tstd::cout << \"Attach an Observer\\n\";\tm_ListObserver.push_back(pObserver);}void Subject::Detach(Observer *pObserver){\tstd::list<Observer*>::iterator iter;\titer = std::find(m_ListObserver.begin(), m_ListObserver.end(), pObserver);\tif (m_ListObserver.end() != iter)\t{\t\tm_ListObserver.erase(iter);\t}\tstd::cout << \"Detach an Observer\\n\";}void Subject::Notify(){\tstd::cout << \"Notify Observers's State\\n\";\tstd::list<Observer*>::iterator iter1, iter2;\tfor (iter1 = m_ListObserver.begin(), iter2 = m_ListObserver.end(); iter1 != iter2;++iter1)\t{\t\t(*iter1)->Update(this);\t}} Subject::~Subject(){\tstd::list<Observer*>::iterator iter1, iter2, temp;\tfor (iter1 = m_ListObserver.begin(), iter2 = m_ListObserver.end();iter1 != iter2;)\t{\t\ttemp = iter1;\t\t++iter1;\t\tdelete (*temp);\t}\tm_ListObserver.clear();}/* --------------------------------------------------------------------|\tConcreateSubject类成员函数的实现 ----------------------------------------------------------------------*/void ConcreateSubject::SetState(STATE nState){\tstd::cout << \"SetState By ConcreateSubject\\n\";\tm_nSubjectState = nState;\t//Notify();也可以写在内部，这样就不用每次调用SetState()后在调用Notify()}STATE ConcreateSubject::GetState(){\tstd::cout << \"GetState By ConcreateSubject\\n\";\treturn m_nSubjectState;}/* --------------------------------------------------------------------|\tConcreateObserver类成员函数的实现 ----------------------------------------------------------------------*/ ConcreateObserver::ConcreateObserver(Subject* sub) : Observer(){\tsub->Attach(this);}void ConcreateObserver::Update(Subject* pSubject){\tif (NULL == pSubject)\t\treturn;\tm_nObserverState = pSubject->GetState(); \tstd::cout << \"The ObeserverState is \" << m_nObserverState << std::endl;}   Main.cpp /********************************************************************\tcreated:\t2006/07/21\tfilename: \tMain.cpp\tauthor:\t\t李创                http://www.cppblog.com/converse/\tpurpose:\tObserver模式的测试代码*********************************************************************/#include \"Observer.h\"#include <iostream>int main(){\tSubject* p = new ConcreateSubject();\tObserver *p1 = new ConcreateObserver(p);\tObserver *p2 = new ConcreateObserver(p);//等价于Observer *p2 = new ConcreateObserver();\tp->Attach(p2); \tp->SetState(4);\tp->Notify();    std::cout<<\"-----------------------\"<<std::endl;\tp->Detach(p1);\tp->SetState(10);\tp->Notify();\tdelete p;\tsystem(\"pause\");\treturn 0;}/************************************************************************ 代码说明：在Observer模式的实现中，Subject维护一个List作为存储其所有观察者的容器。每当调用Notify操作就遍历List中Observer对象，并广播通知改变状态了(调用Observer的Update操作)。目标的状态state可以有Subject自己改变，也可以有Observer的某个操作引起state的改变(可调用Subject的SetState操作)当然，可以有多个Subject子类，和多个Observer的子类，也可以有多个要通知的消息。************************************************************************/  输出结果 观察者模式的实质 观察者模式所做的工作其实就是在解除耦合。让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响另一边的变化。 ","title":"[设计模式]Observer观察者模式"},{"content":"wireshark是非常流行的网络封包分析软件，功能十分强大。可以截取各种网络封包，显示网络封包的详细信息，Fiddler是在windows上运行的程序，专门用来捕获HTTP，HTTPS的。 wireshark能获取HTTP，也能获取HTTPS，但是不能解密HTTPS，所以wireshark看不懂HTTPS中的内容 总结，如果是处理HTTP,HTTPS 还是用Fiddler,  其他协议比如TCP,UDP 就用wireshark 开始界面 wireshark是捕获机器上的某一块网卡的网络包，当你的机器上有多块网卡的时候，你需要选择一个网卡。 点击Caputre->Interfaces.. 出现下面对话框，选择正确的网卡。然后点击\"Start\"按钮, 开始抓包     WireShark 主要分为这几个界面 1. Display Filter(显示过滤器)，  用于过滤 2. Packet List Pane(封包列表)， 显示捕获到的封包， 有源地址和目标地址，端口号。 颜色不同，代表 3. Packet Details Pane(封包详细信息), 显示封包中的字段 4. Dissector Pane(16进制数据) 5. Miscellanous(地址栏，杂项)   使用过滤是非常重要的， 初学者使用wireshark时，将会得到大量的冗余信息，在几千甚至几万条记录中，以至于很难找到自己需要的部分。搞得晕头转向。 过滤器会帮助我们在大量的数据中迅速找到我们需要的信息。 过滤器有两种， 一种是显示过滤器，就是主界面上那个，用来在捕获的记录中找到所需要的记录 一种是捕获过滤器，用来过滤捕获的封包，以免捕获太多的记录。 在Capture -> Capture Filters 中设置   在Filter栏上，填好Filter的表达式后，点击Save按钮， 取个名字。比如\"Filter 102\", Filter栏上就多了个\"Filter 102\" 的按钮。 表达式规则  1. 协议过滤 比如TCP，只显示TCP协议。 2. IP 过滤 比如 ip.src ==192.168.1.102 显示源地址为192.168.1.102， ip.dst==192.168.1.102, 目标地址为192.168.1.102 3. 端口过滤 tcp.port ==80,  端口为80的 tcp.srcport == 80,  只显示TCP协议的愿端口为80的。 4. Http模式过滤 http.request.method==\"GET\",   只显示HTTP GET方法的。  封包列表的面板中显示，编号，时间戳，源地址，目标地址，协议，长度，以及封包信息。 你可以看到不同的协议用了不同的颜色显示。 你也可以修改这些显示颜色的规则，  View ->Coloring Rules.   这个面板是我们最重要的，用来查看协议中的每一个字段。 各行信息分别为 Frame:   物理层的数据帧概况 Ethernet II: 数据链路层以太网帧头部信息 Internet Protocol Version 4: 互联网层IP包头部信息  Transmission Control Protocol:  传输层T的数据段头部信息，此处是TCP  Hypertext Transfer Protocol:  应用层的信息，此处是HTTP协议   从下图可以看到wireshark捕获到的TCP包中的每个字段。     看到这， 基本上对wireshak有了初步了解， 现在我们看一个TCP三次握手的实例    三次握手过程为   这图我都看过很多遍了， 这次我们用wireshark实际分析下三次握手的过程。 打开wireshark, 打开浏览器输入 地址 在wireshark中输入http过滤， 然后选中GET /tankxiao HTTP/1.1的那条记录，右键然后点击\"Follow TCP Stream\", 这样做的目的是为了得到与浏览器打开网站相关的数据包，将得到如下图 图中可以看到wireshark截获到了三次握手的三个数据包。第四个包才是HTTP的， 这说明HTTP的确是使用TCP建立连接的。   第一次握手数据包 客户端发送一个TCP，标志位为SYN，序列号为0， 代表客户端请求建立连接。 如下图 第二次握手的数据包 服务器发回确认包, 标志位为 SYN,ACK. 将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即0+1=1, 如下图 第三次握手的数据包 客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1, 如下图:  就这样通过了TCP三次握手。 完毕。","title":"wirshark 常用操作及 tcp 三次握手过程实例分析"},{"content":"IDR （Instantaneous Decoding Refresh）全称：即时解码刷新，    I和IDR帧都是使用帧内预测的。它们都是同一个东西而已,在编码和解码中为了方便，要首个I帧和其他I帧区别开，所以才把第一个首个I帧叫IDR，这样就方便控制编码和解码流程。IDR帧的作用是立刻刷新,使错误不致传播,从IDR帧开始,重新算一个新的序列开始编码。而I帧不具有随机访问的能力，这个功能是由IDR承担。IDR会导致DPB（参考帧列表——这是关键所在）清空，而I不会。IDR图像一定是I图像，但I图像不一定是IDR图像。一个序列中可以有很多的I图像，I图像之后的图像可以引用I图像之间的图像做运动参考。一个序列中可以有很多的I图像，I图像之后的图象可以引用I图像之间的图像做运动参考。      对于IDR帧来说，在IDR帧之后的所有帧都不能引用任何IDR帧之前的帧的内容，与此相反，对于普通的I-帧来说，位于其之后的B-和P-帧可以引用位于普通I-帧之前的I-帧。从随机存取的视频流中，播放器永远可以从一个IDR帧播放，因为在它之后没有任何帧引用之前的帧。但是，不能在一个没有IDR帧的视频中从任意点开始播放，因为后面的帧总是会引用前面的帧。","title":"h264 I帧， IDR帧笔记"},{"content":"void test_foreach(){\tusing namespace boost::assign;\tstd::vector<int> v;\tv += 1, 2, 3, 4, 5, 6, 7, 8, 9;\tBOOST_FOREACH(int x, v)\t{\t\tstd::cout << x << \", \";\t}\tstd::cout << std::endl;\tstd::string str(\"boost foreach\");\tBOOST_FOREACH(char& x, str)\t{\t\tstd::cout << x << \"-\";\t}\tstd::cout << std::endl;}void test_minmax(){\tstruct Comp\t{\t\tbool operator()(const std::string &a, const std::string &b)\t\t{\t\t\treturn (a < b) || (b.find(\"BOSS\") != std::string::npos);\t\t}\t};\tstd::string s1(\"5000\"), s2(\"123BOSS\");\tBOOST_AUTO(x, minmax(s1, s2)); \tstd::cout << x.second << \" \" << x.first << std::endl;\tBOOST_AUTO(y, minmax(s1, s2, Comp())); \tstd::cout << y.second << \" \" << y.first << std::endl;}void test_minmax_element(){\tstd::vector<int> v = boost::assign::list_of(633)(90)(67)(83)(2)(100);\tBOOST_AUTO(x, boost::minmax_element(v.begin(), v.end()));\tstd::cout << \"min: \" << *x.first << std::endl;\tstd::cout << \"max: \" << *x.second << std::endl;}","title":"【Boost】boost::algorithm的几个简单例子"},{"content":"在开发传统Notes客户机应用时，校验是最常见的功能需求之一。在检查一张表单的输入时，能够使用的方法和呈现给用户的方式很有限。一般我们不会使用域的输入验证公式，因为那样做太分散、重复又不够灵活。更好的方案是将所有的检查集中在一起，在文档保存或者执行某个操作时调用。校验有可能包含对输入做各种检查，最普遍的还是简单的非空性检查。对此，我们可以写一个简单的校验类： Private Const MESSAGE=\"Please input the field \"Public Class Validator\tPrivate fields List As String\tPrivate m_uidoc As NotesUIDocument\tPrivate m_doc As NotesDocument\t\tPublic Sub new()\t\tDim ws As New NotesUIWorkspace\t\tSet m_uidoc=ws.CurrentDocument\t\tSet m_doc=m_uidoc.Document\tEnd Sub\t\tPublic Sub Add(fieldName As String,label As String)\t\tIf label=\"\" Then\t\t\tlabel=fieldName\t\tEnd If\t\tfields(label)=fieldName\tEnd Sub\t\tPublic Function Validate() As Boolean\t\tForall f In fields\t\t\tIf m_uidoc.FieldGetText(f)=\"\" Then\t\t\t\tMessagebox MESSAGE & {\"} & Listtag(f) & {\"},64,\"Lotus Notes\"\t\t\t\tIf m_uidoc.EditMode Then\t\t\t\t\tCall m_uidoc.GotoField(f)\t\t\t\tEnd If\t\t\t\tValidate=False\t\t\t\tExit Function\t\t\tEnd If\t\tEnd Forall\t\tValidate=True\tEnd FunctionEnd Class 在这个类中，Add()方法像要检查的域名和对应的对用户的名称添加到一个List中。Validate()方法检查这些域的值是否为空；如果是，则给用户一个提示，将焦点转移到该域中，并返回False；如果所有域值都不为空，就返回True。这样调用的程序就可以根据Validate()方法的结果判断是否继续执行以后的逻辑。 下面这段代码就是在一个文档的Querysave事件中根据条件添加了若干个需要校验的域，并且根据校验的结果决定是否保存文档。 Sub Querysave(Source As NotesUIDocument, Continue As Variant)\tDim validator1 As New Validator()\tWith validator1\t\tCall .Add(\"ActionName\",\"Action Name\")\t\tCall .Add(\"NodeName\",\"Node Name\")\t\t\t\tIf Source.FieldGetText(\"MultipleNext\")=\"\" Then\t\t\tCall .Add(\"NextNode\",\"Next Node\")\t\tEnd If\t\t\t\tIf source.FieldGetText(\"NeedExpression\")><\"\" Then\t\t\tCall .Add(\"Expression\", \"Action Expression\")\t\tEnd If\t\t\t\tIf Source.FieldGetText(\"NeedMail\")=\"1\" Then\t\t\tCall .Add(\"Subject\",\"Mail Subject\")\t\tEnd If\t\t\tEnd With\tIf Not validator1.Validate() Then\t\tContinue=False\tEnd IfEnd Sub","title":"19. Notes客户机中的校验"},{"content":"美国人的工资高，用于生活必需品的消费又比较少，到头来还欠了一屁股债，那么，他们的钱都到哪里去了呢？用一个非常形象的描述就是，主要花在个人生活的“维稳”费用上了。 美国人用在生活必需品上的消费很少，100美元能从超市里推出一车鸡鸭鱼肉，再加上水果蔬菜，足够三口之家过1周。那么，其余的钱都花在什么地方呢？通常在两个方面，一个是供房子，一个是付保险费。 房子就像是一个家庭的金融蓄水池。美国人宁愿欠一屁股债也要买房，就是因为房子会涨价。为什么从长期来看房子一定会涨价？这是因为适度通胀可以促进经济发展，所以美国政府会有意保持低通胀，这样对经济有利。只要有通胀就一定会涨价。而事实表明，假如在没有遇到经济大萧条的时候卖房子，一套30年前欠了一屁股债的房子，30年以后卖掉所得的钱，减去所有在这套房子上的支出，最后肯定是有钱可赚的。 为什么能这么肯定？因为美国人房子下面的土地有永久的产权，而人类对土地的需求肯定是增加的，因此价格肯定会上涨。随着建筑物的老化贬值，土地价格的上涨会进行弥补。很多时候出售一套房子的本质就是出售土地，买房的人会马上拆掉重建，这个特点在加拿大温哥华的西区非常明显。房子只要超过70年，一般都会被推倒重建，70年前值几万块钱的房子，现在可能一文不值，但是卖出的价格依然可达150万左右。推倒了重建，建房成本不到200万，而周围同样的房子标价都已经接近400万加币了。所以，很多来这里的华人就开始干这个事情，不过由于华人并不熟悉建筑标准，也会有没搞好亏本的现象。 如果你真的没钱了，换小一点的房子，或者换便宜一点的学区，用差价补贴家用完全可以。而在中国，存在70年产权大限，房子越住就越不值钱，买房子不能有长远打算，在这种情况下政府还好意思收什么地产税？简直就是抢钱。在这里，人们心安理得地交税是因为房子会增值，而且自住房还有大约三分之一的折扣，总共税率不到地产估价的百分之五。这钱要是还不愿意交的话，还免费享受那么多的城市福利。 而保险是美国人的另一个财富蓄水池。这个社会靠保险，保险公司靠再保险来逐级分散风险，支付最少的费用来保障自己面临任何灾难的时候生活状态不会发生变化。而这样的日子会让人过得特别安心，每个月把钱花光了心里也不会发毛，所以美国的内需特别大，有钱拼命花，要不他们觉得放着贬值太亏得慌。 在美国人的收入当中真正拿到手的是要扣除个人所得税和失业保险费，还有牙医保险等的。其实除了个人需要支付医疗保险以外，政府的税收本身就有保险的性质，因为当一个纳税人生病的时候政府有巨额的补贴，人到了退休年龄是按照你的养老保险所缴付的金额来领取的，交的税多，你领的就多，所以你交多了一点也不亏。甚至一个美国公民在世界的任何地方出了事，政府都会出面相救。中国也就是在一些需要宣传的大事情上政府会出面，一个普通草民，遇上普通的事件，就不好说了。 保险系统就是一个互助会，尽管保险项目多如牛毛，但是主要的项目是车险、寿险、养老险、医疗险、失业险、房屋险等。当你交完这些保险费以后，发现留着钱也没用了。所以或者加快付房款的步伐，或者出去奢侈旅游，反正要把它花光。这是中国人办不到的，中国人存钱是自己给自己上保险，这效率多低呀。你觉得自己很有钱吗？一个小小的事故，一场稍微大一点的病就足让你一夜回到解放前。 房子和保险如何起到金融蓄水池的作用呢？在你真的需要钱来周转的情况下，这两样东西都能作为抵押物从银行轻易地贷出款来。房子可以抵押似乎好理解，但很多中国人可能不知道，险单抵押在国外也非常普遍，因为每一张险单都是有价值的，其中主要是寿险的险单。根据每一张保单的现金值，更准确地说是你的退保金额，银行甚至1天之内就可以把钱打给你，等你有钱了再连本带息还给银行，没钱了，保险公司可以把保单废掉，替你把钱还上，多么合理的运作体系呀。 一个真正的和谐社会，人心是稳定的，在这里要是有一套已经付清款的房子，或是一份稳定的工作，那简直就是神仙，你要让他造反，有可能吗？政府税收不必用于政治维稳，仅仅是用于百姓生活的维稳，同时根据每个阶层经济能力的差别，民间有更多维稳的产品。因为政治稳定，政府才会将财富分散到民众手里，而民众的人心稳定导致他们把手里所有的现金都放出来，让这部分现金配置到合理的地方，健康地运转。 美国乃至西方发达国家稳定运作了几百年时间，肯定有它们合理的地方。如果中国人听信那些不符合客观事实的说法，说西方人靠掠夺致富，那么你肯定就会忽略很多人家合理的地方，你就会错过学习别人的机会。致富只是一个幻觉问题，难道中国真的富了吗？因为社会生产效率在整体向前发展，所谓富裕可能只是相对于自己的过去而言，而西方发达国家同时也在发展，从综合角度来看，中国与西方发达国家的差距缩小得其实并不明显，而自然环境的差距却变成天壤之别。","title":"美国人的钱大都花到哪里去了"},{"content":"        面向对象设计，一个必不可少的步骤是“实例化”，如果将实例化与具体的实现紧密地结合在一起……简单的创建，当然这是没有问题的，但是，如果我们不是简单的创建呢，我们需要改变具体的算法，需要扩展算法的种类，需要系统在改变之后还是以前的样子运行！那么，问题就会变得复杂，多变！         在创建型的几个设计模式中，将具体算法的实现与实例化分离，工厂方法是这方面的典范，其他的创建型设计模式起到扩展和辅助的作用！             在书中举得那些例子，都很有趣，大家可以好好看看，在这里咱们说说一些扩展的知识。           反射：我个人肤浅的理解是，应用程序在运行时，可以动态地获得一个类型的属性，方法，事件等信息，这样就可以在工厂中动态地创建一个对象了！           c#代码： Assembly.Load(\"程序集\") //Assembly.LoadFile(\"外部调用的动态库\")加载程序集,返回类型是一个Assembly           实际应用：     //引入反射using System.Reflection;//引入config配置文件using System.Configuration ;  //反射优化抽象工厂    //根据配置文件选择创建查询方式    class DateAccess    {        private static readonly string AssemblyName = \"shujuku\";        //利用配置文件:1,添加引用system.configuration ; 2, using system.configuration         //读取配置文件app.config里的DB        private static readonly string db = ConfigurationManager.AppSettings[\"DB\"];        //private static readonly string db = \"Sqlserver\";        //静态函数创建用户表        public static IUser CreateUser()        {            string classname = AssemblyName + \".\" + db + \"User\";\t\t\t\t//利用反射创建对象            return (IUser)Assembly.Load(AssemblyName).CreateInstance(classname);        }        //静态函数创建表        public static IDepartment  CreateDepartment()        {            string classname = AssemblyName + \".\" + db + \"Department\";\t\t\t\t//利用反射创建对象            return (IDepartment )Assembly.Load(AssemblyName).CreateInstance(classname);        }    }             在程序设计中，创建型模式已经给我们带来了意想不到的好处，让我们的工作更轻松，简单，但是不要忘了一种模式只是解决一种特定的问题，下次我们将介绍更多的模式，解决更多的问题！","title":"[置顶] 设计模式初探（二）——既然创建时必然的，所以它独立了！"},{"content":"近几年，中国人、印度人和前苏联人在华尔街形成了三大群体，占华尔街总人数的百分之二十五。但有所不同的是，印度人和前苏联人擅长团体作战，中国人则倾向单打独斗。 近两三年，华尔街可谓血雨腥风，哀鸿遍野。几乎每家银行都成了“总裁”--总在裁员。我直接、间接的朋友中，大约有三十来人丢了工作。前几天，其中的一位朋友来电话，谈起找工作的近况。他绝望地说，每一次第一轮面谈感觉都不错，但第二轮面谈总被刷下来，究其缘由，竟然是因为自己不是印度人，也不是前苏联人！ 他一说我立刻明白。华尔街第一轮面谈，通常都是人事部门或未来的顶头上司先约见，这些行政主管或者项目经理大部分是白人，只看应聘者是否符合要求、是否顺眼。第二轮面谈就轮到技术主管或者部门的技术骨干来“拷问”了。中国人去应聘，白人这一关轻轻松松就过了，但第二轮如果是印度人或者前苏联人，他们便会“朝死里整”,届时向经理说声这个人不合适，中国人自然出局。 印度人不甘心只做普通技术或业务员工，他们的眼睛还会紧紧地盯住管理阶层。在华尔街，一旦一个印度的技术业务高手进入一个部门，就会再招聘两三个助手，也是印度人；新手一两年后出头，然后再带新人。于是，他们的职位就像搭人梯那样渐渐地向上升，到后来，最早进去的那位当上部门经理，甚至更高位置，便掌握了整个部门的用人权。再过不了多久，他的下级中印度人越来越多，并逐渐把其他族裔的员工排挤出这个行业。所以，中国人在华尔街找工作面谈时，只要见到印度人，心里就会嘀咕：“肯定没机会了，印度人不往死里整你是绝不会罢手的。”因为，他们一定要留住这个位置来安顿自己的同胞。 华尔街上流传这样一种说法，上半句是：一个印度人做了头儿，第二年他手下全是印度人。下半句和我们中国人有关：一个中国人当了头儿，第二年他周围就剩他自己了。这话虽然不动听，却一点儿都不夸张。讲一个我自己的跳槽故事吧。 多年前，花旗的投行所罗门美邦（SalomonSmithBarney）招人，那时的花旗如日中天，我觉得机会非常不错，立刻申请，不久就得到了面谈的机会。安排我前去面谈的猎头名叫韩伍，他说一看我履历上的名字便知我是中国人，并告知他是越南人，然后绘声绘色地向我详细介绍道：“我的头儿一看你的履历，就觉得你是非常有希望的候选人。你以前的经验符合他们的标准，而且你要去的那个组，头儿也是中国人，苏博士，技术水平相当高，去年升上去的。你们背景相似，都是从中国来的……” 那天，我怀着与韩伍相同的愿望去了花旗。第一轮面谈采用“PanelInterview”（多人同时面谈）的形式，我们这一批共三个组员，一个老美，一个印度人，还有一个中国人山姆。由于有一个老美在场，那个印度人比较“客气”,这一轮谈下来双方感觉都挺好。韩伍兴致更高了，立刻安排了第二次面谈，见组长，也就是那位苏博士。 见苏博士的前一晚，韩伍又在我临睡前来电话。我好奇地问他是不是还在公司忙，他回答是，不忙不行啊。他说：“听苏博士讲，别的猎头给他送去一个老美，但我们觉得你的希望还是最大，你的实力强过那个老美。”我自己也信心满满，花旗那个位置的业务领域是我熟悉的，而使用的技术更是我的强项。 第二次去花旗，我特意早到了十五分钟，我在会客室等得不耐烦，便伸出头去四下张望，见到了前一次那个叫山姆的组员，他正巧来到门口冲咖啡。看到熟悉的面孔，又是同根同种，我自然地流露出一副热乎劲儿。刚跨出一步想同他套近乎，没想到他看到我跟见了鬼似的，立刻慌里慌张地躲开了，简直莫名其妙！不过，那位苏博士组长倒还好，他浑身散发着书生气，跟我想象的差不多，我们谈得不错。 那晚我等着韩伍的电话，我估计他会安排第三次面谈--去见花旗的部门经理。可电话没有如期而至。第二天中午我正吃着午餐，听到电话铃声，我将一口还来不及下咽的饭吐在盘子里，急忙去接听，是韩伍！ 他开口便质问：“我真搞不懂你们中国人，太奇怪了。明明你最适合那个位置，苏博士却说你不合适，我逼问了他半天，他说顾忌再聘用一位中国人有抱团儿的嫌疑。我的头儿听了之后气坏了，这算什么理由？好端端的一单生意弄丢了。” 我很失望，更无力回答他的问题。抱团儿工作是件好事，中国人为什么要自我心虚？我们中国人如果在外面都不帮自己人，特别在当下的艰难时刻不“抱团儿取暖”,那指望谁来帮你呢？ 这次华尔街的大裁员，更使得中国人大量流失，那电脑软件系统和衍生证券模型原先的三分天下，不久将成为印度人和前苏联人的地盘。","title":"为什么华尔街不会成为中国人的地盘"},{"content":"1.实现的map类                                                                                                                                                                                                                                                                              这个类实现 Mapper 接口中的 map 方法，输入参数中的 value 是文本文件中的一行，利用StringTokenizer 将这个字符串拆成单词，然后将输出结果org.apache.hadoop.mapred.OutputCollector 中。OutputCollector 由 Hadoop框架提供, 负责收集 Mapper 和 Reducer 的输出数据，实现 map 函数和 reduce 函数时，只需要简单地将其输出的对往 OutputCollector 中一丢即可，剩余的事框架自会帮你处理好。 代码如下：     import java.io.IOException;      import java.util.StringTokenizer;             import org.apache.hadoop.io.IntWritable;      import org.apache.hadoop.io.LongWritable;      import org.apache.hadoop.io.Text;      import org.apache.hadoop.mapreduce.Mapper;           public class classCountWordMaper extends Mapper<LongWritable, Text, Text, IntWritable> {              @Override           protected void map(LongWritable key,Text value,                           Context context)                           throws IOException,InterruptedException {                            String text=value.toString();                            StringTokenizer tokens=new StringTokenizer(text);                            while(tokens.hasMoreTokens()){                                    String str=tokens.nextToken();                                    context.write(new Text(str), new IntWritable(1));                            }                          }           }  2.实现reduce类 这个类实现 Reducer 接口中的 reduce 方法, 输入参数中的 key, values 是由 Map任务输出的中间结果，values 是一个 Iterator, 遍历这个 Iterator, 就可以得到属于同一个 key 的所有 value.此处，key 是一个单词，value 是词频。只需要将所有的 value 相加，就可以得到这个单词的总的出现次数。 代码如下：    import java.io.IOException;     import java.util.Iterator;           import org.apache.hadoop.io.IntWritable;     import org.apache.hadoop.io.Text;     import org.apache.hadoop.mapreduce.Reducer;          public class classCountWordReducer extends Reducer<Text, IntWritable, Text, IntWritable> {               @Override            protected void reduce(Text key,Iterable<IntWritable> values, Context context)                           throws IOException,InterruptedException {                   int total=0;                    Iterator<IntWritable>it=values.iterator();                    while(it.hasNext()){                           it.next();                            ++total;                    }                   context.write(key, new IntWritable(total));             }           }  3.由于reduce默认的是对key进行升序排列，而我们要实现降序排列，所以就要实现一个类 import org.apache.hadoop.io.IntWritable.Comparator;import org.apache.hadoop.io.WritableComparable;public class IntWritableDecreasingComparator extends Comparator {    public int compare(WritableComparable a,WritableComparable b){        return -super.compare(a, b);            }    @Override    public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) {        // TODO Auto-generated method stub        return -super.compare(b1, s1, l1, b2, s2, l2);    }    } 4.主程序：      定义了2个job，第一个job是对数据进行词频统计，并且把结果输入到临时文件当中，然后利用mapreduce的管道功能，再递交第二个job，将第一个job 的输出作为第二个排序任务的输入，注意要文件读入的格式一定要符合数据类型。第二个job通过调用系统给出的jobsort.setMapperClass(InverseMapper.class); 作为map函数，reduce利用默认IdentityReducer讲最后map输出的结果输出到输出文件当中。 代码如下： import java.io.IOException;  import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.FileSystem;import org.apache.hadoop.fs.Path;  import org.apache.hadoop.io.IntWritable;  import org.apache.hadoop.io.SequenceFile;import org.apache.hadoop.io.Text;  //import org.apache.hadoop.mapred.TextInputFormat;//import org.apache.hadoop.mapred.KeyValueTextInputFormat;import org.apache.hadoop.mapreduce.Job;  import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;  import org.apache.hadoop.mapreduce.lib.map.InverseMapper;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;  import org.apache.hadoop.mapreduce.lib.output.SequenceFileOutputFormat;import org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;import org.apache.hadoop.mapreduce.lib.input.SequenceFileInputFormat;import org.apache.hadoop.mapreduce.lib.input.TextInputFormat;   public class classCountWord {             public static void main(String[] args)throws IOException, InterruptedException, ClassNotFoundException {                                          Job job=new Job();                    job.setJarByClass(classCountWord.class);                   Path tempath=new Path(args[1]);                 Configuration conf=new Configuration();                  FileInputFormat.addInputPath(job,new Path(args[0]));                   FileSystem.get(conf).delete(tempath);                  FileOutputFormat.setOutputPath(job,tempath);                                       job.setMapperClass(classCountWordMaper.class);                    job.setReducerClass(classCountWordReducer.class);                                       job.setOutputKeyClass(Text.class);                    job.setOutputValueClass(IntWritable.class);                                        job.setOutputFormatClass(SequenceFileOutputFormat.class);                   job.waitForCompletion(false);                                   System.out.println(\"开始第二个任务\");                  Job jobsort=new Job();                                    FileInputFormat.addInputPath(jobsort, tempath);                 jobsort.setOutputKeyClass(IntWritable.class);                 jobsort.setOutputValueClass(Text.class);                 jobsort.setInputFormatClass(SequenceFileInputFormat.class);                                  jobsort.setMapperClass(InverseMapper.class);                 jobsort.setNumReduceTasks(1);                 Path result=new Path(\"/home/hadoop/result\");                 FileSystem.get(conf).delete(result);                 FileOutputFormat.setOutputPath(jobsort, result);                 jobsort.setSortComparatorClass(IntWritableDecreasingComparator.class);                                 jobsort.waitForCompletion(false);                                              }     }   注意：写程序的时候遇到的问题： java.io.IOException: Type mismatch in key from map: expected org.apache.hadoop.io.IntWritable, recieved org.apache.hadoop.io.Text         问题在于第二个任务读取第一个任务的输出结果的格式不对。因为默认的输出是TextOutputFormat,但是import org.apache.hadoop.mapreduce.lib.input包中没有TextInputFormat,所以出现格式不匹配的错误，后来我把第一个任务的输出格式和第二个任务读取数据的格式都设置成 job.setOutputFormatClass(SequenceFileOutputFormat.class); jobsort.setInputFormatClass(SequenceFileInputFormat.class);        后来程序就通了，希望大家少走弯路，能够对大家有点帮助，有问题欢迎指正~~~","title":"mapreduce 利用InverseMapper.class对key,value进行 交换实现词频排序 ."},{"content":"#!/usr/bin/python                                               #py文件#coding:utf8from mod_python import apache,utilimport MySQLdbfp = file(\"/var/www/html/disp.html\",\"r\")#导入模板html = fp.read()\t\t\t\t\t\t#渲染htmlconn = MySQLdb.connect(host=\"localhost\",user=\"root\",passwd=\"\",db=\"dragon\")#创建游标def handler(req):\t\t\t\t\t\t#处理器\trequ = util.FieldStorage(req)\treq.content_type = \"text/html\"\tact = requ.get(\"act\",\"disp\")\tif act ==\"disp\":\t\t\t\t\t#显示\t\thtml=disp() \telif act ==\"save\":\t\t\t\t\t#增加\t\tuname=requ.get('uname','nobody')\t\t\tsaveemp(uname)\t\thtml=disp()\telif act ==\"del\":\t\t\t\t\t#删除\t\tuid=requ.get('id',0)\t\t\tdelemp(uid)\t\thtml = disp()\treq.write(html)\treturn apache.OKdef disp():\t\t\t\t\t\t\t#显示\tcursor = conn.cursor()\tcursor.execute(\"select * from employee\")\temps = cursor.fetchall()\ts=\"\"\tfor id,name in emps:\t\ts += \"<div><span id='empid'>\"+str(id) +\"<\/span><span id='uname'>\" + name + \"<\/span><span><a href='?act=del&id=\"+str(id)+\"'>del<\/a><\/span><\/div>\"\treturn html%sdef saveemp(uname):\t\t\t\t\t\t#增加\tcursor = conn.cursor()\tcursor.execute(\"insert into employee(name) values(%s)\",(uname))\treturn html\tdef delemp(uid):\t\t\t\t\t\t#删除\tcursor = conn.cursor()\tcursor.execute(\"delete from employee where (id=%s)\",uid)#根据id删除\treturn html <?xml version=\"1.0\" encoding=\"UTF-8\"?>                          <!--disp.html--><!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"><html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\"><head>\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\t<title><\/title><\/head><body><div id=\"emplist\">%s<\/div><div><input type=\"button\" value=\"add\" onclick=\"location.href='add.html?act=save'\" /><\/div><\/body><\/html> <?xml version=\"1.0\" encoding=\"UTF-8\"?>                          <!--add.html--><!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"><html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\"><head>\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\t<title><\/title><\/head><body><form action=\"mptest.py\">name:<input type=\"text\" name=\"uname\" /><br /><input type=\"hidden\" name=\"act\" value=\"save\" /><input type=\"submit\" value=\"ok\" /><\/form><\/body><\/html>","title":"mod_python"},{"content":"一、适用场景     首先，必须明确一点，线程池不是万能的，它有其特定的使用场景。使用线程池是为了减小线程本身的开销对应用性能所产生的影响，但是其前提是线程本身创建、销毁的开销和线程执行任务的开销相比是不可忽略的。如果线程本身创建、销毁的开销对应用程序的性能可以忽略不计，那么使用/不使用线程池对程序的性能并不会有太大的影响。     线程池通常适合以下几种场景：         ①、单位时间内处理的任务频繁，且任务时间较短         ②、对实时性要求较高。如果接收到任务之后再创建线程，可能无法满足实时性的要求，此时必须使用线程池。         ③、必须经常面对高突发性事件。比如Web服务器。如果有足球转播，则服务器将产生巨大冲击，此时使用传统方法，则必须不停的大量创建、销毁线程。此时采用动态线程池可以避免这种情况的发生。 二、代码实现 2.1 头文件 #if !defined(__THREAD_POOL_H__)#define __THREAD_POOL_H__#include <stdio.h>#include <stdlib.h>#include <string.h>#include <unistd.h>#include <memory.h>#include <pthread.h>#include <sys/types.h>// 布尔类型typedef int bool;#define false (0)#define true  (1)/* 线程任务链表 */typedef struct _thread_worker_t{\tvoid *(*process)(void *arg);  /* 线程处理的任务 */\tvoid *arg;                    /* 任务接口参数 */\tstruct _thread_worker_t *next;/* 下一个节点 */}thread_worker_t;/* 线程池对象 */typedef struct{\tpthread_mutex_t queue_lock;   /* 队列互斥锁 */\tpthread_cond_t queue_ready;   /* 队列条件锁 */\tthread_worker_t *head;        /* 任务队列头指针 */\tbool isdestroy;               /* 是否已销毁线程 */\tpthread_t *threadid;          /* 线程ID数组 —动态分配空间 */\tint num;                      /* 线程个数 */\tint queue_size;               /* 工作队列当前大小 */}thread_pool_t;/* 函数声明 */extern int thread_pool_init(thread_pool_t **pool, int num);extern int thread_pool_add_worker(thread_pool_t *pool, void *(*process)(void *arg), void *arg);extern int thread_pool_destroy(thread_pool_t *pool);#endif /*__THREAD_POOL_H__*/ 2.2 函数实现 /************************************************************* **功  能：线程池的初始化 **参  数： **    pool：线程池对象 **    num ：线程池中线程个数 **返回值：0：成功 !0: 失败 *************************************************************/int thread_pool_init(thread_pool_t **pool, int num){\tint idx = 0;    /* 为线程池分配空间 */\t*pool = (thread_pool_t*)calloc(1, sizeof(thread_pool_t));\tif(NULL == *pool)\t{\t\treturn -1;\t}    /* 初始化线程池 */\tpthread_mutex_init(&((*pool)->queue_lock), NULL);\tpthread_cond_init(&((*pool)->queue_ready), NULL);\t(*pool)->head = NULL;\t(*pool)->num = num;\t(*pool)->queue_size = 0;\t(*pool)->isdestroy = false;\t(*pool)->threadid = (pthread_t*)calloc(1, num*sizeof(pthread_t));\tif(NULL == (*pool)->threadid)\t{\t\tfree(*pool);\t\t(*pool) = NULL;\t\treturn -1;\t}    /* 依次创建线程 */\tfor(idx=0; idx<num; idx++)\t{\t\tpthread_create(&((*pool)->threadid[idx]), NULL, thread_routine, *pool);\t}\treturn 0;} /************************************************************* **功  能：将任务加入线程池处理队列 **参  数： **    pool：线程池对象 **    process：需处理的任务 **    arg: process函数的参数 **返回值：0：成功 !0: 失败 *************************************************************/int thread_pool_add_worker(thread_pool_t *pool, void *(*process)(void *arg), void *arg){\tthread_worker_t *worker=NULL, *member=NULL;\t\tworker = (thread_worker_t*)calloc(1, sizeof(thread_worker_t));\tif(NULL == worker)\t{\t\treturn -1;\t}\tworker->process = process;\tworker->arg = arg;\tworker->next = NULL;\tpthread_mutex_lock(&(pool->queue_lock));\tmember = pool->head;\tif(NULL != member)\t{\t\twhile(NULL != member->next) member = member->next;\t\tmember->next = worker;\t}\telse\t{\t\tpool->head = worker;\t}\tpool->queue_size++;\tpthread_mutex_unlock(&(pool->queue_lock));\tpthread_cond_signal(&(pool->queue_ready));\treturn 0;} /************************************************************* **功  能：线程池的销毁 **参  数： **    pool：线程池对象 **返回值：0：成功 !0: 失败 *************************************************************/int thread_pool_destroy(thread_pool_t *pool){\tint idx = 0;\tthread_worker_t *member = NULL;\tif(false != pool->isdestroy)\t{\t\treturn -1;\t}\tpool->isdestroy = true;\tpthread_cond_broadcast(&(pool->queue_ready));\tfor(idx=0; idx<pool->num; idx++)\t{\t\tpthread_join(pool->threadid[idx], NULL);\t}\tfree(pool->threadid);\tpool->threadid = NULL;\twhile(NULL != pool->head)\t{\t\tmember = pool->head;\t\tpool->head = member->next;\t\tfree(member);\t}\tpthread_mutex_destroy(&(pool->queue_lock));\tpthread_cond_destroy(&(pool->queue_ready));\tfree(pool);\t\treturn 0;} /************************************************************* **功  能：线程池各个线程入口函数 **参  数： **    arg：线程池对象 **返回值：0：成功 !0: 失败 *************************************************************/static void *thread_routine(void *arg){\tthread_worker_t *worker = NULL;\tthread_pool_t *pool = (thread_pool_t*)arg;\twhile(1)\t{\t\tpthread_mutex_lock(&(pool->queue_lock));\t\twhile((false == pool->isdestroy) && (0 == pool->queue_size))\t\t{\t\t\tpthread_cond_wait(&(pool->queue_ready), &(pool->queue_lock));\t\t}\t\tif(false != pool->isdestroy)\t\t{\t\t\tpthread_mutex_unlock(&(pool->queue_lock));\t\t\tpthread_exit(NULL);\t\t}\t\tpool->queue_size--;\t\tworker = pool->head;\t\tpool->head = worker->next;\t\tpthread_mutex_unlock(&(pool->queue_lock));        /* 执行队列中的任务 */\t\t(*(worker->process))(worker->arg);\t\tfree(worker);\t\tworker = NULL;\t}} 三、函数调用 #define THREAD_MAX_NUM (32)#define SLEEP\t(10)int myprocess(void *arg){\tfprintf(stdout, \"[%s][%d] threadid:%d arg:%d\", __FILE__, __LINE__, pthread_self(), *(int*)arg);\treturn 0;}int main(void){\tint ret=0, idx=0;\tthread_pool_t *pool = NULL;\tint array[THREAD_MAX_NUM] = {0};\tret = thread_pool_init(&pool, THREAD_MAX_NUM);\tif(ret < 0)\t{\t\treturn -1;\t}\tfor(idx=0; idx<THREAD_MAX_NUM; idx++)\t{\t\tarray[idx] = idx;\t\tthread_pool_add_worker(pool, myprocess, &array[idx]); /* 注意：地址各不相同 */\t}\tsleep(SLEEP);\tthread_pool_destroy(pool);\tpool = NULL;\treturn 0;}","title":"[置顶] 通用线程池的设计和实现[C语言实现]"},{"content":"内容摘要：谷歌在硬件方面的野心愈渐清晰，而其亲自操刀上网本的行为尽管被认为是大势所趋，但如何向自己的Android阵营伙伴交待，也着实让人头疼。 谷歌有意亲力亲为发扬光大。 日前，有国外媒体报道称，谷歌打算推出自有品牌的基于Chrome OS系统的上网本，它将配备触摸屏。但与之前的Nexus的推出方式不同，谷歌此次将不通过宏碁或华硕等第三方出货，而是直接从代工厂商处订购产品，自己开拓品牌市场。 有消息称，此次为谷歌代工的很可能是台湾仁宝公司，上网本的内部配件已经运往该公司，Chrome OS将在今年底或者明年初面世。 Chrome OS是基于Chrome浏览器开发而成，以Web体验为主，对硬件需求相对较低，因此其对用户而言可能是一个完美的休闲计算平台。不过，由于Chrome OS将支持触屏，所以这款上网本售价会比新款的三星和宏碁的Chromebook笔记本要高一些。 谷歌亲自操刀Chrome OS上网本，让其合作伙伴很受伤。   在此次亲自上阵之前，Chrome OS上网本似乎只是谷歌的业余爱好--谷歌此前从未真正推广过Chrome OS上网本。而在推出自有品牌产品之后，谷歌可能会加大Chrome OS上网本的推广力度。 有观点认为，谷歌此举不失明智，既有助于Chrome OS平台吸引更多用户，也有助于加强自己的硬件产业链。 然而，对于已经逐渐退出历史舞台的上网本，谷歌还如此费心费力地大力推广，起死回生的希望究竟有几何？谷歌未来又能否借助Chrome OS上网本和其他笔记本厂商们一较高下呢？ 不温不火 谷歌自有品牌Chrome笔记本的诞生要从两年前说起。 2010年12月，谷歌推出了代号为Cr-48的Chrome OS系统笔记本电脑，但没有面向普通消费者销售，只是对特定人群进行了小规模试用。根据谷歌方面的介绍，当时其送出Cr-48达到数千台，也得到了用户的广泛好评，包括奥兰多市政府在内的众多商业用户愿意接受Chrome OS. 在半年之后的2011年谷歌I/O开发者大会上，谷歌发售了两款基于Chrome OS的笔记本Chromebook,谷歌品牌的笔记本由此正式进入普通消费者的视野。据悉，这两款产品分别出自三星和宏碁，都采用英特尔Atom双核处理器，都能够在8秒钟内快速启动。自此之后，谷歌一直在悄悄地发布新版本，同时不断扩大经销渠道。最新上市的三星Series 3和宏碁C7都是很不错的产品，249美元和199美元的售价也相当具有竞争力。 而此次谷歌发布最新款的Chrome OS上网本，最让业界侧目的是其抛开之前合作多时的\"亲密伙伴\",直接和代工厂合作。有境外分析人士指出，在此前相当长的时间里，谷歌都是依靠合作伙伴来生产硬件，其目标是将软件放到用户手中，并不在意硬件是否能够赚钱，此次和代工厂的合作，很可能意味着谷歌日后将会减少硬件合作伙伴的数量，即使硬件利润微薄，也要留给自己。对谷歌而言，Android已成为市场份额最大的智能手机平台，Nexus系列产品的火爆销售表明其硬件之路也许有着相当不错的前景。 当今全球的硬件市场格局正处在改变之中：微软已经开始出售自己的平板电脑Surface;诺基亚正在凭借Lumia 920复苏；而且分析人士也比较看好RIM即将出货的黑莓10;而苹果的长期主导地位因为缺乏创新而开始受到挑战。但是搭载Windows 8的硬件售价相对较高，在中低价位还没有特别优秀的笔记本。在这样的背景之下，业内人士分析指出，谷歌此款Chrome OS上网本的定位很可能是中低端笔记本市场，这一领域还没有特别优秀的产品。而新款Chrome OS上网本的推出将有利于加强Chrome OS平台的影响力，也可能成为谷歌与苹果竞争的又一砝码。 硬件的较量 其实，谷歌的硬件之路多少有些被逼上梁山的味道。 身为目前终端市场最大的平台厂商之一，谷歌在硬件领域却有些默默无闻。反观其竞争对手苹果，不仅拥有自家的iOS系统和应用商店，更有傲视群雄的iPhone和iPad,以及在PC市场上独树一帜的MacBook,\"软硬兼施\"的发展策略让众多竞争对手只能对苹果的利润率自叹不如。 根据苹果最新发布的财报，其目前的毛利率为40%,这远远高于手机制造商诺基亚和电脑厂商戴尔的毛利率。尤其是在智能手机领域，苹果对行业利润的攫取到了\"极端\"的地步。根据着名苹果分析师Horace Dediu的统计，苹果iPhone攫取了三分之二的行业利润，它的暴利已经让诺基亚、HTC、黑莓等厂商只能羡慕嫉妒恨。 一方面，是苹果在软硬件一体化策略上的成功让诸多对手羡慕不已；另一方面，随着竞争的加剧，互联网巨头们也逐渐意识到固守传统的主战场已不再具有强劲竞争力，于是，硬件市场逐渐成为新的竞争领地。 同被苹果挤压的微软，多年来在PC和智能手机上一直少有建树（微软曾推出过平板电脑Tablet PC和智能手机）,但就在今年10月，微软上市了硬件和软件\"接缝\"的产品--Surface平板电脑。微软还计划在2013年发布三款全新的Surface平板电脑，试图以不同尺寸和配置全面对抗苹果各款iPad产品。微软CEO史蒂夫·鲍尔默还表示微软将有可能推出更多其他自有品牌的硬件。而在近期，微软可能推出自主品牌手机的传言也是甚嚣尘上。有消息称：微软正在与亚洲配件供应商进行合作，测试自己的智能手机设计。业界不得不相信，这家以操作系统起家的企业真的开始了自己的硬件征程。   残酷的现实之下，谷歌加快推自有品牌Chrome OS上网本的步伐就不足为奇了。在Gartner消费者设备分析师卡洛琳娜·米拉内西看来，\"谷歌进军硬件的意义在于因此进入了大众市场。\" 其实，谷歌在硬件领域的小试牛刀已经有了成就。今年5月，谷歌完成对摩托罗拉移动的收购，曲线进入手机领域，Nexus系列智能手机更是为其积攒了不少的人气。6月，谷歌又推出了自己的首款Nexus 7平板电脑。 有观点认为：对于用户而言，Chrome OS以Web体验为主，对硬件要求相对较低，可以说谷歌Chrome OS上网本将是一个完美的休闲计算平台。在这方面，或许甚至会强于iOS或Android设备。 咨询公司Envisioneering Group总监理查德·多哈蒂相当乐观地表示：\"在未来五年间，谷歌、微软和亚马逊有望取代过去十年主流的硬件制造商，成为移动设备领域的巨头。\" 令人担忧的谷歌上网本 对于谷歌而言，开发自有品牌的上网本有着天然的优势。一方面，能够突出自己个性化、实用化的系统亮点；另一方面，也更容易挖掘出符合用户内在需求的软件应用融入到终端中。 然而，这样的自主开发并不让人完全乐观。Needham公司分析师Kerry Rice就悲观地表示，谷歌赢得了竞争性的搜索市场，但是硬件领域是一场新游戏，谷歌显然不是领先者。还有观点指出：谷歌不需要进入硬件领域，这可能反而使公司的整体利润面临下滑的风险，谷歌完全可以靠Android阵营的OEM厂商，如三星、LG、HTC等合作伙伴打赢与苹果的移动操作系统战争。 另外，上网本俨然已成鸡肋。尽管上网本一度被喻为在传统PC和笔记本电脑之后，能扛起创新大旗的新产品，一度吸引了包括联想、惠普、华硕和宏碁等几十家中外厂商蜂拥而上，销售数据火爆一时。在2008年和2009年上网本市场最为火爆的时期，上网本在移动PC的市场份额曾经高达20%-25%. 好景不长，在同质化和价格战的大环境下，特别是随着苹果iPad平板电脑的面世，上网本逐渐退到了舞台边缘。到2011年中，其市场份额只剩下区区2%.分析指出，个中原因不仅仅是上网本产品本身仍存不足，如开机慢、上网慢、电池续航时间短、屏幕小、分辨率差，同时也是因为行业人士更加看好Surface平板电脑的发展。也正因为如此，谷歌的Chrome OS上网本想要扭转乾坤怕是有些势单力薄。 更让业界担心的是，谷歌此次和代工厂的\"亲密接触\"可能让此前的合作伙伴\"很受伤\". 与苹果的封闭系统不同，谷歌Android采用开放策略，因此旗下云集大批硬件厂商，如今谷歌自己操刀硬件领域，势必要与这些合作伙伴展开博弈。这些硬件厂商本来就在平台方面受制于人，如此一来，势必更要担心\"东家\"在硬件领域发展壮大后，自身的生存空间是否会被挤压殆尽，因此，产生异心也就在所难免。而这样的异心，很可能将对未来的紧密合作产生不良的影响。 如此看来，尽管谷歌雄心壮志地要加强其在硬件领域上的渗透力度，尽管Chrome OS上网本有着自己的优势，但其必然要经受一番市场的洗礼和考验。","title":"避免过度刺激Android厂商"},{"content":"displaytag1.1之后支持按需进行分页查询，在其官方网站有如下描述： Displaytag 1.1 offers two alternative ways for working with partial lists: the first one uses the valuelist pattern, and requires that the object that you give to displaytag implements theorg.displaytag.pagination.PaginatedList interface. You can pass this object to displaytag as an usual list, and it will extract paging and sorting information from it. This way is more recommended if you have to build your backend layer and you can easily follow this pattern. a second way, recommended if you only have to use partial list for few tables that show a performance problem using full lists, is passing all the needed parameters as separate tag attributes (recors to be shown, page number, total number of records...) 参考：http://www.displaytag.org/1.2/tut_externalSortAndPage.html 当存在大数据量的时候，一般使用第一种方法。本文的示例来自实际项目，主要解决两个问题： 1） 按需取得数据，利用displaytag实现页面分页显示。 2） 对displaytag要求的分页参数进行设置及复杂性包装，便于快速开发。 主要的步骤如下： 1、创建一个简单类实现org.displaytag.pagination.PaginatedList接口，此类在项目中公用，对于所有的分页需求界面，不需要另造轮子。 package com.whyonly.core.displaytag;import java.util.List;import org.displaytag.pagination.PaginatedList;import org.displaytag.properties.SortOrderEnum;public class SimplePaginatedList<T> implements PaginatedList {\tprivate List<T> list;\tprivate int pageNumber = 1;\tprivate int objectsPerPage = 20;\tprivate int fullListSize = 0;\tprivate String sortCriterion;\tprivate SortOrderEnum sortDirection;\tprivate String searchId;\tpublic List<T> getList() {\t\treturn list;\t}\tpublic void setList(List<T> list) {\t\tthis.list = list;\t}\tpublic int getPageNumber() {\t\treturn pageNumber;\t}\tpublic void setPageNumber(int pageNumber) {\t\tthis.pageNumber = pageNumber;\t}\tpublic int getObjectsPerPage() {\t\treturn objectsPerPage;\t}\tpublic void setObjectsPerPage(int objectsPerPage) {\t\tthis.objectsPerPage = objectsPerPage;\t}\tpublic int getFullListSize() {\t\treturn fullListSize;\t}\tpublic void setFullListSize(int fullListSize) {\t\tthis.fullListSize = fullListSize;\t}\tpublic String getSortCriterion() {\t\treturn sortCriterion;\t}\tpublic void setSortCriterion(String sortCriterion) {\t\tthis.sortCriterion = sortCriterion;\t}\tpublic SortOrderEnum getSortDirection() {\t\treturn sortDirection;\t}\tpublic void setSortDirection(SortOrderEnum sortDirection) {\t\tthis.sortDirection = sortDirection;\t}\tpublic String getSearchId() {\t\treturn searchId;\t}\tpublic void setSearchId(String searchId) {\t\tthis.searchId = searchId;\t}} 2，创建一个分页包装器，根据displaytag分页的要求包装共同性，同时把不同的部分通过接口的方式让子类去处理，此包装器也在项目中共用。 package com.whyonly.core.displaytag;import java.util.List;import javax.servlet.http.HttpServletRequest;public abstract class PaginatedWrapper<T> {\t\tprivate int pageSize = 20;\tpublic void paginated(HttpServletRequest request) {\t\tint page = 1;\t\tif (request.getParameter(\"pageSize\") != null\t\t\t\t&& !\"\".equals(request.getParameter(\"pageSize\"))) {\t\t\tpageSize = Integer.parseInt(request.getParameter(\"pageSize\"));\t\t} \t\tif (request.getParameter(\"page\") != null\t\t\t\t&& !\"\".equals(request.getParameter(\"page\"))) {\t\t\tpage = Integer.parseInt(request.getParameter(\"page\"));\t\t} else {\t\t\tpage = 1;\t\t}\t\tint fromIndex = (page - 1) * pageSize;\t\tint toIndex = fromIndex + pageSize;\t\tint fullListSize = getFullListSize();\t\tList<T> pageDatas = getPageDatas(fromIndex, toIndex);\t\tSimplePaginatedList<T> paginatedList = new SimplePaginatedList<T>();\t\tpaginatedList.setPageNumber(page);\t\tif (pageDatas != null && pageDatas.size() > 0 && fullListSize > 0) {\t\t\tpaginatedList.setFullListSize(fullListSize);\t\t\tpaginatedList.setObjectsPerPage(pageSize);\t\t\tpaginatedList.setList(pageDatas);\t\t} else {\t\t\tpaginatedList.setFullListSize(0);\t\t\tpaginatedList.setList(null);\t\t}\t\trequest.setAttribute(\"pagedatas\", paginatedList);\t}\t\tpublic PaginatedWrapper<T> setPageSize(int pageSize) {\t\tthis.pageSize = pageSize;\t\treturn this;\t}\tprotected abstract List<T> getPageDatas(int fromIndex, int toIndex);\tprotected abstract int getFullListSize();} PaginatedWrapper是一个抽象类，有以下几个特性： 1） 支持泛型<T>，可以根据模块的要求传入相应的bean对象。 2） paginated()方法内聚和包装了displaytag的参数需求，并进行了一些共有的初始化。同时也提供了pagesize大小的设置，默认是20，注意setPageSize放回的this，此处使用了反回自身的方式，便于连续的属性设置。 3） 抽象方法 protected abstract List<T> getPageDatas(int fromIndex, int toIndex) 和 protected abstract int getFullListSize() 对每个模块，具有不同性，因此通过接口方法的方式留给具体的模块去实现。实现一般放在Dao层，然后通过前台Controller（Spring），或者Action（Struts），或者Jsp去调用。 3，使用1，2步骤创建好的两个包装类，应用到具体的项目。下面以SSH2为例，也可以应用到其它的框架结构，因为SSH的框架比较通用，以下只给出关键代码，具体的实现应该是简单的。 3.1， Action类 \t@Actions( {                                                                                       \t\t@Action(value = \"/queryIncidental\", results = {                                                         \t\t\t\t@Result(location = \"center/pos/incidental_query_result.jsp\", name = \"success\"), \t\t\t\t})  \t\t})                                                                                              \t})                                                                                                \tpublic String queryIncidental(){                                                         \t\t\tnew PaginatedWrapper<Posbatch>(){\t\t\t\t@Override\t\t\t\tprotected List<Posbatch> getPageDatas(int fromIndex, int toIndex) {\t\t\t\t\treturn service.initQueryIncidentalByPage(mv,getCompid(), fromIndex, toIndex);\t\t\t\t}\t\t\t\t@Override\t\t\t\tprotected int getFullListSize() {\t\t\t\t\treturn service.findFullSizeByCustAndDate(mv,getCompid());\t\t\t\t}\t\t\t\t\t\t\t}.paginated(request);\t\t\treturn SUCCESS;                                                                                 \t} 以上Action的关键点在于实现getPageDatas()方法和getFullListSize()方法，service是业务逻辑成对象，如果用了Spring，可以通过@Autowired自动注入。 3.2） Service类 \tpublic List<Posbatch> initQueryIncidentalByPage(IncidentalMV mv, int compid, int fromIndex, int toIndex) {\t\t\tString custcode = mv.getCustcode();\t\tKTimestamp start = Kalendar.StringToKTimestamp(\"yyyy-MM-dd\", mv.getStartdate());\t\tKTimestamp end = Kalendar.StringToKTimestamp(\"yyyy-MM-dd\", mv.getEnddate());\t\treturn posbatchDao.findByCustAndDateForPage(fromIndex,toIndex,compid,custcode,start,Kalendar.getKTimestampAfterDays(end, 1));\t}\tpublic int findFullSizeByCustAndDate(IncidentalMV mv, int compid) {\t\tString custcode = mv.getCustcode();\t\tKTimestamp start = Kalendar.StringToKTimestamp(\"yyyy-MM-dd\", mv.getStartdate());\t\tKTimestamp end = Kalendar.StringToKTimestamp(\"yyyy-MM-dd\", mv.getEnddate());\t\treturn posbatchDao.findFullSizeByCustAndDate(compid, custcode, start, Kalendar.getKTimestampAfterDays(end, 1));\t} 3.3）Dao类 \tpublic List<Posbatch> findByCustAndDateForPage(int fromIndex,int toIndex,int compid,String custcode, KTimestamp start,\t\t\tKTimestamp end) {\t\tStringBuffer buff = new StringBuffer();\t\tbuff.append(\"select p from Posbatch p left join fetch p.customer c left join fetch p.wicustomer w left join fetch p.createPerson cp \" +\t\t\t\t\"where p.compid = ? and p.ctime >= ? and p.ctime<? \");\t\tbuff.append(\"  order by p.batchnum desc\");\t\treturn super.find(buff.toString(), fromIndex, toIndex, compid,start,end);\t}\t\tpublic int findFullSizeByCustAndDate(int compid,String custcode, KTimestamp start,\t\t\tKTimestamp end) {\t\tStringBuffer buff = new StringBuffer();\t\tbuff.append(\"select count(*) from Posbatch p \" +\t\t\t\t\"where p.compid = ? and p.ctime >= ? and p.ctime<? \");\t\tbuff.append(custcode!=null && !custcode.equals(\"\") ? \" and p.custcode = ?\" : \"\");\t\tbuff.append(\"  order by p.batchnum desc\");\t\treturn super.findFullSize(buff.toString(),compid,start,end);\t} 此Dao用了Hibernate 的 left join fetch 的方式，因此直接注入Posbatch的关联对象，便于displaytag的显示。 另外，此Dao继承了自己的BaseHibernateDAO,findFullSize()以及find()方法的代码如下： \tpublic List<T> find(String hql ,int fromIndex,int toIndex, Object... params){\t\tQuery query = getSession().createQuery(hql);\t\tfor(int i = 0 , len = params.length ; i < len ; i++){\t\t\tquery.setParameter(i , params[i]);\t\t}\t\tquery.setFirstResult(fromIndex);\t\tquery.setMaxResults(toIndex - fromIndex);\t\treturn query.list();\t}\t\tpublic int findFullSize(String hql,Object... params){\t\tQuery query = getSession().createQuery(hql);\t\tfor(int i = 0 , len = params.length ; i < len ; i++){\t\t\tquery.setParameter(i , params[i]);\t\t}\t\treturn ((Long)query.list().get(0)).intValue();\t} 3.4） 页面显示(JSP) <display:table id=\"pagedatas\" name=\"pagedatas\" export=\"false\" sort=\"external\" class=\"dispaytag\" \t\t\t\t requestURI=\"queryIncidental\"  decorator=\"com.whyonly.center.pos.mv.PosbatchWrapper\"\t\t\t\t>\t\t\t\t<display:column property=\"batchnum\" paramId=\"batchnum\" paramProperty=\"batchnum\"  href=\"incidental\" titleKey=\"centerowl.posinvoicing.searchtran2\" />\t\t\t\t<display:column property=\"custname\" titleKey=\"centerowl.posinvoicing.searchtran3\" />\t\t\t\t<display:column property=\"ctime\"\ttitleKey=\"centerowl.posinvoicing.searchtran4\" />\t\t\t\t<display:column property=\"createPerson.name\" titleKey=\"centerowl.posinvoicing.searchtran5\" />\t\t\t<\/display:table> 此处用了一个包装器，用于显示日期。如果不需要对数据进行特殊的处理，直接忽略他。","title":"displaytag按需分页的包装及实例"},{"content":"这几天在写STM32的ISP烧录工具，因此有涉及到输入hex文件或bin文件进行烧录的问题，所以对hex文件和bin文件进行了些总结。 1 hex介绍 Hex 全称 （Intel HEX）文件是由一行行符合Intel HEX文件格式的文本所构成的ASCII文本文件。在Intel HEX文件中，每一行包含一个HEX记录。这些记录由对应机器语言码和/或常量数据的十六进制编码数字组成。Intel HEX文件通常用于传输将被存于ROM或者EPROM中的程序和数据。大多数EPROM编程器或模拟器使用Intel HEX文件。 2 hex与bin的区别 1     HEX文件是包括地址信息的，而BIN文件格式只包括了数据本身,在烧写或下载HEX文件的时候，一般都不需要用户指定地址，因为HEX文件内部的信息已经包括了地址。而烧写BIN文件的时候，用户是一定需要指定地址信息的。 2   BIN文件格式,对二进制文件而言，其实没有”格式”。文件只是包括了纯粹的二进制数据。 3  HEX文件格式 HEX文件都是由记录（RECORD）组成的。在HEX文件里面，每一行代表一个记录。记录的基本格式为：  +---------------------------------------------------------------+          |  RECORD  | RECLEN |  LOAD  |RECTYPE | INFO or DATA | CHKSUM |          |  MARK ':'|        | OFFSET |        |             |       |         +---------------------------------------------------------------+          |  1-byte  | 1-byte | 2-byte | 1-byte  |   n-byte    | 1-byte |         +---------------------------------------------------------------+   记录类型包括：          '00' DataRrecord：用来记录数据，HEX文件的大部分记录都是数据记录          '01' End of File Record:用来标识文件结束，放在文件的最后，标识HEX文件的结尾          '02' Extended SegmentAddress Record: 用来标识扩展段地址的记录          '03' Start Segment Address Record           '04' Extended Linear AddressRecord: 用来标识扩展线性地址的记录           '05' Start Linear Address Record                   在上面的后2种记录，都是用来提供地址信息的。每次碰到这2个记录的时候，都可以根据记录计算出一个“基”地址。         对于后面的数据记录，计算地址的时候，都是以这些“基”地址为基础的。                    数据记录的具体格式：         +---------------------------------------------------------------+          |  RECORD  | RECLEN |  LOAD  |RECTYPE | INFO or DATA | CHKSUM |          |  MARK ':'|        | OFFSET|  '00'   |             |       |         +---------------------------------------------------------------+          |  1-byte  | 1-byte | 2-byte | 1-byte  |   n-byte    | 1-byte |         +---------------------------------------------------------------+                            看个例子：         :020000040000FA        :10000400FF00A0E314209FE5001092E5011092E5A3         :00000001FF                        对上面的HEX文件进行分析：         第1条记录的长度为02，LOADOFFSET为0000，RECTYPE为04，说明该记录为扩展段地址记录。数据为0000，校验和为        FA。从这个记录的长度和数据，我们可以计算出一个基地址，这个地址为0X0000。后面的数据记录都以这个地址为基         地址。         第2条记录的长度为10（16），LOADOFFSET为0004，RECTYPE为00，说明该记录为数据记录。        数据为FF00A0E314209FE5001092E5011092E5，共16个BYTE。这个记录的校验和为A3。此时的基地址为0X0000，加上OFFSET，         这个记录里的16BYTE的数据的起始地址就是0x0000+ 0x0004 = 0x0004.         第3条记录的长度为00，LOADOFFSET为0000，TYPE ＝ 01，校验和为FF。说明这个是一个END OF FILE RECORD，标识         文件的结尾。               在上面这个例子里，实际的数据只有16个BYTE：FF00A0E314209FE5001092E5011092E5，其起始地址为0x4 4   HEX文件和BIN文件大小有区别      HEX文件是用ASCII来表示二进制的数值。例如一般8-BIT的二进制数值0x3F，用ASCII来表示就需要分别表示字符'3'      和字符'F'，每个字符需要一个BYTE，所以HEX文件需要 > 2倍的空间。     对一个BIN文件而言，你查看文件的大小就可以知道文件包括的数据的实际大小。而对HEX文件而言，你看到的文件     大小并不是实际的数据的大小。一是因为HEX文件是用ASCII来表示数据，二是因为HEX文件本身还包括别的附加信息。 要想详细了解HEX文件格式， 请参见INTEL HEX PDF文档 3 hex文件流转bin文件流 hex.h: #ifndef __HEX_H_#define __HEX_H_typedef struct{\tint len; //bin文件大小\tUINT startAddress; //刷写的起始地址\tBYTE *pContent;\t\t//转化后的内容}HexToBinData;typedef struct{\tBYTE data[16];//数据\tBYTE len;\t//数据长度\tUINT pos;\t//偏移地址\tBYTE type;\t//类型}HexLinData;int ConvertHexToBin(const char *str,HexToBinData *pData);#endif hex.cpp: #include \"StdAfx.h\"#include \"hex.h\"static BYTE HexCharToByte(char c){\tif(c>='0' && c<='9')\t\treturn c -'0';\telse if(c>='a' && c<='f')\t\treturn c-'a'+0x0a;\telse if(c>='A' && c <='F')\t\treturn c-'A'+0x0a;\t\treturn -1;}static BYTE GetFirstByte(const char *str){\tASSERT(str !=NULL);\tBYTE tmp =0;\ttmp =HexCharToByte(str[0]);\ttmp <<=4;\ttmp +=HexCharToByte(str[1]);\treturn tmp;}//从字符串中获取一行static int GetLine(const char *str,char *pBuf){\tASSERT(str !=NULL);\tASSERT(pBuf !=NULL);\tchar *start =strchr((char *)str,':');\tif(NULL ==start){\t\treturn -1;\t}\tchar *end =strstr(start,\"\\r\\n\");\tchar *p =start;\tchar *p2 =pBuf;\tint len=0;\tfor (;p<end+2;p++,p2++)\t{\t\tif(*p =='\\0')\t\t\tbreak;\t\t*p2 =*p;\t\tlen ++;\t}\t*p2 ='\\0';\treturn len;}//获取一行的数据static int GetHexLineData(const char *line,HexLinData *pData){\tASSERT(line !=NULL);\tASSERT(pData !=NULL);\tif(line[0] !=':')\t\treturn -1;\tint i=1;\tpData->len =GetFirstByte(&line[i]);\ti +=2;\tpData->pos =GetFirstByte(&line[i]);\ti +=2;\tpData->pos <<=8;\tpData->pos +=GetFirstByte(&line[i]);\ti +=2;\tpData->type =GetFirstByte(&line[i]);\ti +=2;\tfor(int j=0;j<pData->len;i+=2,j++){\t\tpData->data[j] =GetFirstByte(&line[i]);\t}\treturn 0;}//获取第一行指定类型的数据static int GetFirstDataLine(const char *str,BYTE type,HexLinData *pData){\tASSERT(str !=NULL);\tASSERT(pData !=NULL);\tchar *p =(char *)str;\tchar line[128];\tHexLinData data ={0};\tint len =strlen(str);\tint dataLen =0;\tfor(;p<str+len;p+=dataLen){\t\tmemset(line,0,128);\t\tdataLen =GetLine(p,line);\t\tif(dataLen <0)\t\t\treturn -1;\t\tmemset(&data,0x00,sizeof(HexLinData));\t\tif(0 !=GetHexLineData(line,&data))\t\t\treturn -1;\t\tif(data.type ==type){\t\t\tmemcpy(pData,&data,sizeof(HexLinData));\t\t\treturn 0;\t\t}\t}\treturn -1;}static int GetStartAddress(const char *str,UINT *pStartAddress){\tHexLinData data ={0};\tUINT basePos=0;\tUINT pos;\tif(0 !=GetFirstDataLine(str,4,&data))\t\treturn -1;\tfor(int i=0;i<data.len;i++){\t\tbasePos <<=8;\t\tbasePos +=data.data[i];\t}\tmemset(&data,0x00,sizeof(HexLinData));\tif(0 !=GetFirstDataLine(str,0,&data))\t\treturn -1;\tpos =data.pos;\t*pStartAddress =(basePos<<16) +pos;\treturn 0;}int ConvertHexToBin(const char *str,HexToBinData *pData){\tASSERT(str !=NULL);\tASSERT(pData !=NULL);\tUINT startAddress =0;\tchar line[128] ={0};\tHexLinData data={0};\tif(0 !=GetStartAddress(str,&startAddress))\t\treturn -1;\tpData->startAddress =startAddress;\tchar *p =(char *)str;\tint binLen =0;\tint len =0;\tint size =strlen(str);\t/*FILE *file =fopen(\"test.hex\",\"wb+\");\tfseek(file,0,SEEK_SET);\tFILE *file1 =fopen(\"test.bin\",\"wb+\");\tfseek(file1,0,SEEK_SET);*/\tfor(binLen=0;p<str+size;p +=len){\t\tmemset(line,0,128);\t\tlen =GetLine(p,line);\t\tif(len <0)\t\t\tbreak;\t\t/*fwrite(line,1,len,file);*/\t\tmemset(&data,0x00,sizeof(HexLinData));\t\tif(0 !=GetHexLineData(line,&data))\t\t\treturn -1;\t\tif(data.type ==0){\t\t\tbinLen +=data.len;\t\t\t/*fwrite(data.data,1,data.len,file1);*/\t\t}\t}\t/*fclose(file);\tfclose(file1);*/\tpData->len =binLen;\tpData->pContent =(BYTE *)malloc(pData->len+1);\tif(pData->pContent ==NULL)\t\treturn -1;\tp =(char *)str;\tbinLen =0;\tlen =0;\tfor(binLen=0;p<str+size;p +=len){\t\tmemset(line,0,128);\t\tlen =GetLine(p,line);\t\tif(len <0)\t\t\tbreak;\t\tmemset(&data,0x00,sizeof(HexLinData));\t\tif(0 !=GetHexLineData(line,&data))\t\t\treturn -1;\t\tif(data.type ==0){\t\t\tmemcpy(pData->pContent+binLen,data.data,data.len);\t\t\tbinLen +=data.len;\t\t}\t}\treturn 0;} 只有一个接口函数： int ConvertHexToBin(const char *str,HexToBinData *pData); 它的作用是将hex文件流str直接转化为bin文件流，并存储到HexToBinData结构体中，若成功则返回0，失败则返回非0.","title":"HEX文件和BIN文件总结及hex文件流转bin文件流示例代码"},{"content":"中新网12月27日电 今日，北斗卫星导航系统新闻发言人、中国卫星导航系统管理办公室主任冉承其在新闻发布会上宣布，北斗卫星导航系统今日正式提供区域服务。 据冉承其介绍，北斗卫星导航系统简称北斗系统，英文名称为BeiDou Navigation Satellite System，缩写为BDS。北斗系统是中国自主建设、独立运行，与世界其他卫星导航系统兼容共用的全球卫星导航系统，可在全球范围内全天候、全天时，为 各类用户提供高精度、高可靠的定位、导航、授时服务。 冉承其表示，中国卫星导航系统建设是国家科技重大专项，实施“三步走”发展战略。第一步，2000年建成了北斗卫星导航试验系统，解决了我国自 主卫星导航系统的有无问题；第二步，建设北斗卫星导航系统，2012年形成区域覆盖能力；第三步，2020年左右，形成全球覆盖能力。 冉承其介绍说，在全国人民和各有关部门的大力支持下，参与系统研制、建设、试验、应用和管理的全体人员，按照“质量、安全、应用、效益”的总要 求，坚持“自主、开放、兼容、渐进”的发展原则，瞄准建设世界一流卫星导航系统目标，大力协同、奋力攻关，完成了我国卫星导航系统第二步建设任务，走出了 一条中国特色卫星导航发展道路。 冉承其说，自2011年12月27日提供试运行服务以来，北斗系统又完成了4箭6星发射，扩大了系统覆盖范围，增强了星座稳健性，提高了系统服 务精度。目前，在轨卫星和地面系统工作稳定，通过各类用户终端测试和评估，系统服务性能均满足设计指标要求。自今日起，北斗系统在继续保留北斗卫星导航试 验系统有源定位、双向授时和短报文通信服务基础上，向亚太大部分地区正式提供连续无源定位、导航、授时等服务。 另外，冉承其还对我国及周边地区，北斗系统基本服务性能做了介绍，位置精度为平面10米、高程10米；测速精度每秒0.2米；授时精度单向50 纳秒；可提供双向高精度授时和短报文通信服务。同时，通过广域差分和地基增强等手段，北斗系统服务性能还可进一步提高，满足各类用户需求。 冉承其在发布会上表示，“为鼓励国内外企业研发北斗应用终端，推动北斗广泛应用，去年，我们公布了北斗系统空间信号接口控制文件(ICD)测试 版。目前，北斗系统技术状态已经固化，北斗系统空间信号接口控制文件(ICD)正式版具备公布条件，今天正式公布，中、英文两种版本文档将在北斗政府网站 (www.beidou.gov.cn)同步上线。该文件规范了北斗系统和用户接收机之间的信号接口关系，是开发制造接收机及芯片所必备的技术文件。”","title":"北斗卫星导航系统今日正式提供区域服务"},{"content":"自从Windows 8产品上市以来，经历了2个月的时间，我们可以看到Windows 8暂时的销售情况并不是很好。微软在今年10月下旬发布了其最新一代的操作系统，外界对其褒贬不一，并且无论是从配有Windows 8系统的其他硬件厂商产品，还是微软自家的Surface平板电脑，通过下面的具体数据，我们都可以看到截止到目前看来销售情况并不乐观。 根据NPD研究人员的研究结果表明，Windows电脑的销售量与去年同比下降了约13%，如果要是和Windows 7刚上市的头两个月相比，差距则更加明显。当然，有些用户会直接在原有电脑上升级购买Windows 8，但是，我们这里统计的更多是那些10月26日以后同时支持触屏功能的新一代产品，微软甚至为了Windows 8特意研发了Surface来展示其强大的特性。 虽然Windows 8的销售形式不乐观，但这并不能说明Windows 8系统不好。微软凭借其深厚的底蕴和技术实力，将云计算和社交网络完美的融进了系统中，无论是个人用户还是企业用户，都对Windows 8表示满意。但是为什么Windows 8在市场上雷声大雨点小，叫好不叫座呢？ 来自Windows 8的自身的原因 Windows 8固然是一个强大的操作系统，但是对于新用户来说却有些无所适从。内置的使用教程非常简单，仅仅为用户介绍了一些基本的鼠标和手势操作方法。如果你想使用桌面模式，或者想找到在后台运行的程序，不花费点时间基本是无法第一时间做到的，有的用户甚至连找到重启按钮都要费上一番功夫。即时对长期使用Windows的用户来说，刚刚上手Windows 8，也需要相当长的时间来适应。 另一方面，虽然Windows 8系统现在是相当热门的话题，但是目前专门针对Windows 8开发的应用程序却是少之又少。过少数量的程序开发进一步影响了开发者们的热情，导致恶性循环，最终导致消费者们暂时无程序可用。 此外，对于大部分普通消费者来说，电脑的用途仅仅就是娱乐和办公，玩游戏看电影，创建文档收发电子邮件，这些任务Windows 7其实完全就可以很好的满足需求。所以Windows 8对于这部分消费者来说，再购买一台Windows 8电脑无非就是花钱增加了一些触摸功能，对他们来说并不划算。现在平板电脑的价格越来越低，与其花500美元（约合人民币3100元）购买一台Windows 8系统的新笔记本，还不如只花200美元（约合人民币1200元）单独购买一台平板电脑，并且现在的平板电脑有着成千上万非常成熟的应用程序可用，要比使用陌生的微软应用商店更方便。 来自iPad的挤压 让我们来拿iPad的首次亮相与Windows 8对比一下。当苹果公司推出了它的第一款平板电脑时，同样有很多质疑，同样面对没有应用程序可用的局面。但是，iPad的操作系统对于用户们来说并不陌生，因为当时和iPhone的系统几乎完全相同，用户并不需要花费太多的时间来学习使用。 同时，iPad的在一些基本的功能，比如阅读、浏览照片和休闲娱乐上的体验非常优秀。但是如果当你视图使用类似联想Yoga或者戴尔XPS 12的时候，我相信消费者绝不会拿他们当作一台平板电脑来看，毕竟他们不是iPad。 公平的说，如果为一台笔记本电脑加上触摸功能作为辅助，其实是一个不错的想法。但是，目前来看凭借Windows 8的表现，并不足以驱使用户花钱来重新购买一台Windows 8电脑，或者说Windows 8电脑的平板功能无法与iPad和Nexus 7等相抗衡，所以对用户来说没有足够的吸引力。 不过，至少有一款Windows 8产品能够与iPad抗衡，那就是微软自家的Surface平板。但是，就目前Surface缺少应用的情况来看，与iOS或者Android平板电脑相比，价格还是过于昂贵。期待Surface来为Windows 8阵营扭转目前不利的局面，还需要相当长的时间。 Windows 8舍优取劣 虽然微软为Surface提供了相当不错的键盘底座来帮助销售，但是，目前看来微软却有些“不务正业”。虽然Surface或任何Windows RT的用户可以免费使用Office，但是，微软并没有重视提升Office在Windows 8系统中的使用体验。同时，近几年我们都能看到已经有越来越多的其它应用可以取代Office，比如QuickOffice之类的产品，使微软失去了不少个人用户。另外微软对其历史上最成功的硬件产品：Xbox 360与Windows 8的之间的整合也没有重视，SmartGlass就连iOS和Android都已经开发出了专用的应用程序，居然没有Windows 8能够使用的版本。 现在Windows 8似乎同样陷入了微软一直以来“如果一个系统获得了成功，那么它下一代的产品必然表现不佳”的怪圈。Windows 95与Windows98、Windows XP与Windows Vista及现在的Windows 7与Windows 8，虽然造成这种局面的原因各不相同，但是，结果都是惊人的相似。如果微软希望Windows 8能够逃离这个尴尬的传统，以上的问题逐一解决，才有希望让Windows 8取得真正的成功。","title":"叫好不叫座 Windows 8的问题究竟出在哪？"},{"content":"趁着圣诞节这个充满着祝福的日子，盘点下Linux Deepin的2012年。Linux Deepin是目前国内开源社区和国际社区异军突起的一个Linux版本。总的来说，好坏皆有，但不可否认：Linux Deepin在做着正确的事情。在本文中，作者将为大家从九个方面描述Linux Deepin如何异军突起。 一、兼容Ubuntu软件仓库 众所周知，Ubuntu可以说是在国际社区具有重要影响力的发行版本，Ubuntu基于Debian构建自己的发行版本。作者认为，基于并兼容Ubuntu软件仓库，LinuxDeepin可以获得下面2个明显的优势： 直接得益于Debian强大的社区维护团队和开发者的无私的努力贡献，如优秀的包管理工具、系统稳定性和丰富的软件包； 吸收Ubuntu做出的改进之处，并从中获得发展的灵感：丰富的软件仓库、Ubuntu PPA。Linux Deepin 兼容Ubuntu仓库，玩家就可以直接使用这些来自上游开发的这些便捷工具。 可以说是，LinuxDeepin站在了巨人的肩膀和社区长久以来发展的成果之上。这应该是Linux Deepin在项目初期确定的的一个重要考量。 二、社区支持 因为与Debian和Ubuntu同为一脉，Debian和Ubuntu的社区支持大部分也适用于Linux Deepin。同时也有桌面用户手册和社区编写的wiki，都为解决问题提供了支持。我们可以看到已经有多种方式来参与LD的社区讨论和建设：IRC，邮件列表，G+、Twitter、Facebook、BBS。 三、搜狗输入法 虽然来自社区的各种优秀中文输入法不少，但相比软件厂商发布的搜狗输入法略显劣势。搜狗输入法与LinuxDeepin合作，将推出的搜狗输入法forLinux会改变中文用户长期以来对优秀中文输入法的渴望和期待。据其官方微博透露，“目前LinuxDeepin正与搜狗输入法法务部门沟通，洽谈Linux版本在搜狗输入法集团法务层面的许可合作协议”。期待快点出来吧~~等得焦急啊~~ 四、深度音乐播放器为代表的特色应用 深度音乐播放器、影音播放器、截图工具和软件中心，都紧贴了大家的实际需求，在我们使用的时候舒服多了。虽然有人病诟软件界面有点 Windows 的感觉，因为这种感觉而不爽，好吧，这只是一种选择。而且这些软件包可移植性强，源码也都公开，看到在其他发行版本上也都打包了，其实自己动手也没有多麻烦。 五、开发独立的桌面环境 Linux Deepin原先使用GNOME Shell，但宣布正在开发自己的桌面环境。作者认为，这个是Linux Deepin本年最为重要的一个决定。摒弃Ubuntu的Unity和GNOME Shell，打造自己的桌面环境这样就不用受到他们的限制。 六、专注桌面 Linux Deepin初创的目标是让Linux桌面变得更加易用，现在看来，这个目标还稳如磐石。 七、商业公司支持（社区与企业双驱动力） Linux Deepin背后的商业公司深之度是Linux Deepin大军的重要组件。应该说，这家公司为linux Deepin开发提供资金和核心人才支持，开发团队核心成员都是这家公司的。在Linux Deepin发展的进程之中，其发挥了不可忽视的作用。不过，这样可以保证较快的开发效率和开发质量。 八、用户与开发者大会（UAD） Linux Deepin社区的用户与开发者大会召开看来已经形成惯例，为期举办了2届，话题和深度都有层级提升，比如看今年的就有WPS和搜狗输入法代表参加。不用说，这扩大linux Deepin影响力和业界交流，应该说是搭建了一个良好的平台。 九、自由软件日与活动支持 在自由软件日和社区活动中，也看到了Linux Deepin的身影，我们看到Linux Deepin一直努力在做着自己应有社区角色的责任吧。 2012年末，度过了令人惶恐的末日传说，迎来了众人期待的平安夜，收到了慈祥的圣诞老人的礼物。Linux Deepin在这一年里，也收获了很多。","title":"岁末盘点：看Linux Deepin如何异军突起"},{"content":"想要学习Python编程语言的读者有大量相关书籍可供选择，有印刷版也有电子版，而Python是一门开源的编译语言，开发者也提供了不少免费可自由下载的Python电子书。本文挑选其中最优秀的20本Python电子书，内容覆盖了Python的一般介绍，游戏开发，编程技巧，儿童编程学习等类别，它们大多数都采用了创作共用署名非商业许可证，如《Think Python》、《Invent Your Own Computer Games with Python》、《笨方法学Python第二版》、《Natural Language Processing with Python》等。","title":"20 本优秀的 Python 电子书"},{"content":"1.jdbc连接的优缺点 JDBC的优点 直接底层操作，提供了很简单、便捷的访问数据库的方法，跨平台性比较强。灵活性比较强，可以写很复杂的SQL语句。 JDBC的缺点 1）.因为JAVA是面向对象的，JDBC没有做到使数据能够面向对象的编程，使程序员的思考仍停留在SQL语句上。 2）.操作比较繁琐，很多代码需要重复写很多次。 3）.如果遇到批量操作，频繁与数据库进行交互，容易造成效率的下降。 Jdbc是一个比较底层的东西，灵活写SQL语句 1）、注册驱动 2）、获得连接 3）、产生一个Statement 4）、进行操作 返回数据ResultSet 1）、new List对象 2）、把ResultSet数据放入List过程中 A a = new A(); a.setXXX(rs.getString(\"xxx\")); 代码比较繁琐，纯的JDBC是没有缓存的。 2. hibernate引言 l 模型不匹配(阻抗不匹配) Java面向对象语言，对象模型，其主要概念有：继承、关联、多态等；数据库是关系模型，其主要概念有：表、主键、外键等。 l 解决办法 1使用JDBC手工转换。 2使用ORM(Object Relation Mapping对象关系映射)框架来解决。 对象模型中对象与对象之间的关联关系与关系模型中数据库表之间的关系无法一一对应。 对象模型中对象的继承关系在关系模型中无法直接表示。 对象模型中对象的等值性（equals）在关系模型中无法直接实现。 对象模型中有关联的对象之间的导航访问在关系模型中无法直接实现。 3. hibernate l Hibernate是一个开源ORM框架。 l ORM全称Object Relation Mapping，即对象关系映射。它是一种用来完成对象模型到关系模型的映射技术。就是把应用程序中的对象数据持久化到关系数据库的表的一种技术。 l 使用ORM（ Object Relation Mapping ）框架来解决。主流的ORM框架有JBoss公司的Hibernate、Oracle公司的TopLink、Apache组织的OJB、Sun公司的JDO。 l 简单的说：ORM能利用面向对象的思想开放基于关系型数据库的应用程序，它的主要工作是将对象数据保存到关系数据库的表中，以及将关系数据库表中数据读入到对象中。 4.安装配置 下载地址http://www.hibernate.org，这里举例使用的是3.3版本。解压获取必需类库文件。将下载目录/hibernate3.jar和/lib下的hibernate运行时必须的包加入classpath中： 需要使用的jar包以及jar包对应含义如下： l 配置文件hibernate.cfg.xml和hibernate.properties，XML和properties两种，这两个文件的作用一样，提供一个即可，推荐XML格式，下载目录/etc下是示例配置文件，后者中列举的更详细，主要是与各种数据库连接模版。 l 可以在配置文件指定： 数据库的URL、用户名、密码、JDBC驱动类、方言等。 启动时Hibernate会在CLASSPATH里找这个配置文件。 l 映射文件(hbm.xml，对象模型和关系模型的映射)。在/eg目录下有完整的hibernate示例。 l 一个小例子步骤： 1）.新建java或web项目，并加入相应的jar包及jdbc驱动。 2）.创建持久化类（java bean） 3）.准备数据库表 4）.创建配置文件 hibernate.cfg.xml 5）.创建映射文件 xxx.hbm.xml（与bean类在同一个包中） 6）.创建测试文件（测试本项目） 5. 细节分析 Hibernate.connection.url 表示要链接的数据库地址 Hibernate.connection.driver_class表示要链接的数据库的驱动类 Hibernate.connection.username 要连接的数据库的用户名 Hibernate.connection.password 要连接的数据库的密码 Hibernate.dialect 表示要使用的数据库的类型 org.hibernate.dialect.MySQL5Dialect mysql数据库 org.hibernate.dialect.Oracle9Dialect oracle数据库 org.hibernate.dialect.SQLServerDialect SQLServer数据库 hibernate.hbm2ddl.auto validate:加载hibernate时验证创建表结构 update:加载hibernate时自动更新数据库结构，如果表存在不用创建，如果不存在就创建。 create:每一次加载hibernate时都创建表结构 create-drop:加载hibernate时创建，退出时删除 6.基本概念和CURD 开发流程: 1、由Domain object -> mapping->db。(官方推荐) 2、由DB开始，用工具生成mapping和Domain object。(使用较多) 3、由映射文件开始。 Domain Object限制 1、默认的构造方法(必须的)。 2、有无意义的标示符id（主键）(可选) 3、非final的，对懒加载有影响（可选） 7. 案例说明 Domain Java Object(User) public class User { private int id; private String name; private Date birthDay; //getter setter… } l 对象关系映射文件：把面向对象中的实体类对象映射到数据库中的实体（表的记录），把实体类之间的关联关系也映射到数据库中多个表之间的相互关系中。这样，在Hibernate中对这些实体对象的操作就直接转换为对数据库表的记录的操作。 user.hbm.xml <?xml version=\"1.0\"?> <hibernate-mapping package=“cn.itcast.domain\"> <class name=\"User\" table=\"user\"> <id name=\"id\"> <generator class=\"native\"/> <\/id> <property name=\"name\"/> <property name=\"birthday”/> <\/class> <\/hibernate-mapping> hibernate.cfg.xml <!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\"> <hibernate-configuration> <session-factory name=\"foo\"> <property name=\"connection.driver_class\">com.mysql.jdbc.Driver<\/property> <property name=\"connection.url\">jdbc:mysql:///hibernate<\/property> <property name=\"connection.username\">root<\/property> <property name=\"connection.password\">root<\/property> <property name=\"dialect\">org.hibernate.dialect.HSQLDialect<\/property> <property name=\"show_sql\">true<\/property> <property name=\"hbm2ddl.auto\">update<\/property> <mapping resource=\"com/hbsi/domain/User.hbm.xml\"/> <\/session-factory> <\/hibernate-configuration> 测试类 DemoTest.java package com.hbsi.test; import java.text.DateFormat; import java.text.ParseException; import java.util.Date; import org.hibernate.Session; import org.hibernate.SessionFactory; import org.hibernate.cfg.Configuration; import com.hbsi.domain.User; public class UserTest { /** * @param args * @throws ParseException */ public static void main(String[] args) throws ParseException { //给user类字段赋值 User user = new User(); user.setName(\"aa\"); //user.setBirthday(new Date()); user.setBirthday(DateFormat.getDateInstance().parse(\"1992-01-01\")); //获取hibernate.cfg.xml的配置文件 Configuration cfg = new Configuration().configure(); //从session工厂中获取session，相当于jdbc中的connection SessionFactory factory = cfg.buildSessionFactory(); Session session = factory.openSession(); session.beginTransaction(); session.save(user); session.getTransaction().commit(); session.close(); } } 文章原处是我同门师兄这的http://blog.csdn.net/tianyazaiheruan/article/details/8307283","title":"01-hibernate入门"},{"content":"         前面提到了简单工厂，由于简单工厂的缺点：违背开放-封闭原则和单个类（工厂类）职责过多，工厂方法是简单工厂的抽象，克服了简单工厂的缺点。 概念：        工厂方法模式(Factory Method)，定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。          工厂方法模式根据目的划分是创建型模式，根据范围准则来分就是主要作用于类的。6个创建型就只有工厂方法模式是作用于类的。        而所谓的类模式就是指，类和子类之间的关系，是通过继承建立的，是静态的，在编译时刻便确定下来了。而几乎所有的模式都使用继承机制，所以“类模式”指的是那些集中于处理类间关系的模式。详情请见。Java设计模式分类不明白也没事，也不是很重要。 UML类图：      分析一下：工厂方法的角色有，工厂方法Creator（抽象类or接口）和具体工厂方法类ConcreteCreator（N个），以及一个抽象类/接口，用来定义工厂方法创建的对象，Product，然后就是具体的产品（N个）。      与简单工厂相比，就是简单工厂没有ConcreteCreator（具体工厂），所以简单工厂的Creator工厂类的职责就多。 代码实现：        还是汽车的例子。为了简单，还是那两种汽车，奔驰和宝马。不同的是，因为一家工厂生产两种汽车，忙不过来，所以学习单一职责原则，多开几家工厂，一家工厂只生产一种车子。然后就有两家工厂，奔驰工厂和宝马工厂。而且这样的话，如果以后再想增加奥迪，就只用增加奥迪工厂就好了。类图就如下所示： 代码如下： namespace CarFactoryMethod{    class Program    {        static void Main(string[] args)        {            //最后，客户端,作用创建车子。             //首先要实例化具体工厂.            //然后具体工厂创建具体的车,            //具体的车创建完成了,自己展示下.            CarFactory benzFactory = new BenzFactory();                ICar benz=benzFactory.CarCreate();            benz.Show();            CarFactory bmwFactory = new BMWFactory();            ICar bmw = bmwFactory.CarCreate();            bmw.Show();            Console.Read();        }    }    //首先还是抽象产品角色，汽车接口（产品角色都没变,不管抽象产品还是具体产品）    interface ICar    {        void Show();    }    //然后是两个具体产品角色，宝马和奔驰,他们都要实现ICar接口    class BMW:ICar    {        public void Show()        {            //内容很简单，只是输出一句话            Console.WriteLine(\"一辆宝马诞生了！！！\");        }    }    //Benz类    class Benz:ICar    {        public void Show()        {            Console.WriteLine(\"我是一辆奔驰！！！\");        }    }    //以上的类和简单工厂的一样，    //工厂方法的工厂类和简单工厂的不一样。    abstract class CarFactory     {        //是个抽象方法        public abstract ICar CarCreate();    }    //新开的两个工厂    //宝马工厂    class BMWFactory : CarFactory    {        //实现父类的抽象方法        public override ICar CarCreate()        {            //CarCreate方法，它就是实例化个宝马类,也就是子类决定实例化哪一个类.类的实例延迟到子类.                        return new BMW();        }    }    //奔驰工厂,同宝马工厂    class BenzFactory : CarFactory    {        public override ICar CarCreate()        {            return new Benz();        }    }} 运行结果： 如果要增加一个奥迪，要增加一个奥迪类，一个奥迪工厂类。 //增加一个奥迪    class AUDI : ICar    {        public void Show()        {            Console.WriteLine(\"四环奥迪就是我！！！\");        }    } //增加的奥迪工厂,同宝马工厂    class AUDIFactory : CarFactory    {        public override ICar CarCreate()        {            return new AUDI();        }    }   //增加的客户端代码     CarFactory audiFactory = new AUDIFactory();     ICar audi = audiFactory.CarCreate();     audi.Show(); 运行结果： 完美的遵循了开发-封闭原则，对扩展开放，对修改关闭。而且每个类的职责都不多。        百度百科介绍：        工厂方法经常用在以下两种情况中:        第一种情况是对于某个产品，调用者清楚地知道应该使用哪个具体工厂服务，实例化该具体工厂，生产出具体的产品来。Java Collection中的iterator()方法即属于这种情况。        第二种情况，只是需要一种产品，而不想知道也不需要知道究竟是哪个工厂为生产的，即最终选用哪个具体工厂的决定权在生产者一方，它们根据当前系统的情况来实例化一个具体的工厂返回给使用者，而这个决策过程这对于使用者来说是透明的。","title":"工厂方法模式"},{"content":"最近流行跨界，不同编程语言之间喜欢通过一些开源项目来实现相互调用、转换。同时也有一些项目可实现语言之间的集成，例如 JRuby 可让你在 Java 应用中执行 Ruby脚本。 而这里有一个网站给出了一个完整的不同编程语言之间的转换矩阵，通过这个矩阵你可以了解到两个语言需要使用什么工具可以进行转换 访问该网站：http://langlangmatrix.com/","title":"不同编程语言之间转换的项目矩阵"},{"content":"微软安全部门证实发现影响IE6-8的一个漏洞，但目前为止没有提供补丁。IE9和10不受影响。针对XP用户的紧急排险措施包括安装微软EMET工具包、禁用IE中的Java和Flash，或者更简单的——换一个浏览器。 查看:CFR Watering Hole Attack Details","title":"IE 再爆 0day 漏洞，9和10版本不受影响"},{"content":"  观察者模式：顾名思义，就是观察一些人或一些事干了什么，引发了观察者的反应。   java自己定义了Observable类（被观察者）和Observer接口（观察者）：   java.util.Observable  ：表示应用程序想要观察的对象。                                               一个 observable 对象可以有一个或多个观察者。                                      观察者可以是实现了 Observer 接口的任意对象。                                      一个 observable 实例改变后，调用Observable 的notifyObservers 方法的应用程序会通过调用观察者的                                       update 方法来通知观察者该实例发生了改变。                                      新创建一个 observable 对象时，其观察者集是空的。当且仅当equals 方法为两个观察者返回 true 时，才认为                                      它们是相同的。 方法摘要  void addObserver(Observer o)           如果观察者与集合中已有的观察者不同，则向对象的观察者集中添加此观察者。 protected  void clearChanged()           指示对象不再改变，或者它已对其所有的观察者通知了最近的改变，所以 hasChanged 方法将返回 false。  int countObservers()           返回 Observable 对象的观察者数目。  void deleteObserver(Observer o)           从对象的观察者集合中删除某个观察者。  void deleteObservers()           清除观察者列表，使此对象不再有任何观察者。  boolean hasChanged()           测试对象是否改变。  void notifyObservers()           如果 hasChanged 方法指示对象已改变，则通知其所有观察者，并调用 clearChanged 方法来指示此对象不再改变。  void notifyObservers(Object arg)           如果 hasChanged 方法指示对象已改变，则通知其所有观察者，并调用 clearChanged 方法来指示此对象不再改变。 protected  void setChanged()           标记此 Observable 对象为已改变的对象；现在 hasChanged 方法将返回 true。     接口 Observer：一个可在观察者要得到 observable 对象更改通知时可实现Observer 接口的类。   方法摘要  void update(Observable o,Object arg)           只要改变了 observable 对象就调用此方法。     假设这样一个场景：    农村留守家庭里有爷爷奶奶，两个上初中的外孙，哥哥和弟弟。但是哥哥不好好上学，整天跑去上网，奶奶很担心，就叫弟弟时常监督（观察）哥哥的动向，要是发现哥哥去上网了，就回来报告。     Brother 类：被观察者 package com.mayi.file;import java.util.Observable;/** *  * @author Administrator * 哥哥经常跑去上网，奶奶派了弟弟去监督他 * */public class Brother extends Observable {\tprivate final Integer flag =1;\tpublic Brother() {\t\tsuper();\t}\t\t//哥哥跑去上网，就通知奶奶；\tpublic void G0_Internet(){\t\tsetChanged();//必须调用\t\tSystem.out.println(\"------>发现哥哥要去网吧了！\");\t\t//设置参数，做更多的逻辑处理\t\tthis.notifyObservers(flag);\t\t//this.notifyObservers();\t}} LittleBrother类：观察者 package com.mayi.file;import java.util.Observable;import java.util.Observer;/** *  * @author Administrator *弟弟受奶奶指派，监督哥哥的行为，当他发现哥哥去上网的时候就去通知奶奶。 */public class LittleBorther implements Observer {\tpublic LittleBorther() {\t\t// TODO Auto-generated constructor stub\t}\t@Override\tpublic void update(Observable arg0, Object arg1) {\t\t//可以根据arg1的参数分别处理不同的逻辑事件\t\tSystem.out.println(\"接收到得参数arg1是：\"+arg1);\t\tSystem.out.println(\"弟弟：奶奶，哥哥跑去上网了\");\t}} Test类： package com.mayi.test;import com.mayi.file.*;public class Test {\tpublic static void main(String[] args) {\t\tBrother brother = new Brother();\t\t\t\tbrother.addObserver(new LittleBorther());//添加觀察者\t\t\t\tbrother.G0_Internet();//哥哥去上網\t}} 输出： ------>发现哥哥要去网吧了！接收到得参数arg1是：1弟弟：奶奶，哥哥跑去上网了     优点 支持松耦合和减少依赖性。客户端不再依赖于观察器，因为通过使用主体和 Observer 接口对客户端进行了隔离。许多框架具有此优点，在这些框架中的应用程序组件可以注册为当（低级）框架事件发生时得到通知。结果，框架将调用应用程序组件，但不会依赖于它。 观察器数目可变。观察器可以在运行时附加和分离，因为主体对于观察器数目没有任何假定。此功能在这样的情况下是很有用的：观察器数在设计时是未知的。例如，如果用户在应用程序中打开的每个窗口都需要一个观察器。 缺点 性能降低。在许多实现中，观察器的 update() 方法可能与主体在同一线程中执行。如果观察器列表很长，则执行 Notify() 方法可能需要很长时间。抽取对象依赖性并不意味着添加观察器对应用程序没有任何影响。 内存泄漏。在 Observer 中使用的回调机制（当对象注册为以后调用时）会产生一个常见的错误，从而导致内存泄漏，甚至是在托管的 C# 代码中。假定观察器超出作用范围，但忘记取消对主体的订阅，那么主体仍然保留对观察器的引用。此引用防止垃圾收集在主体对象也被破坏之前重新分配与观察器关联的内存。如果观察器的生存期比主体的生存期短得多（通常是这种情况），则会导致严重的内存泄漏。 隐藏的依赖项。观察器的使用将显式依赖性（通过方法调用）转变为隐式依赖性（通过观察器）。如果在整个应用程序中广泛地使用观察器，则开发人员几乎不可能通过查看源代码来了解所发生的事情。这样，就使得了解代码更改的含意非常困难。此问题随传播级别急剧增大（例如，充当 Subject 的观察器）。因此，应该仅在少数定义良好的交互（如 Model-View-Controller 模式中模型和视图之间的交互）中使用观察器。最好不要在域对象之间使用观察器。 测试 / 调试困难。尽管松耦合是一项重大的体系结构功能，但是它可以使开发更困难。将两个对象去耦的情况越多，在查看源代码或类的关系图时了解它们之间的依赖性就越难因此，仅当可以安全地忽略两个对象之间的关联时才应该将它们松耦合（例如，如果观察器没有副作用）。","title":"观察者模式(Observer Pattern)"},{"content":"面向对象分析与设计的主要任务是，找出类和对象，构建对象模型。 对象模型的主要要素：抽象、封装、模块化与层次结构。 对象模型的次要要素：类型、并发、持久。 抽象描述了一个对象的基本特征,可以将这个对象与所有其他类型的对象区分开来，因此提供了清晰定义的概念边界，它与观察者的角度有关。 抽象关注一个对象的外部视图，用来分离对象的基本行为和实现。我们可以理解为抽象关注接口，即可观察到的行为；而封装则关注这些行为的实现。 面向对象设计的核心问题是对于给定问题找出一组正确的抽象。 抽象的两个原则： 最少承诺原则：对象的接口只提供它的基本行为。 最少惊奇原则：抽象捕捉了某个对象的全部行为，不多也不少，并且不提供抽象之外的惊奇效果和副作用。 评判抽象的品质： 耦合：模块之间的关联强度应该是比较弱的，即低耦合。 内聚：模块内的各个元素的联系时紧密的，即高内聚。 充分性：类或模块应该记录某个抽象足够多的特征，从而允许有意义的、有效的交互。 完整性：类和模块的接口记录了它的全部特征。 基础性：只有访问该抽象的底层表现形式才能够有效的实现那些操作。","title":"面向对象—抽象"},{"content":"hosts文件 hosts —— the static table lookup for host name（主机名查询静态表） hosts文件是Linux系统上一个负责ip地址与域名快速解析的文件，以ascii格式保存在/etc/目录下。hosts文件包含了ip地址与主机名之间的映射，还包括主机的别名。在没有域名解析服务器的情况下，系统上的所有网络程序都通过查询该文件来解析对应于某个主机名的ip地址，否呵就需要使用dns服务程序来解决。通过可以将常用的域名和ip地址映射加入到hosts文件中，实现快速方便的访问 优先级 ： dns缓存 > hosts > dns服务 hosts格式配置 hosts文件可以配置主机ip与对应的主机名。在局域网或者是万维网上，每台主机都有一个ip地址，它区分开每台主机，并可以根据ip进行通讯。但是Ip地址不符合人脑的记忆规律，因此出现了域名，例如www.baidu.com.在一个局域网中，每台机器都有一个主机名，用于区分主机，便于相互访问. hosts文件格式 ip地址   主机名/域名   （主机别名） 主机名和域名区别 主机名通常在局域网内使用，通过hosts文件，主机名就被解析到对应的ip;域名通常在internet上使用，但是优先级低于hosts文件中内容，因此如果你不想使用internet上的域名解析，可以更改自己的hosts文件，加入自己的域名解析 hosts文件作用 一个主要的作用是：线下环境模拟，通信双方在同一个局域网内想通过internet上的域名相互访问，则只只需要修改自己的/etc/hosts文件内容即可 修改hosts文件后，ping www.baidu.con结果如下： 参考文献 http://soft.zdnet.com.cn/software_zone/2007/0831/481970.shtml","title":"linux修改/etc/hosts"},{"content":"    Microsoft Enterprise Library中的Cache模块能在多种场景中提供缓存功能：Web程序，桌面程序，WPF程序。我们可以配置Cache模块的缓存处理器，目前系统自带3个缓存处理器：In-Memory，Isolated Storage Cache Store 和 Data Cache Storage。 并且我们还能实现自己的缓存处理器，只需要实现接口 IBackingStore，我们又可以发明自己的轮子啦：） In-Memory：保存在内存中。   Isolated Storage Cache Store：系统将缓存的信息保存在独立文件中（C:\\Users\\<<user name>>\\AppData\\Local\\IsolatedStorage）。 Data Cache Storage：将缓存数据保存在数据库中。 Custom Cache Storage：自己扩展的处理器。我们可以将数据保存在注册表中或文本文件中。   In-Memory             ICacheManager cacheManager = EnterpriseLibraryContainer.Current.GetInstance<ICacheManager>();            cacheManager.Add(\"A\", \"This is letter A.\");            cacheManager.Add(\"A\", \"This is letter A.\");            cacheManager.Add(\"B\", \"This is letter B.\");            cacheManager.Add(\"C\", \"This is letter C.\");            cacheManager.Add(\"D\", \"This is letter D.\");            cacheManager.Add(\"E\", \"This is letter E.\");            Console.WriteLine(string.Format(\"currently there are {0} elements in cache pool.\", cacheManager.Count));            cacheManager.Remove(\"B\");            cacheManager.Remove(\"C\");            Console.WriteLine(string.Format(\"currently there are {0} elements in cache pool.\", cacheManager.Count));            cacheManager.Flush();   配置信息     Isolated Storage Cache Store             simeple demo            ICacheManager cacheManager = EnterpriseLibraryContainer.Current.GetInstance<ICacheManager>();            cacheManager.Add(\"A\", \"This is letter A\");            cacheManager.Add(\"B\", \"This is letter B\");            Console.WriteLine(string.Format(\"{0}:{1}\", \"A\", cacheManager.GetData(\"A\")));            cacheManager.Remove(\"A\");            Console.WriteLine(string.Format(\"currently there are {0} elements in cache pool.\", cacheManager.Count));            cacheManager.Flush();            Console.WriteLine(string.Format(\"currently there are {0} elements in cache pool.\", cacheManager.Count));   配置信息   Data Cache Storage ICacheManager cacheManager = EnterpriseLibraryContainer.Current.GetInstance<ICacheManager>();            cacheManager.Add(\"A\", \"This is letter A.\");            cacheManager.Add(\"A\", \"This is letter A.\");            cacheManager.Add(\"B\", \"This is letter B.\");            cacheManager.Add(\"C\", \"This is letter C.\");            cacheManager.Add(\"D\", \"This is letter D.\");            cacheManager.Add(\"E\", \"This is letter E.\");            Console.WriteLine(string.Format(\"currently there are {0} elements in cache pool.\", cacheManager.Count));            cacheManager.Remove(\"B\");            cacheManager.Remove(\"C\");            Console.WriteLine(string.Format(\"currently there are {0} elements in cache pool.\", cacheManager.Count));            cacheManager.Flush();   配置信息     Custom Cache Storage ICacheManager cacheManager = EnterpriseLibraryContainer.Current.GetInstance<ICacheManager>();            cacheManager.Add(\"A\", \"This is letter A.\");            cacheManager.Add(\"A\", \"This is letter A.\");            cacheManager.Add(\"B\", \"This is letter B.\");            cacheManager.Add(\"C\", \"This is letter C.\");            cacheManager.Add(\"D\", \"This is letter D.\");            cacheManager.Add(\"E\", \"This is letter E.\");            Console.WriteLine(string.Format(\"currently there are {0} elements in cache pool.\", cacheManager.Count));            cacheManager.Remove(\"B\");            cacheManager.Remove(\"C\");            Console.WriteLine(string.Format(\"currently there are {0} elements in cache pool.\", cacheManager.Count));            cacheManager.Flush(); Custom Cache Storage实现代码 namespace SimpleCacheDemo{    using System;    using System.Linq;    using System.Text;    using System.Configuration;    using System.Data;    using System.IO;    using Microsoft.Win32;    using System.Collections.Generic;    using System.Collections.Specialized;    using System.Collections.Generic;    using System.Collections;    using Microsoft.Practices.EnterpriseLibrary.Common;    using Microsoft.Practices.EnterpriseLibrary.Common.Configuration;    using Microsoft.Practices.ServiceLocation;    using Microsoft.Practices.Unity.Configuration;    using Microsoft.Practices.EnterpriseLibrary.Caching;    using Microsoft.Practices.EnterpriseLibrary.Caching.Expirations;    using Microsoft.Practices.EnterpriseLibrary.Caching.Configuration;    /// <summary>    /// TODO: Update summary.    /// <\/summary>    ///     [ConfigurationElementType(typeof(CustomCacheStorageData))]    public class CustomStorage:IBackingStore    {        public CustomStorage(NameValueCollection keys)        { }        public void Add(CacheItem newCacheItem)        {            RegistryKey hklm = Registry.LocalMachine;            RegistryKey software = hklm.OpenSubKey(\"software\", true);            RegistryKey microsoft = software.OpenSubKey(\"microsoft\", true);            RegistryKey entryDir = microsoft.CreateSubKey(\"customcache\", RegistryKeyPermissionCheck.ReadWriteSubTree);            if (entryDir != null)            {                if (entryDir.GetValue(newCacheItem.Key) == null)                {                    entryDir.SetValue(newCacheItem.Key, newCacheItem.Value.ToString(), RegistryValueKind.String);                }                entryDir.Close();            }            microsoft.Close();            software.Close();        }        public int Count        {            get {                int keyCount = 0;                RegistryKey hklm = Registry.LocalMachine;                RegistryKey software = hklm.OpenSubKey(\"software\", true);                RegistryKey microsoft = software.OpenSubKey(\"microsoft\", true);                using (RegistryKey entryDir = microsoft.CreateSubKey(\"customcache\", RegistryKeyPermissionCheck.ReadWriteSubTree))                {                    if (entryDir != null)                    {                        keyCount = entryDir.GetValueNames().Length;                    }                }                return keyCount;            }        }        public void Flush()        {            RegistryKey hklm = Registry.LocalMachine;            RegistryKey software = hklm.OpenSubKey(\"software\", true);            RegistryKey microsoft = software.OpenSubKey(\"microsoft\", true);            microsoft.DeleteSubKeyTree(\"customcache\");        }        public System.Collections.Hashtable Load()        {            Hashtable cacheItemTbl = new Hashtable();            RegistryKey hklm = Registry.LocalMachine;            RegistryKey software = hklm.OpenSubKey(\"software\", true);            RegistryKey microsoft = software.OpenSubKey(\"microsoft\", true);            using (RegistryKey entryDir = microsoft.CreateSubKey(\"customcache\", RegistryKeyPermissionCheck.ReadWriteSubTree))            {                if (entryDir != null)                {                    foreach (string key in entryDir.GetValueNames())                    {                        cacheItemTbl.Add(key, entryDir.GetValue(\"key\"));                    }                }            }            return cacheItemTbl;        }        public void Remove(string key)        {            RegistryKey hklm = Registry.LocalMachine;            RegistryKey software = hklm.OpenSubKey(\"software\", true);            RegistryKey microsoft = software.OpenSubKey(\"microsoft\", true);            using (RegistryKey entryDir = microsoft.CreateSubKey(\"customcache\", RegistryKeyPermissionCheck.ReadWriteSubTree))            {                if (entryDir != null)                {                    entryDir.DeleteValue(key);                }            }        }        public void UpdateLastAccessedTime(string key, DateTime timestamp)        {                   }        public void Dispose()        {                    }    }} 配置信息   缓存禁用 ////cache expire regulation            string moniterFilePath = AppDomain.CurrentDomain.BaseDirectory + \"tmp.txt\";            ICacheManager cacheManager = EnterpriseLibraryContainer.Current.GetInstance<ICacheManager>();            if (File.Exists(moniterFilePath) == false)            {                using (File.Create(moniterFilePath))                { }            }            // these class was implemented interface ICacheItemExpiration            NeverExpired neverExpired = new NeverExpired();            AbsoluteTime absoluteTime = new AbsoluteTime(new TimeSpan(0, 0, 10));//ten seconds            SlidingTime slidingTime = new SlidingTime(new TimeSpan(0, 0, 10));            FileDependency fileDependency = new FileDependency(moniterFilePath);            //没实现，构造函数中的参数比较奇怪            ExtendedFormatTime extendedFormatTIme = new ExtendedFormatTime(\"Hour - 0-23\");            //cache refresh listener            CacheRefreshContainer cacheRefreshContainer = new CacheRefreshContainer(cacheManager, slidingTime);            CacheRefresher cacheRefresher = new CacheRefresher(cacheRefreshContainer);//new CacheRefresher();//new CacheRefresher(cacheManager);            //seems we can't add a new item in cache pool during CacheRefresher was executing.            cacheManager.Add(\"A\", \"This is letter A!\", CacheItemPriority.High, cacheRefresher, slidingTime);            Console.WriteLine(string.Format(\"{0}:{1}\", \"A\", cacheManager.GetData(\"A\")));            System.Threading.Thread.Sleep(15000);            Console.WriteLine(string.Format(\"{0}:{1}\", \"AB\", cacheManager.GetData(\"AB\")));            //test encryptograme function            cacheManager.Add(\"A\", \"This is letter A.\");            Console.WriteLine(string.Format(\"{0}:{1}\", \"A\", cacheManager.GetData(\"A\")));            Console.ReadKey();            cacheManager.Flush(); CacehRefresher     [Serializable]    public class CacheRefresher:ICacheItemRefreshAction    {        //ICacheManager _cacheManager;        //public CacheRefresher(ICacheManager cacheManager)        //{        //    _cacheManager = cacheManager;        //}        CacheRefreshContainer _cacheRefreshContainer;        public CacheRefresher(CacheRefreshContainer cacheRefreshContainer)        {            _cacheRefreshContainer = cacheRefreshContainer;        }        public void Refresh(string removedKey, object expiredValue, CacheItemRemovedReason removalReason)        {            //_cacheManager.Remove(removedKey);            //_cacheManager.Add(removedKey + \"B\", expiredValue.ToString() + \" new!\");        }    }        ","title":"Microsoft Enterprise Library: Cache 模块"},{"content":"Job初始化 当JobTracker接收到一个请求调用它的submitJob()方法时，它把该请求插入一个内部队列中，由job的调度管理器进行调度并初始化。Job初始化将会创建一个控制job的执行情况的对象RunningJob，RunningJob会对tasks进行压缩，记录tasks的信息用于跟踪tasks的状态和执行进度。   为了能够使得tasks运行起来，job的调度管理器首先会接收来自共享文本系统的分片，分片通过调用JobClient产生，然后调度管理器会为每一个分片创建一个map task，而reduce rasks的创建由JobConf中的mapred.reduce.tasks属性决定，通过setNumReduceTasks()方法设置。而Job的调度管理器只是简单的创建reduce tasks的数量。此时Tasks获得ID。   Figure 1:How Hadoop run a MapReduce job     分配Task TaskTrackers执行一个简单的循环，周期性地向JobTracker发送心跳查询。心跳查询告诉jobtracker有一个tasktracker处于活跃中，心跳查询还可以作信息传输通道。作为心跳查询的一部分，一个tasktracker会表明是否有一个新的task准备就绪，如果是，jobtracker将会通过心跳查询的返回值向该tasktracker分配一个task。   在选择一个task分配给tasktracker前，jobtracker必须选择一个job用于选择task。MapReduce中有多种调度算法，默认的优先队列调度算法。选择job后，现在jobtracker为job选择一个task。   TaskTracker有固定的槽用于运行map tasks和reduce tasks。比如，一个tasktracker可能同时运行两个map tasks和两个reduce tasks（具体的数量取决于tasktracker上处理器的个数和内存的容量）。默认的调度管理器会先填充map task槽（slot），因此，如果tasktracker中至少有一个map task槽，jobtracker将会选择一个map task；否则选择一个reduce task。   在选择reduce task时，jobtracker只是简单地从任务列表中取出下一个还没有被执行的reduce task，因为这时不需要考虑数据局部性。而对于一个map task，需要充分考虑tasktracker的网络位置，并选择一个输入分片尽可能靠近tasktracker的task。在优化情况下，task是data-local的，都在分片所属的同一个集群节点上运行。另外一种情况是，task是rack-local的：在相同的rack上，而不是相同的节点（分片同样也是）。一些tasks既不属于data-local，也不属于rack-local，它们从一个不同的rack中获取数据，而这个rack来自于它们所在的rack。     执行Task 现在tasktracker已分得一个任务，下一步就是执行这个任务。首先，tasktracker从共享文件系统中复制job JAR到tasktracker的文件系统，还得从分布式缓冲（distributed cache）中复制一些必须的文件到本地；然后在本地为该任务创建一个工作空间，解压JAR文件到该工作空间；最后，实例化TaskRunner，执行任务。   TaskTracker启动一个新的Java Virtual Machine，每一个任务都在里面运行。因此，任何由用户自定义的map和reduce方法引发的bug都不会影响到tasktracker。Tasks之间可能重用JVM。   子进程通过脐带接口（umbilical interface）与父进程通信，通过这种途径，子进程每个几秒钟就向父进程报告任务的进度，直到任务结束。     流和管道（Streaming and Pipes） 流和管道都是执行特定的map和reduce tasks，为了启动用户支持的可执行文件并与之通信。   使用Streaming时，Streaming task通过标准输入输出流与进程（可能使用任何语言编写）通信；而在使用Pipes时，建立socket接口与进程通信，因此在启动的时候，C++进程建立一个持久的socket连接到父级Java Pipes task。   不管是使用Streaming还是Pipes，在执行task的期间，Java进程将传递输入的key/value对到外部进程，该外部进程通过用户自定义的map或reduce方法运行，并将输出的key/value对返回Java进程。从tasktracker的角度来看，就好像是它的子进程执行map或reduce。   Figure 2:The relationship of the Streaming and Pipes executable to the tasktracker and it child     进度与状态更新 MapReduce作业是长时间运行的批量作业，可能需要几分钟到几小时不定的时间运行，因此需要将作业的进度反馈给用户。作业和它的任务都有一个状态信息，包括作业或任务的执行状态（e.g.,running,successfully completed,failed），maps和reduces的进度，作业counters的值，状态信息及描述。这些信息在job的执行过程中不断地变化，那么它是怎样反馈给客户端的呢？   当一个task运行时，它跟踪它的进度。对于map tasks，指的是输入执行的百分比；对于reduce tasks，有一点复杂，但系统还是能够估算reduce输入执行的进度：系统将所有的进度分成三部分，分别对应于shuffle的三部分。举个例子，如果task已经进行了reducer输入的一半，那么task的进度为5/6，这时因为task已经完成了copy和sort过程（各1/3），并且进行到reduce过程的一半（1/6）。   在MapReduce中进度由什么构成?   并不是所有的进度都能测量的，但是不管怎样，进度告诉Hadoop存在一个task正在运行。比如，一个任务写输入记录就是正在构成进度，虽然它或许不能用准确的百分比来描述，因为后面有些设置我们还不知道。   报告进度非常重要，它代表着Hadoop不会将一个正在运行的task标志位FAILED。下面是所有能产生进度的操作： l  读输入记录（在mapper或reducer中） l  写输出记录（在mapper或reducer中） l  在reporter中设置状态描述（使用Reporter的setStatus()方法） l  计数器增量（使用Reporter的incrCounter()方法） l  调用Reporter的process()方法   Tasks也有一组计数器用于统计在task运行时发生的一些事件，一些计数器是框架内置的，比如统计输出记录数量的计数器，而一些是由用户自定义的。   如果一个task报告进度，它会设置一个标签，表明当状态发生变化时通知tasktracker。每隔三秒钟，该标签会在一个分离的线程中被检测一次。如果设置了该标签，它会通知tasktracker当前task状态。与此同时，tasktracker每五秒钟向jobtracker发送心跳查询（5秒是最小值，心跳查询的间隔取决于集群规模：集群规模越大，间隔越大。）所有在jobtracker中将被tasktracker执行的tasks的状态，都会随心跳包发送出去。发送Counters没有这般频繁，因为它们可以走高带宽。   JobTracker汇集起所有这些更新信息，从全局来监控这些jobs和tasks的状态。最后，JobClient接受最新的状态信息，客户端还可以通过JobClient的getJob()方法来获得一个RunningJob实例，该实例包含一个Job的所有状态信息。     作业结束 当jobtracker接收到通知说，这次作业的最后一个task已经完成，它会将job的状态改为“successful”。当JobClient获取到作业的状态时，它知道job已经成功完成，然后JobClient打印信息告知用户作业已成功结束，最后从RunJob()方法返回。   用户可以通过job.end.notification.url属性设置jobtracker发送一个HTTP作业通告。   最后，jobtracker清除job的工作状态信息，并命令tasktracker也进行清除工作。 Figure 3:How status updates are propagated through the MapReduce system","title":"剖析MapReduce过程"},{"content":"IOC:英文全称：Inversion of Control，中文名称：控制反转，它还有个名字叫依赖注入（Dependency Injection）。 作用：将各层的对象以松耦合的方式组织在一起，解耦，各层对象的调用完全面向接口。当系统重构的时候，代码的改写量将大大减少。 理解依赖注入：     当一个类的实例需要另一个类的实例协助时，在传统的程序设计过程中，通常有调用者来创建被调用者的实例。然而采用依赖注入的方式，创建被调用者的工作不再由调用者来完成，因此叫控制反转，创建被调用者的实例的工作由IOC容器来完成，然后注入调用者，因此也称为依赖注入。 举个有意思的例子（来源于互联网） 假如我们要设计一个Girl和一个Boy类，其中Girl有Kiss方法，即Girl想要Kiss一个Boy，首先问题是Girl如何认识Boy？     在我们中国常见的MM认识GG的方式有以下几种：     A 青梅竹马    B 亲友介绍   C 父母包办     哪一种是最好的？ 1.青梅竹马：很久很久以前，有个有钱的地主家的一闺女叫Lily，她老爸把她许配给县太爷的儿子Jimmy，属于指腹为婚，Lily非常喜欢kiss,但是只能kiss Jimmy public class Lily{        public Jimmy jimmy;         public Girl()        {            jimmy=new Jimmy();        }        public void Kiss()        {            jimmy.Kiss();        }    }    public class Jimmy    {        public void Kiss()        {            Console.WriteLine(\"kissing\");        }    } 这样导致Lily对Jimmy的依赖性非常强，紧耦合。 2.亲友介绍：经常Kiss同一个人令Lily有些厌恶了，她想尝试新人，于是与Jimmy分手了，通过亲朋好友（中间人）来介绍 public class Lily{        public Boy boy;         public Girl()        {            boy=BoyFactory.createBoy();        }        public void Kiss()        {            boy.Kiss();        }    } 亲友介绍，固然是好。如果不满意，尽管另外换一个好了。但是，亲友BoyFactory经常是以Singleton的形式出现，不然就是，存在于Globals，无处不在，无处不能。实在是太繁琐了一点，不够灵活。我为什么一定要这个亲友掺和进来呢？为什么一定要付给她介绍费呢？万一最好的朋友爱上了我的男朋友呢？ 3.父母包办：一切交给父母，自己不用非吹灰之力，Lily在家只Kiss public class Lily{        public Boy boy;         public Girl(Boy boy)        {            this.boy=boy;        }        public void Kiss()        {            this.boy.Kiss();        }    } Well，这是对Girl最好的方法，只要想办法贿赂了Girl的父母，并把Boy交给他。那么我们就可以轻松的和Girl来Kiss了。看来几千年传统的父母之命还真是有用哦。至少Boy和Girl不用自己瞎忙乎了。这就是IOC，将对象的创建和获取提取到外部。由外部容器提供需要的组件。 在设计模式中我们应该还知道依赖倒转原则，应是面向接口编程而不是面向功能实现，好处是：多实现可以任意切换，我们的Boy应该是实现Kissable接口。这样一旦Girl不想kiss可恶的Boy的话，还可以kiss可爱的kitten和慈祥的grandmother 好在.net中微软有一个轻量级的IoC框架Unity，支持构造器注入，属性注入，方法注入如下图所示 具体使用方法如下图所示 using System;using Microsoft.Practices.Unity;namespace ConsoleApplication9{    class Program    {        static void Main(string[] args)        {            //创建容器            IUnityContainer container=new UnityContainer();            //注册映射            container.RegisterType<IKiss, Boy>();            //得到Boy的实例            var boy = container.Resolve<IKiss>();                       Lily lily = new Lily(boy);            lily.kiss();        }    }    public interface IKiss    {        void kiss();    }        public class Lily:IKiss    {        public IKiss boy;         public Lily(IKiss boy)        {            this.boy=boy;        }        public void kiss()        {            boy.kiss();            Console.WriteLine(\"lily kissing\");        }    }    public class Boy : IKiss    {        public void kiss()        {            Console.WriteLine(\"boy kissing\");        }    }}如果采用配置文件注册的话 <?xml version=\"1.0\" encoding=\"utf-8\" ?><configuration>  <configSections>    <section name=\"unity\" type=\"Microsoft.Practices.Unity.Configuration.UnityConfigurationSection,Microsoft.Practices.Unity.Configuration\"/>  <\/configSections>  <unity>    <containers>      <container name=\"defaultContainer\">        <register type=\"命名空间.接口类型1,命名空间\" mapTo=\"命名空间.实现类型1,命名空间\" />        <register type=\"命名空间.接口类型2,命名空间\" mapTo=\"命名空间.实现类型2,命名空间\" />      <\/container>    <\/containers>  <\/unity><\/configuration> 配置的后台代码： UnityConfigurationSection configuration = ConfigurationManager.GetSection(UnityConfigurationSection.SectionName)            as UnityConfigurationSection;configuration.Configure(container, \"defaultContainer\");可以通过方法ResolveAll来得到所有注册对象的实例： var Instances = container.Resolve<IKiss>(); Martin Fowler在那篇著名的文章《Inversion of Control Containers and the Dependency Injection pattern》中将具体依赖注入划分为三种形式，即构造器注入、属性（设置）注入和接口注入,习惯将其划分为一种（类型）匹配和三种注入： 类型匹配（Type Matching）：虽然我们通过接口（或者抽象类）来进行服务调用，但是服务本身还是实现在某个具体的服务类型中，这就需要某个类型注册机制来解决服务接口和服务类型之间的匹配关系； 构造器注入（Constructor Injection）：IoC容器会智能地选择选择和调用适合的构造函数以创建依赖的对象。如果被选择的构造函数具有相应的参数，IoC容器在调用构造函数之前解析注册的依赖关系并自行获得相应参数对象； 属性注入（Property Injection）：如果需要使用到被依赖对象的某个属性，在被依赖对象被创建之后，IoC容器会自动初始化该属性； 方法注入（Method Injection）：如果被依赖对象需要调用某个方法进行相应的初始化，在该对象创建之后，IoC容器会自动调用该方法。 我们创建一个控制台程序，定义如下几个接口（IA、IB、IC和ID）和它们各自的实现类（A、B、C、D）。在类型A中定义了3个属性B、C和D，其类型分别为接口IB、IC和ID。其中属性B在构在函数中被初始化，以为着它会以构造器注入的方式被初始化；属性C上应用了DependencyAttribute特性，意味着这是一个需要以属性注入方式被初始化的依赖属性；属性D则通过方法Initialize初始化，该方法上应用了特性InjectionMethodAttribute，意味着这是一个注入方法在A对象被IoC容器创建的时候会被自动调用。 public interface IA { }    public interface IB { }    public interface IC { }    public interface ID { }    public class A : IA    {        public IB B { get; set; }        [Dependency]        public IC C { get; set; }        public ID D { get; set; }        public A(IB b)        {            this.B = b;        }        [InjectionMethod]        public void Initalize(ID d)        {            this.D = d;        }    }    public class B : IB { }    public class C : IC { }    public class D : ID { } 然后我们为该应用添加一个配置文件，并定义如下一段关于Unity的配置。这段配置定义了一个名称为defaultContainer的Unity容器，并在其中完成了上面定义的接口和对应实现类之间映射的类型匹配。 <?xml version=\"1.0\" encoding=\"utf-8\" ?><configuration>  <configSections>    <section name=\"unity\" type=\"Microsoft.Practices.Unity.Configuration.UnityConfigurationSection,Microsoft.Practices.Unity.Configuration\"/>  <\/configSections>  <unity>    <containers>      <container name=\"defaultContainer\">        <register type=\"UnityDemo.IA,UnityDemo\" mapTo=\"UnityDemo.A, UnityDemo\"/>        <register type=\"UnityDemo.IB,UnityDemo\" mapTo=\"UnityDemo.B, UnityDemo\"/>        <register type=\"UnityDemo.IC,UnityDemo\" mapTo=\"UnityDemo.C, UnityDemo\"/>        <register type=\"UnityDemo.ID,UnityDemo\" mapTo=\"UnityDemo.D, UnityDemo\"/>      <\/container>    <\/containers>  <\/unity><\/configuration> 最后在Main方法中创建一个代表IoC容器的UnityContainer对象，并加载配置信息对其进行初始化。然后调用它的泛型的Resolve方法创建一个实现了泛型接口IA的对象。最后将返回对象转变成类型A，并检验其B、C和D属性是否是空 class Program    {        static void Main(string[] args)        {            UnityContainer container = new UnityContainer();            UnityConfigurationSection configuration = ConfigurationManager.GetSection(UnityConfigurationSection.SectionName) as UnityConfigurationSection;            configuration.Configure(container, \"defaultContainer\");            A a = container.Resolve<IA>() as A;            if (null!=a)            {                Console.WriteLine(\"a.B==null?{0}\",a.B==null?\"Yes\":\"No\");                Console.WriteLine(\"a.C==null?{0}\", a.C == null ? \"Yes\" : \"No\");                Console.WriteLine(\"a.D==null?{0}\", a.D == null ? \"Yes\" : \"No\");            }        }    } 从如下给出的执行结果我们可以得到这样的结论：通过Resolve<IA>方法返回的是一个类型为A的对象，该对象的三个属性被进行了有效的初始化。这个简单的程序分别体现了接口注入（通过相应的接口根据配置解析出相应的实现类型）、构造器注入（属性B）、属性注入（属性C）和方法注入（属性D）   a.B == null ? No   a.C == null ? No   a.D == null ? No","title":"理解依赖注入（IOC）和学习Unity"},{"content":"版本升级记录： 1.数据库脚本初始化自动化（支持多种数据库） 2.权限完善，增加按钮权限功能 3.增加代码生成器：单表模型和一对多（父子表）例子 4.增加Spring jdbc分页（SQL分离代码写法）例子 5.增加Highcharts 图像报表例子 6.修改代码生成器，支持maven工程 7.增加Jeecg开发手册（提供建表模板和共通封装等..） 下载地址：http://code.google.com/p/jeecg/downloads/list 博客原文：http://blog.csdn.net/zhangdaiscott/article/details/8272255","title":"JEECG(J2EE Code Generation) 基于代码生成器J2EE智能开发框架 发布新版本"},{"content":"  文档名称 YFIOs技术白皮书 版本 V1.1.0 说明 增加 技术特色和优势 章节 作者 叶帆 日期 2012-12-27 历史 V1.0.0  叶帆 2012-12-20 文档列表 http://www.sky-walker.com.cn/MFRelease/YF_document_list.pdf 1 前言 在工控领域，组态软件司空见惯，国外的iFix、InTouch、WinCC，国内的组态王、力控、MSCG等等。组态软件的出现彻底解决了软件重复开发的问题，实现模块级复用，好处不仅仅是提高了开发效率，降低了开发周期，更大的优势的是成熟模块的复用，大大提高了系统稳定性和可靠性。 所谓组态（Configuration），就是模块化任意组合（类似积木玩具）。组态软件的主要特点有： （1）、延展性。所谓延展性，就是系统的延续和易于扩展性，用组态软件开发的系统，当现场或用户需求发生改变时（包括硬件设备或系统结构的改变），用户无需做很多修改，就可以很方便地完成系统的升级和改造； （2）、易用性。组态软件对底层功能都进行了模块级封装，对于用户，只需掌握简单的编程语言（内嵌的脚本语言，类Basic或类C语言），甚至不需要编程技术，就能很好地，通过组态配置的方式完成一个复杂系统的开发和集成； （3）、通用性。不同用户根据系统的不同，利用组态软件提供的I/O驱动（如PLC、仪表、板卡、智能模块、变频器等等驱动）、数据库和图元，就能完成一个具有动画、实时数据处理、历史数据和图表并存，且具有多媒体功能和网络功能的系统工程，不受领域或行业限制。 但是无论是基于PC平台的组态软件还是基于ARM系统的嵌入式组态软件，其组态粒度都显过大，大部分通过串口、网口、CAN等通道把个系统模块连接在一起，在一定程度上增加了系统构建的成本和代价。 而以.NET Micro Framework为依托构建的轻量级嵌入式组态软件（YFIOs）就很好的解决了上述问题，除支持常规的串口、网口、CAN外，还支持USB、Wifi、ZigBee、SPI、I2C等通道，SPI、I2C片级总线的支持加上强大的托管代码（C#,VB.net）开发能力，使嵌入式硬件系统真正的组态化、模块化成为可能，这项技术的推出，无疑为快速打造形态各异，功能不同的产品提供了最有力的支撑。 2 YFIOs简介 YFIOs就是YFSoft I/OServer的简称，在物联网、云计算时代，一切以数据为中心，不同的传感器通过不同的方式接入网络，通过云计算的方式为不同的终端用户提供服务。 为了适应这种新形势的发展，加速和降低各种传感器、智能模块的入网代价，以微软成熟的.NET Micro Framework系统为基础，打造出物联网时代的轻量级嵌入式组态系统 —— YFIOs。 2.1 技术特色和优势 和传统组态或其他物联网、嵌入式等方案相比，有如下优势： （1）、组态式搭建系统，自动添加IO配置数据，驱动和策略开发接口对外开放； （2）、支持远程升级，远程调试。 （3）、由于.NET Micro Framework的跨平台特性，所以基于该框架的YFIOs也可以跨平台应用。 （4）、采用MicrosoftVisual Studio 2010模板进行驱动和策略进行C#开发，开发门槛较低，和windows平台的开发别无二致； （5）、驱动和策略可以在MicrosoftVisual Studio 2010开发环境中在线调试； （6）、策略可以和驱动联动，不仅可以直接调用驱动，还可以和驱动进行关联，事件触发的方式执行策略； （7）、策略不仅可以调用驱动，彼此之间还可以互相调用； （8）、驱动和策略可以加密，也可以绑定指定硬件运行，不仅可以保护用户的知识产权，还可以在此基础上为第三方客户提供增值服务。 （9）、运行时小巧轻便，不含YFHMI库的运行时仅19.2K，含MiniGUI、中文字库、四套图元库的运行时，也仅355K。 2.2 .NET Micro Framework简介 Microsoft .NET Micro Framework 将 .NET 的可靠性和效率与 VisualStudio的高生产率结合起来，以针对价格较低、资源受限的小型设备开发应用程序,可帮助人们使用熟悉的Visual Studio工具来构建托管的嵌入式应用程序。2009年5月，.NET MicroFramework采用Apache 2.0license，比Linux等开源软件更为彻底的方式实现了源代码完全开放。 2.2.1 哪些领域可以采用.NETMicro Framework技术？ .NET Micro Framework技术可以应用到：Sideshow、远程控制、智能家电、教育类机器、医疗电子、零售终端以及汽车电子等行业应用场景；此外由于.NET Micro Framework集成了各种接口，如串口、网口、Wifi、Zigbee、I2C、SPI、SDIO、USB等通信接口，加上其应用开发简便，所以在物联网时代，将大有作为。 2.2.2 .NET Micro Framework与Window CE和Windows XPEmbedded的区别？ .NET Micro Framework对存储器和处理器的要求更低。开发人员可以在低功耗、低成本的ARM7、ARM9、Blackfin和Cortex-M3处理器上使用该框架（不需要MMU支持），所开发出来的软件仅需要几百Kbytes的RAM或Flash/ROM存储空间。而WindowsEmbedded CE的托管代码环境需要约10~12Mbytes的存储空间，基于.NET的应用编程设备只需要较少的存储空间，降低了产品成本。 2.2.3 .NET Micro Framework与其他.NET平台的区别？ 作为.NET家族的一员，.NET MicroFramework是微软专门针对超轻量级平台设计的软件架构。与.NET Framework和.NET CompactFramework不同的地方是，.NETMicro Framework具有自启动的特性，并且在HAL层，微软将操作系统的必要特性引入，如：启动管理、中断处理、线程调度、内存管理等。.NET Micro Framework可以单独使用，不需要依托其它操作系统，因此占用空间很小。 2.3 YFIOs系统架构 YFIOs由三大部分构成，一是YFIOs运行时，包含YFIODB、YFIOBC、驱动引擎和策略引擎四部分；二是应用模块，包含驱动、策略和IO数据三部分；三是YFIOsIDE环境（YFIOsManager），该工具和Microsoft Visual Studio开发工具一起共同完成驱动、策略的开发、配置及部署工作。 系统架构图和YFIOs和.NET Micro Framework关系图（如下图所示）：       2.4 YFIODB YFIODB是一个在内存实现的数据库，主要存放IO数据，供驱动程序、策略程序直接访问，从而起到跨模块交换数据的目的。其IO数据一般可分两类，一种是内部IO数据，该类IO数据不绑定任何设备驱动，主要作为中间变量或临时变量来使用；另一种是设备IO数据，该类IO数据和实际的驱动程序进行绑定，该IO数据的值映射驱动所对应的设备参变量的值。 2.4.1 YFIODB库结构   2.4.2字段组成 序号 变量名称 长度 说明 1 Name 32 变量的名称 2 Type 2 数据类型B布尔型I整型F浮点型S 字符串 3 Value 32 变量的值 4 Comment 26 注释 5 RWMode 2 读写类型 0 只读 1 只写 2 读写(自动读) 3 读写(手动读) 4-只读(手动) 6 RWFlag 2 R 自动读 W 自动写  r 手动读 n读不操作 N 写不操作 7 LO 16 下限 8 HO 16 上限 9 DateTime 8 数据更新时YYYY(2B)MM(1B)DD(1B)HH(1B)mm(1B)SS(1B) 统计 136 1000个点需要  约132.8 K Byte 的内存 YFIODB本身仅仅是一个数据库框架平台，并不包含以上的字段信息，也不包含任何数据。YFIOs启动后，会根据以上字段定义的信息，创建指定大小的内存数据库表，并且把预先定义好的内部IO变量和设备IO变量填充到内存数据库中去。 2.4.3访问接口 YFIODB访问接口被操作类接口（IOPerate）进一步封装，而操作类接口是驱动和策略标准函数接口的第一个参数，所以任何一个驱动和策略程序都可以操作YFIODB。 相关操作接口定义如下：     //读数据     stringIORead(string name);     intIOReadInt(string name);     floatIOReadFloat(string name);     //读数据(扩展方式 变量名.字段名)     stringIOReadEx(string name);     //写数据（内部写）     intIOWrite(string name, stringdata);     intIOWrite(string name, intdata);     intIOWrite(string name, floatdata);     //写数据(扩展方式 变量名.字段名)     intIOWriteEx(string name, stringdata);     //外部写（直接写变量）     intExtern_IOWrite(string name, string data);     //变量读写模式     stringIOReadMode(string name); 需要说明的是，该接口提供的对YFIODB的写操作，并不是直接对YFIODB数据库某表某字段，进行写操作，而是根据一定的逻辑算法，对各表项综合操作（注意：扩展方式写操作，是直接对表中具体的项直接进行操作的）。驱动函数要采用内部写模式，执行后，会自动复位“W”标志位，而对策略函数来说，属于用户层面操作，所以要写YFIODB的时候，要采用外部写函数，执行后，函数会自动置位“W”标志位。 写YFIODB分内外的意义在于：策略函数仅仅是把变量的值写入数据库，而驱动才会真正的把该变量的值写入到实际的设备中去。而通过复位和置位“W”标志可以获知是否要写入到实际设备，或是否写入完成。 2.5 YFIOBC 和YFIODB不同，YFIOBC是用来供驱动程序和策略程序存储和交换大块数据而用的，如摄像头的图像数据。该结构设计的如同文件系统，可新建、删除和读写，其内容大小仅受设备内存的限制。 2.5.1 YFIOBC库结构      2.5.2 访问接口 和操作YFIODB接口一样，操作YFIOBC的接口也封装到操作类接口（IOPerate）中，所以驱动和策略程序都可以操作YFIOBC。 操作接口定义如下：     //删除内存数据条目     intIOBC_Del(string name);     //size=0 打开，size>0 创建     intIOBC_Create(string name, uint size);     //获取指定条目所分配的内存大小     intIOBC_GetLength(int hander);     //读写偏移设置     intIOBC_Seek(int hander, intoffset);     //读内存数据     intIOBC_Read(int hander, byte[]buffer, int offset, intcount);     //写内存数据     intIOBC_Write(int hander, byte[]buffer, int offset, intcount);     //关闭     intIOBC_Close(int hander); 该接口仿照文件操作方式进行操作，其作用类似Windows平台上的共享内存操作，读写都在内存中完成。 2.6驱动开发 一个驱动程序可对应一种设备，也可以对应一类设备，关键在于设备支持的协议是私有的，还是公开的，一般公开的协议，如Modbus，不同厂家的通信设备都有不同程度的支持（比如支持3号或16号指令），凡支持该协议的设备，都可以通过同一个设备驱动进行访问，唯一不同的就是设备地址、数据类型、起始地址和数据长度等参变量，我们可以根据实际需要，相应配置即可。 2.6.1 驱动接口类      public interface IDriver     {         DriverInfoGetDriverInfo();         intOnLoad(Device dv, IOperateop, object arg);         intOnRun(Device dv, IOperateop, object arg);         intOnUnload(Device dv, IOperateop, object arg); } 驱动程序必须要实现这四个函数接口，其中GetDriverInfo仅供上位机配置程序调用。 （1）、GetDriverInfo – 返回驱动相关信息（请参见2.5.3）。 （2）、OnLoad – 驱动被加载时，将自动调用OnLoad方法。用户可以在该函数内，完成一些初始化操作。 （3）、OnRun – 根据配置不同，该函数按指定的时间间隔连续被系统调用（如果时间间隔配置为0，则系统不会自动调用OnRun方法）。同一个接口配置的驱动，将共享一个线程，系统将依次调用该方法。 （4）、OnUnload – 驱动被卸载时，系统将调用OnUnload。（目前YFIOs系统不支持驱动卸载）。 2.6.2 通信接口     public enum DeviceConnMode     {         SerialPort = 0,         Ethernet,         CAN,         USB,         SPI,         I2C,         SDIO,         Zigbee,         AD,         DA,         I,         Q,         PWM,         Other,     } 2.6.3 驱动配置信息类     public class DriverInfo {     //32byte,驱动名称（要保证唯一）         public string Name;                                 //16byte,版本信息 public string Ver; //64byte,说明 public stringExplain;                             //16byte,开发者 public stringDeveloper;  //16byte,日期                         public string Date;                                //自动化标志         //0 bit 0 - 系统为你初始化通信接口 1 - 由驱动程序本身完成通信接口初始化         //1 bit 0 - 无操作                  1 - 由驱动程序本身完成IO变量添加         //2~31 bit 备用             public int AutoFlag;   //通信方式                             public DeviceConnMode ConnMode;         //64byte,设备制造商         public stringManufacturer;                 //32byte,设备类型         public string DeviceType;                           //设备参数 //硬件端口名称  空为无效项         public string PortAddrExplain;             //硬件端口默认值项选择（如果有的话）用\"|\" 分隔开，默认项为第一个         public string PortAddrValue; //端口参数名称  空为无效项                       public string PortConfigExplain;              //端口参数默认值项选择（如果有的话）用\"|\" 分隔开，默认项为第一个         public string PortConfigValue;    //设备地址名称  空为无效项                public string DeviceAddrExplain; //设备地址默认值项选择（如果有的话）用\"|\" 分隔开，默认项为第一个                   public string DeviceAddrValue;      //设备参数名称  空为无效项               public string DeviceConfigExplain; //设备参数默认值项选择（如果有的话）用\"|\" 分隔开，默认项为第一个         public string DeviceConfigValue;                   //项参数 //8*32 byte,连接项名称         public string[] ItemExplain;               //8*4 byte 默认值项选择（如果有的话）用\"|\" 分隔开，默认项为第一个         public string[] ItemValue;                           //扩展配置信息的长度如果为0，则表示没有（上位机管理程序使用） public int ConfigSize;                     } 2.6.4 扩展配置接口 如果驱动程序提供的标准配置项，不足以配置驱动，则可以自行定制驱动配置页，自行生成配置数据，驱动自行解析。 DriverInfo信息类中的最后一项ConfigSize，就是定义该配置信息的大小。驱动的实例类中会含有一个Config字节数组，存放上位机管理程序配置的信息。 （【接口说明】选项就是选择该驱动后，自动出现的页面，不过该页面并没有配置任何数据，仅仅起到提示说明的作用）     public interface IConfig     {         //建议面板大小319*203         Panel[]GetPanel(byte[] InitConfig,ConfigParameter parameter);         byte[]GetConfig(); }       public class ConfigParameter     {         public string[] IODataNames;         public string[] DeviceNames;         public string[] StrategyNames;         public object Sender;     } 上位机管理程序会向驱动配置面板提供当前所有IO内存变量名称，驱动名称和策略名称等等信息。 2.6.5 驱动的执行 驱动程序除了按设定的扫描时间周期执行外，还可以把扫描时间设置为0，表示不会自动运行。设置为该模式的驱动，一般被策略程序直接调用而得以执行。 另外驱动还可以设置为Disabled，这样该驱动任何方式的调用将被禁止，如该驱动不存在一样。 2.7 策略开发 可以把YFIOs运行时想象成一个支持多任务的操作系统，这样每个策略的OnRun接口，都可以当成一个进程的Main函数，唯一不同的是，这个Main函数被调用的机制多种多样（参见策略执行模式）。 策略就是一段代码，一段标准的.NETMicro Framework程序，可以根据项目的需求充分访问.NET Micro Framework已有的开发资源(如各类库函数)，编写任意功能的代码模块。 2.7.1 策略接口类     public interface IStrategy     {         StrategyInfoGetStrategyInfo();         intOnLoad(IOperate op, objectarg);         intOnRun(IOperate op, StrategyModemode, object arg);         intOnUnload(IOperate op, object arg); } 策略程序必须要实现这四个函数接口，其中GetStrategyInfo仅供上位机配置程序调用。 （1）、GetDriverInfo – 返回策略相关信息（请参见2.5.3）。 （2）、OnLoad – 策略被加载时，将自动调用OnLoad方法。用户可以在该函数内，完成一些初始化操作。 （3）、OnRun – 根据配置不同，该函数以事件、循环等等方式被系统自动调用。 （4）、OnUnload – 策略被卸载时，系统将调用OnUnload。（目前YFIOs系统不支持策略卸载）。  2.7.2 策略执行模式     public enum StrategyRunMode     {         None = 0,      //无动作           Loop,          //循环执行         System_Loop,   //系统循环执行         //事件驱动         Event_System_Launch_Before,         Event_System_Launch_After,         Event_System_Error_Process,         Event_Driver_Run_Before,         Event_Driver_Run_After, } 和最初的定义的执行模式不同，新版策略执行模块简化了许多。 （1）            None – 策略定义为该模式，意味着需要其它策略来调用才能被执行。系统本身只负责加载策略和调用策略的初始化接口， （2）     Loop – 系统自动为策略创建一个线程，然后按指定的间隔，连续调用策略的OnRun的接口。 （3）     System_Loop – 系统不会另外为策略创建线程，而是在主线程里（也就是Main函数中的while循环里）不断调用策略的OnRun接口，如果多个策略配置了该模式，则这些策略的OnRun接口将依次执行。建议包含界面的策略配置成这种执行模式，并且仅且只有一个这样的策略配置成这种模式。 （4）            Event_System_Launch_Before – 配置为该模式，策略将在YFIOs执行Launch函数之前执行该策略。Launch函数执行的功能主要是初始化驱动、挂载驱动事件策略、创建线程执行驱动、初始化策略和创建线程执行策略。 （5）            Event_System_Launch_After – 策略将在YFIOs执行Launch函数之后执行。 （6）            Event_System_Error_Process – 当系统出现异常和错误的时候，将会自动调用配置为该模式的策略。 （7）            Event_Driver_Run_Before – 该策略执行模式需要指定关联触发的驱动，在系统调用驱动OnRun接口之前，会自动执行配置该模式的策略。注意，当策略调用DriverRun接口来执行驱动的OnRun函数时，该事件也会被触发。 （8）            Event_Driver_Run_After – 和Event_Driver_Run_Before执行模式类似，只是在调用驱动的OnRun接口之后，触发该事件。 注意：策略并不仅支持一种策略执行模式，同一个策略可以配置多个执行模式，只要符合条件，该策略将会被调用。  2.7.3 策略的执行      策略除了按策略执行模式执行外，策略之间还可以互相调用，并且还可以直接调用指定名称的驱动程序的接口函数。     策略在配置的时候，也可以设置为Disabled，这样该策略的所有接口将无法访问，和该策略不存在一样。 2.7.4 扩展配置接口     和驱动程序的扩展配置接口相同，请参见2.5.4项的介绍。 2.8 YFIOs项目存储 2.8.1 项目存储映像图 2.8.2 项目信息头      public class ApplicationHead     {         public string Flag = \"YFIOs\";         //标志 YFIOs 8 byte         public uint Ver;                      //版本         public uint ApplicationHeadSize;      //ApplicationHead大小         public uint ChannelHeadSize;          //ChannelHead大小         public uint DeviceHeadSize;           //DeviceHead大小         public uint StrategyHeadSize;         //StrategyHeadSize大小         public uint StrategyModeSize;         //StrategyModeSize大小         public uint IOItemSize;               //IOItem大小         public uint IODataSize;               //IOData大小          public string Name=\"\";                //应用名称  32 byte         //服务器URL，128byte 既可以是IP+端口模式 192.168.0.1:80 ,也可以是标准url格式         public string Server = \"http://192.168.1.100\";                   public int MaxDBCount = 256;          //IO数据最大条目数         public int MaxBCCount = 8;            //IO数据块最大个数         public uint IODataCount;              //IO数据个数         public uint ChannelCount;             //信道个数         public uint StrategyCount;            //策略个数         //总调试模式开关，驱动中的debugmode为单个控制              public uint DebugMode = 0xEC;                public uint ConfigSize;               //扩展配置信息 } 2.8.3 信道信息头    public class ChannelHead {     //禁止执行 0 - 允许执行 1 - 禁止执行         public int Disabled;          //通道模式 0 - 分别打开端口 1 - 统一打开端口                        public int ChannelMode = 0; //通信方式         public DeviceConnMode ConnMode;      //端口地址 串口：1.串口：1...n 网络：端口号 ...         public int PortAddr;       //32byte,端口参数  如串口：波特率,数据位,校验方式,停止位如9600,N,8,1         public string PortConfig;   //设备个数         public uint DeviceCount;   } 2.8.4 驱动信息头      public class DeviceHead     {                public int Disabled;                  //0- 执行 1 - 禁止执行不调用相关函数         public string Name;                   //32byte,设备名称          public int AutoFlag;                  //自动化标志              public DeviceConnMode ConnMode;       //通信方式         public int PortAddr;                   //端口地址 1.串口：1...n 网络：端口号 ...         public string PortConfig;             //32byte,端口参数         public int DeviceAddr;                //设备地址         public string DeviceConfig;           //32byte,设备参数         public int Scantime;                  //扫描周期(ms) 如果为0，则禁止扫描         public int Overtime;                  //超时时间(ms)         public int ErrorScantime;             //故障扫描周期(s         public int ErrorMaxScantime;          //最长故障扫描周期(s)         public int AcceptBufferLength;        //接收缓冲区大小         public int SendBufferLength;          //发送缓冲区大小         public int ReadDataBufferLength;      //一次从端口读取的字符数         public int DebugMode;                 //debug模式，控制驱动是否显示一些调试信息         public uint IOItemCount;              //设备连接项个数         public uint ConfigSize;               //扩展配置信息         public uint PeSize;                   //pe文件的大小         public uint PeAddr;                   //pe文件存放的地址（相对地址）          } 2.8.5 策略信息头   public class StrategyHead     {         public int Disabled;                   //禁止执行，不调用相关函数         public string Name;                    //32byte,策略名称         public uintModeCount;                 //策略运行模式个数         public uint ConfigSize;                //扩展配置信息         public uint PeSize;                    //pe文件的大小         public uint PeAddr;                    //pe文件存放的地址（相对地址）          } 2.8.6 数据连接项    public class IOItem    {       public string Name;                   //32byte,内存变量名称（对数组，仅指数组名）       public int[] Param = new int[8];      //中间传递变量，由驱动程序自己设定，自己解释    } 2.8.7 IO数据     public class IOData     {         public string Name = \"\";        //32  数据名称         public string Type = \"\";        //2   数据类型 B布尔型 I整型 F浮点型 S 字符串         public string Value = \"\";        //32 变量的值         public string Comment = \"\";      //26 注释 //2  读写模式 0 只读 1 只写 2 读写(自动读) 3 读         public string RWMode = \"\";       写(手动读) 4-只读(手动) //2  R自动读 W 自动写 r 手动读 n读不操作 N 写不操作         public string RWFlag = \"\";               public string LO = \"\";           //16  下限         public string HO = \"\";           //16  上限         public string DateTime = \"\";     //8  数据更新时间     } 3 YFIOs应用开发 3.1 YFIOsManager简介 操作视频演示：http://v.youku.com/v_show/id_XNDkxMzgyNTgw.html 3.2 YFIOs应用实例 3.2.1 农村个人医疗远程助理 3.2.2 YFHMI物联网画面组态系统 操作演示视频：http://v.youku.com/v_show/id_XNDg2MjMxODI4.html 设备运行视频：http://v.youku.com/v_show/id_XNDg2MjM4MTQw.html 4相关资源 1、.NET Micro Framework官方网址 http://www.microsoft.com/netmf/default.mspx 2、.NET Micro Framework官方博客 http://blogs.msdn.com/netmfteam/ 3、中文博客 http://blog.csdn.net/yefanqiu http://www.cnblogs.com/yefanqiu 4、叶帆科技 http://www.sky-walker.com.cn/ 5、物联网中间件技术开发论坛 http://www.yfios.net YFIOs/YFHMI免费试用 从2012-12-21起YFIOs和YFHMI将开展为期半年的免费试用活动，符合申请条件的用户，将依次获取YFIOs和YFHMI的试用机会。 申请表下载：http://sky-walker.com.cn/MFRelease/document/yfios_yfhmi_application.doc","title":"【物联网中间件平台-02】YFIOs技术白皮书（V1.1）"},{"content":"作者：chszs，转载需注明。博客主页：http://blog.csdn.net/chszs Web服务的两种技术SOAP和REST，谁更好的争论一直持续了多年。我的看法是，REST应该是首选的Web服务，但SOAP并非一无是处。那么，什么时候应该使用SOAP呢？ 更适合使用SOAP的场景： 1）Web服务需要可靠性和安全的保证时； 2）Web服务的双方需要自己的标准数据交换格式时； 3）Web服务需要数据上下文和状态管理时。 如果你的需求遇到以上情况，那么最好是选择SOAP。","title":"反思Web服务的选择－对SOAP的再认识"},{"content":"备忘录模式，如它的名字所说，就是为了备忘的。以下很多内容来自GOF的设计模式，不得不佩服，经典就是经典。 定义： 在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。用它保存对象的当 前状态，以便于恢复。它的很重要的一点是在外部保存。 意图： 很多时候为了允许用户的撤销操作，需要保存当前的状态信息到某一个地方，然后到需要恢复的时候再取出来。一般来说，对象封装了它的内部状态， 外部不应该去访问它，那么如何将一个对象的内部状态保存在其他地方呢？于是我们迎来了备忘录模式。 类图解释： 上面一共三个类： Originator：原发器类，它创建一个备忘录，保存自己的状态到备忘录中，同时使用备忘录恢复自己的状态。 Memento：备忘录类，它存储原发器对象的内部状态。它提供了一个宽接口给原发器类，一个窄接口给负责人类。 CareTaker：负责人类，它保留着备忘录的引用，但是不能访问备忘录的内部。 协作图： 再看一下协作图就更明了： 当负责人需要保存原发器的状态时候，它调用原发器的CreateMemento接口，将返回的备忘录的指针保存下来，以便于恢复的时候使用。 原发器收到CreateMemento消息，它首先创建一个Memento对象，然后通过调用SetState将自己的状态传递给备忘录保存下来。 当负责人需要恢复原发器的状态的时候，它调用原发器的SetMemento接口，将存储的备忘录指针传递进去，原发器收到SetMemento消息，它根据传进来的Memento对象，调用Memento对象的GetState方法恢复原发器的状态。 代码： Head文件 #ifndef __ORIGINATOR_H#define __ORIGINATOR_Htypedef struct State{\t//int m_nState;\tint m_nXpos;\tint m_nYpos;}State;//原发器需要保留自己的状态class Memento;//原发器，需要保存自己的状态到备忘录class Originator{public:\tvirtual ~Originator(){}\tOriginator(){\t\t\tm_sState.m_nXpos = 0;\t\t\tm_sState.m_nYpos = 0;\t}\tstatic Originator* Instance();\tMemento* CreateMemento();\tvoid SetMemento(const Memento*);\tvoid MoveTo(int, int);\tvoid ShowState();protected:private:\tState m_sState;\tstatic Originator* m_pInstance;};//备忘录提供宽接口给原发器，窄接口给管理者class Memento{public:\tvirtual ~Memento(){}protected:private:\tfriend class Originator;\tMemento(){\t\tm_sState.m_nXpos = 0;\t\tm_sState.m_nYpos = 0;\t}\tvoid SetState(State s){\t\tm_sState = s;//结构体复制\t}\tState GetState()const{\t\treturn m_sState;\t}\tState m_sState;};//管理者，负责保留着备忘录的指针class MoveCommand{public:\tMoveCommand():m_pMemento(0){}\tvoid Execute();\tvoid UnExecute();\tvoid ShowState();protected:private:\tMemento* m_pMemento;};#endif Cpp文件： #include \"Originator.h\"#include <stdio.h>//原发器是单例模式Originator* Originator::m_pInstance = NULL;Originator* Originator::Instance(){\tif(m_pInstance == NULL){\t\tm_pInstance = new Originator();\t}\treturn m_pInstance;}//保存自己的状态到备忘录Memento* Originator::CreateMemento(){\tMemento* m = new Memento();\tm->SetState(m_sState);\treturn m;//让备忘录帮忙保存它的状态}//从备忘录中恢复状态void Originator::SetMemento(const Memento* m){\tm_sState = m->GetState();}//更改当前原生的状态void Originator::MoveTo(int x, int y){\tm_sState.m_nXpos = x;\tm_sState.m_nYpos = y;}void Originator::ShowState(){\tprintf(\"State: %d, %d\\n\",m_sState.m_nXpos,m_sState.m_nYpos);}//管理者，使用原生器的创建备忘录，和从备忘录恢复的方法void MoveCommand::Execute(){\tOriginator* ot = Originator::Instance();\tm_pMemento = ot->CreateMemento();\tot->MoveTo(1,2);}//取消命令 void MoveCommand::UnExecute(){\tOriginator* ot = Originator::Instance();\tot->SetMemento(m_pMemento);}void MoveCommand::ShowState(){\tOriginator* ot = Originator::Instance();\tot->ShowState();} main文件： #include <iostream>#include \"Originator.h\"using namespace std;int main(){\tMoveCommand mv;\tmv.ShowState();\tmv.Execute();\tmv.ShowState();\tmv.UnExecute();\tmv.ShowState();\treturn 0;} 输出： 解释main文件： 1，首先创建一个命令对象， 2，调用命令对象的展示状态方法，从而调用Originator的单例方法来创建对象并打印状态(Originator默认为0,0) 3，Execute执行移动命令，首先创建备忘录，保存它的引用，然后移动坐标 4，ShowState打印状态 5，UnExecute，取消命令，首先设置备忘录，从而调用备忘录的GetState方法，恢复状态 6，ShowState打印状态","title":"备忘录模式"},{"content":"无须刻意套用某种设计模式，模式的应用纯属自然的选择。 如果你要买辆车，你会怎么做 就我而言 从网上选好车型查过报价，到实体店找一位漂亮的销售小姐，咨询具体的价位及相关服务和优惠。付钱提车。 整个过程中：适合哪些设计模式呢 我需要一辆车，自己当然没法造的出来。于是找到卖车的一方，他们联系造车的工厂，工厂在造车的过程肯定会用到各种零部件，有些是他们自己能生产的，至于他们所不能的便由车厂联系相关上游零部件制造商，最终组装成一部车。 这里面又有哪些模式的思想呢","title":"设计模式.笔记.结合生活场景理解"},{"content":"软件系统的本质是复杂的，开发团队的任务就是制造出简单的假象。 软件的复杂性是其根本特征，原因在于： 问题域的复杂性：软件系统一般都是处理逻辑或业务规则比较复杂的问题。 管理开发过程的困难性：不存在标准的流程，且现有的各种流程都只适合特定的团队、项目或者产品。 软件实现的灵活性：软件的实现是没有标准的，即便存在一些所谓的原则（如面向对象设计原则），这些原则也可以在进度或特定限制下妥协。 描述离散系统行为的问题：离散系统永远都只能是对连续过程的抽样和模拟，这就使得系统一直是从一个状态变到另一个状态，而这些状态又容易受到外部的干扰。 复杂系统的5个属性 层次结构：复杂系统的架构是它所有的组件以及这些组件之间的层次结构的函数。 相对本原：基础组件的选择或者说抽象取决于系统的观察者。 分离关注：注意组件内部作用与组件间作用的差异，以此来分离系统。 共同模式：复杂系统具有共同的模式，因此组件的复用成为可能。 稳定的中间形式：复杂系统是由简单系统演变而来的。 复杂系统的这些属性为开发者去开发软件系统提供了一些指导准则与探索方向。","title":"软件系统的复杂性"},{"content":"在用spring做数据源配置的时候，如果代码中有用ClassPathXmlApplicationContext去加载spring配置文件，那么每次运行到此处代码，spring都会重新获得一个数据库连接。 如果浏览量太大就会导致超出数据库连接会话上写的错误，比如oracle会报出ORA-12519错误，临时修改数据库连接数治标不治本。 处理方式; 1、将需要用ClassPathXmlApplicationContext手动加载spring文件的类放到spring配置文件中去实例化，禁用ClassPathXmlApplicationContext直接调用。 2、将ClassPathXmlApplicationContext加载spring文件放到全局常量中(static标识)。 3、使用WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext)在服务器启动时候直接加载web.xml配置中的spring配置文件 推荐第三种，并做详细介绍： public class SpringDBInit{    /**     * 系统应用spring环境     */    private static ApplicationContext ctx;    /**     * 单实例对象     */    private static SpringDBInit instance = null;    private SpringDBInit()    {    }    /**     * 获得单实例对象     *      * @return     */    public static SpringDBInit getInstance()    {        if (instance == null)        {            synchronized (SpringDBInit.class)            {                if (instance == null)                {                    instance = new SpringDBInit();                }            }        }        return instance;    }    /**     * 初始化Spring组件     */    public void init(Properties props)        throws Exception    {        loadContextXML(props);    }    /**     * 加载spring对象     *      * @param props     */    private void loadContextXML(Properties props)        throws Exception    {        /*         * LogFactory.getInstance().logRun(RunPriority.INFORMATIONAL,         * LogConstants.sysLogConstants.INT_SPRING_START, null );         */        try        {            ServletContext servletContext = (ServletContext) props                .get(\"APP_CONTEXT\");            if (servletContext != null)                ctx = WebApplicationContextUtils                    .getRequiredWebApplicationContext(servletContext);        }        catch (Exception e)        {            e.printStackTrace();        }        if ((ctx == null) || (ctx.getBeanDefinitionNames().length == 0))        {        }    }    /**     * 得到一个spring的配置对象     *      * @param name     * @return     */    public Object getBean(String name)    {        if (ctx == null)            return null;        else            return ctx.getBean(name);    }    /**     * 获取单个信息     *      * @param key     * @param object     * @param request     * @return     */    public static String getMessage(String key, Object[] object, Locale locale)    {        return ctx.getMessage(key, object, locale);    }} public class SpringDBUtil{    /**     * sjb管理类实例     */    private static SpringDBInit sdb = SpringDBInit.getInstance();    /**     * 得到一个系统配置 bean     *      * @param name bean的配置名称     * @return 如果系统没有加载返回 null     */    public static Object getBean(String name)    {        return sdb.getBean(name);    }} public class SpringInitServlet    extends HttpServlet{    static final long serialVersionUID = -1111516993124229949L;    /**     * 启动对象实例     */    private SpringDBInit sdbinit = SpringDBInit.getInstance();    /**     * servlet初始化     */    public void init(ServletConfig config)        throws ServletException    {        super.init(config);        Properties props = new Properties();        props.put(\"APP_CONTEXT\", config.getServletContext());        // 文件路径        String prefix = getServletContext().getRealPath(\"/\");        // web应用路径        props.put(\"APP_PATH\", prefix);        try        {            sdbinit.init(props);        }        catch (Exception e)        {        }    }} web.xml配置： <servlet>\t\t<servlet-name>springInitServlet<\/servlet-name>\t\t<servlet-class>com.panda.util.springDB.SpringInitServlet<\/servlet-class>\t\t<load-on-startup>1<\/load-on-startup>\t<\/servlet>","title":"请慎用spring-ClassPathXmlApplicationContext手动加载spring配置文件"},{"content":"翻译的是这本书： Chapter 1.Design Patterns and MapReduce MapReduce 是一种运行于成百上千台机器上的处理数据的框架，目前被google，Hadoop等多家公司或社区广泛使用。这种计算框架是非常强大，但它没有提供一个处理所谓“big data”的通用，普遍的情形，所以它能很好的解决一些问题，在处理某些问题上也存在挑战。这本书教给你在什么问题上适合使用MapReduce和怎样高效的使用它。   初次接触时，很多人没有意识到MapReduce是一种计算框架而不仅仅是一个工具。你必须找到合适的map和reduce框架作为合适的解决方案，而这种map和reduce可能并不适用于其它情形。MapReduce算不上是特征，更确切的说是一种规则。   这使得问题解决起来更容易也更难了。它明确告诉你能做什么不能做什么，比起通常使用的方法，它提供的可选方式也少了。同时，理解怎样用规则解决问题需要灵活的头脑和思维的转变。   开始学习MapReduce非常像递归的学习：在找出问题的递归情形上存在挑战，当你一旦发现，问题也就变得清晰，简明，优雅。在很多情况下，你必须考虑到被MapReduce job，特别是内部集群网络使用的的系统资源的利用率。这里要权衡的是：指定的MapReduce框架是否有能力在分布式计算中处理数据，而不去考虑并发，鲁棒性，数据规模及其它的挑战。使用独特的系统，独特的解决问题的方式，便引入了设计模式。   什么是MapReduce的设计模式？它是一种使用MapReduce解决常规数据处理问题的模板。模式不会限定于特定的领域，比如：文本处理或图形分析。它只是一种处理问题的通用手段。 使用设计模式就是使用被久经考验并证明是好的设计原则来更好的构建你的软件。   由于一些原因，设计一款好的软件存在挑战性，想在MapReduce里实现一种好的设计也是相似的。就像好的程序猿能够把创作出不好的软件归因于糟糕的设计，好的程序猿也能创作出差的MapReduce算法。使用MapReduce时，我们不仅要保证代码的整洁和可维护性，还要保证分布于成百上千各节点上所要计算的TB甚至PB数量级数据的job的性能。除此之外，这个job还可能存在与共享集群上其他job存在竞争。这使得使用MapReduce时选择一种正确的设计变得极其重要，用的好的话，在性能上能获得几个数量级的提高。在我们深入讨论设计模式之前，先说说怎样和为什么设计模式和MapReduce一起使用会很有意义，还有需要具备的知识及从哪获得。   Design Patterns 众多的设计模式已经让开发者们悠哉悠哉了很多年。他们是通用，可复用的解决问题的工具，所以开发者可以在短时间内想出克服障碍的方法并进行下面的开发。它们也是有经验的开发者们用一种简洁的方式把他们的知识传递给下一代的手段。   在软件工程设计模式领域，一个重要的里程碑就是这本书：Design Patterns: Elements of Reusable Object-Oriented Software, by Gamma etal. (Addison-Wesley Professional, 1995)。众人所知的“Gang of Four”book。在这本非常流行的书里，没有一个模式是新的，并且已经使用了好多年。它仍然非常有影响力的原因是：作者花时间证明了最重要的设计模式在面向对象编程中普遍适用。自从这本书1994年发行至今，很多对设计感兴趣的人让这些模式口口相传，或出现在各种学术会议，期刊，互联网。   设计模式已经经得起时间考验并显示了正确的抽象度：不确定性，即有太多的的模式要记忆并且很难适用一个问题。不通用性，大量工作涌入一个模式去运行。这种抽象度也带来一个重要的好处：提供给开发者口头和书面交流的通用语言。简单的说“abstract factory”要比去解释抽象工厂是什么是什么要容易的多。并且，看到别人写的实现抽象工厂的代码时，也就大体知道要完成什么样的工作。   MapReduce设计模式在局部的问题和情况下也适用于这样的规则。它提供通用的框架用于解决数据计算问题，但不需要指定问题所在的领域。有经验的MapReduce开发者能把解决通用问题的知识传递给初学者。这点是极其重要的，因为MapReduce是一种新兴的技术并且被快速的被接受，每天都有很多程序猿加入社区。MapReduce设计模式也提供了一种团队合作解决MapReduce问题时的公用语言。设想一种情形，开发者说应该使用“reduce-side join”代替“map-side replicated join”比解释它们各自底层的实现机制更简明。   现在MapReduce世界的状态跟1994年前面向对象世界很相似。模式已经通过博客，站点比如StackOverflow，深入其它书籍中，深入全球先进的技术开发团队，组织中。写这本书的目的不是提供现在还没有人见过的开创性的MapReduce问题的处理方式，而是收集了各自领域有经验的开发者分享的模式。   注释：目前提供的设计模式，真实的MapReduce范例方面的经验在使用的时候仍然需要深入理解。当你用这本书或其他地方看到的模式解决一个新的问题的时候，密切注意”Applicability”部分。   对大多数部分，书中的模式是平台无关性的。MapReduce被Google以一种没有任何实际源代码的范例发布，不管作为独立系统（例如：Hadoop，Disco，Amazon Elastic MapReduce）还是查询语言系统（例如：MongoDB, Greenplum DB, Aster Data），已经被实现了好几次。为了让设计模式更倾向于通用，我们站在hadoop角度写这本书。很多模式可以应用于其他系统，比如MoongoDB，因为他们概念上的架构是一致的。但是，很对技术细节上由于实现的不同而不同。“Gang of Four“的设计模式使用c++写的，但开发者更倾向于希望用比较流行的语言比如ruby，python。书中的模式对各种系统是可用的，而不仅仅对hadoop本身。你可以用书中的例子代码作为自己开发的向导。   MapReduce History 为什么说写本MapReduce设计模式的书是个很好的想法呢？确切的一点，社区的强势和范例的普遍使用度已经达到了可以写一些综合的开发者可以共享的设计模式的程度。几年前，当hadoop还在摇篮里的时候，还没被人们理解它能够胜任什么。但是MapReduce被采纳的速度是值得注意的。它来自于2004年google一篇有趣的论文，并被迅速接受，在2012年成为业界分布式数据处理的标准。   MapReduce具体的起源是有争议的，但是我们最先想起的是2004年下载的那篇Jeffrey Dean and SanjayGhemawat写的论文：“MapReduce: Simplified Data Processing on LargeClusters”。这篇文章描述了google如何分割，处理，整合他们令人难以置信的大数据集。   随后，开源软件先驱Doug Cutting，开始做MapReduce的实现用于解决可扩展数据，去构建开源搜索引擎Nutch。随后yahoo也开始投入研究，Hadoop分割出来成为apache顶级项目。如今，很多个人和组织都在为hadoop项目做贡献。每一次新的发行版都有新的功能和性能上的提升。   几个其他开源项目都是在hadoop基础之上建设的，并且数量还在增长。许多比较流行的，比如：pig，hive，hbase，Mahout，zookeeper。Doug Cutting和其他hadoop专家已经多次提到，hadoop将会成为分布式应用程序运行的分布式操作系统的核心。在这本书里，我们将会用最少通用的规范解释hadoop ecosystem和java MapReduce的例子。在一些章节模式相似的部分，我们将会概述pig和hive sql的对比。   MapReduce and Hadoop Refresher 这部分的重点是快速复习hadoop中的MapReduce，因为书中的代码例子是基于hadoop的。初学者可以进一步参考的资源有Tom White’s Hadoop:The Definitive Guide或者Apache Hadoop website。这些书可以帮你搭建一个可以运行书中例子的完整的环境。   Hadoop MapReduce jobs可以切分成一系列运行于分布式集群中的map和reduce任务，每个任务只运行全部数据的一个指定的子集，以此达到整个集群的负载平衡。Map任务通常加载，解析，转换，过滤数据，每个reduce处理map输出的一个子集。Reduce任务会去map任务端copy中间数据来完成分组，聚合。用这样一种简明直接的范式，从简单的数值聚合到复杂的join操作和笛卡尔操作，解决这么广泛的问题真的令人难以置信。   mapReduce 的输入是hdfs上存储的一系列文件集。在hadoop中，这些文件被一种定义了如何分割一个文件成分片的input format来分割，一个分片是一个文件基于字节的可以被一个map任务加载的一个块。   每个map任务被分为以下阶段：record reader，mapper，combiner，partitioner。Map任务的输出叫中间数据，包括keys和values，发送到reduce端。Reduce任务分为以下阶段：shuffle，sort，reduce，output format。运行map任务的节点会尽量选择数据所在的节点。这种情况下，不会出现网络传输，在本地节点就可以完成计算。   Record reader Record reader会把根据input fromat生成输入分片翻译成records。Record reader的目的是把数据解析成记录，而不是解析数据本身。它把数据以键值对的形式传递给mapper。通常情况下键是偏移量，值是这条记录的整个字节块。自定义record reader 超出本书的范围。我们假设你有了处理数据适合的record reader。 Map Map阶段，会对每个从record reader处理完的键值对执行用户代码，这些键值对又叫中间键值对。键和值的选择不是任意的，并且对MapReduce job的成功非常重要。键会用来分组，值是reducer端用来分析的数据。这本书会在设计模式方面提供大量的细节去解释键值对的选择。设计模式之间一个主要的区别是键值对的语义。 Combiner Combiner 是一个map阶段分组数据，可选的，局部reducer。它根据用户提供的方法在一个mapper范围内根据中间键去聚合值。例如：数的总和是各个部分数量的和，你可以先计算中间的数目，最后再把所有中间数目加起来。很多情况下，这样能减少数据的网络传输量。发送（hello world，1）三次很显然要比发送（hello world，3）需要更多的网络传输字节量。Combiners可以被广泛的模式替换。很多hadoop开发者忽视combiner，但能获得更好的性能。我们需要指出的是哪一种模式用combiner有好处，哪一种不能用combiner。Combiner不会保证总会执行，所以它是一个整体逻辑。 Partitioner Partitioner会获取从mapper（或combiner）来的键值对，并分割成分片，每个reducer一个分片。默认用哈希值，典型使用md5sum。然后partitioner根据reduce的个数执行取余运算：key.hashCode() % (number of reducers)。这样能随即均匀的根据key分发数据到reduce，但仍然要保证不同mapper的相同key要到同一个reduce。Partitioner也可以自定义，使用更高级的样式，例如排序。然而，更改partitioner很少用。Partitioner的每个map的数据会写到本地磁盘，并等待对应的reducer检测，拿走数据。 Shuffle and sort Reduce任务开始于shuffle和sort阶段。这一阶段获取partitioner的输出文件，并下载到reduce运行的本地机器。这些分片数据会根据key合并，排序成一个大的数据文件。排序的目的是让相同的key相邻，方便在reduce阶段值得迭代处理。这一阶段不能自定义，由框架自动处理。需要做的只是key的选择和可以自定义个用于分组的比较器。 Reduce Reduce 任务会把分组的数据作为输入并对每个key组执行reduce方法代码。方法会传递key和可以相关的所有值得迭代集合。很多的处理会在这个方法里执行，也就会有很多的模式。一旦reduce方法完成，会发送0或多个键值对到output format。跟map一样，不同的reduce依据不同的逻辑情形而不同。 Output format Output format会把reduce阶段的输出键值对根据record writer写到文件里。默认用tab分割键值对，用换行分割不同行。这里也可以自定义为更丰富的输出格式，最后，数据被写到hdfs，自定义 output format也超出本书范围。   Hadoop Example: Word Count 现在你已经清楚了整个mapreduce的过程，下面看一个简单的例子。单词计数程序是mapreduce界权威的例子。简单直接表明mapreduce处理的高效。很多人抱怨单词计数例子被过度使用，但愿书中后面的部分能弥补这一点。   在这个例子中，我们使用StackOverflow上用户提交的word count。拿出文本域的一部分处理，我们就可以看到每个单词出现的次数。其中一条记录是这样的：   <row Id=\"8189677\" PostId=\"6881722\" Text=\"Have you looked at Hadoop?\" CreationDate=\"2011-07-30T07:29:33.343\" UserId=\"831878\" />   Id是8189677，邮编6881722，用户编码831878。邮编和用户编码可以作为其它数据部分的外键。后面的join模式中会讲怎样做数据集的join。   下面一段代码是一段框架代码，使用它可以编写不同的mapreduce job并运行。这段代码是通用的，被誉为“boiler plate”。你会看到我们所讲的大部分模式都用这套框架。   这段代码来自hadoop中“word count”例子： importjava.io.IOException; importjava.util.StringTokenizer; importjava.util.Map; importjava.util.HashMap; importorg.apache.hadoop.conf.Configuration; importorg.apache.hadoop.fs.Path; importorg.apache.hadoop.io.IntWritable; importorg.apache.hadoop.io.Text; importorg.apache.hadoop.mapreduce.Job; importorg.apache.hadoop.mapreduce.Mapper; importorg.apache.hadoop.mapreduce.Reducer; importorg.apache.hadoop.mapreduce.lib.input.FileInputFormat; importorg.apache.hadoop.mapreduce.lib.output.FileOutputFormat; Hadoop Example: Word Count | 7 importorg.apache.hadoop.util.GenericOptionsParser; importorg.apache.commons.lang.StringEscapeUtils; public classCommentWordCount { public static classWordCountMapper extendsMapper<Object,Text, Text, IntWritable> { ... } public static classIntSumReducer extendsReducer<Text,IntWritable,Text, IntWritable> { ... } public staticvoid main(String[]args) throws Exception{ Configuration conf= newConfiguration(); String[]otherArgs = newGenericOptionsParser(conf,args).getRemainingArgs(); if(otherArgs.length!= 2) { System.err.println(\"Usage: CommentWordCount <in> <out>\"); System.exit(2); } Job job= newJob(conf,\"StackOverflow Comment Word Count\"); job.setJarByClass(CommentWordCount.class); job.setMapperClass(WordCountMapper.class); job.setCombinerClass(IntSumReducer.class); job.setReducerClass(IntSumReducer.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(IntWritable.class); FileInputFormat.addInputPath(job,new Path(otherArgs[0])); FileOutputFormat.setOutputPath(job,new Path(otherArgs[1])); System.exit(job.waitForCompletion(true) ? 0 : 1); } }   框架的目的是编排job。Main方法的前几行用于解析命令行参数。然后用计算类，输入输出路径设置job。大致如此。仅仅保证类名正确和输出key，value types匹配reduce（此处原文是map，本人认为有误）的输出类型。   你将看到不同模式之间在job.setCombinerClass上会有不同，在一些情况下，combiner由于reduce的特殊性而不能使用。还有的情况下，combiner类不同于reduce类。在“word count”中，combiner的使用简单，高效。   下面是解析，准备数据的mapper代码。先清除掉单引号，非字符用空格代替等文本清洗后，文本被分割成单词列表，中间key就是单词本身，value为1。这意味着每个单词都会看到一次。如果一行里某单词出现两次，我们也会在单词列表中看到这个键值对“单词：1“两次。最后，所有的数据都会加到每个单词的全局计数字段里去。   public static classWordCountMapper extendsMapper<Object,Text, Text, IntWritable> { private final staticIntWritable one =new IntWritable(1); privateText word =new Text(); publicvoid map(Object key,Text value,Context context) throwsIOException,InterruptedException { // Parse the input string into a nice map Map<String,String> parsed = MRDPUtils.transformXmlToMap(value.toString()); // Grab the \"Text\" field, since that is what we are counting over String txt= parsed.get(\"Text\"); // .get will return null if the key is not there if(txt== null) { // skip this record return; } // Unescape the HTML because the data is escaped. txt= StringEscapeUtils.unescapeHtml(txt.toLowerCase()); // Remove some annoying punctuation txt= txt.replaceAll(\"'\",\"\"); // remove single quotes (e.g., can't) txt= txt.replaceAll(\"[^a-zA-Z]\",\" \"); // replace the rest with a space // Tokenize the string by splitting it up on whitespace into // something we can iterate over, // then send the tokens away StringTokenizer itr= newStringTokenizer(txt); while(itr.hasMoreTokens()) { word.set(itr.nextToken()); context.write(word,one); } } } 第一个方法, MRDPUtils.transformXmlToMap,是一个解析数据时出于友好提示的打印帮助信息的方法。你会看到我们的例子经常用到。它主要获取一行xml格式的记录（有着透明的格式）并根据属性把值放入map中。   下面，要把注意力放到wordcountMapper类，代码有一点复杂。大多数工作都在这里做。第一个要注意的是父类的类型： Mapper<Object,Text, Text, IntWritable> 它们分别是，输入键，输入值，输出键，输出值。我们不关心输入键，所以用Object。因为我们一行一行以文本格式读入数据，所以输入值为Text（hadoop中特殊的string类型）。输出键和值是Text和IntWritable是因为我们使用单词作为键，出现次数作为值。   Notice：mapper的输入key和value是由job的配置类FileInputFormat指定的。默认实现类是TextInputformat，字节偏移量作为键，是LongWritable类型，文本值作为值，是Text类型。使用不同的input format会是不同的键值类型。   直到代码底部StringTokenizer的使用，我们仅仅是清洗文本。我们反转义数据，是因为文本被存储成转义的方式以方便xml解析。下一步，我们删除杂散的标点符号以便统一认为“hadoop!””hadoop?””hadoop”是相同的单词。最后，给每个单词赋值1，表示出现次数。Mapreduce框架然后运行shuffle和sort，输出的键值对给reduce任务。   最后看下reducer代码，相对来说比较简单。Reduce方法，每次以相同key为一组来调用，在这里是以每个单词为一组。通过迭代数值类型的值得集合，来计算求和。最终的结果就是每个单词出现的次数。     public static classIntSumReducer extendsReducer<Text,IntWritable,Text, IntWritable> { privateIntWritable result =new IntWritable(); publicvoid reduce(Text key,Iterable<IntWritable>values, Context context)throws IOException,InterruptedException { intsum =0; for(IntWritable val: values) { sum+= val.get(); } result.set(sum); context.write(key,result); } }   跟mapper一样，我们通过父类模板指定了输入输出类型。输入键值必须匹配map的输出键值。Reduce的输出键值必须匹配job配置的FileOutputFormat中的内容。在这里，我们使用默认的TextOutputFormat，能将任意两个writable类型对象作为输出。   Reduce方法跟map的签名不同，那就是，在所有值（同一key）上进行迭代而不是仅处理一个值。那是因为你可以迭代同一个key的所有值。Reduce中的key是非常重要的，相比于map中的key来说。   传递给context.Write的数据会写到输出文件。每个reduce一个文件，如果你想把它们合起来还必须进一步处理。   Pig and Hive Hive和pig在hadoop生态系统中对MapReduce设计模式来讲不是很需要。然而，我们也要找机会解释为什么设计模式仍然很重要。   Pig和hive是更高级抽象的MapReduce。它们提供的接口里对map或reduce什么都不做，但是系统会解析高级语言成为mapreduce jobs。跟关系型数据库中解析sql为具体数据操作的行为的执行计划很相似，hive和pig翻译它们的语句为MapReduce操作。   正如在这本书里相同的部分我们将要看到的，pig和hiveql相比于原生java写的hadoop程序来说，显得更为整洁。例如，用java解释全局排序要写几页的代码，但用pig仅仅几行代码。   为什么在有可选择的hive和pig时，我们任然写java mapreduce呢？为什么本书的作者花了很多时间解释怎么用上百行代码实现一件事情，而相同的事情也可以用几行代码解决？这里有两个主要的原因。   第一，这样可以从更底层理解MapReduce的工作原理。如果开发者理解了pig是怎样运行reduce端join，他将会做出更明智的选择。不理解MapReduce原理而去使用pig和hive可以导致危险的行为。你可以从更高一层的接口受益并不代表你可以忽视某些细节。在大型MapReduce集群上更应遵守必要的规则。   第二，到目前为止，hive和pig还没有完全实现应有的功能和成熟。很明显还没达到他们的全部潜能。现在，他们不能把用java写的MapReduce完全实现。这将随着发行版本的不断发行而改变一些。比如说，在pig0.6版本，你的团队50%的分析能用pig，而在0.9版本中，会达到90%。伴随着每一版的发行，随之而来的也有更高一层的抽象。有趣的事情是，像软件工程这类事物的趋势，剩下的10%问题不能用更高级的抽象解决会受到到多数人的批评和反对。这就像，java语言已经成为最流行的工具语言，而一些人实际上还在用汇编语言。   当你能够用hive或pig写MapReduce语言的时候，一些主要的高级抽象带来的好处有，可读性，可维护性，开发周期和自动优化。很少出现常见的性能问题是间接的严重的原因导致的。这些分析成批运行并已经运行了几分钟，那么多一两分钟又有什么关系？有些时候，hive或pig中的执行计划的优化比你写的代码要好的多。在处理小部分数据时，hive或pig会增加的额外的时间有点多，这时你应该写java MapReduce。   Pig和hive比其它东西更能影响MapReduce的设计模式。他们出现的新特性可以成为MapReduce中的设计模式。同样的，更多的设计模式也会因MapReduce而发展，很多流行的模式会成为更高层次优秀的抽象。   Pig和hive有他们自己的模式，随着专家们解决越来越多的问题，他们也会记录它们。Hive得益于是用了几十年的sql样式，但不是所有的sql在hive中都适用，反过来也一样。可能随着这些平台越来越流行，cookbook和design pattern类的书会写它们。","title":"MapReduce Design Patterns（chapter 1）（一）"},{"content":"丢包可以由内部(企业LAN范围内)或外部(企业WAN或网络提供商的核心网)原因引起。丢包的主要原因包括：网络拥塞、高优先级流量阻塞低优先级流量、网络设备问题(交换机，路由器故障等)、设置/配置问题(10/1 00M不匹配，IP地址重复使用等)、视频设备问题、电缆问题(线路问题，连接问题)等等。 　　IP 视频通信丢包的影响 　　在IP视频通话中丢包造成的影响多种多样。其中： 　　对视频质量的影响主要有：马赛克现象、局部变形(图像的某些区域不清晰)、图像模糊、屏幕频繁刷新或闪烁、视音频不同步、帧率下降、图像静止等等。 　　对音频质量的影响包括：总体音频失真、间断或间歇性噪音、音频中断等。 　　对内容和演示数据质量的影响包括：幻灯片模糊变形、翻页速度减慢或屏幕频繁刷新和图像静止等等。 　　另外，丢包还会引起过度延迟，甚至是通话中断。 　　IP视频通话中丢包造成的影响程度主要由丢包率、丢包随时间变化情况和视频通话中各个终端和设备的能力所决定。正如我们通常认为的那样，丢包率越高，对视频通话的影响也更为明显。","title":"分组网络中视频丢包及其影响"},{"content":"装饰者模式 Decorator模式（别名Wrapper）：动态将职责附加到对象上，若要扩展功能，装饰者提供了比继承更具弹性的代替方案。   意图： 动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。   设计原则： 1. 多用组合，少用继承。 利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相同的行为。然而，如果能够利用组合的做法扩展对象的行为，就可以在运行时动态地进行扩展。 2. 类应设计的对扩展开放，对修改关闭。   要点： 1． 装饰者和被装饰对象有相同的超类型。 2． 可以用一个或多个装饰者包装一个对象。 3． 装饰者可以在所委托被装饰者的行为之前或之后，加上自己的行为，以达到特定的目的。 4． 对象可以在任何时候被装饰，所以可以在运行时动态的，不限量的用你喜欢的装饰者来装饰对象。 5． 装饰模式中使用继承的关键是想达到装饰者和被装饰对象的类型匹配，而不是获得其行为。 6． 装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型。在实际项目中可以根据需要为装饰者添加新的行为，做到“半透明”装饰者。 7． 适配器模式的用意是改变对象的接口而不一定改变对象的性能，而装饰模式的用意是保持接口并增加对象的职责。     类图：     Component： 定义一个对象接口，可以给这些对象动态地添加职责。 public interface Component {     void operation(); }   Concrete Component： 定义一个对象，可以给这个对象添加一些职责。 public class ConcreteComponent implements Component {     public void operation()     {         // Write your code here     } }   Decorator： 维持一个指向Component对象的引用，并定义一个与 Component接口一致的接口。 public class Decorator implements Component {     public Decorator(Component component)     {         this.component = component;     }          public void operation()     {         component.operation();     }          private Component component; }   Concrete Decorator： 在Concrete Component的行为之前或之后，加上自己的行为，以“贴上”附加的职责。 public class ConcreteDecorator extends Decorator {     public void operation()     {         //addBehavior也可以在前面                  super.operation();                  addBehavior();     }          private void addBehavior()     {         //your code     } }     模式的简化： 1. 如果只有一个Concrete Component类而没有抽象的Component接口时，可以让Decorator继承Concrete Component。       2. 如果只有一个Concrete Decorator类时，可以将Decorator和Concrete Decorator合并。   适用性： 以下情况使用Decorator模式 1. 需要扩展一个类的功能，或给一个类添加附加职责。 2. 需要动态的给一个对象添加功能，这些功能可以再动态的撤销。 3. 需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。 4. 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。   优点： 1. Decorator模式与继承关系的目的都是要扩展对象的功能，但是Decorator可以提供比继承更多的灵活性。 2. 通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。 缺点： 1. 这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。 2. 装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。 3. 装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可 以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择。          ","title":"装饰者模式"},{"content":"W5100是WIZnet研发的一款非常经典的TCP/IP芯片，它能将相关网络协议从主控芯片中卸载出来，释放更多内存资源，能明显提升整个系统的网络接入性能。它经历住了长期的市场考验，它的易用性和出色表现也得到了不少开发者的认可和亲睞。各位朋友们也可能注意到了W5100在使用过程中可能温度略高，朋友们也在网站、论坛等平台上针对这个问题展开了一些讨论，下面将这些整理出来供大家参考一下。 来自“极客工坊”：http://www.geek-workshop.com/forum.php?mod=viewthread&tid=1179 “电源插头”提问：“入手W5100，用的时候一上电就发热，烫手。刚开始还都能运行，后来就ping不通了，不知道什么情况。板子是带小SD的那种。” 网友回帖： —“囧。。。会不会是你的W5100板子有问题，我自己做的W5100，运行一晚上往外网发数据。。。第二天也没死机。。。温度嘛，不能算很烫。比较热那种感觉。。” —“烫确实有点烫，不过我的已经连续运行一个多星期了，一分钟发一次数据。。。” —“W5100的确发热有点高。据说这是很正常的。因为以太网的phy本身不是低功耗的，所以产热量有点高。” —“很热是正常的，能工作。不过这种模块有一个很有趣的问题，你只是接上USB上电，而没有点开arduino的串口监视窗口（打开时IDE会由串口发送复位信号），或者没有按复位。芯片里面的程序是正常运行，但网络不通的。” 来自“阿莫西电子论坛”：http://www.amobbs.com/thread-4702243-1-1.html “Andiwxz”的提问: “W5100很热，烫手怎么回事? 在测试的时候我的W5100很热，烫手。我还没找出问题。请大家帮忙看看有什么问题” 网友回帖： —“W5100发热是正常现象，因为它集成了PHY，工作电流在130mA左右。。。” 来自“百度知道”： “ W5100的温度有点高，这是不是说明芯片有问题？” 网友回帖： —“因为W5100中嵌入了PHY（模拟部分），会比其他WIZnet芯片产生的热量多些，但是这并不影响它的性能。W5100是通过了关于温度的可靠性测试的。“ ———————————————————————————————————————————————– 小结： 由于W5100是将以太网的PHY集成在芯片内，在加上W5100封装的体积小，因此在实际使用时发现W5100比较热。W5100的发热主要是由以太网的PHY引起的。一般的以太网PHY的电流都比较大，比如RTL8201CP，IP101A等，在3.3V工作电压、100BaseT时功耗都在120mA左右。W5100属于工业级器件，工作温度范围在-40度到85度。一般不需要散热处理，如果工作环境实在是极其恶劣，果然工作环境实在恶劣如周围有大发热设备，可以考虑加散热片或通风换热。 但面对绝大多数工业应用，W5100是没问题的，也不需要做散热处理。W5100也通过了相关测试，大家可以放心使用！ 相关文档：W5100温度认证报告（W5100 Temperature Qualification Report）(http://www.iwiznet.cn/sub_modules/product/product_detail.asp?Refid=80&page=1&cate1=5&cate2=7&cate3=26&pid=1011&cType=2)","title":"直面W5100发热问题"},{"content":"最近在做struts+ajax+json项目，项目中使用了struts2-json-plugin-2.2.3.jar（一款json转化插件），研究了一段时间，今天来总结一下具体的使用过程。 使用struts2-json-plugin-2.2.3.jar需要理解以下几点：1、struts2-json-plugin-2.2.3.jar就是一个将对象属性转化成json的东东，2、要转化的对象中必须要有get打头的函数才可以（所以，如果使用struts2-json-plugin-2.2.3.jar，尽量避免在要转化的对象中将不想转化json的的函数使用get*打头），不多说了，下面看配置： 1、我的程序目录结构，由于这是一个struts插件，所以必须要有struts才可以。 2、我的java文件： StudentEntity.java import java.io.Serializable;public class StudentEntity implements Serializable {\tprivate String stuName;\tprivate String stuAge;\tprivate String stuSex;\tpublic String getStuAge() {\t\treturn stuAge;\t}\tpublic void setStuAge(String stuAge) {\t\tthis.stuAge = stuAge;\t}\tpublic String getStuName() {\t\treturn stuName;\t}\tpublic void setStuName(String stuName) {\t\tthis.stuName = stuName;\t}\tpublic String getStuSex() {\t\treturn stuSex;\t}\tpublic void setStuSex(String stuSex) {\t\tthis.stuSex = stuSex;\t}\t} TeacherEntity.java import java.io.Serializable;public class TeacherEntity implements Serializable {\tprivate String teacName;\tprivate String teacAge;\tprivate String teacSex;\tpublic String getTeacAge() {\t\treturn teacAge;\t}\tpublic void setTeacAge(String teacAge) {\t\tthis.teacAge = teacAge;\t}\tpublic String getTeacName() {\t\treturn teacName;\t}\tpublic void setTeacName(String teacName) {\t\tthis.teacName = teacName;\t}\tpublic String getTeacSex() {\t\treturn teacSex;\t}\tpublic void setTeacSex(String teacSex) {\t\tthis.teacSex = teacSex;\t}}   StrIndex.java（这是一个action，命名不规范） import java.util.Date;import org.apache.struts2.json.annotations.JSON;import com.opensymphony.xwork2.ActionSupport;public class StrIndex extends ActionSupport {\t\tprivate TeacherEntity teacher=new TeacherEntity();\tprivate StudentEntity student=new StudentEntity();\tprivate Date nowd=new Date();\tpublic String toIndex(){\t\tteacher.setTeacName(\"张三\");\t\tteacher.setTeacAge(\"100\");\t\tteacher.setTeacSex(\"男男\");\t\t\t\tstudent.setStuName(\"李老师\");\t\t\t\treturn SUCCESS;\t}\t// 是否转换该对象//\t@JSON(serialize=true)//\t@JSON(name=\"newName\")\tpublic StudentEntity getStudent() {\t\treturn student;\t}\tpublic void setStudent(StudentEntity student) {\t\tthis.student = student;\t}\tpublic TeacherEntity getTeacher() {\t\treturn teacher;\t}\tpublic void setTeacher(TeacherEntity teacher) {\t\tthis.teacher = teacher;\t}\t@JSON(format=\"yyyy-MM-dd\")\tpublic Date getNowd() {\t\treturn nowd;\t}\tpublic void setNowd(Date nowd) {\t\tthis.nowd = nowd;\t}\t\t\t\t}   紧接着是我的struts配置文件： <?xml version=\"1.0\" encoding=\"UTF-8\" ?><!DOCTYPE struts PUBLIC        \"-//Apache Software Foundation//DTD Struts Configuration 2.0//EN\"        \"http://struts.apache.org/dtds/struts-2.0.dtd\"><struts>\t<package name=\"test-default\" extends=\"json-default\">\t\t<action name=\"ind\" class=\"StrIndex\" method=\"toIndex\">\t\t\t<result name=\"success\" type=\"json\">\t\t\t<\/result>\t\t<\/action>\t<\/package><\/struts> 3、简单配置说明 在struts中使用struts2-json-plugin-2.2.3.jar需要将要返回json的action配置在 <package name=\"test-default\" extends=\"json-default\">\t...\t...<\/package> 中，注意extends=\"json-default\"继承的是“json-default\" 我们正常配置struts是使用‘struts-default’，所以需要将返回json的action和普通action分开使用两个package进行配置 <package name=\"test-default\" extends=\"json-default\">\t...\t...<\/package><package name=\"struts-default\" extends=\"struts-default\">\t...\t...<\/package> 在json package中的acton配置 <result name=\"success\" type=\"json\"><\/result> 便可以成功的转化json，结果如   {\"nowd\":\"2012-12-27T22:23:13\",\"student\":{\"stuAge\":null,\"stuName\":\"李老师\",\"stuSex\":null},\"teacher\":{\"teacAge\":\"100\",\"teacName\":\"张三\",\"teacSex\":\"男男\"}} 4、拦截器配置 因为json插件的原理是将action中所有以get打头的函数全部转化，包括bena中的bean（如本案例所示，会将action中student中的name以及age等全部转化），如果bean太多这会造成巨大浪费，使用拦截器可以根据需要将bean转化成json。 4.1、配置什么属性转化什么属性，如下配置 <result name=\"success\" type=\"json\">\t<param name=\"includeProperties\">               \t\tteacher\\.teacName,teacher\\.teacAge\t<\/param><\/result> 在result中配置param标签，同时为param标签指定includeProperties属性，通过以上配置可以让json插件只转化param配置的属性。结果如   {\"teacher\":{\"teacAge\":\"100\",\"teacName\":\"张三\"}} 4.2、只返回指定属性的值，如下配置 <result name=\"success\" type=\"json\">\t<param name=\"root\">               \t\tteacher.teacName       \t<\/param><\/result> 在result中配置param标签，同时为param标签指定root属性，通过以上配置可以让json插件只转化param配置的属性，如 \"张三\" 4.3、不想转化某些对象、属性 <result name=\"success\" type=\"json\">\t<param name=\"excludeProperties\">               \t\tteacher\\.teacName\t<\/param><\/result> 在result中配置param标签，同时为param标签指定excludeProperties属性，通过以上配置可以让json插件不转化param配置的属性，如 {\"nowd\":\"2012-12-27T22:34:00\",\"student\":{\"stuAge\":null,\"stuName\":\"李老师\",\"stuSex\":null},\"teacher\":{\"teacAge\":\"100\",\"teacSex\":\"男男\"}} 5、json注解使用 我目前所知道的json插件提供四种注解 serialize：设置是否序列化该属性 @JSON(serialize=true)public StudentEntity getStudent() {\treturn student;} deserialize：设置是否反序列化该属性。 @JSON(deserialize=true)public StudentEntity getStudent() {\treturn student;} format：设置用于格式化输出、解析日期表单域的格式。例如\"yyyy-MM-dd'T'HH:mm:ss\"。 @JSON(format=\"yyyy-MM-dd\")public Date getNowd() {\treturn nowd;}   name：可改变序列后的属性明 @JSON(name=\"newName\")public StudentEntity getStudent() {\treturn student;}   [声明]：以上内容纯属个人工作之余学习总结，如有不正确的地方欢迎指出，共同学习、交流。","title":"struts2-json-plugin-2.2.3 使用"},{"content":"最近由于工作原因研究了jrouter，简单的记录和分享下。 一，项目介绍 jrouter是一套基于配置和annotation拦截方法的框架，专注方法的映射、调用、拦截和结果处理，比较强大。项目地址http://code.google.com/p/jrouter/ 二，实现思路 首先说标签，jrouter提供了Action，Interceptor，result，namespace等标签，通过spring文件将自定义的\"标签实现类\"加载到内存中。标签是一种对真正执行代理的映射，在感兴趣的method上定义想要的标签和name。两层代理，一层是对标签的代理(ActionProxy或InterceptorProxy)，action和interceptor的代理，由ActionFactory产生；往下一层是具体的proxy（使用javassitproxy产生的代理对象），由ProxyFactory产生。总体来看，jrouter是标签和代理的结合运用。 三，关键路径分析 入口类DefaultActionFactoryBean（又是FactoryBean）会在属性初始化后将“代理环境”搭建起来，其中有个属性classScannerProperties定义了扫描类的规则，在buildActionFactory过程中将所有符合规则的类加载，jrouter就是给这些类加上一层代理，所以同时一起初始化的还有Action，interceptor等自定义实现。整个初始化过程就是对jrouter-spring的解析+设置代理的过程。 测试执行过程： factory = new DefaultActionFactory();        //interceptor        factory.addInterceptors(SampleInterceptor.class);        //interceptor stack        factory.addInterceptorStacks(DefaultInterceptorStack.class);        //result        factory.addResultTypes(DefaultResult.class);        //aciotn        //class        factory.addActions(jrouter.URLTestAction.class);        //object        factory.addActions(new jrouter.URLTestAction2());factory.invokeAction(\"\"); invokeAction过程中根据参数创建调用上下文，ActionInvocation invocation = createActionInvocation(path, params); 那么后面自然是对action和interceptor的调用了，这里用到了recursive invoke。直接上代码： //recursive invoke        if (interceptors != null && _index < interceptors.size()) {            final InterceptorProxy interceptor = interceptors.get(_index++);            LOG.debug(\"Invoke Interceptor [{}] at : {}\", interceptor.getName(), interceptor.getMethod());            invokeResult = interceptor.isRequireAction() ? interceptor.invoke(this) : interceptor.invoke();        } else {            //action invoke            if (!executed) {                invokeActionOnly(params);            }        }        return invokeResult; 再往后使用Java反射或代理对象调用底层方法： 使用Java反射或代理对象调用底层方法： return proxy == null ? method.invoke(obj, params) : proxy.invoke(method, obj, params); **************分割线************* 看下创建Action代理类（ActiionProxy）时取得这个Action的拦截代理的实现： Action action = method.getAnnotation(Action.class); //action中申明的interceptors            for (String name : action.interceptors()) {                InterceptorProxy ip = interceptors.get(name);                if (ip == null) {                    LOG.warn(\"No such Interceptor [{}] at : {}\", name, ap.getMethod());                } else {                    inters.add(ip);                }            } 可以是根据标签配置的拦截器的name从内存的拦截器集合中取到的。真正执行invoke时只要像上述遍历所有拦截器即可。 四，总结 这种基于标签和配置的方式扩展性很强，适合于短小精干的批量的拦截场景，同时学习成本也比较大，跟我想要的拦截模型还不太一样，但也是有参考价值的。javaassist和reflectasm同样操作字节码但使用上方式有很大差别，后面有时间写篇两者对比的文章。","title":"jrouter源码分析"},{"content":"XPages自带的控件集最缺乏的恐怕就是类似于经典Notes开发的大纲了。虽然一个大纲/导航是一个Web应用几乎不可缺少的部分，但是截至8.5.3，IBM仍然没有为开发人员提供这个方便。接着，提供了一堆控件的UpgradePack 1来了，继承了大量在OpenNTF网站上已经发布的XPagesExtension Library的内容。其中，就有一个outline和一个navigator。但是这些控件的质量参差不齐，与设计器的结合和文档更是初级。往页面上放outline和navigator各一个，添加必要的属性和treeNodes。显示页面，结果相当令人失望。Outline控件被转换成一个单纯的HTML的UL，没有任何修饰，也就是左边带有黑色圆点的列表，甚至添加了list-style-type:none的style属性之后，转换成HTML时也丢失了。Navigator控件则消失在一个空白的DIV中。另外，即使显示效果能调节成IBM附带的XPages版本的Teamroom应用中的那样美观，这两个控件的功能也不完备，比如不能指定链接的target属性，treeNodes支持的事件也只有onItemClick。 幸好，我们可以像在《14. 如何在XPages中插入HTML》里说的，在XPage中添加HTML，再利用CSS和Javascript，做出想要的大纲效果： <?xml version=\"1.0\" encoding=\"UTF-8\"?><xp:view xmlns:xp=\"http://www.ibm.com/xsp/core\" xmlns:xc=\"http://www.ibm.com/xsp/custom\"\tstyle=\"background-color: #F4F5F6;\">\t<xp:this.resources>\t\t<xp:styleSheet href=\"/ui.css\"><\/xp:styleSheet>\t<\/xp:this.resources><script language=\"Javascript\">\t\tXSP.addOnLoad(function () {\t\tdojo.query(\".menu li a\").onclick(function (e){\t\tdojo.query(\".menu li a\").removeClass(\"selected\");\t\tdojo.query(e.target).addClass(\"selected\");\t\t});\t\t}\t\t);<\/script>\t<xp:br><\/xp:br>\t<xp:panel style=\"width:100%\">\t\t<ul class=\"menu\">\t\t\t<li>\t\t\t\t<xp:link escape=\"true\" text=\"Access Record\" id=\"link1\"\t\t\t\t\ttarget=\"right\" value=\"/viewRecord.xsp\" styleClass=\"selected\">\t\t\t\t<\/xp:link>\t\t\t<\/li>\t\t\t<li>\t\t\t\t<xp:link escape=\"true\" text=\"Exception\" id=\"link2\"\t\t\t\t\ttarget=\"right\" value=\"/viewException.xsp\">\t\t\t\t<\/xp:link>\t\t\t<\/li>\t\t\t<li>\t\t\t\t<xp:link escape=\"true\" text=\"Settings\" id=\"link3\" value=\"viewsettings.xsp\"\t\t\t\t\ttarget=\"right\" rendered=\"#{javascript: //control the visibility}\">\t\t\t\t<\/xp:link>\t\t\t<\/li>\t\t\t<li>\t\t\t\t<xp:link escape=\"true\" text=\"Log\" id=\"link6\" value=\"/viewLogs.xsp\"\t\t\t\t\ttarget=\"right\">\t\t\t\t\t<xp:this.rendered><![CDATA[${javascript: //control the visibility}]]><\/xp:this.rendered>\t\t\t\t<\/xp:link>\t\t\t<\/li>\t\t<\/ul>\t<\/xp:panel><\/xp:view> 整个页面放置在一个frames中作为导航之用。大纲由一个UL包含xp:link组成。显示效果由CSS和通过XSP.addOnLoad()执行的函数完成，控制大纲项目在默认、鼠标悬浮和选定状态下的属性。ui.css相关部分的内容如下： ul.menu{\tlist-style-type: none;\tmargin: 0;\tpadding: 5px 0;\tfont-weight:bold;}.menu li a{\ttext-decoration: none;\tdisplay: block;\tpadding: 5px 0 5px 10px;}.menu li a.selected{\tcolor:white;\tbackground-color: #1384B8;}.menu li a:hover{\tcolor:white;\tbackground-color: #1384B8;}","title":"17. 如何在XPages里创建大纲/导航？"},{"content":"    编写一个装饰者把所有的输入流内的大写字符转化成小写字符：   import java.io.FilterInputStream; import java.io.IOException; import java.io.InputStream; public class LowerCaseInputStream extends FilterInputStream {     protected LowerCaseInputStream(InputStream in)     {         super(in);     }          @Override     public int read() throws IOException     {         int c = super.read();         return (c == -1 ? c : Character.toLowerCase((char) c));     }          @Override     public int read(byte[] b, int offset, int len) throws IOException     {         int result = super.read(b, offset, len);                  for (int i = offset; i < offset + result; i++)         {             b[i] = (byte) Character.toLowerCase((char) b[i]);         }                  return result;              } }   测试我们的装饰者类： import java.io.*; public class InputTest {     public static void main(String[] args) throws IOException     {         int c;                  try         {             InputStream in = new LowerCaseInputStream(new BufferedInputStream(                     new FileInputStream(\"D:\\\\test.txt\")));                          while ((c = in.read()) >= 0)             {                 System.out.print((char) c);             }                          in.close();         }         catch (IOException e)         {             e.printStackTrace();         }     } }  ","title":"装饰模式在Java I/O库中的应用"},{"content":"1 Ant是什么？  Apache Ant 是一个基于 Java的生成工具。 生成工具在软件开发中用来将源代码和其他输入文件转换为可执行文件的形式（也有可能转换为可安装的产品映像形式）。随着应用程序的生成过程变得更加复杂，确保在每次生成期间都使用精确相同的生成步骤，同时实现尽可能多的自动化，以便及时产生一致的生成版本 2 下载、安装Ant  安装Ant 下载.zip文件，解压缩到c:\\ant1.3(后面引用为%ANT_HOME%) 2.1 在你运行Ant之前需要做一些配置工作。 ? 将bin目录加入PATH环境变量。  ? 设定ANT_HOME环境变量，指向你安装Ant的目录。在一些OS上，Ant的脚本可以猜测ANT_HOME（Unix和Windos NT/2000）－但最好不要依赖这一特性。  ? 可选地，设定JAVA_HOME环境变量（参考下面的高级小节），该变量应该指向你安装JDK的目录。 注意：不要将Ant的ant.jar文件放到JDK/JRE的lib/ext目录下。Ant是个应用程序，而lib/ext目录是为JDK扩展使用的（如JCE，JSSE扩展）。而且通过扩展装入的类会有安全方面的限制。 2.2 运行Ant  运行Ant非常简单，当你正确地安装Ant后，只要输入ant就可以了。 ?  没有指定任何参数时，Ant会在当前目录下查询build.xml文件。如果找到了就用该文件作为buildfile。如果你用 -find 选项。 Ant就会在上级目录中寻找buildfile，直至到达文件系统的根。要想让Ant使用其他的buildfile，可以用参数 - buildfile file，这里file指定了你想使用的buildfile。 ? 可以指定执行一个或多个target。当省略target时，Ant使用标签<project>的default属性所指定的target。 命令行选项总结： ant [options] [target [target2 [target3] ...]] Options: -help print this message -projecthelp print project help information -version print the version information and exit -quiet be extra quiet -verbose be extra verbose -debug print debugging information -emacs produce logging information without adornments -logfile file use given file for log output -logger classname the class that is to perform logging -listener classname add an instance of class as a project listener -buildfile file use specified buildfile -find file search for buildfile towards the root of the filesystem and use the first one found -Dproperty=value set property to value  例子 ant 使用当前目录下的build.xml运行Ant，执行缺省的target。 ant -buildfile test.xml 使用当前目录下的test.xml运行Ant，执行缺省的target。 ant -buildfile test.xml dist 使用当前目录下的test.xml运行Ant，执行一个叫做dist的target。 ant -buildfile test.xml -Dbuild=build/classes dist 使用当前目录下的test.xml运行Ant，执行一个叫做dist的target，并设定build属性的值为build/classes。 3 编写build.xml  Ant的buildfile是用XML写的。每个buildfile含有一个project。 buildfile中每个task元素可以有一个id属性，可以用这个id值引用指定的任务。这个值必须是唯一的。（详情请参考下面的Task小节） 3.1 Projects project有下面的属性： Attribute Description Required name 项目名称. No default 当没有指定target时使用的缺省target Yes basedir 用于计算所有其他路径的基路径。该属性可以被basedir property覆盖。当覆盖时，该属性被忽略。如果属性和basedir property都没有设定，就使用buildfile文件的父目录。 No 项目的描述以一个顶级的<description>元素的形式出现（参看description小节）。 一个项目可以定义一个或多个target。一个target是一系列你想要执行的。执行Ant时，你可以选择执行那个target。当没有给定target时，使用project的default属性所确定的target。 3.2 Targets 一个target可以依赖于其他的target。例如，你可能会有一个target用于编译程序，一个target用于生成可执行文件。你在生成可执行文件之前必须先编译通过，所以生成可执行文件的target依赖于编译target。Ant会处理这种依赖关系。 然而，应当注意到，Ant的depends属性只指定了target应该被执行的顺序－如果被依赖的target无法运行，这种depends对于指定了依赖关系的target就没有影响。 Ant会依照depends属性中target出现的顺序（从左到右）依次执行每个target。然而，要记住的是只要某个target依赖于一个target，后者就会被先执行。 <target name=\"A\"/> <target name=\"B\" depends=\"A\"/> <target name=\"C\" depends=\"B\"/> <target name=\"D\" depends=\"C,B,A\"/> 假定我们要执行target D。从它的依赖属性来看，你可能认为先执行C，然后B，最后A被执行。错了，C依赖于B，B依赖于A，所以先执行A，然后B，然后C，最后D被执行。 一个target只能被执行一次，即时有多个target依赖于它（看上面的例子）。 如 果（或如果不）某些属性被设定，才执行某个target。这样，允许根据系统的状态（java version, OS, 命令行属性定义等等）来更好地 控制build的过程。要想让一个target这样做，你就应该在target元素中，加入if（或unless）属性，带上target因该有所判断的 属性。例如： <target name=\"build-module-A\" if=\"module-A-present\"/> <target name=\"build-own-fake-module-A\" unless=\"module-A-present\"/> 如果没有if或unless属性，target总会被执行。 可选的description属性可用来提供关于target的一行描述，这些描述可由-projecthelp命令行选项输出。 将你的tstamp task在一个所谓的初始化target是很好的做法，其他的target依赖这个初始化target。要确保初始化target是出现在其他target依赖表中的第一个target。在本手册中大多数的初始化target的名字是\"init\"。 target有下面的属性： Attribute Description Required name target的名字 Yes depends 用逗号分隔的target的名字列表，也就是依赖表。 No if 执行target所需要设定的属性名。 No unless 执行target需要清除设定的属性名。 No description 关于target功能的简短描述。 No 3.3 Tasks 一个task是一段可执行的代码。 一个task可以有多个属性（如果你愿意的话，可以将其称之为变量）。属性只可能包含对property的引用。这些引用会在task执行前被解析。 下面是Task的一般构造形式： <name attribute1=\"value1\" attribute2=\"value2\" ... /> 这里name是task的名字，attributeN是属性名，valueN是属性值。 有一套内置的（built-in）task，以及一些可选task，但你也可以编写自己的task。 所有的task都有一个task名字属性。Ant用属性值来产生日志信息。 可以给task赋一个id属性： <taskname id=\"taskID\" ... /> 这里taskname是task的名字，而taskID是这个task的唯一标识符。通过这个标识符，你可以在脚本中引用相应的task。例如，在脚本中你可以这样： <script ... > task1.setFoo(\"bar\"); <\/script> 设定某个task实例的foo属性。在另一个task中（用java编写），你可以利用下面的语句存取相应的实例。 project.getReference(\"task1\"). 注意1：如果task1还没有运行，就不会被生效（例如：不设定属性），如果你在随后配置它，你所作的一切都会被覆盖。 注意2：未来的Ant版本可能不会兼容这里所提的属性，因为很有可能根本没有task实例，只有proxies。 3.4 Properties 一 个project可以有很多的properties。可以在buildfile中用property task来设定，或在Ant之外设定。一个 property有一个名字和一个值。property可用于task的属性值。这是通过将属性名放在\"${\"和\"}\"之间并放在属性值的位置来实现的。 例如如果有一个property builddir的值是\"build\"，这个property就可用于属性值：${builddir} /classes。这个值就可被解析为build/classes。 内置属性 如果你使用了<property> task 定义了所有的系统属性，Ant允许你使用这些属性。例如，${os.name}对应操作系统的名字。 要想得到系统属性的列表可参考the Javadoc of System.getProperties。 除了Java的系统属性，Ant还定义了一些自己的内置属性：  basedir project基目录的绝对路径 (与<project>的basedir属性一样)。 ant.file buildfile的绝对路径。 ant.version Ant的版本。 ant.project.name 当前执行的project的名字；由<project>的name属性设定. ant.java.version Ant检测到的JVM的版本； 目前的值有\"1.1\", \"1.2\", \"1.3\" and \"1.4\". 例子 <project name=\"MyProject\" default=\"dist\" basedir=\".\">  <!-- set global properties for this build --> <property name=\"src\" value=\".\"/> <property name=\"build\" value=\"build\"/> <property name=\"dist\" value=\"dist\"/>  <target name=\"init\"> <!-- Create the time stamp --> <tstamp/> <!-- Create the build directory structure used by compile --> <mkdir dir=\"${build}\"/> <\/target> <target name=\"compile\" depends=\"init\"> <!-- Compile the java code from ${src} into ${build} --> <javac srcdir=\"${src}\" destdir=\"${build}\"/> <\/target> <target name=\"dist\" depends=\"compile\"> <!-- Create the distribution directory --> <mkdir dir=\"${dist}/lib\"/> <!-- Put everything in ${build} into the MyProject-${DSTAMP}.jar file --> <jar jarfile=\"${dist}/lib/MyProject-${DSTAMP}.jar\" basedir=\"${build}\"/> <\/target> <target name=\"clean\"> <!-- Delete the ${build} and ${dist} directory trees --> <delete dir=\"${build}\"/> <delete dir=\"${dist}\"/> <\/target> <\/project> 3.5 Path-like Structures 你可以用\":\"和\";\"作为分隔符，指定类似PATH和CLASSPATH的引用。Ant会把分隔符转换为当前系统所用的分隔符。 当需要指定类似路径的值时，可以使用嵌套元素。一般的形式是 <classpath> <pathelement path=\"${classpath}\"/> <pathelement location=\"lib/helper.jar\"/> <\/classpath> location属性指定了相对于project基目录的一个文件和目录，而path属性接受逗号或分号分隔的一个位置列表。path属性一般用作预定义的路径－－其他情况下，应该用多个location属性。 为简洁起见，classpath标签支持自己的path和location属性。所以： <classpath> <pathelement path=\"${classpath}\"/> <\/classpath> 可以被简写作： <classpath path=\"${classpath}\"/> 也可通过<fileset>元素指定路径。构成一个fileset的多个文件加入path-like structure的顺序是未定的。 <classpath> <pathelement path=\"${classpath}\"/> <fileset dir=\"lib\"> <include name=\"**/*.jar\"/> <\/fileset> <pathelement location=\"classes\"/> <\/classpath> 上面的例子构造了一个路径值包括：${classpath}的路径，跟着lib目录下的所有jar文件，接着是classes目录。 如果你想在多个task中使用相同的path-like structure，你可以用<path>元素定义他们（与target同级），然后通过id属性引用－－参考Referencs例子。 path-like structure可能包括对另一个path-like structurede的引用（通过嵌套<path>元素）： <path id=\"base.path\"> <pathelement path=\"${classpath}\"/> <fileset dir=\"lib\"> <include name=\"**/*.jar\"/> <\/fileset> <pathelement location=\"classes\"/> <\/path> <path id=\"tests.path\"> <path refid=\"base.path\"/> <pathelement location=\"testclasses\"/> <\/path> 前面所提的关于<classpath>的简洁写法对于<path>也是有效的，如： <path id=\"tests.path\"> <path refid=\"base.path\"/> <pathelement location=\"testclasses\"/> <\/path> 可写成： <path id=\"base.path\" path=\"${classpath}\"/> 命令行变量 有些task可接受参数，并将其传递给另一个进程。为了能在变量中包含空格字符，可使用嵌套的arg元素。 Attribute Description Required value 一个命令行变量；可包含空格字符。 只能用一个 line 空格分隔的命令行变量列表。  file 作为命令行变量的文件名；会被文件的绝对名替代。  path 一个作为单个命令行变量的path-like的字符串；或作为分隔符，Ant会将其转变为特定平台的分隔符。  例子 <arg value=\"-l -a\"/> 是一个含有空格的单个的命令行变量。 <arg line=\"-l -a\"/> 是两个空格分隔的命令行变量。 <arg path=\"/dir;/dir2:\\dir3\"/> 是一个命令行变量，其值在DOS系统上为\\dir;\\dir2;\\dir3；在Unix系统上为/dir:/dir2:/dir3 。 References buildfile元素的id属性可用来引用这些元素。如果你需要一遍遍的复制相同的XML代码块，这一属性就很有用－－如多次使用<classpath>结构。 下面的例子： <project ... > <target ... >  <rmic ...>  <classpath>  <pathelement location=\"lib/\"/>  <pathelement path=\"${java.class.path}/\"/>  <pathelement path=\"${additional.path}\"/>  <\/classpath>  <\/rmic>  <\/target> <target ... > <javac ...> <classpath> <pathelement location=\"lib/\"/> <pathelement path=\"${java.class.path}/\"/> <pathelement path=\"${additional.path}\"/> <\/classpath> <\/javac> <\/target> <\/project> 可以写成如下形式： <project ... >  <path id=\"project.class.path\">  <pathelement location=\"lib/\"/> <pathelement path=\"${java.class.path}/\"/>  <pathelement path=\"${additional.path}\"/>  <\/path> <target ... > <rmic ...> <classpath refid=\"project.class.path\"/> <\/rmic> <\/target> <target ... >  <javac ...> <classpath refid=\"project.class.path\"/> <\/javac> <\/target> <\/project> 所有使用PatternSets, FileSets 或 path-like structures嵌套元素的task也接受这种类型的引用。       4.1 File（Directory）类 4.1.1 Mkdir ? 创建一个目录，如果他的父目录不存在，也会被同时创建。 ? 例子： <mkdir dir=\"build/classes\"/> ? 说明： 如果build不存在，也会被同时创建 4.1.2 Copy ? 拷贝一个（组）文件、目录 ? 例子： 1. 拷贝单个的文件：  <copy file=\"myfile.txt\" tofile=\"mycopy.txt\"/> 2. 拷贝单个的文件到指定目录下 <copy file=\"myfile.txt\" todir=\"../some/other/dir\"/> 3. 拷贝一个目录到另外一个目录下 <copy todir=\"../new/dir\"> <fileset dir=\"src_dir\"/> <\/copy> 4. 拷贝一批文件到指定目录下 <copy todir=\"../dest/dir\"> <fileset dir=\"src_dir\"> <exclude name=\"**/*.java\"/> <\/fileset> <\/copy> <copy todir=\"../dest/dir\"> <fileset dir=\"src_dir\" excludes=\"**/*.java\"/> <\/copy> 5. 拷贝一批文件到指定目录下，将文件名后增加。Bak后缀 <copy todir=\"../backup/dir\"> <fileset dir=\"src_dir\"/> <mapper type=\"glob\" from=\"*\" to=\"*.bak\"/> <\/copy> 6. 拷贝一组文件到指定目录下，替换其中的@标签@内容 <copy todir=\"../backup/dir\"> <fileset dir=\"src_dir\"/> <filterset> <filter token=\"TITLE\" value=\"Foo Bar\"/> <\/filterset> <\/copy> 4.1.3 Delete ? 删除一个（组）文件或者目录 ? 例子 1. 删除一个文件 <delete file=\"/lib/ant.jar\"/> 2. 删除指定目录及其子目录 <delete dir=\"lib\"/> 3. 删除指定的一组文件 <delete> <fileset dir=\".\" includes=\"**/*.bak\"/> <\/delete> 4. 删除指定目录及其子目录，包括他自己 <delete includeEmptyDirs=\"true\"> <fileset dir=\"build\"/> <\/delete> 4.1.4 Move ? 移动或重命名一个（组）文件、目录 ? 例子： 1. 移动或重命名一个文件 <move file=\"file.orig\" tofile=\"file.moved\"/> 2. 移动或重命名一个文件到另一个文件夹下面 <move file=\"file.orig\" todir=\"dir/to/move/to\"/> 3. 将一个目录移到另外一个目录下 <move todir=\"new/dir/to/move/to\"> <fileset dir=\"src/dir\"/> <\/move> 4. 将一组文件移动到另外的目录下 <move todir=\"some/new/dir\"> <fileset dir=\"my/src/dir\"> <include name=\"**/*.jar\"/> <exclude name=\"**/ant.jar\"/> <\/fileset> <\/move> 5. 移动文件过程中增加。Bak后缀 <move todir=\"my/src/dir\"> <fileset dir=\"my/src/dir\"> <exclude name=\"**/*.bak\"/> <\/fileset> <mapper type=\"glob\" from=\"*\" to=\"*.bak\"/> <\/move>   4.2 Java相关 4.2.1 Javac ? 编译java原代码 ? 例子 1. <javac srcdir=\"${src}\" destdir=\"${build}\" classpath=\"xyz.jar\" debug=\"on\" /> 编译${src}目录及其子目录下的所有。Java文件，。Class文件将放在$｛build｝指定的目录下，classpath表示需要用到的类文件或者目录，debug设置为on表示输出debug信息 2. <javac srcdir=\"${src}:${src2}\" destdir=\"${build}\" includes=\"mypackage/p1/**,mypackage/p2/**\" excludes=\"mypackage/p1/testpackage/**\" classpath=\"xyz.jar\" debug=\"on\" /> 编 译${src}和${src2}目录及其子目录下的所有。Java文件，但是package/p1/**,mypackage/p2/**将被编译，而 mypackage/p1/testpackage/**将不会被编译。Class文件将放在$｛build｝指定的目录下，classpath表示需要 用到的类文件或者目录，debug设置为on表示输出debug信息 3. <property name=\"classpath\" value=\".;./xml-apis.jar;../lib/xbean.jar;./easypo.jar\"/> <javac srcdir=\"${src}\" destdir=\"${src}\" classpath=\"${classpath}\" debug=\"on\" /> 路径是在property中定义的 4.2.2 java ? 执行指定的java类 ? 例子： 1. <java classname=\"test.Main\"> <classpath> <pathelement location=\"dist/test.jar\"/> <pathelement path=\"${java.class.path}\"/> <\/classpath> <\/java> classname中指定要执行的类，classpath设定要使用的环境变量 2. <path id=\"project.class.path\"> <pathelement location=\"lib/\"/> <pathelement path=\"${java.class.path}/\"/> <pathelement path=\"${additional.path}\"/> <\/path> <target ... > <rmic ...> <classpath refid=\"project.class.path\"/> <\/rmic> <\/target>   4.3 打包相关 4.3.1 jar ? 将一组文件打包 ? 例子： 1. <jar destfile=\"${dist}/lib/app.jar\" basedir=\"${build}/classes\"/> 将${build}/classes下面的所有文件打包到${dist}/lib/app.jar中 2. <jar destfile=\"${dist}/lib/app.jar\" basedir=\"${build}/classes\" includes=\"mypackage/test/**\" excludes=\"**/Test.class\" /> 将${build}/classes下面的所有文件打包到${dist}/lib/app.jar中，但是包括mypackage/test／所有文件不包括所有的Test.class 3. <jar destfile=\"${dist}/lib/app.jar\" basedir=\"${build}/classes\" includes=\"mypackage/test/**\" excludes=\"**/Test.class\" manifest=”my.mf” /> manifest属性指定自己的META-INF/MANIFEST.MF文件，而不是由系统生成 4.3.2 war ? 对Jar的扩展，用于打包Web应用 ? 例子： ? 假设我们的文件目录如下： thirdparty/libs/jdbc1.jar thirdparty/libs/jdbc2.jar build/main/com/myco/myapp/Servlet.class src/metadata/myapp.xml src/html/myapp/index.html src/jsp/myapp/front.jsp src/graphics/images/gifs/small/logo.gif src/graphics/images/gifs/large/logo.gif ? 下面是我们的任务的内容：  <war destfile=\"myapp.war\" webxml=\"src/metadata/myapp.xml\"> <fileset dir=\"src/html/myapp\"/> <fileset dir=\"src/jsp/myapp\"/> <lib dir=\"thirdparty/libs\"> <exclude name=\"jdbc1.jar\"/> <\/lib> <classes dir=\"build/main\"/> <zipfileset dir=\"src/graphics/images/gifs\"  prefix=\"images\"/> <\/war> ? 完成后的结果： WEB-INF/web.xml WEB-INF/lib/jdbc2.jar WEB-INF/classes/com/myco/myapp/Servlet.class META-INF/MANIFEST.MF index.html front.jsp images/small/logo.gif images/large/logo.gif 4.3.3 ear ? 用于打包企业应用 ? 例子 <ear destfile=\"${build.dir}/myapp.ear\" appxml=\"${src.dir}/metadata/application.xml\"> <fileset dir=\"${build.dir}\" includes=\"*.jar,*.war\"/> <\/ear>     4.4 时间戳 在生成环境中使用当前时间和日期，以某种方式标记某个生成任务的输出，以便记录它是何时生成的，这经常是可取的。这可能涉及编辑一个文件，以便插入一个字符串来指定日期和时间，或将这个信息合并到 JAR 或 zip 文件的文件名中。 这种需要是通过简单但是非常有用的 tstamp 任务来解决的。这个任务通常在某次生成过程开始时调用，比如在一个 init 目标中。这个任务不需要属性，许多情况下只需 <tstamp/> 就足够了。 tstamp 不产生任何输出；相反，它根据当前系统时间和日期设置 Ant 属性。下面是 tstamp 设置的一些属性、对每个属性的说明，以及这些属性可被设置到的值的例子： 属性 说明 例子  DSTAMP 设置为当前日期，默认格式为yyyymmdd 20031217 TSTAMP 设置为当前时间，默认格式为 hhmm 1603 TODAY 设置为当前日期，带完整的月份 2003 年 12 月 17 日 例如，在前一小节中，我们按如下方式创建了一个 JAR 文件： <jar destfile=\"package.jar\" basedir=\"classes\"/> 在调用 tstamp 任务之后，我们能够根据日期命名该 JAR 文件，如下所示： <jar destfile=\"package-${DSTAMP}.jar\" basedir=\"classes\"/> 因此，如果这个任务在 2003 年 12 月 17 日调用，该 JAR 文件将被命名为 package-20031217.jar。 还可以配置 tstamp 任务来设置不同的属性，应用一个当前时间之前或之后的时间偏移，或以不同的方式格式化该字符串。所有这些都是使用一个嵌套的 format 元素来完成的，如下所示： <tstamp> <format property=\"OFFSET_TIME\" pattern=\"HH:mm:ss\" offset=\"10\" unit=\"minute\"/> <\/tstamp> 上面的清单将 OFFSET_TIME 属性设置为距离当前时间 10 分钟之后的小时数、分钟数和秒数。 用于定义格式字符串的字符与 java.text.SimpleDateFormat 类所定义的那些格式字符相同     4.5 执行SQL语句 ? 通过jdbc执行SQL语句 ? 例子： 1. <sql driver=\"org.gjt.mm.mysql.Driver\" url=\"jdbc:mysql://localhost:3306/mydb\" userid=\"root\" password=\"root\" src=\"data.sql\" /> 2. <sql driver=\"org.database.jdbcDriver\" url=\"jdbc:database-url\" userid=\"sa\" password=\"pass\" src=\"data.sql\" rdbms=\"oracle\" version=\"8.1.\" > <\/sql> 只有在oracle、版本是8.1的时候才执行       4.6 发送邮件 ? 使用SMTP服务器发送邮件 ? 例子： <mail mailhost=\"smtp.myisp.com\" mailport=\"1025\" subject=\"Test build\"> <from address=\"me@myisp.com\"/> <to address=\"all@xyz.com\"/> <message>The ${buildname} nightly build has completed<\/message> <fileset dir=\"dist\"> <includes name=\"**/*.zip\"/> <\/fileset> <\/mail> ? mailhost： SMTP服务器地址 ? mailport： 服务器端口 ? subject： 主题 ? from： 发送人地址 ? to： 接受人地址 ? message： 发送的消息 ? fileset： 设置附件 ====================================================================   在ANT 出现之前，编译和部署Java应用需要使用包括特定平台的脚本、Make文件、不同的IDE以及手工操作等组成的大杂烩。现在，几乎所有的开源Java项 目都在使用Ant，许多公司的开发项目也在使用Ant。Ant的大量使用，也自然带来了对总结Ant最佳实践的迫切需求。  本文总结了我 喜好的Ant最佳实践，很多是从亲身经历的项目错误，或从其他开发者的“恐怖”故事中得到的灵感的。比如，有人告诉我有个项目将 XDoclet 生成的 代码放入锁定文件的版本控制工具中。单开发者修改源代码时，他必须记住手工检出（Check out）并锁定所有将要重生成的文件。然后，手工运行代码生 成器，当他能够让Ant编译代码时，这一方法还存在一些问题：  生成的代码无法存储在版本控制系统中  Ant（本案例中是Xdoclet）应该自动确定下一次构建涉及的源文件，而不应由程序员人工确定。  Ant的构建文件应该定义好正确的任务依赖关系，这样程序员不必按照特定顺序调用任务。  当我开始一个新项目时，我首先编写Ant构建文件。文件定义构建的过程，并为团队中的每个程序员都使用。本文所有的最佳实践假设Ant构建文件是一个必须精心编写的重要文件，它应在版本控制系统中得到维护，并定期进行重构。下面是我的十五大Ant最佳实践。  1. 采用一致的编码规范  Ant用户不管是喜欢还是痛恨XML构建文件的语法，都愿意跳进这一迷人的争论中。让我们先看一些保持XML构建文件简洁的方法。  首 先，也是最重要的，化费时间格式化你的XML让它看上去很清晰。不过XML是否美观，Ant都可以工作。但是丑陋的XML很难读懂。倘若你在任务之间留出 空行，有规则的缩进，每行文字不超过90列，那么XML令人惊讶的易读。再加上好的编辑器或IDE高亮相应的语句，你就不会有如何阅读的麻烦。同样，精选 有意义明确、容易读懂的词汇来命名任务和属性。比如，dir.reports就比rpts好。并不需要特定的编码规范，只要有一种规范并坚持使用就好。  2. 将build.xml 放在项目根目录中  Ant构建文件build.xml可以放在如何位置，但是放在项目顶层目录中可以保持项目简洁。这是最普遍的规范，使开发者能够在根目录找到它。同时，也能够容易了解项目中不同目录之间的逻辑关系。以下是一个典型的项目层次：  [root dir]  | build.xml  +--src  +--lib (包含第三方 JAR包)  +--build (由 build任务生成)  +--dist (由 build任务生成) 当build.xml在顶级目录时，倘若你在项目某个子目录中，只要输入：ant -find compile 命令，不需要改变工作目录就能够以命令行方式编译代码。参数-find告诉Ant寻找存在于上级目录中的build.xml并执行。  3. 使用单一构建文件  有人喜欢将一个大项目分解到几个小的构建文件，每个构建文件分担整个构建过程的一小部分工作。但是应该认识到，将构建文件分割会增加对整个构建过程的理解难度。要注意在单一构建文件能够清楚表现构建层次的情况下，不要过工程化(over-engineer)。  即使你把项目划分为多个构建文件，也应使程序员能够在项目根目录下找到核心build.xml。尽管该文件只是将实际构建工作委派给下级构建文件，也应保证该文件可用。  4. 提供良好的帮助说明  应尽量使构建文件自文档化。增加任务描述是最简单的方法。当你输入ant -projecthelp时，你就可以看到带有描述的任务清单。比如，你可以这样定义任务：  <target name=\"compile\"   description=\"Compiles code, output goes to the build dir.\"> 最简单的规则是对所有你希望程序员通过命令行直接调用的任务都加上描述。对于一般用来执行中间处理过程的内部任务，比如生成代码或建立输出目录等，就无法使用描述属性。  这时，可以通过在构建文件中加入XML注释来处理。或者专门定义一个help任务，当程序员输入ant help时来显示详细的使用说明。  <target name=\"help\"         description=\"Display detailed usage information\">  <echo>Detailed help...<\/echo><\/target> 5. 提供清空任务  每个构建文件都应包含一个清空任务，删除所有生成的文件和目录，使系统回到构建文件执行前的初始状态。执行清空任务后还存在的文件应处在版本控制系统的管理下。  比如：  <target name=\"clean\"     description=\"Destroys all generated files and dirs.\">  <delete dir=\"${dir.build}\"/>  <delete dir=\"${dir.dist}\"/><\/target>  除非是在产生整个系统版本的特殊任务中，否则不要自动调用clean任务。当程序员仅仅执行编译任务或其他任务时，他们不需要构建文件事先执行即令人讨厌有没有必要的清空任务。要相信程序员能够确定何时需要清空所有文件。  6. 使用ANT管理任务从属关系  假 设你的应用由Swing GUI组件、Web界面、EJB层和公共应用代码组成。在大型系统中，你需要清晰地定义Java包属于系统的哪一层。否则如何一 点修改都要重新编译成千上百个文件。任务从属关系管理差会导致过度复杂而脆弱的系统。改变GUI面板的设计不应造成Servlet和EJB的重编译。  当系统变得庞大后，稍不注意就可能将依赖于客户端的代码引入到服务端。这是因为IDE在编译文件时使用单一的classpath。Ant让你更有效地控制构建活动。  设计你的构建文件编译大型项目的步骤：首先，编译公共应用代码，将编译结果打成JAR包文件。然后，编译上一层的项目代码，编译时依靠第一步产生的JAR文件。不断重复这一过程，直到最高层的代码编译完成。  分步构建强化了任务从属关系管理。如果你工作在底层Java框架上，引用高层的GUI模板组件，这时代码不需要编译。这是由于构建文件在编译底层框架时，在源路径中没有包含高层GUI面板组件的代码。  7. 定义并重用文件路径  如果文件路径在一个地方集中定义，并在整个构建文件中得到重用，那么构建文件更易于理解。以下是这样做的一个例子：  <project name=\"sample\" default=\"compile\" basedir=\".\">  <path id=\"classpath.common\">    <pathelement location=\"${jdom.jar.withpath}\"/>    ...etc  <\/path>  <path id=\"classpath.client\">    <pathelement location=\"${guistuff.jar.withpath}\"/>    <pathelement location=\"${another.jar.withpath}\"/>    <!-- reuse the common classpath -->    <path refid=\"classpath.common\"/>  <\/path>  <target name=\"compile.common\" depends=\"prepare\">    <javac destdir=\"${dir.build}\" srcdir=\"${dir.src}\">          <classpath refid=\"classpath.common\"/>          <include name=\"com/oreilly/common/**\"/>    <\/javac>  <\/target><\/project> 当 项目不断增长，构建日益复杂时，这一技术越发体现出其价值。你可能为编译不同层次的应用定义各自的文件路径，比如运行单元测试的、运行应用程序的、运行 Xdoclet的、生成JavaDocs的等等不同路径。这种组件化路径定义的方法比为每个任务单独定义路径要优越得多。否则，很容易丢失任务任务从属关 系的轨迹。  8. 定义恰当的任务参数关系  假设dist任务从属于jar任务，那么哪个任务从属于compile任 务，哪个任务从属于prepare任务呢？Ant构建文件最终定义了任务的从属关系图，它必须被仔细地定义和维护。应该定期检查任务的从属关系以保证构建 工作得到正确执行。大的构建文件随着时间推移趋向于增加更多的任务，所以到最后由于不必要的从属关系导致构建工作非常困难。比如，你可能发现在程序员只是 需要编译一些没有使用EJB的GUI代码时，重新生成EJB代码。  以“优化”的名义忽略任务的从属关系是另一种常见的错误。这种错误迫 使程序员为了得到恰当的结果必须记住并按照特定的顺序调用一串任务。更好的做法是：提供描述清晰的公共任务，这些任务包含正确的任务从属关系；另外提供一 套“专家”任务让你能够手工执行个别的构建步骤，这些任务不提供完整的构建过程，但是让那些专家在快速而恼人的编码期间跳过某些步骤  9.使用配置属性  任何需要配置或可能发生变化的信息都应作为Ant属性定义下来。对于在构建文件中多次出现的值也同样处理。属性既可以在构建文件头部定义，也可以为了更好的灵活性而在单独的属性文件中定义。以下是在构建文件中定义属性的样式：  <project name=\"sample\" default=\"compile\" basedir=\".\">  <property name=\"dir.build\" value=\"build\"/>  <property name=\"dir.src\" value=\"src\"/>  <property name=\"jdom.home\" value=\"../java-tools/jdom-b8\"/>  <property name=\"jdom.jar\" value=\"jdom.jar\"/>  <property name=\"jdom.jar.withpath\"                     value=\"${jdom.home}/build/${jdom.jar}\"/>    etc...<\/project> 或者你可以使用属性文件：  <project name=\"sample\" default=\"compile\" basedir=\".\">  <property file=\"sample.properties\"/>   etc...<\/project> 在属性文件 sample.properties中:  dir.build=builddir.src=srcjdom.home=../java-tools/jdom-b8jdom.jar=jdom.jarjdom.jar.withpath=${jdom.home}/build/${jdom.jar} 用一个独立的文件定义属性是有好处的，它可以清晰地定义构建中的可配置部分。另外，在开发者工作在不同操作系统的情况下，你可以在不同的平台上提供该文件的不同版本。  10. 保持构建过程独立  为 了最大限度的扩展性，不要应用外部路径和库文件。最重要的是不要依赖于程序员的CLASSPATH设置。取而代之的是，在构建文件中使用相对路径并定义自 己的路径。如果你引用了绝对路径如C:\\java\\tools，其他开发者未必使用与你相同的目录结构，所以就无法使用你的构建文件  如果你部署开发源码项目，应该提供包括所有需要的JAR文件的发行版本，当然是在遵守许可协议的基础上。对于内部项目，相关的JAR文件都应在版本控制系统的管理中，并捡出到大家都知道的位置。  当你不得不应用外部路径时，应将路径定义为属性。使程序员能够涌适合他们自己的机器的参数重载这些属性。你也可以使用以下语法引用环境变量：  <property environment=\"env\"/><property name=\"dir.jboss\" value=\"${env.JBOSS_HOME}\"/> 11. 使用版本控制系统  构建文件是一个重要的文件，应该象代码一样进行版本控制。当你标记你的代码时，也应用同样的标签标记构建文件。这样当你需要回溯构建旧版本的软件时，能够使用相对应的旧版本构建文件。  除构建文件之外，你还应在版本控制中维护第三方JAR文件。同样，这使你能够重新构建旧版本的软件。这也能够更容易保证所有开发者拥有一致的JAR文件，因为他们都是同构建文件一起从版本控制系统中捡出的。  通常应避免在版本控制系统中存放构建输出品。倘若你的源代码很好地得到了版本控制，那么通过构建过程你能够重新生成任何版本的产品。  12. 把Ant作为“最小公分母”  假设你的开发团队使用IDE，为什么要为程序员通过点击图标就能够构建整个应用而烦恼呢？  IDE 的问题在团队中是一个关于一致性和重现性的问题。几乎所有的IDE设计初衷都是为了提高程序员的个人生产率，而不是开发团队的持续构建。典型的IDE要求 每个程序员定义自己的项目文件。程序员可能拥有不同的目录结构，可能使用不同版本的库文件，还可能工作在不同的平台上。这将导致出现这种情况：在A那里运 行良好的代码，到B那里就无法运行。  不管你的开发团队使用何种IDE，一定要建立所有程序员都能够使用的Ant构建文件。要建立一个程 序员在将新代码提交版本控制系统前必须执行Ant 构建文件的规则。这将确保代码是经过同一个Ant构建文件构建的。当出现问题时，要使用项目标准的 Ant构建文件，而不是通过某个IDE来执行一个干净的构建。  程序员可以自由选择任何他们习惯使用的IDE。但是Ant应作为公共基线以保证永远是可构建的。  13. 使用 zipfileset属性  人们经常使用Ant产生WAR、JAR、ZIP和 EAR文件。这些文件通常都要求有一个特定的内部目录结构，但其往往与你的源代码和编译环境的目录结构不匹配。  一个最常用的方法是写一个Ant任务按照期望的目录结构把一大堆文件拷贝到临时目录中，然后生成压缩文件。这不是最有效的方法。使用zipfileset属性是更好的解决方案。它让你从任何位置选择文件，然后把它们按照不同目录结构放进压缩文件中。以下是一个例子：  <ear earfile=\"${dir.dist.server}/payroll.ear\"    appxml=\"${dir.resources}/application.xml\">  <fileset dir=\"${dir.build}\" includes=\"commonServer.jar\"/>  <fileset dir=\"${dir.build}\">    <include name=\"payroll-ejb.jar\"/>  <\/fileset>  <zipfileset dir=\"${dir.build}\" prefix=\"lib\">    <include name=\"hr.jar\"/>    <include name=\"billing.jar\"/>  <\/zipfileset>  <fileset dir=\".\">    <include name=\"lib/jdom.jar\"/>    <include name=\"lib/log4j.jar\"/>    <include name=\"lib/ojdbc14.jar\"/>  <\/fileset>  <zipfileset dir=\"${dir.generated.src}\" prefix=\"META-INF\">    <include name=\"jboss-app.xml\"/>  <\/zipfileset><\/ear> 在这个例子中，所有JAR文件都放在EAR文件包的lib目录中。hr.jar和billing.jar是从构建目录拷贝过来的。因此我们使用zipfileset属性把它们移动到EAR文件包内部的lib目录。prefix属性指定了其在EAR文件中的目标路径。  14. 运行 Clean 构建任务的测试  假设你的构建文件中有clean和compile的任务，执行以下的测试。第一步，执行ant clean；第二步，执行ant compile；第三步，再执行ant compile。第三步应该不作任何事情。如果文件再次被编译，说明你的构建文件有问题。  构建文件应该只在与输出文件相关联的输入文件发生变化时，才应该执行任务。一个构建文件在不必执行诸如编译、拷贝或其他工作任务的时候执行这些等任务是低效的。当项目规模增长时，即使是小的低效工作也会成为大的问题。  15. 避免特定平台的Ant包  不管什么原因，有人喜欢用简单的、名称叫做compile之类的批文件或脚本装载他们的产品。当你去看脚本的内容，你会发现以下内容：  ant compile 其实开发人员熟悉Ant，并且完全能够自己键入ant compile。请不要仅仅为了调用Ant而使用特定平台的脚本。这只会使其他人在首次使用你的脚本时，增加学习和理解的烦扰。除此之外，你不可能提供适用于每个操作系统的脚本，这是真正烦扰其他用户的地方。  总结  太多的公司依靠手工方法和程序来编译代码和生成软件发布版本。那些不使用Ant或类似工具定义构建过程的开发团队，花费了令人惊异的时间来捕捉代码编译过程中出现的问题，这些在某些开发者那里编译成功的代码，到另一些开发者那里却失败了。  生成并维护构建脚本不是一项迷人的工作，但却是一项必需的工作。一个好的Ant构建文件将使你集中到更喜欢的工作——写代码中！ ","title":"Ant commend"},{"content":"用sharepoint designer 2010 创建列表工作流，出现以下错误 英文版： The form cannot be rendered. This may be due to a misconfiguration of the Microsoft SharePoint Server State Service. For more information, contact your server administrator. 中文版： 该表单无法显示，可能是由于 Microsoft SharePoint Server State Service 配置不当。有关详细信息，请与服务器管理员联系。 解决方法是需要在管理中心--〉应用程序管理--〉服务应用程序关联，启动一个服务配置。 点击配置服务应用程序关联，进入其配置页面，找到你需要配置的站点，例如http://moss:8000 点击该站点，选择自定义关联，并且确定选中state service 点击确定，完成配置。 接下来再次返回列表工作流，再次启动工作流。 点击流程，就没有报前面的error了，点击开始，流程启动。 这应该是工作流常见的一个error,所以简单记录一下。 广州京微信息科技有限公司,.微软sharepoint解决方案提供商。","title":"sharepoint 2010 启动工作流时，该表单无法显示，可能是由于Microsoft SharePoint Server State Service 配置不当."},{"content":"Flynn分类法，是基于指令流和数据流的数量对计算机进行分类的方法。 一系列修改那些流经数据处理单元的数据（数据流）的命令，可以被认为是一个指令流。 以下是四种不同的情况： 单指令流单数据流（SISD）——传统的计算机包含单个CPU，它从存储在内存中的程序那里获得指令，并作用于单一的数据流（本例中就是一个指令处理一条数据）。 单指令流多数据流（SIMD）——单个的指令流作用于多于一个的数据流上。例如有数据4、5和3、2，一个单指令执行两个独立的加法运算：4+5和3+2，就被称为单指令流多数据流。SIMD的一个例子就是一个数组或向量处理系统，它可以对不同的数据并行执行相同的操作。 多指令流单数据流（MISD）——用多个指令作用于单个数据流的情况实际上很少见。这种冗余多用于容错系统。 多指令流多数据流（MIMD）——这种系统类似于多个SISD系统。实际上，MIMD系统的一个常见例子是多处理器计算机，如Sun的企业级服务器。","title":"Flynn分类法"},{"content":"商务智能-系统概述-数据图形方式","title":"商务智能-系统概述-数据图形方式"},{"content":"一、写日志缓存： 方式1: printk（linux kernel中存在） 数值范围从0到7，数值越小，优先级越高。 控制日志： /proc/sys/kernel/printk 1       4       1       7 # echo 8 > /proc/sys/kernel/printk 四个整型数值：当前记录级，缺省记录级，最低记录级和启动时刻的缺省记录级。 方式2：syslog内核函数（linux kernel中存在） int syslog(int type, char *bufp, int len);  /* No wrapper provided in glibc */ ------- 内核API         *         *      0 -- Close the log.  Currently a NOP.         *      1 -- Open the log. Currently a NOP.         *      2 -- Read from the log.         *      3 -- Read all messages remaining in the ring buffer.         *      4 -- Read and clear all messages remaining in the ring buffer         *      5 -- Clear ring buffer.         *      6 -- Disable printk to console         *      7 -- Enable printk to console         *      8 -- Set level of messages printed to console         *      9 -- Return number of unread characters in the log buffer         *     10 -- Return size of the log buffer         */ 方式3：klogctl函数（C库中存在） #include <sys/klog.h> int klogctl(int type, char *bufp, int len);  --- glibc提供的API 二、写日志文件 方式1：/sbin/klogd -c 1 -x 通过klogctl函数读取，通过syslog系统函数写入日志文件。（注意，此处的syslog不是kernel中的syslog） 方式2：syslogd 二者在busybox库中可以找到。 /etc/syslog.conf 三、读日志： 方式1：文件kmsg -r-------- 1 root root 0 Dec 22 16:20 /proc/kmsg 方式2：命令dmesg  dmesg is used to examine or control the kernel ring buffer。 打印不带日志级别，其他和/proc/kmsg的内容相同。 方式3：读日志文件？？ printk 数值范围从0到7，数值越小，优先级越高。","title":"linux log"},{"content":" UML关系 依赖    依赖(dependency)关系表达一个类向另一个类发送消息，或者一个类是另一个类的数据成员类型，或者一个类     是另一个类的操作的参数或返回值类型等等。                         关联    关联(association)是一种结构关系，它指明一个事物的对象与另一个事物的对象间的联系                          关联包含   ：  集合，组合                                       集合：“has  a”    表示类之间整体与部分的关系。                                       组合：“contains    a”  特殊形式的集合，部分和整体有同样的生存期。                                                      泛化     泛化(generalization)是一种特殊/一般的关系。也可以看作是常说的继承，扩展关系。                                              实现     实现(realization)表达了一个类对于一个接口的实现关系。                                                                  网上搜的经典案例：    ","title":"UML简记"},{"content":"《Spring--IoC和DI》中把Spring比作了一个婚姻介绍所，准确的说应该是把IoC容器比作了婚姻介绍所，那么，这里就给他起个完整的名字叫IoC婚姻介绍所吧，这篇重点来看看这个IoC婚姻介绍所到底是怎么回事？各位都知道每家公司都会有BOSS这个角色，他一般是这个公司的实际代表者；而Spring中BeanFactory就是这家IoC婚姻介绍所的大BOSS，IoC容器的实际代表者，它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。 BeanFactory虽是大老板，但什么事情都不是他能亲历亲为的，想要这个婚姻介绍所发展壮大还需引进专业性人才，各司其职才是正道。因此，在BeanFactory的基础上衍生出了很多接口和实现类，这里的接口你就暂时先理解为那些趾高气昂的部门经理吧，至于实现类就是那些苦逼的普通员工了（顿时想到了苦逼的程序猿）。LZ大概数了下，这家IoC婚姻介绍所部门经理有十人，普通员工有十九人。鉴于管理层和员工比例失调，就先谈谈优秀的普通员工代表吧，这十九位普通员工中，有一位特别能干活，特别能吃苦，并且获得八一劳动奖章的员工，他叫XmlBeanFactory，没错，就是他，就是在十九人中事情最多的一位，该员工主要职责是：以XML方式描述组成应用的对象以及对象间的依赖关系，XmlBeanFactory类将获取此XML配置元数据，并用他来构建一个完全可配置的系统或应用。下图为这哥们的工作状态：               当然，能描述组成应用的对象以及对象间的依赖关系不止是Xml，还是有很多方式的，比如Annotation-based，这里就不做过多的介绍了，因为道理的想通的，用到的话查询下相关技术文档即可。 一个公司总有一些人是来干活的，一些人是打酱油的，这在管理层和普通员工中都会存在，下面就来看看优秀的部门经理代表，他叫ApplicationContext，是Context包的核心接口，我们可以采用声明式和编程式两种方式使用ApplicationContext。他除了拥有BeanFactory的所有功能外，还支持MessageSource，国际化消息访问；资源访问，如URL和文件；事件传播，实现了ApplicationListener接口的bean；载入多个（有继承关系）上下文，使得每个上下文都专注于特定的层次，比如应用的web层。其实说了半天也没有触及到它的核心职责，下面就来介绍核心职责：在ApplicationContext接口的众多实现类中，有3个是我们经常用到的：  1.ClassPathXmlApplicationContext：从类路径ClassPath中寻找指定的XML配置文件，找到并装载完成ApplicationContext的实例化工作。 2.FileSystemXmlApplicationContext：从指定的文件系统路径中寻找指定的XML配置文件，找到并装载完成ApplicationContext的实例化工作。 3.XmlWebApplicationContext：从Web应用中的寻找指定的XML配置文件，找到并装载完成ApplicationContext的实例化工作。 ApplicationContext实例化后，同样通过getBean方法从ApplicationContext容器中获取装配好的Bean实例以供使用。与BeanFactory不同的是，ApplicationContext容器实例化后会自动对所有的单实例Bean进行实例化与依赖关系的装配，使之处于待用状态。而BeanFactory容器实例化后并不会自动实例化Bean，只有当Bean被使用时BeanFactory容器才会对该Bean进行实例化与依赖关系的装配。 　　在Java项目中通过ClassPathXmlApplicationContext类手动实例化ApplicationContext容器通常是不二之选。但对于Web项目就不行了，Web项目的启动是由相应的Web服务器负责的，因此，在Web项目中ApplicationContext容器的实例化工作最好交给Web服务器来完成。  Spring为此提供了两种解决方案，一种是基于ContextLoaderListener实现的（此方案只适用于Servlet2.4及以上规范的Servlet容器）。例如，在web.xml中加入如下代码： <!--指定Spring的配置文件，多个配置文件以逗号分隔--> 　　<context-param> 　　<param-name>contextConfigLocation<\/param-name> 　　<param-value>classpath:spring-config/applicationContext.xml<\/param-value> 　　<\/context-param> 　　<!--指定以Listener方式启动Spring容器--> 　　<listener> 　　<listener-class>org.springframework.web.context.ContextLoaderListener<\/listener-class> 　　<\/listener> 另外一种方案则是基于ContextLoaderServlet实现的。例如，在web.xml中加入如下代码： <!--指定Spring的配置文件，多个配置文件以逗号分隔--> 　　<context-param> 　　<param-name>contextConfigLocation<\/param-name> 　　<param-value>classpath:spring-config/applicationContext.xml<\/param-value> 　　<\/context-param> 　　<!--指定以Servlet方式启动Spring容器--> 　　<servlet> 　　<servlet-name>context<\/servlet-name> 　　<servlet-class>org.springframework.web.context.ContextLoaderServlet<\/servlet-class> 　　<load-on-startup>1<\/load-on-startup> 　　<\/servlet> 从servlet容器启动时加载组件的顺序来看，Listener组件是优先于Servlet组件的。基于Servlet方式的加载方案主要是为了兼容Servlet2.3及以下规范的Servlet容器。以Tomcat为例，Tomcat5.x都已经支持Servlet2.4规范了，因此，基于Listener方式启动Spring容器是目前的主流选择。 最后再说一点，关于BeanFactory和ApplicationContext的选择，一般，除非你有更好的理由，否则尽量使用ApplicationContext，就好像，既然该公司有了这么多部门经理，别什么事都找大老板，有什么事找什么人最好。 对了，再说一点，既然IoC婚姻介绍所有了员工，那客户必不可少，最少也得需要一位客户来撑门面，也就是说至少要配置一个<bean>。  ","title":"Spring--IoC容器"},{"content":"hihernate一对多关联映射（单向Classes----->Student） 一对多关联映射利用了多对一关联映射原理 多对一关联映射：在多的一端加入一个外键指向一的一端，它维护的关系是多指向一 一对多关联映射：在多的一端加入一个外键指向一的一端，它维护的关系是一指向多 也就是说一对多和多对一的映射策略是一样的，只是站的角度不同 在一一端维护关系的缺点：  * 如果将t_student表里的classesid字段设置为非空，则无法保存  * 因为不是在student这一端维护关系，所以student不知道是哪个班的，    所以需要发出多余的update语句来更新关系       hihernate一对多关联映射（双向Classes<----->Student） 一对多双向关联映射：  * 在一一端的集合上使用<key>，在对方表中加入一个外键指向一一端  * 在多一端采用<many-to-one>   注意：<key>标签指定的外键字段必须和<many-to-one>指定的外键字段一致，否则引用字段的错误   如果在”一“一端维护一对多关联关系，hibernate会发出多余的udpate语句，所以我们一般在多 的一端来维护关联关系 关于inverse属性：  inverse主要用在一对多和多对多双向关联上，inverse可以被设置到集合标签<set>上，  默认inverse为false，所以我们可以从”一“一端和”多“一端维护关联关系，  如果设置成inverse为true，则我们只能从多一端来维护关联关系    注意：inverse属性，只影响数据的存储，也就是持久化   inverse和cascade  * inverse是关联关系的控制方向  * cascade操作上的连锁反应       hibernate一对一主键关联映射（单向关联Person---->IdCard） 一对一主键关联映射:让两个实体对象的id保持相同，这样可以避免多余的字段被创建 具体映射：  <id name=\"id\">   <!-- person的主键来源idCard，也就是共享idCard的主键 -->   <generator class=\"foreign\">    <param name=\"property\">idCard<\/param>   <\/generator>  <\/id>  <property name=\"name\"/>  <!-- one-to-one标签的含义，指示hibernate怎么加载它的关联对象，默认根据主键加载，  constrained=\"true\"， 表明当前主键上存在一个约束，person的主键作为外键参照了idCard   -->  <one-to-one name=\"idCard\" constrained=\"true\"/>     hibernate一对一主键关联映射（双向关联Person<---->IdCard） 需要在idcard映射文件中加入<one-to-one>标签指向person，指示hibernate如何加载person 默认根据主键加载       hibernate一对一唯一外键关联映射（单向关联Person---->IdCard） 一对唯一外键关联映射是多对一关联映射的特例 可以采用<many-to-one>标签，指定多的一端的unique=true，这样就限制了多的一端的多重性为一 通过这种手段映射一对一唯一外键关联     hibernate一对一唯一外键关联映射（双向关联Person<---->IdCard） 一对一唯一外键关联双向，需要在另一端（idcard），添加<one-to-one>标签，指示hibernate如何加载 其关联对象，默认根据主键加载person，外键关联映射中，因为两个实体采用的是person的外键维护的关系， 所以不能指定主键加载person，而要根据person的外键加载，所以采用如下映射方式： <one-to-one name=\"person\" property-ref=\"idCard\"/>       hibernate多对一关联映射 关联映射的本质：  * 将关联关系映射到数据库，所谓的关联关系是对象模型在内存中的一个或多个引用 <many-to-one>会在多的一端加入一个外键，指向一的一端，这个外键是由<many-to-one> 中的column属性定义的，如果忽略了这个属性那么默认的外键与实体的属性一致 <many-to-one>标签的定义示例：   * <many-to-one name=\"group\" column=\"groupid\"/>   理解级联的含义？  * 是对象的连锁操作        hibernate多对多关联映射(单向User---->Role) 具体映射方式：  <set name=\"roles\" table=\"t_user_role\">   <key column=\"userid\"/>   <many-to-many class=\"com.bjsxt.hibernate.Role\" column=\"roleid\"/>  <\/set>       hibernate多对多关联映射(双向User<---->Role) 映射方法：   <set name=\"roles\" table=\"t_user_role\">    <key column=\"userid\"/>    <many-to-many class=\"com.bjsxt.hibernate.Role\" column=\"roleid\"/>   <\/set> table属性值必须和单向关联中的table属性值一致 <key>中column属性值要与单向关联中的<many-to-many>标签中的column属性值一致 在<many-to-many>中的column属性值要与单向关联中<key>标签的column属性值一致","title":"hibernate中多对一、一对一、一对多、多对多的配置方法"},{"content":"            首先我们发现现在我们所用的android智能手机大部分都有当你在打电话时按power键来挂断电话，一般都是在设置中。 我主要是在原生源码中添加这一功能，主要用于学习。。。。先看一张图：   看到那个按电源键挂断电话吧，那就是我所添加的，本来原生源码中是没有这一栏的。。。。。 大概思路： 首先我先添加这一个checkboxPreference，然后将是否选择这一功能的值（0和1）存到data/data/com.android.providers.settings /databases/settings.db数据库的system表中 ，然后再根据数据库表中的值在PhoneWindownManager.java中去处理。 具体过程： 首先找到setting的源码，在源码下我们要找到通话设置，在seting.xml中我们能找到  <com.android.settings.IconPreferenceScreen            android:key=\"call_settings\"            settings:icon=\"@drawable/ic_settings_call\"            android:title=\"@string/call_settings_title\">            <intent                android:action=\"android.intent.action.MAIN\"                android:targetPackage=\"com.android.phone\"                android:targetClass=\"com.android.phone.CallFeaturesSetting\" />        <\/com.android.settings.IconPreferenceScreen> 这个call_settings就是我们在setting（设置）中看到的通话设置，但是我们却不能在settings中的源码中找到关于call_settings的布局文件， 因此我们需要找到它，其实这个布局文件是在package/app/Phone中，也就是在Phone这个app源码的资源文件中。 因此我们在Phone的资源文件下能找到Call_feature_setting.xml文件如下： <PreferenceScreen xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:phone=\"http://schemas.android.com/apk/res/com.android.phone\"        android:title=\"@string/call_settings\">            <PreferenceScreen        android:key=\"button_fdn_key\"        android:title=\"@string/fdn\"        android:summary=\"@string/sum_fdn\"        android:persistent=\"false\">        <intent android:action=\"android.intent.action.MAIN\"            android:targetPackage=\"com.android.phone\"            android:targetClass=\"com.android.phone.FdnSetting\" />    <\/PreferenceScreen>    <PreferenceCategory        android:key=\"button_voicemail_category_key\"        android:title=\"@string/voicemail\"        android:persistent=\"false\">      <ListPreference          android:key=\"button_voicemail_provider_key\"          android:title=\"@string/voicemail_provider\"          android:summary=\"@string/sum_voicemail_choose_provider\"          android:defaultValue=\"\"          android:persistent=\"true\"      />      <PreferenceScreen android:key=\"button_voicemail_setting_key\"            android:title=\"@string/voicemail_settings\"            android:persistent=\"false\">            <!-- Note for all com.android.phone.EditPhoneNumberPreference objects           The last several attributes are for use with the EditText field           in the dialog.  These attributes are forwarded to that field           when the edittext is created.  The attributes include:             1. android:singleLine             2. android:autoText             3. android:background -->              <com.android.phone.EditPhoneNumberPreference                android:key=\"button_voicemail_key\"                android:title=\"@string/voicemail_settings_number_label\"                android:persistent=\"false\"                android:dialogTitle=\"@string/voicemail\"                phone:confirmMode=\"confirm\"                android:singleLine=\"true\"                android:autoText=\"false\" />      <\/PreferenceScreen>  <\/PreferenceCategory>。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。 因此我们可以在最前面添加一个checkboxPreference <CheckBoxPreference        android:key=\"press_power_end_call_key\"        android:title=\"@string/press_power_end_call\"         android:persistent=\"false\"/> 变成： <PreferenceScreen xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:phone=\"http://schemas.android.com/apk/res/com.android.phone\"        android:title=\"@string/call_settings\">     <CheckBoxPreference        android:key=\"press_power_end_call_key\"        android:title=\"@string/press_power_end_call\"         android:persistent=\"false\"/>            <PreferenceScreen        android:key=\"button_fdn_key\"        android:title=\"@string/fdn\"        android:summary=\"@string/sum_fdn\"        android:persistent=\"false\">        <intent android:action=\"android.intent.action.MAIN\"            android:targetPackage=\"com.android.phone\"            android:targetClass=\"com.android.phone.FdnSetting\" />    <\/PreferenceScreen>。。。。。。。。。。。。。。。。。。。。。 在这里有自己定义的： android:title=\"@string/press_power_end_call\"  所以我们要在资源的string.xml文件中添加相关的信息： 在package/app/Phone/res/values/string.xml中添加： <string name=\"press_power_end_call\">press_power_end_call<\/string> 在package/app/Phone/res/values-zh-rCN/string.xml中添加： <string name=\"press_power_end_call\" msgid=\"4676390750360727396\">按电源键挂断电话<\/string> 到这里就算添加好了UI上的东西，接下来就是代码了： 在package/app/Phone/src/com/android/phone下找到CallFeatureSetting.java文件， 在 public boolean onPreferenceChange(Preference preference, Object objValue) 方法中要增加一个如果选择了按power键挂电话 的事件： //add by xxnan\t\telse if (preference == press_power_end_call) {              //如果勾选就将1存到system表的press_power_end_call中              Settings.System.putInt(getContentResolver(),                    \"press_power_end_call\",                    press_power_end_call.isChecked() ? 1 : 0);\t\t //end by xxnan       在OnCreate添加如下代码之后： protected void onCreate(Bundle icicle) {        super.onCreate(icicle);        if (DBG) log(\"Creating activity\");                mPhone = PhoneFactory.getDefaultPhone();        addPreferencesFromResource(R.xml.call_feature_setting);         //add by xxnan        ContentResolver resolver = getContentResolver();        press_power_end_call= (CheckBoxPreference)findPreference(press_power_end_call_key);\t press_power_end_call.setOnPreferenceChangeListener(this);// 获的数据库system表里press_power_end_call的值，也就是是否选择了checkboxpreference\t int \tpress_power_end_call_key=Settings.System.getInt(getContentResolver(),                    \"press_power_end_call\",0);//如果得到的值是1，则下次打开setting的话，选项框要勾选\t if(press_power_end_call_key==1)\t \tpress_power_end_call.setChecked(true);\t //end by xxnan\t        mAudioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);        // get buttons        PreferenceScreen prefSet = getPreferenceScreen();        mSubMenuVoicemailSettings = (EditPhoneNumberPreference)findPreference(BUTTON_VOICEMAIL_KEY);。。。。。。。。。。。。。。 这样就算差不多完成了到获取是否开启这一功能存放和取出到系统数据库中，接下来就是到framework/base/policy/src/com/android /internal/policy/impl下的 PhoneWindowManager.java中去处理了，之前我们就有分析到PhoneWindowManager.java中的 public int interceptKeyBeforeQueueing(long whenNanos, int action, int flags, int keyCode, int scanCode, int policyFlags, boolean isScreenOn)方法来接受按power键的事件，在这个方法里我们只需要添加很少代码： 原来代码是： case KeyEvent.KEYCODE_POWER: {                result &= ~ACTION_PASS_TO_USER;\t\t \t                if (down) {\t\t       Log.i(\"xxnan\",\"xxnan\"+\"xiaxiangnan\");                    ITelephony telephonyService = getTelephonyService();\t\t\t     boolean hungUp = false;                                        if (telephonyService != null) {                        try {                            if (telephonyService.isRinging()) {                                // Pressing Power while there's a ringing incoming                                // call should silence the ringer.                                telephonyService.silenceRinger();                             } else if ((mIncallPowerBehavior                                    & Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) != 0                                    && telephonyService.isOffhook()) {                                // Otherwise, if \"Power button ends call\" is enabled,                                // the Power button will hang up any current active call.                                hungUp = telephonyService.endCall();                            }                                                 } catch (RemoteException ex) {                            Log.w(TAG, \"ITelephony threw RemoteException\", ex);                        }                    }                    interceptPowerKeyDown(!isScreenOn || hungUp);。。。。。。。。。。。。。。。。。。。。。。。。 修改后： case KeyEvent.KEYCODE_POWER: {                result &= ~ACTION_PASS_TO_USER;\t\t \t                if (down) {\t\t       Log.i(\"xxnan\",\"xxnan\"+\"xiaxiangnan\");\t\t\t\t   int end_call_key=Settings.System.getInt(mContext.getContentResolver(),                    \"press_power_end_call\",0); //取出数据库中是否打开这一功能的值  \t\t\t   Log.i(\"end_call_key\",\"end_call_key=\"+end_call_key);                    ITelephony telephonyService = getTelephonyService();\t\t\t     boolean hungUp = false;                                        if (telephonyService != null) {                        try {                            //如果是电话正在打且开启了这一功能，当按power键就挂掉电话                              if (telephonyService.isRinging()&&end_call_key==1) {                                // Pressing Power while there's a ringing incoming                                // call should silence the ringer.                               // telephonyService.silenceRinger(); \t\t\t\t\t                               hungUp=telephonyService.endCall();                            } else if ((mIncallPowerBehavior                                    & Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) != 0                                    && telephonyService.isOffhook()) {                                // Otherwise, if \"Power button ends call\" is enabled,                                // the Power button will hang up any current active call.                                hungUp = telephonyService.endCall();                            }                                                 } catch (RemoteException ex) {                            Log.w(TAG, \"ITelephony threw RemoteException\", ex);                        }                    }                    interceptPowerKeyDown(!isScreenOn || hungUp);。。。。。。。。。。。。。。。。。。。。。。由于我这个开发板上是不能插电话卡的也就没能实验成功，但是原理应该就这样的！ 最后修改过的地方都要重新编译，那么我们要在源码下编译app下的Phone以及framework下的policy 最后生成的out/。。。/system/app/Phone.apk和out/。。。。/system/framework/android.policy.jar都要替换 手机里的相同（adb shell 进入你的手机,要有root权限）文件应该就可以了。","title":"android setting中添加电源键挂断电话"},{"content":"      前几天停下来整理了一下OA的部分代码,主要是struts部分,尤其是页面jsp和xml配置文件部分.       之前实现的:       (1)搭建SSH环境: jar包拷贝和冲突解决; 配置文件准备; Spring+Struts整合,在web应用启动时,创建spring的ApplicationContext实例; 编码问题CharacterEncodingFilter;  Spring+Hibernate: OpenSessionInViewFilter, 配置sessionFactory, 配置事务, 配置数据库连接参数.       (2)实体层编写-->Hibernate映射文件的编写或生成-->Dao层接口抽象和实现-->Manager层接口抽象和实现-->ApplicationContext-daos.xml和ApplicationContext-managers.xml的编写       --之前进行到这里,我的剩余工作:       (3)ActionForm的编写-->Action的编写-->jsp页面的修改(在模板的基础上进行修改)       -->配置文件的编写: struts-config.xml和applicationContext-actions         要实现的模块: 组织机构(机构管理,人员管理),权限管理(模块管理,角色管理,用户管理)        大部分都是相似的代码:       Dao部分无非是增删改查: add*(), 删一个或删多个del*(), update*(), 查特定find*(), 分页查全部search*(), 以及各种查询.       Action主要是: 打开主页面,打开添加页面,添加,删除,有的还有打开更新页面,更新.      只有用户管理多一些分配角色的操作(打开角色列表页,打开分配角色页,分配角色,删除用户的角色).        代码测试过程中,遇到两大bug,很让人无语但绝对实用的bug:        (1)报Action里面MethodNotFoundException         --> 最后发现是Action里面的方法,我复制的unspecified(),它的修饰符为protected, 所以我其他的方法也都是protected, 然后就MethodNotFound了.          --> 解决:除override的unspecified()方法外,其他方法应为public       (2)让我从昨天晚上纠结到今天晚上的错误: org.springframework.dao.InvalidDataAccessApiUsageException:Write operations are not allowed in read-only mode (FlushMode.NEVER/MANUAL): Turn your Session into FlushMode.COMMIT/AUTO or remove 'readOnly' marker from transaction definition.          -->尝试:在getHibernateTemplate().save(module);之前加上       getSession().setFlushMode(FlushMode.COMMIT);       有说在web.xml文件中加上init-param,如下: \t<filter>\t    <filter-name>OpenSessionInViewFilter<\/filter-name>\t    <filter-class>org.springframework.orm.hibernate3.support.OpenSessionInViewFilter<\/filter-class>\t    <init-param>\t\t\t<param-name>FlushMode<\/param-name>\t\t\t<param-value>COMMIT<\/param-value>\t\t<\/init-param>\t<\/filter>\t\t<filter-mapping>\t    <filter-name>OpenSessionInViewFilter<\/filter-name>\t    <url-pattern>/*<\/url-pattern>\t<\/filter-mapping>       但是仍然报上面的错误, 可见, 这个设置对于我的保存操作/写操作并没有生效. 后来改用在getHibernateTemplate().save(module);之前加上 getSession().setFlushMode(FlushMode.COMMIT);      保存成功!       -->最终解决:applicationContext-common.xml中pointcut的配置\"execution (* com.ys.oa.managers.*.*(..))\",包名写错了.      因此,不属于这个pointcut范围内的方法,FlushMode被设置为Never/Manual;      pointcut范围内的方法,FlushMode为Commit/Auto.       -->还好,顺带理解一下session的FlushMode吧:       因为OpenSessionInViewFilter在getSession的时候,会把获取回来的session的flush mode 设为FlushMode.NEVER。故进行insert、 update和delete操作时会产生异常：org.springframework.dao.InvalidDataAccessApiUsageException: Write operations are not allowed in read-only mode (FlushMode.NEVER/MANUAL): Turn your Session into FlushMode.COMMIT/AUTO or remove 'readOnly' marker from transaction definition. 因此需要采用spring的事务声明,使方法受transaction控制: \t<!-- 配置事务管理器 -->\t\t<bean id=\"transactionManager\" class=\"org.springframework.orm.hibernate3.HibernateTransactionManager\">\t\t<property name=\"sessionFactory\">\t\t\t<ref local=\"sessionFactory\"/>\t\t<\/property>\t<\/bean>        <!-- 配置事务特性 -->           <tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">    \t<tx:attributes>    \t\t<tx:method name=\"add*\" propagation=\"REQUIRED\"/>    \t\t<tx:method name=\"del*\" propagation=\"REQUIRED\"/>    \t\t<tx:method name=\"update*\" propagation=\"REQUIRED\"/>    \t\t<tx:method name=\"*\" propagation=\"REQUIRED\" read-only=\"true\"/>    \t<\/tx:attributes>    <\/tx:advice>        <!-- 配置那些类的方法进行事务管理 -->    <aop:config>    \t<aop:pointcut id=\"allManagerMethod\" expression=\"execution (* com.ys.oa.managers.*.*(..))\"/>    \t<aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"allManagerMethod\"/>    <\/aop:config> 参考文档:http://blog.sina.com.cn/s/blog_59bc146c0100emn2.html","title":"OA模块管理实现中出现的问题"},{"content":"一、简单工厂 简单工厂是面向对象编程的起步设计模式，用到面向对象设计的三大特性：封装，继承，多态来进行设计是必须的。 封装：使业务逻辑和界面逻辑分离，做到代码复用，而不是复制。 继承：将在同一类中进行的逻辑操作，抽象出一个类或者接口，统一定义，通过子类进行不同的实现。这样对象之间的修改就变得独立，不会影响到其他类，降低了对象间的耦合。 多态：通过给同类Things定义接口或抽象类，由子类继承实现统一父类方法，但不同的子类又有不同实现，将继承和多态演绎完成。   1、简单工厂解决的问题 原来这些业务都在同一个类中，我们通过传入参数，来判断具体调用哪个函数，现在我们把这些类都一个个独立封装起来，问题出现了， 我们应该怎样从客户端调用具体要实现的业务逻辑类呢？？？   这时候该简单工厂上场了。在工厂中根据客户端传入参数来决定要实例化的对象。   定义一个工厂类，负责创建实例过程。通过这个工厂，我们将客户端和业务逻辑类进行联系。 当然作为联系者，当然定义中就要需要知道所有的业务逻辑类，所以在类图中，你会发现是工厂类依赖逻辑类哦！ 2、类图     二、工厂模式 1、工厂模式 工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。   2、工厂模式的出现 简单工厂模式通过一个工厂类实现了客户端对具体调用类的实例化。那么大家都知道简单工厂中的工厂类是通过客户端传入参数，由条件语句进行判断后决定实例化哪个类的。那是不是您也有这样的疑问呢？面向对象技术要做到尽可能的封装性好，一个类修改，增删，不影响到其他类。那在简单工厂模式中，工厂类中要修改或增加一个操作，都必须打开这个工厂类，那么工厂类中的所有运算我就可以一览无遗了，是不是这里就封装不严了呢？ 工厂类封装不严怎么办？   还是由简单模式的二姐（还有大姐哦），工厂模式来给她完善吧！   工厂模式将面向对象理解的很到位，既然封装不严，那么我们就给抽象工厂也分出一个层次了来，抽象出一个接口，然后把这些分支判断语句转换成一个个小的子类来实现工厂接口。是不是跟业务逻辑的封装是如出一辙呢？   这样我们就把原来需要再工厂类中要判断的条件语句转移到客户端，虽然还得判断需要实例化哪个，但是这些都是跟界面打交道的代码，我们都放在客户端中处理，不会影响到内层业务，且以后要增加运算，我们只需增加运算类，对应的指向运算类的工厂，不会干扰到其他类，这样的业务结构是牢固的，我们所期待的。   3、类图   三、抽象工厂 详情请见上篇博客：抽象工厂。   作者信息","title":"工厂三姐妹——创建型设计模式之二"},{"content":"注意：该方法用于网站项目。但对于其他类型的项目有一定的参考作用。 1.首先在你想被别人访问的位置新建一个ashx文件，如/System/xxx.ashx。 新建xxx.ashx的代码如下： <%@ WebHandler Language=\"C#\" Class=\"xxx\" %>using System;using System.Web;public class xxx: IHttpHandler {        public void ProcessRequest (HttpContext context) {        context.Response.ContentType = \"text/plain\";        context.Response.Write(\"Hello World\");    }     public bool IsReusable {        get {            return false;        }    }}注意到首行的Class=“xxx”吗？“xxx”代表一个类型，表示一般处理文件的处理逻辑在那里执行。 这个时候就应该有点好奇了，能不能该Class的属性的，或者把“xxx”类搬到其他地方呢？明确的告诉你是可以的。 但我发现对于网站来说，将cs文件放在除App_Code文件外，将不能识别，所以在App_Code文件新建一个xxx.cs，将xxx.ashx除首行 <%@ WebHandler Language=\"C#\" Class=\"xxx\" %>外的代码剪切到xxx.cs里，注意是剪切哦。 year，运行正常。","title":"让一般处理文件.ashx的代码有折叠功能（#region）"},{"content":"浩瀚的宇宙，充满着神秘和魅力。宇宙中每天都上演着无数美丽壮观的天文奇观，甚至是“大鱼吃小鱼”的暴力事件——大的星体如黑洞吞噬小的星体。天文学家近期就评出宇宙十大最为美丽壮观的暴力事件：   1、小行星撞击行星 一个巨大的太空星体碰撞木星，在木星表面形成一个太平洋大小的“黑眼圈”，科学家分析称，木星表面出现的黑眼圈很可能是由一颗未探测到的彗星碰撞造成的，提示许多天文学家未来有一日可能出现类似的碰撞事件，足以对地球构成致命的毁灭，使人类重蹈恐龙灭绝之路。   2、超新星爆炸 恒星的剧痛死亡--超新星爆炸。这张图片基于美国宇航局“斯皮策”太空望远镜的观测数据，从而揭示仙后座A超新星是以相同的形式的产生爆炸，当它们进入太空时仍保留其外层。   3、热核恒星爆炸 超新星爆炸事件非常明亮，观测者能够较早期地在夜晚观测到超新星释放出的光亮。如图所示，这是超新星SN 2006gy的爆炸过程。   4、伽马射线爆 恒星爆炸释放伽马射线流距离地球75亿光年星系中的一颗恒星爆炸非常强大，所释放的光度很明亮，人们在地球上完全可以通过肉眼进行观测。天文学家通过美国宇航局“雨燕”人造卫星记录了此次恒星爆炸更详细的观测资料，称此次爆炸为“伽马射线爆”。   5、黑洞吞并共同恒星的其他 黑洞吞并共同恒星的气体如图所示，一个超大黑洞的形成源自垂死的恒星，该黑洞正在吞噬着垂死恒星另一颗共生恒星所释放的气体，黑洞能够吸食范围之内的所有宇宙物质和光线。   6、黑洞吞噬恒星 这是距离地球7亿光年之遥的RX J1242-11星系中心的一个超大质量黑洞，它曾将一颗太阳大小的恒星撕裂。黑洞重心牵引力使这颗恒星延伸，实际上只有大约百分之一的恒星被黑洞所吞噬。恒星其他部分通过交互动能被抛入星系之中。   7、超级黑洞吞入电子流 如图所示，人马座A星系中心一个超大质量黑洞附近的电子流与无线电、X射线和可见光结合在一起。星系内黑洞质量相当于太阳1亿倍，该电子流被吞入超大质量黑洞之中，电子流需要传播0.5光年。当电子流猛烈撞击周边气体，就形成一股冲击波，右下侧正是冲击波喷射出的蓝色X射线。   8、星系碰撞 哈勃天文望远镜拍摄到星系碰撞。天文学家认为20亿年之后仙女座星系将与银河系进行合并，并吞噬银河系全部的星体。如图所示，这是科学家模拟的仙女座星系恒星爆的过程。   9、神秘的暗物质 科学家认为暗物质在宇宙中占主要成份，当天文学家观测两个超大星系簇发生碰撞时可揭示暗物质的存在。这项观测基于钱德拉X射线天文台和其他天文望远镜，显示出星系碰撞如何从普遍宇宙物质中分离出暗物质。如图所示，粉红物质是星系碰撞出现的普通物质，蓝色物质则是暗物质。   10、“星系高速路”的连环碰撞。 如图所示，呈现的是星系高速路的连环碰撞，这张合成照片是由钱德拉X射线天文台、哈勃太空望远镜和夏威夷凯克天文台拍摄完成的。图片揭示4个隔离星系簇之间沿一条0.13亿光年长的星系高速路壮观碰撞，在这个星系高速路上充满着星系、气体和暗物质。","title":"神奇壮观！宇宙中上演的十大暴力事件"},{"content":"观察者模式概念：定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。“Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.” – GoF UML图 特点：     1.观察者模式定义了对象之间一对多的关系。     2.主题（也就是可观察者）用一个共同的接口来更新观察者。     3.观察者和可观察者用松耦合的方式结合，可观察者不知道观察者的细节，只知道观察者实现了观察者接口     4.有多个观察者时，不可以依赖特点的通知次序。 C++源代码： Observer.h [cpp] view plaincopyprint? /*      观察者模式：在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，      依赖它的对象都会收到通知，并自动更新。  */      #include <iostream>   #include <vector>   using namespace std;      class Observer;      //Account抽象类，用作接口   class Account   {   protected:       vector<Observer*> observer;       double balance;   public:       virtual void add_observer(Observer *o)=0;       virtual void remove_observer(Observer *o)=0;       virtual void notify_observer()=0;       virtual void set_balance(double balance)=0;       virtual double get_balance()=0;   public:       virtual ~Account()       {           cout<<\"in the destructor of Account\"<<endl;       }   };      //Observer抽象类，用作接口   class Observer   {   protected:       Account *account;   public:       Observer(Account *account):account(account) {}       virtual void handle_event()=0;       virtual void set_account_balance(double balance)=0;       virtual ~Observer()       {           cout<<\"in the destructor of Observer\"<<endl;       }   };      //BankAccount具体类，继承了ACcount抽象类   class BankAccount:public Account   {   public:          ~BankAccount()       {           cout<<\"in the destructor of BankAccount\"<<endl;       }      public:       void add_observer(Observer *o)       {           observer.push_back(o);       }       void remove_observer(Observer *o)       {           for(vector<Observer*>::iterator it=observer.begin(); it!=observer.end(); it++)           {               if(o==*it)               {                   observer.erase(it);                   return;               }           }       }       void notify_observer()       {           for(vector<Observer*>::const_iterator it=observer.begin(); it!=observer.end(); it++)           {               (*it)->handle_event();           }       }       void set_balance(double balance)       {           this->balance=balance;           notify_observer();       }       double get_balance()       {           return balance;       }      };      class ATM:public Observer   {   public:       ATM(Account *account):Observer(account)//将acount传递给基类Observer的构造函数       {       }       ~ATM()       {           cout<<\"in the destructor of ATM\"<<endl;       }   public:       void handle_event()       {           cout<<\"ATM: the balance of bank accont is changed to \"<<account->get_balance()<<endl;       }       void set_account_balance(double balance)       {           account->set_balance(balance);       }   };      class InternetBankService:public Observer   {   public:       InternetBankService(Account *account):Observer(account) {}       ~InternetBankService()       {           cout<<\"in the destructor InternetBankService \"<<endl;       }   public:       void handle_event()       {           cout<<\"IBS: the balance of bank account is changed to:\"<<account->get_balance()<<endl;       }       void set_account_balance(double balance)       {           account->set_balance(balance);       }      };   Observer.cpp   [cpp] view plaincopyprint? #include \"Observer.h\"   int main(int argc, char **argv)   {       Account *account=new BankAccount();       Observer *atm_observer=new ATM(account);       Observer *ibs_observer=new InternetBankService(account);          account->add_observer(atm_observer);       account->add_observer(ibs_observer);          account->set_balance(1000.12);          cout<<\"Event is triggered by atm_observer\"<<endl;       cout<<\"=============\"<<endl;       atm_observer->set_account_balance(1000.23);          cout<<\"Event is triggered by ibs_observer\"<<endl;       cout<<\"=============\"<<endl;       ibs_observer->set_account_balance(1000.36);          delete atm_observer;       delete ibs_observer;       return 0;   }   例2： Test_Observer.cpp [cpp] view plaincopyprint? /*      千万要注意对象分割问题的出现。一定要理解。  */   #include <iostream>   #include <string>   #include <vector>   using namespace std;      class Observer   {   protected:       string name;   public:       virtual void update()       {           cout<<\"Observer\"<<endl;       }   };      class Man:public Observer   {   public:       Man(string name)       {           this->name=name;       }       void update()       {           cout<<name<<\" Man is coming\"<<endl;       }   };   class Woman:public Observer   {   public:       Woman(string name)       {           this->name=name;       }       void update()       {           cout<<name<<\" Woman is leaving\"<<endl;       }   };      class Subject   {   private:       vector<Observer*> obser;   public:       void add(Observer &ob)       {           obser.push_back(&ob);       }       void notify()       {           for (vector<Observer*>::iterator it=obser.begin(); it!=obser.end(); it++)           {               (*it)->update();           }       }   };      int main()   {       Subject secret;       Man m1(\"m1--\");       Man m2(\"m2--\");       Woman w1(\"w1\");       Woman w2(\"w2\");          secret.add(m1);       secret.add(m2);       secret.add(w1);       secret.add(w2);          secret.notify();       return 0;      }  ","title":"观察者模式-C++实现"},{"content":"In Magento, catalog rules apply to catalog and products to cut the product prices and promote sales. This is one special sharp tool for holidays promotion. Catalog price offers four ways to discount the price.     public function calcPriceRule ($actionOperator, $ruleAmount, $price)    {        $priceRule = 0;        switch ($actionOperator) {            case 'to_fixed':                $priceRule = $ruleAmount;                break;            case 'to_percent':                $priceRule= $price * $ruleAmount / 100;                break;            case 'by_fixed':                $priceRule = $price - $ruleAmount;                break;            case 'by_percent':                $priceRule = $price * (1 - $ruleAmount / 100);                break;        }        return $priceRule;    }In addition, catalog rules use Magento event mechanism to finish the discount work. There are lots of event hooks defined in the config.xml.         <events>            <prepare_catalog_product_price_index_table>                <observers>                    <catalogrule>                        <class>catalogrule/observer<\/class>                        <method>prepareCatalogProductPriceIndexTable<\/method>                    <\/catalogrule>                <\/observers>            <\/prepare_catalog_product_price_index_table>            <catalog_product_type_configurable_price>                <observers>                    <catalogrule>                        <class>catalogrule/observer<\/class>                        <method>catalogProductTypeConfigurablePrice<\/method>                    <\/catalogrule>                <\/observers>            <\/catalog_product_type_configurable_price>        <\/events>It is obvious that class Mage_CatalogRule_Model_Observer plays an important role in the catalog rule model. I will pick up some methods to explain the logic behind the scene. public function prepareCatalogProductCollectionPrices(Varien_Event_Observer $observer){\t/* @var $collection Mage_Catalog_Model_Resource_Eav_Mysql4_Product_Collection */\t$collection = $observer->getEvent()->getCollection();\t\t$productIds = array();\t/* @var $product Mage_Core_Model_Product */\tforeach ($collection as $product) {\t\t$key = implode('|', array($date, $websiteId, $groupId, $product->getId()));\t\tif (!isset($this->_rulePrices[$key])) {\t\t\t$productIds[] = $product->getId();\t\t}\t}\tif ($productIds) {\t\t$rulePrices = Mage::getResourceModel('catalogrule/rule')\t\t\t->getRulePrices($date, $websiteId, $groupId, $productIds);\t\tforeach ($productIds as $productId) {\t\t\t$key = implode('|', array($date, $websiteId, $groupId, $productId));\t\t\t$this->_rulePrices[$key] = isset($rulePrices[$productId]) ? $rulePrices[$productId] : false;\t\t}\t}\treturn $this;}When the production collection show in the front-end, the above code snippets will carry out and ensure the products to get their catalog rule prices. After you apply the catalog rule in the admin back-end, the product price may be back to normal price after some time. It is a bit strange. However, the answer for this question is cron job. Catalog rule cron job must be enabled to avoid this problem.     <crontab>        <jobs>            <catalogrule_apply_all>                <schedule>                    <cron_expr>0 1 * * *<\/cron_expr>                <\/schedule>                <run>                    <model>catalogrule/observer::dailyCatalogUpdate<\/model>                <\/run>            <\/catalogrule_apply_all>        <\/jobs>        <events>            <catalog_product_get_final_price>                <observers>                    <catalogrule>                        <class>catalogrule/observer<\/class>                        <method>processAdminFinalPrice<\/method>                    <\/catalogrule>                <\/observers>            <\/catalog_product_get_final_price>        <\/events>    <\/crontab> You may be still in doubt about the cron job's magic power. The follow code snippets from admin back-end tells us the truth.     public function applyRulesAction()    {        try {            Mage::getModel('catalogrule/rule')->applyAll();            Mage::app()->removeCache('catalog_rules_dirty');            Mage::getSingleton('adminhtml/session')->addSuccess(                Mage::helper('catalogrule')->__('The rules have been applied.')            );        } catch (Exception $e) {            Mage::getSingleton('adminhtml/session')->addError(                Mage::helper('catalogrule')->__('Unable to apply rules.')            );            throw $e;        }        $this->_redirect('*/*');    }    public function dailyCatalogUpdate($observer)    {        Mage::getResourceSingleton('catalogrule/rule')->applyAllRulesForDateRange();        return $this;    }","title":"[置顶] [Magento] Why the catalog promotion rule disappear after some time?"},{"content":"•       HQL：Hibernate查询语言，它是Hibernate提供的一种面向对象的查询语言。  (1)在查询语句中设定各种查询条件  (2)支持动态绑定参数 (3)支持投影查询、分页查询、连接查询、分组查询，子查询 (4) 内置了一些聚集函数  二．HQL Hibernate中的Query接口就是专门用来执行HQL语句的查询接口。 1.创建查询对象 Query query=session.createQuery(“fromDept”); 2.执行查询列出结果   1）列出所有的结果 List<Dept> depts=query.list(); for(Dept dept:depts){…} •       2)列出单个结果 Query query=session.createQuery(“from Deptwhere id=1”);  query.setMaxResults(1);  Dept dept=(Dept)query.uniqueResult(); 3)迭代访问结果 Iterator<Dept> it=query.iterate(); While(it.hasnext()){ } HQL 基本语法：持久化类名区分大小写 1）选择要查询的持久化类。   String hql=“from Dept”  Query query=session.createQuery(hql);  String hql=“from Dept as d”; 2）投影查询 String hql=\"select id,name fromDept\"; Query query=session.createQuery(hql); List list=query.list(); intsize=list==null?0:list.size(); for(inti=0;i<size;i++){     Object[] obj=(Object[])list.get(i);       System.out.println(obj[1]+“  ”+obj[2]); } •       针对选定属性创建一个类，提供以这两个属性为参数的构造方法，使用此类来封装查询结果。   3）where 条件子句 •       String hqlString=\"from Dept d whered.createdTime>='2010-01-01'\"; •       Query query=session.createQuery(hqlString); •       String hqlString=\"from Dept d where d.name like'java%' andd.employees is not empty and d.createdTime<current_date()\"; •       绑定查询参数： •       按参数名字绑定 •       String hql=“from  Dept whereid>:id and name like:likeName” •       List<Dept> depts=session.createQuery(hql).setLong(“id”,newLong(ingputID)).setString(“likeName”,”%”+inputName+”%”).list(); •       按参数位置绑定 •       5）distinct 过滤重复值 •       Select distinct createTime from Dept •       6）聚集函数 •        select count(d) from Dept d •       7）order by 排序 •       From Dept d order by d.createdTime asc,d.name desc •       8）group by 对记录分组 •       Select count(e) from Employee e group by e.dept; •       9）having 对分组后数据进行条件过滤 •       Select e.dept.name from Eployee e group by e.dept havingcount(e)>1 分页查询 Query接口提供两个用于分批显示查询结果的方法 setFirstResult(intfirstResult)：在记录集中从第几条记录开始取数据。默认是0。 setMaxResults(intmaxResults)：设置每次查询返回的最大对象数。 session.beginTransaction(); String hql =\"from Employee\"; List<Employee>empls =  session.createQuery(hql)                    .setMaxResults(pageSize)                    .setFirstResult((pageNo - 1)* pageSize)                    .list(); session.getTransaction().commit(); 批量修改和删除：直接通过SQL语句操作数据库，执行完后，当前session缓存中的数据与数据库中的数据不是同步的。 Stringhql=“delete Dept as d where d.name like:likeName”; Queryquery=session.createQuery(hql).setString(“likeName”,”%三%”); int count=query.executeUpdate(); 连接查询 •       Inner join                  left outer join    •       Right outer join         fulljoin String hql =\"FROM Dept d JOIN d.employees e \"  + \" WHERE d.name LIKE :likeName\"; 抓取连接查询  fetch 抓取：是指从数据库加载一个对象数据时，同时把它所关联的对象和集合的数据一起加载出来，以便减少SQL语句的数据，从而提高查询效率。 From Dept d leftjoin Fetch d.employees e where d.name like “%web%” 子查询 From Dept dwhere (Select count(e) from d.employees e)>1   •       命名查询：是指将SQL查询语句编写在映射文件里，在程序中通过Session的getNameQuery()方法来获取该查询语句。 <queryname=\"findDeptsByCondition\">      <![CDATA [from Dept d where d.name like:likeName ]]> <\/query> session.getNamedQuery(\"findDeptsByCondition\")      .setString(\"likeName\",\"%a%\")      .list();  ","title":"Hibernate数据查询"},{"content":"工作流审批平台-审批流程-指定审批部门","title":"工作流审批平台-审批流程-指定审批部门"},{"content":"以下很多内容都来自GOF的设计模式，我仅仅根据自己的理解进行了简化，方便大家的同时也便于后期的回忆 目的： 状态模式一般是用在一个可能会有多个状态的对象中。当此对象的内部状态改变的时候，它的行为也会改变。对象看起来似乎是修改了它的类。 动机： 考虑一个简单的tcp连接的对象TCPConnection,它可能会处于连接开启，连接关闭，连接建立三种状态。当一个TCPConnection对象收到其他对象的请求的时候，它根据自己当前的状态进行不同的反映。但是我总感觉这个不好理解，后面举的另一个例子我感觉不错，例如我们打开了一个pdf文档，当选择“手型工具”的时候，拖拽鼠标的时候，屏幕会跟着移动，当选择“选择工具”的时候，拖拽鼠标，会进行屏幕中文字的选择，当选择“高亮工具”的时候，拖拽鼠标，会对选择的文本进行高亮。针对选择的不同工具，我们可以认为其当前处于不同的状态，即处于不同的状态的时候，相同的鼠标拖拽操作会呈现不同的行为。 类图： 从上文的类图中可以看出，DrawController类作为客户类，它在调用MousePressed方法的时候，实际上调用的是currentTool的HandleMousePress方法，至于currentTool指的具体是哪个工具，可以通过给DrawController加一个方法SetTool来设定相应的工具。当用户点击“选择工具”按钮，就会调用DrawController的SetTool(new SelectionTool)方法，来设置currentTool属性。 再次强调： 当客户对象处于不同的状态，会改变相应操作的具体行为，如上图，客户选择了不同的工具，调用相同的MousePressed方法，却做了不同的事情。依据状态模式，将一个个的状态封装成具体的对象，如上面类图中的三个具体工具，同时继承一个抽象类。抽象类负责提供虚接口。 代码简单实现： Head文件 #ifndef __PATTERN_STATE_H#define __PATTERN_STATE_H#include <stdio.h>#define LogPattern(fmt, ...) printf(\"[%4d %10s]\" fmt\"\\n\", __LINE__, __FUNCTION__, ##__VA_ARGS__ )//基类工具，默认空实现class GraphicTool{public:virtual void HandleMousePressed(){}protected:private:};//绘图控制器，根据不同的工具，控制鼠标的行为class DrawController{public:DrawController():m_pCurTool(0){}~DrawController(){}void MousePressed(){if(m_pCurTool)m_pCurTool->HandleMousePressed();}void SetTool(GraphicTool* tool);void Initialise();protected:private:GraphicTool* m_pCurTool;};//如果工具没有内部状态，可以设置其为单例模式，这样settool就不用频繁的new，delete了。//高亮工具class HighLightTool : public GraphicTool{public:void HandleMousePressed();protected:private:};//选择工具class SelectionTool : public GraphicTool{public:void HandleMousePressed();protected:private:};//文本工具class TextTool : public GraphicTool{public:void HandleMousePressed();protected:private:};#endif Cpp文件 #include \"PatternState.h\"//初始化，设置默认工具.工具可以设置为单例模式void DrawController::Initialise(){SetTool(new TextTool());}void DrawController::SetTool(GraphicTool* tool){if (m_pCurTool){delete m_pCurTool;}m_pCurTool = tool;}void HighLightTool::HandleMousePressed(){LogPattern(\"\\n\");}void TextTool::HandleMousePressed(){LogPattern(\"\\n\");}void SelectionTool::HandleMousePressed(){LogPattern(\"\\n\");} main文件的使用 void main(){DrawController draw;draw.Initialise();draw.MousePressed();draw.SetTool(new SelectionTool);draw.MousePressed();draw.SetTool(new HighLightTool);draw.MousePressed();} 截屏输出结果： 可以很清楚的看到，首先通过Initialise设置默认的工具为TextTool，然后调用MousePressed，实际上调用的为TextTool::HandleMousePressed 当通过draw.SetTool(new SelectionTool);设置工具为SelectionTool，再次调用MousePressed，实际上调用的为SelectionTool::HandleMousePressed 好的思想： 扩展：从上面可以看出，状态模式非常适合于扩展新的状态，只需要继承基类，实现对应的方法即可。 切换：关于状态的切换，上面的是在外部进行切换的，通过设置不同的工具来实现。事实上，还可以在状态类的内部实现。例如现在我想实现当用户选择了SelectionTool，选择之后立刻回到默认的TextTool，我们可以在客户调用MousePressed方法的时候，将客户类传入进去(即DrawController),在HandleMousePressed的末尾，调用controller->SetTool(new TextToll);即可以恢复到默认的TextTool。这样就实现了一种状态切换在内部实现的机制。 实现：关于状态类的实现，如果状态之间切换非常频繁，那么状态类可以使用单例模式，这样仅仅在第一次创建，省去了很多的new delete开销，相应的内存开销就稍微大了一点。具体应用场景需要具体分析。","title":"状态模式"},{"content":"视频地址：“http://v.youku.com/v_show/id_XNDkzMjIwOTIw.html” “Power by ASUS WL-500gp V1无线路由器 + OpenWrt (kernel 2.6) + mjpg-streamer视频服务器; Arduino UNO R3; 以太网控制器W5100+Micro SD card Shield;Motor Drive Shield (L293D电机驱动)” 这个视频是由国外朋友设计的“WiFi Camera Robot”。方案简介如上所示，用Motor L293D电机驱动来控制电机的正反转等；mjpg-streamer用作视频服务器，提取摄像头数据，再配合OpenWrt作为远程摄像方案。整个系统也用到了WIZnet W5100以太网芯片，作为Arduino Uno的网络接入，在经过简单配置，就能实现网络接入，在远端进行相应控制操作。整个系统配合WL-500gp无线路由器连接电脑，在PC端上就能进行相应的小车控制和摄像监测。 从视频中我们看到在PC端采集的视频图像虽然有一定时间的延迟，但总体上还算流畅。 系统使用了OpenWrt+mjpg-streamer作为远程摄像方案。还有Arduino配合W5100接入网络，在网络远端进行相应控制。 相信很多朋友也有过做无线摄像小车的经历和心得,肯定有更好的方案。大家也可以分享自己方案经验供大家交流讨论~何乐不为？^_^","title":"【视频：Arduino_OpenWRT无线摄像小车】"},{"content":"中国古代有句成语，叫做“百炼成钢”。其意是人必须经过千锤百炼，才能有所作为。然而，这一成语的最初起源于我国古代的一种特殊的炼钢工艺——“百炼钢”，语出汉代应劭《汉官仪》：“今取坚钢百炼而不耗”。     唐代齐己在《古剑歌》中写道：“古人手中铸神物，百炼百淬始提出”。早在春秋战国时期，我国就出现了许多炼剑名家。如吴国的干将、莫邪，就是一对著名的铸剑夫妇。他们用最优质的钢铁、精湛的技艺及勇敢无畏的精神铸造了两把以他们名字命名的锋利无比的宝剑，受到了后人的称颂。到了东汉时期，才出现了用“百炼钢”工艺炼制的标以“炼数”的剑。1974年，在山东苍山县汉代安帝永初六年（公元112年）的“三十湅”（湅和炼字字义相同）的环首钢刀，其上的 “宜子孙”三字锈蚀不清，是在X射线的照射下辨读出来的。1978年，在徐州铜山县一座小型汉代砖石墓中，发现了一把汉代建初二年（公元77年）的“五十湅”的钢剑，剑长109厘米，宽1.1~3.1厘米，脊厚0.3~0.8厘米，为蜀郡西工官所造。这说明至少在东汉前期，用炒钢以及以此为原料的“百炼钢”工艺已经相当普遍地被使用了。     钢和铁都是铁和碳的合金，纯铁和钢都是由生铁炼成，铁和钢的区别在于含碳量的不同，从而引起性能的变化。生铁含碳量最多，超过2.1%，较脆；其次是碳钢，含碳0.06～2.1%，硬度韧性较好；纯铁含碳量在0.06%以下，比较韧。那么什么叫“百炼钢”，“百炼钢”的工艺过程又如何呢？简单说来，“百炼钢”就是以炒钢为原料进行反复加热锻打，少则三五十次，多则百余次，其目的是满足制作优质兵器等物件所用特殊钢的需求。北宋苏颂在《本草图经》中说，生铁再三销拍，可作  （ye，金属薄片）者为  （xu）铁，亦称之为熟铁。“销”指入火炒炼，拍指拿出炉后锻打。反复加热锻打过程，引起了一系列物理化学变化，提高了金属材料质量，改善了钢铁的性能。其具体作用有以下几方面：一是使物质成份分布更加均匀。因为锻打次数越多，就产生较强的机械搅拌作用，碳粒分布就越均匀。二是在多次锻打中，杂质被逐步排除。三是使结构更加紧密。锻打过程减少了其中的空隙，同时起到了细化晶粒的作用。正是百炼过程，锻件硬度和韧性增强，使铁变成了一种优质碳素钢。晋代刘琨曾写到：“何意百炼钢，化为绕指柔”，说明“百炼钢”既有硬度，又有韧性。科技人员曾对山东省苍山县出土的永初“卅湅大刀”、徐州铜山县出土的建初“五十湅”剑进行了科学分析，得知其原料均是含碳量稍高的一种炒钢。“卅湅刀”刃部含碳量为0.6～0.7%，组织均匀，珠光体很细，曾经淬火，可看到少量的马氏体（纯金属或合金从某一固相转变曾另一固相时的产物。转变过程中，主要是晶体结构发生变化。钢中的马氏体在显微镜下多呈针状）。“五十湅”剑刃部含碳量分层，中心稍高，约0.7%；两边稍低，低达0.4%，晶粒较细。在金相显微镜下，它们的夹杂总量都较少，数目较多，细薄分散，变形量大，说明在“卅湅”、“五十湅”过程中，材料曾多次被加热锻打，经受过较大的加工变形。     百炼钢工艺一直延续后世。历史上有许多“削铁如泥”的宝剑的记载。三国时曹操曾命“有司”作“百炼”利器5枚。晋代崔豹在《古今注.舆服》中记载，吴大帝有宝刀三：“一曰百炼，二曰青犊，三曰漏景。”北宋的科学家沈括在《梦溪笔谈》中谈到了当时北方最大的冶炼中心之一磁州锻坊炼制百炼钢的情况：“……取精铁锻之百余火……此铁之精纯者，其色清明，磨莹之，则黯然青且黑，与常铁迥异。”周去非在《岭外代答》中记载广西少数民族以“三十炼”的钢刀为上品，佩带在身上。南宋的曾敏行在《独醒杂志》中谈到湘西瑶人中曾看到一种“黄钢刀”，锋利无比，“一挥能断牛腰，乃百炼而成。”明代的宋应星在《天工开物》中也谈到“百炼钢”用在制作精美的刀刃上。可见百炼钢对后人的影响极大。     我国进入铁器时代约在公元前1400多年前的商代，远早于“百炼钢”出现的时间。1972年，在河北藁城台西村商代墓室中出土了一件铁刃铜钺（yue,古代兵器，形如板斧而较大）。1977年，在北京平谷县刘家河村商代晚期墓中也发现了一件铁刃铜钺。经技术鉴定，这两件器物的铁刃部分均系从宇宙中降落在地球上的陨铁加热锻成。到了春秋战国时期，我国的冶铁技术出现了三项重大发展。首先是生铁冶铸技术，它能从矿石中大量地省力地提炼生铁，为铸造各种铁器打下了基础。如公元前513年晋国铸造了一个铁质刑鼎，就是用生铁铸造的。其次是出现了含碳量在0.5～0.6%的中碳钢，提供了比铁更硬、锐利的原料。第三是创造了铸铁柔化技术。它通过对退火温度和退火时间的控制这一“热处理脱碳技术”，增强了铸铁的强度和韧性，使生铁广泛用作生产工具成为可能，加快了铁器取代青铜器等生产工具的历史进程。到了南北朝时期，我国已有了“灌钢法”，方法是将溶化了生铁灌到纯铁中去，使纯铁中的含碳量增加而变成钢。     对古代钢铁文物的检测，由于钢铁容易氧化，出土时有很厚的锈蚀层，再加上钢铁材料因冶炼产生的内部不均匀性，分析鉴定比青铜文物困难得多。科技人员通过金相显微检验可获得文物中铁碳合金相的内部构造面貌以及古代渗碳、淬火、回火、锻打、表面处理等工艺信息。如陨铁中镍密度在5～8%左右，而人工冶炼的铁中镍的密度仅含约0.1%。正是通过对含镍量的鉴定，专家们从而得出了商代的铁刃铜钺中的铁刃部分是陨铁加工而成的结论。     今天，人们不必经过炼铁这一步，可以直接由矿石炼成钢。世界上已取得成功的“一步炼钢法”就有几百种。如“等离子体炼钢”用氢气和天然气作燃料，可将矿石直接炼成钢。为避免重力作用及其它作用的影响，目前一些发达国家还进行了数十次“天外炼钢”的实验，炼出的钢和合金，多用于航天及其它特殊要求的设备上。","title":"“百炼成钢”的科技内蕴"},{"content":"package com.hbsi.test;import java.util.HashSet;import java.util.List;import java.util.Set;import org.hibernate.Query;import org.hibernate.Session;import org.junit.Test;import com.hbsi.one2manyboth.DepartRow;import com.hbsi.one2manyboth.Department;import com.hbsi.one2manyboth.Employment;import com.hbsi.utils.Hibernate;public class AppHql {\t@Test\tpublic void find(){\t\tSession session=Hibernate.getSession();\t\tsession.beginTransaction();\t\t\t\t//简单查询\t\t/*Query query=session.createQuery(\"from Department\");\t\tList<Department> list=query.list();\t\tfor(Department d:list){\t\t\tSystem.out.println(d.getId()+\":\"+d.getName());\t\t}*/\t\t\t\t//列出单个结果\t\t/*String hql=\"from Department where id>1\";\t\tQuery query=session.createQuery(hql);\t\tquery.setMaxResults(1);\t\tDepartment dept=(Department) query.uniqueResult();\t\tSystem.out.println(dept.getName());*/\t\t\t\t//投影查询,查看部分属性,list中存放的元素是object[]数组,不方便，最好少用\t\t/*String hql=\"select id,name from Department\";\t\tQuery query=session.createQuery(hql);\t\tList list=query.list();\t\tfor(int i=0;i<list.size();i++){\t\t\tObject[] obj=(Object[]) list.get(i);\t\t\tSystem.out.println(\"id=\"+obj[0]);\t\t\tSystem.out.println(\"name\"+obj[1]);\t\t\tSystem.out.println(\"------------\");\t\t}*/\t\t\t\t//通过一个类来封装查询结果\t\t/*String hql=\"select new com.hbsi.one2manyboth.DepartRow(d.id,d.name) from Department d\";\t\tQuery query=session.createQuery(hql);\t\tList<DepartRow> list=query.list();\t\tfor(DepartRow d:list){\t\t\tSystem.out.println(d.getId()+\":\"+d.getName());\t\t}*/\t\t\t\t//查询一列\t\t/*String hql=\"select name from Department\";\t\tQuery query=session.createQuery(hql);\t\tList<String> list=query.list();\t\tfor(String s:list){\t\t\tSystem.out.println(s);\t\t}*/\t\t\t\t//查询包含员工的部门\t\t/*String hql=\"from Department d where d.emps is not empty\";\t\tQuery query=session.createQuery(hql);\t\tList<Department> list=query.list();\t\tfor(Department d:list){\t\t\tSystem.out.println(d.getName());\t\t\tfor(Employment e:d.getEmps()){\t\t\t\tSystem.out.println(\"|\"+e.getName());\t\t\t}\t\t}*/\t\t\t\t//绑定查询的参数:? 的下标是从0开始\t\t/*String hql=\"from Department d where d.id>? and d.name=?\";\t\tQuery query=session.createQuery(hql);\t\tquery.setInteger(0,1);\t\tquery.setString(1,\"软件系\");\t\tList<Department> list=query.list();\t\tfor(Department d:list){\t\t\tSystem.out.println(d.getName());\t\t}*/\t\t\t\t/*String hql=\"from Department d where d.id>:ids and d.name=:name\";\t\tList<Department> list=session.createQuery(hql).setInteger(\"ids\",1).setString(\"name\",\"软件系\").list();\t\tfor(Department d:list){\t\t\tSystem.out.println(d.getName());\t\t}*/\t\t\t\t//统计一下部门数\t\t/*String hql=\"select count(id) from Department\";\t\tQuery query=session.createQuery(hql);\t\tLong l=(Long) query.uniqueResult();\t\tSystem.out.println(l);*/\t\t\t\t/*String hql=\"select e.dept.name,count(e.id) from Employment e group by e.dept having count(e.id)>1\";\t\tQuery query=session.createQuery(hql);\t\tList list=query.list();\t\tfor(int i=0;i<list.size();i++){\t\t\tObject[] obj=(Object[]) list.get(i);\t\t\tSystem.out.println(obj[0]+\"-----\");\t\t\tSystem.out.println(obj[1]);\t\t}*/\t\t\t\t\t\t/*Employment emp=(Employment) session.get(Employment.class,1);\t\tString hql=\"delete Employment where id=1\";\t\tQuery query=session.createQuery(hql);\t\tquery.executeUpdate();*/\t\t\t\t//inner join\t\t/*String hql=\"from Department d join d.emps where d.name like:likename\";\t\tQuery query=session.createQuery(hql).setString(\"likename\",\"%数媒%\");\t\tList list=query.list();\t\tfor(int i=0;i<list.size();i++){\t\t\tObject[] obj=(Object[])list.get(i);\t\t\tDepartment dept=(Department) obj[0];\t\t\tEmployment emp=(Employment) obj[1];\t\t\tSystem.out.println(dept.getName());\t\t\tSystem.out.println(emp.getName());\t\t}*/\t\t\t\t//left join\t\t/*String hql=\"from Department d left join d.emps\";\t\tQuery query=session.createQuery(hql);\t\tList list=query.list();\t\tfor(int i=0;i<list.size();i++){\t\t\tObject[] obj=(Object[])list.get(i);\t\t\tDepartment dept=(Department) obj[0];\t\t\tEmployment emp=(Employment) obj[1];\t\t\tSystem.out.println(dept.getName());\t\t\t//System.out.println(emp.getName());\t\t}*/\t\t\t\t\t\t//抓取fetch\t\tString hql=\"from Department d left join fetch d.emps\";\t\tQuery query=session.createQuery(hql);\t\tList<Department> list=query.list();\t\tSet<Department> set=new HashSet<Department>(list);\t\tfor(Department d:set){\t\t\tSystem.out.println(d.getName());\t\t\tfor(Employment e:d.getEmps()){\t\t\t\tSystem.out.println(e.getName());\t\t\t}\t\t}\t\t\t\t\t\tsession.getTransaction().commit();\t\tsession.close();\t}\t\t@Test\tpublic void findEmployment(){\t\tList<Employment> emps=findEmployment(2,2);\t\tfor(Employment emp:emps){\t\t\tSystem.out.println(emp.getId()+\":\"+emp.getName());\t\t}\t}\t\t\tpublic List<Employment> findEmployment(int pageNo,int pageSize){\t\tSession session=Hibernate.getSession();\t\tsession.beginTransaction();\t\t\t\tString hql=\"from Employment\";\t\tQuery query=session.createQuery(hql);\t\tquery.setFirstResult((pageNo-1)*pageSize);\t\tquery.setMaxResults(pageSize);\t\tList<Employment> list=query.list();\t\t\t\tsession.getTransaction().commit();\t\tsession.close();\t\t\t\treturn list;\t}}","title":"HQL语句"},{"content":"引言 因为要在内网搭建模拟测试环境，所以这里记录一下吧，以后也方便.所谓的LNMP即ubuntu + nginx + mysql + php的标配，其中nginx + fpm取代了apche + mod_php ssh服务器设置 修改端口号，防止被轻易攻击 Port  **** 禁止root用户登陆 PermitRootLogin no 只允许公私钥认证的方式登陆，防止口令暴力破解 RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile      %h/.ssh/authorized_keysPasswordAuthentication no 修改密钥长度 ServerKeyBits 2048 修改语言环境变量 1.修改local配置文件 sudo vim /etc/default/localeLANG=zh_CN.UTF-8LANGUAGE=zh_CN:en_US:enLC_CTYPE=\"zh_CN.UTF-8\"LC_NUMERIC=zh_CN.UTF-8LC_TIME=zh_CN.UTF-8LC_COLLATE=\"zh_CN.UTF-8\"LC_MONETARY=zh_CN.UTF-8LC_MESSAGES=\"zh_CN.UTF-8\"LC_PAPER=zh_CN.UTF-8LC_NAME=zh_CN.UTF-8LC_ADDRESS=zh_CN.UTF-8LC_TELEPHONE=zh_CN.UTF-8LC_MEASUREMENT=zh_CN.UTF-8LC_IDENTIFICATION=zh_CN.UTF-8LC_ALL= 2.导入修改后配置 source /etc/default/locale 安装php&&php扩展 预安装软件 apt-get install make gcc g++ automake libtool libmysqlclient18 libxml2-dev libexpat1-dev mysql-client php5 1.安装php和fpm sudo apt-get install php5 php5-fpm 2.安装memcache扩展 sudo apt-get install php5-memcache php5-memcached 3.安装mysql扩展 sudo apt-get install php5-mysql 4.安装http扩展 sudo apt-get install libcurl4-openssl-devsudo apt-get install libmagic-devsudo pecl install pecl_http 具体使用见之前文章 5.安装oauth扩展 sudo apt-get install libpcre3-dev(需要perl-compatible regular expression library)sudo pecl install oauth 6.安装gd扩展 sudo apt-get install php5-gd 7.安装redis扩展 安装phpredis扩展，点击打开链接 rsync+shell部署文件和目录 来一个部署的脚本吧，大家可以参考一下里面的思想，主要是灾备 #!/bin/bash - #1.参数配置sour_dir=\"/home/wangzhengyi\"file_name=\"test1\"datetime=`date -d '+0 days' +%Y-%m-%d-%H-%I`dest_dir=\"/srv/www/test2\"back_dir=\"/tmp\"if [ ! -d $dest_dir ];then   mkdir -p $dest_dir   chown -R www-data.www-data $dest_dirfi #2.备份源目录if [ -d $dest_dir/$file_name ]then\tcp -r  $dest_dir/$file_name $back_dir/$file_name$datetimefi#3.更新目录  rsync -rvz --delete $sour_dir/$file_name/ $dest_dir/$file_name/if [ $? = 0 ]then\tchown -R www-data.www-data $dest_dir/$file_namefi 搭建nginx虚拟主机 共享一下我的nginx.conf配置 user www-data;worker_processes 4;worker_cpu_affinity 0001 0010 0100 1000;worker_rlimit_nofile 204800;pid /var/run/nginx.pid;events {\tuse epoll;\tworker_connections 768;\t# multi_accept on;}http {\tinclude       /etc/nginx/mime.types;    \tdefault_type  application/octet-stream;\tcharset  utf-8;\tserver_names_hash_bucket_size 128;\tclient_header_buffer_size 2k;\tlarge_client_header_buffers 4 4k;\tclient_max_body_size 8m;    \tlog_format  main  '$server_name\u0001$remote_addr\u0001$remote_user[$time_local]\u0001\"$request\"\u0001'                      '$status\u0001$body_bytes_sent\u0001\"$http_referer\"\u0001'                      '\"$http_user_agent\"\u0001\"$http_x_forwarded_for\"';    \taccess_log  /var/log/nginx/access.log  main;\terror_log /var/log/nginx/error.log;    \tsendfile        on;    \ttcp_nopush     on;    \tkeepalive_timeout  60;    \topen_file_cache max=204800 inactive=20s;    \topen_file_cache_min_uses 1;    \topen_file_cache_valid 30s;    \ttcp_nodelay on;    \tgzip  on;    \tinclude /etc/nginx/conf.d/*.conf;} 根据需要搭建虚拟主机 这里由于隐私大家网上搜一下就行，而且我之前有文章写过搭建nginx+fpm虚拟主机的方法 修改/etc/hosts文件 修改/etc/hosts文件，保持通信双方的相同测试环境，具体见链接http://blog.csdn.net/zinss26914/article/details/8442853 部署nginx&&fpm按天分割脚本 http://blog.csdn.net/zinss26914/article/details/8256144，之前写的一篇博客，crontab定时运行即可 部署nginx定期迁移脚本 http://blog.csdn.net/zinss26914/article/details/8425838,crontab定期运行即可，程序里判断每两周执行一次 搭建mysql 安装mysql sudo apt-get install  mysql-server 配置mysql默认编码 http://blog.csdn.net/zinss26914/article/details/8035902 mysql远程连接 修改bind-address = server_ip 授权远程访问 grant all privileges on  *.* to 'user'@'remote_ip'  identified by 'password'; 刷新权限使生效 flush privileges 共享mysql导出指定数据库上传到指定服务器的脚本 #!/bin/bash - #1.数据库备份参数配置mysqlhost=\"your_mysql_ip\"mysqluser=\"****\"mysqlpasswd=\"****\"mysqldb=\"db_name\"tablenames=(\"table_name1\")dbtime=`date -d '+0 days' +%Y%m%d`export_directory=\"/home/user/sql/$dbtime\"remote_dir=\"/home/user/sql/back/\"ip_array=(\"192.168.1.***\")#定义数据备份目录if [ ! -d $export_directory ]then\tmkdir -p $export_directoryficd $export_directory#2.mysqldump备份数据库数据for tablename in ${tablenames[*]}do\t#定义数据备份文件名\tdbfile=\"$tablename-$dbtime.sql\"\t#导出mysql数据\tmysqldump -h$mysqlhost -u$mysqluser -p$mysqlpasswd $mysqldb $tablename >$dbfile\t#采用tar压缩备份存储的sql文件\ttar -zcPpf $tablename-$dbtime.tar.gz  $dbfile\t#删除大容量文件\tif [ $? = 0 ]\tthen\t\trm $dbfile\tfi\t#同步数据库备份到指定服务器\tfor ip in ${ip_array[*]}\tdo\t\tport=\"your_port\"\t\tscp -P $port $tablename-$dbtime.tar.gz username@$ip:$remote_dir\tdonedone 搭建redis ubuntu的ppa源同步redis版本与线上服务器保持一直，否则不能兼容rdb文件 增加redis数据库连接密码 修改bind的ip地址，允许远程访问 搭建coreseek全文搜索引擎 参考官方文档搭建即可，http://www.coreseek.cn/products-install/install_on_macosx/","title":"LNMP环境的搭建"},{"content":"一、了解抽象工厂设计模式 书上说：提供一个创建一系列相关或相互依赖对象的接口，而无需制定他们具体的类。   二、看类图 解说员：图上分两部分来看，一部分是左边的IFactory家族，另一部分是右边的IProduct 家族。   1、先看IProduct家族。   第一层：客户需求。可以看出我们需要哪些产品，由客户端决定，我们需要提前设计好第二层的产品。   第二层：ProductA和ProductB，这一系列的产品，具体要根据实际情况来确定。 第二层要说明的是：这个具体的产品的属性是不变的，而我们要对这个产品进行的各种操作是变化的，为了符合开放——封闭，和封装原则，在修改方法的时候不必影响到属性，我们把这个产品类分成了两部分，一部分是具体的名词类，不包含任何方法，只有该类的属性；另一部分是抽象接口：定义对该类的操作方法。这样我们就可以单独的对一个类的属性或者是方法进行分别操作，而互不影响，做到面向对象的封装。他们之间是依赖关系，接口依赖具体类。这个内部关系，在上图中没有变现出来。 也就是说，第三层实现的是第二层的接口方法，访问和操作的是第二层的具体类。   第三层：A1，A2，则是具体的实现类了。他们是ProductA 的具体实现过程。可能实现有多种，SO，具体的实现类也要多个，当然也需要一个统一的接口来统一管理。这里的接口就设在了第二层，有力第二层的接口，我们就可以在三层进行扩展，这也是一个封装。   体现的原则 开放——封闭原则：对扩展开放，对修改封闭。 在这个三层图上，有两个接口，也就是有两个地方可能发生变化，一个是数据库的选择，一个是访问数据库表的选择。   依赖倒转原则：抽象工厂的设计是由上自下逐步抽象的，且是针对接口编程，在最后一层才开始考虑具体的实现，提高了代码的复用，分别体现了：高层模块不依赖低层模块；抽象不依赖细节。   单一原则：第三层的每个类都是对单一功能的实现，对一个数据库表进行访问。     举例说明：用户需要访问数据库，那第二层就是数据库表，这些是哪个数据库都具备的；从第一层到二层扩展为了将来对更多或者其他数据库表的访问；现在我们要访问用户表，或许以后，我们还需要访问公司部门表，或者公司财务表；第三层应该考虑数据库的具体访问，操作实现，可扩展的子类有SQL server，Access 或者oracle。这些都是不同的实现过称，但同属于实现这一级别。可能现在用的是access，将来用SQL server，或者是Oracle,所以我们在要第二层为什么准备了接口，以备第三层的多种实现。       2、看IFactory家族。   此处工厂不是具体的制造产品的工厂，只是一个中介所。为什么这么说？   第一层：定义了一个创建一系列相关或相互依赖对象的接口。 例如我们需要访问的多个数据库表都在其中定义。这也是区别于工厂模式的一点。工厂模式针对的是一类，而抽象工厂针对的是一系列产品。   第二层：具体实现访问方法，他们根据客户端实例化的对象，帮助用户找到Iproduct 家族中第三层的地址，达到实现的目的。  练手：对SQL server和ACCESS两种数据库中的用户表和部门表进行访问。 //定义用户表类——定义了用户表的属性        class User        {            private int id;            public int ID            {                get { return id; }                set { id = value; }            }            private string name;            public string Name            {                get { return name; }                set { name = value; }            }        }        //定义数据库用户表接口——定义了对用户表的进行的操作        interface IUser        {            void Insert(User user);            User GetUser(int id);        }        //定义SQL数据库表        class SqlserverUser:IUser        {            public void Insert(User user)            {                Console.WriteLine(\"在SQL 中增加一条用户记录\");            }            public User GetUser(int id)            {                Console.WriteLine(\"在SQL 中根据ID得到一条用户记录\");                return null;            }        }        //定义Access数据库表        class AccessUser : IUser        {            public void Insert(User user)            {                Console.WriteLine(\"在Access 中增加一条用户记录\");            }            public User GetUser(int id)            {                Console.WriteLine(\"在Access 中根据ID得到一条用户记录\");                return null;            }        }         //定义数据库部门表——属性        class Department        {            private int id;            public int ID            {                get { return id; }                set { id = value; }            }            private string dname;            public string DName            {                get { return dname; }                set { dname = value; }            }        }        //定义操作部门的接口——操作        interface IDepartmnet        {            void Insert(Department department);            Department GetDepartment(int id);        }        //定义用于访问部门的SQL 实现        class SQLdepartment:IDepartmnet         {            public void Insert(Department department)            {                Console.WriteLine(\"在SQL 中插入一条记录！\");            }            public Department GetDepartment(int id)            {                Console.WriteLine(\"根据ID 号取出部门！\");                return null;            }        }         //定义用于访问部门的Access 实现        class Accessdepartment : IDepartmnet        {            public void Insert(Department department)            {                Console.WriteLine(\"在SQL 中插入一条记录！\");            }            public Department GetDepartment(int id)            {                Console.WriteLine(\"根据ID 号取出部门！\");                return null;            }        }          //定义访问数据库表的工厂接口        interface IFactory        {            IUser CreateUser();            IDepartmnet CreatDepartment();        }         //实例化SQL 工厂接口        class SqlFactory : IFactory        {            public IUser CreateUser()            {                return new SqlserverUser();            }            public IDepartmnet CreatDepartment()            {                return new SQLdepartment();            }        }        //实例化Access工厂接口        class AccessFactory : IFactory        {            public IUser CreateUser()            {                return new AccessUser();            }            public IDepartmnet CreatDepartment()            {                return new Accessdepartment();            }        }                      static void Main(string[] args)        {            User user = new User();            Department department = new Department();             IFactory factory = new SqlFactory();                 IUser iu = factory.CreateUser();            iu.Insert(user);            iu.GetUser(2);//任意的int类型的都可以             IFactory factory1 = new  AccessFactory();            IUser au = factory1.CreateUser();            au.Insert(user);            au.GetUser(2);//任意的int类型的都可以             IFactory factoryd = new SqlFactory();            IDepartmnet id=factoryd .CreatDepartment ();            id.Insert (department );            id.GetDepartment (1);             IFactory factorya = new AccessFactory();            IDepartmnet ad=factoryd .CreatDepartment ();            ad.Insert (department );            ad.GetDepartment (1);             //IUser au = new AccessUser();             //au.Insert(user);            //au.GetUser(2);//任意的int类型的都可以            Console.Read();        }    ","title":"抽象工厂——创建型设计模式一"},{"content":"在开发一些窗口层次比复杂的cocos2d项目时，会发现一些由于没有窗口层次而引起的bug。这些bug让一些从windows平台过来的人觉得很无奈。比如，我们有一个列表控件，我们在其中放了一些菜单，当我们滑动列表控件使菜单选项（称为A）滑出列表控件的可视范围时，按理我们是无法再点击到A的，因为它滚动出了父控件可视范围，不被用户所看到。但是cocos2d的默认情况是能点击到的，这是因为cocos2d的消息管理是优先级消息机制，只要控件登记接收消息，那么cocos2d会一如既往的发给他。所以我们刚才讲的情形在cocos2d看来，它无法根据A被遮挡而不给A发消息。究其根本，是没有一个层级窗口消息机制（当然你能通过其他的方法帮助cocos2d，但我个人觉得有点不够彻底）。 我想建立一个相对完整cocos2d的的层级窗口消息机制，且不改变cocos2d任何源码（因为改变源码的话，不知道以后升级起来是不是很麻烦）。基本思路有如下几条： 在任何一个场景中，我们会有一个最底层的Layer（我称为祖层），这个Layer将接受cocos2d的触摸消息。并且这个Layer能将触摸消息传递给其所有的子控件。 一个场景中除了祖层之外，所有其他的控件都将不接受任何触摸消息，其触摸消息的来源于父控件。当然任何非叶子控件都会将其触摸消息传递给其子控件。 控件将消息传递给子控件时，如果子控件消息处理函数返回真，则记录该子控件，以方便将后续消息传递给这个子控件。 尽可能兼容已知和未知的cocos2d控件库，这样在这个机制类我们会有更多好用的子控件。 提供模式和非模式两种窗口模式。就像我们在用windows时，点新建文件，会弹出一个模式窗口，不关闭它，我们无法和其他窗口交互。 下面看一下类的组织架构图: 我们分别说一下各个类的大体作用： wmTouchDelegate并非继承于ccTouchDelegate或其他类（但消息处理函数名同ccTouchDelegate一样）。它是一个消息传播大使，所有继承于该类的类都能自动地将消息传播到所有的子控件。不继承于ccTouchDelegate主要出于设计原则中避免多重继承中的基类重复。 wmLayer继承于wmTouchDelegate和CCLayer(图中未指出），负责将消息处理函数转接到wmTouchDelegate的消息处理函数，这是因为wmTouchDelegate的消息处理函数同ccTouchDelegate是一样的，而CCLayer已经继承了ccTouchDelegate，这样如果不显示的转接处理函数，C++编译器会提示有两个版本选择的错误。 wmLayerAncestor继承于wmLayer，这样它已经具备了消息转发的功能。同时它接受触摸消息。并注册了优先级为0且吞并消息的touch target。这样它将是上面提到的祖层，一个Scene中只有一个祖层。 wmLayerDescendant继承于wmLayer，这样它已经具备了消息转发功能，同时它屏蔽了消息触摸消息。一个scene中多数层都应该是继承与wmLayerDescendant的。 wmLayerModal继承于wmLayerAncestor，所以它接受触摸消息，为了达到模式窗口的功能（程序中当有模式窗口时，只有最顶层的模式窗口能接受到消息，其他层都屏蔽），我们将wmLayerModal注册为优先级-128且吞并消息的窗口。 通过这个类层次，我实现了在cocos2d-x 2.0.4中的CCTableView中放多层元素，且元素滚动出View可视范围无法点中的功能，且点击中菜单时，TableView依旧能滚动的功能（因为原来的CCTableView中放CCMenu的话，一旦点击中菜单，就无法拖动TableView了，因为CCMenu把消息吞了）。且可与CCControl等cocos控件一同使用。 下面来看源码： wmTouchDelegate: wmTouchDelegate.h ////  Created by jason on 12-12-25.////#ifndef __TableTest__wmTouchDelegate__#define __TableTest__wmTouchDelegate__#include <iostream>#include \"cocos2d.h\"USING_NS_CC;#define WM_TOUCH_DELEGATE_OWNER_CONSTRUCTOR_IN_HEAD_FILE( ownerClassName ) \\ownerClassName() : wmTouchDelegate( this ){}#define WM_TOUCH_DELEGATE_IMPLEMENT_IN_HEAD_FILE()                      \\virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent)             \\{                                                                       \\    return wmTouchDelegate::ccTouchBegan( pTouch, pEvent );             \\}                                                                       \\virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent)             \\{                                                                       \\    wmTouchDelegate::ccTouchMoved( pTouch, pEvent );                    \\}                                                                       \\virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent)             \\{                                                                       \\    wmTouchDelegate::ccTouchEnded( pTouch, pEvent );                    \\}                                                                       \\virtual void ccTouchCancelled(CCTouch *pTouch, CCEvent *pEvent)         \\{                                                                       \\    wmTouchDelegate::ccTouchCancelled( pTouch, pEvent );                \\}//window message mechanism//We only change the TargetedTouch message mechansim.//Node who want standard touch message should register all by itself.class wmTouchDelegate{public:    wmTouchDelegate( CCNode* pOwner ) :    m_pOwner( pOwner ),    m_bDraging( false )    {        m_pItemsClaimTouch = CCArray::createWithCapacity( CHILD_MAX );        assert( m_pItemsClaimTouch );        m_pItemsClaimTouch->retain();    }    virtual ~wmTouchDelegate()    {        CC_SAFE_RELEASE_NULL( m_pItemsClaimTouch );    }protected:    // default implements are used to call script callback if exist    virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent);    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);    virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);    virtual void ccTouchCancelled(CCTouch *pTouch, CCEvent *pEvent);private:    //return value:    //true: pParent is touched by user    //false: pParent isn't touched by user.    bool passMessage( CCNode* pParent, CCTouch *pTouch, CCEvent *pEvent );    //if has significant touch handler.    bool hasNonTrivalTouchHandler( cocos2d::CCNode *pItem );private:    CCNode* m_pOwner;    bool m_bDraging;    //items claim touch message    CCArray* m_pItemsClaimTouch;    //store all class whose touch handler is non-trival    static const void* m_pNonTrivalTouchHandlerClasses[];};#endif /* defined(__TableTest__wmTouchDelegate__) */\t\t\t ////  wmTouchDelegate.cpp//  TableTest////  Created by jason on 12-12-25.////#include \"wmTouchDelegate.h\"#include \"cocos-ext.h\"#include \"wmControl.h\"//include wmTableView,wmMenu,wmControlUSING_NS_CC_EXT;const void* wmTouchDelegate::m_pNonTrivalTouchHandlerClasses[ ] ={    &typeid( wmTableView ),    &typeid( wmMenu ),    &typeid( wmControlButton ),};#pragma mark- input touchebool wmTouchDelegate::ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent){    //pass message to all children    return passMessage( m_pOwner, pTouch, pEvent );}void wmTouchDelegate::ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent){    //special process for menu, we won't pass ccTouchMoved message to menu. Because we think menu doesn't need ccTouchMoved message in ios device where user always want to dray layer instead menu. The fllowing block for menu will only go once.    if( false == m_bDraging )    {        for( int i = 0; i < m_pItemsClaimTouch->count(); )        {            CCLayer* pItem = ( CCLayer* )m_pItemsClaimTouch->objectAtIndex( i );            //menu items doesn't process ccTouchMove(), cancel it.            assert( NULL != pItem );                        //if it's menu            if( dynamic_cast< CCMenu* >( pItem ) )            {                pItem->ccTouchCancelled( pTouch, pEvent );                m_pItemsClaimTouch->removeObjectAtIndex( i );            }            else            {                ++i;            }        }    }        //pass ccTouchMoved message to un-CCMenu item    int iNumItemsNotMenu = m_pItemsClaimTouch->count();    for( int i = 0; i < iNumItemsNotMenu; ++i )    {        wmTouchDelegate* pItemWindowMessage = NULL;        CCLayer* pItem = NULL;                pItem = ( CCLayer* )m_pItemsClaimTouch->objectAtIndex( i );        assert( NULL != pItem );                //window message items        if( ( pItemWindowMessage = dynamic_cast< wmTouchDelegate* >( pItem ) ) )        {            pItemWindowMessage->ccTouchMoved( pTouch, pEvent );        }        else//coscos2d-x items        {            pItem->ccTouchMoved( pTouch, pEvent );        }    }        m_bDraging = true;}void wmTouchDelegate::ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent){    int iNumItems = m_pItemsClaimTouch->count();    for( int i = 0; i < iNumItems; ++i )    {        wmTouchDelegate* pItemWindowMessage = NULL;        CCLayer* pItem = NULL;                pItem = ( CCLayer* )m_pItemsClaimTouch->objectAtIndex( i );        assert( NULL != pItem );                //window message items        if( ( pItemWindowMessage = dynamic_cast< wmTouchDelegate* >( pItem ) ) )        {            pItemWindowMessage->ccTouchEnded( pTouch, pEvent );        }        else//coscos2d-x items        {            pItem->ccTouchEnded( pTouch, pEvent );        }    }        m_pItemsClaimTouch->removeAllObjects();            m_bDraging = false;}void wmTouchDelegate::ccTouchCancelled(CCTouch *pTouch, CCEvent *pEvent){    int iNumItems = m_pItemsClaimTouch->count();    for( int i = 0; i < iNumItems; ++i )    {        wmTouchDelegate* pItemWindowMessage = NULL;        CCLayer* pItem = NULL;                pItem = ( CCLayer* )m_pItemsClaimTouch->objectAtIndex( i );        assert( NULL != pItem );                //window message items        if( ( pItemWindowMessage = dynamic_cast< wmTouchDelegate* >( pItem ) ) )        {            pItemWindowMessage->ccTouchCancelled( pTouch, pEvent );        }        else//coscos2d-x items        {            pItem->ccTouchCancelled( pTouch, pEvent );        }    }        m_pItemsClaimTouch->removeAllObjects();        m_bDraging = false;}bool wmTouchDelegate::passMessage( CCNode* pParent, CCTouch *pTouch, CCEvent *pEvent ){    if( !pParent || !pParent->isVisible() )    {        return false;    }        CCPoint pt;    CCRect rcBoundingBox;        //hande message to items    int iNumChildren = 0;    CCArray* pChildren = NULL;        //if the item'size > 1, check whether use touches it. Such as TableView.    //some items doesn't get size. they are medium for maintaining some children. Such as CCTableViewCell.    if( pParent->getContentSize().width * pParent->getContentSize().height > 1.0f )    {        pt = pParent->convertTouchToNodeSpace( pTouch );        rcBoundingBox.setRect( 0, 0, pParent->getContentSize().width, pParent->getContentSize().height );                //whether hit the node        if( !rcBoundingBox.containsPoint( pt ) )        {            return false;        }    }        pChildren = pParent->getChildren();        //no children, but use touch this item, so return true.    if( !pChildren )    {        return true;    }        iNumChildren = pParent->getChildren()->count();        //pass to all children    for( int iChildIndex = 0; iChildIndex < iNumChildren; ++iChildIndex )    {        //if the item claims the touch message        bool bClaim = false;                wmTouchDelegate* pItemWindowMessage = NULL;        CCNode* pItem = NULL;                pItem = ( CCNode*  )( pChildren->objectAtIndex( iChildIndex ) );        assert( pItem );                //items derives from wmTouchDelegate        if( ( pItemWindowMessage = dynamic_cast< wmTouchDelegate* >( pItem ) ) )        {            bClaim = pItemWindowMessage->ccTouchBegan( pTouch, pEvent );        }        else//items doesn't derive from wmTouchDelegate        {                        //classes have non-trival ccTouchX() hander            if( hasNonTrivalTouchHandler( pItem ) )            {                bClaim = ( ( CCLayer* ) pItem )->ccTouchBegan( pTouch, pEvent );            }            //items who doesn't derive from wmTouchDelegate can't pass touch message to its children,            //so we have to help them to pass touch message.            passMessage( pItem, pTouch, pEvent );        }                //if this item is interested in this message, add it to array for other messages        if( bClaim )        {            m_pItemsClaimTouch->addObject( pItem );        }    }        return true;}bool wmTouchDelegate::hasNonTrivalTouchHandler( cocos2d::CCNode *pItem ){    //classes have non-trival ccTouchX() hander    const void* pItemAddress = &typeid( *pItem );    for ( int i = 0; i < sizeof( m_pNonTrivalTouchHandlerClasses ) / sizeof( void* ); ++i)    {        if( m_pNonTrivalTouchHandlerClasses[ i ] == pItemAddress )        {            return true;        }    }        return false;}\t\t\t其中比较重要的地方解释一下： 1.首先是m_bDragging是为了判断拖动用的，主要用于菜单处理，当点击了一下之后，菜单对此消息感兴趣，我们记录菜单，并传递后续消息，然后点击完之后传来的是TouchMoved消息，那么就停止菜单消息处理。 2.passMessage同ccTouchBegan一起来完成消息递归传递。passMessage还将帮助没有继承wmTouchDelegate的类（这些类的ccTouchBegan不具备消息传递功能）传递消息给其子控件。 3.hasNonTrivalTouchHandler()函数是用于判断哪些类具有重要消息处理函数的，这些类都是没有继承wmTouchDelegate，我们在帮助它把消息传递给子控件的同时，也让它调用自己的消息处理函数来完成自己的操作，这里目前只加了wmTableView,wmMenu这两个类，他们都是简单地继承ccTableView,ccMenu，并屏蔽触摸消息（因为任何加入窗口层级消息体制的控件都应该只能从父控件那里获得消息）。当然通过typeid来设计是并不好的，扩展性差，当添加一个新控件进去我们都要往这个函数中添加一个判断。但是由于我们基于不修改cocos2d源码的考虑，目前只能这么做。如果想做彻底，那么我们将会从ccNode那里开始设计。 wmLayer, wmLayerAncestor, wmLayerDescendant, wmLayerModal都在一个头文件中完成，没有cpp。因为主要功能都有wmTouchDelegate完成了，这些类只是做了简单功能和约束的的添加。 wmLayer.h ////  Created by jason on 12-12-21.////#ifndef __TableTest__WMLayer__#define __TableTest__WMLayer__#include <iostream>#include \"cocos2d.h\"#include \"wmTouchDelegate.h\"USING_NS_CC;#define WM_INIT_DEFAULT( parentClassName )              \\virtual bool init()                                     \\{                                                       \\    if( !parentClassName::init() )                      \\    {                                                   \\        return false;                                   \\    }                                                   \\                                                        \\    return true;                                        \\}#define WM_TOUCH_REGISTER_DEFAULT( iPriority )          \\virtual void registerWithTouchDispatcher( void  )       \\{                                                       \\    CCDirector::sharedDirector()->getTouchDispatcher()->addTargetedDelegate( this, iPriority, true );\\}//Users shouldn't derive from wmLayerAncestor, wmLayerDescendant, wmLayerModal instead wmLayer.//wmLayer can't be touched.//wmLayer pass message to it's all descendant.class wmLayer : public CCLayer, public wmTouchDelegate{protected:    WM_INIT_DEFAULT( CCLayer );        WM_TOUCH_DELEGATE_OWNER_CONSTRUCTOR_IN_HEAD_FILE( wmLayer );    WM_TOUCH_DELEGATE_IMPLEMENT_IN_HEAD_FILE();//staticpublic:    CREATE_FUNC( wmLayer );};//wmLayerAncestor can be touched.//all secene should have only one wmLayerAncestor for bottom layer.//all the other layer should be wmLayerDescendant.class wmLayerAncestor : public wmLayer{protected:    bool virtual init()    {        if( !wmLayer::init() )        {            return false;        }                setTouchEnabled( true );        return true;    }    WM_TOUCH_REGISTER_DEFAULT( 0 );    //staticpublic:    CREATE_FUNC( wmLayerAncestor );    //data};class wmLayerDescendant : public wmLayer{protected:    WM_INIT_DEFAULT( wmLayer );    virtual void registerWithTouchDispatcher(){};    //staticpublic:    CREATE_FUNC( wmLayerDescendant );    //data};//wmLayerModal stopes touch messages from being passed to other layers which are not it's children.//And will pass touch messages to it's children normally.class wmLayerModal : public wmLayerAncestor{protected:    WM_INIT_DEFAULT( wmLayerAncestor );    WM_TOUCH_REGISTER_DEFAULT( kCCMenuHandlerPriority );    //staticpublic:    CREATE_FUNC( wmLayerModal );        //data};#endif /* defined(__TableTest__WMLayer__) */里面通过一些宏，让我编写的更快一些。但希望没能阻碍你阅读。这里面没有太多需要说的。 整个体制是如何做到消息递归传递的呢？ 答：任何一个wmLayer对象或者派生自wmLayer的对象，将记录每个直接子控件（对象的第一层子控件），并试图沿每个直接子控件路径逐层向下记录所有非直接子控件（不是这个对象的第一层子控件），直到路径上碰到继承自wmTouchDelegate子控件，我们称它为X（也记录这个）。这个子控件X将负责记录它的所有子控件（按照上面的方法，任何一个wmLaye...）。 也正是通过这个方法，我们能让一些没有继承wmTouchDelegate的控件也能加入这个体系，其消息传递功能由离它最近的上层继承自wmTouchDelegate控件来完成。 扩展提示： 如果你想让其他控件加入这个体制，简单的方法继承这些控件并屏蔽他们接受消息，我们的体制会确保消息能传递给他们身上的所有子控件。如wmMenu,wmTableView,wmControl,代码如下： class wmTableView : public CCTableView{public:    static wmTableView* create(cocos2d::extension::CCTableViewDataSource *dataSource, cocos2d::CCSize size, CCNode *container = NULL )    {        wmTableView *table = new wmTableView();        table->initWithViewSize(size, container);        table->autorelease();        table->setDataSource(dataSource);        table->_updateContentSize();                return table;    }        void registerWithTouchDispatcher(void){}};//this menu won't get any touch message becase it doesn't register target touches.class wmMenu : public CCMenu{public:        virtual void registerWithTouchDispatcher()    {    }        static wmMenu * create(CCMenuItem* item, ...)    {        va_list args;        va_start(args,item);        wmMenu *pRet = new wmMenu();        if (pRet && pRet->initWithItems(item, args))        {            pRet->autorelease();            va_end(args);            return pRet;        }        va_end(args);        CC_SAFE_DELETE(pRet);        return NULL;    }};class wmControlButton : public CCControlButton{public:    WM_TOUCH_REGISTER_EMPTY();    static wmControlButton* create(CCNode* label, CCScale9Sprite* backgroundSprite)    {        wmControlButton *pRet = new wmControlButton();        pRet->initWithLabelAndBackgroundSprite(label, backgroundSprite);        pRet->autorelease();        return pRet;    }}; 但如果想更好的优化消息记录，应该避免一个wmLayer上面放N多层 非本体制控件（即没有继承wmTouchDelegate的控件）。可以在其中穿插一些本体制的控件，因为这些控件具有消息传递功能。如何创建本体制控件呢？ 1.第一种情况，类对象已经继承了CCLayer，且没有自己重要的消息处理函数。如CCLayerColor，我们想把它变成本体系控件，我们应该继承CCLayerColor，并继承wmTouchDelegate。然后转接消         息处理函数。如下代码： class wmLayerColor : public CCLayerColor, public wmTouchDelegate{protected:    WM_TOUCH_DELEGATE_OWNER_CONSTRUCTOR_IN_HEAD_FILE( wmLayerColor );    WM_TOUCH_DELEGATE_IMPLEMENT_IN_HEAD_FILE();    WM_INIT_DEFAULT( CCLayerColor );    //staticpublic:    CREATE_FUNC( wmLayerColor );};这是因为这类对象已经继承了CCLayer，我们不能让它再继承wmLayerDescendant，因为wmLayerDescendant也继承自ccLayer,这样多重继承中会有多份CCLayer，比较危险。所以我们简单的继承自wmTouchDelegate就可以了。 2.第二种情况，我们自己创造新型控件，如我们要在商店放一些物品，每个物品都是有一套共同的UI（物品图片，物品名称，价钱，购买数量，购买按钮），我们可以写     一个控件，然后重用这个控件将会让商店编程更简单。此时我们就让这个新控件继承自wmLayerDescendant即可。其他就不用管了。 class wmUISellItem : public wmLayerDescendant{    //macropublic:    enum    {        ITEM_NAME_LENGTH = 20,        WIDTH = 219,        HEIGHT = 141,    };        //methodprotected:    bool init();    //staticpublic:    static wmUISellItem* Create( const char* pszItemName, int iItemPriceNormal, int iItemPriceVIP, int iItemAmount );}; 对多触摸点消息感兴趣的控件，需自行注册standardTouchDelegate。我们没分将多触摸点消息转化成单触摸点消息传播，因为多触摸点消息更适合一次性接受处理，而不是分批传递。 最后，上述代码在写文章时做过手动修改，所以可能存在书写错误。如若使用需自行改正。这里面一定存在一些不足，还请指出改正，感激不尽。","title":"cocos2d-x 建立自己的层级窗口消息机制"},{"content":"  软件设计是一个十分复杂且没有规律可遵循的思维发散过程。设计软件系统是非常有挑战性的，因为一方面需要你聚焦在今天的需求，同时要求可以适应未来对功能的修改和增加。 面对软件最大的敌人—需求的变化，我们更多的是通过堆积木的方式堆砌代码。 随着系统的上线运营，客户需求不断的变化与扩充、程序BUG的不断涌现，我们天天在为了修正BUG而干十万火急的工作，下班了还提心吊胆实施地是否给自己提了除错单。面对一堆高深且杂乱无章的代码、面对一个接一个的BUG、面对一个又一个的需求单，我们抱怨、救急、茫然、苦不堪言，眼前看不到一丝希望。 对于困惑，我们束手就擒了吗？没有。我们搬来了一堆设计方法论，什么CMMI、RUP、XP、TDD，还有结对编程、四色原型等等。拿来了国外先进的方法论，我们自豪的说我们的设计多牛多牛，设计理念多么的先进。可现实落实下去了吗？几乎没有。我们根本没有理解如何去实践，我们只是了解皮毛然后在尝试，可悲的是我们在实践过程中没有去总结，没有去改进。结果呢？我们的设计仍旧纠结于细节的泥潭，设计的人力耗进去了，貌似也有些输出成果，只是这些成果对质量没有本质的提升，仅仅能看到稍许眼前利--开发人员轻松了却又纠结了，我是否该完全按设计去做，照搬又不能实现需求？怎么办？ 我们每个人都希望能够把设计做好并尽力最大努力，但随着不停的添加临时性的修复，越来越多的代码变得难以维护和改进，项目也一步步陷入泥潭。 系统的依赖关系与复杂度让我们对系统望而生畏，领导一拍板--重新设计开发，我们又重新沉迷于初期的美好架构与愿景，似乎眼前一片光明大道。可实现了？不说大家都知道答案。 我们到底应该如何去做设计？什么样的设计才是好的设计呢？业界的可维护性、可扩展性、可复用性、灵活性等大家耳熟能详，说的时候也是信手拈来，可实践中如何去实现，如何才能满足了？我们又迷茫了。 首先看一个分层与包结构关系图，我们不讨论其合理性，但第一眼的印象是不是觉得很晕？ 太复杂了，可现实是残酷的，软件设计与开发的复杂性一直伴随在我们身边，问题域的复杂性、管理开发过程的困难性、软件实现的灵活性等等导致了软件开发就像一匹脱缰的野马，我们无力掌控。 导致复杂性的根本原因是什么？依赖。代码的变乱，根本原因就是由于太多不良依赖或者模块失去单一性所致。如何解除依赖？我们先看看计算机组成结构图： 计算机的各个组件为什么能轻松组合运行？关键是抽象层次之间以某种定义好的方式进行交互，在给定层的内外之间有清晰的边界，在不同抽象层的不同部件之间，存在清晰的分离关注。 从计算机的组装看软件的设计： 从上图看，面对系统的复杂性，设计的核心是分离关注点与模块化/组件化，如何实现模块化开发呢？我认为应该从职责、协作、服务、变化四个方面着手去设计，即： （1）分析出各组件的职责； （2）发布组件的服务； （3）建立组件之间的协作关系； （4）组件本身如何应对变化； 关于划分职责、发布服务、建立协作、应对变化四个方面，后续再逐一总结发布。","title":"[置顶] 软件设计的思考与关注点"},{"content":"Acegi 对于密码提供三种方式：明文及不采用任何加密方式、MD5加密方式、哈希算法加密方式。 只需要在DAO的认证管理器中分别加入以下对应配置： 第一种：不使用任何加密方式的配置 <bean id=\"daoAuthenticationProvider\"      class=\"org.acegisecurity.providers.dao.DaoAuthenticationProvider\">      <property name=\"userDetailsService\" ref=\"userDetailsService\" />        <!-- 明文加密，不使用任何加密算法, 在不指定该配置的情况下，Acegi默认采用的就是明文加密 -->      <!-- <property name=\"passwordEncoder\"> <bean class=\"org.acegisecurity.providers.encoding.PlaintextPasswordEncoder\">           <property name=\"ignorePasswordCase\" value=\"true\"><\/property> <\/bean> <\/property> -->  <\/bean>  第二种：MD5方式加密 <bean id=\"daoAuthenticationProvider\" class=\"org.acegisecurity.providers.dao.DaoAuthenticationProvider\">         <property name=\"userDetailsService\" ref=\"userDetailsService\" />             <property name=\"passwordEncoder\">             <bean class=\"org.acegisecurity.providers.encoding.Md5PasswordEncoder\">                 <!-- false 表示：生成32位的Hex版, 这也是encodeHashAsBase64的, Acegi 默认配置; true  表示：生成24位的Base64版 -->                 <property name=\"encodeHashAsBase64\" value=\"false\" />             <\/bean>         <\/property>     <\/bean>      第三种：使用MD5加密，并添加全局加密盐 <bean id=\"daoAuthenticationProvider\" class=\"org.acegisecurity.providers.dao.DaoAuthenticationProvider\">         <property name=\"userDetailsService\" ref=\"userDetailsService\" />             <property name=\"passwordEncoder\">             <bean class=\"org.acegisecurity.providers.encoding.Md5PasswordEncoder\">                 <property name=\"encodeHashAsBase64\" value=\"false\" />             <\/bean>         <\/property>             <!-- 对密码加密算法中使用特定的加密盐及种子 -->         <property name=\"saltSource\">             <bean class=\"org.acegisecurity.providers.dao.salt.SystemWideSaltSource\">                 <property name=\"systemWideSalt\" value=\"acegisalt\" />             <\/bean>         <\/property>     <\/bean> 第四种：使用MD5加密，并添加动态加密盐 <bean id=\"daoAuthenticationProvider\" class=\"org.acegisecurity.providers.dao.DaoAuthenticationProvider\">         <property name=\"userDetailsService\" ref=\"userDetailsService\" />             <property name=\"passwordEncoder\">             <bean class=\"org.acegisecurity.providers.encoding.Md5PasswordEncoder\">                 <property name=\"encodeHashAsBase64\" value=\"false\" />             <\/bean>         <\/property>             <!-- 对密码加密算法中使用特定的加密盐及种子 -->         <property name=\"saltSource\">             <!-- 通过动态的加密盐进行加密，该配置通过用户名提供加密盐, 通过UserDetails的getUsername()方式 -->              <bean class=\"org.acegisecurity.providers.dao.salt.ReflectionSaltSource\">                 <property name=\"userPropertyToUse\" value=\"getUsername\" />              <\/bean>         <\/property>     <\/bean>   第五种：使用哈希算法加密，加密强度为256[html] view plaincopy<bean id=\"daoAuthenticationProvider\" class=\"org.acegisecurity.providers.dao.DaoAuthenticationProvider\">         <property name=\"userDetailsService\" ref=\"userDetailsService\" />             <property name=\"passwordEncoder\">             <bean class=\"org.acegisecurity.providers.encoding.ShaPasswordEncoder\">                 <constructor-arg value=\"256\" />                 <property name=\"encodeHashAsBase64\" value=\"false\" />             <\/bean>         <\/property>     <\/bean>    第六种：使用哈希算法加密，加密强度为SHA-25ml] view plain <bean id=\"daoAuthenticationProvider\" class=\"org.acegisecurity.providers.dao.DaoAuthenticationProvider\">          <property name=\"userDetailsService\" ref=\"userDetailsService\" />               <property name=\"passwordEncoder\">              <bean class=\"org.acegisecurity.providers.encoding.ShaPasswordEncoder\">                  <constructor-arg value=\"SHA-256\" />                  <property name=\"encodeHashAsBase64\" value=\"false\" />              <\/bean>          <\/property>      <\/bean>  cop <bean id=\"daoAuthenticationProvider\" class=\"org.acegisecurity.providers.dao.DaoAuthenticationProvider\">         <property name=\"userDetailsService\" ref=\"userDetailsService\" />             <property name=\"passwordEncoder\">             <bean class=\"org.acegisecurity.providers.encoding.ShaPasswordEncoder\">                 <constructor-arg value=\"SHA-256\" />                 <property name=\"encodeHashAsBase64\" value=\"false\" />             <\/bean>         <\/property>     <\/bean>    上述配置只是在Acegi通过表单提交的用户认证信息中的密码做各种加密操作。而我们存储用户密码的时候，可以通过一下程序完成用户密码操作： package org.hz.test;    import java.security.NoSuchAlgorithmException;    import org.springframework.security.authentication.encoding.Md5PasswordEncoder;  import org.springframework.security.authentication.encoding.ShaPasswordEncoder;    public class MD5Test {      public static void md5() {             Md5PasswordEncoder md5 = new Md5PasswordEncoder();             // false 表示：生成32位的Hex版, 这也是encodeHashAsBase64的, Acegi 默认配置; true  表示：生成24位的Base64版             md5.setEncodeHashAsBase64(false);             String pwd = md5.encodePassword(\"1234\", null);             System.out.println(\"MD5: \" + pwd + \" len=\" + pwd.length());         }      public static void sha_256() throws NoSuchAlgorithmException {               ShaPasswordEncoder sha = new ShaPasswordEncoder(256);             sha.setEncodeHashAsBase64(true);             String pwd = sha.encodePassword(\"1234\", null);             System.out.println(\"哈希算法 256: \" + pwd + \" len=\" + pwd.length());         }                          public static void sha_SHA_256() {             ShaPasswordEncoder sha = new ShaPasswordEncoder();             sha.setEncodeHashAsBase64(false);             String pwd = sha.encodePassword(\"1234\", null);              System.out.println(\"哈希算法 SHA-256: \" + pwd + \" len=\" + pwd.length());         }                          public static void md5_SystemWideSaltSource () {             Md5PasswordEncoder md5 = new Md5PasswordEncoder();             md5.setEncodeHashAsBase64(false);                          // 使用动态加密盐的只需要在注册用户的时候将第二个参数换成用户名即可             String pwd = md5.encodePassword(\"1234\", \"acegisalt\");             System.out.println(\"MD5 SystemWideSaltSource: \" + pwd + \" len=\" + pwd.length());         }         public static void main(String[] args) throws NoSuchAlgorithmException {          md5(); // 使用简单的MD5加密方式                       sha_256(); // 使用256的哈希算法(SHA)加密                          sha_SHA_256(); // 使用SHA-256的哈希算法(SHA)加密                          md5_SystemWideSaltSource(); // 使用MD5再加全局加密盐加密的方式加密          }        }","title":"Spring Security加密策略"},{"content":"Portal-Basic Java Web应用开发框架（简称 Portal-Basic）是一套功能完备的高性能Full-Stack Web应用开发框架，内置稳定高效的MVC基础架构和DAO框架（已内置Hibernate、MyBatis和JDBC支持），集成 Action拦截、Form Bean / Dao Bean / Spring Bean装配、国际化、文件上传下载和缓存等基础Web应用组件，提供高度灵活的纯 Jsp/Servlet API 编程模型，完美整合 Spring，支持Action Convention“零配置”，能快速开发传统风格和RESTful风格的Web应用程序，文档和代码清晰完善，非常容易学习。 　　Portal-Basic 源码、示例及文档资源：请访问 google code 项目 ^_* Portal-Basic在设计之初就充分注重功能、性能与使用体验。Portal-Basic主要特点： 1) 功能全面：内置稳定高效的MVC基础架构和DAO框架，支持Action拦截、Form Bean / Dao Bean / Spring Bean装配和声明式事务，提供国际化、文件上传下载、缓存和页面静态化等常用Web组件，能满足绝大部分Web应用的需要。 2) 高度扩展：Portal-Basic通过的plug-in机制可以灵活扩展，Portal-Basic发布包中自带的portal-basic-ext-rest和portal-basic-ext-spring均以插件的形式提供，用户可根据需要加载或卸载这些插件。应用程序开发者也可以根据实际需要编写自定义插件来扩展Portal-Basic。 3) 强大的整合能力：Portal-Basic是一个Full-Stack框架，同时也是一个开放式框架，可以以非常简单的方式整合第三方组件。本开发手册会详细阐述如何在Portal-Basic中整合FreeMarker、Velocity、UrlRewrite、EHCache-Web、Spring、Hibernate和MyBaits等常用框架和组件。 4) 高性能：性能要求是Portal-Basic的硬性指标，从每个模块的设计到每行代码的实现都力求简洁高效。另外，Portal-Basic并没有对JSP/Servet API进行过多封装，开发者仍然使用JSP/Servet API开发应用程序，没有过多的迂回，性能得到保证。 5) 优秀的使用体验：Portal-Basic的设计目标之一是提供良好的开发体验，尽量减少应用程序开发者的工作，API的设计力求简单、完整、明确。同时，Portal-Basic为应用开发提供了大量Util工具，用来处理应用程序开发过程中通常会遇到的一般性问题，进一步减少应用程序开发者的工作负担。 6) 平缓的学习曲线：平缓的学习曲线：学习使用Portal-Basic只需掌握一定的Core Java与JSP/Servlet知识，本开发手册会循序渐进阐述每个知识点，每个知识点都会结合完整的示例进行讲述，知识点之间前后呼应，确保学习者在学习时温故知新，融会贯通。 7) 完善的技术支持：除了提供完善的开发手册和示例代码以外，还提供博客和QQ群用于解答使用Portal-Basic过程中碰到的所有问题。接下来，将计划建设一个Portal-Basic技术论坛。 Portal-Basic 3.0.1 更新： 1、增加 Action Convention，支持“Action 零配置”： 1) 根据 Action 请求的地址信息自动加载 Action，并调用相应的入口方法处理请求 2) 根据 Action 请求的地址信息和 Action Result 自动组合出输出页面的地址并转发 3) 通过 @Result/@Results 和 @ExceptionMapping/@ExceptionMappings 注解自定义 Result 和 Exception 处理策略 2、增加 REST 支持： 1) 增加 REST 插件包 portal-basic-ext-rest-3.0.1.jar 用于支持 REST 2) portal-basic-ext 通过 com.bruce.ext.rest.RestDispatcher 过滤器把 REST 请求转换为 Action 请求 3) portal-basic-ext 提供 com.bruce.ext.rest.RestActionSupport 作为处理 REST 请求的 Action 基类 4) Action 的 REST 请求处理方法通过声明 @Get/@Post/@Put/@Delete 注解来匹配 REST 地址格式，并注入参数 5) 内置 Rails-style REST 标准方法 6) 同时支持 HTML/XML/JSON 三种视图格式，应用程序也可以扩展自己的视图格式 7) portal-basic-ext 与 Action Convention 结合使用能实现“零配置”处理 REST 请求    相关链接： Portal-Basic Java Web 应用开发框架 —— 概述 Portal-Basic Java Web 应用开发框架：应用篇（一） —— 配置文件 Portal-Basic Java Web 应用开发框架：应用篇（二） —— Action 使用 Portal-Basic Java Web 应用开发框架：应用篇（三） —— 国际化 Portal-Basic Java Web 应用开发框架：应用篇（四） —— 文件上传和下载 Portal-Basic Java Web 应用开发框架：应用篇（五） —— DAO 框架 Portal-Basic Java Web 应用开发框架：应用篇（六） —— 公共组件 Portal-Basic Java Web 应用开发框架：应用篇（七） —— 页面静态化 Portal-Basic Java Web 应用开发框架：应用篇（八） —— 整合 Freemarker Portal-Basic Java Web 应用开发框架：应用篇（九） —— 多入口 Action Portal-Basic Java Web 应用开发框架：应用篇（十） —— 新 DAO 访问接口 Portal-Basic Java Web 应用开发框架：应用篇（十一） —— 整合 Spring Portal-Basic Java Web 应用开发框架：应用篇（十二） —— Action Convention Portal-Basic Java Web 应用开发框架：应用篇（十三） —— REST Convention     开发文档目录：  ","title":"[置顶] 【双旦献礼】Portal-Basic Java Web 应用开发框架 v3.0.1 正式发布（源码、示例及文档）"},{"content":"什么是设计不足？设计出来的系统复用性差，扩展性不强，不能灵活的应对变化，简言之，设计没到位。设计不足，多半是因为经验有限，设计能力有限。 什么是过度设计？设计出来的系统比恰到好处要复杂臃肿的多，过度的封装、一堆继承、接口和无用的方法，超复杂的xml配置文件，简言之，客户需求是要一把杀鸡的刀，你给设计了一把牛刀（杀鸡用牛刀）。过度设计，多半是因为有设计的癖好，喜欢炫耀或玩弄无谓的技巧，或是喜欢把简单的问题搞复杂化。 如此说来，没有人能说自己的设计就是恰到好处的。适合的就是最好的，但什么是适合的？这个度很难把握。 客户只是告诉你他“需要一把杀鸡的刀”，至于将来有没有需求变化，有没有可能要这把刀能杀牛，客户也不知道。所以当然这个设计的度就很难把握了。 有人主张设计必须前瞻与用户需求，不能以需求为导向。因为客户从来不会告诉你他未来的需求，连他也不知道。例如，消费者从来不会告诉RIM公司，我需要一款能收企业邮件的BlackBerry手机。 但也有人持相反观点，认为设计必须以需求为导向，软件以人为本，以用为本。 其实从一定意思上说，过度设计和设计不足都是“设计错误”的一种形式。 设计不足，则意味着系统复用性扩展性和灵活性差，系统僵化，不能应对将来的需求变化，或者将来修改和维护的代价和成本会很高，这当然是设计错误； 过度设计，则意味着为了实现这个设计要付出的额外代价，例如成本上升，缺陷可能性加大，提升维护成本，甚至降低系统性能。而可维护性和系统的高性能都是系统的隐性需求，这些需求没实现好，当然也是设计错误。 从另外一个角度看来，能够进行过度设计的，多半设计能力高于设计不足的；过度的设计改回来的成本也比设计不足的改过去的成本低的多。 Martin Fowler说敏捷开发不是轻视设计重实践和重构，而是演进式的设计(Evolutionary Design，区别与计划性的设计 Planned Design)。每一次的重构和迭代都映射和更新到最新的设计中来，从而最大限度的满足客户的功能性需求和非功能性需求。从最初的Prototyping、初始需求分析与建模，然后进行演进式的架构设计和实践，这也许是适合于大多数中小型项目的最佳实践。 因为变化是无穷无尽的，需求是变幻莫测的，我们每天都跟在需求后面跑，跑的很累。而客户还要求我们随需应变，抱怨我们不够敏捷，要求我们以欢喜的心态来拥抱变化，因为变化就是IT的机会嘛! 但我们能找到“银弹”来封装所有未知的需求变化吗？我们能超前于客户的需求，能变被动为主动吗？我们能设计出一个系统超前于未来客户的需求吗？ 没有一个完美的能随需应变的系统，所谓“设计之美”也是盛名之下其实难副。我们实际的目标只是最大限度的封装变化，最大限度的预测某些未来可能的变化，提供某些系统扩展和变化的可能性，从而减低未来变化的成本，为客户创造价值。 也许，最简单的才是最好的。大巧若拙，大道至简，有时候越简单的反而越难实现，而且越接近真理。也许这个只能靠个人体会和悟性了，才能最终体会到简单的精妙设计之美。熟背各种设计模式、学个一招半式的人，就像一个天天背着一把剑的剑客一样，唯恐旁人不知道其剑术高强；而真正的高手是手中无剑，却照样可以打赢别人，因为万物都可被他用来施以剑法。这才是真正的高境界。 我们缺乏的是真正有创意的创造性的设计，比如我们为什么没有设计出中国人自己的framework和platform？因为我们经验、技术和设计能力不足，大家都沉迷于玩一些小技巧，战术技巧，不是战略技巧；玩到30岁然后都去做PM做培训做销售去了。而在那些需要简约设计的地方，我们却自诩为高手而加上很多华丽的设计来维护虚幻的可扩展性和灵活性。 中国的架构师，缺乏的不仅仅是经验、技术、创意、设计能力，也许最缺乏的是思想，是心境。  ","title":"设计不足与过度设计"},{"content":"错误：hdfs.DFSClient: Exception in createBlockOutputStream java.io.IOException: hadoopioexceptionconnectbadack  hadoop 运行任务的时候突然报错： java.io.IOException: Bad connect ack with firstBadLink 192.168.1.11:50010 at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.createBlockOutputStream(DFSClient.java:2903) at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.nextBlockOutputStream(DFSClient.java:2826) at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.access$2000(DFSClient.java:2102) at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream$DataStreamer.run(DFSClient.java:2288) 某次运行一个任务时，报出了以下的错误提示： 10/12/10 21:09:05 INFO hdfs.DFSClient: Exception in createBlockOutputStream java.io.IOException: Bad connect ack with firstBadLink 10.1.73.148:50010 10/12/10 21:09:05 INFO hdfs.DFSClient: Abandoning block blk_3623545154924652323_87440 10/12/10 21:09:11 INFO hdfs.DFSClient: Exception in createBlockOutputStream java.net.ConnectException: Connection refused 10/12/10 21:09:11 INFO hdfs.DFSClient: Abandoning block blk_-4726571439643867938_87441\\ 原因 错误提示中包含了任务跟踪/数据节点机器的IP地址（10.1.73.148）。出现错误的原因是这台机器上的数据节点的守护进程没有在运行；通过登录这个机器确认错误，例子中的机器是10.1.73.148。所以运行一下命令：jps，看有没有datenode在运行，如果没有任何返回，那么一位着数据节点的守护进程没有运行。 还有一种可能：原因是运行的任务要求包含了某数据块。如果这个数据块在其他机器上有复本，并且其他机器正运行着数据节点的守护进程，那么Hadoop将会从其他机器上获取数据块，然后继续执行任务，但如果其他任何机器上没有该数据块可用，那么任务就会失败。 解决方法 登录到10.1.73.148，运行如下命令： hadoop-daemon.sh start datanode 以上命令会启动10.1.73.148上数据节点的守护进程。重新运行一下任务，应该不会再报错了。","title":"错误：hdfs.DFSClient: Exception in createBlockOutputStream java.io.IOException:"},{"content":"cause:org.apache.hadoop.mapred.FileAlreadyExistsException: Output directory hdfs://localhost:54310/。。。。。 12/05/28 09:33:37 WARN mapred.JobClient: Use GenericOptionsParser for parsing the arguments. Applications should implement Tool for the same. 12/05/28 09:33:37 INFO mapred.JobClient: Cleaning up the staging area file:/tmp/hadoop-Hadoop/mapred/staging/Hadoop-1983717839/.staging/job_local_0001 12/05/28 09:33:37 ERROR security.UserGroupInformation: PriviledgedActionException as:Hadoop (auth:SIMPLE) cause:org.apache.hadoop.mapred.FileAlreadyExistsException: Output directory hdfs://localhost:54310/user/Hadoop/input/cxu_index already exists Exception in thread \"main\" org.apache.hadoop.mapred.FileAlreadyExistsException: Output directory hdfs://localhost:54310/user/Hadoop/input/cxu_index already exists at org.apache.hadoop.mapreduce.lib.output.FileOutputFormat.checkOutputSpecs(FileOutputFormat.java:132) at org.apache.hadoop.mapred.JobClient$2.run(JobClient.java:872) at org.apache.hadoop.mapred.JobClient$2.run(JobClient.java:833) at java.security.AccessController.doPrivileged(Native Method) at javax.security.auth.Subject.doAs(Subject.java:396) at org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:1157) at org.apache.hadoop.mapred.JobClient.submitJobInternal(JobClient.java:833) at org.apache.hadoop.mapreduce.Job.submit(Job.java:476) at org.apache.hadoop.mapreduce.Job.waitForCompletion(Job.java:506) at com.payegis.caesar.hdfsindex.Main.main(Main.java:58)  ==================================================================================================   hadoop 由于进行的是耗费资源的计算，生产的结果默认是不能被覆盖的， 因此中间结果输出目录一定不能存在，否则出现这个错误。   就是这句代码： FileOutputFormat.setOutputPath( job, new Path(args[1]) );","title":"org.apache.hadoop.mapred.FileAlreadyExistsException"},{"content":"    Win下Eclipse提交hadoop程序出错：org.apache.hadoop.security.AccessControlException: Permission denied: user=administrator, access=WRITE 描述：在window下使用Eclipse进行hadoop的程序编写，然后Run on hadoop 后，出现如下错误： 11/10/28 16:05:53 INFO mapred.JobClient: Running job: job_201110281103_0003 11/10/28 16:05:54 INFO mapred.JobClient: map 0% reduce 0% 11/10/28 16:06:05 INFO mapred.JobClient: Task Id : attempt_201110281103_0003_m_000002_0, Status : FAILED org.apache.hadoop.security.AccessControlException: org.apache.hadoop.security.AccessControlException: Permission denied: user=administrator, access=WRITE, inode=\"hadoop\":hadoop:supergroup:rwxr-xr-x at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)         因为Eclipse使用hadoop插件提交作业时，会默认以administrator身份去将作业写入hdfs文件系统中，对应的也就是 HDFS 上的/user/xxx , 我的为/user/hadoop ,   由于 administrator 用户对hadoop目录并没有写入权限，所以导致异常的发生。解决方法为：放开 hadoop 目录的权限 ， 命令如下 ：$hadoop fs -chmod 777 /user/hadoop    ","title":"Win下Eclipse提交hadoop程序出错：org.apache.hadoop.security.AccessControlException: Permission denied:"},{"content":"1：Shuffle Error: Exceeded MAX_FAILED_UNIQUE_FETCHES; bailing-out Answer： 程序里面需要打开多个文件，进行分析，系统一般默认数量是1024，（用ulimit -a可以看到）对于正常使用是够了，但是对于程序来讲，就太少了。 修改办法： 修改2个文件。         /etc/security/limits.conf vi /etc/security/limits.conf 加上： * soft nofile 102400 * hard nofile 409600     $cd /etc/pam.d/     $sudo vi login         添加        session    required     /lib/security/pam_limits.so 针对第一个问题我纠正下答案： 这是reduce预处理阶段shuffle时获取已完成的map的输出失败次数超过上限造成的，上限默认为5。引起此问题的方式可能会有很多种，比如网络连接不正常，连接超时，带宽较差以及端口阻塞等。。。通常框架内网络情况较好是不会出现此错误的。 2：Too many fetch-failures Answer: 出现这个问题主要是结点间的连通不够全面。 1) 检查 、/etc/hosts    要求本机ip 对应 服务器名    要求要包含所有的服务器ip + 服务器名 2) 检查 .ssh/authorized_keys    要求包含所有服务器（包括其自身）的public key 3：处理速度特别的慢 出现map很快 但是reduce很慢 而且反复出现 reduce=0%  Answer: 结合第二点，然后 修改 conf/hadoop-env.sh 中的export HADOOP_HEAPSIZE=4000  4：能够启动datanode，但无法访问，也无法结束的错误 在重新格式化一个新的分布式文件时，需要将你NameNode上所配置的dfs.name.dir这一namenode用来存放NameNode 持久存储名字空间及事务日志的本地文件系统路径删除，同时将各DataNode上的dfs.data.dir的路径 DataNode 存放块数据的本地文件系统路径的目录也删除。如本此配置就是在NameNode上删除/home/hadoop/NameData，在DataNode上删除/home/hadoop/DataNode1和/home/hadoop/DataNode2。这是因为Hadoop在格式化一个新的分布式文件系统时，每个存储的名字空间都对应了建立时间的那个版本（可以查看/home/hadoop /NameData/current目录下的VERSION文件，上面记录了版本信息），在重新格式化新的分布式系统文件时，最好先删除NameData 目录。必须删除各DataNode的dfs.data.dir。这样才可以使namedode和datanode记录的信息版本对应。 注意：删除是个很危险的动作，不能确认的情况下不能删除！！做好删除的文件等通通备份！！ 5：java.io.IOException: Could not obtain block: blk_194219614024901469_1100 file=/user/hive/warehouse/src_20090724_log/src_20090724_log 出现这种情况大多是结点断了，没有连接上。 6：java.lang.OutOfMemoryError: Java heap space 出现这种异常，明显是jvm内存不够得原因，要修改所有的datanode的jvm内存大小。 Java -Xms1024m -Xmx4096m 一般jvm的最大内存使用应该为总内存大小的一半，我们使用的8G内存，所以设置为4096m，这一值可能依旧不是最优的值。 7: Namenode in safe mode  解决方法 bin/hadoop dfsadmin -safemode leave 8:java.net.NoRouteToHostException: No route to host j解决方法： sudo /etc/init.d/iptables stop 9：更改namenode后，在hive中运行select 依旧指向之前的namenode地址 这是因为：When youcreate a table, hive actually stores the location of the table (e.g. hdfs://ip:port/user/root/...) in the SDS and DBS tables in the metastore . So when I bring up a new cluster the master has a new IP, but hive's metastore is still pointing to the locations within the old cluster. I could modify the metastore to update with the new IP everytime I bring up a cluster. But the easier and simpler solution was to just use an elastic IP for the master 所以要将metastore中的之前出现的namenode地址全部更换为现有的namenode地址 10：Your DataNode is started and you can create directories with bin/hadoop dfs -mkdir, but you get an error message when you try to put files into the HDFS (e.g., when you run a command like bin/hadoop dfs -put). 解决方法： Go to the HDFS info web page (open your web browser and go to http://namenode:dfs_info_port where namenode is the hostname of your NameNode and dfs_info_port is the port you chose dfs.info.port; if followed the QuickStart on your personal computer then this URL will be http://localhost:50070). Once at that page click on the number where it tells you how many DataNodes you have to look at a list of the DataNodes in your cluster. If it says you have used 100% of your space, then you need to free up room on local disk(s) of the DataNode(s). If you are on Windows then this number will not be accurate (there is some kind of bug either in Cygwin's df.exe or in Windows). Just free up some more space and you should be okay. On one Windows machine we tried the disk had 1GB free but Hadoop reported that it was 100% full. Then we freed up another 1GB and then it said that the disk was 99.15% full and started writing data into the HDFS again. We encountered this bug on Windows XP SP2. 11：Your DataNodes won't start, and you see something like this in logs/*datanode*: Incompatible namespaceIDs in /tmp/hadoop-ross/dfs/data 原因： Your Hadoop namespaceID became corrupted. Unfortunately the easiest thing to do reformat the HDFS. 解决方法： You need to do something like this: bin/stop-all.sh rm -Rf /tmp/hadoop-your-username/* bin/hadoop namenode -format 12：You can run Hadoop jobs written in Java (like the grep example), but your HadoopStreaming jobs (such as the Python example that fetches web page titles) won't work. 原因： You might have given only a relative path to the mapper and reducer programs. The tutorial originally just specified relative paths, but absolute paths are required if you are running in a real cluster. 解决方法： Use absolute paths like this from the tutorial: bin/hadoop jar contrib/hadoop-0.15.2-streaming.jar \\   -mapper  $HOME/proj/hadoop/multifetch.py         \\   -reducer $HOME/proj/hadoop/reducer.py            \\   -input   urls/*                                  \\   -output  titles 13： 2009-01-08 10:02:40,709 ERROR metadata.Hive (Hive.java:getPartitions(499)) - javax.jdo.JDODataStoreException: Required table missing : \"\"PARTITIONS\"\" in Catalog \"\" Schema \"\". JPOX requires this table to perform its persistence operations. Either your MetaData is incorrect, or you need to enable \"org.jpox.autoCreateTables\" 原因：就是因为在 hive-default.xml 里把 org.jpox.fixedDatastore 设置成 true 了 14：09/08/31 18:25:45 INFO hdfs.DFSClient: Exception in createBlockOutputStream java.io.IOException:Bad connect ack with firstBadLink 192.168.1.11:50010 > 09/08/31 18:25:45 INFO hdfs.DFSClient: Abandoning block blk_-8575812198227241296_1001 > 09/08/31 18:25:51 INFO hdfs.DFSClient: Exception in createBlockOutputStream java.io.IOException: Bad connect ack with firstBadLink 192.168.1.16:50010 > 09/08/31 18:25:51 INFO hdfs.DFSClient: Abandoning block blk_-2932256218448902464_1001 > 09/08/31 18:25:57 INFO hdfs.DFSClient: Exception in createBlockOutputStream java.io.IOException: Bad connect ack with firstBadLink 192.168.1.11:50010 > 09/08/31 18:25:57 INFO hdfs.DFSClient: Abandoning block blk_-1014449966480421244_1001 > 09/08/31 18:26:03 INFO hdfs.DFSClient: Exception in createBlockOutputStream java.io.IOException: Bad connect ack with firstBadLink 192.168.1.16:50010 > 09/08/31 18:26:03 INFO hdfs.DFSClient: Abandoning block blk_7193173823538206978_1001 > 09/08/31 18:26:09 WARN hdfs.DFSClient: DataStreamer Exception: java.io.IOException: Unable to create new block. >         at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.nextBlockOutputStream(DFSClient.java:2731) >         at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.access$2000(DFSClient.java:1996) >         at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream$DataStreamer.run(DFSClient.java:2182) >  > 09/08/31 18:26:09 WARN hdfs.DFSClient: Error Recovery for block blk_7193173823538206978_1001 bad datanode[2] nodes == null > 09/08/31 18:26:09 WARN hdfs.DFSClient: Could not get block locations. Source file \"/user/umer/8GB_input\" - Aborting... > put: Bad connect ack with firstBadLink 192.168.1.16:50010 解决方法： I have resolved the issue: What i did:  1) '/etc/init.d/iptables stop' -->stopped firewall 2) SELINUX=disabled in '/etc/selinux/config' file.-->disabled selinux I worked for me after these two changes 15:把IP换成主机名，datanode 挂不上 解决方法： 把temp文件删除，重启hadoop集群就行了 是因为多次部署，造成temp文件与namenode不一致的原因     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~     一、hadoop集群在namenode格式化（bin/hadoop namenode -format）后重启集群会出现如下 Incompatible namespaceIDS in … :namenode namespaceID = … ,datanode namespaceID=… 错误，原因是格式化namenode后会重新创建一个新的namespaceID,以至于和datanode上原有的不一致。 解决方法： 删除datanode dfs.data.dir目录（默认为tmp/dfs/data）下的数据文件 修改dfs.data.dir/current/VERSION 文件，把namespaceID修成与namenode上相同即可（log错误里会有提示） 重新指定新的dfs.data.dir目录 二、hadoop集群启动start-all.sh的时候，slave总是无法启动datanode，并会报错： … could only be replicated to 0 nodes, instead of 1 … 就是有节点的标识可能重复（个人认为这个错误的原因）。也可能有其他原因，一下解决方法请依次尝试，我是解决了。 解决方法： 删除所有节点dfs.data.dir和dfs.tmp.dir目录（默认为tmp/dfs/data和tmp/dfs/tmp）下的数据文件；然后重新hadoop namenode -format 格式化节点；然后启动。 如果是端口访问的问题，你应该确保所用的端口都打开，比如hdfs://machine1:9000/、50030、50070之类的。执行#iptables -I INPUT -p tcp –dport 9000 -j ACCEPT 命令。如果还有报错：hdfs.DFSClient: Exception in createBlockOutputStream java.net.ConnectException: Connection refused；应该是datanode上的端口不能访问，到datanode上修改iptables：#iptables -I INPUT -s machine1 -p tcp -j ACCEPT 还有可能是防火墙的限制集群间的互相通信。尝试关闭防火墙。/etc/init.d/iptables stop 最后还有可能磁盘空间不够了，请查看 df -al 我在解决这个问题的时候还有人说：先后启动namenode、datanode可以解决这个问题（本人尝试发现没用，大家可以试试）$hadoop-daemon.sh start namenode ； $hadoop-daemon.sh start datanode 三、程序执行出现Error: java.lang.NullPointerException 空指针异常，确保java程序的正确。变量什么的使用前先实例化声明，不要有数组越界之类的现象。检查程序。 四、执行自己的程序的时候，（各种）报错，请确保一下情况： 前提都是你的程序是正确通过编译的 集群模式下，请把要处理的数据写到HDFS里，并且确保HDFS路径正确 指定执行的jar包的入口类名（我不知道为什么有时候不指定也是可以运行的） 正确的写法类似： $ hadoop jar myCount.jar myCount input output 五、ssh无法正常通信的问题，这个问题我在搭建篇里有详细提到过。 六、程序编译问题，各种包没有的情况，请确保你把hadoop目录下 和hadoop/lib目录下的jar包都有引入。详细情况也是看搭建篇里的操作。 七、Hadoop启动datanode时出现Unrecognized option: -jvm 和 Could not create the Java virtual machine. 在hadoop安装目录/bin/hadoop中有如下一段shell: View Code SHELL 123456 CLASS='org.apache.hadoop.hdfs.server.datanode.DataNode'  if [[ $EUID -eq 0 ]]; then    HADOOP_OPTS=\"$HADOOP_OPTS -jvm server $HADOOP_DATANODE_OPTS\"  else    HADOOP_OPTS=\"$HADOOP_OPTS -server $HADOOP_DATANODE_OPTS\"  fi $EUID 这里的用户标识，如果是root的话，这个标识会是0，所以尽量不要使用root用户来操作hadoop就好了。这也是我在配置篇里提到不要使用root用户的原因。 八、如果出现终端的错误信息是： ERROR hdfs.DFSClient: Exception closing file /user/hadoop/musicdata.txt : java.io.IOException: All datanodes 10.210.70.82:50010 are bad. Aborting… 还有jobtracker log的报错信息 Error register getProtocolVersion java.lang.IllegalArgumentException: Duplicate metricsName:getProtocolVersion 和可能的一些警告信息： WARN hdfs.DFSClient: DataStreamer Exception: java.io.IOException: Broken pipe WARN hdfs.DFSClient: DFSOutputStream ResponseProcessor exception for block blk_3136320110992216802_1063java.io.IOException: Connection reset by peer WARN hdfs.DFSClient: Error Recovery for block blk_3136320110992216802_1063 bad datanode[0] 10.210.70.82:50010 put: All datanodes 10.210.70.82:50010 are bad. Aborting… 解决办法： 查看dfs.data.dir属性所指的路径是否磁盘已经满了，如果满了则进行处理后再次尝试hadoop fs -put数据。 如果相关磁盘没有满，则需要排查相关磁盘没有坏扇区，需要检测。 九、如果在执行hadoop的jar程序时得到报错信息： java.io.IOException: Type mismatch in key from map: expected org.apache.hadoop.io.NullWritable, recieved org.apache.hadoop.io.LongWritable 或者类似： Status : FAILED java.lang.ClassCastException: org.apache.hadoop.io.LongWritable cannot be cast to org.apache.hadoop.io.Text 那么你需要学习hadoop数据类型和 map/reduce模型的基本知识。我的这篇读书笔记里边中间部分有介绍hadoop定义的数据类型和自定义数据类型的方法(主要是对writable类的学习和了解)；和这篇里边说的MapReduce的类型和格式。也就是《hadoop权威指南》这本书的第四章Hadoop I/O和第七章MapReduce的类型和格式。如果你急于解决这个问题，我现在也可以告诉你迅速的解决之道，但这势必影响你以后开发： 确保一下数据的一致： … extends Mapper… public void map(k1 k, v1 v, OutputCollector output)… … …extends Reducer… public void reduce(k2 k,v2 v,OutputCollector output)… … job.setMapOutputKeyClass(k2.class); job.setMapOutputValueClass(k2.class); job.setOutputKeyClass(k3.class); job.setOutputValueClass(v3.class); … 注意 k* 和 v*的对应。建议还是看我刚才说的两个章节。详细知道其原理。 十、如果碰到datanode报错如下： ERROR org.apache.hadoop.hdfs.server.datanode.DataNode: java.io.IOException: Cannot lock storage /data1/hadoop_data. The directory is already locked. 根据错误提示来看，是目录被锁住，无法读取。这时候你需要查看一下是否有相关进程还在运行或者slave机器的相关hadoop进程还在运行，结合linux这俩命令来进行查看： netstat -nap ps -aux | grep 相关PID 如果有hadoop相关的进程还在运行，就使用kill命令干掉即可。然后再重新使用start-all.sh。 十一、如果碰到jobtracker报错如下： Shuffle Error: Exceeded MAX_FAILED_UNIQUE_FETCHES; bailing-out. 解决方式，修改datanode节点里/etc/hosts文件。 简单介绍下hosts格式： 每行分为三个部分：第一部分网络IP地址、第二部分主机名或域名、第三部分主机别名 操作的详细步骤如下： 1、首先查看主机名称： cat /proc/sys/kernel/hostname 会看到一个HOSTNAME的属性，把后边的值改成IP就OK，然后退出。 2、使用命令： hostname ***.***.***.*** 星号换成相应的IP。 3、修改hosts配置类似内容如下： 127.0.0.1  localhost.localdomain       localhost ::1      localhost6.localdomain6  localhost6 10.200.187.77   10.200.187.77   hadoop-datanode 如果配置后出现IP地址就表示修改成功了，如果还是显示主机名就有问题了，继续修改这个hosts文件， 如下图： 上图提醒下，chenyi是主机名。 当在测试环境里，自己再去部署一个域名服务器（个人觉得很繁琐），所以简单地方式，就直接用IP地址比较方便。如果有了域名服务器的话，那就直接进行映射配置即可。 如果还是出现洗牌出错这个问题，那么就试试别的网友说的修改配置文件里的hdfs-site.xml文件，添加以下内容： dfs.http.address *.*.*.*:50070 端口不要改，星号换成IP，因为hadoop信息传输都是通过HTTP，这个端口是不变的。 十一、如果碰到jobtracker报错如下： java.lang.RuntimeException: PipeMapRed.waitOutputThreads(): subprocess failed with code * 这是java抛出的系统返回的错误码，错误码表示的意思详细的请看这里。 我这里是些streaming的php程序时遇到的，遇到的错误码是code 2: No such file or directory。即找不到文件或者目录。发现命令竟然忘记使用’php ****’ 很坑，另外网上看到也可能是include、require等命令造成。详细的请根据自身情况和错误码修改。  ","title":"Hadoop使用常见问题以及解决方法 ."},{"content":"三．详细设计 Ø        CON 控制器产生时序脉冲信号作用下，协调各个部件取出指令，解析并执行指令。而指令周期是指从取指令开始，到该指令执行完毕所经历的时间。循环计数器是将划分指令周期的。 循环计数的时序图   在SAP-1中，指令周期为如上图。指令周期由取指周期和执行周期组成。SAP-1中，取指周期包括T0、T1、T2。执行周期为T3、T4、T5。     取指令周期中，所有的指令都是一样的，分三步 （1）将PC中数据（ROM的地址）读取放到MAR中 （2）根据MAR读取ROM中的数据，放到IR中 （3）PC = PC + 1 下图周标出了这三个阶段中，那些部位处于工作状态，那些不工作。其中绿色部位处于工作状态，灰色不工作。   取指周期      第一阶段（T0），EP=1，LM=1，其他控制位是0，这样在CLK到达上升沿时，PC中的内容将通过总线存储到MAR中。     第二阶段（T1），ER=1，LI=1，其他控制位是0，这样从PROM中取出数据，在CLK上升沿时，根据MAR读取ROM中的数据，放到IR中。     第三阶段（T3），CP=1，其他控制位是0。其中CP为PC的使能端，CP=1时，CLK上升沿时，PC=PC+1。     因此取指周期中，总结如下表 阶段 CP EP LM ER LI EI  LA EA SU EU LB LO 功能 T0 0  1  1  0 0  0  0  0 0  0  0  0 MAR = PC T1 0  0  0  1 1  0  0  0 0  0  0  0 IR = ROM(PC) T2 1  0  0  0 0  0  0  0 0  0  0  0 PC = PC + 1   执行周期中，各个指令需要执行的操作是不同的。下面对各个指令分别进行介绍。 LDA指令 LDA指令的执行周期包括分三步 （1）IR将指令分为操作码和操作数。操作码将存入CON中，操作数存入MAR中。其中操作码将存入CON中，操作数（PROM的地址）存入MAR中。 （2）根据MAR读取PROM中的数据，放到A中。 （3）LDA指令在这个阶段是空操作。   LDA执行周期    第四阶段（T3），EI=1，LM=1，其他控制位是0，首先IR将操作码直接输出给CON；而操作数，由于EI=1，LM=1，当CLK下一个上升沿到达时，会被存放到MAR中。     第五阶段（T4），ER=1，LA=1，其他控制位是0，这样根据MAR存储的数据地址从PROM中取出数据，在CLK上升沿时，PROM中的数据通过总线放到A中。     第六阶段（T5），所有控制位都为0，空操作 总结如下表：   阶段 CP EP LM ER LI EI  LA  EA SU EU LB LO 功能 T3 0  0   1   0 1  0   0   0 0  0   0   0 MAR = ADDRESS T4 0  0   0   1 0  0   1   0 0  0   0   0 A = ROM(ADDRESS) T5 1  0   0   0 0  0   0   0 0  0   0   0 空操作 ADD指令 ADD指令的执行周期包括分三步 （1）IR将指令划分为操作码和操作数。操作码将存入CON中，而操作数存入MAR中。 （2）根据MAR读取PROM中的数据，放到B中。 （3）ALU将A、B中的数据相加，将结果放到A中。   ADD执行周期 第四阶段（T3），EI=1，LM=1，其他控制位是0，首先IR将操作码直接输出给CON；而操作数由于EI=1，LM=1，当CLK下一个上升沿到达时，会将操作数存放到MAR中。     第五阶段（T4），ER=1，LB=1，其他控制位是0，这样根据MAR存储的数据地址从PROM中取出数据，在CLK上升沿时，根据MAR读取ROM中的数据，放到B中。     第六阶段（T5），LA=1，EU=1，其他控制位是0。由于ALU的加减控制位SU=0，ALU执行加法操作。而LA=1，EU=1，当CLK的上升沿到达时，ALU中计算的结果将通过总线到达A。而这个过程，将经历两个延迟时间段。一个是ALU输出数据的延迟，一个LA接收数据时的延迟。因此ALU只会计算一次。 阶段 CP EP LM ER LI EI  LA EA SU EU LB LO 功能 T3 0  0  1  0 0  1  0  0 0  0  0  0 MAR = ADDRESS T4 0  0  0  1 0  0  0  0 0  0  1  0 B = ROM(ADDRSS) T5 0  0  0  0 0  0  1  0 0  1  0  0 A = SUM SUB指令     SUB指令的执行过程与ADD指令类似，T0——T4阶段相同，只是T5时，ALU的加减法使能端SU=1，ALU执行减法操作。 阶段 CP EP LM ER LI EI  LA EA SU EU LB LO 功能 T3 0  0  1  0 0  1  0  0 0  0  0  0 MAR = ADDRESS T4 0  0  0  1 0  0  0  0 0  0  1  0 B = ROM(ADDRSS) T5 0  0  0  0 0  0  1  0 1  1  0  0 A = DIFF OUT指令 OUT指令的执行周期包括分三步 （1）IR将指令分为操作码和操作数，操作码传给CON。将A的内容传输到O寄存器，同时O寄存器的内容将传给D。 （2）、（3）空操作。 OUT执行周期 OUT执行周期 第四阶段（T3），EA=1，LO=1，其他控制位是0，IR将操作码解码输出给CON；CON信号中EA=1，LO=1，这样当CLK上升沿时，将A中的数据通过总线传输给O。同时D（LED等）显示O的内容（计算结果）。     第五阶段（T4），所有控制位是0。     第六阶段（T5），所有控制位是0。 阶段 CP EP LM ER LI EI  LA EA SU EU LB  LO 功能 T3 0  0  0  0 0  0  0  1 0  0  0  1 OUT = A T4 0  0  0  0 0  0  0  0 0  0  0  0 空操作 T5 0  0  0  0 0  0  0  0 0  0  0  0 空操作 HLT指令     HLT指令，将通知CON停止计算。这个操作将通过CON产生关闭时序脉冲来实现。 四．电路 Ø        CON 控制器是计算机操作执行指令的关键部件。 l        指令解码器 指令解码器解析从IR寄存器发送的操作码，也就是IR的高四位。电路图如下， LDA = 非I7·非I6·非I5·非I4 ADD = 非I7·非I6·非I5·I4 SUB = 非I7·非I6·I5·非I4 OUT = I7·I6·I5·非I4 HLT = I7·I6·I5·I4 I7 I6 I5 I4 = 0000时， LDA = 1，ADD=0，SUB=0，OUT=0，HLT=0； I7 I6 I5 I4 = 0001时， ADD = 1； I7 I6 I5 I4 = 0010时， SUB = 1； I7 I6 I5 I4 = 1110时，OUT = 1； I7 I6 I5 I4 = 1111时，HLT = 1。 l        控制器矩阵 从指令解码器解析出来的LDA、ADD、SUB、OUT和循环计数器的输出（T0、T1、T2、T3、T4、T5）共同来解析这个控制矩阵，矩阵的输出为CON信号：CP EP LM ER  LI EI LA EA  SU EU LB LO。 在控制矩阵中， CP = T2 EP = T0 LM = T0 + ( LDA· T3 ) + (ADD· T3) +（SUB· T3） ER  = T1+ ( LDA· T4 ) + (ADD·T4)+（SUB· T4） LI  = T1 EI  = ( LDA·T3 ) + (ADD·T3) +（SUB·T3） EA  = ( LDA·T4 ) + (ADD·T5) +（SUB·T5） LA  = OUT· T3 SU = SUB ·T5 EU = ( ADD· T5 ) + (SUB· T5) LB = ( ADD· T4 ) + (SUB· T4) LO = OUT · T3 取指周期 当T0是高电平时，EP=1，LM=1。其他控制信号为0； 当T1是高电平时，ER=1，LI=1，其他控制信号为0； 当T2是高电平时，CP=1，其他控制信号为0。 执行周期 以LDA为例，即LDA=1。 当T3是高电平时，LM=1，EI=1。其他控制信号为0。 当T4是高电平时，ER=1，EA=1。其他控制信号为0。 当T5是高电平时，所有控制信号为0。 ADD、SUB、OUT取指周期的分析过程与LDA相同。   循环计数器、指令解码器、控制矩阵的连接关系如下： Ø        PROM ROM相当于很多的寄存器。 ROM可以使用二极管阵列来存取数据。使用解码器来存期ROM中的数据。 ROM实现的电路图如下： ROM电路图     在电路图中，当A2 A1 A0 = 000时，选中0号与门，输出为1，1-7号与门输出为0。 因此，二极管矩阵中第一行有二极管的位置将处于导通状态，输出为1，其他位置输出为0。输出结果0001。 在proteus中的仿真结果如下图，红色代表高电平，蓝色代表低电平。     Ø        ALU 半加器 二进制半加器电路图 SUM = A⊕B CARRY = A·B 半加器真值表     A B CARRY SUM 0 0 0 0 0 1 0 1 1 0 0 1 1 1 1 0   全加器 二进制全加器电路图 SUM = A⊕B⊕C CARRY = ( A·B ) + ( B·C ) + ( A·C )     A B C CARRY SUM 0 0 0 0 0 0 0 1 0 1 0 1 0 0 1 0 1 1 1 0 1 0 0 0 1 1 0 1 1 0 1 1 0 1 0 1 1 1 1 1 而四位二进制全加器结果如下 ALU可以执行加法和减法操作。为了设计的电路简单，ALU对补码进行运算。SUB为加减法标志。当SUB=1时，执行减法操作，当SUB=0时，执行加法操作。四位ALU的电路图所下：   Ø        PC PC使用带使能端的计数器实现 在proteus中，使用74161来实现。74161为4位二进制计数器，计数范围为0000—1111。 电路图如下，CP为使能端。CLK是脉冲输入端，CLR是清空计数器，EP是输出使能端。当CP=1时，76161开始计数，CP=0时，76161停止计数。 CLR=1时，清空计数器，CLR为异步清空。 EP=1时，将输出数据，EP=0时，输出处于断开状态。 Ø        A 寄存器A使用两个四位寄存器4076实现。 Ø        B、IR、MAR、O这四个寄存也使用4076实现。   五．在Proteus软件仿真 电路图所用的proteus版本是7.1sp2，电路图的下载地址如下： http://user.qzone.qq.com/457204657#!app=905&url=http%3A%2F%2Fqzs.qq.com%2Fqzone%2Fapp%2FqzoneDisk%2FqzoneDisk.html%23qz_height%3D920%26qz_width%3D950%26uin%3D457204657%26pfid%3D2%26qz_ver%3D6%26appcanvas%3D1%26qz_style%3Dv6%2F88%26params%3D%26entertime%3D1356499239203%26canvastype%3D SAP-1全局图 PC   MAR   ROM     IR   CON   A   ALU   B   O  ","title":"[置顶] 计算机SAP-1 设计与实现（2）"},{"content":"    Microsoft Enterprise Library中的Exception Handle模块主要用来处理程序中的异常错误，它的实现原理为遮罩模式：不让敏感的信息泄露。类似Logging模块，我们也可以通过Configuration程序便捷的对它进行配置。     Exception Handle模块默认为我们提供了多种异常处理功能：Wrap Handler，Replace Handler，Logging Handler，Fault Contract Exception Handler，Custom Exception Handler。在日常应用中，我们都会将它们组合使用，发挥它们的整体效果。它们的功能分别为：     Wrap Handler：包装原始错误，以达到过滤敏感数据的效果。     Replace Handler：替换原始错误，并给出一个新的错误。     Logging Handler：纪录原始错误的相应信息。     Fault Contract Exception Handler：捕捉具体的协议错误，该异常处理功能主要用在WCF Service上。     Custom Exception Handler：自定义错误处理模块，也就是说我们可以实现自己的错误处理程序。   Wrap Handler             //Warp Exception            try            {                int a = 10;//int.Parse(Console.ReadLine());                int b = 0;//int.Parse(Console.ReadLine());                int c = a / b;                Console.WriteLine(string.Format(\"{0}/{1}={2}\", a, b, c));            }            catch (Exception ex)            {                Exception exceptionToRethrow;//=new Exception(\"what's up\");                ExceptionManager exManager = EnterpriseLibraryContainer.Current.GetInstance<ExceptionManager>();                bool rethrow = exManager.HandleException(ex, \"Divide Exceptions\", out exceptionToRethrow);                if (rethrow)                {                    Console.WriteLine(exceptionToRethrow.Message);                }            } 配置信息   Replace Handler + Logging Exception Handler             //Replace Exception            try            {                throw new System.Data.DataException(\"abc\");            }            catch (Exception ex)            {                Exception exceptionToRethrow;                ExceptionManager exManager = EnterpriseLibraryContainer.Current.GetInstance<ExceptionManager>();                bool rethrow = exManager.HandleException(ex, \"DB Exceptions\", out exceptionToRethrow);                if (rethrow)                {                    throw exceptionToRethrow;                }            } 配置信息    Fault Contract Exception Handler             try            {                WCF.HelloClient client = new WCF.HelloClient();                client.DoWork();            }            catch (FaultException ex)            {                var faultDetail = ex.CreateMessageFault();                SimpleExceptionHandlerDemoInWCF.FaultMessage faultMessage=null;                if (faultDetail.HasDetail)                {                    faultMessage=faultDetail.GetDetail<SimpleExceptionHandlerDemoInWCF.FaultMessage>();                                    }                if (faultMessage != null)                {                    Console.WriteLine(string.Format(\"ID:{0}|Message:{1}|Detail:{2}\",faultMessage.ID,faultMessage.Message,ex.Message));                }                            } WCF Service代码     [ServiceContract]    public interface IHello    {        [OperationContract]        FaultMessage DoWork();    }    [ExceptionShielding(\"wcfexception\")]    public class Hello : IHello    {        public FaultMessage DoWork()        {            throw new NotImplementedException();        }    }    [DataContract]    public class FaultMessage    {        [DataMember]        public Guid ID{get;set;}        [DataMember]        public string Message{get;set;}    }     配置信息     Custom Exception Handler             //Test custom exception handler            try            {                throw new Exception(\"ok\");            }            catch (Exception ex)            {                Exception latestException = null;                ExceptionManager exManager = EnterpriseLibraryContainer.Current.GetInstance<ExceptionManager>();                bool reThrow = exManager.HandleException(ex, \"customexceptionhandler\", out latestException);            }   Custom Exception Handler 实现代码 namespace SimpleExceptionHandlerDemo{    using System;    using System.Windows.Forms;    using System.Collections;    using System.Collections.Specialized;    using System.Collections.Generic;    using System.Linq;    using System.Text;    using Microsoft.Practices.EnterpriseLibrary.Common;    using Microsoft.Practices.EnterpriseLibrary.Common.Configuration;    using Microsoft.Practices.EnterpriseLibrary.ExceptionHandling;    using Microsoft.Practices.EnterpriseLibrary.ExceptionHandling.WCF;    using Microsoft.Practices.EnterpriseLibrary.ExceptionHandling.Configuration;    using Microsoft.Practices.Unity;    using Microsoft.Practices.Unity.Configuration;    /// <summary>    /// TODO: Update summary.    /// <\/summary>    ///     [ConfigurationElementType(typeof(CustomHandlerData))]    public class MessageBoxCustomExceptionHandler:IExceptionHandler    {        public MessageBoxCustomExceptionHandler(NameValueCollection keys)        { }        public Exception HandleException(Exception exception, Guid handlingInstanceId)        {            MessageBox.Show(exception.Message, \"Error\", MessageBoxButtons.OK, MessageBoxIcon.Error);            return exception;        }    }} 配置信息     小结    一个错误类型能具有多个错误处理者，可以参考Replace Exception Handler+Logging Exception Handler小节，系统是按从上至下的顺序进行处理的。所以在这里Logging Exception Handler记录的错误信息是被Replace Exception Handler处理后的信息。  ","title":"Microsoft Enterprise Library: Exception Handle 模块"},{"content":"       hadoop将mapReduce的输入数据划分为等长的小数据块，称为输入分片或者分片，hadoop为每个分片构建一个map任务。        hadoop在存储有输入数据（HDFS中的数据）的节点上运行map任务，可以获得高性能，这就是所谓的数据本地化。所以最佳分片的大小应该与HDFS上的块大小一样，因为如果分片跨越2个数据块，对于任何一个HDFS节点（基本不肯能同时存储这2个数据块），分片中的另外一块数据就需要通过网络传输到map任务节点，与使用本地数据运行map任务相比，效率更低！！！","title":"为什么分片大小需要与HDFS数据块大小一致"},{"content":"按照《数字计算机电子学》Digital Computer Electronics）中SAP-1的设计，使用proteus仿真了SAP-1（simple as possible）计算机。能完成这个工作，首先要感谢网友杨志雄先生对我的帮助，他帮我解决了很多电路和使用proteus的问题。 一. 系统架构 按冯·诺依曼型结构，计算机由运算器、控制器、存储器、输入设备、输出设备组成。运算器和控制器组合称为中央处理部件或CPU。 CPU的基本功能，是执行事先存放在主存储器中的程序。而控制器的任务，是识别、解释和控制（其他所有部件）执行程序中的每一条指令，并使整个系统运行在高度同步协调的状态。运算器的功能是完成算术和逻辑运算。存储器用来存储程序和数据。 为了解决实际问题，需要计算机执行人们为解改问题而编制的程序。为存储和执行程序，要求系统有足够的存储空间和可以接受的执行时间。从解题的角度看，作为系统的一个重要组成部分的存储器，必须在存储容量和存取速度方面达到系统总体设计的要求。理想的存储器，应当是大容量、高速度、低成本。为了发挥各种不同类型存储器的长处，避开其弱点，应把它们合理地组织起来，这就出现了存储系统层次结构的概念。实际计算机系统中的存储器层次结构如下图所示。       计算机中为什么要采用总线呢？主要目的是减少传输线总数以简化I/O系统的结构。例如有n个k位的部件相互要进行通信，如果不采用总线结构而直接采用传输线互连起来，那么在一般情况下，n个部件必须以所有可能的方式连接，需要的专用通路数目为[（n-1）*n]/2，而每条通路为k位，则传输线位数总数为[k*（n-1）*n]/2；若n、k很大，则传输线总位数多的惊人。构成总线的位传输线的总数称为总线宽度。采用共享总线结构，n个k位部件要相互进行通信，只需要宽度为k为的总线就可以，且与n的大小无关，这就大大节省了传输线成本。 如果计算机采用单总线结构，架构如下图： 单总线结构 SAP-1架构图：            在SAP-1中， 控制器包括：CON、PC、IR。存储器包括：MAR，PROM。运算器包括：累加器A、寄存器B，ALU。输出包括：输出寄存器O、LED显示D。输入需要在计算机运行前，使用开关将数据存储到PROM中。 其中累加器A、寄存器B属于存储系统，完全可以用PROM代替，而使用寄存器是了提高访问速度。MAR（存储器地址寄存器）缓存了PROM的地址，也是为了提高速度。IR用于缓存正在执行或即将执行的指令同样为了提高访问速度。 Ø        PC(程序计数器) PC寄存器用于存储当前指令在ROM中的地址。在SAP-1中，PC为4位计数器，计数范围为0000——1111。当计算机运行之前，PC重置为0000。 Ø        IR（指令寄存器） IR用于存放正在执行或即将执行的指令，将指令的操作码部分传送给CON，操作数部分通过总线传输到MAR。 Ø        控制单元（CON）     在SAP-1中，控制器包括。其中CON的功能包括 1.    产生时序脉冲信号CLK，CLK将同步计算机中各个部件的运行。 2.    发送清除指令CLR，计算机运行之前，发送CLR给PC和IR，这样使IR的内容清空，PC重置 0000。 3.    根据IR中的操作码，产生一个12位控制信号 CP EP LM ER  LI EI LA EA  SU EU LB LO。（取指周期不需要操作码） 这些控制信号定义了各个寄存器在CLK的上升沿到达时的动作。例如，CP=1，代表在CLK上升沿到达时，PC将会加1。EP=1，LM=1，意味着，PC的内容会加载到MAR中。 Ø        MAR（存储器地址寄存器） 在访问存储器时，缓存存储单元的地址。在SAP-1中，MAR为4位寄存器。 Ø        PROM（可编程只读存储器） 存储器用于存储程序和数据。 在SAP-1中，PROM大小是16*8，意思是他有16个8位的存储单元，因此PROM的存储地址为0000——1111。程序需放在以0000开始的地址空间，数据需放在程序的后面。因为PC计数从0000开始，计算机运行后，首先从PROM的0000地址读取数据，所以程序必须存从0000开始存放。   Ø        累加器A 累加器A，是一个8位二进制寄存器，专门用来存放操作数或运算结果。在CPU执行某种运算前，两个操作数中的第一个放在累加器A中，运算完成后，累加器A中便可得到运算结果。 Ø        寄存器B 寄存器B也是一个8位二进制寄存器，该寄存器，用来存放加数或减数。 Ø        ALU ALU用于完成算术运算。在SAP-1中，SU=1时，ALU执行减法操作，A=A-B；SU=0时，ALU执行加法操作，A=A+B。为了简化ALU的设计，SAP-1中的数据是补码形式。因此PROM、A、B、O中的数据是以补码形式存放的。 Ø        输出寄存器O 当运算结束后，累加器A中存储计算结果。当EA=1，LO=1，下一个CLK上升沿到达时，寄存器A的内容通过总线到达输出寄存器O。 Ø        LED显示D D是一排8个LED灯构成的，而LED灯连接了输出寄存器O，LED将输出寄存器O的内容。当执行OUT指令后，我们将看到二进制补码形式的答案。 Ø        总线（W bus） 在SAP-1中，总线是8位的。跟总线连接的如果是部件的输出需要使用三态门，如果是部件的输入使用使能端控制是能否输入。 三态门 当ENABLE = 0时，相当于Din与Dout处于断开状态。 当ENABLE = 1时，Dout = Din。         例如，寄存器A、B、C、D之间使用总线传输数据，如下图所示。 总线     其中，A、B、C、D的输出通过三态门与总线相连。LOAD为输入使能端，LOAD=1时，输入端数据存入寄存器。LOAD=0时，不接收输入数据。ENABLE为输出使能端（为三态门使能端），ENABLE=0时，寄存器与总线连接处于断开状态。ENABLE=1时，寄存器与总线处于连接状态，寄存器的输出会输出到总线上。     在本例中，如果寄存器中存储的数据为         A = 0011  B = 0110  C = 1001  D = 1100     如果需要将寄存器C的数据传送到B，只要使EC = 1， LB = 1，这样会使寄存器C的内容传送到总线，同时寄存器B的输入使用端 ENABLE = 1，会将连接到总线输入端的数据存入寄存器中。当CLK的上升沿到达时，寄存器B=1001。 二．指令 指令，是计算机硬件和软件的接口。计算机软件通过编制程序来解决问题。程序为指令序列或被翻译成指令序列。而计算机硬件的功能是执行指令序列。因此计算机硬件设计的最终目的是设计指令，并实现这些指令。 机器指令集像餐馆的菜单。如果顾客想吃饭，拿到餐馆的菜单，写出自己想吃的菜；而厨师按照顾客的菜单做菜。这样顾客就能吃到自己想吃的菜了。顾客吃到想吃的菜是计算机需要实现的功能，首先顾客写出菜单，就是编制程序，餐馆菜单中的每一道菜是一条指令，整个菜单是机器的指令集。而厨师拿到顾客的菜单，看到自己需要做的菜，然后按顺序作出这些菜。厨师就相当于硬件，按顺序执行顾客菜单指令。 在SAP-1中，只有五条指令，下面将对五条指令分别介绍。 Ø        LDA（load the accumulator） LDA将数据加载到累加器A。格式为，LDA R*(ROM地址)。例如，加载ROM中R8的数据。R8中的数据为, R8 = 1111 0000。指令为 LDA R8(地址) Ø        ADD ADD将数据与累加器A中的数据相加，结果放在A中。 格式：ADD  R*。例如，ADD R9意思是“将 R9中的数据与A中的数据相加，结果放在A中”。下面用实际数据来说明，A中的数据为2，R9中的数据为3，用二进制的形式表示为，                             A = 0000 0010                            R9 = 0000 0011 ADD指令的执行过程，首先, R9被加载到 B中，因此B的内容如下，                            B = 0000 0011 随后，ALU完成了Ａ＋Ｂ的计算（由于ALU不需要CLK同步），                            ALU = 0000 0101 然后, ALU内容被加载到累加器A中，                            A = 0000 0101 这样A中最终存储了运算结果。 Ø        SUB SUB将累加器A中的数据减去PROM中的某个数据，结果放在A中。 格式：SUB R* 处理过程参考ADD Ø        OUT OUT指令将A寄存器中的数据传输到O寄存器中。 格式： OUT Ø        HLT HLT代表停机。 格式: HLT 在SAP-1的程序末尾必须使用HLT指令，否则计算机会崩溃，因为SAP-1将取出ROM中存储在程序后面的无意义数据进行执行，所以会得到无意义的结果。   指令编码表 如果想将上面这些指令在SAP-1中存储，执行，需要将他们用二进制编码。 指令名称 编码 LDA 0000 ADD 0001 SUB 0010 OUT 1110 HLT 1111   下面举例说明如何给SAP-1编程，比如计算 16 + 20 + 24 + 28 – 32的值。 可以16存储到R9中，20存储到RA中，24存储到RB中，28存储到RC中，32存储到RD中。其中R*为ROM地址，例如R9为ROM中编号为1001的地址。 ROM中存储的程序和数据如下： 程序： R0 = 0000 1001    ( LDA 9(地址) ) R1 = 0001 1010    ( ADD A(地址) ) R2 = 0001 1011    ( ADD B(地址) ) R3 = 0001 1100    ( ADD C(地址) ) R4 = 0010 1101    ( SUB D(地址) ) R5 = 1110 ****     ( OUT ) R6 = 1111 ****     ( HLT ) 数据 R9 = 0001 0000     ( 16十进制 ) RA = 0001 0100     ( 20十进制 ) RB = 0001 1000     ( 24十进制 ) RC = 0001 1100     ( 28十进制 ) RD = 0010 0000     ( 32十进制 ) 下面的详细设计参见《 SAP-1设计与实现（2）》","title":"[置顶] 计算机SAP-1 设计与实现（1）"},{"content":"Linus大神实乃性情中人，口无遮拦。继称OpenBSD开发者是一帮自慰的猴子、  调侃digg用户是“手淫的海象”、以及 对 Nvidia 比中指爆粗 后，又有不懂事的人惹大神发怒了。 这回事由在于Linus认为Mauro违反了内核维护的基本原则。他的原话很好理解： 闭上你的臭嘴，Mauro！ 这明显是一个bug，Kernel中的bug！你做了多长时间的维护人员了，为什么还不明白Kernel维护的第一原则？ 如果修改会导致用户程序的破坏，那问题一定是在Kernel上！永远不可以归咎用户程序的责任，学会这点真的很难吗？ 更糟糕的是，commit f0ed2ce840b3虽然并没有破坏程序，但它完全是废话。 …… 永远不可以破坏USERSPACE！ 或许有人觉得Linus的批评太过严厉，但这也正反映出他对Kernel设计、维护原则的坚持，如果没有这种信念，相信Linux很难有今天的地位。希望各位程序员引以为戒！ http://thread.gmane.org/gmane.linux.kernel/1413835/focus=1414106 From: Linus Torvalds <torvalds <at> linux-foundation.org>  Subject: Re: [Regression w/ patch] Media commit causes user space to misbahave (was: Re: Linux 3.8-rc1)  Newsgroups: gmane.linux.kernel  Date: 2012-12-23 17:36:15 GMT (1 day, 17 hours and 45 minutes ago)  On Sun, Dec 23, 2012 at 6:08 AM, Mauro Carvalho Chehab  <mchehab <at> redhat.com> wrote:  >  > Are you saying that pulseaudio is entering on some weird loop if the  > returned value is not -EINVAL? That seems a bug at pulseaudio.  Mauro, SHUT THE FUCK UP!  It's a bug alright - in the kernel. How long have you been a  maintainer? And you *still* haven't learnt the first rule of kernel  maintenance?  If a change results in user programs breaking, it's a bug in the  kernel. We never EVER blame the user programs. How hard can this be to  understand?  To make matters worse, commit f0ed2ce840b3 is clearly total and utter  CRAP even if it didn't break applications. ENOENT is not a valid error  return from an ioctl. Never has been, never will be. ENOENT means \"No  such file and directory\", and is for path operations. ioctl's are done  on files that have already been opened, there's no way in hell that  ENOENT would ever be valid.  > So, on a first glance, this doesn't sound like a regression,  > but, instead, it looks tha pulseaudio/tumbleweed has some serious  > bugs and/or regressions.  Shut up, Mauro. And I don't _ever_ want to hear that kind of obvious  garbage and idiocy from a kernel maintainer again. Seriously.  I'd wait for Rafael's patch to go through you, but I have another  error report in my mailbox of all KDE media applications being broken  by v3.8-rc1, and I bet it's the same kernel bug. And you've shown  yourself to not be competent in this issue, so I'll apply it directly  and immediately myself.  WE DO NOT BREAK USERSPACE!  Seriously. How hard is this rule to understand? We particularly don't  break user space with TOTAL CRAP. I'm angry, because your whole email  was so _horribly_ wrong, and the patch that broke things was so  obviously crap. The whole patch is incredibly broken shit. It adds an  insane error code (ENOENT), and then because it's so insane, it adds a  few places to fix it up (\"ret == -ENOENT ? -EINVAL : ret\").  The fact that you then try to make *excuses* for breaking user space,  and blaming some external program that *used* to work, is just  shameful. It's not how we work.  Fix your f*cking \"compliance tool\", because it is obviously broken. And fix your approach to kernel programming.                 Linus","title":"Linus大神又怒了 呃...我为什么要说“又”？"},{"content":"随着C++ 11和C++ CX的引入，很多人重新燃起了对这门语言的兴趣。不少开发者，尤其是Windows开发者，都想知道是否应该放弃C#和Java，转而支持C++。John Sonmez认为这并不需要。 在“为什么C++并没有‘王者归来’（Why C++ Is Not ‘Back’）”一文中，John Sonmez认为只有如下三个原因才会使用C++： 需要榨干软件每一寸可能的性能，并且想用支持面向对象抽象的语言来实现。 编写直接面对硬件的代码。（例如，编写底层驱动。） 内存控制与定时极为重要，因而系统的行为必须是完全确定的，还必须能够手动管理内存。（想一下控制机器移动部件的嵌入式实时操作系统。） Herb Sutter高度称赞了这篇文章，认为文中的“观点有些深度，没有夸张”。关于C++的应用场景，他又做了一些补充： 服务，依赖于运行时会更为困难。 测试，对比一下全部或者大部分采用静态链接的应用程序与在最终用户机器上往往是首次执行时才编译或即时编译（JIT）的应用程序，后者无法完整地测试。 John Sonmez反对学习C++，过于复杂是原因之一。即使C++ 11让开发容易了一些，但是程序员仍然不得不学习各种老式的C++编码方法。“你会碰到20年前的C++代码，看起来就像是完全不同的语言。”为了加强其观点，他向准备应聘C++职位的开发者提出了36个问题。下面列出几条： 1.在C++中，基本数据类型有多少种初始化方式？你能都说出来吗？ 12.什么是复制构造函数，何时会用到？尤其是与赋值操作符相比，你能区分吗？ 16.在C++中，何时适合通过引用来返回值，何时不适合？ 33.为什么绝对不应该在析构函数中抛出异常？ 反对C++的另一个理由是“编程语言真正需要的是简化并提高抽象层次，而不是反其道而行之”。他继续道， 编写底层代码的需求总是存在的，但我们今天编写的大部分都是较高层次的代码。 很多年前，当我终于无法再坚持认为我用C++开发应用的速度比C#快时，我跳下了C++这条船。 我坚持良久，试图让自己相信我在C++上的所有投入并没有白费，但是事实证明， C#带来的简化是如此之大，以至于与此相比，C++所提供的额外的力量并不值得这些额外的付出。 在文章结尾，John Sonmez说到，学习C++对于理解计算机的一般工作原理仍然是有用的，“但是我认为C++不会东山再起，这是好事”。 关于这一点，Alo补充到： 我是从C++开始的，而且我职业生涯的前四年都花在了C++上。这种经验对我非常有价值，正如您的文章中所指出的那样，因为一旦把C++学到了足够的水平，就可以很快地捡起其他任何语言；此外，还能从一个更低的层次上更深刻地理解软件工作原理——如果从其他层次更高的语言开始学习编程，获得这种知识的难度就大多了。正因如此，我一直不赞成让程序员从Java开始学起。 Richard Dunks反驳到： 我认为，在第一学期的程序设计导论课程和数据结构的教学中，C++是没什么帮助的，因为光实现就要耗费很多时间，反而让同学们忽略了他们要复现的结构。我很高兴自己能够精通C++，但我认为这并不值得，而且C++绝对不是一门万能的教学语言。 Stephen Cleary有一条评论谈到了可重用性： 我原来是C++开发者，几年之前，市场的压力让我成了一名C#开发者。C#的确更有生产率，但是完全不可能实现C++模板那种级别的代码复用。 经典的例子就是容器、迭代器和算法这三驾马车。在C++中，能够创建一个用于任何容器的算法，而且可以在编译时对算法加以调整以便必要的情况下利用随机访问能力。你可以用C#试试。这还是尚未谈到“新C++”的情况；1998年的C++对代码复用的支持就比现在的C#好了。 关于性能，Herb Sutter给出了如下建议： 在任何语言中，如果非常关注性能，都会大量使用数组（未必“总是”使用，只是“大量”用到）。不过这在有些语言中很容易，可以很好地控制一般内存布局，特别是控制数组；而在其他语言或环境中就困难一些（有可能让你使用，但更为困难），如果这些语言或运行时特别偏爱通过指针构造的数据结构，你就不得不“放弃”或者“尽量避开”。 除了在Herb Sutter和John Sonmez的相关博客上的大量高质量评论，Reddit的Programming和Coding子群组也有很多可以学习的东西。","title":"开发者应该开始学习 C++ 了"},{"content":"我的新书的内容被我砍掉了两章，因为它们太让我觉得不堪。 我的员工发动暴动要除掉我，赶我走，他们败坏了公司的文化，使公司变成了权益为先的腐败温床，只关注他们自己的利益，而不是把客户放在第一位。那两章内容就是在发泄我对这些恐怖的员工的不满的细节。 多年之后，我仍然对这些邪恶的小子们的所作所为感到愤怒。就像所有感觉被做为牺牲品或被错怪的人一样，我需要渲泄——说出站在我的立场上的故事。或者是我认为的故事。 你想知道我砍掉这两种内容的真正原因吗？ 我认识到，这都是我的错。 是我，让公司的文化变得腐烂。 是我，置若罔闻，没能防患于未然。 是我，疏离群体，没有认真管理和培训中层干部。 是我，用不停变换的想法命令让他们困惑不堪，没能让他们参与决策的过程。 是我，只是发号施令，以为他们会照命令完成，没有跟进去检查完成情况。 是我，用人失误，没有在这方面用心。 (我还可以列出另外20条，但你应该知道我的意思了。) 认识到这完全是我的错，这种感觉真好！ 这是比宽恕更好的结果。如果你宽恕他们，说明你仍然认为自己是牺牲者，你认为仍然是他们的错，而你在慷慨的宽恕他们的恶行。 但当认定这是自己的错时，这种感觉很神奇！现在自己不是被错怪。他们只是在你创造的形势下做他们该做的事。他们只是在你编织的故事里添加高潮部分。 太强大了！现在我觉得自己变成了一个新的英雄，一下子发现了自己的强大之处。我就是那个强有力的人，让这一切发生了，自己犯了错误，然后从中学到了教训。完全在自己的掌握之中，没有任何可抱怨的。 这种价值观让人感觉是如此之好，我欣然的决定让我的余生都遵行“一切都是我的错”处事原则。 这种类似“人性本善”的思想，信比不信更有益，虽然有些例外的情况，但总比全然不信要好。 原谅那个偷走我9000美元的人吗？对，这是我的错。我早该认真对待他提出的诉求。 6年的恋人突然抛弃了我，原谅？对，这是我的错。是我让我们的关系停滞不前。 今天有人对我无礼了，原谅？对，是我的错。我事先应该让他们心情好一些。 不喜欢政府？我的错。我应该积极参政议政，去改变这个世界。 这是什么的力量？ 是的，用“用于承担责任”这个词更准确，但这是一个很严肃的6字短语，远不如“一切都是我的错”的经验论更有趣，而且我还可以吟唱nirvana的歌“都是我的错”。 试一下。起立，打开窗户，面向外面的世界，大声说，“一切都是我的错！” 当想起自己的倒霉不幸的事情时，对自己说一遍。 神奇，不是吗？ 这种力量看起来对你有好处。","title":"员工造反 —— 原来都是我的错"},{"content":"JihadBird 11:46:42 老师，您好 在线吗？ 青润  11:46:50 在。 JihadBird 11:47:32 目前大家公认的这种面向对象分析设计思路，应该只是所有设计思路中的一种吧？ 就是比较优秀的一种，是吧？ JihadBird 11:49:50 因为往我以前的传统思路上套的话，感觉套不上。我以前的思路是：应用逻辑、业务逻辑相互掺杂在一起，也没有实体类，数据直接通过界面元素获取，业务逻辑直接就是拼凑SQL执行的。   但是从即便用新的设计思路重构它的话，从程序运行效果上也看不出什么异同。 青润  11:51:04 未必是最优秀的。 人类创造的每一种设计思路和方法都有其适应的环境。 JihadBird 11:47:32 目前大家公认的这种面向对象分析设计思路，应该只是所有设计思路中的一种吧？ 就是比较优秀的一种，是吧？ 你的第二个问题，说的是面向过程的开发方法吧？ 这两者的区别应该在我的书中有详细的介绍，如果没有那就是在我曾经的培训中做过很明确的区分介绍。 JihadBird 11:58:29 同一个系统，我可以采取如下两种方法：   1、应用逻辑、业务逻辑相互掺杂在一起，也没有实体类，数据直接通过界面元素获取，业务逻辑直接就是拼凑SQL执行的。   2、应用逻辑、业务逻辑分离、通过实体对象在各层之间传递数据。   还是第二种最好，代码可以公用，各层隔离，很清晰。 青润  11:59:24 这个和设计方法无关，和你的系统设计构成有关，每个设计师都可以有自己习惯用的方法，并不代表哪一种一定更优秀，关键在于适用场合。 青润  12:00:55 你认为各层很清晰的设计，在一些业务系统实现中，就会形成过度复杂的业务层间调用关系，使得业务逻辑表现的特别复杂。 就类似于管理制度，管理制度明晰的公司，往往缺少变通，也就是说容易僵化教条，但是整体管理效率会比大多数公司都好。但是管理制度不明晰的公司，就类似于你说的第一种，对于一些需要快速处理的事务，就可以达到非常高效的效果。 JihadBird 12:01:06 是的 分得越细，在协调上浪费的时间就越多。 青润  12:02:54 所以，要明白自己要做的系统是什么，然后因地制宜，灵活应用，这才是软件工程的本质。 我的很多文字中多次提到反对本本主义，就是看到国内绝大多数公司都是本本主义的尊崇者，实在是国内软件项目失败的重要因素之一。 JihadBird 12:03:59 是的，都是因为大家没有到灵活运用的级别，还处在低级的教条阶段。 青润  12:04:48 所以，我的书能看懂的，感兴趣的人就很少。 JihadBird 12:05:53 佩服，您一直做技术培训？ 青润  12:06:35 做的不多，只是根据情况，认可我的技术和培训的朋友介绍。","title":"[技术讨论]什么是最好的软件设计方法"},{"content":"据国外科技博客科技博客AllThingsD报道，2012年是谷歌企业业务高速发展的一年，该公司副总裁阿米特·辛格回顾了全年的发展脉络，并对2013年进行展望，他表示，谷歌云计算软件将占领90%的微软Office市场。 对谷歌的企业业务来说，2012年是重要的一年，因为他们推出了Google Drive和云计算平台。此外，谷歌企业应用套件——一款基于Web的Office应用程序已经开始正面与微软Office竞争。目前，越来越多的公司已经接受谷歌的做法，与此同时，微软则在今年早些时候相应了推出具有竞争力的SkyDrive。谷歌和微软在软件方面的竞争进入白热化。谷歌副总裁阿米特·辛格接受了记者的访问，对这一问题进行阐述。 辛格说，谷歌已经打破了行业壁垒，争取到很多大客户，罗氏公司和西班牙对外银行等制药和银行企业成为最先采用谷歌软件的机构。迪拉兹、科尔、家得宝，以及上个月公布的好市多等零售企业也成为谷歌企业软件的主要客户。在过去一年，谷歌企业业务的合作伙伴数量从3000个增长到6000个。 谈到谷歌企业业务的优势，辛格认为，客户的信任是谷歌产品销售的保障。谷歌的产品在安全性和兼容性方面均优于业内竞争对手。而且，谷歌推出了新一代的Chromebooks，在网络建设方面存在无可比拟的优势，也让客户对他们的产品和服务充满信心。 相对于微软的SyDrive和新版本Office软件，谷歌推出的Compute Engine云计算平台的速度更快，可靠性更高，服务的针对性也更强。这款产品的主要目的是“吸引90%并不需要Office大部分先进功能的用户。”此外，谷歌还发布了下一代Chromebook笔记本电脑，并推出了首款面向企业用户的PC设备Chromebox。 目前，谷歌已从向企业提供产品和服务的5项业务中获得近10亿美元营收，不过这仅仅占谷歌总营收的4%。谷歌大部分营收仍来自广告。 辛格表示，2013年谷歌将突出产品的定制化和人性化，提高云计算企业软件的普及率，希望在这一市场超过微软，取得领先地位。","title":"2013年 谷歌欲在云计算市场战胜微软"},{"content":"近日，淘宝“暴动”风波经商务部出面“劝架”之后只消停了几天，又有升级迹象。怨气未消的中小商户们将战线转移到支付宝，声称支付宝私自挪用客户资金用于放贷，并鼓动用户集体提现攻击支付宝。反淘宝联盟认为，这将造成支付宝资金断裂，从而击垮支付宝。为什么淘宝的商户们对马云会如此不依不饶，有这么大的“恨劲”呢？笔者以为，是马云式的“粗暴”惹了这场祸。 　　在商言商，从商得利，无可厚非。淘宝对经营的商品或者服务内容定价属于其经营自主权。但是，自负自大的马云犯了一项商家大忌——践踏和凌辱了中国“和气生财”的古训，用君临天下的气势和咄咄逼人的手段，粗暴地发号施令，意欲在自已的电商王国为所欲为。 　　事件缘起马云下令淘宝商城修改规则，大幅提价，激恼了商家。这种提价，不是10%，也不是翻一番，而是提价5-10倍。虽说中国正处于高通胀经济周期，但也只有5%左右的通胀率，这么大翻跟斗式的涨价令人匪夷所思。想当年，正是中国的几十万中小商户响应马云的“爱国”号召，与长驱直入的大鳄eBay决一雌雄，屠龙成功，才使淘宝后来居上，可以说是万千小商户把马云抬上了中国电商的王座。如今，马云过河拆桥，怎不让商户们气愤？此为马云“粗暴”之一。 　　你出价我还价，是最正常不过的商场游戏规则。即使讲不成价，也会是“生意不成仁义在”。可到了马云这里，商场游戏规则全乱套。他这个“运动员”，摇身变成了说一不二的“裁判员”，只许自己出价，不许商户还价，“生意不成就滚蛋”。在众多小商户面临倾家荡产之灾面前，马云仍厉言正色，并口出狂言：“我们不是道德模范。”他视众商户为草芥，根本不把“衣食父母”放在眼里。此为马云“粗暴”之二。 　　马云的粗暴还有其性格的内在因素。由于犯了众怒，加之商务部出面斡旋调停，马云不得不强压怒火作出让步。后来，他公开说，当他出席那场宣布推迟执行新规的发布会时，他在自已的手心上写满了“忍”字，而同事也十分担心他会在会上“乱发脾气”。 　　俗话说，官当大了，脾气见长。马云这些年随着淘宝和阿里的成功，声名鹊起，己经成为全球互联网数一数二的大佬。他的脾气也已明显“见长”，颐指气使，独行独断。君不见前不久，他对新员工发号施令，一是要其闭嘴，嘴上没毛别谈什么战略；二是请滚蛋，我的话你不听，就另谋活路吧！看到他发给员工的内部电邮，怪不得有人说脊背上阵阵发凉。此为马云“粗暴”之三。 　　粗暴，是为商者之大忌。马云曾不断宣扬要维护互联网生态平衡，但这个“平衡”绝不是用马云式的粗暴可以“维护”的。中国电子商务是怎么成长起来的？想必马云心里很清楚，前辈如瀛海威与8848，早就是浮云了。市场竞争，大浪淘沙，优胜劣汰，这是规律。但切不可粗暴从事，始终需要保持一颗平常心，才能防止在商场栽跟头。","title":"粗暴\"让马云栽了个大跟"},{"content":"项目应用本地化我们不是创造多一个项目来解决问题！ 微软早就有本地化支持的资源文件。 步骤1： 打开VS2010 ------ 文件 ------ 新建项目 ------选择MVC3.0 创建一个新的项目 步骤2： 创建一个放本地化的文件夹并命名为Lang（当然您可以放在其他类库中,如Common通用类库） 右键添加新项 选择资源文件并命名为Com 把访问修饰符从Internal设置为Public公开出来，要不其他类库引用不了 步骤3： 同样道理在Lang下新建一个Com.en-US.resx的资源文件，这都是微软定义的 en-US为英文的 zh-CH为中文 还有繁体,其他类型的，我们可以参考国际定义，这里就不一一列举 在文件里面我们 我们看到里面有名称和值，稍后使用就明白了 步骤4： 添加国际化值Com.resx  (这里么有zh-Ch默认为zh中文) 名称：Create 值：创建 名称：Edit   值：修改 添加国际化值Com.en-US.resx   名称：Create 值：Create 名称：Edit   值：Edit 步骤5： 提供系统处理事件 在Lang新建类CultureAwareHttpModule.cs并添加以下代码 using System;using System.Collections.Generic;using System.Linq;using System.Web;using System.Web.Routing;using System.Globalization;using System.Threading;namespace YmNetsProject.Lang{    public class CultureAwareHttpModule : IHttpModule    {        private CultureInfo currentCulture;        private CultureInfo currentUICulture;        public void Dispose() { }        public void Init(HttpApplication context)        {            context.BeginRequest += SetCurrentCulture;            context.EndRequest += RecoverCulture;        }        private void SetCurrentCulture(object sender, EventArgs args)        {            currentCulture = Thread.CurrentThread.CurrentCulture;            currentUICulture = Thread.CurrentThread.CurrentUICulture;            HttpContextBase contextWrapper = new HttpContextWrapper(HttpContext.Current);            RouteData routeData = RouteTable.Routes.GetRouteData(contextWrapper);            if (routeData == null)            {                return;            }            object culture;            if (routeData.Values.TryGetValue(\"lang\", out culture))            {                try                {                    Thread.CurrentThread.CurrentCulture = new CultureInfo(culture.ToString());                    Thread.CurrentThread.CurrentUICulture = new CultureInfo(culture.ToString());                }                catch                { }            }        }        private void RecoverCulture(object sender, EventArgs args)        {            Thread.CurrentThread.CurrentCulture = currentCulture;            Thread.CurrentThread.CurrentUICulture = currentUICulture;        }    }} 在web.config的system.web标签添加 <httpModules>          <add name=\"CultureAwareHttpModule\" type=\"YmNetsProject.Lang.CultureAwareHttpModule,YmNetsProject\"/>      <\/httpModules> 在Global.asax.cs注册路由   public static void RegisterRoutes(RouteCollection routes)        {            routes.IgnoreRoute(\"{resource}.axd/{*pathInfo}\");            routes.MapRoute(                \"Globalization\", // 路由名称                \"{lang}/{controller}/{action}/{id}\", // 带有参数的 URL                new { lang = \"zh\", controller = \"Home\", action = \"Index\", id = UrlParameter.Optional }, // 参数默认值                new { lang = \"^[a-zA-Z]{2}(-[a-zA-Z]{2})?$\" }    //参数约束            );            routes.MapRoute(                \"Default\", // 路由名称                \"{controller}/{action}/{id}\", // 带有参数的 URL                new { controller = \"Home\", action = \"Index\", id = UrlParameter.Optional } // 参数默认值            );        } 添加Home控制器，并添加index视图 在视图添加以下代码 @{    ViewBag.Title = \"Index\";    Layout = \"~/Views/Shared/_Layout.cshtml\";}<h2>@YmNetsProject.Lang.Com.Create<\/h2><h2>@YmNetsProject.Lang.Com.Edit<\/h2> 运行后我们可以看到通过地址我们完成了一次国际化 示例代码下载","title":"构建Asp.net MVC3项目之旅（8）-MVC3多语言版,本地化,国际化"},{"content":"Garlan和Shaw对通用体系结构风格的分类： 数据流风格：批处理序列；管道/过滤器 调用/返回风格：主程序/子程序；面向对象风格；层次结构 独立构件风格：进程通讯；事件系统 虚拟机风格：解释器；基于规则的系统　 仓库风格：数据库系统；超文本系统；黑板系统 每一大类风格中会包含许多子风格，这些子风格有时候也被称之为架构模式。这些风格并不是彼此孤立，互相对立的，而是相互联系的。做设计的时候往往是几种风格一起使用。 另外，这也不是唯一的分类方式，在《面向模式的体系架构》中，就把体系结构模式分成以下4类： 结构化系统：层、管道与过滤器、黑板 分布式系统：代理者 交互式系统：MVC ，PAC（presentation-abstraction-control） 适应式系统：微核、映射 每个大类下面又有若干小类，这些子分类与Garlan和Shaw的分类中的子风格有很多重合之处。 我觉得，对体系结构这种本身就比较庞大和抽象的概念来说，只需要知道大概有那么写类别就可以了，至于怎么分类，可以不去细究。毕竟，每种分类都有其道理。","title":"体系架构风格与模式"},{"content":"Magento supports tier prices feature and it allows the actual price to be determined by the quantities. This is a common sale promotion technique used by lots of Magento store owners. Mageno product model Mage_Catalog_Model_Product has two methods which are related to tire prices: /**     * Get product tier price by qty     *     * @param   double $qty     * @return  double     */    public function getTierPrice($qty=null)    {        return $this->getPriceModel()->getTierPrice($qty, $this);    }    /**     * Count how many tier prices we have for the product     *     * @return  int     */    public function getTierPriceCount()    {        return $this->getPriceModel()->getTierPriceCount($this);    }From above-mentioned methods, we know that product's tire prices is determined by price model. Magento uses price factory design pattern to cover all kinds of product types: simple, configurable,group, virtual, downloadable.  public function getPriceModel()    {        return Mage::getSingleton('catalog/product_type')->priceFactory($this->getTypeId());    }class Mage_Catalog_Model_Product_Type is a helper or utility class which can get all the product types information from configuration file and database.     public static function priceFactory($productType)    {        if (isset(self::$_priceModels[$productType])) {            return self::$_priceModels[$productType];        }        $types = self::getTypes();        if (!empty($types[$productType]['price_model'])) {            $priceModelName = $types[$productType]['price_model'];        } else {            $priceModelName = self::DEFAULT_PRICE_MODEL;        }        self::$_priceModels[$productType] = Mage::getModel($priceModelName);        return self::$_priceModels[$productType];    } <product>\t<type>\t\t<simple translate=\"label\" module=\"catalog\">\t\t\t<label>Simple Product<\/label>\t\t\t<model>catalog/product_type_simple<\/model>\t\t\t<composite>0<\/composite>\t\t\t<index_priority>10<\/index_priority>\t\t<\/simple>\t\t<grouped translate=\"label\" module=\"catalog\">\t\t\t<label>Grouped Product<\/label>\t\t\t<model>catalog/product_type_grouped<\/model>\t\t\t<price_model>catalog/product_type_grouped_price<\/price_model>\t\t\t<composite>1<\/composite>\t\t\t<allow_product_types>\t\t\t\t<simple/>\t\t\t\t<virtual/>\t\t\t<\/allow_product_types>\t\t\t<index_priority>50<\/index_priority>\t\t\t<price_indexer>catalog/product_indexer_price_grouped<\/price_indexer>\t\t<\/grouped>\t\t<configurable translate=\"label\" module=\"catalog\">\t\t\t<label>Configurable Product<\/label>\t\t\t<model>catalog/product_type_configurable<\/model>\t\t\t<price_model>catalog/product_type_configurable_price<\/price_model>\t\t\t<composite>1<\/composite>\t\t\t<allow_product_types>\t\t\t\t<simple/>\t\t\t\t<virtual/>\t\t\t<\/allow_product_types>\t\t\t<index_priority>30<\/index_priority>\t\t\t<price_indexer>catalog/product_indexer_price_configurable<\/price_indexer>\t\t<\/configurable>\t\t<virtual translate=\"label\" module=\"catalog\">\t\t\t<label>Virtual Product<\/label>\t\t\t<model>catalog/product_type_virtual<\/model>\t\t\t<composite>0<\/composite>\t\t\t<index_priority>20<\/index_priority>\t\t<\/virtual>\t<\/type><\/product> For simplicity, i prefer to use simple type product's price model to show you around.  class Mage_Catalog_Model_Product_Type_Price is the simple type product's default price model.     public function getTierPrice($qty = null, $product)    {        $allGroups = Mage_Customer_Model_Group::CUST_GROUP_ALL;        $prices = $product->getData('tier_price');        $custGroup = $this->_getCustomerGroupId($product);        if ($qty) {            $prevQty = 1;            $prevPrice = $product->getPrice();            $prevGroup = $allGroups;            foreach ($prices as $price) {                if ($price['cust_group']!=$custGroup && $price['cust_group']!=$allGroups) {                                        continue;                }                if ($qty < $price['price_qty']) {                                       continue;                }                if ($price['price_qty'] < $prevQty) {                                       continue;                }                if ($price['price_qty'] == $prevQty && $prevGroup != $allGroups && $price['cust_group'] == $allGroups) {                    // found tier qty is same as current tier qty but current tier group is ALL_GROUPS                    continue;                }                if ($price['website_price'] < $prevPrice) {                    $prevPrice  = $price['website_price'];                    $prevQty    = $price['price_qty'];                    $prevGroup  = $price['cust_group'];                }            }            return $prevPrice;        }        return ($prices) ? $prices : array();    }The logic is very apparently because it fetches the tire prices set up by admin panel and compares the quantity to get the corresponding price. ","title":"[置顶] How to calculate the tier prices in Magento"},{"content":"京东商城CEO刘强东与阿里巴巴集团主席马云又上演了新的续集。 　　继京东商城停用支付宝之后，刘强东10月24日在微博暗讽一淘网“鸡鸣狗盗”，未经允许私自抓取京东用户评论。一淘网也毫不含糊，迅速在微博接招，使得暗战迅速升级。 　　而苏宁易购等的加入，很容易让人联想起一份京东商城内部针对一淘网的竞争策略研究文档，其中建议京东应“高调宣布拒绝与一淘合作，并采取远交近攻的合纵联盟策略”。 　　不管是效仿还是结盟，一淘网触动的显然不仅仅是京东商城一家的神经。一淘网主打比价购物搜索，号称要做“全网购物入口”，目前其收录商家超过2700家，团购网站600多家。用户通过一淘网的比价功能，可以方便地找到商品价格最低的网站。 　　一淘网做“全网购物入口”是马云为防止其他B2C平台、独立B2C网站侵蚀淘宝市场份额而打出的防守牌，只要其在购买决策服务和搜索偏好上稍向淘宝商城倾斜，就可带来大量的收益。而即便一淘网对各家平等对待，也可为淘宝商城开辟一个淘宝网以外的单独入口，带来大量流量，有利于建立固定用户群。这对京东商城和苏宁易购等电商而言，有可能意味着大量用户的流失，不能不说是巨大的潜在威胁。 　　况且，对京东商城和苏宁易购而言，它们的竞争优势更多体现在综合服务能力方面，如京东商城丰富的产品、贴心的售后服务，都是其用户忠诚度高的重要原因，而苏宁易购出色的物流配送，则是其最大的优势。一淘网纯粹比价格，无形中让价格优势屏蔽了其他优势，可能会导致用户在搜索之后转向购买价格更低的商品。但综合服务能力方面的差异，一淘网并未给出相关的比较结果。对京东和苏宁易购而言，对于整个购物流程，仅仅用价格来“断章取义”，无疑是有失全面和公允的。长此以往，一些综合实力较强的电商企业，它们反而会被弱化，被迫陷于纯粹的价格比拼之中。 　　随时随地比价购物，代表着未来网购的发展方向，一淘网的比价功能，显然让所有的电商都感受到了巨大压力，马云这张防守牌有点狠，未来也许还会有更多被动了奶酪的电商联手抵制一淘网。","title":"一淘网是马云手中的防守牌"},{"content":"淘宝商城”喵“的一声，”天猫“这个名字就这样诞生了，而”淘宝商城“成为了历史。 然而，公众面对这次淘宝商城的更名却相当不淡定。天猫出笼之后，公众的生活被这只横空出世的天猫扰乱了，各种点评、各种恶搞、各种挖苦、各种不解、各种质疑充斥着微博。 当然，品牌更名并不稀奇。从BMW的巴依尔到宝马，从富士到斯巴鲁，从SONNY到SONY，从联想的Legend到Lenovo……甚至有些品牌不惜散尽千金以求好名。比如埃克森，其之前的名字为美国新泽西标准石油公司。1972年为了换成现名，历时3年，动员了心理学、社会学、语言学等各方面的专家，先后调查了55个国家和地区的风俗习惯，从1万个名字中，选出8个，再把这8个名字放到100多种语言中进行研究，充分考虑品牌名称各种文字的音、形、谐音、误解、近义、联想等因素，最后确定把企业名称定为EXXON，中译名为埃克森。这次改名共花费了1亿美元，还不包括其后的巨额宣传和推广费用。 但是，大多数品牌仍不愿意轻易改名，特别是对于已经有一定知名度和辨识度的品牌来说，不到迫不得已是不会去尝试更名这一招。所以当听到淘宝商城改名为天猫的新闻之后，我的第一反应就怀疑是不是因为商标的问题。然而，这与商标无关。 抛开这种因素，在这背后，细心的公众似乎嗅到一种异样的味道，那就是在电子商务竞争白炽化的当下，淘宝商城的更名之举，隐约之中有那么一种不自信的滋味。莫非面对众多强大的对手，它已走火入魔？ 当然，淘宝商城的这一次更名，毫无疑问是在为未来资产剥离、分拆上市埋下伏笔。尽管淘宝方面否认了业界这样的猜测，但面对这种”路人皆知“的事情，再遮遮掩掩就显得矫情了。更名之后，不仅能够让B2C业务有清晰的品牌形象，阿里巴巴各平台的定位也将变得非常清晰。以淘宝网、天猫、阿里巴巴、支付宝、一淘网、阿里云组成一条完整的产业链，这让整个阿里巴巴的未来战略定位变得更加清晰。 打造独立品牌的战略本没有错，相反，马云舍得狠下心做一次大手术，这不得不说难能可贵。但是，这名改得估计不光是淘宝商城的拥趸们不乐意，看客们也看不过眼。 诚然，公众可以接受网络环境下的品牌名字是轻松幽默的，只是天猫这名字和B2C业务需要的品牌形象实在相去甚远。光是看天猫诠释的定位就让人觉得侧重于对女性顾客的考虑，而忽略了男性顾客的理性认识，很容易让人误读为”女性大卖场“。就目前的情况看来，这听起来不伦不类的天猫要想得到公众的认可，公关公司任重而道远。","title":"从天猫诞生看淘宝商城更名"},{"content":"UML类图关系大全 1、关联 双向关联： C1-C2：指双方都知道对方的存在，都可以调用对方的公共属性和方法。 在GOF的设计模式书上是这样描述的：虽然在分析阶段这种关系是适用的，但我们觉得它对于描述设计模式内的类关系来说显得太抽象了，因为在设计阶段关联关系必须被映射为对象引用或指针。对象引用本身就是有向的，更适合表达我们所讨论的那种关系。所以这种关系在设计的时候比较少用到，关联一般都是有向的。 使用ROSE 生成的代码是这样的： class C1  ...{ public:     C2* theC2; }; class C2  ...{ public:     C1* theC1; }; 双向关联在代码的表现为双方都拥有对方的一个指针，当然也可以是引用或者是值。 单向关联: C3->C4：表示相识关系，指C3知道C4，C3可以调用C4的公共属性和方法。没有生命期的依赖。一般是表示为一种引用。 生成代码如下： class C3  ...{ public:     C4* theC4; }; class C4  ...{ }; 单向关联的代码就表现为C3有C4的指针，而C4对C3一无所知。 自身关联（反身关联）： 自己引用自己，带着一个自己的引用。 代码如下： class C14  ...{ public:     C14* theC14; }; 就是在自己的内部有着一个自身的引用。 2、聚合/组合 当类之间有整体-部分关系的时候，我们就可以使用组合或者聚合。 聚合：表示C9聚合C10，但是C10可以离开C9而独立存在（独立存在的意思是在某个应用的问题域中这个类的存在有意义。这句话怎么解，请看下面组合里的解释）。 代码如下： class C9  ...{ public:     C10 theC10; }; class C10  ...{ };   组合（也有人称为包容）：一般是实心菱形加实线箭头表示，如上图所示，表示的是C8被C7包容，而且C8不能离开C7而独立存在。但这是视问题域而定的，例如在关心汽车的领域里，轮胎是一定要组合在汽车类中的，因为它离开了汽车就没有意义了。但是在卖轮胎的店铺业务里，就算轮胎离开了汽车，它也是有意义的，这就可以用聚合了。在《敏捷开发》中还说到，A组合B，则A需要知道B的生存周期，即可能A负责生成或者释放B，或者A通过某种途径知道B的生成和释放。 他们的代码如下： class C7  ...{ public:     C8 theC8; }; class C8  ...{ }; 可以看到，代码和聚合是一样的。具体如何区别，可能就只能用语义来区分了。 3、依赖 依赖: 指C5可能要用到C6的一些方法，也可以这样说，要完成C5里的所有功能，一定要有C6的方法协助才行。C5依赖于C6的定义，一般是在C5类的头文件中包含了C6的头文件。ROSE对依赖关系不产生属性。 注意，要避免双向依赖。一般来说，不应该存在双向依赖。 ROSE生成的代码如下： // C5.h #include \"C6.h\" class C5  ...{ }; // C6.h #include \"C5.h\" class C6 ...{ }; 虽然ROSE不生成属性，但在形式上一般是A中的某个方法把B的对象作为参数使用(假设A依赖于B)。如下： #include \"B.h\" class A ...{           void Func(B &b); } 那依赖和聚合\\组合、关联等有什么不同呢？ 关联是类之间的一种关系，例如老师教学生，老公和老婆，水壶装水等就是一种关系。这种关系是非常明显的，在问题领域中通过分析直接就能得出。 依赖是一种弱关联，只要一个类用到另一个类，但是和另一个类的关系不是太明显的时候（可以说是“uses”了那个类），就可以把这种关系看成是依赖，依赖也可说是一种偶然的关系，而不是必然的关系，就是“我在某个方法中偶然用到了它，但在现实中我和它并没多大关系”。例如我和锤子，我和锤子本来是没关系的，但在有一次要钉钉子的时候，我用到了它，这就是一种依赖，依赖锤子完成钉钉子这件事情。 组合是一种整体-部分的关系，在问题域中这种关系很明显，直接分析就可以得出的。例如轮胎是车的一部分，树叶是树的一部分，手脚是身体的一部分这种的关系，非常明显的整体-部分关系。 上述的几种关系（关联、聚合/组合、依赖）在代码中可能以指针、引用、值等的方式在另一个类中出现，不拘于形式，但在逻辑上他们就有以上的区别。 这里还要说明一下，所谓的这些关系只是在某个问题域才有效，离开了这个问题域，可能这些关系就不成立了，例如可能在某个问题域中，我是一个木匠，需要拿着锤子去干活，可能整个问题的描述就是我拿着锤子怎么钉桌子，钉椅子，钉柜子；既然整个问题就是描述这个，我和锤子就不仅是偶然的依赖关系了，我和锤子的关系变得非常的紧密，可能就上升为组合关系（让我突然想起武侠小说的剑不离身，剑亡人亡...）。这个例子可能有点荒谬，但也是为了说明一个道理，就是关系和类一样，它们都是在一个问题领域中才成立的，离开了这个问题域，他们可能就不复存在了。 4、泛化（继承） 泛化关系：如果两个类存在泛化的关系时就使用，例如父和子，动物和老虎，植物和花等。 ROSE生成的代码很简单，如下： #include \"C11.h\" class C12 : public C11 ...{ }; 5、这里顺便提一下模板 上面的图对应的代码如下： template<int> class C13  ...{ }; 这里再说一下重复度，其实看完了上面的描述之后，我们应该清楚了各个关系间的关系以及具体对应到代码是怎么样的，所谓的重复度，也只不过是上面的扩展，例如A和B有着“1对多”的重复度，那在A中就有一个列表，保存着B对象的N个引用，就是这样而已。 好了，到这里，已经把上面的类图关系说完了，希望你能有所收获了，我也费了不少工夫啊（画图、生成代码、截图、写到BLOG上，唉，一头大汗）。不过如果能让你彻底理解UML类图的这些关系，也值得了。:) +++++++++++++++++++++++++++++++++++++++++++++++++++++ 在UML建模中，对类图上出现元素的理解是至关重要的。开发者必须理解如何将类图上出现的元素转换到Java中。以java为代表结合网上的一些实例，下面是个人一些基本收集与总结：   基本元素符号：   1. 类（Classes） 类包含3个组成部分。第一个是Java中定义的类名。第二个是属性（attributes）。第三个是该类提供的方法。 属性和操作之前可附加一个可见性修饰符。加号（+）表示具有公共可见性。减号（-）表示私有可见性。#号表示受保护的可见性。省略这些修饰符表示具有package（包）级别的可见性。如果属性或操作具有下划线，表明它是静态的。在操作中，可同时列出它接受的参数，以及返回类型，如下图所示：   　　2. 包（Package） 包是一种常规用途的组合机制。UML中的一个包直接对应于Java中的一个包。在Java中，一个包可能含有其他包、类或者同时含有这两者。进行建模时，你通常拥有逻辑性的包，它主要用于对你的模型进行组织。你还会拥有物理性的包，它直接转换成系统中的Java包。每个包的名称对这个包进行了惟一性的标识。 　　3. 接口（Interface） 接口是一系列操作的集合，它指定了一个类所提供的服务。它直接对应于Java中的一个接口类型。接口既可用下面的那个图标来表示（上面一个圆圈符号，圆圈符号下面是接口名，中间是直线，直线下面是方法名），也可由附加了<<interface>>的一个标准类来表示。通常，根据接口在类图上的样子，就能知道与其他类的关系。 关　系：   1. 依赖（Dependency） 实体之间一个“使用”关系暗示一个实体的规范发生变化后，可能影响依赖于它的其他实例。更具体地说，它可转换为对不在实例作用域内的一个类或对象的任何类型的引用。其中包括一个局部变量，对通过方法调用而获得的一个对象的引用（如下例所示），或者对一个类的静态方法的引用（同时不存在那个类的一个实例）。也可利用“依赖”来表示包和包之间的关系。由于包中含有类，所以你可根据那些包中的各个类之间的关系，表示出包和包的关系。 　　2. 关联（Association） 实体之间的一个结构化关系表明对象是相互连接的。箭头是可选的，它用于指定导航能力。如果没有箭头，暗示是一种双向的导航能力。在Java中，关联转换为一个实例作用域的变量，就像图E的“Java”区域所展示的代码那样。可为一个关联附加其他修饰符。多重性（Multiplicity）修饰符暗示着实例之间的关系。在示范代码中，Employee可以有0个或更多的TimeCard对象。但是，每个TimeCard只从属于单独一个Employee。     3. 聚合（Aggregation） 聚合是关联的一种形式，代表两个类之间的整体/局部关系。聚合暗示着整体在概念上处于比局部更高的一个级别，而关联暗示两个类在概念上位于相同的级别。聚合也转换成Java中的一个实例作用域变量。 关联和聚合的区别纯粹是概念上的，而且严格反映在语义上。聚合还暗示着实例图中不存在回路。换言之，只能是一种单向关系。 　　4. 合成（Composition） 合成是聚合的一种特殊形式，暗示“局部”在“整体”内部的生存期职责。合成也是非共享的。所以，虽然局部不一定要随整体的销毁而被销毁，但整体要么负责保持局部的存活状态，要么负责将其销毁。 局部不可与其他整体共享。但是，整体可将所有权转交给另一个对象，后者随即将承担生存期职责。Employee和TimeCard的关系或许更适合表示成“合成”，而不是表示成“关联”。 　　5. 泛化（Generalization） 泛化表示一个更泛化的元素和一个更具体的元素之间的关系。泛化是用于对继承进行建模的UML元素。在Java中，用extends关键字来直接表示这种关系。   　　6. 实现（Realization） 实例关系指定两个实体之间的一个合同。换言之，一个实体定义一个合同，而另一个实体保证履行该合同。对Java应用程序进行建模时，实现关系可直接用implements关键字来表示。","title":"UML类图关系大全"},{"content":"简介 　　即Proxy Pattern，23种java常用设计模式之一。代理模式的定义：对其他对象提供一种代理以控制对这个对象的访问。 　　代理模式的主要作用是为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。 　　代理模式的思想是为了提供额外的处理或者不同的操作而在实际对象与调用者之间插入一个代理对象。这些额外的操作通常需要与实际对象进行通信。 编辑本段应用场景 　　例如：假设有一组对象都实现同一个接口，实现同样的方法，但这组对象中有一部分对象需要有单独的方法，传统的笨办法是在每一个应用端都加上这个单独的方法，但是代码重用性低，耦合性高。 　　如果用代理的方法则很好的解决了这个问题。 编辑本段代码示例 示例说明 　　假设有一个Italk接口，有空的方法talk（）（说话），所有的people对象都实现（implements）这个接口，实现talk（）方法，前端有很多地方都将people实例化，执行talk方法，后来发现这些前端里有一些除了要说话以外还要唱歌（sing），那么我们既不能在Italk接口里增加sing()方法，又不能在每个前端都增加sing方法，我们只有增加一个代理类talkProxy，这个代理类里实现talk和sing方法，然后在需要sing方法的客户端调用代理类即可，代码如下： 接口类Italk 　　public interface Italk { 　　public void talk(String msg); 　　} 实现类people 　　public class People implements Italk { 　　public String username; 　　public String age; 　　public String getName() { 　　return username; 　　} 　　public void setName(String name) { 　　this.username= name; 　　} 　　public String getAge() { 　　return age; 　　} 　　public void setAge(String age) { 　　this.age = age; 　　} 　　public People(String name1, String age1) { 　　this.username= name1; 　　this.age = age1; 　　} 　　public void talk(String msg) { 　　System.out.println(msg+\"!你好,我是\"+username+\"，我年龄是\"+age); 　　} 　　} 代理类talkProxy 　　public class TalkProxy implements Italk { 　　Italk talker; 　　public TalkProxy (Italk talker) { 　　//super(); 　　this.talker=talker; 　　} 　　public void talk(String msg) { 　　talker.talk(msg); 　　} 　　public void talk(String msg,String singname) { 　　talker.talk(msg); 　　sing(singname); 　　} 　　private void sing(String singname){ 　　System.out.println(\"唱歌：\"+singname); 　　} 　　} 　　} 应用端myProxyTest 　　public class MyProxyTest { 　　/**代理模式 　　* @param args 　　*/ 　　public static void main(String[] args) { 　　//不需要执行额外方法的 　　Italk people1=new People(\"湖海散人\",\"18\"); 　　people1.talk(\"No ProXY Test\"); 　　System.out.println(\"-----------------------------\"); 　　//需要执行额外方法的 　　TalkProxy talker=new TalkProxy(people1); 　　talker.talk(\"ProXY Test\",\"七里香\"); 　　} 　　}","title":"java代理模式"},{"content":"从2002开始接触Java学会HelloWorld这么经典的程序到如今不知不觉已经十年啦，十年中亲耳听到过不少大牛的演讲，见到过项目中的神人在键盘上运指如飞的编程速度，当时就被震撼了。当编程越来越成体力活，我们还能有自己的思想，还能修炼为Java系统级别的程序员嘛？学习与修炼以下知识与技能，帮你早日达成愿望。 一：Java语言学习 对线程(thread)，串行化，反射，网络编程，JNI技术，容器(Map,List, Iterator), 类加载器(ClassLoader)，输入输出流，垃圾回收机制， 有比较深入的了解，最起码做过项目应用。有过Java项目的性能优化经验，最起码掌握一种性能监视工具的使用，熟悉JVM参数，最起码知道可以在JVM启动时指定不同垃圾回收机制，以及不同垃圾回收机制之间的差别，熟悉JVM参数优化。 二：J2EE方面 最好知道JDBC规范是怎么回事情，面对Oracle数据库如果告诉你JDBC驱动不能用了，你还知道有OCI驱动可以。掌握常见的SQL语句，熟悉JMS， JNDI等组件，掌握一套web开发模式，从前台到后台，有能力整合好这样的框架。理解并掌握MVC思想，像SSH已经实现了MVC的分层，几乎不需要你自己再实现，假设你开发一个简单的Swing程序，你能MVC就说明你真的掌握了MVC的精髓。有能力在J2EE前端开发中构建自己的MVC模式，知道什么是WEB2.0，知道什么是SOA， SaaS， SaaP等含义 三：理解并能合理运用设计模式，UML建模 知道并理解设计模式中蕴含的几种基本原则如：里氏替换原则， 开闭原则，合成复用原则，依赖倒置原则有很好的理解，并能举例说明。对常用的设计模式如工厂模式，单例模式，观察者模式，责任链模式，桥接模式等知道灵活运用，明白什么是回调(Callback)。最后用一位高人话来总结设计模式，它是为了让软件更容易被别人读懂，更容易维护而产生，设计模式本质是程序员之间的交流，如果A用工厂模式设计一个模块B来接替，A只要说该模块是工厂模式实现，B维护起来应该容易得多，所以设计模式是关于交流，不关于代码。切忌滥用设计模式。学会使用UML建模工具至少熟悉一种URL建模工具。   四：注重用户体验，掌握KISS原则，知道欧卡姆剃刀原则 顾客就是上帝这个口号我们已经喊了N年了，程序员的劳动成果最终也需要转换为服务提供给客户，用户体验至关重要，常常看到的场景是功能实现了，软件很难使用，程序员有个很充足的理由我不是美工，其实注重用户体验跟美工八杆子也打不到一起，FoxMail的成功在很大程度是用户体验的成功，友好，清晰的用户提示，强的容错与纠错设计是获得好的用户体验的不二法门。傻瓜相机顾名思义傻子都会使用，这个就著名的KISS原则(Keep it simple and stupid)意思是UI设计要简单明了，傻子一看就知道怎么用，想想我们做出来的东西，对照说明书都不知道怎么用。另外一个就是最著名的例子IPhone手机外观设计，是典型的欧卡姆剃刀设计原则来完成人机交互。   五：自动测试与软件配置管理(SCM)实现 知道什么是软件配置管理，知道Hudson - http://java.net/projects/hudson/运用该工具SCM，知道怎么获取测试代码覆盖率， Java有效代码行数(NCSS)，完成firebug， JDepend等工具集成ant/maven。熟悉并注重在开发过程中使用JUnit单元测试，理解白盒测试规范。   六：熟悉常见的网络通信协议 对HTTP协议，知道POST, GET的区别是什么，阅读过HTTP相关的RFC文档。学会使用sniffer工具查看数据包，帮助查找与调试程序，知道TCP与UDP的区别，知道并理解E-Mail发送与接受的协议如SMTP， POP3，IMAP等协议，了解MIME与Base64编码。知道组播是怎么回事情。   七：面向市场，永远对新技术保持渴望 计算机技术的发展日新月异，做为IT行业的软件开发人员要不断的给自己充电，更新自己的技术与时代保持同步，同时还要面向市场，华为总裁任正非说过-“华为的技术革新必须面向市场”，作为程序员同样要有市场意识，很多人都后悔没有在android刚出来的时候加以关注学习。那些很早关注android开发技术的很多程序员因此获得丰厚回报。如今HTML5得到越来越多的浏览器厂家支持，你是否已经跟上脚步，开始学习。   八：保持谦虚，三人行必有我师 乔帮主说他要保持初心，努力学习，我等更应该保持谦虚，IT技术发展日新月异，在你眼中不可能实现的技术，也许别人早已经有思路。保持谦虚就有机会吸取别人身上的长处，古人有云：满招损，谦受益。一个得道的高人更是说出了”下下人，上上智”的禅语。永远不要拒绝帮助你周围的人解决难题，解决难题是进步最快途径。不要放弃任何一次可以提升自己技术与能力的机会。   九：养成总结的习惯，不断反思 上学的时候老师常让写小结，也没总结出来所以然，以至于工作以后再也不提这档子事情，建议每个项目做完以后对自己都有个小结，总结自己在项目里面学到了什么，反问自己能不能完成在不需要别人帮助的情况下自己完成这样的系统搭建，是否熟悉与掌握项目中所用到的技术，即使有些东西不是你负责完成的但是什么也不能阻挡一颗求知的心，总结要尽量详细记录你遇到那些难题是怎么一个一个的解决的，下次再遇到你是否可以很快解决或者避免这样的问题。有总结才有提高，孔子曰：学而不思则罔，如果我们只是coding到吐血，不思考，不总结提高，永远不可能有能有本质提高，秦相李斯有云：“泰山不让土壤，故能成其大，河海不择细流，故能就其深”，点滴积累不断总结方能量变导致质变。   十：数学功底与算法知识 用任何编程语言开发应用，都离不开核心算法支持，很多国外的软件单单从UI上看，恐怕写几年程序的人都可以模仿，但是UI之下的那些真实深浅不一，相信不是你想模仿就可以模仿的，为什么我们越来越山寨，因为我们没有核心竞争力，对于程序员来说算法与数学显然是他最重要的核心竞争力之一。《算法导论》，《编程珠玑》等书绝对值得读十遍。微软亚洲研究院视觉计算组负责人在一次演讲中说到他们招人的标准是“三好学生– 数学好，编程好，态度好”。可是现实的普遍情况却是 - 微机原理闹危机，汇编语言不会变，实变函数学十遍。计算机基础知识被大家普遍忽视。从今天开始好好学习吧……   十一：Java代码反编译与代码保护 Java编译产生字节码，因而可以被轻松的逆向工程(反编译)，微软的C#生产的DLL也一样可以被轻松反编译。正式由于这个原因产生了许多Java开源的代码保护工具，而Proguard是其中佼佼者，已经被google集成在android之中用于Java代码保护，访问这里了解更多：http://proguard.sourceforge.net/   十二：努力成为某个行业或者领域骨干 面对漫长的职业生涯，要想不被淘汰，必须具备一招鲜吃遍天下的能力，选择自己感兴趣的方向，努力而深入的研究，计算机技术发展到今天已经细分很细，努力研究一种Java开源框架或者开源HTTP服务器源码或者研究过网络爬虫源码或者WEBKIT内核，不愁没有人要你。如果你是非常了解金融，企业ERP，证券，保险，移动应用行业的应用开发业务的人，一样不用愁工作。这些知识不随语言而改变，努力做一个有核心竞争力的Java程序员。   十三：提高语言与书面表达能力，掌握基础的项目管理知识 文档与语言表达能力是最好的向外界展现自己能力的方式，很多程序员编程能力很高，表达能力一般，Linux能够成功，除了归功于网络社区的力量之外，也得益于Linux作者本人给各大基金会写信，宣传推广，试想如果没有良好的书面语言表达能力，即使Linux系统再优秀，却无法被准确表达，失去各大基金会的支持，Linux还会像今天这么好的局面嘛。所以重视文档，重视提升沟通与表达能力，才有可能成为Java系统程序员。掌握基本的2/8原则，学会将模块细化分配给不同的人，预见并控制项目风险，把握项目进度，优化流程，合理的时间管理，了解TDD，熟悉敏捷开发模式，常规软件开发模式。   十四：掌握英语，良好的读写能力 英语是计算机的母语，掌握好英语对于阅读英文资料学习新技术大有帮助，我的建议是尽量读英文原版书，如果是算法方面的可能会困难一点，但是其它像设计模式，软件工程，OO编程思想等尽量读原版，提高自己的英文水平，多多访问开发者，code project，程序员天堂，Pc-magazine等英文IT网站。英语绝对是你必须修炼与提高的技能。此外英语好在外资企业尤其重要，只有外语足够好才可能在外资企业中突破职业瓶颈，向上发展。 转自：伯乐在线http://blog.jobbole.com/23310/","title":"Java系统程序员修炼之道"},{"content":"原文：http://blog.jobbole.com/1383/     http://blog.jobbole.com/5886/ 以下列表中的计算机书籍（中文版）来自微博：@程序员的那些事 粉丝的推荐。按推荐次数，从高到低往下排。如果大家还有其他计算机相关的经典书籍推荐，请在评论中留言，或者在这条微博的评论中留言，我们将继续扩充这个列表。 算法导论（第2版） 代码大全（第2版） C++ Primer中文版（第4版） 设计模式：可复用面向对象软件的基础 浪潮之巅 Java编程思想（第4版） Java核心技术 卷1：基础知识 Java核心技术 卷2：高级特性 人月神话 Linux内核编程 C程序设计语言（第2版新版） 黑客与画家：硅谷创业之父Paul Graham文集 编程之美：微软技术面试心得 代码之美 软件随想录：程序员部落酋长Joel谈软件 架构之美 国外计算机科学经典教材：Unix & Linux大学教程 深入理解计算机系统（原书第2版） UNIX网络编程 卷1：套接字联网API UNIX网络编程 卷2：进程间通信 自动机理论、语言和计算导论 Photoshop CS4入门到精通 软件架构的艺术 Effective C++中文版 Effective Java中文版（第2版） PHP & MySQL Web数据库应用开发指南（第2版） PHP经典实例（第2版） C++ 编程思想 第1卷 C++ 编程思想 第2卷   两卷合订本 Linux内核设计的艺术：图解Linux操作系统架构设计与实现原理 数据库系统导论（原书第8版） Python参考手册（第4版） Python灰帽子 提高C++性能的编程技术 从网管员到CTO：网络设备配置与管理实战详解 深入理解计算机系统（修订版） UNIX编程艺术 深入理解Java虚拟机:JVM高级特性与最佳实践 Microsoft.NET框架程序设计 代码整洁之道 编程珠玑（第2版）、编程珠玑（续） 大话设计模式 C#开发宝典 深入理解Linux内核（第3版） UNIX环境高级编程 （第2版） WCF服务编程：.NET开发者决战SOA的制胜利剑（第3版） 现代编译原理:C语言描述 （虎书） 高级编译器设计与实现 （鲸书） 编译原理（第2版）（龙书） Windows核心编程 （第5版） C++标准程序库：自修教程与参考手册 设计原本：计算机科学巨匠Frederick P.Brooks的思考 软件框架设计的艺术 编者按：2008年8月4日，StackOverflow 网友 Bert F 发帖提问：哪本最具影响力的书，是每个程序员都应该读的？ “如果能时光倒流，回到过去，作为一个开发人员，你可以告诉自己在职业生涯初期应该读一本，你会选择哪本书呢？我希望这个书单列表内容丰富，可以涵盖很多东西。” 很多程序员响应，他们在推荐时也写下自己的评语。以前就有国内网友介绍这个程序员书单，不过都是推荐数 Top 10的书。其实除了前10本之外，推荐数前30左右的书籍都算经典，伯乐在线整理编译这个问答贴，同时摘译部分推荐人的评语。下面就按照各本书的推荐数排列。   1. 《代码大全》 史蒂夫·迈克康奈尔 推荐数：1684 “优秀的编程实践的百科全书，《代码大全》注重个人技术，其中所有东西加起来，就是我们本能所说的“编写整洁的代码”。这本书有50页在谈论代码布局。” —— Joel Spolsky 对于新手来说，这本书中的观念有点高阶了。到你准备阅读此书时，你应该已经知道并实践过书中99%的观念。– esac   2. 《程序员修炼之道》 推荐数：1504 对于那些已经学习过编程机制的程序员来说，这是一本卓越的书。或许他们还是在校生，但对要自己做什么，还感觉不是很安全。就像草图和架构之间的差别。虽然你在学校课堂上学到的是画图，你也可以画的很漂亮，但如果你觉得你不太知道从哪儿下手，如果某人要你独自画一个P2P的音乐交换网络图，那这本书就适合你了。—— Joel 3. 《计算机程序的构造和解释》 推荐数：916 就个人而言，这本书目前为止对我影响醉倒的一本编程书。 《代码大全》、《重构》和《设计模式》这些经典书会教给你高效的工作习惯和交易细节。其他像《人件集》、《计算机编程心理学》和《人月神话》这些书会深入软件开发的心理层面。其他书籍则处理算法。这些书都有自己所属的位置。 然而《计算机程序的构造和解释》与这些不同。这是一本会启发你的书，它会燃起你编写出色程序的热情；它还将教会你认识并欣赏美；它会让你有种敬畏，让你难以抑制地渴望学习更多的东西。其他书或许会让你成为一位更出色的程序员，但此书将一定会让你成为一名程序员。 同时，你将会学到其他东西，函数式编程（第三章）、惰性计算、元编程、虚拟机、解释器和编译器。 一些人认为此书不适合新手。个人认为，虽然我并不完全认同要有一些编程经验才能读此书，但我还是一定推荐给初学者。毕竟这本书是写给著名的6.001，是麻省理工学院的入门编程课程。此书或许需要多做努力（尤其你在做练习的时候，你也应当如此），但这个价是对得起这本书的。 你还不确信么？那就读读第一版的前言或序言。网上有免费的电子版。 - Antti Sykäri   4. 《C程序设计语言》 推荐数：774 这本书简洁易读，会教给你三件事：C 编程语言；如何像程序员一样思考；底层计算模型。（这对理解“底层”非常重要）—— Nathan   5. 《算法导论》 推荐数：671 《代码大全》教你如何正确编程；《人月神话》教你如何正确管理；《设计模式》教你如何正确设计…… 在我看来，代码只是一个工具，并非精髓。开发软件的主要部分是创建新算法或重新实现现有算法。其他部分则像重新组装乐高砖块或创建“管理”层。我依然梦想这样的工作，我的大部分时间（>50%）是在写算法，其他“管理”细节则留给其他人…… —— Ran Biron   6. 《重构：改善既有代码的设计》 推荐数：617 我想我不得不推荐《重构》：改进现有代码的设计。—— Martin 我必须承认，我最喜欢的编程语录是出自这本书：任何一个傻瓜都能写出计算机能理解的程序，而优秀的程序员却能写出别人能读得懂的程序。—— Martin Fowler   7. 《设计模式》 推荐数：617 就我而言，我认为四人帮编著的《设计模式》是一本极为有用的书。虽然此书并不像其他建议一样有关“元”编程，但它强调封装诸如模式一类的优秀编程技术，因而鼓励其他人提出新模式和反模式（antipatterns），并运用于编程对话中。—— Chris Jester-Young   8. 《人月神话》 推荐数：588   9. 《计算机程序设计艺术》 推荐数：542 这是高德纳倾注心血写的一本书。—— Peter Coulton   10. 《编译原理》（龙书） 推荐数：462 我很奇怪，居然没人提到龙书。（或许已有推荐，我没有看到）。我从没忘过此书的第一版封面。此书让我知道了编译器是多么地神奇绝妙。- DB   11. 《深入浅出设计模式》 推荐数：445 我知道四人帮的《设计模式》是一本标准书，但倒不如先看看这部大部头，此书更为简易。一旦你了解了解了基本原则，可以去看四人帮的那本圣经了。- Calanus   12. 《哥德尔、艾舍尔、巴赫书：集异璧之大成》 推荐数：437 如果下昂真正深入阅读，我推荐道格拉斯·侯世达（Douglas Hofstadter）的《哥德尔、艾舍尔、巴赫书》。他极为深入研究了程序员每日都要面对的问题：递归、验证、证明和布尔代数。这是一本很出色的读物，难度不大，偶尔有挑战，一旦你要鏖战到底，将是非常值得的。 – Jonik   13. 《代码整洁之道》 推荐数：329 虽然《代码整洁之道》和《代码大全》有很多共同之处，但它有更为简洁更为实际的清晰例子。 – Craig P. Motlin   14. 《Effective C++》和《More Effective C++》 推荐数：297 在我职业生涯早期，Scott Meyer的《Effective C++》和后续的《More effective C++》都对我的编程能力有着直接影响。正如当时的一位朋友所说，这些书缩短你培养编程技能的过程，而其他人可能要花费数年。 去年对我影响最大的一本书是《大教堂与市集》，该书教会我很有关开源开发过程如何运作，和如何处理我代码中的Bug。 – John Channing   15. 《编程珠玑》 推荐数：282 尽管我不得不羞愧地承认，书中一半的东西我都没有理解，但我真的推荐《编程珠玑》，书中有些令人惊奇的东西。 – Matt Warren   16. 《修改代码的艺术》by Michael Feathers 我认为没有任何一本书能向这本书一样影响了我的编程观点。它明确地告诉你如何处理其他人的代码，含蓄地教会你避免哪些（以及为什么要避免）。- Wolfbyte 同意。很多开发人员讨论用干净的石板来编写软件。但我想几乎所有开发人员的某些时候是在吃其他开发人员的狗食。– Bernard Dy   17. 《编码：隐匿在计算机软硬件背后的语言》 我推荐Charles Petzold的《编码》。在这个充满工具和IDE的年代，很多复杂度已经从程序员那“抽取”走了，这本书一本开眼之作。 – hemil   18. 《禅与摩托车维修艺术 / Zen and the Art of Motorcycle Maintenance》 对我影响最大的那本书是 Robert Pirsig 的《禅与摩托车维修艺术》。不管你做什么事，总是要力求完美，彻底了解你手中的工具和任务，更为重要的是，要有乐趣（因为如果你做事有乐趣，一切将自发引向更好的结果）。 – akr （编注：关于这本书，也可以看看阮一峰的读后感。）   19. 《Peopleware / 人件集:人性化的软件开发》 Demarco 和 Lister 表明，软件开发中的首要问题是人，并非技术。他们的答案并不简单，只是令人难以置信的成功。第二版新增加了八章内容。 – Eduardo Molteni   20. 《Coders at Work / 编程人生》 一本非常有影响力的书，可以从中学到一些业界顶级人士的经验，了解他们如何思考并工作。 – Jahanzeb Farooq   21. 《Surely You’re Joking, Mr. Feynman! / 别闹了，费曼先生！》 虽然这本书可能有点偏题，但不管你信不信，这本书曾在计算机科学专业课程的阅读列表之上。一个优秀的角色模型，一本有关好奇心的优秀书籍。 – mike511   22. 《Effective Java 中文版》 此书第二版教你如何编写漂亮并高效的代码，虽然这是一本Java书，但其中有很多跨语言的理念。 – Marcio Aguiar   23. 《Patterns of Enterprise Application Architecture / 企业应用架构模式》 很奇怪，还没人推荐 Martin Fowler 的《企业应用架构模式》- levi rosol   24. 《The Little Schemer》和《The Seasoned Schemer》 nmiranda 这两本是LISP的英文书，尚无中文版。美国东北大学网站上也有电子版。   25. 《交互设计之路》英文名：《The Inmates Are Running The Asylum: Why High Tech Products Drive Us Crazy and How to Restore the Sanity》该书作者：Alan Cooper，人称Visual Basic之父，交互设计之父。 本书是基于众多商务案例，讲述如何创建更好的、高客户忠诚度的软件产品和基于软件的高科技产品的书。本书列举了很多真实可信的实际例子，说明目前在软件产品和基于软件的高科技产品中，普遍存在着“难用”的问题。作者认为，“难用”问题是由这些产品中存在着的高度“认知摩擦”引起的，而产生这个问题的根源在于现今软件开发过程中欠缺了一个为用户利益着想的前期“交互设计”阶段。“难用”的产品不仅损害了用户的利益，最终也将导致企业的失败。本书通过一些生动的实例，让人信服地讲述了由作者倡导的“目标导向”交互设计方法在解决“难用”问题方面的有效性，证实了只有改变现有观念，才能有效地在开发过程中引入交互设计，将产品的设计引向成功。 本书虽然是一本面向商务人员而编写的书，但也适合于所有参与软件产品和基于软件的高科技产品开发的专业人士，以及关心软件行业和高科技行业现状与发展的人士阅读。 他还有另一本中文版著作：《About Face 3 交互设计精髓》   26. 《Why’s (Poignant) Guide to Ruby 》 如果你不是程序员，阅读此书可能会很有趣，但如果你已经是个程序员，可能会有点乏味。   27. 《Unix编程艺术》 It is useful regardless operating system you use. – J.F. Sebastian 不管你使用什么操作系统，这本书都很有用。 – J.F. Sebastian   28. 《Practices of an Agile Developer / 高效程序员的45个习惯：敏捷开发修炼之道》 45个习惯，分为7个方面：工作态度、学习、软件交付、反馈、编码、调试和协作。 每一个具体的习惯里，一开始提出一个谬论，然后展开分析，之后有正队性地提出正确的做法，并设身处地地讲出了正确做法给你个人的“切身感受”，最后列出几条注意事项，帮助你修正自己的做法（“平衡的艺术”）。   29. 《Test-Driven Development by Example. / 测试驱动开发》 前面已经提到的很多书都启发了我，并影响了我，但这本书每位程序员都应该读。它向我展示了单元测试和TDD的重要性，并让我很快上手。 – Curro 我不关心你的代码有多好或优雅。如果你没有测试，你或许就如同没有编写代码。这本书得到的推荐数应该更高些。人们讨论编写用户喜欢的软件，或既设计出色并健壮的高效代码，但如果你的软件有一堆bug，谈论那些东西毫无意义。– Adam Gent   30. 《Don’t Make Me Think / 点石成金:访客至上的网页设计秘笈》 取决于你所追求的目标。我喜欢《代码大全》是因纯编程，《点石成金》是一本有关UI设计的卓越书籍。 – Justin Standard   后语 除这个书单之外，曾经也有微博网友推荐《一些经典的计算机书籍》，大约在50本。","title":"一些经典的计算机书籍"},{"content":"普通定义Bean并且进行初始化的方法一般通过property（属性）的setter方法或者构造方法进行。例如 <bean id=\"beanName\" class=\"com.csdn.net.arvin.BeanClass\" >    <constructor-arg value=\"***\" />    <property name=\"propertyOne\" value=\"\" /><\/bean> 这种定义创建Bean相当于使用new  com.csdn.net.arvin.BeanClass(); 的方法来新建Bean对象。在实际应用中很多情况下还会使用设计模式中的工厂模式来创建对象。使用静态工厂类即调用工厂类中的静态方法，比如public static 类名 getInstance()方法返回根据getInstance()方法内部逻辑判断后创建的我们实际需要的对象。   以下为完整的通过XML配置文件配置，在Spring中使用工厂类创建我们需要的Bean对象的Demo    这样的好处显而易见，即使实际获取的MailConfig类型对象发生了变化，main方法中的代码也不需要进行变动。   代码如下： MAIN方法类： package factorybean;import injection.MailConfig;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class FactoryBeanMain{    public static void main(String[] args)    {        String springConfig = \"factorybean/spring-config.xml\";        ApplicationContext context =                 new ClassPathXmlApplicationContext(springConfig);        MailConfig mailConfig =                 context.getBean(\"mailConfig\", MailConfig.class);        mailConfig.doIt();    }} Spring-config.xml： <?xml version=\"1.0\" encoding=\"UTF-8\"?><beans xmlns=\"http://www.springframework.org/schema/beans\"\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\txsi:schemaLocation=\"http://www.springframework.org/schema/beans \t    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\">\t<bean id=\"mailConfig\" class=\"factorybean.StaticMailConfigFactory\"\tfactory-method=\"getMailConfig\">\t\t<constructor-arg value=\"companyTwo\" />\t<\/bean><\/beans> 静态工厂类： package factorybean;import injection.MailConfig;public class StaticMailConfigFactory{    public static MailConfig getMailConfig(String mailServiceProvider)    {        if (\"companyOne\".equals(mailServiceProvider))            return new MailConfigOfCompanyOne();        if (\"companyTwo\".equals(mailServiceProvider))            return new MailConfigOfCompanyTwo();        return null;    }} MailConfig接口：   package injection;public interface MailConfig{    public void doIt();} 实现MailConfig接口的MailConfigOfCompanyOne类 ： package factorybean;import injection.MailConfig;public class MailConfigOfCompanyOne implements MailConfig{    @Override    public void doIt()    {        System.out.print(\"companyOne's mailConfig is created.\");    }} 实现MailConfig接口的MailConfigOfCompanyTwo类： package factorybean;import injection.MailConfig;public class MailConfigOfCompanyTwo implements MailConfig{    @Override    public void doIt()    {        System.out.print(\"companyTwo's mailConfig is created.\");    }}              ","title":"Spring学习笔记 使用Static Factory（静态工厂类）创建Bean"},{"content":"Java系统程序员修炼之道 2012-07-05 09:37 jia20003 博客园 我要评论(1) 字号：T | T 从2002开始接触Java学会HelloWorld这么经典的程序到如今不知不觉已经十年啦，十年中亲耳听到过不少大牛的演讲，见到过项目中的神人在键盘上运指如飞的编程速度，当时就被震撼了。当编程越来越成体力活，我们还能有自己的思想，还能修炼为Java系统级别的程序员嘛？学习与修炼以下知识与技能，帮你早日达成愿望。 AD： 从2002开始接触Java学会HelloWorld这么经典的程序到如今不知不觉已经十年啦，十年中亲耳听到过不少大牛的演讲，见到过项目中的神人在键盘上运指如飞的编程速度，当时就被震撼了。当编程越来越成体力活，我们还能有自己的思想，还能修炼为Java系统级别的程序员嘛？学习与修炼以下知识与技能，帮你早日达成愿望。 一：Java语言学习   对线程(thread)，串行化，反射，网络编程，JNI技术，容器(Map,List, Iterator), 类加载器(ClassLoader)，输入输出流，垃圾回收机制， 有比较深入的了解，最起码做过项目应用。有过Java项目的性能优化经验，最起码掌握一种性能监视工具的使用，熟悉JVM参数，最起码知道可以在JVM启动时指定不同垃圾回收机制，以及不同垃圾回收机制之间的差别，熟悉JVM参数优化。 二：J2EE方面   最好知道JDBC规范是怎么回事情，面对Oracle数据库如果告诉你JDBC驱动不能用了，你还知道有OCI驱动可以。掌握常见的SQL语句，熟悉JMS， JNDI等组件，掌握一套web开发模式，从前台到后台，有能力整合好这样的框架。理解并掌握MVC思想，像SSH已经实现了MVC的分层，几乎不需要你自己再实现，假设你开发一个简单的Swing程序，你能MVC就说明你真的掌握了MVC的精髓。有能力在J2EE前端开发中构建自己的MVC模式，知道什么是WEB2.0，知道什么是SOA， SaaS， SaaP等含义。 三：理解并能合理运用设计模式，UML建模   知道并理解设计模式中蕴含的几种基本原则如：里氏替换原则， 开闭原则，合成复用原则，依赖倒置原则有很好的理解，并能举例说明。对常用的设计模式如工厂模式，单例模式，观察者模式，责任链模式，桥接模式等知道灵活运用，明白什么是回调(Callback)。最后用一位高人话来总结设计模式，它是为了让软件更容易被别人读懂，更容易维护而产生，设计模式本质是程序员之间的交流，如果A用工厂模式设计一个模块B来接替，A只要说该模块是工厂模式实现，B维护起来应该容易得多，所以设计模式是关于交流，不关于代码。切忌滥用设计模式。学会使用UML建模工具至少熟悉一种URL建模工具。 四：注重用户体验，掌握KISS原则，知道欧卡姆剃刀原则   顾客就是上帝这个口号我们已经喊了N年了，程序员的劳动成果最终也需要转换为服务提供给客户，用户体验至关重要，常常看到的场景是功能实现了，软件很难使用，程序员有个很充足的理由我不是美工，其实注重用户体验跟美工八杆子也打不到一起，FoxMail的成功在很大程度是用户体验的成功，友好，清晰的用户提示，强的容错与纠错设计是获得好的用户体验的不二法门。傻瓜相机顾名思义傻子都会使用，这个就著名的KISS原则(Keep it simple and stupid)意思是UI设计要简单明了，傻子一看就知道怎么用，想想我们做出来的东西，对照说明书都不知道怎么用。另外一个就是最著名的例子IPhone手机外观设计，是典型的欧卡姆剃刀设计原则来完成人机交互。 五：自动测试与软件配置管理(SCM)实现   知道什么是软件配置管理，知道Hudson - http://java.net/projects/hudson/运用该工具SCM，知道怎么获取测试代码覆盖率， Java有效代码行数(NCSS)，完成firebug， JDepend等工具集成ant/maven。熟悉并注重在开发过程中使用JUnit单元测试，理解白盒测试规范。 六：熟悉常见的网络通信协议   对HTTP协议，知道POST, GET的区别是什么，阅读过HTTP相关的RFC文档。学会使用sniffer工具查看数据包，帮助查找与调试程序，知道TCP与UDP的区别，知道并理解E-Mail发送与接受的协议如SMTP， POP3，IMAP等协议，了解MIME与Base64编码。知道组播是怎么回事情。 七：面向市场，永远对新技术保持渴望   计算机技术的发展日新月异，做为IT行业的软件开发人员要不断的给自己充电，更新自己的技术与时代保持同步，同时还要面向市场，华为总裁任正非说过-“华为的技术革新必须面向市场”，作为程序员同样要有市场意识，很多人都后悔没有在android刚出来的时候加以关注学习。那些很早关注android开发技术的很多程序员因此获得丰厚回报。如今HTML5得到越来越多的浏览器厂家支持，你是否已经跟上脚步，开始学习。 八：保持谦虚，三人行必有我师   乔帮主说他要保持初心，努力学习，我等更应该保持谦虚，IT技术发展日新月异，在你眼中不可能实现的技术，也许别人早已经有思路。保持谦虚就有机会吸取别人身上的长处，古人有云：满招损，谦受益。一个得道的高人更是说出了”下下人，上上智”的禅语。永远不要拒绝帮助你周围的人解决难题，解决难题是进步最快途径。不要放弃任何一次可以提升自己技术与能力的机会。 九：养成总结的习惯，不断反思   上学的时候老师常让写小结，也没总结出来所以然，以至于工作以后再也不提这档子事情，建议每个项目做完以后对自己都有个小结，总结自己在项目里面学到了什么，反问自己能不能完成在不需要别人帮助的情况下自己完成这样的系统搭建，是否熟悉与掌握项目中所用到的技术，即使有些东西不是你负责完成的但是什么也不能阻挡一颗求知的心，总结要尽量详细记录你遇到那些难题是怎么一个一个的解决的，下次再遇到你是否可以很快解决或者避免这样的问题。有总结才有提高，孔子曰：学而不思则罔，如果我们只是coding到吐血，不思考，不总结提高，永远不可能有能有本质提高，秦相李斯有云：“泰山不让土壤，故能成其大，河海不择细流，故能就其深”，点滴积累不断总结方能量变导致质变。 十：数学功底与算法知识   用任何编程语言开发应用，都离不开核心算法支持，很多国外的软件单单从UI上看，恐怕写几年程序的人都可以模仿，但是UI之下的那些真实深浅不一，相信不是你想模仿就可以模仿的，为什么我们越来越山寨，因为我们没有核心竞争力，对于程序员来说算法与数学显然是他最重要的核心竞争力之一。《算法导论》，《编程珠玑》等书绝对值得读十遍。微软亚洲研究院视觉计算组负责人在一次演讲中说到他们招人的标准是“三好学生– 数学好，编程好，态度好”。可是现实的普遍情况却是 - 微机原理闹危机，汇编语言不会变，实变函数学十遍。计算机基础知识被大家普遍忽视。从今天开始好好学习吧……  十一：Java代码反编译与代码保护   Java编译产生字节码，因而可以被轻松的逆向工程(反编译)，微软的C#生产的DLL也一样可以被轻松反编译。正式由于这个原因产生了许多Java开源的代码保护工具，而Proguard是其中佼佼者，已经被google集成在android之中用于Java代码保护，访问这里了解更多：http://proguard.sourceforge.net/ 十二：努力成为某个行业或者领域骨干   面对漫长的职业生涯，要想不被淘汰，必须具备一招鲜吃遍天下的能力，选择自己感兴趣的方向，努力而深入的研究，计算机技术发展到今天已经细分很细，努力研究一种Java开源框架或者开源HTTP服务器源码或者研究过网络爬虫源码或者WEBKIT内核，不愁没有人要你。如果你是非常了解金融，企业ERP，证券，保险，移动应用行业的应用开发业务的人，一样不用愁工作。这些知识不随语言而改变，努力做一个有核心竞争力的Java程序员。  十三：提高语言与书面表达能力，掌握基础的项目管理知识     文档与语言表达能力是最好的向外界展现自己能力的方式，很多程序员编程能力很高，表达能力一般，Linux能够成功，除了归功于网络社区的力量之外，也得益于Linux作者本人给各大基金会写信，宣传推广，试想如果没有良好的书面语言表达能力，即使Linux系统再优秀，却无法被准确表达，失去各大基金会的支持，Linux还会像今天这么好的局面嘛。所以重视文档，重视提升沟通与表达能力，才有可能成为Java系统程序员。掌握基本的2/8原则，学会将模块细化分配给不同的人，预见并控制项目风险，把握项目进度，优化流程，合理的时间管理，了解TDD，熟悉敏捷开发模式，常规软件开发模式。 十四：掌握英语，良好的读写能力   英语是计算机的母语，掌握好英语对于阅读英文资料学习新技术大有帮助，我的建议是尽量读英文原版书，如果是算法方面的可能会困难一点，但是其它像设计模式，软件工程，OO编程思想等尽量读原版，提高自己的英文水平，多多访问开发者，code project，程序员天堂，Pc-magazine等英文IT网站。英语绝对是你必须修炼与提高的技能。此外英语好在外资企业尤其重要，只有外语足够好才可能在外资企业中突破职业瓶颈，向上发展。 原文链接：http://blog.csdn.net/jia20003/article/details/7671595","title":"Java系统程序员修炼之道"},{"content":"现在是夜里22点了，还在外地出差中，无聊的看着 “遍地狼烟” 这部电影。 一遍一遍的翻着微博，已经成为了无聊时期的必不可少的动作了。 我对行业没有太高的敏捷度，但是却有着对it行业孜孜不倦的学习的劲头。 想想到现在已经工作两年了，记着刚开始工作的时候，就是一个不知天高地厚的小子，每个人在毕业的时候都有一颗雄心壮志，那是想着自己在学校的专业里非常不错的学生，就自大的梦想着有朝一日要做“架构师”。 从进入公司接触项目之后，发现一切都没那么简单。之前有人说，其实在公司里基本上都是ctrl+c和ctrl+v，那个时候我还不相信，不过此时我相信了。可是不同的是，就算是这种重复的动作也不是轻易就能完成的，有时一个简单的动作可能要花一天的时间才敢做。那个时候我想到了别人一直说，现在程序员都是”码工“，可是就算是\"码工\"也不是人人都能做的，还是需要有专业的技能的。 接触的以一个大的项目就是上海的一个项目了，虽然是二次开发，却是一次全新的架构，一次全新的设计思想。刚刚接手时已做了50%了，只是页面还不是太完整；在这里做的是后台模块开发，并且也第一次学习到了后台与前台的沟通，知道了接口的书写方式具体是什么样子的，可是第一次接触却遇到了很大的麻烦，由于对业务的不清楚，导致开始开发的好多模块都是错误的，那个时候的感觉就是 太丢人了，连这点事都不会做，太笨了（呵呵，自己骂自己其实还是很爽的，是不是觉得自己是个找虐的人）。一步一步的锻炼，到了后来一个人负责后台模块的开发与其他的模块的调试工作，正是这次锻炼，锻炼出了我具有很强的调试工作的能力和快速学习一个项目的 经验。后来项目割接过程中，一天一天的日子如同在地狱里生活，整整两个月没有休息并且每天休息4个多小时的日子磨练出了坚强的意志。 再后来就是去了河南做项目了，第一次领导让我负责一个模块的整体设计与开发，整个模块是由我和另外一个人做，我做为这个模块的负责人。由于是第一次负责模块的整体设计与开发，要与客户进行沟通模块的具体需求，当时缺乏经验，多次设计都与需求有出格的地方，还好在需求的人员的帮助下完成了整体的设计，不过那个时候却学到了如何与客户和团队人员沟通，由于模块比较复杂，数据库设计出来之后，领导进行评审，虽说没什么问题，不过确不能扩展出去。这个时候由在项目经理的帮助下，由经理提供想法，我完成设计，终于设计出了不错的表结构（在此感谢一下经理哈，虽说现在不在公司了，但是您还是我的良师益友的）。 两次大型项目的经验，确实学到了很多。不过今年在公司做了一个项目之后，却做起了实施。有人说开发的去做实施会把人做废了，其实开发的进而去做实施好处还是挺多的，可以对公司的产品能够进一步的了解，其次在于与客户的沟通也能学到很多，有些客户是做技术的，他们不但技术非常好，对业务也非常熟悉，在于他们沟通的过程中，我感觉到了他们的想法是丰富的也是合理的，并且也学到了与客户沟通的技巧，虽说过程有些痛苦，不过却在一步一步的成长着。 最近没事的时候，回顾一下语言的基础，最近发现，经验虽然丰富了，可是基础的东西却忘了，万卷不离其宗，温习一下基础，看看设计模式，学习一些开源工具。 最近虽然事情不多，但是却感觉有点累，各地实施，一直在出差，下班之后，一个人打车回了酒店，没人聊天，不想出去。 好了，时间不早了，该睡觉了，就到这吧","title":"我的it生活"},{"content":"1.static关键字      静态块比构造器先执行      静态方法只能访问静态的，非静态方法可以访问静态的和非静态的   2.单子（Sington）设计模式     在整个应用中，只有一个实例存在。    例：  public class Single             {                     private double r;                   private static Single sp;                   private Single()                      //私有构造器，因此不能随便new                   {   r = Math.random();  }        //产生一个随机数                   public static Single getInstance()       //返回Single的实例                   {                        if(sp == null)                        {                            sp = new Single();                            return sp;                        }                  }                  public double getR()                  {    return  r;  }                         //用于检测是否为同一个实例                  public static void main(String[] args)                  {                       Single s1 = Single.getInstance();                       Single s2 = Single.getInstance();                       System.out.println(s1.getR());                       System.out.println(s2.getR());                  }                                            //两个结果相同，表示是同一个实例 3.final关键字        final类，不可被继承        final变量，在初始化后不可改变变量值（如果final变量是引用变量，则不可以改变它的引用对象，但可以改变对象的数据）        final方法，不可被覆盖 4.abstract关键字       abstract抽象类，不能被实例化       abstract抽象方法，只有方法声明，没有方法的实现       抽象类里面并非一定需要抽象方法，但是没有抽象方法，抽象类就没有存在的必要   在以下任一条件成立时，类必须定义成抽象类：       1）类中有至少一个抽象方法       2）类继承了父类中的抽象方法，但是至少有一个抽象方法没有实现       3）类实现了某个接口，但没有全部实现接口中的方法 5.模板设计模式（Template Pattern）     在类中定义了某个算法的骨架，但不具体实现，而在其子类中实现 6.接口（interface）：是方法和常量值的定义的集合      接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，而没有实现      定义格式：<modifier> interface <name> [extends<superinterface>]                       {    [<attribute declarations>]                            [<abstract method declarations>]                       }   抽象类里可以有非抽象的方法和属性，也可以有抽象的方法和属性   接口中只包含常量和方法的定义，没有实现 7.接口的继承     接口和类类似，也可以从一个父接口中派生，接口的继承也是使用extends来完成    语法：<modifier> interface <name>              [extends <super interface>,<super interface>]              {    [<attribute   declarations>]                   [<abstract method declarations>]              }    和类不同的是，一个接口可以继承多个父接口 8.实现接口：       多个无关的类可实现同一个接口，一个类可实现多个无关的接口   语法：  <class declaration>  ::=                <modifier> class <name> [extends<superclass>]  [implements<interface> [<interface>]*]                {   <declaration> *  }    在java中，可以通过接口来模拟多继承 例： 抽象类    public abstract class People                        {                              public abstract int yearSalary();                         }                        public class Worker extends People                        {                               public int yearSalary()                               { ....}                        }         接口        public interface Pelple                        {                               public int yearSalary();                        }                        public class Worker implements People                        {                               publci int yearSalary()                               { ....}                        } 9.多态（Polymorphism）    一个类型为Aclass的变量既可以指向类型为Aclass的对象，又可以指向Aclass的任何子类的对象（继承的对象和实现的对象）      一个对象只能有一种确切的数据类型       一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法 10.对象造型（Casting）      所谓造型就是Java对象间的类型转换，分为自动造型和强制造型         对象的造型只用在有继承关系的对象之间 11.内部类（inner class）        允许一个类的定义出现在另一个类中，将处于另一个类中的“寄生类”称为内部类         内部类对其封装类的内部成员有访问权限        实例化内部类的两种方法：               1) Outer.Inner in = new Outer().new Inner();               2) Outer o = new Outer();                   Outer.Inner = o.new Inner();                如果内部类是static的，也可以用下面的方法：                    Outer .Inner  in = new Outer.Inner(); 12.异常              try{ 程序代码段 业务逻辑 }              catch(Exception e) { 异常信息 }              finally{程序一定会运行的代码，程序尾声 }     RuntimeException:是那些可能在Java虚拟机正常运行期间抛出的异常的超类。           如：ArithmeticException,EmptyStackException,IndexOutOfBoundsException     抛出异常：在定义一个方法的时候，如果并不能确定如何处理其中可能出现的异常，可以不在方法中对异常进行处理，而是将可能发生的异常让这个方法的调用者来处理。         不要抛出如下异常：1）从Error中派生的那些异常   2）从RuntimeException中派生的那些异常     方法中抛出异常的格式： <modifier> <returnType> methodName ([argument_list>]) throws <exception_list>  {....}     捕获和抛出结合使用：捕获异常和抛出异常的方式，并不是排它的，它们可以结合使用  方法覆盖中的异常：             当子类中的方法覆盖父类中的方法时，可以抛出异常             覆盖方法抛出的异常，可以抛出与被覆盖方法的相同的异常或者被覆盖方法的异常的子类异常     Error：例 IOError, ThreadDeath , VirtualMachineError","title":"lesson5 高级类特性"},{"content":"Joel Spolsky曾经感叹：招聘难，难于上青天（此处笔者稍加演绎:)）。他有两个辛辣但不乏洞察力的断言：真正的牛人也许一辈子就投大概4次简历，这些家伙一毕业就被好公司抢走了，并且他们的雇主会给他们不赖的待遇，所以他们也不想挪窝。（刚刚去世的Dennis Ritchie就是这样一个人）而“人才”市场上能找到的大多都不是什么人才。招到这帮人轻则费钱重则把你公司搞挂。 （当我把这篇文章给邹欣老师review的时候，他说了另外两点：1. 最好的人也许不投简历，就决定去哪里了。所以要在他们做决定前找到他们。2. 比较差的会投很多次简历，找不到工作的时间越多，投的简历越多，给整个pool 带来很多噪音，top10%的简历也许根本不算全部人的top10%。） 诚然，也许没有哪个行业像IT行业这样，无形资产占据公司的绝大多数资产。拒坊间传言比尔·盖茨就曾经说过类似这样的话：只要允许我带走100个人我可以再造一个微软。这话没搜到原版出处，但是从一个侧面反映了IT公司当中智力资产所占的比例之重。 所以一个自然的推论就是，招聘也许是一个公司决策当中最最重要的一个环节。Joel Spolsky把他在这方面的观察，体会和洞见集结成了一本小册子《Smart and Gets Things Done》，开篇就挑战“产品是公司成败的关键”这个传统观念，他认为创造最适合工程师生活的环境，留下最优秀的人才才是最先最重要的一步，接下来好的产品是水到渠成的事情。国内iapp4me.com创始人郝培强正是这个理念，所以他在微博上说： 我们是小公司，工资开的不高，也不招太多的人，但是电脑都是iMac27，iMac21，Macbook pro15，基本上比很多大公司都好多了。软件没盗版，刚才photoshop的正版我也收了。中午管饭，公司备伞。哈哈。节日假正常放，从不加班，早晨11点上班，下午6点下班。我是有资格说某些大公司的员工苦逼的。 事实上，米国找个人尚且难成这样，搞得Joel还费心费力写本书语重心长地劝企业们要善待好工程师，国内找个人更是难上加难，国内高质量问答社区知乎创始人周源就曾经在知乎上分享他呕心沥血的招人历程，看完真是让人慨叹这年头找个靠谱的人多不容易（这条知乎问答还有很多精彩的跟帖）： 其实从 08 年到现在，我一直想这事能不能有点窍门，或者是实用的方法，结论是几乎没有。我用过的大家都用的方法： 在水木上发贴子（有点效果） 在蓝色理想上发贴子（无效） 在技术邮件组里发贴子（无效） 买 51job/智联 最便宜的服务（有点效果） 给所有可以想到的人打电话，请他们推荐（无效） 给所有和你讨论过创业，喝过点小酒的人打电话（无效） 约前同事私下谈（有效） 我用过的大家可能没有用的方法： 上 twitter，看 XXX 的 follower，一个一个看，看他们的 twitter，博客，Google Reader 分享，想办法搞到邮件，联系，半夜电话骚扰。 上豆瓣，前端后端挑几本重量级的书，去找想看，看过，正在看这本书的人，一个一个看，看他们的活动，博客，Google Reader 分享，想办法搞到邮件，联系，半夜电话骚扰。 找同事，问他们都看什么技术博客，想办法搞到邮件，联系，半夜电话骚扰。 正是这样的不容易，才有不少公司走内部培养的办法，这里的逻辑是：一上来就招到靠谱的人太难了，但找一块靠谱的璞玉然后雕琢雕琢相对就简单很多。这倒是个办法，但这样做的人难免就陷入了纠结：培养好了，人跑了怎么办。这也不能怪招聘的公司，的确是人之常情。其实解决的办法也很简单，培养的时候进行适当引导，让员工发挥自己的主动学习能力，这样不但人得到更多成长，公司也不会觉得投入太多患得患失。所谓师傅领进门修行在个人。 但是，这仍然还是没有解决根本的问题，就是招聘真的很困难。应聘者固然觉得自己是在“海投”，大海捞针一般。而招聘者何尝不也是这种大海捞针的感觉。这就好比两个人谈恋爱，都想和对方好上，但是偏偏就聊不到一块去。 招聘真的很困难。以至于招聘者每年需要绞尽脑汁出新笔试题，以免往年的笔试题早就被人背熟了。出题很费脑子，要出的不太简单也不太难，能够滤掉绝大多数滥竽充数的但又要保证不因题目不公平而滤掉真正有能力的，要考虑审题人的时间成本就只能大多数用选择题，而选择题又是可以猜答案的（极少有人会在选了答案之后还敢在空白的地方写为什么选某答案的原因的）。更悲催的是，有些题目出的连公司的员工们自己都会做错（真的是员工们做错了吗？还是题目本身就出错了？） 笔试完了之后如果还没有被鄙视就要进入面试环节，姑且不说笔试题的种种弊端，就说面试环节，短短几个小时的面试（大多数公司也许连几个小时的面试时间都没有），既需要全面考察基本知识，又要考察编程素养，还要考察（也许最重要的）性格心态。再然后还有一项根本没法考察但却占据程序员相当一部分工作时间的：debug能力。面试官不但得找准问题，不因对方一题答对而妄下结论，也不因一题打错而就扼杀机会，还要以管窥豹，从一朵花看到整个世界，从面试人的举止言谈，分析问题的方式，甚至写程序的笔迹来观察这个人的性格，做事的方式和心态，简直是要面试官具备心理分析师的水准才行。 这厢要招人的雇主苦不堪言，那边找工作的人也是一团乱麻。绝大多数应届生直到毕业也不清楚他们想要去的公司到底需要什么样的能力，或者说，他们到底需要具备什么样的能力才能在应聘季节拥有自己的选择权。中国虽然本科教育环境差，但是同样有很多的人在本科希望整点东西出来，他们有一腔的激情和抱负，有强大的动力，但就是不知道自己需要掌握哪些技能才能满足雇主的要求，求告无门，整年整年苦闷的像没头苍蝇一样乱撞（我就收到过很多次这样的来信，他们往往很想学点东西，但又不知道哪些重要哪些不重要，到底该学到什么程度，不知道导致不确定，不确定导致决策瘫痪，干脆嘛也不动，荒废时间）。 什么叫熟练？什么又叫精通？那么扎实呢？两年的YY经验又意味着什么？能这么简单的量化吗？同样是两年的“实践”有的人能真的学到点东西，有的人也许近似一无所得。那么实习呢？很多人都一定要在简历上弄个实习经验，这个又能说明多少问题呢？大作业呢？得奖呢？有一次我面试一位同学，据简历说编译原理课的大作业得了一等奖，可我一问什么是递归下降，就傻眼了。 这个现实的结果就是，现在绝大多数应届简历而言，也许最具信息量的部分不是“精通XXX，熟悉YYY，掌握ZZZ”，不是“在UUU实习过”，也不是这个项目那个作业，反倒是越来越被认为不重要的一项：毕业学校。毕业学校本不应该是最具信息量的，它之所以最具信息量只是源于一个悲剧的事实：简历上其他条目实在信息量太少了。所以靠谱的面试者往往学会了无视简历上华而不实的内容，只相信面试的时候亲眼所见，扫两眼简历也就罢了，最后还得自己捋起袖子慢慢面。而应聘者也许也知道招聘的也不会细细纠简历上的条目，所以什么词也都敢往上捅，反正先过了HR筛简历这关再说。从经济学角度来讲，应聘者的这种策略是正确的，没有代价（因为目前似乎没有公司会去给已经申请过的人做一个诚信数据库），但至少有可能会带来巨大的收益。应聘成了博彩。而博彩式的应聘给招聘公司带来了巨大的筛选压力。简历成了摆设。 那么招聘这个关系里面的第三者——学校——所处的位置呢？学校更关心的是毕业率和就业率，这似乎是件好事，有这个为目标，那么老师们似乎应该努力让自己的学生多学点东西。可惜就业的质量似乎不是最重要的指标，此其一。其二老师本身大多数没有丰富的业界经验，根本不知道企业整整需要的人才是什么样的，可能花了精力，但却培养不出雇主真正需要的人。另一方面，老师所起的作用很多时候甚至是一个负面的作用，例如布置大作业表面上看上去是培养学生的能力，我们姑且不说抄袭，假设每个人都做了，那么大作业本身能够衡量多少东西呢？能否衡量代码质量，能否衡量团队协作能力？能否衡量交流能力？考虑到大作业用到的东西往往都是书里面现成的，大作业甚至不能衡量学习能力。而学习能力简直算是这个行业最重要的能力没有之一了。 所以，简而言之，如果把人才培养/招聘这件事情本身类比做一个项目，那么这整个项目迄今为止就是一个巨大的失败。为什么这么说呢： 和需求严重脱节：作为人才需求方的雇主的需求到底是什么？绝大多数应聘者都没搞清。更严重的是，这却一点都不是应聘者的错。因为雇主是stakeholder，是雇主自己的责任得去说清楚需求是什么。结果应聘者实现的不是雇主想要的，雇主想要的应聘者没有实现。 应聘者雇来培训自己的人根本不管事：学生交了学费，就相当于雇老师来培训自己，可培训者根本也不了解（或不关心）他的客户们的需求。这里，学生是需求方，老师则是实现方。弄清需求的职责在后者，可后者也弄不清。 学生自己也弄不清：学生自己既是需求方（需要特定技能），也是实现方。可他们自己也弄不清需求到底是什么。 以上三点还不是最严重的，最严重的在下面： 明白需求是什么的也不知道怎么实现：怎么去培养现代IT企业真正需要的人才？特别地，实战能力怎么培养？代码素养怎么培养？协作沟通能力怎么培养？学习能力怎么培养？就算这些都知道怎么培养，又怎么给在象牙塔里头，离催命之日还遥遥无期的学生提供足够的动力呢？而学生自己就算知道该学哪些技能，又怎么知道具体怎么着手？什么是最有效率的学习方法？又如何让自己保持学习的热情？ 以上这些问题，就是当下人才培养/招聘的惨淡现状。简而言之，在雇主和学生之间，横梗着一条巨大的鸿沟，两头都很着急，两头都有动力，但就是没有方法，君住长江头妾住长江尾。像微软谷歌这样的，干脆和高校合作，直接插手本科或硕士的教育，从而保证到时有足够强的候选，某种程度上，这的确是根本解决之道，可一来这代价太大了，非一般企业承受得起，二来这影响面也太小了。 这一切，也许将在未来的5年发生根本的变化。 《Switch: How to Change Things When Change Is Hard》（中译《瞬变》）里面指出，表面上看来非常困难的改变，也许是因为根本就没有抓住要害。在书中作者通过大量案例分析和心理学研究，雄辩地指出以下几点促成改变的关键之处： 触动内心的大象：要改变的人必须要有情感层面的动力。有一些特定的方法能够比另一些方法更能对人的情感产生触动。 给出清晰、明确的目标：目标一定不能含糊，模棱两口的目标让人无所适从，导致决策瘫痪。例如最近我们组在招实习生，我在微博上发了一条招聘信息，其中提到“扎实”的系统底层知识，有同学就写信来问，怎么叫“扎实”。我傻眼了。比尔·盖茨就以目标清晰明确著称，不仅在战略制定上，“每个人桌面上都有一台PC”，而且居然还体现在招聘上——“如果你读完了TAOCP，那么就给我投简历吧”。多么清晰，明确的目标啊——虽然高了点，也许这就是比尔·盖茨至今还没被应聘邮件淹没的原因:) 给前进的道路扫清障碍：人是懒惰的，只要有借口就会不想往前。如果既有明确的目标，同时道路又直直指向目标，一览无余，只等你开始往前走，那么便没有借口，一往无前。 那么让我们对照上面看看，可以做什么？ 首先，内心的大象不需要触动，中国有足够多的人足够早就开始焦虑就业的事情，只是不知道往哪使劲，这部分人如果把劲头用到正确的事情上面也许足以满足现在的IT企业人才饥渴了。至于其他人，好吧，也许身边的人开始动起来他们也会被触动。 然后是清晰、明确的目标。这一点上目前雇主们的做法可谓好坏参半，好的一点是大家都强调要有实践经验，要有团队协作精神，坏的一点就在基础知识和技能的要求方面，可谓再含糊不过了：“精通XX语言”，“扎实的XX功底”，“熟悉XX技术”，甚至看上去最具量化感的描述“X年YY经验”其实都根本说明不了多少东西，在信息量方面还不如我家门口菜市场上一家卖酥油饼的店门口挂的横幅——“三天不硬、至少六层！”。 很多朋友也许注意到一个现象，现在企业对招聘者简历的要求也在变得越来越灵活变通，例如ThoughtWorks在招聘的时候就希望招聘者能给出自己的博客地址，博客对IT行业的意义也许胜过其他所有行业，一个积累多年的技术博客比任何简历都更能说明问题。台湾的郭安定也说“为什么写技术博客对新人如此重要”。可惜这个做法也有一个弊端：并不是所有技术牛人都写博客，有人就是只干不说型的，而就算写博客，乃至动手写过一阵子的，写一个常年的博客，也远比你想象的更为困难，因为很多时候，写（说）得靠谱比做得靠谱更难。所以这个过滤器很多时候用不上。 但是这的确表明了一个思考的方向，就是寻找更具鉴别力的过滤器，Stackoverflow Careers 2.0之所以强大，是因为Joel Spolsky和Jeff Atwood这两位常年混社区的资深博主创造性地将一个人在社区的活动历史浓缩成为一系列的量化数值，由于这个历史很长期，所以鉴别力非常高。但它同样也有问题，就是对于应聘者来讲相当花费时间，而且并不是花时间（在Stackoverflow上回答问题）就一定能花到点子上。 到底什么特征才是既通用，又能够有效地鉴别高低应聘者的特征呢？这个特征必须不像博客那样难以实现，同时又必须有足够的区分度。 有的地方在要求填写简历的时候必须填上平时都访问哪些技术网站。恩，很不错的尝试，可区分度仍然还是不够，因为上网站上查东西毕竟只占现阶段大多数应届生的少数信息来源，特别是当我们看重得更多的是应届应聘者的系统性的知识基础的时候，网上的东西虽然丰富，但属于提高班，也更为琐碎，什么是更系统的知识来源呢？答案其实大家都知道—— 书。 我一向认为，很多时候，是否好好看完一本好书，对一个人的提升往往能达到质的区别。就算不好好看完一本好书，马马虎虎看完，只要书是真的好书，也肯定会有很大的提高。我在面试的时候就经常询问对方看过哪些技术书籍，经常上哪些网站，订哪些博客。这里头尤其数书籍这一项的区分度最高。此外，好书和坏书的差别，从本质上，就是学习效率和大方向的差别。一本烂书可以浪费你半年的时间，但一本好书却可以为你带来真正扎实的基础和开阔的视野。人们常常用“内功”来形容扎实的基础，认为学好了内功以后学什么都快，其实一点没错，好的“内功”书不仅讲清楚深刻的原理，而且指明技术的本质，刻画领域的地图。好的书抓住不变量，让人能够触类旁通。好的书不仅介绍知识，而且阐释原则，介绍那些万变不离其宗的东西。读烂书浪费时间，但读好书却节省时间。 象牙塔内的学生受到视野的限制，往往择书不慎，事倍功半，烂书不仅浪费时间，还会打击人的积极性，让人对知识心生恐惧，认为很难掌握，殊不知只是作者没有讲好（或者没有翻译好）。因此，为招聘头疼的公司完全可以给出“应聘俺们公司前必读的十本书”，也不一定要每个公司都不一样，在某个技术子领域有影响力的人，或者创始人们，可以来定义具有代表性的书单。 我们姑且把这个计划叫做“书单计划”，容易看到“书单计划”具备以下几个卓越的优点： 清晰、明确。完全可度量。 防伪：读没读过，随便一问便知。而正因为应聘者也知道这事不像实习经验可以忽悠，所以也不敢乱往简历上捅词。 不在乎是否“泄题”：书单完全公开的，无所谓，本来就是要你去读的。想背题？背书吧。真能背下来说明认真看了。 管你用心不用心读，只要读了，读完了，就有区别。真正的好书，你想不被吸引都难。据我观察很多人就是不知道该去读什么书。 不存在“怎么做”的障碍：所有人都知道怎么读书——一页一页读。 不需要招聘者投入精力：书单在此，就这么简单，您看着办。 评估的负担很大程度转移到了应聘者的身上：是不是认真看完了，有没有心得体会，您自己掂量。没看完别来找我们。 “书单计划”能很大程度上起到强鉴别器的作用，看了就是看了，必然能学到东西，没看就是没看。知道和不知道，区别是本质的。其实很多企业内部培训，根本上其实还不就是叫员工去看之前没看过的书或者资料嘛。最后，除了鉴别作用之外，它还是一个清晰促进的目标，是完全不花精力的培养。 当然，“书单计划”的背后是另一个悲剧的现实，如果不是因为这个现实，这个计划也完全没有必要，那就是，中国IT大学教育当中要求要学的书，和企业真正需要你去读的书相比，不是完全不够用，就是写的不够好，或者更悲剧的就是根本用不上，所以在这个大背景下出来的牛人都是自己淘书自己学的。微软高级开发测试工程师，《Windows用户态程序高效排错》作者熊力就在微博上说过：“我当年毕业的时候总结了一个公式：第一份工作的月薪=大学四年买过的技术书籍价格的总和。” 但是光有“书单计划”还不够，因为书籍只能管基础知识这一块，一些更难以量化衡量的实战“能力”又怎么办呢？至少目前为止，除了“练”之外好像还没有特别好的办法。可是在象牙塔里面做的项目，或大作业，真的能起到练的作用吗？前面说了，学生会知道自己最终要交差的不是雇主，而是老师，于是就以老师能够评判的标准来默认要求自己了，老师能够评判编码素养？代码风格？文档？设计？协作？甚至连著名的Joel 12条的第一条“是否用源代码管理系统”都没法通过。所以大多数时候，大作业能起到的作用近乎0。 但是如果这一切是由雇主来评判的，这个“作业”是由雇主来给出的，就完全不一样了。一想到作业是要作为简历的一部分的，能不紧张嘛。能不好好做嘛。能不学到点东西嘛？ 可是这事儿能实现吗？雇主能给学生出大作业吗？也许一两个关系好的高校可以，可是中国那么多学生呢？ 为什么不能呢？如果像书单那样，列出各个技术领域“推荐在学校期间尝试的项目”，至于动不动手做，那是学生自己的问题。做的，自然能够得到锻炼，面试的时候自然能得到更大的优势。 可问题是，面试的人又怎么来评估呢？这不又回到了没法有效评估的怪圈了吗？答案很简单，但这个答案，直到最近几年，才真正成为现实—— GitHub GitHub诞生于08年春天，第一年便产生了4万6千个公共项目，大约一年半之后用户就已经达到10万用户之巨。而到今年九月份，GitHub已经迎来了百万级用户。Host超过两百万个项目。 增长的太快了！就像Twitter一样。这样疯了一般的增长只能说明一个事实——人们等待这个产品太久了。 Social Coding。 真实的项目，真实的流程，真实的人名，一切代码review, check-in, test, build, document, 甚至讨论，计划，brianstorming，流程，一切的一切，都是项目历史的一部分，都可以像棋局那样复盘。有经验的面试者只要稍稍扫两眼一个人的GitHub历史，挑出几个check-in历史看一看，便完全能够迅速判断这个人是否满足他的要求。不再需要费劲心机地去想题目，去观察，去揣测，去花费大量的时间的同时还只能采样到几个极为有限的点。 不像象牙塔里面大作业，这里有源代码管理系统，自动化build，有check-in，有review，有分工，有合作，最重要的是——这是一个集市，一个超出象牙塔的集市，牛人相互吸引，你可以在互联网上找到和自己拥有共同兴趣的一帮人，真正做起一点事情，而不是交差，不需要受限于几十个人的一个小班级。Here Comes Everybody。 为什么我这么有信心？因为这事儿已经发生了。这个想法也完全不是我原创的。 正如很多事情一样，现在在国内发生的事情，往往是美国那头的历史。今年7月中旬，纽约一家公司的工程师老大发了一篇博客文章：Github is Your New Resume。指出一个惊人但再合理不过的事实：越来越多的IT公司在招聘的时候要求应聘者给出GitHub账号。甚至已经有人为GitHub写了根据GitHub上的历史自动生成简历的工具。 仔细想想，这是必然的趋势，没有比这个再合理的事情了，既然StackOverflow的历史能够作为简历，GitHub的历史不本该就是更好的简历吗：你想要具有实战经验，懂check-in懂review懂test和代码质量的重要性，懂交流和沟通的重要性，你本就应该在一个真实的项目当中去锻炼这些东西，而这些在目前已经完全可以办到。正如邹欣老师所说，你的工作就是最好的面试。 这件事情放在早几年，是完全没法做到的，因为我们那时候还没有GitHub。正如没有Twitter，没有微博之前，很多事情都不会成为可能一样，你有千钧之力，缺乏一个合适的支点，也没法撬动一整个社群。无组织中的组织，具有强大的杠杆效应。 这个事情里面，我唯一提出的东西就是：在目前国内这个现状下，苦闷的招聘者应该主动行动，给出一些建议项目，正如前面提到的书单计划一样，招聘者需要给出的只是引导和清晰明确的目标，剩下的事情，应聘者自然会去完成，这些项目可以是实验项目，也可以是完全能做出点卖钱的东西的项目（如果好好做的话），唯一的不可或缺的前提是，项目不能太小，单人就能完成的项目不理想，一两个月就能完成的项目不理想，最好足够大到能够锻炼到方方面面，偏大一点倒是无所谓的，因为一个尚未完成的项目完全可以作为简历。当然，可以想见的是，真到了那个时候，学生们肯定又是不会满足于仅去做那些已经有许多人做过的项目了。所以这里企业们一开始所建议的项目只是一个《Nudge》，是滚雪球之前需要的一点初始动能。后面的事情，他们自己会完成。 “GitHub计划”同样有一些明显的、甚至不可替代的优点： 清晰、明确，完全可度量。 防伪：同样不担心“泄题”。你伪造不了GitHub历史，伪造不了check-in历史，review comments，文档，交流记录… 它不但是招聘，也是不花精力的培养。善哉善哉。 评估的责任很大程度上交给了应聘者自己。 从你的GitHub旅程开始，你就已经一脚踏进了真正的企业，而企业的面试也已经开始。 书单+GitHub，就相当于一个两年左右的面试。 没有什么面试比持续两年的面试更具有信息量。 书单，加上项目，已经基本上覆盖了所需的全部技能。最妙的是，有太多的人在焦急的等待着他们未来的雇主给出明确的信号，他们想投入精力，去学习和实践，去成为企业需要的人，但是他们就是不知道往什么方向走，所谓有动力没方向。所以，雇主给出了清晰明确的要求，相信对于很多人来说反倒是一个解脱：“终于知道该干什么了”。《编程之美》为什么常居畅销榜？因为它透露了雇主眼中的需求，明确、清晰的需求，可以实现，并且知道怎么去实现的需求。 你提前两年就开始面试和培养未来的候选者，而且还不需要你花出一分精力，而且人家还很乐意，没有比这更完美的面试了。 想一想，以后那些没见过世面的公司看见你拿出GitHub账号给他看，该是多么惊讶同时又觉得多么合理。 而这一切，只是因为两个小小的改变： 由需求方（雇主）给出了清晰、明确的目标。 GitHub这样的平台。 那么，学校/老师在这个事情当中的位置呢？说实话我不知道。没有哪个行业像IT行业这样特殊：没有什么东西不能够（应该）在互联网上学到的。自组织的力量完全大过传统的教育方式。而且，既然雇主都当了领路人了，我不知道还有中间开发商什么事儿。（注：这里说的是软件开发，并非计算机科学研究，后者另当别论） 那么，这个改变会发生吗？多久会发生呢？当然，它在国外已经发生了，所以问这个问题多少有点无趣。但我还是预计很快就会在国内发生，毕竟，不是已经有人要求出示博客，和经常浏览的网站了吗？也许5年左右（4年本科和6年硕士的中间值？））就会深刻改变整个人才培养/招聘的格局。当然，我并不是预言家，所以不要把我的时间估计当真，我能肯定的是，这种方式是必然的大势所趋。 刚才我就收到一位同学邀请我上知乎回答一个问题“找工作的首要原则是什么？”，当然，这个问题的答案是：“弄清雇主的需求到底是什么”。 列一下我所认为的，你面试微软前必须要读的十本书： Code: The Hidden Language of Computer Hardware and Software （《编码的奥秘》） Computer System: A Programmer’s Perspective （《深入理解计算机系统》） / Windows via C/C++ （《Windows核心编程》 / 《程序员的自我修养》 Code Complete 2（《代码大全》）/ The Pragmatic Programmer （《程序员修炼之道》，我也把这本书称为《代码小全》） Programming Pearls （《编程珠玑》） / Algorithms / Algorithm Design / 《编程之美》 The C Programming Language The C++ Programming Language / Programming: Principles and Practice Using C++ / Accelerated C++ The Structure and Interpretation of Computer Programs （《计算机程序的构造和解释》） Clean Code / Implementation Patterns Design Patterns （《设计模式》） / Agile Software Development, Principles, Patterns, and Practices Refactoring （《重构》） （注：1. 以上同一条目下用“/”隔开的表示任选，当然你也可以都读了，相信我，时间是足够的。2. 读这些书并不意味着逐字逐句从第一页读到最后一页——当然你也可以这么做。怎么是聪明高效的读法，可以参考我之前写的关于如何阅读和查找/鉴别书籍/资料的博文） 注意：以上是我个人认为你面试微软开发职位前必须要读的10本书，它不代表我的雇主的观点。它也只是一个初步的书单，肯定会受到我个人经验和眼界的限制。欢迎大家提意见。 此外，IT不同子领域的必读书单可能千差万别，所以在发布之前我把这篇文章发给了一些朋友，他们给出了自己的书单（你是不是能看到一些有趣的共同点呢）： 云风（中国游戏编程先行者，前网易游戏部门资深程序员，简悦创始人）： 如果面试，我会挑以下的我自己读过的书，让人选择他也读过的部分，再了解他对这些书的理解。这些书其实本质上就是两类，对所面对的东西（程序语言也好，操作系统也好，底层设施也好）本身的理解程度。以及另一类：对设计思想和原则的理解： C++编程思想 Effective C++ 深度探索C++对象模型 C++语言的设计和演化 C专家编程 C陷阱与缺陷 C语言接口与实现 Lua程序设计 Linkers and Loaders COM本质论 Windows核心编程 深入解析Windows操作系统 程序员修炼之道 代码大全 UNIX编程艺术 设计模式 代码优化：有效使用内存 深入理解计算机系统 深入理解LINUX内核 TCP/IP 详解 冯大辉（丁香园CTO，贝塔咖啡创始人）： 软件随想录 黑客与画家 重来 UNIX编程艺术 编程人生 洪强宁（豆瓣技术总监）： StackOverflow上有一个程序员必读书单帖子，这里仅列出top10，更多参考这里。 Code Complete 2 The Mythical Man-Month （《人月神话》） Code: The Hidden Language of Computer Hardware and Software （《编码的奥秘》） TAOCP （不解释） The Pragmatic Programmer （《程序员修炼之道》） Design Patterns （《设计模式》） The Structure and Interpretation of Computer Programs （《计算机程序的构造和解释》） Refactoring （《重构》） The C Programming Language Introduction to Algorithms （《算法导论》） 郑昀（窝窝团研发副总裁）： 工程师入门： Code Complete 2 程序员修炼之道 深入理解计算机系统 工程师升级： 设计模式 重构——改善既有代码的设计 工程师转型： 快速软件开发——有效控制与完成进度计划 人月神话 IT项目管理那些事儿 软件随想录 最后期限 走出软件作坊 你的灯亮着吗?——发现问题的真正所在 张峥（微软亚洲研究院副院长）： Algorithms (by Sanjoy Dasgupta, Christos Papadimitriou and Umesh Vazirani) Data Structure and Algorithms The C Programming Language The Design of the UNIX Operating System Compilers （龙书） Computer Architecture: A Quantitative Approach Flow Outliers (why hard work and luck are both important) 邹欣（MSRA创新工程中心首席研发经理）： 关于创新的书籍(http://book.douban.com/doulist/1253169/): The Myths of Innovation The Innovator’s Dilemma The Innovator’s Solution Crossing the Chasm Inside Intuit 盛田昭夫 杰克·韦尔奇自传 梦断代码 Innovation 浪潮之巅 关于“精通”的一篇博客《技能的反面：魔方和模仿》： http://www.cnblogs.com/xinz/archive/2011/08/07/2129751.html 在我教的《现代软件工程》课上，除了教科书，每个学生要看另一本相关的书籍并写读书分析。这个博客有一些同学的读书报告:  http://www.cnblogs.com/OMG-Team/archive/2011/10/25/2223247.html 转自： http://mindhacks.cn/2011/11/04/how-to-interview-a-person-for-two-years/ 读好书是如此的重要，因为好书往往带领你去到更好的书，更大的世界。","title":"怎样花两年时间去面试一个人"},{"content":"首先解释面上意思，service是业务层，dao是数据访问层。呵呵，这个问题我曾经也有过，记得以前刚学编程的时候，都是在service里直接调用dao，service里面就new一个dao类对象，调用，其他有意义的事没做，也不明白有这个有什么用，参加工作久了以后就会知道，业务才是工作中的重中之重。我们都知道，标准主流现在的编程方式都是采用MVC综合设计模式，MVC本身不属于设计模式的一种，它描述的是一种结构，最终目的达到解耦，解耦说的意思是你更改某一层代码，不会影响我其他层代码，如果你会像spring这样的框架，你会了解面向接口编程，表示层调用控制层，控制层调用业务层，业务层调用数据访问层。初期也许都是new对象去调用下一层，比如你在业务层new一个DAO类的对象，调用DAO类方法访问数据库，这样写是不对的，因为在业务层中是不应该含有具体对象，最多只能有引用，如果有具体对象存在，就耦合了。当那个对象不存在，我还要修改业务的代码，这不符合逻辑。好比主板上内存坏了，我换内存，没必要连主板一起换。我不用知道内存是哪家生产，不用知道多大容量，只要是内存都可以插上这个接口使用。这就是MVC的意义。接下来说你感觉service的意义，其实因为你现在做东西分层次不是那么严格，在一个你们做东西业务本身也少，举个最简单的例子，你做一个分页的功能，数据1000条，你20条在一个页，你可以把这个功能写成工具类封装起来，然后在业务层里调用这个封装的方法，这才是业务里真正干得事，只要没访问数据库的，都要在业务里写。 再有不明白的追问，这是经验问题，呵呵，其实以后你就会懂。只是刚开始写的代码都是有个请求，我就去数据库取，业务几乎没有。","title":"dao&service"},{"content":"从2002开始接触Java学会HelloWorld这么经典的程序到如今不知不觉已经十年啦，十年中 亲耳听到过不少大牛的演讲，见到过项目中的神人在键盘上运指如飞的编程速度，当时就 被震撼了。当编程越来越成体力活，我们还能有自己的思想，还能修炼为Java系统级别的 程序员嘛？学习与修炼以下知识与技能，帮你早日达成愿望。   一：Java语言学习 对线程(thread)，串行化，反射，网络编程，JNI技术，容器(Map,List, Iterator), 类加载器 (ClassLoader)，输入输出流，垃圾回收机制， 有比较深入的了解，最起码做过项目应用。有 过Java项目的性能优化经验，最起码掌握一种性能监视工具的使用，熟悉JVM参数，最起 码知道可以在JVM启动时指定不同垃圾回收机制，以及不同垃圾回收机制之间的 差别，熟悉JVM参数优化。 二：J2EE方面 最好知道JDBC规范是怎么回事情，面对Oracle数据库如果告诉你JDBC驱动不能用了，你 还知道有OCI驱动可以。掌握常见的SQL语句，熟悉JMS， JNDI等组件，掌握一套web开 发模式，从前台到后台，有能力整合好这样的框架。理解并掌握MVC思想，像SSH已经实 现了MVC的分层，几乎不需要你自己再实现，假设你开发一个简单的Swing程序，你能MVC 就说明你真的掌握了MVC的精髓。有能力在J2EE前端开发中构建自己的MVC模式，知道 什么是WEB2.0，知道什么是SOA， SaaS， SaaP等含义   三：理解并能合理运用设计模式，UML建模 知道并理解设计模式中蕴含的几种基本原则如：里氏替换原则， 开闭原则，合成复用原则， 依赖倒置原则有很好的理解，并能举例说明。对常用的设计模式如工厂模式，单例模式，观 察者模式，责任链模式，桥接模式等知道灵活运用，明白什么是回调(Callback)。最后用一位 高人话来总结设计模式，它是为了让软件更容易被别人读懂，更容易维护而产生，设计模 式本质是程序员之间的交流，如果A用工厂模式设计一个模块B来接替，A只要说该模块是 工厂模式实现，B维护起来应该容易得多，所以设计模式是关于交流，不关于代码。切忌滥 用设计模式。学会使用UML建模工具至少熟悉一种URL建模工具。   四：注重用户体验，掌握KISS原则，知道欧卡姆剃刀原则 顾客就是上帝这个口号我们已经喊了N年了，程序员的劳动成果最终也需要转换为服务提 供给客户，用户体验至关重要，常常看到的场景是功能实现了，软件很难使用，程序员有个 很充足的理由我不是美工，其实注重用户体验跟美工八杆子也打不到一起，FoxMail的成功 在很大程度是用户体验的成功，友好，清晰的用户提示，强的容错与纠错设计是获得好的 用户体验的不二法门。傻瓜相机顾名思义傻子都会使用，这个就著名的KISS原则(Keep it  simple and stupid)意思是UI设计要简单明了，傻子一看就知道怎么用，想想我们做出来的 东西，对照说明书都不知道怎么用。另外一个就是最著名的例子IPhone手机外观设计，是 典型的欧卡姆剃刀设计原则来完成人机交互。   五：自动测试与软件配置管理(SCM)实现 知道什么是软件配置管理，知道Hudson - http://java.net/projects/hudson/运用该工具SCM， 知道怎么获取测试代码覆盖率， Java有效代码行数(NCSS)，完成firebug， JDepend等工具 集成ant/maven。熟悉并注重在开发过程中使用JUnit单元测试，理解白盒测试规范。   六：熟悉常见的网络通信协议 对HTTP协议，知道POST, GET的区别是什么，阅读过HTTP相关的RFC文档。学会使用sniffer 工具查看数据包，帮助查找与调试程序，知道TCP与UDP的区别，知道并理解E-Mail发送 与接受的协议如SMTP， POP3，IMAP等协议，了解MIME与Base64编码。知道组播是怎 么回事情。   七：面向市场，永远对新技术保持渴望 计算机技术的发展日新月异，做为IT行业的软件开发人员要不断的给自己充电，更新自己 的技术与时代保持同步，同时还要面向市场，华为总裁任正非说过-“华为的技术革新必须面 向市场”，作为程序员同样要有市场意识，很多人都后悔没有在android刚出来的时候加以 关注学习。那些很早关注android开发技术的很多程序员因此获得丰厚回报。如今HTML5 得到越来越多的浏览器厂家支持，你是否已经跟上脚步，开始学习。   八：保持谦虚，三人行必有我师 乔帮主说他要保持初心，努力学习，我等更应该保持谦虚，IT技术发展日新月异，在你眼中 不可能实现的技术，也许别人早已经有思路。保持谦虚就有机会吸取别人身上的长处，古人 有云：满招损，谦受益。一个得道的高人更是说出了”下下人，上上智”的禅语。永远不要拒 绝帮助你周围的人解决难题，解决难题是进步最快途径。不要放弃任何一次可以提升自己技 术与能力的机会。   九：养成总结的习惯，不断反思 上学的时候老师常让写小结，也没总结出来所以然，以至于工作以后再也不提这档子事情， 建议每个项目做完以后对自己都有个小结，总结自己在项目里面学到了什么，反问自己能不 能完成在不需要别人帮助的情况下自己完成这样的系统搭建，是否熟悉与掌握项目中所用到 的技术，即使有些东西不是你负责完成的但是什么也不能阻挡一颗求知的心，总结要尽量详 细记录你遇到那些难题是怎么一个一个的解决的，下次再遇到你是否可以很快解决或者避免 这样的问题。有总结才有提高，孔子曰：学而不思则罔，如果我们只是coding到吐血，不 思考，不总结提高，永远不可能有能有本质提高，秦相李斯有云：“泰山不让土壤，故能 成其大，河海不择细流，故能就其深”，点滴积累不断总结方能量变导致质变。   十：数学功底与算法知识 用任何编程语言开发应用，都离不开核心算法支持，很多国外的软件单单从UI上看，恐怕写 几年程序的人都可以模仿，但是UI之下的那些真实深浅不一，相信不是你想模仿就可以模 仿的，为什么我们越来越山寨，因为我们没有核心竞争力，对于程序员来说算法与数学显然 是他最重要的核心竞争力之一。《算法导论》，《编程珠玑》等书绝对值得读十遍。微软亚洲 研究院视觉计算组负责人在一次演讲中说到他们招人的标准是“三好学生– 数学好，编程 好，态度好”。可是现实的普遍情况却是 - 微机原理闹危机，汇编语言不会变，实变函数学 十遍。计算机基础知识被大家普遍忽视。从今天开始好好学习吧……   十一：Java代码反编译与代码保护 Java编译产生字节码，因而可以被轻松的逆向工程(反编译)，微软的C#生产的DLL也一样可 以被轻松反编译。正式由于这个原因产生了许多Java开源的代码保护工具，而Proguard是 其中佼佼者，已经被google集成在android之中用于Java代码保护，访问这里了解更多： http://proguard.sourceforge.net/   十二：努力成为某个行业或者领域骨干 面对漫长的职业生涯，要想不被淘汰，必须具备一招鲜吃遍天下的能力，选择自己感兴趣的 方向，努力而深入的研究，计算机技术发展到今天已经细分很细，努力研究一种Java开源 框架或者开源HTTP服务器源码或者研究过网络爬虫源码或者WEBKIT内核，不愁没有人要 你。如果你是非常了解金融，企业ERP，证券，保险，移动应用行业的应用开发业务的人， 一样不用愁工作。这些知识不随语言而改变，努力做一个有核心竞争力的Java程序员。   十三：提高语言与书面表达能力，掌握基础的项目管理知识 文档与语言表达能力是最好的向外界展现自己能力的方式，很多程序员编程能力很高，表达 能力一般，Linux能够成功，除了归功于网络社区的力量之外，也得益于Linux作者本人给各 大基金会写信，宣传推广，试想如果没有良好的书面语言表达能力，即使Linux系统再优秀， 却无法被准确表达，失去各大基金会的支持，Linux还会像今天这么好的局面嘛。所以重视 文档，重视提升沟通与表达能力，才有可能成为Java系统程序员。掌握基本的2/8原则，学 会将模块细化分配给不同的人，预见并控制项目风险，把握项目进度，优化流程，合理的时 间管理，了解TDD，熟悉敏捷开发模式，常规软件开发模式。   十四：掌握英语，良好的读写能力 英语是计算机的母语，掌握好英语对于阅读英文资料学习新技术大有帮助，我的建议是尽量 读英文原版书，如果是算法方面的可能会困难一点，但是其它像设计模式，软件工程，OO 编程思想等尽量读原版，提高自己的英文水平，多多访问开发者，code project，程序员天堂， Pc-magazine等英文IT网站。英语绝对是你必须修炼与提高的技能。此外英语好在外资企业 尤其重要，只有外语足够好才可能在外资企业中突破职业瓶颈，向上发展。","title":"Java系统程序员修炼之道"},{"content":"类关系图       装饰模式：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比继承更为灵活。     Compontent 是定义一个对象接口，可以给这些对象动态地添加职责。ConcreteComponent 是定义了一个具体的对象，也可以给这个对象添加一些职责。Decorator，装饰抽象类，继承了 Component，从外类来 扩展 Component 类的功能，但对于 Component 来说，是无需知道 Drecoratot 的存在的，ConcreteDecorator 就是具体的装饰对象，起到给 Component 添加职责的功能功能。     例：一杯咖啡，可以加糖、加奶、大杯……但它仍旧是一杯咖啡，只是对咖啡进行了装饰     [java:showcolumns] view plaincopyprint? ·········10········20········30········40········50········60········70········80········90········100·······110·······120·······130·······140·······150 public interface IComponent {       void showCoffee();              double showPrice();   }   public class Coffee implements IComponent {       private String name;       private double price;       public Coffee(String name, double price) {           this.setName(name);           this.setPrice(price);       }       public String getName() {           return name;       }       public void setName(String name) {           this.name = name;       }       public double getPrice() {           return price;       }       public void setPrice(double price) {           this.price = price;       }       @Override       public void showCoffee() {           System.out.println(\"的\" + this.getName() + \"咖啡\");       }       @Override       public double showPrice() {           return this.getPrice();       }   }   public abstract class Decorator implements IComponent {       private IComponent component;       public void setComponent(IComponent component) {           this.component = component;       }       @Override       public void showCoffee() {           component.showCoffee();       }       @Override       public double showPrice() {           return component.showPrice();       }   }   public class Sugar extends Decorator {       @Override       public void showCoffee() {           System.out.print(\"加糖\");           super.showCoffee();       }       @Override       public double showPrice() {           return 8.0 + super.showPrice();       }   }   public class Milk extends Decorator {       @Override       public void showCoffee() {           System.out.print(\"加奶\");           super.showCoffee();       }       @Override       public double showPrice() {           return 15.0 + super.showPrice();       }   }   public class Test {       public static void main(String[] args) {           Coffee coffee = new Coffee(\"拿铁\", 55.0);           Decorator sugar = new Sugar();           Decorator milk = new Milk();                      sugar.setComponent(coffee);           milk.setComponent(sugar);           milk.showCoffee();           System.out.println(milk.showPrice());       }   }      最后输出：","title":"装饰模式"},{"content":"Spring 的骨骼架构 　　Spring 总共有十几个组件，但是真正核心的组件只有几个，下面是 Spring 框架的总体架构图： 　　图 1 .Spring 框架的总体架构图   　　从上图中可以看出 Spring 框架中的核心组件只有三个：Core、Context 和 Beans。它们构建起了整个 Spring 的骨骼架构。没有它们就不可能有 AOP、Web 等上层的特性功能。下面也将主要从这三个组件入手分析 Spring。 　　Spring 的设计理念 　　前面介绍了 Spring 的三个核心组件，如果再在它们三个中选出核心的话，那就非 Beans 组件莫属了，为何这样说，其实 Spring 就是面向 Bean 的编程(BOP,Bean Oriented Programming)，Bean 在 Spring 中才是真正的主角。 　　Bean 在 Spring 中作用就像 Object 对 OOP 的意义一样，没有对象的概念就像没有面向对象编程，Spring 中没有 Bean 也就没有 Spring 存在的意义。就像一次演出舞台都准备好了但是却没有演员一样。为什么要 Bean 这种角色 Bean 或者为何在 Spring 如此重要，这由 Spring 框架的设计目标决定，Spring 为何如此流行，我们用 Spring 的原因是什么，想想你会发现原来 Spring 解决了一个非常关键的问题他可以让你把对象之间的依赖关系转而用配置文件来管理，也就是他的依赖注入机制。而这个注入关系在一个叫 Ioc 容器中管理，那 Ioc 容器中有又是什么就是被 Bean 包裹的对象。Spring 正是通过把对象包装在 Bean 中而达到对这些对象管理以及一些列额外操作的目的。 　　它这种设计策略完全类似于 Java 实现 OOP 的设计理念，当然了 Java 本身的设计要比 Spring 复杂太多太多，但是都是构建一个数据结构，然后根据这个数据结构设计他的生存环境，并让它在这个环境中按照一定的规律在不停的运动，在它们的不停运动中设计一系列与环境或者与其他个体完成信息交换。这样想来回过头想想我们用到的其他框架都是大概类似的设计理念。 　　核心组件如何协同工作 　　前面说 Bean 是 Spring 中关键因素，那 Context 和 Core 又有何作用呢?前面把 Bean 比作一场演出中的演员的话，那 Context 就是这场演出的舞台背景，而 Core 应该就是演出的道具了。只有他们在一起才能具备能演出一场好戏的最基本的条件。当然有最基本的条件还不能使这场演出脱颖而出，还要他表演的节目足够的精彩，这些节目就是 Spring 能提供的特色功能了。 　　我们知道 Bean 包装的是 Object，而 Object 必然有数据，如何给这些数据提供生存环境就是 Context 要解决的问题，对 Context 来说他就是要发现每个 Bean 之间的关系，为它们建立这种关系并且要维护好这种关系。所以 Context 就是一个 Bean 关系的集合，这个关系集合又叫 Ioc 容器，一旦建立起这个 Ioc 容器后， Spring 就可以为你工作了。那 Core 组件又有什么用武之地呢?其实 Core 就是发现、建立和维护每个 Bean 之间的关系所需要的一些列的工具，从这个角度看来，Core 这个组件叫 Util 更能让你理解。 　　它们之间可以用下图来表示： 　　图 2. 三个组件关系   　　核心组件详解 　　这里将详细介绍每个组件内部类的层次关系，以及它们在运行时的时序顺序。我们在使用 Spring 是应该注意的地方。 　　Bean 组件 　　前面已经说明了 Bean 组件对 Spring 的重要性，下面看看 Bean 这个组件式怎么设计的。Bean 组件在 Spring 的 org.springframework.beans 包下。这个包下的所有类主要解决了三件事：Bean 的定义、Bean 的创建以及对 Bean 的解析。对 Spring 的使用者来说唯一需要关心的就是 Bean 的创建，其他两个由 Spring 在内部帮你完成了，对你来说是透明的。 　　Spring Bean 的创建时典型的工厂模式，他的顶级接口是 BeanFactory，下图是这个工厂的继承层次关系： 　　图 4. Bean 工厂的继承关系   　　BeanFactory 有三个子类：ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory。但是从上图中我们可以发现最终的默认实现类是 DefaultListableBeanFactory，他实现了所有的接口。那为何要定义这么多层次的接口呢?查阅这些接口的源码和说明发现，每个接口都有他使用的场合，它主要是为了区分在 Spring 内部在操作过程中对象的传递和转化过程中，对对象的数据访问所做的限制。例如 ListableBeanFactory 接口表示这些 Bean 是可列表的，而 HierarchicalBeanFactory 表示的是这些 Bean 是有继承关系的，也就是每个 Bean 有可能有父 Bean。AutowireCapableBeanFactory 接口定义 Bean 的自动装配规则。这四个接口共同定义了 Bean 的集合、Bean 之间的关系、以及 Bean 行为。         Bean 的定义主要有 BeanDefinition 描述，如下图说明了这些类的层次关系： 　　图 5. Bean 定义的类层次关系图   　　Bean 的定义就是完整的描述了在 Spring 的配置文件中你定义的节点中所有的信息，包括各种子节点。当Spring 成功解析你定义的一个节点后，在 Spring 的内部他就被转化成 BeanDefinition 对象。以后所有的操作都是对这个对象完成的。 　　Bean 的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。Bean 的解析主要就是对 Spring 配置文件的解析。这个解析过程主要通过下图中的类完成： 　　图 6. Bean 的解析类   　　当然还有具体对 tag 的解析这里并没有列出。 　　Context 组件 　　Context 在 Spring 的 org.springframework.context 包下，前面已经讲解了 Context 组件在 Spring 中的作用，他实际上就是给 Spring 提供一个运行时的环境，用以保存各个对象的状态。下面看一下这个环境是如何构建的。 　　ApplicationContext 是 Context 的顶级父类，他除了能标识一个应用环境的基本信息外，他还继承了五个接口，这五个接口主要是扩展了 Context 的功能。下面是 Context 的类结构图： 　　图 7. Context 相关的类结构图   　　从上图中可以看出 ApplicationContext 继承了 BeanFactory，这也说明了 Spring 容器中运行的主体对象是 Bean，另外 ApplicationContext 继承了 ResourceLoader 接口，使得 ApplicationContext 可以访问到任何外部资源，这将在 Core 中详细说明。 　　ApplicationContext 的子类主要包含两个方面： 　　ConfigurableApplicationContext 表示该 Context 是可修改的，也就是在构建 Context 中用户可以动态添加或修改已有的配置信息，它下面又有多个子类，其中最经常使用的是可更新的 Context，即 AbstractRefreshableApplicationContext 类。 　　WebApplicationContext 顾名思义，就是为 web 准备的 Context 他可以直接访问到 ServletContext，通常情况下，这个接口使用的少。 　　再往下分就是按照构建 Context 的文件类型，接着就是访问 Context 的方式。这样一级一级构成了完整的 Context 等级层次。 　　总体来说 ApplicationContext 必须要完成以下几件事： 　　标识一个应用环境 　　利用 BeanFactory 创建 Bean 对象 　　保存对象关系表 　　能够捕获各种事件 　　Context 作为 Spring 的 Ioc 容器，基本上整合了 Spring 的大部分功能，或者说是大部分功能的基础。 　　Core 组件 　　Core 组件作为 Spring 的核心组件，他其中包含了很多的关键类，其中一个重要组成部分就是定义了资源的访问方式。这种把所有资源都抽象成一个接口的方式很值得在以后的设计中拿来学习。下面就重要看一下这个部分在 Spring 的作用。 　　下图是 Resource 相关的类结构图： 　　图 8. Resource 相关的类结构图   　　从上图可以看出 Resource 接口封装了各种可能的资源类型，也就是对使用者来说屏蔽了文件类型的不同。对资源的提供者来说，如何把资源包装起来交给其他人用这也是一个问题，我们看到 Resource 接口继承了 InputStreamSource 接口，这个接口中有个 getInputStream 方法，返回的是 InputStream 类。这样所有的资源都被可以通过 InputStream 这个类来获取，所以也屏蔽了资源的提供者。另外还有一个问题就是加载资源的问题，也就是资源的加载者要统一，从上图中可以看出这个任务是由 ResourceLoader 接口完成，他屏蔽了所有的资源加载者的差异，只需要实现这个接口就可以加载所有的资源，他的默认实现是 DefaultResourceLoader。","title":"Spring框架的设计理念与设计模式分析（一）"},{"content":"Java 动态代理机制的出现，使得 Java 开发人员不用手工编写代理类，只要简单地指定一组接口及委托类对象，便能动态地获得代理类。代理类会负责将所有的方法调用分派到委托对象上反射执行，在分派执行的过程中，开发人员还可以按需调整委托类对象及其功能，这是一套非常灵活有弹性的代理框架。通过阅读本文，读者将会对 Java 动态代理机制有更加深入的理解。本文首先从 Java 动态代理的运行机制和特点出发，对其代码进行了分析，推演了动态生成类的内部实现。 代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。   为了保持行为的一致性，代理类和委托类通常会实现相同的接口，所以在访问者看来两者没有丝毫的区别。通过代理类这中间一层，能有效控制对委托类对象的直接访问，也可以很好地隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。Java 动态代理机制以巧妙的方式近乎完美地实践了代理模式的设计理念。 相关类和接口 java.lang.reflect.Proxy：这是 Java 动态代理机制的主类，它提供了一组静态方法来为一组接口动态地生成代理类及其对象。  清单 1. Proxy 的静态方法 \t\t\t\t\t\t// 方法 1: 该方法用于获取指定代理对象所关联的调用处理器static InvocationHandler getInvocationHandler(Object proxy) // 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象static Class getProxyClass(ClassLoader loader, Class[] interfaces) // 方法 3：该方法用于判断指定类对象是否是一个动态代理类static boolean isProxyClass(Class cl) // 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例static Object newProxyInstance(ClassLoader loader, Class[] interfaces,     InvocationHandler h)  java.lang.reflect.InvocationHandler：这是调用处理器接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。  清单 2. InvocationHandler 的核心方法 \t\t\t\t\t\t// 该方法负责集中处理动态代理类上的所有方法调用。第一个参数既是代理类实例，第二个参数是被调用的方法对象// 第三个方法是调用参数。调用处理器根据这三个参数进行预处理或分派到委托类实例上发射执行Object invoke(Object proxy, Method method, Object[] args)  每次生成动态代理类对象时都需要指定一个实现了该接口的调用处理器对象（参见 Proxy 静态方法 4 的第三个参数）。 java.lang.ClassLoader：这是类装载器类，负责将类的字节码装载到 Java 虚拟机（JVM）中并为其定义类对象，然后该类才能被使用。Proxy 静态方法生成动态代理类同样需要通过类装载器来进行装载才能使用，它与普通类的唯一区别就是其字节码是由 JVM 在运行时动态生成的而非预存在于任何一个 .class 文件中。 每次生成动态代理类对象时都需要指定一个类装载器对象（参见 Proxy 静态方法 4 的第一个参数）","title":"JAVA代理机制2"},{"content":"1、什么是UML？具体包括哪些内容？    答：标准建模语言UML。包括用例图，静态图(包括类图、对象图和包图)，行为图，交互图(顺序图和合作图)和实现图。 2、Java EE常用的设计模式？    答：Java中的23种设计模式包括：Factory（工厂模式），Builder（建造模式），FactoryMethod（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式），Facade（门面模式），Adapter（适配器模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模式），Flyweight（享元模式），Proxy（代理模式），Command（命令模式），?Interpreter（解释器模式），Visitor（访问者模式），Iterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibleity（责任链模式） 3、说说你是如何理解工厂模式的？    答：工厂模式是一种经常被使用到的模式，根据工厂模式实现的类可以根据提供的数据生成一组类中某一个类的实例，通常这一组类都拥有一个公共的抽象父类并且实现了相同的方法，但是，这些方法针对不同的数据进行了不同的操作。     工厂模式的具体实现方法是：首先需要定义一个基类，该类的子类通过不同的方法实现了基类中的方法。然后需要定义一个工厂类，工厂类可以根据条件生成不同的子类实例。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。  4、确定模块的功能和模块的接口是在软件设计的那个队段完成的? 　 答：概要设计阶段。","title":"UML面试题"},{"content":"简单工厂模式，工厂方法模式和抽象工厂模式都是属于创建型设计模式，这三种创建型模式都不需要知道具体类。我们掌握一种思想，就是在创建一个对象时，需要把容易发生变化的地方给封装起来，来控制变化（哪里变化，封装哪里），以适应客户的变动，项目的扩展。用这三种设计模式都可以实现，那究竟这三种设计模式有什么异同呢？下面根据这三者之间的特点，优点，缺点，适用范围进行比较。 一．特点 简单工厂模式：专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。它又称为静态工厂方法模式。它的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。在这个模式中，工厂类是整个模式的关键所在。它包含必要的判断逻辑，能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。用户在使用时可以直接根据工厂类去创建所需的实例，而无需了解这些对象是如何创建以及如何组织的。有利于整个软件体系结构的优化。   工厂方法模式：工厂方法是粒度很小的设计模式，因为模式的表现只是一个抽象的方法。提前定义用于创建对象的接口，让子类决定实例化具体的某一个类，即在工厂和产品中间增加接口，工厂不再负责产品的创建，由接口针对不同条件返回具体的类实例，由具体类实例去实现。工厂方法模式是简单工厂模式的衍生，解决了许多简单工厂模式的问题。首先完全实现‘开－闭 原则’，实现了可扩展。其次实现更复杂的层次结构，可以应用于产品结果复杂的场合。工厂方法模式是对简单工厂模式进行了抽象。有一个抽象的Factory类（可以是抽象类和接口），这个类将不在负责具体的产品生产，而是只制定一些规范，具体的生产工作由其子类去完成。在这个模式中，工厂类和产品类往往可以依次对应。即一个抽象工厂对应一个抽象产品，一个具体工厂对应一个具体产品，这个具体的工厂就负责生产对应的产品。   抽象工厂模式：抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。它有多个抽象产品类，每个抽象产品类可以派生出多个具体产品类，一个抽象工厂类，可以派生出多个具体工厂类，每个具体工厂类可以创建多个具体产品类的实例。每一个模式都是针对一定问题的解决方案，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式针对的是多个产品等级结果。   二．优点 简单工厂模式：工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅\"消费\"产品。简单工厂模式通过这种做法实现了对责任的分割。简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。通过它，外界可以从直接创建具体产品对象的尴尬局面中摆脱出来。外界与具体类隔离开来，偶合性低。明确区分了各自的职责和权力，有利于整个软件体系结构的优化。                       工厂方法模式：工厂方法模式是为了克服简单工厂模式的缺点（主要是为了满足OCP）而设计出来的。简单工厂模式的工厂类随着产品类的增加需要增加很多方法（或代码），而工厂方法模式每个具体工厂类只完成单一任务，代码简洁。工厂方法模式完全满足OCP，即它有非常良好的扩展性。                       抽象工厂模式：抽象工厂模式主要在于应对“新系列”的需求变化。分离了具体的类，抽象工厂模式帮助你控制一个应用创建的对象的类，因为一个工厂封装创建产品对象的责任和过程。它将客户和类的实现分离，客户通过他们的抽象接口操纵实例，产品的类名也在具体工厂的实现中被分离，它们不出现在客户代码中。它使得易于交换产品系列。一个具体工厂类在一个应用中仅出现一次——即在它初始化的时候。这使得改变一个应用的具体工厂变得很容易。它只需改变具体的工厂即可使用不同的产品配置，这是因为一个抽象工厂创建了一个完整的产品系列，所以整个产品系列会立刻改变。它有利于产品的一致性。当一个系列的产品对象被设计成一起工作时，一个应用一次只能使用同一个系列中的对象，这一点很重要，而抽象工厂很容易实现这一点。抽象工厂模式有助于这样的团队的分工，降低了模块间的耦合性，提高了团队开发效率。                       三．缺点 简单工厂模式：当产品有复杂的多层等级结构时，工厂类只有自己，以不变应万变，就是模式的缺点。因为工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，有可能造成工厂逻辑过于复杂,违背了\"开放--封闭\"原则(OCP).另外，简单工厂模式通常使用静态工厂方法，这使得无法由子类继承，造成工厂角色无法形成基于继承的等级结构。                       工厂方法模式：不易于维护，假如某个具体产品类需要进行一定的修改，很可能需要修改对应的工厂类。当同时需要修改多个产品类的时候，对工厂类的修改会变得相当麻烦（对号入座已经是个问题了）。                       抽象工厂模式：抽象工厂模式在于难于应付“新对象”的需求变动。难以支持新种类的产品。难以扩展抽象工厂以生产新种类的产品。这是因为抽象工厂几乎确定了可以被创建的产品集合，支持新种类的产品就需要扩展该工厂接口，这将涉及抽象工厂类及其所有子类的改变。                        四．适用范围 简单工厂模式：工厂类负责创建的对象比较少，客户只知道传入了工厂类的参数，对于始何创建对象（逻辑）不关心。                       工厂方法模式：当一个类不知道它所必须创建对象的类或一个类希望由子类来指定它所创建的对象时，当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候，可以使用工厂方法。                       抽象工厂模式：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的。这个系统有多于一个的产品族，而系统只消费其中某一产品族。同属于同一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来。系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。                       其实，无论是简单工厂模式、工厂模式还是抽象工厂模式，它们本质上都是将不变的部分提取出来，将可变的部分留作接口，以达到最大程度上的复用。究竟用哪种设计模式更适合，这要根据具体的业务需求来决定。","title":"简单工厂模式，工厂方法模式和抽象工厂模式的异同"},{"content":"说明 键组合 打开报表生成器菜单。 Alt+F 创建报表。 Ctrl+N 打开报表。 Ctrl+O 保存报表。 Ctrl+S、Alt+S 在报表生成器的各区域之间移动，例如功能区、设计图面、“分组”窗格、“属性”窗格和“数据”窗格。 F6、Shift+F6 移动到功能区。 Alt 移动到功能区上的“主文件夹”选项卡。 Alt+H 移动到功能区上的“插入”选项卡。 Alt+I 移动到功能区上的“视图”选项卡。 Alt+V 激活各区域之间的分隔线，例如，“分组”窗格与设计图面之间的分隔线。 Tab 移动区域之间的分隔线。 任意箭头键。使用向上键和向下键可移动“分组”窗格和设计图面之间的分隔线。使用向右键和向左键可移动“报表数据”窗格和设计图面之间的分隔线。 在报表生成器的某个区域内移动，例如在一个功能区选项卡内移动。 Tab、Shift+Tab 在功能区选项卡之间移动。 向右键、向左键 浏览下拉菜单。 任意箭头键 在设计图面上选择项。 Tab、Shift+Tab 在设计图面上移动选定项。 任意箭头键 在设计图面上以较小增量移动选定项。 Ctrl + 箭头键 在设计图面上调整选定项的大小。 Shift + 箭头键 在设计图面上以较小增量调整选定项的大小。 Ctrl + Shift + 箭头键 将多个选定项的边缘对齐。 Alt+H+A 运行报表。 F5、Alt+H+R 切换到设计模式。 F8 复制 Ctrl+C、Alt+H+C 剪切 Ctrl+X、Alt+H+X 粘贴 Ctrl+V、Alt+H+V 全选。 Ctrl+A 撤消 Ctrl+Z、Alt+Z 重做 Ctrl+Y、Alt+Y 放大。 Ctrl + 加号 (+) 缩小。 Ctrl + 减号 (-) 选中和取消选中“视图”选项卡上的复选框。 空格键 在“主文件夹”选项卡上显示字体系列列表、字号列表或边框点大小列表。 Alt + 向下键 显示字体颜色列表。 向下键 显示帮助。 F1 合并表单元。 Alt+H+M 拆分表单元。 Alt+H+U 插入表。 Alt+I+A 插入矩阵。 Alt+I+M 插入列表。 Alt+I+L 插入图表。 Alt+I+C 插入仪表。 Alt+I+G 插入地图 Alt+I+P 插入数据条。 Alt+I+D 插入迷你图。 Alt+I+K 插入指示器。 Alt+I+U 插入文本框。 Alt+I+T 插入图像。 Alt+I+I 插入行。 Alt+I+N 插入矩形。 Alt+I+E 插入子报表。 Alt+I+S 插入报表表头。 Alt+I+H 插入报表表尾。 Alt+I+F 在选择地图视区时平移地图视图区域。 Ctrl + 箭头键 在选择地图视区时放大地图视图区域。 Ctrl + 加号 (+) 在选择地图视区时缩小地图视图区域。 Ctrl + 减号 (-) 在选择地图视区时平移并放大地图视区的快捷键模式。 Ctrl + 单击左键","title":"[置顶] Report Builder 中的快捷键"},{"content":"序 这篇《设计模式之路》是看完四人帮的《design pattern》之后的感悟。《设计模式》重剑无锋，大巧不工。即使有很好的编程基础，很高的英语阅读水平，也未必能窥知全貌。笔者试图将《设计模式》演绎为通俗易懂的白话，简单生动的故事。在闲暇时光，重温旧知，也是一件惬意的事情。 为什么取名为on road？是因为笔者一直在探求知识的路上，而这条路永无终止！ 顺便说一句，想不看《设计模式》，直接看了本文就想弄懂什么是设计模式的，有点儿不切实际。本文源于经典，不能超越经典，必须有点儿基础再来看看。 另外，《设计模式》这本书也需要懂一些UML的知识，如果没有的话，请在百度或者谷歌一些UML的基本知识，至少需要知道什么是依赖、继承、组合、聚合之类的概念。 起 《设计模式》这本书起源于一个文本编辑器的开发案例。我相信这四个老贼选取这个案例要么是他们在开发过程中真正的痛苦过；要么就是非常鸡贼的，有远见的，刻意的选取。我相信前者的原因居多。科学来源于实践，能在开篇中就将lexi编辑器举出实例，且映射了8个设计模式的案例一一列举。没有经历过（这个编辑器的开发过程），让人很难相信。 一个文本编辑器，设计的8中设计模式如下： 组合模式 策略模式 修饰器模式 抽象工厂模式 工厂模式 桥接模式 命令模式 迭代器模式 组合模式 组合模式在Lexi编辑器这个case中出场的情形最普通。就是设计者（使用者、开发者，随便怎么称呼吧）需要对编辑器中的字符、文字、图片、行、列等“对象”，进行统一的处理，不希望这些“散乱”的对象有不同的行为和属性。就设计了一个名字叫做Glyph的抽象类，这些“对象”就被实例化自Glyph类的子类。 这里不讨论为什么统一了行为就是合理的（本人从来相信“有钱难买我喜欢”，但要证明这个统一行为的合理性，要浪费我不少字，我一向又懒得写字），姑且我们认为“存在即合理”或“四个老家伙”“喜欢这样的统一性”。简单说下组合模式的使用特性： 要组合的类，必须具有统一的行为接口，比如上文的字符、文字，都有size，都能自我draw（渲染），都能知道自己在文档中的位置（postion）。 要组合的类，必须能够递归组合，即一个Glyph必须能包含若干个子Glyph类得对象，而且一个Glyph可以有一个父类Glyph对象。 要组合的类，根据第3点，能够像一棵树一样，从不同的node之间进行对象的游历（注意，我说游历，这里不使用“遍历”，为的是和迭代器模式区分开）。游历的方式包括“父类.getChildren()”和“子类.getParent()”之类的明显的表示方法。 组合模式，要区分于UML中的类或对象之间的“组合”关系。UML中的“组合”的关系，是描述两个类之间的关系的，而组合模式是描述具有上述三点特征的一组类之间的“组合”或者“聚合”的关系的。 [2012-07-11 to be continued...]","title":"Design Pattern On Road"},{"content":"【业务知识】浅议基于系统规范的设计创新（二） ----by samson 自定义手势 触摸手势如今成为了移动设备的一种标志性交互方式。Iphone通过触摸手势给用户带来了“直接操作”的体验概念——人们发现可以像在现实物理世界中操作物体那样去操控软件，这也是手势交互被大众广泛接受的原因。良好的触摸手势，能让用户自动映射到日常生活中的交互行为，让用户感觉亲切、自然，这些动作发自本能，一学即会。反之，一些动作不是来自熟知的物理世界或非系统既有，那就没那么容易发现并易于使用了。   手势的创新大抵可以分为两种，一种是对系统标准手势的功能扩展，即手势动作是系统既有的，但其对应的功能或响应的反馈做了改变；另一种则是完全自定义手势，譬如iphone平台上的多点触控（超过两点）。一般而言，前者的学习成本低，易于发现，发现之后又易于记忆掌握。在一些优秀app中，这种手势扩展方式已经运用的非常娴熟了。 关于手势有太多的话题，这里我们只聚焦于原生系统与那些优秀创新的app在手势操作设计上的相通之处。生硬的模仿往往是蹩脚的，但有时当我们想创意地解决一些问题时，灵感常常从经典中来。   iphone常用标准手势[1]     Pull-to-refresh Pull-to-refresh(拉动刷新)如今几乎已是业界的一种标准交互设计模式。最先发明这种手势触发刷新模式的是Twiiter的设计师。但这个设计并非是一蹴而就的，在第一个版本中，加载按钮被塞到了列表顶部，当用户滚动（Scroll）屏幕至顶部时，很自然地就会看到这个按钮，比起单纯把刷新放在工具栏上，这已是一个不小的创新进步了。接下来，Twiiter的设计师又进一步地改良了这个手势操作：滚动至页面顶部，会出现一条隐藏的文字信息：“pull down to refresh”（下拉刷新），当下拉了足够距离后，又显示“release to refresh”（松手吧）。整个交互过程是一种对标准滚动操作的一种功能扩展，非常容易发现、学习、使用。 twiiter的pull-to-refresh[2]   回到Twiiter第一版的设计，当初Twiiter设计师是如何走出第一步，福至心灵，把加载按钮隐藏在页面顶部的呢？我们来看一看系统的信息应用，在短信列表界面，同样把搜索栏藏在了列表顶部，当用户滚动短信列表时，搜索栏会很自然地出现。我们可以发现，两者的设计模式是如此相似。 信息应用中滚屏显示搜索栏     Clear——将标准手势发扬光大了一遍 Clear是一款全手势操作的任务管理应用。它绕过了通用的控件，让一些通常作为快捷方式的手势来作为唯一的交互方式，配合动态、积极的反馈，使得整个交互流程酷炫无比。可观察这些眼花缭乱的手势后，我们可以发现clear采用的全是常用的系统标准手势。 Clear的每个界面都是列表视图，向左滑动（swipe）列表项可删除任务。这也是iOS中一种删除信息的快捷手势操作。但是clear对其进行了“加工改造”，它省去了二次确认的步骤，在交互流程中，加入了直观的动效反馈和细腻的UI变化，这样一来用户对这个手势仍然熟悉，但对整个设计的感觉却是耳目一新。接下来仿佛是水到渠成般地，clear按照对称法则加入了向右滑动的手势，功能也是与“删除”所相对应的功能——“完成”。       Clear另一个出彩的手势是双指缩放（Pinch&Spread），在iphone中该手势用于缩放图片内容。Clear巧妙地利用这个手势完成类似的目的——把一堆任务条目归到一起或分开；这与现实世界中的操作体验也是非常一致的。唯一遗憾的是两指捏合这个手势在手机屏幕上使用起来并不是非常舒适高效，如果是在ipad上，5指的缩放可更大有可为。 Pinch手势归拢信息条目   结语 在标准手势的基础上进行扩展设计，可以大大降低用户发现手势操作的门槛和学习的成本。另外，从传统中衍变往往会比平地建新楼更让人感到功力和底蕴。   待续…… 【1】       图片来自来自http://gesturecons.com/ 【2】       图片截自《Tapworthy.Desiging Great Iphone Apps》，作者 Josh Clark 本文原创自无线技术运营空间： http://wireless.qzone.qq.com 及 http://blog.csdn.net/wireless_tech （专注无线技术运营——无线技术(操作系统/数据库/WEB前端/负载均衡/系统容灾/系统安全/短信接入/WAP接入/3G等)、无线业务运营、无线开放平台、统计分析(用户行为分析/数据挖掘)、CP合作，联系我们：1780551083@qq.com） ","title":"浅议基于系统规范的设计创新（二）"},{"content":"委托模式是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。委托模式是一项基本技巧，许多其他的模式，如状态模式、策略模式、访问者模式本质上是在更特殊的场合采用了委托模式。委托模式使得我们可以用聚合来替代继承，它还使我们可以模拟mixin。 　　“委托”在C#中是一个语言级特性，而在Java语言中没有直接的对应，但是我们可以通过动态代理来实现委托！代码如下： import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy;     public abstract class Delegator implements InvocationHandler {     //--------------------------------------------     protected Object obj_orgin = null; //原始对象     protected Object obj_proxy = null; //代理对象     //--------------------------------------------     public Delegator() {     }     public Delegator(Object orgin) {         this.createProxy(orgin);     }         protected Object createProxy(Object orgin) {         obj_orgin = orgin;         //下面语句中orgin.getClass().getClassLoader()为加载器，orgin.getClass().getInterfaces()为接口集         obj_proxy = Proxy.newProxyInstance(orgin.getClass().getClassLoader(), orgin.getClass().getInterfaces(), this); //委托         return obj_proxy;     }         protected Object invokeSuper(Method method, Object[] args) throws Throwable {         return method.invoke(obj_orgin, args);     }     //--------------实现InvocationHandler接口，要求覆盖------------     //下面实现的方法是当委托的类调用toString()方法时，操作其他方法而不是该类默认的toString()，这个类的其他方法则不会。     public Object invoke(Object obj, Method method, Object[] args) throws Throwable {         // 缺省实现：委托给obj_orgin完成对应的操作         if (method.getName().equals(\"toString\")) { //对其做额外处理             return this.invokeSuper(method, args) + \"$Proxy\";         } else { //注意，调用原始对象的方法，而不是代理的（obj==obj_proxy）             return this.invokeSuper(method, args);         }     } }   下面的代码，则是作为一个委托的例子，实现Map的功能。 import java.io.IOException; import java.lang.reflect.Method; import java.util.Hashtable; import java.util.Map; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import com.bs2.core.UtilLog; public class Delegator4Map extends Delegator {     private static Log _log = LogFactory.getLog(Delegator4Map.class);     private Map orginClass = null; //原始对象     private Map proxyClass = null; //代理对象     public Map getOrgin() {         return orginClass;     }     public Map getProxy() {         return proxyClass;     }     public Delegator4Map(Map orgin) {         super(orgin);         orginClass = orgin;         proxyClass = (Map) super.obj_proxy;     }     public Object invoke(Object obj, Method method, Object[] args) throws Throwable {         if (method.getName().equals(\"size\")) { //修改size处理逻辑             Object res2 = new Integer(-1);             System.out.println(\"调用委托的方法\");             return res2;         } else {             System.out.println(\"调用原始的方法\");             return super.invoke(obj, method, args);         }     }     public static void main(String[] args) throws IOException {         Delegator4Map rtm = new Delegator4Map(new Hashtable());         Map m = rtm.getProxy();         m.size();     } }","title":"Java中的委托模式"},{"content":"        桥接模式的特点:  桥接模式的主要目的是将一个对象的变化因素抽象出来，不是通过类继承的方式来满足这个因素的变化，而是通过对象组合的方式来依赖因素的抽象，这样当依赖的因素的具体实现发生变化后，而我们的具体的引用却不用发生改变，因为我们的对象是依赖于抽象的，而不是具体的实现。  而且，通过这样的依赖抽象，我们在多个对象共享这样的因素的时候，就成为可能，如果我们使用的是具体的因素的共享，当我们改变这个变化因素的时候，我们必须把使用这个因素的所有的对象，都进行相应的修改，而如果所有的引用这个变化因素的对象都依赖于抽象而不是具体的依赖呢？这也为我们的共享的提供了变化性。           桥接模式的使用场景: 1、当一个对象有多个变化因素的时候，通过抽象这些变化因素，将依赖具体实现，修改为依赖抽象。 2、当某个变化因素在多个对象中共享时。我们可以抽象出这个变化因素，然后实现这些不同的变化因素。  3、当我们期望一个对象的多个变化因素可以动态的变化，而且不影响客户的程序的使用时。          由于有些对象具有两个或者多个维度的变化，通过使用桥接模式可以使得对象能够轻松的沿着多个方向进行自由变化。            例如：图形有各种类型的图形，矩形、 圆形等。图形 又可被不同的绘图程序来绘制 。               window窗口有很多种类，在不同的操作系统平台上又不同。          以上两个例子都是对象在不同层次上的继承关系，两个层次间通过对象聚合实现连接 即桥接             c++  实现代码如下：   class CImplementor   { public: CImplementor(); virtual ~CImplementor(); virtual void OperationImp()=0; };   class CImplementorA  : public CImplementor { public: CImplementorA(){printf(\"CImplementorA Constructor\\n\");};; virtual void OperationImp(){printf(\"CImplementorA OpeartionImp \\n\");}; };   class CImplementorB : public CImplementor { public: CImplementorB(){printf(\"CImplementorB Constructor\\n\");};; virtual void OperationImp(){printf(\"CImplementorB OpeartionImp \\n\");}; };   class CAbstraction { public: virtual void Operation()=0; protected: CImplementor* m_lpImplementor; private:   };   class CRefinedAbstraction:public CAbstraction { public: CRefinedAbstraction(CImplementor* pImp){m_lpImplementor=pImp;}; virtual void Operation(){m_lpImplementor->OperationImp();}; };   int main(int argc, char* argv[]) { CAbstraction* as=new CRefinedAbstraction(new CImplementorA); as->Operation(); getchar(); return 0; } 独立博客地址： http://www.gddhx.com/post/25.html","title":"设计模式之桥接模式 及 c++ 实现"},{"content":"  装饰模式原理请随便找书看一下，这里直接给例子： 生产一把刀需要两个工序，工序一和工序二   Process：生产 Component：原料（生产刀具的原材料是棒料 bar） Procedure：生产刀具工序 FirstProcedure：工序一 SecondProcedure：工序二 from __future__ import divisionfrom __future__ import print_functionfrom __future__ import unicode_literalsfrom future_builtins import *import sysclass Process(object):    def __init__(self):        super(Process,self).__init__()        pass    def make(self):        pass    class Component(Process):    def __init__(self):        super(Component,self).__init__()        pass    def make(self):        print(\"bar\")        pass    pass                class Procedure(Process):    component=Process()    def __init__(self,comp):        super(Procedure,self).__init__()        self.component=comp                pass    def make(self):        print('procedure')        pass    passclass FirstProcedure(Procedure):    def __init__(self,component):        super(FirstProcedure,self).__init__(component)        pass    def make(self):        self.component.make()        print('firs procedure')        pass    pass                class SecondProcedure(Procedure):    def __init__(self,component):        super(SecondProcedure,self).__init__(component)        pass    def make(self):        self.component.make()        print('second procedure')        pass    pass  #客户端if(__name__==\"__main__\"):    component=Component()        first=FirstProcedure(component)    second=SecondProcedure(first)        second.make()  ","title":"[置顶] 设计模式四（装饰模式,采用python 实现）"},{"content":"概念：创建型模式本质上都是对对象的创建过程进行封装。 单例模式(Singleton)：一个类只有一个实例，而且提供一个全局访问点。 原型模式(Prototype)：创建一个拷贝的对象。 工厂方法模式(FactoryMethod)：定义一个创建对象的接口，子类决定创建的对象。 抽象工厂模式(AbstractFactory)：提供一个创建一系列对象的接口。 建造者模式(Builder)：把一个对象的构建和表示分离开来。 总结：       单例模式和原型模式没有什么太大的难度！工厂方法，抽象工厂和建造者的关联性比较大。把工厂方法抽象产生出抽象工厂。抽象工厂和建造者都是在一个整体上观看“部分”。前面说到建造型模式就是把对象的建造过程封装起来，但建造者模式要对外暴露“部分”的接口。","title":"创建型模式总结"},{"content":"      适配器模式（Adapter，包装，包装样式）：将一个类的接口转换成客户希望的另外一个接口。适配器还分为类适配器（适配器继承自已实现的类）和对象适配器（适配器容纳一个它包裹的类的实例,下面的例子）. 类图： 代码： publicclass Adaptee {     publicvoid sayHello(){        System.out.println(\"hello\");     } } publicinterface Target {     publicvoid Request(); } publicclass Adapter implements Target {     Adaptee adaptee=new Adaptee();     @Override     publicvoid Request() {        adaptee.sayHello();     } } publicstaticvoid main(String[] args) {        //创建适配器        Target adapter=new Adapter();        //调用统一接口        adapter.Request();     } } 优点：令到接口不一样的类可以在一起工作。 缺点：因为Adapter 是为了Adaptee而存在，所以 Adaptee和Adapter类的耦合度很高。       适配器模式适用于对已有类的扩展。在java.io包中用了很多adapter。","title":"适配器模式"},{"content":"      抽象工厂是为创建一组相关或依赖的对象提供接口，使得一组对象的维护，只需要维护相应的创建对象的工厂类。可以大大提高程序的可维护性。       在如下情况下，应当考虑使用抽象工厂模式：     一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的。 这个系统有多于一个的产品族，而系统只消费其中某一产品族。 同属于同一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来。 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。 抽象工厂遵循 “开放--封闭” 原则 \"开放－封闭\"原则要求系统对扩展开放，对修改封闭。通过扩展达到增强其功能的目的。对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面： 增加产品族：Abstract Factory很好的支持了\"开放－封闭\"原则。 增加新产品的等级结构：需要修改所有的工厂角色，没有很好支持\"开放－封闭\"原则。 综合起来，抽象工厂模式以一种倾斜的方式支持增加新的产品，它为新产品族的增加提供方便，而不能为新的产品等级结构的增加提供这样的方便。 c++ 实现的抽象工厂的一个简单实例 下载示例代码(vc6 下编译通过) AbstractFactorySample.rar //---------header file #include <iostream> using namespace std; class BaseProductA { protected:  BaseProductA(){}; }; class BaseProductB { protected:  BaseProductB(){}; }; class ProductA1:public BaseProductA { public:  ProductA1(){cout<<\"product A1 is created..\"<<endl;}; }; class ProductA2:public BaseProductA { public:  ProductA2(){cout<<\"product A2 is created..\"<<endl;}; }; class ProductB1:public BaseProductB { public:  ProductB1(){cout<<\"product B1 is created..\"<<endl;}; }; class ProductB2:public BaseProductB { public:  ProductB2(){cout<<\"product B2 is created..\"<<endl;}; }; class IFactory   { protected:  IFactory();  virtual ~IFactory()=0; public:  virtual BaseProductA* CreateProductA()=0;  virtual BaseProductB* CreateProductB()=0; }; class ConcreteFactory1:public IFactory { public:  ConcreteFactory1(){cout<<\"ConcreteFactory1 is created..\"<<endl;}; public:  virtual BaseProductA* CreateProductA();  virtual BaseProductB* CreateProductB(); }; class ConcreteFactory2:public IFactory { public:  ConcreteFactory2(){cout<<\"ConcreteFactory2 is created..\"<<endl;}; public:  virtual BaseProductA* CreateProductA();  virtual BaseProductB* CreateProductB(); }; //-----------------------header file end------------------------------------ // -----------------------cpp file-------------------------------- IFactory::IFactory() {} IFactory::~IFactory() {} BaseProductA* ConcreteFactory1::CreateProductA() {  return new ProductA1(); } BaseProductB* ConcreteFactory1::CreateProductB() {  return new ProductB1(); } BaseProductA* ConcreteFactory2::CreateProductA() {  return new ProductA2(); } BaseProductB* ConcreteFactory2::CreateProductB() {  return new ProductB2(); } int main(int argc, char* argv[]) {  IFactory* pFactory1=new ConcreteFactory1();  pFactory1->CreateProductA();  pFactory1->CreateProductB();  IFactory* pFactory2=new ConcreteFactory1();  pFactory2->CreateProductA();  pFactory2->CreateProductB();  getchar();  return 0; } //-----------------------cpp file end-------------------------- 原文地址： http://www.gddhx.com/post/7.html ","title":"设计模式之 工厂模式 及 c++ 实现"},{"content":"     观察者模式是最常用的设计模式之一，在此模式中，一个目标对象管理依赖它的观察对象，并在自身状态发生改变的时候主动通知所有注册的观察者对象。观察者模式常被用作设计事件处理系统。      例如下面的示例代码是常见的观察者模式的示例，在此用c++进行实现。猫作为目标物件 管理两个观察者，一个是主人，一个是老鼠。当猫叫这个事件发生时能够调用观察者相应的响应函数，从而做出相应的反应。     通过观察者模式可以优化程序的业务逻辑，实现松耦合、易维护。 下载示例代码(VC6下编译通过):  ObserverSample.rar //-------------代码示例------------- #include <list> #include <iostream> using namespace std; class CObserver; class CSubject { protected:  CSubject(){m_obsList=new list<CObserver*>;}; private:  list<CObserver*>* m_obsList; public:  virtual attach(CObserver* pObs);  virtual detach(CObserver* pObs);  virtual notify();  virtual action()=0; }; class CCat:public CSubject { public:  void Cry();  virtual action(){Cry();}; }; class CObserver   { protected:  CObserver();  virtual ~CObserver(); public:  virtual void Response()=0; }; class CMaster:public CObserver { public:  CMaster(CSubject* pSubject);  virtual void Response(); protected:  CSubject* m_pSubject; }; class CMouse:public CObserver { public:  CMouse(CSubject* pSubject);  virtual void Response(); protected:  CSubject* m_pSubject; }; //  实现 CObserver::CObserver() { } CObserver::~CObserver() { } void CMaster::Response() {  cout<<\"the master wakeup\"<<endl; } CMaster::CMaster( CSubject* pSubject ) {  cout<<\"master is created...\"<<endl;  m_pSubject=pSubject;  pSubject->attach(this); } void CMouse::Response() {  cout<<\"the mouse run away...\"<<endl; } CMouse::CMouse( CSubject* pSubject ) {  cout<<\"master is created...\"<<endl;  m_pSubject=pSubject;  pSubject->attach(this); } CSubject::attach( CObserver* pObs ) {  m_obsList->push_front(pObs); } CSubject::detach( CObserver* pObs ) {  if (pObs)  {   m_obsList->remove(pObs);  } } CSubject::notify() {  list<CObserver*>::iterator it;  it=m_obsList->begin();  for (;it!=m_obsList->end();it++)  {   (*it)->Response();  } } void CCat::Cry() {  cout<<\"the cat cry...\"<<endl;  this->notify(); } 原文地址： http://www.gddhx.com/post/8.html","title":"设计模式之观察者模式 及 c++ 实现"},{"content":"Observer Pattern 观察模式： 关于观察者模式，该书讲的例子是气象观测应用程序，当气象观测站得到新的气象数据时就将数据发送给应用程序，应用程序的模块就会得到相应的数据，这其实也是观察者模式的模型。观察者模式定义了一个一对多的应用模式，一是主题（Subject），也就是气象观测站，多是观察者（Observer），也就是应用程序模块（如：应用程序中有好几个功能，当前天气的展示、最近一周天气的趋势、未来几天的天气预报）；当subject数据发生变化时，observer会接收到subject发出的通知。书中还提到一个有助于理解的例子，我们每个人（观察者）都订了报社（被观察者）的杂志，只要报刊有新报纸出版，就会给你送来，只要你是他们的订户，你就会一直受到新报纸。 也就是：出版者+订阅者=观察者模式 这一章就描述了一个设计原则：为了交互对象之间的松藕合设计而努力。我觉得这也是我们用面向对象的设计语言设计程序是所要努力的方向。 下面实现书中的气象观测应用程序： 抽象主题角色： public interface Subject{\tpublic void registerObserver(Observer o);\tpublic void removeObserver(Observer o);\tpublic void notifyObserver();} 抽象观察者角色： public interface Observer{\tpublic void updata(float temp,float humidity,float pressure);//当主题发生变化时，会将这三者的变化值告诉观察者\tpublic void display();//输出} 具体主题角色，继承自subject接口 public WeatherData implements Subject{ \tprivate ArrayList<Observer> observers; \tprivate float temperature; \tprivate float humidity; \tprivate float pressure; \tpublic WeatherData(){ \t\tobservers=new ArrayList<Observer>(); \t} \tpublic void registerObserver(Observer o){ \t\tobservers.add(o); \t} \tpublic void removeObserver(Observer o){ \t\tint i=observers.indexOf(o); \t\tif(i>=0){ \t\t\tobservers.remove(i); \t\t} \t} \tprivate void notifyObserver(){ \t\tfor(int i=0;i<observers.size();i++){ \t\t\tObserver observer=observers.get(i); \t\t\tobserver.updata(temperature,humidity,pressure); \t\t} \t} \tprivate void measurementsChanged(){//当消息有更新时就发送数据给所有观察者 \t\tnotifyObserver(); \t} \t//获得气象数据的来源 \tpublic void setMeasurements(float temperature,float humidity,float pressure){ \t\tthis.temperature=temperature; \t\tthis.humidity=humidity; \t\tthis.pressure=pressure; \t\tmeasurementsChanged(); \t} } 具体观察者角色，继承自Observer接口，该类实现了当前天气展示模块，还有其他两个模块与此相似 public class CurrentconditionsDisplay implements Observer{ \tprivate Subject weatherData; \tprivate float temperature; \tprivate float humidity; \tprivate float pressure; \tpublic CurrentconditionsDisplay(Subject weatherData){ \t\tthis.weatherData=weatherData; \t\tweatherData.registerObserver(this); \t} \tpublic void updata(float temperature,float humidity,float pressure){ \t\tthis.temperature=temperature; \t\tthis.humidity=humidity; \t\tthis.pressure=pressure; \t\tdisplay(); \t} \tprivate void display(){ \t\tSystem.out.println(\"Temperature:\"+temperature+\"Humidity:\"+humidity+\"Pressure:\"+pressure); \t} } 客户端类，主应用程序： public class WeatherStation{\tpublic static void main(String[] args){\t\tWeatherData weather=new WeatherData();\t\tCurrentconditionsDisplay currentconditionsDisplay=new CurrentconditionsDisplay(weatherData);\t\tweather.setMeasurements(23.2,65,30.4f);\t\tweather.setMeasurements(24.3,70,43.1f);\t}} 关于观察者的一切，主题只知道观察者实现了Observer接口，主题不知道观察者具体类是谁，做了些什么或其他任何细节。我们可以在任何时候添加或者删除一个观察者。 其实JavaAAPI有内置的观察者模式。java.util包（package）内包含最基本的Observer接口与Observable类，这和我们的Subject接口与Observer接口很相似。有空该看看启源代码的实现了。而且在javabeans和swing中也实现了观察者模式。swing的观察者模式就是消息监听机制。无论在java中还是在android中都是这种模式，在android中，当你单间一个按钮时就会触发OnClickListener，此时button就是被观察者，而OnClickListener就是观察者。","title":"《Head First设计模式》读书笔记之观察者模式"},{"content":"基本理论请直接找书看，这里直接给例子，欢迎大家学习、讨论、或指点改进   在保证上文代码不变的基础上，增加GUI外衣 针对工厂公司增加了用户服务部，用户服务部内部分为铣刀客服组MillForm和钻头客服组DrillForm以及策略服务中心StrategyToolForm #文件名：toolform.py# -*- coding: utf-8 -*-from __future__ import divisionfrom __future__ import print_functionfrom __future__ import unicode_literalsfrom future_builtins import *from tool import *#from PyQt4.QtGui import *#from PyQt4.QtCore import *import sysfrom PySide.QtCore import *from PySide.QtGui import *import stringimport gcQTextCodec.setCodecForTr(QTextCodec.codecForName(\"utf8\"))class ToolForm(QWidget):        def __init__(self, parent=None):        super(ToolForm, self).__init__(parent)        self.setAttribute(Qt.WA_DeleteOnClose)        self.name=None        self.diameter=0        self.parent=parent        self.main_layout=QGridLayout(self.parent)         name_label=QLabel((\"名称:\"))        self.name_value=QLineEdit()        self.main_layout.addWidget(name_label,0,0)         self.main_layout.addWidget(self.name_value,0,1)            diameter_label=QLabel((\"直径:\"))        self.diameter_value=QLineEdit()        self.main_layout.addWidget(diameter_label,1,0)         self.main_layout.addWidget(self.diameter_value,1,1)      def make(self):        self.name=self.name_value.text()        print(self.diameter_value.text())        self.diameter=string.atof(self.diameter_value.text())                         class MillForm(ToolForm):        def __init__(self, parent=None):        super(MillForm, self).__init__(parent)        self.setAttribute(Qt.WA_DeleteOnClose)        self.setWindowTitle('铣刀')    def make(self):        super(MillForm,self).make()        tool=MillTool(self.name,self.diameter)        str=tool.make()        return str  class DrillForm(ToolForm):        def __init__(self, parent=None):        super(DrillForm, self).__init__(parent)        self.setWindowTitle('钻头')         self.setAttribute(Qt.WA_DeleteOnClose)               self.drill=0        drill_label=QLabel((\"锥度:\"))        self.drill_value=QLineEdit()        self.main_layout.addWidget(drill_label,2,0)         self.main_layout.addWidget(self.drill_value,2,1)      def make(self):        super(DrillForm,self).make()        self.drill=string.atof(self.drill_value.text())        tool=DrillTool(self.name,self.diameter,self.drill)        return tool.make()         #if (__name__== \"__main__\"):    #app = QApplication(sys.argv)        #widget=QWidget()    #form = MillForm(widget)      #widget.show()    #app.exec_()     class StrategyToolForm(object):    def __init__(self,tool_type,parent=None):        super(StrategyToolForm,self).__init__()        self.parent=parent        self.tool_type=tool_type        if self.tool_type=='mill':            self.tool=MillForm(parent)        elif self.tool_type=='drill':            self.tool=DrillForm(parent)         else:            print('error in strategy')    def make(self):        return self.tool.make()    if (__name__==\"__main__\"):    app = QApplication(sys.argv)        widget=QWidget()    strategy =StrategyToolForm('drill',widget)      widget.show()    app.exec_()        #客户端：#文件名：client.py# -*- coding: utf-8 -*-from __future__ import divisionfrom __future__ import print_functionfrom __future__ import unicode_literalsfrom future_builtins import *import sysfrom PySide.QtCore import *from PySide.QtGui import *from toolform import *import gcQTextCodec.setCodecForTr(QTextCodec.codecForName(\"utf8\"))class Form(QDialog):        def __init__(self, parent=None):        super(Form, self).__init__(parent)        self.setAttribute(Qt.WA_DeleteOnClose)        self.main_layout=QGridLayout(self)         self.tool=None        self.ls=list()         self.strategy=None        type_label=QLabel((\"请选择刀具类型\"))        self.main_layout.addWidget(type_label,0,0)                self.type_tool=QComboBox()                #str=QString(\"None,mill,drill\")        self.zjm=QPushButton()        self.type_tool.addItems(['None','mill','drill'])        self.main_layout.addWidget(self.type_tool,0,1)           self.widget=QWidget()        self.main_layout.addWidget(self.widget,1,0,1,2)                         self.information=QLabel()        self.main_layout.addWidget(self.information,2,0,1,2)        self.makeButton=QPushButton(\"制造\")        self.main_layout.addWidget(self.makeButton,2,3)        self.type_tool.currentIndexChanged.connect(self.choose)        #self.connect(type_tool,SIGNAL(\"currentIndexChanged(QString) \"),self.choose)        self.makeButton.clicked.connect(self.make)              self.lsout=list()        self.lsout.append(self.main_layout)                #while 1:            #self.type_tool.setCurrentIndex(1)            #self.type_tool.setCurrentIndex(2)                          @Slot()    def make(self):        if self.strategy!=None:            str=self.strategy.make()            self.information.setText(self.information.text()+\"\\n\\r\"+str)            @Slot(str)    def choose(self, str):        text=self.type_tool.currentText()        print(text)                if text!='None':            self.main_layout.removeWidget(self.widget)            self.widget.hide()            del self.widget                self.widget=QWidget()                                self.strategy =StrategyToolForm(text,self.widget)                        self.main_layout.addWidget(self.widget,1,0,1,2)        else:            self.strategy=None            pass                      gc.collect()if (__name__== \"__main__\"):     #gc.set_threshold(5,5,5)      app = QApplication(sys.argv)    form = Form()    form.setWindowTitle('刀具生产')    form.show()    app.exec_()      ","title":"[置顶] 设计模式三（采用pyside为设计模式一、二增加GUI外衣 ）"},{"content":"基本理论请直接找书看，这里直接给例子，欢迎大家学习、讨论、或指点改进 刀具、铣刀、钻头类代码和关系同设计模式一相同   在简单工厂的基础上进一步封装（客户端由认识两个类，封装成只认识策略类就可以了） 增加策略类 #文件名 tool.pyclass StrategyAddFactory(object):        def __init__(self,tool_type,name=None,diameter=10,drill=2):        self.tool=Tool()        self.tool_type=tool_type        if tool_type=='mill':            self.tool=MillTool(name,diameter)        elif tool_type=='drill':            self.tool=DrillTool(name,diameter,drill)        else:            print('tool type error')            def make(self):        self.tool.make()#客户端：if (__name__ == \"__main__\"):        strategy=StrategyAddFactory('drill','sunny',10,3)     strategy.make()  ","title":"[置顶] 设计模式二（策略模式,采用python实现）"},{"content":"基本理论请直接找书看，这里直接给例子，欢迎大家学习、讨论、或指点改进   刀具是祖先类，铣刀和钻头继承了刀具 #文件名 tool.py# -*- coding: utf-8 -*-from __future__ import divisionfrom __future__ import print_functionfrom __future__ import unicode_literalsfrom future_builtins import *import sysclass Tool(object):    '''刀具的祖先类 '''    def __init__(self,name=None,diameter=0):        self.name=name        self.diameter=diameter    def make(self):        result='made nothing'        print (result)        return result                class MillTool(Tool):    def __init__(self, name=None,diameter=0):        super(MillTool,self).__init__(name,diameter)    def make(self):        result=self.name+ ' diameter=%d' %self.diameter  + ' have been made'        print (result)        return result       class DrillTool(Tool):        def __init__(self, name=None,diameter=0,drill=0):        self.drill=drill        super(DrillTool,self).__init__(name,diameter)            def make(self):        result=self.name+ ' diameter=%d' %self.diameter + ' drill=%d' %self.drill + ' have been made'        print (result)        return result#为了生产刀具，建立一个简单工厂class SimpleToolFactory(object):    def creat(self,tool_type,name=None,diameter=10,drill=2):        tool=Tool()        if tool_type=='mill':            tool=MillTool(name,diameter)        elif tool_type=='drill':            tool=DrillTool(name,diameter,drill)        else:            print('tool type error')        return  tool#客户端为if (__name__ == \"__main__\"):        tool=Tool()         tool_factory=SimpleToolFactory()        tool=tool_factory.creat(\"mill\",\"zjm\",10)            tool.make()   ","title":"[置顶] 设计模式一（简单工厂，采用python实现）"},{"content":"    创建型模式                1、FACTORY—追MM少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是MM爱吃的东西，虽然口味有所不同，但不管你带MM去麦当劳或肯德基，只管向服务员说“来四个鸡翅”就行了。麦当劳和肯德基就是生产鸡翅的Factory                 工厂模式：客户类和工厂类分开。消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。                 2、BUILDER—MM最爱听的就是“我爱你”这句话了，见到不同地方的MM,要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到MM我只要按对应的键，它就能够用相应的语言说出“我爱你”这句话了，国外的MM也可以轻松搞掂，这就是我的“我爱你”builder。（这一定比美军在伊拉克用的翻译机好卖）                 建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。                 3、FACTORY METHOD—请MM去麦当劳吃汉堡，不同的MM有不同的口味，要每个都记住是一件烦人的事情，我一般采用Factory Method模式，带着MM到服务员那儿，说“要一个汉堡”，具体要什么样的汉堡呢，让MM直接跟服务员说就行了。                 工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。                 4、PROTOTYPE—跟MM用QQ聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要copy出来放到QQ里面就行了，这就是我的情话prototype了。（100块钱一份，你要不要）                 原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。                 5、SINGLETON—俺有6个漂亮的老婆，她们的老公都是我，我就是我们家里的老公Sigleton，她们只要说道“老公”，都是指的同一个人，那就是我(刚才做了个梦啦，哪有这么好的事)                 单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的“单一实例”的需求时才可使用。             结构型模式                 6、ADAPTER—在朋友聚会上碰到了一个美女Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友kent了，他作为我和Sarah之间的Adapter，让我和Sarah可以相互交谈了(也不知道他会不会耍我)                 适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。                 7、BRIDGE—早上碰到MM，要说早上好，晚上碰到MM，要说晚上好；碰到MM穿了件新衣服，要说你的衣服好漂亮哦，碰到MM新做的发型，要说你的头发好漂亮哦。不要问我“早上碰到MM新做了个发型怎么说”这种问题，自己用BRIDGE组合一下不就行了                 桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以独立的变化。                 8、COMPOSITE—Mary今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件T恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM都会用Composite模式了，你会了没有？                 合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。                 9、DECORATOR—Mary过完轮到Sarly过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上“最好的的礼物，就是爱你的Fita”，再到街上礼品店买了个像框（卖礼品的MM也很漂亮哦），再找隔壁搞美术设计的Mike设计了一个漂亮的盒子装起来……，我们都是Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？                 装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。                 10、FACADE—我有一个专业的Nikon相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但MM可不懂这些，教了半天也不会。幸好相机有Facade设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样MM也可以用这个相机给我拍张照片了。                 门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。                 11、FLYWEIGHT—每天跟MM发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上MM的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是Flyweight，MM的名字就是提取出来的外部特征，根据上下文情况使用。                 享元模式：FLYWEIGHT在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。                 12、PROXY—跟MM在网上聊天，一开头总是“hi,你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？”这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自动的回答，接收到其他的话时再通知我回答，怎么样，酷吧。                 代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。              行为型模式                 13、CHAIN OF RESPONSIBLEITY—晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上“Hi,可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条传给老师了，听说是个老处女呀，快跑!                 责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接                 起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。                 14、COMMAND—俺有一个MM家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送COMMAND，就数你最小气，才请我吃面。”，:-(                 命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。                 15、INTERPRETER—俺有一个《泡MM真经》，上面有各种泡MM的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟MM约会时，只要做一个Interpreter，照着上面的脚本执行就可以了。                 解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。                                 16、ITERATOR—我爱上了Mary，不顾一切的向她求婚。                 Mary：“想要我跟你结婚，得答应我的条件”                 我：“什么条件我都答应，你说吧”                 Mary：“我看上了那个一克拉的钻石”                 我：“我买，我买，还有吗？”                 Mary：“我看上了湖边的那栋别墅”                 我：“我买，我买，还有吗？”                 Mary：“你的小弟弟必须要有50cm长”                 我脑袋嗡的一声，坐在椅子上，一咬牙：“我剪，我剪，还有吗？”                 ……                 迭代子模式：迭代子模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代子模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。                 17、MEDIATOR—四个MM打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就OK啦，俺得到了四个MM的电话。                 调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。                 18、MEMENTO—同时跟几个MM聊天时，一定要记清楚刚才跟MM说了些什么话，不然MM发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个MM说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。                 备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。                 19、OBSERVER—想知道咱们公司最新MM情报吗？加入公司的MM情报邮件组就行了，tom负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦                 观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。                 20、STATE—跟MM交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的MM就会说“有事情啦”，对你不讨厌但还没喜欢上的MM就会说“好啊，不过可以带上我同事么？”，已经喜欢上你的MM就会说“几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把MM的状态从不讨厌不喜欢变成喜欢哦。                 状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。                 21、STRATEGY—跟不同类型的MM约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到MM的芳心，我的追MM锦囊中有好多Strategy哦。                 策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模式把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。                 22、TEMPLATE METHOD——看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤(Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦(具体实现)；                 模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。                 23、VISITOR—情人节到了，要给每个MM送一束鲜花和一张卡片，可是每个MM送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下Visitor，让花店老板根据MM的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；                 访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。","title":"Java常用的设计模式"},{"content":"简单工厂         简单工厂不是一个标准的设计模式，但是它实在是太常用了，简单而又神奇，所以还是需要好好掌握的，就当是对学习设计模式的热身运动吧。         为了保持一致性，我们尽量按照学习其它模式的步骤来进行学习。 1  场景问题         大家都知道，在Java应用开发中，要“面向接口编程”。         那么什么是接口？接口有什么作用？接口如何使用？一起来回顾一下： 1.1  接口回顾 （1）Java中接口的概念         在Java中接口是一种特殊的抽象类，跟一般的抽象类相比，接口里面的所有方法都是抽象方法，接口里面的所有属性都是常量。也就是说，接口里面是只有方法定义而不会有任何方法实现。 （2）接口用来干什么         通常用接口来定义实现类的外观，也就是实现类的行为定义，用来约束实现类的行为。接口就相当于一份契约，根据外部应用需要的功能，约定了实现类应该要实现的功能，但是具体的实现类除了实现接口约定的功能外，还可以根据需要实现一些其它的功能，这是允许的，也就是说实现类的功能包含但不仅限于接口约束的功能。         通过使用接口，可以实现不相关类的相同行为，而不需考虑这些类之间的层次关系，接口就是实现类对外的外观。 （3）接口的思想         根据接口的作用和用途，浓缩下来，接口的思想就是“封装隔离”。         通常提到封装是指对数据的封装，但是这里的封装是指“对被隔离体的行为的封装”，或者是“对被隔离体的职责的封装”；而隔离指的是外部调用和内部实现，外部调用只能通过接口进行调用，而外部调用是不知道内部具体实现的，也就是说外部调用和内部实现是被接口隔离开的。 （4）使用接口的好处         由于外部调用和内部实现被接口隔离开了，那么只要接口不变，内部实现的变化就不会影响到外部应用，从而使得系统更灵活，具有更好的扩展性和可维护性，这也就是所谓“接口是系统可插拔性的保证”这句话的意思。 （5）接口和抽象类的选择         既然接口是一种特殊的抽象类，那么在开发中，何时选用接口，何时选用抽象类呢？         对于它们的选择，在开发中是一个很重要的问题，特别总结两句话给大家： 优先选用接口 在如下情况应选择抽象类：既要定义子类的行为，又要为子类提供公共的功能 1.2  面向接口编程         面向接口编程是Java编程中的一个重要原则。         在Java 程序设计里面，非常讲究层的划分和模块的划分。通常按照三层来划分Java程序，分别是表现层、逻辑层、数据层，它们之间都要通过接口来通讯。         在每一个层里面，又有很多个小模块，一个小模块对外也应该是一个整体，那么一个模块对外也应该提供接口，其它地方需要使用到这个模块的功能，都应该通过此接口来进行调用。这也就是常说的“接口是被其隔离部分的外观”。基本的三层结构如图1所示：  图1  基本的三层结构示意图 在一个层内部的各个模块交互也要通过接口，如图2所示： 图2  一个层内部的各个模块交互示意图         各个部分的接口具体应该如何去定义，具体的内容是什么，不去深究，那是需要具体问题具体分析的，这里只是来学习设计的方法。         上面频频提到“组件”，那么什么是组件呢？先简单的名词解释一下：         所谓组件：从设计上讲，组件就是能完成一定功能的封装体。小到一个类，大到一个系统，都可以称为组件，因为一个小系统放到更大的系统里面去，也就当个组件而已。事实上，从设计的角度看，系统、子系统、模块、组件等说的其实是同一回事情，都是完成一定功能的封装体，只不过功能多少不同而已。         继续刚才的思路，大家会发现，不管是一层还是一个模块或者一个组件，都是一个被接口隔离的整体，那么下面我们就不去区分它们，统一认为都是接口隔离体即可，如图3所示： 图3  接口隔离体示意图 既然在Java中需要面向接口编程，那么在程序中到底如何使用接口，来做到真正的面向接口编程呢？ 1.3  不用模式的解决方案         回忆一下，以前是如何使用接口的呢，假设有一个接口叫Api，然后有一个实现类Impl实现了它，在客户端怎么用这个接口呢？         通常都是在客户端创建一个Impl的实例，把它赋值给一个Api接口类型的变量，然后客户端就可以通过这个变量来操作接口的功能了，此时具体的结构图如图4：    图4  基本的接口和实现 还是用代码来说明，会更清楚一些。 （1）先定义接口Api，示例代码如下： 查看复制到剪贴板打印 /**  * 某个接口(通用的、抽象的、非具体的功能)   */   public interface Api {       /**       * 某个具体的功能方法的定义，用test1来演示一下。       * 这里的功能很简单，把传入的s打印输出即可        * @param s 任意想要打印输出的字符串       */       public void test1(String s);   }   （2）既然有了接口，自然就要有实现，定义实现Impl，示例代码如下： 查看复制到剪贴板打印 /**  * 对接口的实现   */   public class Impl implements Api{       public void test1(String s) {           System.out.println(\"Now In Impl. The input s==\"+s);       }   }     （3）那么此时的客户端怎么写呢？ 按照Java的知识，接口不能直接使用，需要使用接口的实现类，示例代码如下： 查看复制到剪贴板打印 /**  * 客户端：测试使用Api接口  */   public class Client {       public static void main(String[] args) {           Api api = new Impl();           api.test1(\"哈哈，不要紧张，只是个测试而已！\");       }   }       1.4  有何问题         上面写得没错吧，在Java的基础知识里面就是这么学的，难道这有什么问题吗？         请仔细看位于客户端的下面这句话： 查看复制到剪贴板打印 Api api = new Impl();           然后再想想接口的功能和思想，发现什么了？仔细再想想？           你会发现在客户端调用的时候，客户端不但知道了接口，同时还知道了具体的实现就是Impl。而接口的思想是“封装隔离”，而Impl这个实现类，应该是被接口Api封装并同客户端隔离开的，也就是说，客户端根本就不应该知道具体的实现类是Impl。         有朋友说，那好，我就把Impl从客户端拿掉，让Api真正的对实现进行“封装隔离”，然后我们还是面向接口来编程。可是，新的问题出现了，当他把“new Impl()”去掉过后，发现他无法得到Api接口对象了，怎么办呢？         把这个问题描述一下：在Java编程中，出现只知接口而不知实现，该怎么办？         就像现在的Client，它知道要使用Api接口，但是不知由谁实现，也不知道如何实现，从而得不到接口对象，就无法使用接口，该怎么办呢？","title":"23种模式之简单工厂模式"},{"content":"装饰模式（Decorator）：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活 类图： 代码： publicabstractclass Componet {     publicabstractvoid Operation(); } publicclass ConcreteComponet extends Componet {     @Override     publicvoid Operation(){        System.out.println(\"特定操作\");     } } publicabstractclass Decorator extends Componet {     protected Componet componet;     publicvoid setComponet(Componet componet){        this.componet=componet;     } } publicclass ConcreteDecoratorA extends Decorator {     @Override     publicvoid Operation() {        if(componet!=null){            System.out.println(\"记录日记_A\");            componet.Operation();        }     } } publicclass ConcreteDecoratorB extends Decorator{     @Override     publicvoid Operation() {        if(componet!=null){            System.out.println(\"读取记录_B\");            componet.Operation();        }     } } publicstaticvoid main(String[] args) {        //创建装饰者和被被装饰者        Componet base=new ConcreteComponet();        Decorator d1=new ConcreteDecoratorA();        Decorator d2=new ConcreteDecoratorB();        //随意添加装饰        d1.setComponet(base);        d2.setComponet(d1);             d2.Operation();               d2.setComponet(base);        d1.setComponet(d2);        d1.Operation();                   } 优点：可以随意更换装饰，扩展性很强。 缺点：必须对外暴露装饰者实现类；装饰职责链过长。       装饰模式用于对于已有功能的扩展比较适合。装饰模式和适配器模式一样，都用于java.io包。如果没有用到装饰模式就不要编写多余的代码，因为装饰模式可以再有需要的时候再添加上去。   装饰 适配器 适用背景 在已有功能的基础上扩展功能 在已有功能的基础上统一接口 使用的接口 使用原来接口 使用新的接口 增加功能 增加功能 可以修改功能      ","title":"装饰模式"},{"content":"命令模式（Command）模式，将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。 使用场景：       1、当一个应用程序调用者与多个目标对象之间存在调用关系时，并且目标对象之间的操作很类似的时候。       2、例如当一个目标对象内部的方法调用太复杂，或者内部的方法需要协作才能完成对象的某个特点操作时。       3、有时候调用者调用目标对象后，需要回调一些方法。 c++ 实现代码 #include <stdio.h> class CCommand   { public: CCommand(); virtual ~CCommand(); virtual void Execute()=0; }; class CReceiver { public: void Action(){printf(\"receiver action() \\n\");}; protected: private: }; class CConcreteCommand:public CCommand { public: CConcreteCommand(CReceiver* pReceiver){m_pReceiver=pReceiver;}; virtual void Execute(){m_pReceiver->Action();}; protected: private: CReceiver* m_pReceiver; };   class CInvoker { public: CInvoker(CCommand* pCommand){m_pCommand=pCommand;}; void Invoke(){m_pCommand->Execute();}; protected: private: CCommand* m_pCommand; };   #include \"Command.h\" int main(int argc, char* argv[]) { CInvoker* pInvoker=new CInvoker(new CConcreteCommand(new CReceiver)); pInvoker->Invoke(); getchar(); return 0; } 实例  某公司(Client) 告诉生产部（Invoker） 生产一台 惠普电脑 和 一台 戴尔电脑 ，生产部将订单发往工厂（Receiver）去生产。 类图如下：   c++ 代码实现如下:     #define MAX_CMD_COUNT 256 #include <stdio.h> class CCommand   { public: CCommand(); virtual ~CCommand(); virtual void Execute()=0; }; class ComputerFactory { public: void CreateHP(){printf(\"create hp \\n\");}; void CreateDell(){printf(\"create dell \\n\");}; protected: private: }; class CCreateHpCommand:public CCommand { public: CCreateHpCommand(ComputerFactory* pFactory){m_pFactory=pFactory;}; virtual void Execute(){m_pFactory->CreateHP();}; protected: private: ComputerFactory* m_pFactory; }; class CCreateDellCommand:public CCommand { public: CCreateDellCommand(ComputerFactory* pFactory){m_pFactory=pFactory;}; virtual void Execute(){m_pFactory->CreateDell();}; protected: private: ComputerFactory* m_pFactory; }; class CProductDepartment { public: CProductDepartment() { for (int i=0;i<MAX_CMD_COUNT;i++) { m_cmd[i]=NULL; } } void Invoke() { for (int i=0;i<MAX_CMD_COUNT;i++) { if (m_cmd[i]) { m_cmd[i]->Execute(); delete m_cmd[i]; m_cmd[i]=NULL; } } } void AddCmd(CCommand* pCmd) { for (int i=0;i<MAX_CMD_COUNT;i++) { if (!m_cmd[i]) { m_cmd[i]=pCmd; break; } } } protected: private: CCommand* m_pCmd; CCommand* m_cmd[256]; }; #include \"Command.h\" int main(int argc, char* argv[]) { ComputerFactory* pFactory=new ComputerFactory(); CCommand* pHpCommand=new CCreateHpCommand(pFactory); CCommand* pDellCommand=new CCreateDellCommand(pFactory); CProductDepartment* pDepartment=new CProductDepartment(); pDepartment->AddCmd(pHpCommand); pDepartment->AddCmd(pDellCommand); pDepartment->Invoke(); getchar(); return 0; } 独立博客地址 ： http://www.gddhx.com/post/36.html","title":"设计模式之命令模式 及 c++ 实现"},{"content":" 创建者设计模式属于 创建型设计模式的一种。 创建者设计模式主要用于复杂对象的创建，这些对象的创建步骤和组合方式基本固定，但是可能具体的对象的组成部分却又可以自由的变化。创建者设计模式通过封装来隔离组成复杂对象的各个组成部分的变化。从而可以应对各种各样的需求。   创建者模式的类图如下： 举例来说： KFC的套餐 为 Product 角色  顾客为Client  收银员为 Director 角色  套餐内的食品制作员工为 Builder角色 Director 包含 Construct 方法用于构建最终产品。而这个产品就是我们要构建的复杂的对象。   用c++ 来实现的代码如下：   #include \"stdafx.h\" #include <stdio.h> class Product {   }; class Builder { public: virtual void BuildPartA()=0; virtual void BuildPartB()=0; protected: private: }; class ConcreteBuilder:public Builder { public: void BuildPartA(){printf(\"builder part a:\\n\");}; void BuildPartB(){printf(\"builder part b:\\n\");}; private: Product m_product; }; class Director { public: Director(Builder* builder){m_bBuilder=builder;}; void Construct(){m_bBuilder->BuildPartA();m_bBuilder->BuildPartB();}; protected: private: Builder* m_bBuilder;   }; int main(int argc, char* argv[]) { Director director(new ConcreteBuilder); director.Construct(); getchar(); return 0; } 独立博客地址： http://www.gddhx.com/post/23.html  ","title":"设计模式之创建者模式 c++ 实现"},{"content":"这个星期很闲，找了一本电子书head-first设计模式看，放假闲来无事整理一下内容，书很有意思，电子书在我上传的资源中可以下载。 策略模式：定义了算法假装，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。 需求：在一个模拟鸭子的游戏中，有各种各样的鸭子 最开始设计： /** *鸭子的抽象类，定义了鸭子的一般行为 ，可以游泳，可以呱呱的叫，但是鸭子长得不一样 *因此留到具体的子类中实现 * @author Administrator */public abstract class Duck {\tpublic void quack(){\t\tSystem.out.println(\"i can quack!\");\t}\t\tpublic void swim(){\t\tSystem.out.println(\"i can swim!\");\t}\t\tpublic abstract void display();}/** * 红色的鸭子 * @author Administrator */public class RedDuck extends Duck {\t@Override\tpublic void display() {\t\tSystem.out.println(\"i am redDuck\");\t}}/** * 蓝色的鸭子 * @author Administrator */public class BlueDuck extends Duck {\t@Override\tpublic void display() {\t\tSystem.out.println(\"i am blueDuck!\");\t}} 但是此时需要添加一种玩具鸭子，鸭子不能呱呱的叫，而只能学小鸡咯咯的叫，那么怎么办呢？ 或许我们可以重写quack()方法，改变其行为 public class RubberDuck extends Duck {\t@Override\tpublic void quack(){\t\tSystem.out.println(\"i can quack!咯咯咯\");\t}\t@Override\tpublic void display() {\t\tSystem.out.println(\"i am rubberDuck\");\t}}如果有这么一系列的鸭子都只能咯咯咯的叫唤的话，那么就需要在每个类中重写该方法，造成了代码的重复。 设计原则：找出应用中可能会变化的地方，把他们独立出来，和那些不会变化的代码区别开来。也就是把会变化的部分提取出来单独封装，以便以后可以轻易的改动或扩展而不影响不需要变化的部分。 在本例中会变化的部分是鸭子的鸣叫方式，因此我们把该代码提取出来： /** *鸣叫方式  * @author Administrator */public interface QuackBehavior {\tvoid quack();}/** * 咯咯的鸣叫 * @author Administrator */public class QuackAsGeGe implements QuackBehavior{\t@Override\tpublic void quack() {\t\tSystem.out.println(\"i can quack!咯咯咯\");\t}}/** * 呱呱呱的鸣叫方式 * @author Administrator */public class QuackAsGuaGua implements QuackBehavior {\t@Override\tpublic void quack() {\t\tSystem.out.println(\"i can quack! 呱呱呱\");\t}} 鸭子将叫唤的行为委托给其他的类进行处理 /** *鸭子的抽象类，定义了鸭子的一般行为 ，可以游泳，可以叫唤，但是鸭子长得不一样 *因此留到具体的子类中实现 * @author Administrator */public abstract class Duck {\tprivate QuackBehavior quackBehavior;\tpublic void quack(){\t\tquackBehavior.quack();\t}\t\tpublic void swim(){\t\tSystem.out.println(\"i can swim!\");\t}\t\tpublic abstract void display();\tpublic QuackBehavior getQuackBehavior() {\t\treturn quackBehavior;\t}\tpublic void setQuackBehavior(QuackBehavior quackBehavior) {\t\tthis.quackBehavior = quackBehavior;\t}}此时我们可以把鸭子的叫唤行为看做某种算法，我们可以扩展QuackBehaviour接口实现更多的算法，在运行过程中通过setQuackBehaviour()来设置使用的算法，在不改变类的情况下达到替换不同的算法的目的","title":"设计模式--策略模式"},{"content":"抽象工厂模式应用场景举例： 时光甜蜜的飞逝，GG和MM过着童话般的王子和公主的浪漫的生活。眼看MM生日就要到了，GG着急了。毕竟，这是自己的第一个女朋友的第一个生日啊。想了千万种方法，问了身边很多朋友，这个傻GG最终还是没有确定最终该如何去做~~~~(>_<)~~~~ 哎！爱，总是想到太多做的太少^_^ 都快夜里十二点了，GG还在Google和百度上面查询如何给自己的Sweatheart过生日。此时，突然手机短信铃声响了，打开一看，上面写道：“亲爱的，我知道这些天你一直在想我们如何一切过生日，其实，一切都很简单的。简单就好。”，看完短信，GG顿时全身暖流涌动，感觉好幸福^_^，有如此体贴理解人的MM，夫复何求( ⊙ o ⊙ )啊！刚要回复短信，手机铃声又响了，上面写道：“我们还去麦当劳吧，不过这次使我们俩，要换一个地方，到华联那边的麦当劳吧^_^”，GG读着短信，感动的无语了。短信回复道：“一切惟老婆大人之命是从:-O”。GG和MM都沉浸在甜蜜和幸福中^_^ 抽象工厂模式解释： 抽象工厂模式（Abstact Factory Pattern）是所有形态的工厂模式中最为抽象和最其一般性的。抽象工厂模式可以向客户端提供一个接口，使得客户端在不必指定产品的具体类型的情况下，能够创建多个产品族的产品对象。 抽象工厂中方法对应产品结构，具体工厂对应产品族 英文定义为：Provide an interface forcreating families of related or dependent objects without specifying theirconcrete classes. 抽象工厂模式的UML图： 抽象工厂模式模式中包含的角色及其相应的职责如下： 抽象工厂（Creator）角色：抽象工厂模式的核心，包含对多个产品结构的声明，任何工厂类都必须实现这个接口。 具体工厂（Concrete Creator）角色: 具体工厂类是抽象工厂的一个实现，负责实例化某个产品族中的产品对象。 抽象（Product）产品角色：抽象模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。 具体产品（Concrete Product）角色：抽象模式所创建的具体实例对象。 抽象工厂模式深入分析： 抽象工厂模式是在当产品有多个 抽象角色的时候使用的一种创建型设计模式。 按照里氏代换原则，凡是父类适用的地方，子类也必然适用。而在实际系统中，我们需要的是和父类类型相同的子类的实例对象，而不是父类本身，也就是这些抽象产品的具体子类的实例。具体工厂类就是来负责创建抽象产品的具体子类的实例的。 　　当每个抽象产品都有多于一个的具体子类的时候，工厂角色是如何确定实例化哪一个子类呢？例如说有两个抽象产品角色，而每个抽象产品角色都有两个具体产品。抽象工厂模式提供两个具体工厂角色，分别对应于这两个具体产品角色，每一个具体工厂角色只负责某一个产品角色的实例化。每一个具体工厂类只负责创建抽象产品的某一个具体子类的实例。 　　每一个模式都是针对一定问题的解决方案，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式针对的是多个产品等级结构。 何谓产品族？产品族是指位于不同产品等级结构中，功能相关联的产品组成的家族。一般是位于不同的等级结构中的相同位置上。显然，每一个产品族中含有产品的数目，与产品等级结构的数目是相等的，形成一个二维的坐标系，水平坐标是产品等级结构，纵坐标是产品族。 　　对于每一个产品族，都有一个具体工厂。而每一个具体工厂创建属于同一个产品族，但是分属于不同等级结构的产品。 　　通过引进抽象工厂模式，可以处理具有相同（或者相似）等级结构的多个产品族中的产品对象的创建问题。 由于每个具体工厂角色都需要负责不同等级结构的产品对象的创建，因此每个工厂角色都需要提供相应数目的工厂方法，分别用于创建相应数目的等级结构的产品。 如下图所示： 抽象工厂模式使用场景分析及代码实现： MM过生日的时候还是要到麦当劳，但是这次要求是到华联那边的麦当劳去，就是地方不同了，要换换口味和心情。这就是抽象工厂模式的一个很好的体现。首先对不同的麦当劳分店而言，每一种产品，例如说汉堡，都是汉堡，但是每个地方的汉堡在遵循统一标准的前提下又会尽力突出自己的特色，这样这样才能更好的吸引和留住顾客，因为不同的地方，随着环境等的不同，人们的喜好和口味等都会有所不同，但是无论怎么不同，始终还是汉堡，具有汉堡的基本功能。同时，每一个分店都有一系列的产品，例如汉堡、鸡翅等等，这就构成了产品的等级结构。 总之：麦当劳总部相当于抽象工厂，每个分店相当于具体工厂，而每种产品又有所不同。这样在既保持了统一性的前提下，又使得各分店的特色有所不同，适合于吸引和留住不同环境下的客户。 UML模型图如下所示： 具体实现代码如下： 新建立一个食物的接口： package com.diermeng.designPattern.AbstractFactory; /* * 所有食物的接口 */ public interface Food { /* * 获取食物的方法 */ public void get(); } 新建一个麦当劳总店的接口： package com.diermeng.designPattern.AbstractFactory; /* * 麦当劳总店 */ public interface FoodFactory { //实例化汉堡 public Food getHamburg(); //实例化鸡翅 public Food getChickenWing(); } 建立汉堡的抽象基类 package com.diermeng.designPattern.AbstractFactory; /* * 汉堡的抽象父类 */ public abstract class Hamburg implements Food{ /* * 获取汉堡的方法 */ public abstract void get(); } 建立鸡翅的抽象基类 package com.diermeng.designPattern.AbstractFactory; /* * 鸡翅的抽象类 */ public abstract class ChickenWing implements Food{ /* * 获取鸡翅的方法 */ public abstract void get(); } 建立中心商业街南部的麦当劳分店 package com.diermeng.designPattern.AbstractFactory.impl; import com.diermeng.designPattern.AbstractFactory.Food; import com.diermeng.designPattern.AbstractFactory.FoodFactory; /* * 中心商业街南边的麦当劳分店 */ public class SouthMacDonald implements FoodFactory { /* * 获取汉堡 * @see com.diermeng.designPattern.AbstractFactory.FoodFactory#getHamburg() */ public Food getHamburg() { return new SouthMacDonaldHamburg(); } /* * 获取鸡翅 * @see com.diermeng.designPattern.AbstractFactory.FoodFactory#getChickenWing() */ public Food getChickenWing() { return new SouthMacDonaldChickenWing(); } } 建立华联那边麦当劳分店 package com.diermeng.designPattern.AbstractFactory.impl; import com.diermeng.designPattern.AbstractFactory.Food; import com.diermeng.designPattern.AbstractFactory.FoodFactory; /* * 麦当劳的华联分店 */ public class HualianMacDonald implements FoodFactory { /* * 获取汉堡 * @see com.diermeng.designPattern.AbstractFactory.FoodFactory#getHamburg() */ public Food getHamburg() { return new HualianMacDonaldHamburg(); } /* * 获取鸡翅 * @see com.diermeng.designPattern.AbstractFactory.FoodFactory#getChickenWing() */ public Food getChickenWing() { return new HualianMacDonaldChickenWing(); } } 建立中心商业街南边的麦当劳的汉堡： package com.diermeng.designPattern.AbstractFactory.impl; import com.diermeng.designPattern.AbstractFactory.Hamburg; /* * 中心商业街南边的的麦当劳分店的汉堡 */ public class SouthMacDonaldHamburg extends Hamburg { /* * 获取汉堡 * @see com.diermeng.designPattern.AbstractFactory.Hamburg#get() */ public void get() { System.out.println(\"获取中心商业街南边的的麦当劳分店的汉堡\"); } } 建立华联那边的麦当劳的汉堡： package com.diermeng.designPattern.AbstractFactory.impl; import com.diermeng.designPattern.AbstractFactory.Hamburg; /* * 华联那边的麦当劳分店的汉堡 */ public class HualianMacDonaldHamburg extends Hamburg { /* * 获取汉堡 * @see com.diermeng.designPattern.AbstractFactory.Hamburg#get() */ public void get() { System.out.println(\"获取华联那边的麦当劳分店的汉堡\"); } } 建立中心商业街南边的麦当劳鸡翅 package com.diermeng.designPattern.AbstractFactory.impl; import com.diermeng.designPattern.AbstractFactory.ChickenWing; /* * 中心商业街南边的的麦当劳分店的鸡翅 */ public class SouthMacDonaldChickenWing extends ChickenWing { /* * 获取鸡翅 * @see com.diermeng.designPattern.AbstractFactory.ChickenWing#get() */ public void get() { System.out.println(\"获取中心商业街南边的的麦当劳分店的鸡翅\"); } } 建立华联那边的麦当劳的鸡翅 package com.diermeng.designPattern.AbstractFactory.impl; import com.diermeng.designPattern.AbstractFactory.ChickenWing; /* * 华联那边的麦当劳分店的鸡翅 */ public class HualianMacDonaldChickenWing extends ChickenWing { /* * 获取鸡翅 * @see com.diermeng.designPattern.AbstractFactory.ChickenWing#get() */ public void get() { System.out.println(\"获取华联那边的麦当劳分店的鸡翅\"); } } 最后我们建立测试客户端： package com.diermeng.designPattern.AbstractFactory.client; import com.diermeng.designPattern.AbstractFactory.Food; import com.diermeng.designPattern.AbstractFactory.FoodFactory; import com.diermeng.designPattern.AbstractFactory.impl.HualianMacDonald; import com.diermeng.designPattern.AbstractFactory.impl.SouthMacDonald; /* * 测试客户端 */ public class AbstractFactoryTest { public static void main(String[] args) { //声明并实例化中心商业街南边的的麦当劳分店 FoodFactory southMacDonald= new SouthMacDonald(); //获取中心商业街南边的的麦当劳分店的汉堡 Food southMacDonaldHamburg = southMacDonald.getHamburg(); southMacDonaldHamburg.get(); //获取中心商业街南边的的麦当劳分店的鸡翅 Food southMacDonaldChickenWing = southMacDonald.getChickenWing(); southMacDonaldChickenWing.get(); //声明并实例化华联那边的麦当劳分店 FoodFactory hualianMacDonald = new HualianMacDonald(); //获取华联那边的麦当劳分店的汉堡 Food hualianMacDonaldHamburg =hualianMacDonald.getHamburg(); hualianMacDonaldHamburg.get(); //获取华联那边的麦当劳分店的鸡翅 Food hualianMacDonaldChickenWing = hualianMacDonald.getChickenWing(); hualianMacDonaldChickenWing.get(); } } 输出的结果如下： 获取中心商业街南边的的麦当劳分店的汉堡 获取中心商业街南边的的麦当劳分店的鸡翅 获取华联那边的麦当劳分店的汉堡 获取华联那边的麦当劳分店的鸡翅 抽象工厂模式的优缺点分析： 优点：客户端不再负责对象的具体创建，而是把这个责任交给了具体的工厂类，客户端之负责对对象的调用。当具有产品家族性质的产品被涉及到一个工厂类中后，对客户端而言是非常友好的，更重要的是如果想要更换为另外一产品家族，所要做的只是需要增加相应的产品家族成员和增加一个具体的产品工厂而已。 缺点：当有新的产品加入的时候，也就是当产品的结构发生改变时，修要修改抽象工厂类的设计，这就导致了必须修改所有的具体工厂类，导致很客观的工作量的增加。 抽象工厂模式的实际应用简介： 抽象工厂模式是针对多个产品系列的创建的问题，这在持久化层的设计很实现中有很大的指导意义。由于Java的跨平台性，一般而言，持久化层都要考虑到都肿数据库的问题，例如MySQL、Oracle等，每一个数据库就相当于一个产品系列，持久化层必须设计好好不同产品系列的共同接口，这样才便于使用者操作数据库，同时也有利于数据库的移植。大名鼎鼎的Hibernate就很好的借鉴了抽象工厂模式的设计方法。 温馨提示： 抽象工厂模式考虑的是不同产品系列的创建的问题，并非能到处使用。另外在新增加产品的时候，需要改变抽象工厂的设计，这会导致很大的工作量，所以在规划之初必须考虑好产品的结构，力求降低参加产品的可能性，是抽象工厂比较稳定。","title":"设计模式之抽象工程"},{"content":"原型模式应用场景举例： GG和MM经常在QQ上聊天，但是GG打字的速度慢如蜗牛爬行，每次MM在瞬间完成恢复或者问候是，GG都会很紧张的去尽力快速打字，尽管如此，还是让MM有些不高心，MM说回复信息这么慢，显然是用心不专，不在乎她。哎，GG也是百口难辩啊，不过也确实是没有办法。 有一天，GG想自己的密友K倾诉了自己的苦衷。K顿生大笑。说道：“傻瓜，你怎么不去网上收集一些肉麻的情话以及一些你们经常说话会涉及到主题，把这些东西拷贝下来保存在自己的电脑或者U盘里面，这样一来如果下次在聊天就可以借用过来了！”，“K就是K，我怎么没有想到呢~妙极~妙极^_^”，“不过不要太高兴，这些东西是要适当修改的，要不然你把名字都搞错的话，就等着你的MM把你踹死吧O(∩_∩)O哈哈~”K补充道，“嗯，说的对，谢谢K哥解决了我的心腹之患啊”GG乐不可支的说道。 这是MM由在网上和GG聊天，GG专门复制那些实现准备好的肉麻情话经过稍加修改后发给MM，MM都快美死了… 原型模式解释： 原型模式（Prototype Pattern）是一种对象创建型模式，它采取复制原型对象的方法来创建对象的实例。使用Prototype模式创建的实例，具有与原型一样的初始化数据 英文定义为：Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype. 原型模式的UML图： 原型模式涉及以下的角色： 客户端（Client）角色: 客户端提出创建对象的请求。 抽象原型（Prototype）角色：通常由一个Java接口或者Java抽象类来实现。从而为具体原型设立好规范。 具体原型（Concrete Prototype）角色：被复制的具体对象，此具体角色实现了抽象原型角色所要求实现的方法。 原型模式的UML图如下所示： 原型模式深入分析： 原型模式的工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。 Java在语言级别是直接支持原型模式的。我们知道，在java.lang.Object是一切类和接口的父类，而java.lang.Object正好提供了一个clone（）方法来支持原型模式。当然，一个对象如果想具有被复制的能力，还必须声明自己实现了Cloneable接口，如果没有声明，就会在对象被复制的时候抛出CloneNotSupportedException. 在java.lang.Object中提供了一个 protected Object clone()方法来支持对象的克隆，子类可以采用默认的方式进行所有字段的复制，也可以在子类中覆盖clone()方便，根据实际需要定制自己的复制行为。 复制浅复制和深复制之分，浅复制是对基本数据类型和String类型而言的，深复制是对其他引用类型而言的。对于深复制，每一个应用也需要声明Cloneable接口。 原型模式使用场景分析及代码实现： 在上面的使用场景中，因为GG打字太慢经常被女朋友怪罪，所以有了拷贝网上肉麻情话的和主要聊天话题内容的办法。这样，以后GG每次和MM聊天的时候只需要把原话拷贝出来，加以适当修改就行，省时省力，而且效果绝佳^_^，这就是设计模式的原型模式的使用的好处O(∩_∩)O~ UML模型图如下所示： 建立一个肉麻情话类，类中有非常详细的注释，这里就不在解释了： package com.diermeng.designPattern.Prototype.impl; import java.util.ArrayList; import java.util.List; /* * 肉麻情话类 */ public class SweetWord implements Cloneable{ //肉麻情话句子 private String content; //肉麻情话句子集合 private List<String> contents; /* * 获取肉麻情话集合 */ public List<String> getContents() { return contents; } /* * 设置肉麻情话集合 */ public void setContents(List<String> contents) { this.contents = contents; } /* * 获取肉麻情话 */ public String getContent() { return content; } /* * 设置肉麻情话 */ public void setContent(String content) { this.content = content; } /* * 肉麻情话覆盖了Object类的clone()方法，因为这里有List引用进行深度复制 * @see java.lang.Object#clone() */ public SweetWord clone() { try { //新建一个肉麻情话对象，同时复制基本的属性 SweetWord sweetWord = (SweetWord)super.clone(); //新建一个肉麻情话集合 List<String> newContents = new ArrayList<String>(); //把原对象的肉麻情话集合中的肉麻情话集合通过forEach循环加入新建的newContents中 for(String friend : this.getContents()) { newContents.add(friend); } //把新的肉麻情话集合设置进新的对象 sweetWord.setContents(newContents); //返回新的的肉麻情话对象 return sweetWord; } catch (CloneNotSupportedException e) { e.printStackTrace(); return null; } } } 最后我们建立测试客户端： package com.diermeng.designPattern.Prototype.client; import java.util.ArrayList; import java.util.List; import com.diermeng.designPattern.Prototype.impl.SweetWord; /* * 肉麻情话测试客户端 */ public class PrototypeClient { public static void main(String[] args) { //新建一个肉麻情话对象并设置相应的属性 SweetWord content1 = new SweetWord(); List<String> contents = new ArrayList<String>(); contents.add(\"宝贝儿，我爱你\"); contents.add(\"你是我的唯一\"); content1.setContents(contents); //复制content1 SweetWord content2 = content1.clone(); //分别输入两个对象的内容 System.out.println(content1.getContents()); System.out.println(content2.getContents()); //在原来的肉麻情话对象中加入新的内容并把新的内容设置进去 contents.add(\"你是我真命天女\"); content1.setContents(contents); //分别输出新的修改后的两个肉麻情话对象 System.out.println(content1.getContents()); System.out.println(content2.getContents()); } } 输出的结果如下： [宝贝儿，我爱你, 你是我的唯一] [宝贝儿，我爱你, 你是我的唯一] [宝贝儿，我爱你, 你是我的唯一, 你是我真命天女] [宝贝儿，我爱你, 你是我的唯一] 原型模式的优缺点分析： 优点： 1.允许动态地增加或减少产品类。由于创建产品类实例的方法是产品类内部具有的，因此增加新产品对整个结构没有影响。 2.提供简化的创建结构。 3.具有给一个应用软件动态加载新功能的能力。 4.产品类不需要非得有任何事先确定的等级结构，因为原型模式适用于任何的等级结构。 缺点： 每一个类都必须配备一个克隆方法，这对于全新的类来说不是很难，而对已有的类来说实现clone()方法不一定很容易，而且在进行比较深层次的复制的时候也需要编写一定工作量的代码 原型模式的实际应用简介： 原型对象一般在适用于一下场景： 在创建对象的时候，我们不仅希望被创建的对象继承其类的基本机构，而且还希望继承原型对象的数据。 希望对目标对象的修改不影响既有的原型对象（深度克隆的时候可以完全互不影响）。 隐藏克隆操作的细节。很多时候，对对象本身的克隆需要涉及到类本身的数据细节。 温馨提示： 因为使用原型模式的时候每个类都要具备克隆方法。如果在类的设计之初没有很好的规划，等使用很久了才想到克隆，就可能非常的麻烦，尤其是在设计到深层次复制的时候，因为此时牵扯到很多因素，而且工作量非常大。 在给女朋友复制肉麻情话的之前必须充分检查，做适当的修改，别搞的发过去的情话中有参见某某具体网址的情况出现，否则的话，你就死定了O(∩_∩)O哈！","title":"设计模式之原型模式"},{"content":"前言： 适配器的最经典的解释就是一个插线板，里面只有2个孔的插座，而电器用的插头是3个孔的。然后用了个适配器。即把插头插在适配器三个孔上。适配器再插到插线板2个孔上。 这是个简单而形象的比喻。最近在看《代码大全2》其中谈到了隐喻，及将代码的设计，或结构的设计等用建筑工程等实际例子做比喻。很有趣！比如上面举的例子，我们会发现一个问题，就是插头是3个孔的，插了2个孔的插座，还有一个孔的功能没有实现，怎么办。对应具体代码中，老系统或老代码提供的接口就少了这样一个实现，你又必需去整合老系统，怎么办？ 从上面的比喻中，我们看到适配器主要提供一个转换功能。将提供方的数据转换后提供给接收方。所以适配器模式解决的是接口不兼容模式。当我们可以修改任何一方的接口时，就不需要适配器这个东西了。就如同，我们将两孔插座改成了3孔。改了之后不支持原来的2孔了。或者改造插座，同时提供2孔和3孔。抑或将2孔插头改成3孔插头。这些都意味着需要改动原有的稳定的接口。带来不稳定因素。当产品尚未稳定，尚未发布，尚未投入使用，改造还是可以的。但一旦投入使用，已经稳定的产品，是不建议进行改动的。更适合采用适配器模式。 事实上，适配器模式适用于异构系统和2个稳定而不做改动的系统中的接口不一致时采用。 在短信平台项目中，短信发送就是个典型的适配器模式。 短信的组织、接收者的选择等用户操作部分已经稳定下来，而短信平台将短信提交至短信运营商发送也已稳定。用户操作界面与短信平台均已稳定，并在若干个项目中投入使用。 但用户操作界面系统提供的接口，只是将待发送短信送入数据库待发送列表，而短信平台则提供WebService接收短信并发送。2者并无法直接对接，就像前面提供3孔插头无法插入2孔插座一样。因此我们开发了个适配器，一个后台Windows服务，定期从数据库中读取待发送短信提交至WebService。 从上面的描述来看，适配器模式好像很好理解。但在没有设计直接编码实现的代码世界里，会面临很多问题。就好比提供电源的插座和电器插头是连在一起的，这还不只如此，里面供电的线路异常复杂，可能有好几处电线搅在一起。你可能觉得不可思议，但翻看代码，你就会发现这样的问题，会遍地存在。 首先是插座和插头是连在一起的。也就是代码对提供者和供应者没有进行抽象分开，没有定义双方通信的接口，直接就调用实现。类似于代码中直接New 了一个对象，直接使用。而未定义个接口或抽象类。但这还不是最糟的，还有直接将本该对象实现的代码直接写在方法体内了（面向过程的写法）。类似于，电线内大约与上千根细小的铜线，各个都独立供电。我们在看现实世界的时候很多问题能好理解，然后在代码世界往往缺少对整体设计的理解和把握。 概述 　　将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。 解决的问题 　　即Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。 模式中的角色 1 目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。 2 需要适配的类（Adaptee）：需要适配的类或适配者类。 3 适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。　　 模式解读 　　注：在GoF的设计模式中，对适配器模式讲了两种类型，类适配器模式和对象适配器模式。由于类适配器模式通过多重继承对一个接口与另一个接口进行匹配，而C#、java等语言都不支持多重继承，因而这里只是介绍对象适配器。    适配器模式的类图： 用插座，插头的例子来进行对比：Client类好比电器（比如：电风扇） Target类好比插头，Request方法好比3足插头，Adapter好比3孔2足适配器，Adaptee好比2孔插座。 现实生活中，Client和Target(Reqeust)一般是紧密联系在一起，Adapter 和Adaptee、Client三者均完全独立，可独立更换。 适配器模式代码本身非常简单，我们仍然从代码演进开始一步步走向最终设计： 示例一：面向过程设计  private voidForm1_Load(object sender, EventArgs e)         {            Console.Write(\"这段文字需要写入日志\");         } 直接输出需要输出的文字。这样写，在没有变化的情况下是没有任何问题的。遇到变化时候的适应性很差。电器自带电源。因此我们将此段实现丢给一个类去具体实现。具体变化如下： 示例二：面向对象设计  private voidForm1_Load(object sender, EventArgs e)         {             Logger log =new Logger();            log.WriteLog(\"这段文字需要写入日志\");         }         public classLogger     {        public void WriteLog(string msg)         {            Console.Write(msg);         }     } 将写日志抽象成也类来实现其功能。当需要将日志写入数据库，或写入文件，可以直接在Logger类中修正即可。无需项目中遍地去修改。电器定义了自己的插头，并设计了带有匹配此插头的电源，但可拆卸更换电源。但无法使用其他人提供的电源。此时电源已经有电器零部件的意思了，但未定义电器插头的标准。故无法使用第三方电源。为了扩展电源提供，定义接口标准。具体变化如下： 示例三：定义接口 private void Form1_Load(objectsender, EventArgs e)         {             ILogger log= new Logger();            log.WriteLog(\"这段文字需要写入日志\");         }          public interface ILogger     {         void WriteLog(string msg);     }     public class Logger:ILogger     {        public void WriteLog(string msg)         {             Console.Write(msg);         }     } 正如前面所说，定义接口，形成调用者与被调用者双方的契约。明确被调用者的职责。电器外置电源，将电器与电源分开，并定义了使用的标准插头。电器通过标准插头获取电源。极大的丰富了电源的提供商。 示例四：适配器模式      private void Form1_Load(object sender, EventArgs e)         {             ILogger log= new Logger();            log.WriteLog(\"这段文字需要写入日志\");         }          public interface ILogger     {         void WriteLog(string msg);     }     public class Logger : ILogger      {         ILogger2 logger2 = new Logger2();        public void WriteLog(string msg)         {            logger2.Write(msg, \"c://a.txt\");            //Console.Write(msg);         }            }          public interface ILogger2     {         void Write(string msg, string type);     }     public classLogger2 : ILogger2     {         public void Write(string msg, stringpath)         {            System.IO.File.WriteAllText(path, msg);         }     } 这步跨度有点大，需要说明的有几点： ILogger2 和Logger2是另外一个系统或者第三方提供的DLL我们无法改变其内部逻辑。 其次Logger类就是我们所称的适配器类。严格按照我们上面所举的列子的话，它应该独立存在一个DLL中。当使用不同的方式记录日志时，采用不同的DLL（适配器）。使用已有插座提供电源，并找到对应的适配器。  该例子中，Form1_Load为Client即电器，Ilogger 是标准，提供电源，或者称插座标准。Logger 插头适配器， Logger2 插座。 关于隐喻： 我们对照代码世界和现实世界，还是会发现会有很多不一样的地方。比如插座和插头现实世界中是完全分开的，我们可以看的很清楚。但代码世界中，“插头\"和\"插座\"有可能还是在一起的。同个项目中，同个DLL中。用现实世界的眼光看代码世界，似乎插座和插头连在了一起。而严格按照现实世界来改造代码世界，似乎很恐怖，一个类就有可能一个DLL一个简单项目成百上千个DLL（为了方便随时替换）。当然此处的类比对象是代码中的类对象而非DLL。只是当适配对象和被适配对象同在一个项目（DLL）中，缺乏明确的类对象间职责划分，尤其是自己写的代码，容易直接修改接口，而非扩展适配。 各种实现方式的讨论： 示例一编程风格，这里不做评论，面临改动的时将带来很大工作量，导致系统不稳定，不适合大项目中。 示例二编程风格，遇到需要切换输出日志方式时，我们可以新增一个类，实现新的日志输出方式，或者直接使用现有的日志类。我们只要改造Logger类，即可实现实现现成类。适配的功能。代码如下：  private void Form1_Load(object sender, EventArgs e)         {             Logger log =new Logger();            log.WriteLog(\"这段文字需要写入日志\");         }         public classLogger     {        Logger2 logger2 = new Logger2();        public void WriteLog(string msg)         {            logger2.Write(msg, \"c://a.txt\");            //Console.Write(msg);         }     } public class Logger2   {         public void Write(string msg, stringpath)         {            System.IO.File.WriteAllText(path, msg);         }     } Logger也是个适配器，这电器使用了特定的插头，而插座也非通用插座。每次都要特定的适配器。这就是没有定义标准带来的问题。这个适配器也不通用，只能在这样的一种情境中使用。   5. 模式总结 5.1 优点 5.1.1 通过适配器，客户端可以调用同一接口，因而对客户端来说是透明的。这样做更简单、更直接、更紧凑。 5.1.2 复用了现存的类，解决了现存类和复用环境要求不一致的问题。 5.1.3 将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码。 5.1.4 一个对象适配器可以把多个不同的适配者类适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。 5.2 缺点 　　　　对于对象适配器来说，更换适配器的实现过程比较复杂。（可以用工厂模式解决） 5.3 适用场景 5.3.1 系统需要使用现有的类，而这些类的接口不符合系统的接口。 5.3.2 想要建立一个可以重用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。 5.3.3 两个类所做的事情相同或相似，但是具有不同接口的时候。 5.3.4 旧的系统开发的类已经实现了一些功能，但是客户端却只能以另外接口的形式访问，但我们不希望手动更改原有类的时候。 5.3.5 使用第三方组件，组件接口定义和自己定义的不同，不希望修改自己的接口，但是要使用第三方组件接口的功能。    ","title":".Net设计模式之适配器模式（Adapter Pattern）"},{"content":"1.工厂方法模式（Factory Method）  将程序中创建对象的操作，单独出来处理，创建一个产品的工厂接口，把实际的工作转移到具体的子类。大大提高了系统扩展的柔性，接口的抽象化处理给相互依赖的对象创建提供了最好的抽象模式。 [java] view plaincopy public class TestFactoryMethod {      public static void main(String[] args) {      AnimalFactory af=new DogFactory();      Animal1 a=af.getAnimal();      }      }      abstract class Animal1{}      class Dog1 extends Animal1{}      class Cat1 extends Animal1{}            abstract class AnimalFactory{      public abstract Animal1 getAnimal();      }      class DogFactory extends AnimalFactory{      public Animal1 getAnimal(){      System.out.println(\"Dog\");      return new Dog1();      }      }      class CatFactory extends AnimalFactory{      public Animal1 getAnimal(){      System.out.println(\"Cat\");      return new Cat1();      }      }      2.抽象工厂模式（Abstract Factory） 针对多个产品等级的情况，而工厂方法模式针对单一产品等级的情况。 [java] view plaincopy import java.awt.*;      import javax.swing.*;      import java.awt.event.*;      public class TestAbstractFactory {      public static void main(String[] args) {      GUIFactory fact=new SwingFactory();      Frame f=fact.getFrame();      Component c1=fact.getButton();      Component c2=fact.getTextField();            f.setSize(500,300);      f.setLayout(new FlowLayout());      f.add(c1);      f.add(c2);      f.setVisible(true);            f.addWindowListener(new WindowAdapter(){      public void windowClosing(WindowEvent e){      System.exit(0);      }      });      }      }      abstract class GUIFactory{      public abstract Component getButton();      public abstract Component getTextField();      public abstract Frame getFrame();      }      class AWTFactory extends GUIFactory{      public Component getButton() {      return new Button(\"AWT Button\");      }      public Frame getFrame() {      return new Frame(\"AWT Frame\");      }      public Component getTextField() {      return new TextField(20);      }            }      class SwingFactory extends GUIFactory{      public Component getButton() {      return new JButton(\"Swing Button\");      }      public Frame getFrame() {      return new JFrame(\"Swing Frame\");      }      public Component getTextField() {      return new JTextField(20);      }      }    3.单例模式（Singleton） 改善全局变量和命名空间的冲突，可以说是一种改良了的全局变量。这种一个类只有一个实例，且提供一个访问全局点的方式，更加灵活的保证了实例的创建和访问约束。系统中只有一个实例，因此构造方法应该为私有 饿汉式：类加载时直接创建静态实例 懒汉式：第一次需要时才创建一个实例，那么newInstance方法要加同步 饿汉式比懒汉式要好，尽管资源利用率要差。但是不用同步。 [java] view plaincopy public class TestSingleton {      public static void main(String[] args) {            }      }      class ClassA{ //饿汉式      private static ClassA i=new ClassA();      public static ClassA newInstance(){      return i;      }      private ClassA(){}      }      class ClassB{ //懒汉式      private static ClassB i=null;      public static synchronized ClassB newInstance(){      if (i==null) i=new ClassB();      return i;      }      private ClassB(){}      }    4.建造模式（Builder） 将一个对象的内部表象和建造过程分割，一个建造过程可以造出不同表象的对象。可简化为模版方法模式. [java] view plaincopy public class TestBuilder {       public static void main(String[] args) {       Builder b=new BuilderImpl1();       Director d=new Director(b);       Product p=d.createProduct();       }            }       interface Builder{       void buildPart1();       void buildPart2();       void buildPart3();       Product getProduct();       }       class BuilderImpl1 implements Builder{            public void buildPart1() {       System.out.println(\"create part1\");       }            public void buildPart2() {       System.out.println(\"create part2\");      }            public void buildPart3() {       System.out.println(\"create part3\");       }            public Product getProduct() {       return new Product();       }            }            class Director{       Builder b;       public Director(Builder b){       this.b=b;       }       public Product createProduct(){       b.buildPart1(); b.buildPart2();       b.buildPart3();       return b.getProduct();       }       }       class Product{}    5.原型模式（ProtoType） 通过一个原型对象来创建一个新对象（克隆）。Java中要给出Clonable接口的实现，具体类要实现这个接口，并给出clone()方法的实现细节，这就是简单原型模式的应用。  浅拷贝：只拷贝简单属性的值和对象属性的地址  深拷贝：拷贝本对象引用的对象，有可能会出现循环引用的情况。可以用串行化解决深拷贝。写到流里再读出来，这时会是一个对象的深拷贝结果。 [java] view plaincopy import java.io.*;      public class TestClonealbe {      public static void main(String[] args) throws Exception {      Father f=new Father();            User u1=new User(\"123456\",f);      User u2=(User)u1.clone();      System.out.println(u1==u2);      System.out.println(u1.f==u2.f);      }      }      class User implements Cloneable,Serializable{      String password;      Father f;      public User(String password,Father f){      this.password=password;      this.f=f;      }      public Object clone() throws CloneNotSupportedException {      //return super.clone();      ObjectOutputStream out=null;      ObjectInputStream in=null;      try {      ByteArrayOutputStream bo=new ByteArrayOutputStream();      out = new ObjectOutputStream(bo);      out.writeObject(this);      out.flush();      byte[] bs=bo.toByteArray();            ByteArrayInputStream bi=new ByteArrayInputStream(bs);      in = new ObjectInputStream(bi);      Object o=in.readObject();            return o;      } catch (IOException e) {      e.printStackTrace();      return null;      } catch (ClassNotFoundException e) {      e.printStackTrace();      return null;      }      finally{      try {      out.close();      in.close();      } catch (IOException e) {      e.printStackTrace();      }      }      }      }      class Father implements Serializable{}   结构模式 如何把简单的类根据某种结构组装为大的系统  6.适配器模式（Adapter） 在原类型不做任何改变的情况下，用一个适配器类把一个接口转成另一个接口，扩展了新的接口，灵活且多样的适配一切旧俗。这种打破旧框框，适配新格局的思想，是面向对象的精髓。以继承方式实现的类的 Adapter模式和以聚合方式实现的对象的Adapter模式，各有千秋，各取所长。 [java] view plaincopy public class TestAdapter {      public static void main(String[] args) {      USB mouse=new Mouse();      PC pc=new PC();      //pc.useMouse(mouse);      PS2 adapter=new USB2PS2Adapter(mouse);      pc.useMouse(adapter);      }      }      interface PS2{      void usePs2();      }      interface USB{      void useUsb();      }      class Mouse implements USB{      public void useUsb(){      System.out.println(\"通过USB接口工作\");      }      }      class PC{      public void useMouse(PS2 ps2Mouse){      ps2Mouse.usePs2();      }      }      class USB2PS2Adapter implements PS2{      private USB usb;      public USB2PS2Adapter(USB usb) {      this.usb = usb;      }      public void usePs2(){      System.out.println(\"把对usePS2的方法调用转换成对useUSB的方法调用\");      usb.useUsb();      }      }      7.组合模式（Composite） 把整体和局部的关系用树状结构描述出来，使得客户端把整体对象和局部对象同等看待。 [java] view plaincopy import java.util.*;      public class TestComposite {      public static void main(String[] args) {      Node n1=new LeafNode(3);      Node n2=new LeafNode(4);      Node n3=new LeafNode(6);      Node n4=new LeafNode(5);      Node n5=new LeafNode(2);      Node n6=new LeafNode(9);      Node n7=new LeafNode(12);      Node n8=new LeafNode(7);      Node n9=new LeafNode(8);      Node c1=new CompositeNode(n1,n2,n3);      Node c4=new CompositeNode(n8,n9);      Node c3=new CompositeNode(n5,c4);      Node c2=new CompositeNode(n4,c3);      Node c5=new CompositeNode(n6,n7);      Node root=new CompositeNode(c1,c2,c5);            System.out.println(root.getValue());      }      }      abstract class Node{      public abstract int getValue();      }      class LeafNode extends Node{      int value;      public LeafNode(int value){      this.value=value;      }      public int getValue(){      return value;      }      }      class CompositeNode extends Node{      private List children=new ArrayList();      public CompositeNode(Node... nodes){      for(Node n:nodes){      children.add(n);      }      }      public int getValue(){      int result=0;      for(Node n:children){      result+=n.getValue();      }      return result;      }            }    8.装饰模式（Decorator） 以对客户透明的方式来扩展对象的功能。 用户根据功能需求随意选取组成对象的成分，通过方法的链式调用来实现。 可以给对象动态的增加功能，比继承灵活性更大。 [java] view plaincopy public class TestDecorator {      public static void main(String[] args) {      Teacher t1=new SimpleTeacher();      Teacher t2=new CppTeacher(t1);      Teacher t3=new JavaTeacher(t2);      t3.teach();      //t.teach();      }      }            abstract class Teacher{      public abstract void teach();      }      class SimpleTeacher extends Teacher{      public void teach(){      System.out.println(\"Good Good Study, Day Day Up\");      }      }      class JavaTeacher extends Teacher{      Teacher teacher;      public JavaTeacher(Teacher t){      this.teacher=t;      }      public void teach(){      teacher.teach();      System.out.println(\"Teach Java\");      }      }      class CppTeacher extends Teacher{      Teacher teacher;      public CppTeacher(Teacher t){      this.teacher=t;      }      public void teach(){      teacher.teach();      System.out.println(\"Teach C++\");      }      }    9.代理模式（Proxy） 用一个代理对象来作为另一个对象的代理，对客户来说是透明的。 存在一个抽象主题类，具体主题类和代理主题类都继承（实现）抽象主题，代理主题类中的方法会调用具体主题类中相对应的方法。 10.享元模式（Flyweight Pattern） 对象的状态分为内蕴状态和外蕴状态。内蕴状态不随环境变化而变化，因此可以作成系统共享.  11.门面模式（Facade） 访问子系统的时候，通过一个Façade对象访问。Facade类是单例的。 客户代码只需要和门面对象通信，不需要和具体子系统内部的对象通信，使得他们之间的耦合关系减弱。 这次将表现层和逻辑层隔离，封装底层的复杂处理，为用户提供简单的接口，这样的例子随处可见。 门面模式很多时候更是一种系统架构的设计，在我所做的项目中，就实现了门面模式的接口，为复杂系统的解耦提供了最好的解决方案。  12.桥梁模式（Bridge） 将抽象和实现脱耦，使得二者可以单独变化。使得一个继承关系不承担两个变化因素.使用合成来代替继承的一种体现. [java] view plaincopy public YuanUser(BankAccount account) {      super(account);            }      public void getMoney() {      System.out.print(\"人民币\");      account.withdraw();      }      public void saveMoney() {      System.out.print(\"人民币\");      account.deposit();      }            }      class DollarUser extends BankUser{            public DollarUser(BankAccount account) {      super(account);            }      public void getMoney() {      System.out.print(\"美元\");      account.withdraw();      }      public void saveMoney() {      System.out.print(\"美元\");      account.deposit();      }      }      行为模式 描述如何在对象之间划分责任  13.策略模式（Strategy） 如同LayoutManager和具体的布局管理器的关系，在抽象策略类中定义方法，将易于变化的部分封装为接口，通常Strategy 封装一些运算法则，使之能互换。Bruce Zhang在他的博客中提到策略模式其实是一种“面向接口”的编程方法，真是恰如其分。 在具体策略子类中实现，客户代码根据不同的需要选择相应的具体类，例如电子商务中多种价格算法。 一种策略一旦选中，整个系统运行期是不变化的 [java] view plaincopy public class TestStrategy {      public static void main(String[] args) {      Strategy s1=new May1Strategy();      Strategy s2=new June1Strategy();      Book b=new Book(100);      b.setS(s2);            System.out.println(b.getPrice());            }      }            class Book{      Strategy s;      public Book(double price){      this.price=price;      }      private double price;            public void setS(Strategy s) {      this.s = s;      }            public double getPrice(){      return price*s.getZheKou();      }            }            interface Strategy{      double getZheKou();      }      class May1Strategy implements Strategy{      public double getZheKou(){      return 0.8;      }      }      class June1Strategy implements Strategy{      public double getZheKou(){      return 0.7;      }      }    14.模板方法（Template Method） 准备一个抽象类，把部分确定的逻辑定义在某些方法中，用其他抽象方法实现剩余的逻辑。不同子类对这些逻辑有不同的实现。 用法：定义多个抽象操作，定义并实现一个模板方法，将步骤放在这个具体方法里，推迟到子类实现。子类可以改变父类的可变部分，但不能改变模板方法所代表的顶级逻辑。 [java] view plaincopy public class TestTemplateMethod {      public static void main(String[] args) {      XiaoPin xp=new DaPuKe();      xp.act();      }      }      abstract class XiaoPin{      public abstract void jiaoLiu();      public abstract void xuShi();      public abstract void gaoXiao();      public abstract void shanQing();      public final void act(){      jiaoLiu();      xuShi();      gaoXiao();      shanQing();      }      }      class DaPuKe extends XiaoPin{      public void jiaoLiu(){      System.out.println(\"顺口溜\");      }      public void xuShi(){      System.out.println(\"火车除夕，老同学见面\");      }      public void gaoXiao(){      System.out.println(\"名片当作扑克\");      }      public void shanQing(){      System.out.println(\"马家军\");      }      }        15.观察者模式（Observer） 定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。观察者和被观察者的分开，为模块划分提供了清晰的界限。在低耦合的对象间完成协调。 Java中的事件模型就是一个应用。 16.迭代器模式（Iterator） 类似于集合中的Iterator，使用迭代器来统一不同集合对象的遍历方式。在绝大多数的系统中，都会用到数组、集合、链表、队列这样的类型，关心迭代模式的来龙去脉非常有必要。在遍历算法中，迭代模式提供了遍历的顺序访问容 器，GOF给出的定义为：提供一种方法访问一个容器（container）对象中各个元素，而又不需暴露该对象的内部细节。.NET中就是使用了迭代器来 创建用于foreach的集合。 [java] view plaincopy public class TestIterator {      public static void main(String[] args) {      Stack s=new Stack();      s.push(\"Liucy\");      s.push(\"Huxz\");      s.push(\"George\");            LinkedList l=new LinkedList();      l.addFirst(\"Liucy\");      l.addFirst(\"Huxz\");      l.addFirst(\"George\");            print(l.iterator());      }            public static void print(Itr it){      while(it.hasNext()){      System.out.println(it.next());      }      }      }      interface Itr{      boolean hasNext();      Object next();      }      class Stack{      Object[] os=new Object[10];      int index=0;      private void expand(){      Object[] os2=new Object[os.length*2];      System.arraycopy(os,0,os2,0,os.length);      os=os2;      }      public void push(Object o){      if (index==os.length) expand();      os[index]=o;      index++;      }      public Object pop(){      index--;      Object o=os[index];      os[index]=null;      return o;      }      private class StackItr implements Itr{      int cursor=0;      public boolean hasNext(){      return cursor}      public Object next(){      return os[cursor++];      }      }      public Itr iterator(){      return new StackItr();      }      }            class LinkedList{      private class Node{      Object o;      Node next;      public Node(Object o){      this.o=o;      }      public void setNext(Node next){      this.next=next;      }      public Node getNext(){      return this.next;      }      }            Node head;      public void addFirst(Object o){      Node n=new Node(o);      n.setNext(head);      head=n;      }      public Object removeFirst(){      Node n=head;      head=head.getNext();      return n.o;      }            class LinkedListItr implements Itr{      Node currentNode=head;      public boolean hasNext(){      return this.currentNode!=null;      }      public Object next(){      Node n=currentNode;      currentNode=currentNode.getNext();      return n.o;      }      }      public Itr iterator(){      return new LinkedListItr();      }      }      17.责任链（Chain of Responsibility） 多个处理器对象连成一串，请求在这条链上传递，由该处理这个请求的处理器来处理。发出请求的客户端并不知道哪个对象处理请求。 [java] view plaincopy public class TestChain {      public static void main(String[] args) {      String pass1=\"123456\";      String pass2=\"123456\";      String personId=\"123456789012345678\";      String email=\"chmask@163.com\";            register(pass1,pass2,personId,email);            }      public static void register(String pass1,String pass2,String personId,String email){      Filter f1=new PasswordFilter1();      Filter f2=new PasswordFilter2();      Filter f3=new PersonIdFilter();      Filter f4=new EmailFilter();            f1.setNext(f2);      f2.setNext(f3);      f3.setNext(f4);            System.out.println(f1.doFilter(pass1,pass2,personId,email));      }      }      abstract class Filter{      Filter next=null;      public Filter getNext() {      return next;      }      public void setNext(Filter next) {      this.next = next;      }      public String doFilter(String pass1,String pass2,String personId,String email){      if (next==null) return \"成功\";      else return next.doFilter(pass1,pass2,personId,email);      }      }      class PasswordFilter1 extends Filter{      public String doFilter(String pass1,String pass2,String personId,String email){      if (!(pass1.equals(pass2)))      return \"两次密码输入不一致\";      else return super.doFilter(pass1,pass2,personId,email);      }      }      class PasswordFilter2 extends Filter{      public String doFilter(String pass1,String pass2,String personId,String email){      if (pass1.length()!=6)      return \"密码长度必须为6\";      else return super.doFilter(pass1,pass2,personId,email);      }      }      class PersonIdFilter extends Filter{      public String doFilter(String pass1,String pass2,String personId,String email){      if (personId.length()!=15 && personId.length()!=18)      return \"身份证号码非法\";      else return super.doFilter(pass1,pass2,personId,email);      }      }      class EmailFilter extends Filter{      public String doFilter(String pass1,String pass2,String personId,String email){      int i1=email.indexOf(\"@\");      int i2=email.indexOf(\".\");      if (i1==-1 || i2==-1 || i2-i1<=1 || i1==0 || i2==email.length()-1)      return \"email非法\";      else return super.doFilter(pass1,pass2,personId,email);      }      }    18.状态模式（State） 在对象内部状态改变时改变其行为。把所研究的对象的行为封装在不同的状态对象中。 [java] view plaincopy import static java.lang.System.*;      public class TestState {      public static void main(String[] args) {      BBSUser u=new BBSUser();      u.setState(new GuestState());      u.publish();            u.setState(new NormalState());      u.publish();            u.setState(new BlockedState());      u.publish();            u.setState(new NewComerState());      u.publish();      }      }      class BBSUser{      private State state;      public void setState(State state){      this.state=state;      }      public void publish(){      state.action();      }      }      abstract class State{      public abstract void action();      }      class GuestState extends State{      public void action(){      out.println(\"您处在游客状态，请先登录\");      }      }      class NormalState extends State{      public void action(){      out.println(\"您处在正常状态，文章发表成功\");      }      }      class BlockedState extends State{      public void action(){      out.println(\"您处在被封状态，文章发表失败\");      }      }      class NewComerState extends State{      public void action(){      out.println(\"您是新手，请先学习一下，3天后再来\");      }      }            class StateFactory{      public static State createState(int i){      if (i==1) return new GuestState();      else return new NormalState();      }      }    19.备忘录模式（Memento） 备忘录对象用来存储另一个对象的快照对象，保存其内部状态，使得可以随时恢复。 备忘录角色：保存发起人对象的内部状态，保护内容不被除发起人对象之外的对象获取。窄接口：负责人对象和其他对象看到的接口，只允许把备忘录对象传给其他对象。宽接口：发起人能看到的接口，允许读取内部状态。 发起人角色：创建并使用备忘录对象来保存其状态 负责人角色：负责保存备忘录对象。  白箱实现：备忘录类对其他类也可见，这样发起人的状态可能会存在安全问题。  黑箱实现：把备忘录类作成发起人的内部类，对外提供一个标识接口。 [java] view plaincopy public class TestMemento{      public static void main(String[] args){      Originator ori=new Originator();      Caretaker c=new Caretaker();      ori.setState(\"State 1\");      IFMemento m=ori.createMemento();      c.save(m);      ori.setState(\"State 2\");      m=c.retrieve();      ori.restore(m);      System.out.println(\"Now State:\"+ori.getState());            }      }      class Originator{      String state;      public void setState(String s){      state=s;      System.out.println(\"State change to: \"+s);      }      public String getState(){      return this.state;      }      public IFMemento createMemento(){      return new Memento(state);      }      public void restore(IFMemento m){      Memento mt=(Memento)m;      this.state=mt.getState();      }      private class Memento implements IFMemento{      private String state;      public Memento(String s){      this.state=s;      }      public String getState(){      return this.state;      }      }      }            class Caretaker{      private IFMemento m;      public IFMemento retrieve(){      return this.m;      }      public void save(IFMemento m){      this.m=m;      }      }            interface IFMemento{            } ","title":"java设计模式示例"},{"content":"2  解决方案 2.1  工厂方法模式来解决         用来解决上述问题的一个合理的解决方案就是工厂方法模式。那么什么是工厂方法模式呢？ （1）工厂方法模式定义         定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到其子类。   （2）应用工厂方法模式来解决的思路         仔细分析上面的问题，事实上在实现导出数据的业务功能对象里面，根本就不知道究竟要使用哪一种导出文件的格式，因此这个对象本就不应该和具体的导出文件的对象耦合在一起，它只需要面向导出的文件对象的接口就好了。         但是这样一来，又有新的问题产生了：接口是不能直接使用的，需要使用具体的接口实现对象的实例。         这不是自相矛盾吗？要求面向接口，不让和具体的实现耦合，但是又需要创建接口的具体实现对象的实例。怎么解决这个矛盾呢？         工厂方法模式的解决思路很有意思，那就是不解决，采取无为而治的方式：不是需要接口对象吗，那就定义一个方法来创建；可是事实上它自己是不知道如何创建这个接口对象的，没有关系，那就定义成抽象方法就好了，自己实现不了，那就让子类来实现，这样这个对象本身就可以只是面向接口编程，而无需关心到底如何创建接口对象了。 2.2  模式结构和说明         工厂方法模式的结构如图3所示：                      图3  工厂方法模式结构示意图 Product：         定义工厂方法所创建的对象的接口，也就是实际需要使用的对象的接口。 ConcreteProduct：         具体的Product接口的实现对象。 Creator：         创建器，声明工厂方法，工厂方法通常会返回一个Product类型的实例对象，而且多是抽象方法。也可以在Creator里面提供工厂方法的默认实现，让工厂方法返回一个缺省的Product类型的实例对象。 ConcreteCreator：         具体的创建器对象，覆盖实现Creator定义的工厂方法，返回具体的Product实例。 2.3  工厂方法模式示例代码 （1）先看看Product的定义，示例代码如下：     /** * 工厂方法所创建的对象的接口 */ public interface Product {     //可以定义Product的属性和方法 } （2）再看看具体的Product的实现对象，示例代码如下：     /** * 具体的Product对象 */ public class ConcreteProduct implements Product {     //实现Product要求的方法 } （3）接下来看看创建器的定义，示例代码如下：     /** * 创建器，声明工厂方法 */ public abstract class Creator {     /**     * 创建Product的工厂方法     * @return Product对象     */     protected abstract Product factoryMethod();     /**     * 示意方法，实现某些功能的方法     */     public void someOperation() {        //通常在这些方法实现中，需要调用工厂方法来获取Product对象        Product product = factoryMethod();     } } （4）再看看具体的创建器实现对象，示例代码如下：     /** * 具体的创建器实现对象 */ public class ConcreteCreator extends Creator {     protected Product factoryMethod() {        //重定义工厂方法，返回一个具体的Product对象        return new ConcreteProduct();     } }   2.4  使用工厂方法模式来实现示例         要使用工厂方法模式来实现示例，先来按照工厂方法模式的结构，对应出哪些是被创建的Product，哪些是Creator。分析要求实现的功能，导出的文件对象接口ExportFileApi就相当于是Product，而用来实现导出数据的业务功能对象就相当于Creator。把Product和Creator分开过后，就可以分别来实现它们了。         使用工厂模式来实现示例的程序结构如图4所示：                                  图4  使用工厂模式来实现示例的程序结构示意图 下面一起来看看代码实现。 （1）导出的文件对象接口ExportFileApi的实现没有变化，这里就不去赘述了 （2）接下来看看接口ExportFileApi的实现，为了示例简单，只实现导出文本文件格式和数据库备份文件两种。先看看导出文本文件格式的实现，示例代码如下：     /** * 导出成文本文件格式的对象 */ public class ExportTxtFile implements ExportFileApi{     public boolean export(String data) {        //简单示意一下，这里需要操作文件        System.out.println(\"导出数据\"+data+\"到文本文件\");        return true;     } } 再看看导出成数据库备份文件形式的对象的实现，示例代码如下：     /** * 导出成数据库备份文件形式的对象 */ public class ExportDB implements ExportFileApi{     public boolean export(String data) {        //简单示意一下，这里需要操作数据库和文件        System.out.println(\"导出数据\"+data+\"到数据库备份文件\");        return true;     } } （3）Creator这边的实现，首先看看ExportOperate的实现，示例代码如下：     /** * 实现导出数据的业务功能对象 */ public abstract class ExportOperate {     /**     * 导出文件     * @param data 需要保存的数据     * @return 是否成功导出文件     */     public boolean export(String data){        //使用工厂方法        ExportFileApi api = factoryMethod();        return api.export(data);     }     /**     * 工厂方法，创建导出的文件对象的接口对象     * @return 导出的文件对象的接口对象     */     protected abstract ExportFileApi factoryMethod(); } （4）加入了两个Creator实现，先看看创建导出成文本文件格式的对象，示例代码如下：     /** * 具体的创建器实现对象，实现创建导出成文本文件格式的对象 */ public class ExportTxtFileOperate extends ExportOperate{     protected ExportFileApi factoryMethod() {        //创建导出成文本文件格式的对象        return new ExportTxtFile();     } } 再看看创建导出成数据库备份文件形式的对象，示例代码如下：     /** * 具体的创建器实现对象，实现创建导出成数据库备份文件形式的对象 */ public class ExportDBOperate extends ExportOperate{     protected ExportFileApi factoryMethod() {        //创建导出成数据库备份文件形式的对象        return new ExportDB();     } } （5）客户端直接创建需要使用的Creator对象，然后调用相应的功能方法，示例代码如下：     public class Client {     public static void main(String[] args) {        //创建需要使用的Creator对象        ExportOperate operate = new ExportDBOperate();        //调用输出数据的功能方法        operate.export(\"测试数据\");     } } 运行结果如下：     导出数据测试数据到数据库备份文件           你还可以修改客户端new的对象，切换成其它的实现对象，试试看会发生什么。看来应用工厂方法模式是很简单的，对吧。","title":"23种设计模式之工厂方法模式"},{"content":"一. 模式概述       摸板方法(Template Method)模式是一种非常简单而又经常使用的设计模式.先创建一个父类,把其中的一个或多个方法留给子类去实现,这实际上就是在使用摸板模式.所谓的摸板模式可以这样来理解:\"在一个类中定义一个算法,但将此算法的某些细节留到子类中去实现.换句话说,基类是一个抽象类,那么你就是在使用一种简单形式的摸板模式.\"       更近一步可以这样来理解:\"准备一个抽象类,将部分逻辑以具体方法的形式实现,然后申明一些抽象方法来迫使子类实现剩余的逻辑.不同的子类可以以不同的方法实现这些抽象方法,从而对剩余的逻辑有不同的实现.\" 二. 模式意图       将一个类的基本部分抽取出来放到一个基类中,这样它就不必重复出现在几个派生类里. 三. 模式UML图(下图转自http://www.dofactory.com/)                             四. 模式结构与参与者     抽象摸板角色:         1. 定义了一个或多个抽象操作,以便让子类实现.         2. 定义并实现了一个摸板方法.     具体摸板角色:         1. 实现父类所定义的一个或多个抽象方法.         2. 每一个抽象摸板角色都可以有任意多个具体摸板角色与之对应.         3. 每一个具体摸板角色都可以给出这些抽象方法的不同实现. 五. 模式中的方法种类     1. 抽象模板角色里提供完整的方法,它完成了所有派生类都要用到的一些基本功能.     2. 抽象模板角色里只提供空方法,把功能全部留给派生类去实现.     3. 抽象模板角色里只包含某些操作的默认实现,派生类里可以重新定义这些方法的实现.     4. 抽象模板角色里模板方法,他是一个调用抽象方法,钩子方法以及具体方法的各种组合. 六. 造电脑的示例       首先来看一张图片:                              不用我说,大家都知道,一台电脑(参考上图)的基本组成部分包括的硬件主要有CUP,主板,硬盘,显卡以及内存等.OK,现在的需求就是要去造一台电脑,可计算机生产商有没给我们提供生产电脑的方法(MackPC)呢?没有吧,那么我们自己来定义一个总可以吧(听起好象有点夸张,呵呵,怎么生产电脑的方法也可以自己定义了,那不是自己就可以生产电脑了,可不是呢,这里只是定义了一个生产电脑的程序方法罢).OK,Go! namespace DesignPattern.TemplateMethod.Computer{    /**//// <summary>    /// 抽象摸板角色    /// 定义了一个或多个抽象操作，以便让子类实现。    /// 定义并实现了一个模板方法。    /// <\/summary>    public abstract class Template    {        protected String pcType;        public Template(String pcType)        {            this.pcType = pcType;        }        //留给子类去实现（抽象操作）        protected abstract void MakeCUP(String pcType);        protected abstract void MakeMainBorad(String pcType);        protected abstract void MakeHD(String pcType);        private  void MakeOver(String pcType)         {           Console.WriteLine(pcType + \"造好了！\");        }            /**//// <summary>        /// 摸板方法        /// <\/summary>        public  void MakePC()        {            MakeCUP(pcType);            MakeMainBorad(pcType);            MakeHD(pcType);            MakeOver(pcType);        }    }} 在上面的抽象摸板角色(Template)里,分别定义了生产CPU(MakeCPU),生产主板(MakeMainBorad)以及生产硬盘(MakeHD)的抽象操作(实际中电脑并不只有这三个组成部分,这里为了更简单的演示,故只取了这三个主要组成部分作为示例).在这里,MakePC方法则作为摸板方法. namespace DesignPattern.TemplateMethod.Computer{    /**//// <summary>    ///  具体摸板角色    ///  实现父类所定义的一个或多个抽象方法。    ///  每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法的不同实现。    /// <\/summary>    public class NotePc : Template    {        public NotePc(string pcType)            : base(pcType)        { }        protected override void MakeCUP(string pcType)        {            Console.WriteLine(pcType + \"的CPU造好了\");        }        protected override void MakeMainBorad(string pcType)        {            Console.WriteLine(pcType + \"的硬盘造好了\");        }        protected override void MakeHD(string pcType)        {            Console.WriteLine(pcType + \"的主板造好了\");        }    }}        NotePC作为模式参与者中的具体摸板角色,实现了抽象摸板角色(Template)里的抽象方法.       OK,到这里抽象模板(Template)和具体模板(NotePC)都已经准备好了.可说是\"万事具备,只欠命令\"了,那么,现在就对模板下放一命令,让其制造一\"笔记本\"电脑出来. namespace DesignPattern.TemplateMethod.Computer{    /**//// <summary>    /// 简单的造笔记本摸板    class Client    {        public static void Main1(string[] args)        {            Template t = new NotePc(\"笔记本\");            t.MakePC();        }    }   程序运行结果如下:           七. 典型的摸板方法应用    1. HttpServlet技术        HttpServlet类提供了一个service()方法.这个方法调用了一个或是多个do方法,完成对客户端发起的请求的处理,这些do方法则是由具体的HttpServlet类提供的.那么这里的service()方法就是一个摸板方法. 　　三、举例 　　还是在我刚刚分析完源码的JUnit中找个例子吧。JUnit中的TestCase以及它的子类就是一个模板方法模式的例子。在TestCase这个抽象类中将整个测试的流程设置好了，比如先执行Setup方法初始化测试前提，在运行测试方法，然后再TearDown来取消测试设置。但是你将在Setup、TearDown里面作些什么呢？鬼才知道呢！！因此，而这些步骤的具体实现都延迟到子类中去，也就是你实现的测试类中。 　　来看下相关的源代码吧。 　　这是TestCase中，执行测试的模板方法。你可以看到，里面正像前面定义中所说的那样，它制定了“算法”的框架——先执行setUp方法来做下初始化，然后执行测试方法，最后执行tearDown释放你得到的资源。 public void runBare() throws Throwable { 　setUp(); 　try { 　　runTest(); 　} 　finally { 　　tearDown(); 　} } 　　这就是上面使用的两个方法。与定义中不同的是，这两个方法并没有被实现为抽象方法，而是两个空的无为方法（被称为钩子方法）。这是因为在测试中，我们并不是必须要让测试程序使用这两个方法来初始化和释放资源的。如果是抽象方法，则子类们必须给它一个实现，不管用到用不到。这显然是不合理的。使用钩子方法，则你在需要的时候，可以在子类中重写这些方法。 protected void setUp() throws Exception {} protected void tearDown() throws Exception {} 　　四、适用情况 　　根据上面对定义的分析，以及例子的说明，可以看出模板方法适用于以下情况： 　　1) 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。 　　2) 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。其实这可以说是一种好的编码习惯了。 　　3) 控制子类扩展。模板方法只在特定点调用操作，这样就只允许在这些点进行扩展。比如上面runBare（）方法就只在runTest前面适用setUp方法。如果你不愿子类来修改你的模板方法定义的框架，你可以采用两种方式来做：一是在API中不体现出你的模板方法；二、将你的模板方法置为final就可以了。 　　可以看出，使用模板方法模式可以将代码的公共行为提取出来，达到复用的目的。而且，在模板方法模式中，是由父类的模板方法来控制子类中的具体实现。这样你在实现子类的时候，根本不需要对业务流程有太多的了解。","title":"设计模式----模板方法模式(Template Method)"},{"content":"CHAIN OF RESPONSIBILITY责任链 1、 意图 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿用这条链传递该请求，直到有一个对象处理它为止。 2、 适用性 在以下条件下使用responsibility链：  有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。 你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 可处理一个请求的对象集合应被动态指定。 3、 结构 4、 参与者  Handler                            ——定义一个处理请求的接口。                           ——（可选）实现后继链。 ConcreteHandler                           ——处理它所负责的请求。                           ——可访问它的后继者。                           ——如果可处理该请求，就处理之；否则将该请求转发给它的后继者。 Client                           ——向链上的具体处理者对象提供请求。 5、 协作 当客户提交一个请求时，请求沿链传递直至有一个ConcreteHandler对象负责处理它。 6、 效果 Responsibility链有下列优点和缺点： 1）  降低耦合度；该模式使得一个对象无需知道是其他哪一个对象处理其请求。对象仅需知道该请求被“正确”地处理。接收者和发送者都没有对方的明确的信息，且链中的对象不知道链的结构。结果是，责任链可简化对象的互相连接。它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接收者的引用。 2）  增强了给对象指派职责的灵活性；当在对象中分派职责时，职责链给你更多的灵活性。你可以通过在运行时刻对该链进行动态的增加或修改来增加或改变处理一个请求的那些职责。你可以将这种机制与静态的特例化处理对象的继承机制结合起来使用。 3）  不保证被接受；一个对象没有明确的接收者，那么就不能保证它一定会被处理。该请求可能一直到链末端都得不到处理。一个请求也可能因该链没有被正确配置而得不到处理。 7、 实现 下面是在职责链模式中要考虑的实现问题： 1）   实现后继者链；有两种方法可以实现后继链。 a)  定义新的链接（通常在Handler中定义，但也可由ConcreteHandler来定义）。 b)  使用已有的链接。 2）  连接后继者。如果没有已有的引用可定义一个链，那么你必须自己引入它们。这种情况下Handler不仅定义该请求的接口，通常也维护后继链接。这样Handler就提供了HandleRequest的缺省实现：HandleRequest向后继者转发请求。如果ConcreteHandler子类该请求不感兴趣，它不需要重定义转发操作，因为它的缺省实现进行无条件的转发。 3）  表示请求。可以有不同的方法表示请求。 8、 代码示例 Handler package com.examples.pattern.responsibility;/** * 职责的接口，也就是处理请求的接口 */public abstract class Handler {\t\t/**\t * 持有后继的职责对象\t */\tprotected Handler successor;\t/**\t * 设置后继的职责对象\t * @param successor 后继的职责对象\t */\tpublic void setSuccessor(Handler successor) {\t\tthis.successor = successor;\t}\t\t\t/**\t * 处理方法\t */\tpublic abstract void handleRequest();} ConcreteHandler package com.examples.pattern.responsibility;public class ConcreteHandler1 extends Handler {\t@Override\tpublic void handleRequest() {\t\t//根据某些条件判断是否属于自己处理的职责范围\t\tboolean someCindition = false;\t\tif(someCindition){\t//如果是自己的职责范围\t\t\tSystem.out.println(\"ConcreteHandler1 handle request\");\t\t}else{\t//不是自己的职责范围\t\t\tif(this.successor != null){\t//判断是否有后继的职责对象。如果有，就转发请求给后继者\t\t\t\tthis.successor.handleRequest();\t\t\t}\t\t\t\t\t}\t}} package com.examples.pattern.responsibility;public class ConcreteHandler2 extends Handler {\t@Override\tpublic void handleRequest() {\t\t//根据某些条件判断是否属于自己处理的职责范围\t\tboolean someCindition = true;\t\tif(someCindition){\t//如果是自己的职责范围\t\t\tSystem.out.println(\"ConcreteHandler2 handle request\");\t\t}else{\t//不是自己的职责范围\t\t\tif(this.successor != null){\t//判断是否有后继的职责对象。如果有，就转发请求给后继者\t\t\t\tthis.successor.handleRequest();\t\t\t}\t\t\t\t\t}\t}}Client package com.examples.pattern.responsibility;public class Client {\t/**\t * @param args\t */\tpublic static void main(String[] args) {\t\t//先要组装职责链\t\tHandler h1 = new ConcreteHandler1();\t\tHandler h2 = new ConcreteHandler2();\t\t\t\th1.setSuccessor(h2);\t\t//提交请求\t\th1.handleRequest();\t}} 9、 相关模式  责任链通常与Composite一起使用，这种情况下，一个构建的父构件可作为它的后继。","title":"设计模式——职责链"},{"content":"建造者模式（Builder）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 类图： 代码： publicclass Product {     private List<Object> product=new ArrayList<Object>();     publicvoid add(Object part){        product.add(part);     }     public Object result(){        returnproduct;     } } publicabstractclass Builder {     publicabstractvoid buildPart(Object part);     publicabstract Object getResult(); } publicclass ConcreteBuilder extends Builder{     private Product product=new Product();     @Override     public Object getResult() {        returnproduct.result();     }     @Override     publicvoid buildPart(Object part) {        this.product.add(part);     } } publicclass Director {       public Object conStruct(Builder builder){          return builder.getResult();       } } publicstaticvoid main(String[] args) {        //创建建造者        Builder builder=new ConcreteBuilder();        builder.buildPart(\"head\");        builder.buildPart(\"body\");        builder.buildPart(\"foot\");        //调用创建者        Director director=new Director();        Object pro=director.conStruct(builder);        System.out.println(pro);     } 优点：一个整体和部分的解耦，而且扩展性很好。 缺点：Builder类的方法与Director类的调用方法耦合度很高。如果增加一部分要修改两个类，而且每个整体的部分的数量都要一样。 建造者适合一些对象由其他对象组成的情况。（电脑由主机，屏幕，鼠标，键盘……）","title":"建造者"},{"content":"定义             装饰者模式：动态的将责任附加到对象上，若要扩展功能，装饰者提供比继承更有弹性的替代方案。就增加功能来说，Decorator模式相比生成子类更为灵活。 设计原则：        相信大家现在对装饰者模式都应该很清楚了吧！那么，就像我们在前面的文章里反复强调的一样，设计原则远比模式重要，学习设计模式的同时一定要注意体会设计原则的应用。这里我们再来看看装饰者模式里都符合那些主要的设计原则。 1、 Identify the aspects of your application that vary and separate them from what stays the same. (找到系统中变化的部分，将变化的部分同其它稳定的部分隔开。)         在装饰者模式的应用场景里变化的部分是Component的扩展功能。使用Decorator模式可以很好地将装饰者同被装饰者完全隔离开，我们可以任意改变ConcreteComponent或ConcreteDecorator，它们之间不会有任何相互影响。 2、 Program to an interface,not an implementation.（面向接口编程，而不要面向实现编程。）. 多用组合，少用继承。         利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相同的行为。然而，如果能够利用组合的做法扩展对象的行为，就可以在运行时动态地进行扩展。         Component和Decorator都是抽象类实现，其实相当于起到很好的接口隔离作用，在运行时具体操作的也是Component类型的变量引用，这完全是面向接口编程的。 3、 Favor composition over inheritance.（优先使用对象组合，而非类继承）         装饰者模式最成功的地方就是合理地使用了对象组合，通过组合灵活地扩展了Component的功能，所有的扩展的功能都是通过组合而非继承获得的，这从根本上决定了这种实现是高内聚低耦合的。 4、 Classes should be open for extension, but closed for modification (类应该对扩展开发，对修改关闭)         这是大名鼎鼎的OCP原则，我们在这个系列的第一篇【模式和原则】里就有专门的介绍。在装饰者模式里充分体现了OCP原则，在需要扩展Component的功能的时候，只需要实现一个新的特定的ConcreteDecorator即可，这完全是一种增量开发，不会对原来代码造成任何影响，对用户代码完全是透明的。   要点： 1． 装饰者和被装饰对象有相同的超类型。 2． 可以用一个或多个装饰者包装一个对象。 3． 装饰者可以在所委托被装饰者的行为之前或之后，加上自己的行为，以达到特定的目的。 4． 对象可以在任何时候被装饰，所以可以在运行时动态的，不限量的用你喜欢的装饰者来装饰对象。 5． 装饰模式中使用继承的关键是想达到装饰者和被装饰对象的类型匹配，而不是获得其行为。 6． 装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型。在实际项目中可以根据需要为装饰者添加新的行为，做到“半透明”装饰者。 7． 适配器模式的用意是改变对象的接口而不一定改变对象的性能，而装饰模式的用意是保持接口并增加对象的职责。   其类图实现： 模式的简化： 1. 如果只有一个Concrete Component类而没有抽象的Component接口时，可以让Decorator继承Concrete Component。 2. 如果只有一个Concrete Decorator类时，可以将Decorator和Concrete Decorator合并。   适用性： 以下情况使用Decorator模式 1. 需要扩展一个类的功能，或给一个类添加附加职责。 2. 需要动态的给一个对象添加功能，这些功能可以再动态的撤销。 3. 需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。 4. 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。   优缺点： 模式不是万能的，我们要用好设计模式来解决我们的实际问题，就必须熟知模式的应用场景和优缺点： 装饰者模式的优点： 1、 通过组合而非继承的方式，实现了动态扩展对象的功能的能力。 2、 有效避免了使用继承的方式扩展对象功能而带来的灵活性差，子类无限制扩张的问题。 3、 充分利用了继承和组合的长处和短处，在灵活性和扩展性之间找到完美的平衡点。 4、 装饰者和被装饰者之间虽然都是同一类型，但是它们彼此是完全独立并可以各自独立任意改变的。 5、 遵守大部分GRASP原则和常用设计原则，高内聚、低偶合。 6、 Decorator模式与继承关系的目的都是要扩展对象的功能，但是Decorator可以提供比继承更多的灵活性。 7、 通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合 装饰者模式的缺点： 1、 装饰链不能过长，否则会影响效率。 2、 因为所有对象都是Component,所以如果Component内部结构发生改变，则不可避免地影响所有子类(装饰者和被装饰者)，也就是说，通过继承建立的关系总是脆弱地，如果基类改变，势必影响对象的内部，而通过组合(Decoator HAS A Component)建立的关系只会影响被装饰对象的外部特征。 3、只在必要的时候使用装饰者模式，否则会提高程序的复杂性，增加系统维护难度。 4、 这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。 5、装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。 6、装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择。 修饰者模式至少有两个关键利益及两个责任(liability)： 比静态继承更有弹性：修饰者模式提供一个较静态（多重）继承更有弹性的方式附加责任到对象上。使用修饰者责任可以在执行期简单的附加或取消，相对的继承需要为每一个新的附加责任建立一个新的类（如BorderedScrollableTextView、BorderedTextView等），如此会造成使用许多类及增加系统复杂度。更进一步；为特定的Component类提供不同的修饰者类让你比较及混合责任。 避免在层级架构中增加外貌装载(feature-laden《译注：在类中存有许多有关显示外貌的Component或属性等》)类：修饰者提供一个你要才有(pay-as-you-go)的方式附加责任。相对的不去在一个复杂客制化类中提供一所有可预测外貌；而定义一个简单类并在一个修饰者类逐步增加功能，其结果是一个应用系统无须准备一些不会使用到的外貌。同时也容易从他们所扩充的对象类定义一个新的修饰者类；甚至不在预测内。扩充一个复杂类需要揭露与你要附加责任无关的部分。 修饰者及其Component不是同一个：修饰者就像透明的围墙(transparent enclosure)，但从一个对象界定(identity)的观点；一个被修饰的对象与其本身并不需要去区分(identical)，因此当你使用修饰者无区依赖对象界定。 有许多小对象：使用修饰这设计时常常产生在一个系统中组合看起来很像的许多小对象的结果。这些对象的差一点只是互动(interconnect)的方式；而非他的类或者其内不变量的值。虽然只要你了解他们就可以方便客制系统；但是可能难以学习及除错。 接口一致(conformance)：修饰者对象的接口必须与其修饰的对象接口一致具体修饰指(ConcreteDecorator)类必须继承一个公用(common)类。 忽略(omitting)抽象修饰者类：当你只是附加单一责任时无须定义一个抽象修饰者类，这种情形一般是当你使用现存的类层级架构而非构建一个新的，因此你可以将修饰者传递请求到Component的责任融合(merge)至具体修饰者。 保持轻量(lightweight)的Component类：要确保接口一致，Component及修饰者必须自一个公用Component类继承，保持这个公用Component类轻量是很重要的，即必须专注于定义一个接口而非储存数据。数据责任的定义必须延缓至子类，否则太复杂的Component类会在数量上使用太过于重(heavyweight)。在Component类中放置太多的功能同时会增加其子类为许多没有必要的外表付出代价的可能性。   改变对象的外表(skin)或其内部(guts)：我们可以想象修饰者就像对象的可以改变行为外表，另一种替代方式是改变其内部，策略模式(Strategy)就是改变其内部的作法。当Component类在本质上(intrinsically)太重(heavyweight)时策略模式是一个比较适当的选择，因为以修饰者模式实现成本太高。在策略模式中组件传递(forward)他的部分行为给另外的策略对象，策略模式让我们以替代的策略对象改变或扩充组件的功能。          再说说提到的动态和静态的问题，所谓动态是说可以在系统运行时(RunTime)动态给对象增加其它职责而不需要修改代码或重新编译；所谓静态是说必须通过调整代码(DesignTime)才能给对象增加职责,而且系统还需要重新编译；从具体技术层面来说，对象的组合和继承正好对应于前面的动态和静态，因为通过对象组合建立的交互关系不是在代码中(DesignTime)固定死的，而是在运行时(RunTime)动态组合的；而通过继承建立的关系是僵硬的难以改变的，因为它是在代码中(DesignTime)固定死了的，根本不存在运行时(RunTime)改变的可能。换个角度说：我们应该多使用对象组合来保持系统的运行时扩展性，尽量少使继承，因为继承让程序变得僵硬！这句话听着是不是很熟悉啊？恩！这就是我们前面文章里提过多次的一个设计原则：Favor composition over inheritance.（优先使用对象组合，而非类继承），更多的就不需要再解释了吧？       首先说一下：本文中很多内容均从网上摘抄而来，看到好的总结，就复制粘贴保留了下来，没有给出出处，很不好意思！下面是自己写的一个例子： 这个例子是用食物来说明：煎饼卷菜，煎饼可以配很多菜，然后算出总的价格，每种蔬菜都一个价格：        先看component接口： [html] view plaincopyprint? public Interface IFood {       public double mPrice;       public String mFoodName;       abstract String getPrice();       abstract double cost();   }   public Interface IFood {\tpublic double mPrice;\tpublic String mFoodName;\tabstract String getPrice();\tabstract double cost();} 接下来是concreteComponent类：煎饼类： [html] view plaincopyprint? public class JianBing implements IFood {       public JianBing () {           mPrice = 1.5;           mFoodName = \"煎饼\";       }          @Override       public double cost() {           // TODO Auto-generated method stub           return mPrice ;       }          @Override       String getPrice() {           // TODO Auto-generated method stub           return \"煎饼： + mPrice;       }      }   public class JianBing implements IFood {\tpublic JianBing () {\t\tmPrice = 1.5;\t\tmFoodName = \"煎饼\";\t}\t@Override\tpublic double cost() {\t\t// TODO Auto-generated method stub\t\treturn mPrice ;\t}\t@Override\tString getPrice() {\t\t// TODO Auto-generated method stub\t\treturn \"煎饼： + mPrice;\t}} 后面是Decorator: [html] view plaincopyprint? public abstract class CondimentDecorator implements IFood{       IFood iFood;              public CondimentDecorator (IFood iFood) {           this.iFood = iFood;       }              public double cost () {           return mPrice + iFood.cost();       }   }   public abstract class CondimentDecorator implements IFood{\tIFood iFood;\t\tpublic CondimentDecorator (IFood iFood) {\t\tthis.iFood = iFood;\t}\t\tpublic double cost () {\t\treturn mPrice + iFood.cost();\t}}         最后是concreteDecorator： [html] view plaincopyprint? package cn.test;      public class DoufuChuan extends CondimentDecorator{          public DoufuChuan(IFood iFood) {           super(iFood);           mPrice = 1.0;       }          @Override       String getPrice() {           // TODO Auto-generated method stub           return iFood.getPrice()+\" \"+\"豆腐串：\"+mPrice;       }      }   package cn.test;public class DoufuChuan extends CondimentDecorator{\tpublic DoufuChuan(IFood iFood) {\t\tsuper(iFood);\t\tmPrice = 1.0;\t}\t@Override\tString getPrice() {\t\t// TODO Auto-generated method stub\t\treturn iFood.getPrice()+\" \"+\"豆腐串：\"+mPrice;\t}} [html] view plaincopyprint? public class Huotuichang extends CondimentDecorator{          public Huotuichang(IFood iFood) {           super(iFood);           mPrice = 2.0;       }          @Override       String getPrice() {           // TODO Auto-generated method stub           return iFood.getPrice()+\"/n\"+\"火腿肠：\"+mPrice;       }      }   public class Huotuichang extends CondimentDecorator{\tpublic Huotuichang(IFood iFood) {\t\tsuper(iFood);\t\tmPrice = 2.0;\t}\t@Override\tString getPrice() {\t\t// TODO Auto-generated method stub\t\treturn iFood.getPrice()+\"/n\"+\"火腿肠：\"+mPrice;\t}} 最后看一下测试类： [html] view plaincopyprint? public class DecoratorTest {                     public static void main(String [] args) {           IFood iFood = new JianBing();           iFood = new DoufuChuan(iFood);           iFood = new Huotuichang(iFood);                                 System.out.println(iFood.getPrice());           System.out.println(“一共花费：”+iFood.cost());       }                 }   public class DecoratorTest {\t\t\tpublic static void main(String [] args) {\t\tIFood iFood = new JianBing();\t\tiFood = new DoufuChuan(iFood);\t\tiFood = new Huotuichang(iFood);\t\t\t\t\t\tSystem.out.println(iFood.getPrice());\t\tSystem.out.println(“一共花费：”+iFood.cost());\t}\t\t} 最后结果： [java] view plaincopyprint? 煎饼：1.5 豆腐串：1.0 火腿肠：2.0   一共花费：4.5   煎饼：1.5 豆腐串：1.0 火腿肠：2.0一共花费：4.5         如果没有想明白装饰者模式的好处，可以试着再加一个concreteComponent，再加一个烧饼呢，烧饼也可以搭配各种菜，当然在这里只列举了两种。用装饰者是不是方便很多啊？         装饰者模式体现了【对扩展开放，对修改关闭】的原则，很好的解决了类爆炸以及后期的拓展问题。在java当中，IO包中的输入输出流就是用装饰者模式创建的：java的 IO包中的输入输出六都是基于四个抽象类创建的：字节处理流 InputStream，OutputStream，字符处理流 Reader，Writer。 基于这四个抽象类，又分出了节点流和处理流两类。         节点流常用的有 FileInputStream，FileOutputStream，FileReader，FileWriter。这些类包括抽象基类就是就是被包装（修饰）的对象。          处理流中的缓冲流，转换流，数据流就是装饰者，通过这些类，可以讲节点流对象很好的转换为处理流对象，方便的进行读写操作。          当然，处理流和节点流分别有共同的接口，那就是上述四种抽象类。","title":"浅学设计模式之装饰者<Decorator>模式 ."},{"content":"最近在学习下设计模式，而加深学习的不错的方法就是把心得写出来吧。记录下自己的理解。现在自己看的书是《head.Frist设计模式》这本书。比较不错，想学习设计模式的朋友可以看下这本书。         观察者<Observer>模式（有时又被称为发布-订阅<Publish/Subscribe>模式、模型-视图<Model/View>模式、源-收听者<Source/Listener>模式或从属者<Dependents>模式）是软件设计模式的一种。在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实作事件处理系统。（源自百度百科）            （五月三十一号修正内容）         看下结构图：      开始一个小例子 Observer接口：       [java] view plaincopyprint? public interface ISubscribe {       void getNewPaper();   }   public interface ISubscribe {\tvoid getNewPaper();} 实现Observer接口的观察者： 个人订阅者： [java] view plaincopyprint? public class PersonalSubscriber implements ISubscribe {       private String strName;              public void setNewsPaperName(String strName){           this.strName = strName;       }              public String getNewsPaperName(){           return strName;       }          @Override       public void getNewPaper() {           // TODO Auto-generated method stub           System.out.println(\"我是个人用户，我得到了我的报纸：\"+getNewsPaperName());       }      }   public class PersonalSubscriber implements ISubscribe {\tprivate String strName;\t\tpublic void setNewsPaperName(String strName){\t\tthis.strName = strName;\t}\t\tpublic String getNewsPaperName(){\t\treturn strName;\t}\t@Override\tpublic void getNewPaper() {\t\t// TODO Auto-generated method stub\t\tSystem.out.println(\"我是个人用户，我得到了我的报纸：\"+getNewsPaperName());\t}} 企业订阅者： [java] view plaincopyprint? public class EnterpriseSubscriber implements ISubscribe {       private String strName;              public void setNewsPaperName(String strName){           this.strName = strName;       }              public String getNewsPaperName(){           return strName;       }       @Override       public void getNewPaper() {           // TODO Auto-generated method stub           System.out.println(\"我是企业用户，我得到了我的报纸：\"+getNewsPaperName());       }      }   public class EnterpriseSubscriber implements ISubscribe {    private String strName;\t\tpublic void setNewsPaperName(String strName){\t\tthis.strName = strName;\t}\t\tpublic String getNewsPaperName(){\t\treturn strName;\t}\t@Override\tpublic void getNewPaper() {\t\t// TODO Auto-generated method stub\t\tSystem.out.println(\"我是企业用户，我得到了我的报纸：\"+getNewsPaperName());\t}} 被观察者：Subject [java] view plaincopyprint? public abstract class Publish {        public List<ISubscribe> list;       public Publish(){           list = new ArrayList();       }              public void registered(ISubscribe iSubscribe){           list.add(iSubscribe);       }              public void unregistered(ISubscribe iSubscribe){           list.remove(iSubscribe);       }              public abstract void sendNewsPaper();   }   public abstract class Publish { \tpublic List<ISubscribe> list;\tpublic Publish(){\t\tlist = new ArrayList();\t}\t    public void registered(ISubscribe iSubscribe){    \tlist.add(iSubscribe);    }        public void unregistered(ISubscribe iSubscribe){    \tlist.remove(iSubscribe);    }        public abstract void sendNewsPaper();} 这里使用的是抽象类 下面是实现： [java] view plaincopyprint? public class PostOffice extends Publish{          @Override       public void sendNewsPaper() {           // TODO Auto-generated method stub           Iterator iterator = list.iterator();           while(iterator.hasNext()){               ((ISubscribe) iterator.next()).getNewPaper();           }       }          }   public class PostOffice extends Publish{\t@Override\tpublic void sendNewsPaper() {\t\t// TODO Auto-generated method stub\t\tIterator iterator = list.iterator();\t\twhile(iterator.hasNext()){\t\t\t((ISubscribe) iterator.next()).getNewPaper();\t\t}\t}\t} 测试： [java] view plaincopyprint? public static void main(String[] args) {           // TODO Auto-generated method stub           PostOffice postOffice = new PostOffice();                      //得到个人用户            PersonalSubscriber person = new PersonalSubscriber();           person.setNewsPaperName(\"《南方周末》\");           //得到企业用户            EnterpriseSubscriber enterprise = new EnterpriseSubscriber();           enterprise.setNewsPaperName(\"《企业报》\");                      //注册观察者            postOffice.registered(person);           postOffice.registered(enterprise);                      //发放报纸            postOffice.sendNewsPaper();       }   public static void main(String[] args) {\t\t// TODO Auto-generated method stub\t\tPostOffice postOffice = new PostOffice();\t\t\t\t//得到个人用户\t\tPersonalSubscriber person = new PersonalSubscriber();\t\tperson.setNewsPaperName(\"《南方周末》\");\t\t//得到企业用户\t\tEnterpriseSubscriber enterprise = new EnterpriseSubscriber();\t\tenterprise.setNewsPaperName(\"《企业报》\");\t\t\t\t//注册观察者\t\tpostOffice.registered(person);\t\tpostOffice.registered(enterprise);\t\t\t\t//发放报纸\t\tpostOffice.sendNewsPaper();\t} 测试结果： [java] view plaincopyprint? 我是个人用户，我得到了我的报纸：《南方周末》   我是企业用户，我得到了我的报纸：《企业报》   我是个人用户，我得到了我的报纸：《南方周末》我是企业用户，我得到了我的报纸：《企业报》 下面是有些错误五月18号版本：后面有错误解析！         举个例子，张三从邮局订阅了《南方周末》，李四从邮局订阅了《新京报》，王五从邮局里面订阅了《南方都市报》。当报纸抵达邮局的时候，邮局就会把报纸送递订阅者。而不需要订阅者天天到邮局询问报纸是否到达邮局。        下面开始代码：首先应该是个订阅者接口： [java] view plaincopyprint? package cn.demo;      public interface ISubscribe {       //从邮局订阅报纸        public void registered(PostOffice postOffice);       //从邮局退订报纸        public void unregistered(PostOffice postOffice);       //获取报纸名称        public void getNewsPaper();   }   package cn.demo;public interface ISubscribe {\t//从邮局订阅报纸\tpublic void registered(PostOffice postOffice);\t//从邮局退订报纸\tpublic void unregistered(PostOffice postOffice);\t//获取报纸名称\tpublic void getNewsPaper();} 第三个方法非必须，前两个方法必须要有。（应修改为前两个非必须，第三个方法必须有） 然后有三个订阅者类： 张三： [java] view plaincopyprint? package cn.demo;      public class ZhangSan implements ISubscribe{       private String mName;       private String mNewsPaperName;              public ZhangSan(String mName, String mNewsPaperName) {           this.mName = mName;           this.mNewsPaperName = mNewsPaperName;       }              public String getName() {           return mName;       }          public String getNewsPaperName() {           return mNewsPaperName;       }              @Override       public void registered(PostOffice postOffice){           postOffice.registeredNewsPaper(this);       }              @Override       public void unregistered(PostOffice postOffice){           postOffice.unregisteredNewsPaper(this);       }          @Override       public void getNewsPaper() {           // TODO Auto-generated method stub           System.out.println(\"我是\"+getName()+\",我收到我订阅的\"+getNewsPaperName());       }      }   package cn.demo;public class ZhangSan implements ISubscribe{\tprivate String mName;\tprivate String mNewsPaperName;\t\tpublic ZhangSan(String mName, String mNewsPaperName) {\t\tthis.mName = mName;\t\tthis.mNewsPaperName = mNewsPaperName;\t}\t\tpublic String getName() {\t\treturn mName;\t}\tpublic String getNewsPaperName() {\t\treturn mNewsPaperName;\t}\t\t@Override\tpublic void registered(PostOffice postOffice){\t\tpostOffice.registeredNewsPaper(this);\t}\t\t@Override\tpublic void unregistered(PostOffice postOffice){\t\tpostOffice.unregisteredNewsPaper(this);\t}\t@Override\tpublic void getNewsPaper() {\t\t// TODO Auto-generated method stub\t\tSystem.out.println(\"我是\"+getName()+\",我收到我订阅的\"+getNewsPaperName());\t}} 李四： [java] view plaincopyprint? package cn.demo;      public class Lisi implements ISubscribe{       private String mName;       private String mNewsPaperName;              public Lisi(String mName, String mNewsPaperName) {           this.mName = mName;           this.mNewsPaperName = mNewsPaperName;       }              public String getName() {           return mName;       }          public String getNewsPaperName() {           return mNewsPaperName;       }              @Override       public void unregistered(PostOffice postOffice){           postOffice.unregisteredNewsPaper(this);       }              @Override       public void registered(PostOffice postOffice){           postOffice.registeredNewsPaper(this);       }          @Override       public void getNewsPaper() {           // TODO Auto-generated method stub           System.out.println(\"我是\"+getName()+\",我收到我订阅的\"+getNewsPaperName());       }      }   package cn.demo;public class Lisi implements ISubscribe{\tprivate String mName;\tprivate String mNewsPaperName;\t\tpublic Lisi(String mName, String mNewsPaperName) {\t\tthis.mName = mName;\t\tthis.mNewsPaperName = mNewsPaperName;\t}\t\tpublic String getName() {\t\treturn mName;\t}\tpublic String getNewsPaperName() {\t\treturn mNewsPaperName;\t}\t\t@Override\tpublic void unregistered(PostOffice postOffice){\t\tpostOffice.unregisteredNewsPaper(this);\t}\t\t@Override\tpublic void registered(PostOffice postOffice){\t\tpostOffice.registeredNewsPaper(this);\t}\t@Override\tpublic void getNewsPaper() {\t\t// TODO Auto-generated method stub\t\tSystem.out.println(\"我是\"+getName()+\",我收到我订阅的\"+getNewsPaperName());\t}} 王五： [java] view plaincopyprint? package cn.demo;      public class Wangwu implements ISubscribe{       private String mName;       private String mNewsPaperName;              public Wangwu(String mName, String mNewsPaperName) {           this.mName = mName;           this.mNewsPaperName = mNewsPaperName;       }              public String getName() {           return mName;       }          public String getNewsPaperName() {           return mNewsPaperName;       }              @Override       public void registered(PostOffice postOffice){           postOffice.registeredNewsPaper(this);       }              @Override       public void unregistered(PostOffice postOffice){           postOffice.unregisteredNewsPaper(this);       }             @Override       public void getNewsPaper() {           // TODO Auto-generated method stub           System.out.println(\"我是\"+getName()+\",我收到我订阅的\"+getNewsPaperName());       }      }   package cn.demo;public class Wangwu implements ISubscribe{\tprivate String mName;\tprivate String mNewsPaperName;\t\tpublic Wangwu(String mName, String mNewsPaperName) {\t\tthis.mName = mName;\t\tthis.mNewsPaperName = mNewsPaperName;\t}\t\tpublic String getName() {\t\treturn mName;\t}\tpublic String getNewsPaperName() {\t\treturn mNewsPaperName;\t}\t\t@Override\tpublic void registered(PostOffice postOffice){\t\tpostOffice.registeredNewsPaper(this);\t}\t\t@Override\tpublic void unregistered(PostOffice postOffice){\t\tpostOffice.unregisteredNewsPaper(this);\t}\t@Override\tpublic void getNewsPaper() {\t\t// TODO Auto-generated method stub\t\tSystem.out.println(\"我是\"+getName()+\",我收到我订阅的\"+getNewsPaperName());\t}} 三个订阅者，都有方法订阅报纸，或者取消订阅。其实关于订阅者的信息，是存储在邮局类里面。 邮局类：（邮局类应该继承一个抽象类或者接口（Subject），这里没有实现） [java] view plaincopyprint? import java.util.ArrayList;   import java.util.List;      public class PostOffice {       private List<ISubscribe> SubscribeList = new ArrayList<ISubscribe>();              public void registeredNewsPaper(ISubscribe subscribe) {           SubscribeList.add(subscribe);       }              public void unregisteredNewsPaper(ISubscribe subscribe) {           if (subscribe != null) {               SubscribeList.remove(subscribe);           }                  }              public void getNewsPaper(boolean bool) {           if (bool) {               sendNewsPaper();           }       }              public void sendNewsPaper() {           for(ISubscribe subscribe : SubscribeList) {               subscribe.getNewsPaper();           }       }   }   import java.util.ArrayList;import java.util.List;public class PostOffice {\tprivate List<ISubscribe> SubscribeList = new ArrayList<ISubscribe>();\t\tpublic void registeredNewsPaper(ISubscribe subscribe) {\t\tSubscribeList.add(subscribe);\t}\t\tpublic void unregisteredNewsPaper(ISubscribe subscribe) {\t\tif (subscribe != null) {\t\t\tSubscribeList.remove(subscribe);\t\t}\t\t\t}\t\tpublic void getNewsPaper(boolean bool) {\t\tif (bool) {\t\t\tsendNewsPaper();\t\t}\t}\t\tpublic void sendNewsPaper() {\t\tfor(ISubscribe subscribe : SubscribeList) {\t\t\tsubscribe.getNewsPaper();\t\t}\t}}在这个类里面，有变化通知是使用的sendNewsPaper()这个方法，遍历所有的订阅者。 测试类： [java] view plaincopyprint? public static void main(String[] args) {           // TODO Auto-generated method stub           PostOffice mPostOffice = new PostOffice();           ISubscribe zhangsan = new ZhangSan(\"张三\", \"《南方周末》\");           ISubscribe lisi = new Lisi(\"李四\", \"《新京报》\");           ISubscribe wangwu = new Wangwu(\"王五\", \"《南方都市报》\");                      //开始订阅报纸            zhangsan.registered(mPostOffice);           lisi.registered(mPostOffice);           wangwu.registered(mPostOffice);                      //邮局收到报纸，开始发放            mPostOffice.getNewsPaper(true);                      //李四退订            lisi.unregistered(mPostOffice);           //邮局收到报纸，开始发放            mPostOffice.getNewsPaper(true);       }   public static void main(String[] args) {\t\t// TODO Auto-generated method stub\t\tPostOffice mPostOffice = new PostOffice();\t\tISubscribe zhangsan = new ZhangSan(\"张三\", \"《南方周末》\");\t\tISubscribe lisi = new Lisi(\"李四\", \"《新京报》\");\t\tISubscribe wangwu = new Wangwu(\"王五\", \"《南方都市报》\");\t\t\t\t//开始订阅报纸\t\tzhangsan.registered(mPostOffice);\t\tlisi.registered(mPostOffice);\t\twangwu.registered(mPostOffice);\t\t\t\t//邮局收到报纸，开始发放\t\tmPostOffice.getNewsPaper(true);\t\t\t\t//李四退订\t\tlisi.unregistered(mPostOffice);\t\t//邮局收到报纸，开始发放\t\tmPostOffice.getNewsPaper(true);\t} 打印结果：      [html] view plaincopyprint? 我是张三,我收到我订阅的《南方周末》   我是李四,我收到我订阅的《新京报》   我是王五,我收到我订阅的《南方都市报》   我是张三,我收到我订阅的《南方周末》   我是王五,我收到我订阅的《南方都市报》   我是张三,我收到我订阅的《南方周末》我是李四,我收到我订阅的《新京报》我是王五,我收到我订阅的《南方都市报》我是张三,我收到我订阅的《南方周末》我是王五,我收到我订阅的《南方都市报》 这里只是提供了一个简单的例子，而且代码你会发现有冗余，三个订阅者类，几乎是一样，因为没有在类里面添加他们独自的属性，可以用一个Person类来替代。这里写这三个类是为了显示清晰。         关于五月18号的例子，观察者没必要有注册和取消注册的方法。他们的方法的实现也是调用的被观察者的注册和取消注册，不如直接使用被观察者的方法。          在Android中，button.setOnclickListener()这个方式是比较常见的观察者模式：当然，众所周知，onClick是著名的回调方法，在这里不会研究回调，不用太在意。 看下代码： [java] view plaincopyprint? Button button1 = (Button)findViewById(R.id.button1);           Button button2 = (Button)findViewById(R.id.button2);           Button button3 = (Button)findViewById(R.id.button3);           button1.setOnClickListener(this);           button2.setOnClickListener(this);           button3.setOnClickListener(this);       }          @Override       public void onClick(View v) {           // TODO Auto-generated method stub           switch(v.getId()) {           case R.id.button1 :   //          do some thing                   case R.id.button2 :   //          do some thing            case R.id.button3 :   //          do some thing            }       }   Button button1 = (Button)findViewById(R.id.button1);        Button button2 = (Button)findViewById(R.id.button2);        Button button3 = (Button)findViewById(R.id.button3);        button1.setOnClickListener(this);        button2.setOnClickListener(this);        button3.setOnClickListener(this);    }\t@Override\tpublic void onClick(View v) {\t\t// TODO Auto-generated method stub\t\tswitch(v.getId()) {\t\tcase R.id.button1 ://\t\t\tdo some thing\t\t\t\tcase R.id.button2 ://\t\t\tdo some thing\t\tcase R.id.button3 ://\t\t\tdo some thing\t\t}\t} 先button.setOnclickListener()进行注册。相当于邮局中的lisi.registered(mPostOffice)，此处错误，应该是第一例中的postOffice.registered(person)。onclick响应事件相当于邮局中的 [html] view plaincopyprint? public void sendNewsPaper() {           for(ISubscribe subscribe : SubscribeList) {               subscribe.getNewsPaper();           }       }   public void sendNewsPaper() {\t\tfor(ISubscribe subscribe : SubscribeList) {\t\t\tsubscribe.getNewsPaper();\t\t}\t} 这个中的subscribe.getNewsPaper()这个方法。View.onClickListener相当于邮局。View也就是button是我们的订阅者，也就相当于张三。我们也可以在getNewsPaper中加一些自己的switch判断。        最后，如果我们的邮局要实现类似button这样的回调这么实现呢？ [html] view plaincopyprint? ISubscribe isubscribe;          @Override       public void getNewsPaper() {           // TODO Auto-generated method stub           System.out.println(\"我是\"+getName()+\",我收到我订阅的\"+getNewsPaperName());           isubscribe.getNewsPaper();       }   ISubscribe isubscribe;\t@Override\tpublic void getNewsPaper() {\t\t// TODO Auto-generated method stub\t\tSystem.out.println(\"我是\"+getName()+\",我收到我订阅的\"+getNewsPaperName());\t\tisubscribe.getNewsPaper();\t} 在这里，弄的有点绕，其实可以另起一个接口。不知道是否能够明白，不明白欢迎留言探讨。谢谢，今天就到此，周末愉快！","title":"浅学设计模式之观察者<Observer>模式及在android中的应用 ."},{"content":"一、单一职责原则 面向对象编程的设计中的最小单位是类，单一原则就是说，一个类只给他一种功能，也就是一个类只实现一个业务功能，那么类也是业务设计上的最小单位。我们可以肯定，类将会只有一个引起它变化的原因——这个类的功能所涉及到的业务变更。如此这般，只有当某一项业务变更时，类才需要改动。 单一职责原则的目的就是让一个类改动的原因尽量单一，牵扯到的业务尽量细小，以减少耦合，便于代码的维护。 二、开放封闭原则 设计过程中，乃至设计完成，甚至设计完成后相当一段时间里，我们都会面临新的需求。所以，我们的设计必须要能在承受需求的改变时保持代码稳定。要保证代码稳定的绝对方法是不修改，要使软件能良好的承受需求的变化就必须修改，那么如何做才能解决这个矛盾呢？ 香港回归，一国两制就是很好的提示，我国社会主义制度不变，类似的，我们将已经写好的代码封闭，尽量不去修改；两种制度，就是增加一种制度，同样，我们允许代码的扩展，增加代码是被允许的。 这其中有一个问题，无论我们是多么地想“封闭”，一定存在一些无法封闭的变化，既然不可能完全封闭，那么我们就必须对无法封闭的变化隔离出来，防止它再次变化，这就是将原来的封闭的设计转变成可扩展的设计。所以，当我们最初设计时，这里不会发生变化，那么我们不用想太多，大可以封闭，但是当这里发生变化时，我们就必须创建抽象来隔离以后的同类变化。 总之，面对需求，面对代码的改动，最大化让它变成增加新代码，而不是更改现有的代码。这就是开放封闭原则的精髓。 三、依赖倒转原则 要保证开放封闭原则，就要求程序的模块和模块之间，功能和功能之间的耦合性尽量的低，也就是说，我只拿我需要的那部分，至于其它的部分我不关心，即使它们变化，只要我需要能满足我就行了。所以，模块之间不应该依赖具体，而应该依赖抽象。具体是指具体的类，抽象就是抽象类和接口。 四、里氏代换原则 这个原则很简单，子类继承父类，就必须拥有父类的所有功能。从某种特定情况中看起来，子类就是父类，父类能做的事，子类都可以做。它们不同的地方就只能是子类比父类的功能多。 五、迪米特法则 如果两个类，各自都能完成一个功能，他们就可以分开，现在有一功能需要他们俩共同完成，我们就不需要他们俩合成一个。迪米特法则，如果两个类不必要直接通讯，但是其中一个类需要调用另一个类的方法的时候，我们可以通过第三方来转发这个调用，减少类和类之间的依赖。 这个法则有一个缺点，代码中会出现大量的中介类，所以使用时一定要把握好度。","title":"面向对象编程设计原则"},{"content":"概念               在软件系统中，“行为请求者”与“行为实现者”通常呈现一种“紧耦合”。但在某些场合，比如要对行为进行“记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将“行为请求者”与“行为实现者”解耦？将一组行为抽象为对象，实现二者之间的松耦合。这就是命令模式（Command Pattern） 关系图： 看下命令模式是有哪些角色来组成的吧。              1)        命令角色（Command）：声明执行操作的接口。有java接口或者抽象类来实现。 2)        具体命令角色（Concrete Command）：将一个接收者对象绑定于一个动作；调用接收者相应的操作，以实现命令角色声明的执行操作的接口。 3)        客户角色（Client）：创建一个具体命令对象（并可以设定它的接收者）。 4)        请求者角色（Invoker）：调用命令对象执行这个请求。 5)        接收者角色（Receiver）：知道如何实施与执行一个请求相关的操作。任何类都可能作为一个接收者。      代码小例子         物联网是未来一个卖点之一，实现物联网以后，我们可以随便遥控家里电器的情况，在这里，设计一个遥控器，具有遥控电视和洗衣机的功能。当然，你也可以添加很多遥控其他电器的功能，如果要编写这么一个类，如何更好的实现解耦呢？命令模式是个不错的选择： 首先：先建立一个Command接口： [java] view plaincopy public interface ICommand {       //执行       void execute();       //撤销       void undo();   }   再者，得有电视和洗衣机，才可以遥控： [java] view plaincopy public class TV {       public void turnOnTV(){           System.out.println(\"打开电视\");       }              public void turnOffTV(){           System.out.println(\"关闭电视\");       }          }   [java] view plaincopy public class Washer {       public void turnOnWasher(){           System.out.println(\"打开洗衣机\");       }              public void turnOffWasher(){           System.out.println(\"关闭洗衣机\");       }          }         实现ConcreteCommand（具体的Command）： [java] view plaincopy public class TVCommand implements ICommand {       TV tv = null;       public TVCommand(TV tv){           this.tv = tv;       }          @Override       public void execute() {           // TODO Auto-generated method stub           tv.turnOnTV();       }          @Override       public void undo() {           // TODO Auto-generated method stub           tv.turnOffTV();       }      }   [java] view plaincopy public class WasherCommand implements ICommand{       Washer washer = null;       public WasherCommand(Washer washer){           this.washer=washer;       }       @Override       public void execute() {           // TODO Auto-generated method stub           washer.turnOnWasher();       }       @Override       public void undo() {           // TODO Auto-generated method stub           washer.turnOffWasher();       }   }   最后，实现遥控器类： [java] view plaincopy public class RemoteControl {       ICommand iCommand = null;              public void setCommand(ICommand iCommand){           this.iCommand = iCommand;       }              public void startCommand() {           iCommand.execute();       }              public void stopCommand(){           iCommand.undo();       }      }   看一下，遥控器只是把command传出去，而它丝毫不关心打开和关闭电器是如何实现的，就这样实现了解耦。 测试类： [java] view plaincopy public class CommandTest {          public static void main(String[] args) {           // TODO Auto-generated method stub           //先得到家电           TV tv = new TV();           Washer washer = new Washer();           //生成命令           TVCommand tvCommand = new TVCommand(tv);           WasherCommand washerCommand = new WasherCommand(washer);                      RemoteControl remoteControl = new RemoteControl();           //遥控器发出命令           remoteControl.setCommand(tvCommand);           remoteControl.startCommand();           remoteControl.stopCommand();           remoteControl.setCommand(washerCommand);           remoteControl.startCommand();           remoteControl.stopCommand();                  }      }   测试结果： 打开电视 关闭电视 打开洗衣机 关闭洗衣机 想想一下，往后，如果我们在遥控器想加入遥控电风扇、空调、冰箱等等功能是不是特别清晰。 模式优点 　　  1.降低系统的耦合度。 　　 2.新的命令可以很容易地加入到系统中。 　　         3.可以比较容易地设计一个组合命令。 模式缺点 　　  使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。 适用环境 　　1.系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。 　　       2.系统需要在不同的时间指定请求、将请求排队和执行请求。 　　       3.系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。 　　       4.系统需要将一组操作组合在一起，即支持宏命令。 概念               在软件系统中，“行为请求者”与“行为实现者”通常呈现一种“紧耦合”。但在某些场合，比如要对行为进行“记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将“行为请求者”与“行为实现者”解耦？将一组行为抽象为对象，实现二者之间的松耦合。这就是命令模式（Command Pattern） 关系图： 看下命令模式是有哪些角色来组成的吧。              1)        命令角色（Command）：声明执行操作的接口。有java接口或者抽象类来实现。 2)        具体命令角色（Concrete Command）：将一个接收者对象绑定于一个动作；调用接收者相应的操作，以实现命令角色声明的执行操作的接口。 3)        客户角色（Client）：创建一个具体命令对象（并可以设定它的接收者）。 4)        请求者角色（Invoker）：调用命令对象执行这个请求。 5)        接收者角色（Receiver）：知道如何实施与执行一个请求相关的操作。任何类都可能作为一个接收者。      代码小例子         物联网是未来一个卖点之一，实现物联网以后，我们可以随便遥控家里电器的情况，在这里，设计一个遥控器，具有遥控电视和洗衣机的功能。当然，你也可以添加很多遥控其他电器的功能，如果要编写这么一个类，如何更好的实现解耦呢？命令模式是个不错的选择： 首先：先建立一个Command接口： [java] view plaincopy public interface ICommand {       //执行       void execute();       //撤销       void undo();   }   再者，得有电视和洗衣机，才可以遥控： [java] view plaincopy public class TV {       public void turnOnTV(){           System.out.println(\"打开电视\");       }              public void turnOffTV(){           System.out.println(\"关闭电视\");       }          }   [java] view plaincopy public class Washer {       public void turnOnWasher(){           System.out.println(\"打开洗衣机\");       }              public void turnOffWasher(){           System.out.println(\"关闭洗衣机\");       }          }         实现ConcreteCommand（具体的Command）： [java] view plaincopy public class TVCommand implements ICommand {       TV tv = null;       public TVCommand(TV tv){           this.tv = tv;       }          @Override       public void execute() {           // TODO Auto-generated method stub           tv.turnOnTV();       }          @Override       public void undo() {           // TODO Auto-generated method stub           tv.turnOffTV();       }      }   [java] view plaincopy public class WasherCommand implements ICommand{       Washer washer = null;       public WasherCommand(Washer washer){           this.washer=washer;       }       @Override       public void execute() {           // TODO Auto-generated method stub           washer.turnOnWasher();       }       @Override       public void undo() {           // TODO Auto-generated method stub           washer.turnOffWasher();       }   }   最后，实现遥控器类： [java] view plaincopy public class RemoteControl {       ICommand iCommand = null;              public void setCommand(ICommand iCommand){           this.iCommand = iCommand;       }              public void startCommand() {           iCommand.execute();       }              public void stopCommand(){           iCommand.undo();       }      }   看一下，遥控器只是把command传出去，而它丝毫不关心打开和关闭电器是如何实现的，就这样实现了解耦。 测试类： [java] view plaincopy public class CommandTest {          public static void main(String[] args) {           // TODO Auto-generated method stub           //先得到家电           TV tv = new TV();           Washer washer = new Washer();           //生成命令           TVCommand tvCommand = new TVCommand(tv);           WasherCommand washerCommand = new WasherCommand(washer);                      RemoteControl remoteControl = new RemoteControl();           //遥控器发出命令           remoteControl.setCommand(tvCommand);           remoteControl.startCommand();           remoteControl.stopCommand();           remoteControl.setCommand(washerCommand);           remoteControl.startCommand();           remoteControl.stopCommand();                  }      }   测试结果： 打开电视 关闭电视 打开洗衣机 关闭洗衣机 想想一下，往后，如果我们在遥控器想加入遥控电风扇、空调、冰箱等等功能是不是特别清晰。 模式优点 　　  1.降低系统的耦合度。 　　 2.新的命令可以很容易地加入到系统中。 　　         3.可以比较容易地设计一个组合命令。 模式缺点 　　  使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。 适用环境 　　1.系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。 　　       2.系统需要在不同的时间指定请求、将请求排队和执行请求。 　　       3.系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。 　　       4.系统需要将一组操作组合在一起，即支持宏命令。","title":"浅学设计模式之命令<command>模式"},{"content":"关于单例模式，可能是23种模式里面最容易理解的一种模式了，这篇文章里主要是整理了一下从网上搜集的材料，文字部分大部分直接从网上拷贝而来。中间有部分自己的理解。                   单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。             实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。          单例模式适合于一个类只有一个实例的情况，比如窗口管理器，打印缓冲池和文件系统，它们都是原型的例子。典型的情况是，那些对象的类型被遍及一个软件系统的不同对象访问，因此需要一个全局的访问指针，这便是众所周知的单例模式的应用。当然这只有在你确信你不再需要任何多于一个的实例的情况下。       尽管单例设计模式如在下面的图中的所显示的一样是最简单的设计模式，但对于粗心的Java开发者来说却呈现出许多缺陷。         在《设计模式》一书中，作者这样来叙述单例模式的：确保一个类只有一个实例并提供一个对它的全局访问指针。 下图说明了单例模式的类图。 单例模式的类图        正如你在上图中所看到的，这不是单例模式的完整部分。此图中单例类保持了一个对唯一的单例实例的静态引用，并且会从静态getInstance()方法中返回对那个实例的引用。           很多人都会写的一种单例类型： [java] view plaincopyprint? public class Singleton {       private static Singleton <SPAN style=\"FONT-SIZE: 16px\">INSTANCE<\/SPAN> = null;       private Singleton(){                  }       public static Singleton getInstance(){           if(singleton == null){               <SPAN style=\"FONT-SIZE: 16px\">INSTANCE<\/SPAN> = new Singleton();           }           return <SPAN style=\"FONT-SIZE: 16px\">INSTANCE<\/SPAN>;       }          }   public class Singleton {\tprivate static Singleton INSTANCE = null;\tprivate Singleton(){\t\t\t}\tpublic static Singleton getInstance(){\t\tif(singleton == null){\t\t\tINSTANCE = new Singleton();\t\t}\t\treturn INSTANCE;\t}\t}          但是这种单例类型在多线程中是不安全。有可能会出现两个INSTANCE.为什么呢？         如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。  懒汉式单例模式： [java] view plaincopyprint? public class Singleton {       private static Singleton INSTANCE = null;           // Private constructor suppresses         // default public constructor        private Singleton() {}           //thread safe and performance  promote         public static  Singleton getInstance() {           if(INSTANCE == null){                synchronized(Singleton.class){                    //if 2 or more thread go  into first null check at same time , it will be instance more then once.so we must check it again.                     if(INSTANCE == null){                         INSTANCE = new Singleton();                     }                 }            }           return INSTANCE;       }     }   public class Singleton {    private static Singleton INSTANCE = null;     // Private constructor suppresses     // default public constructor    private Singleton() {}     //thread safe and performance  promote     public static  Singleton getInstance() {        if(INSTANCE == null){             synchronized(Singleton.class){                 //if 2 or more thread go  into first null check at same time , it will be instance more then once.so we must check it again.                 if(INSTANCE == null){                      INSTANCE = new Singleton();                  }              }         }        return INSTANCE;    }  }         还有另外一个方法（也被称为饿汉式单例模式）： [java] view plaincopyprint? public class Singleton {     private final static Singleton INSTANCE = new Singleton();        // Private constructor suppresses         private Singleton() {}        // default public constructor      public static Singleton getInstance() {         return INSTANCE;     }   }     public class Singleton {    private final static Singleton INSTANCE = new Singleton();     // Private constructor suppresses       private Singleton() {}     // default public constructor    public static Singleton getInstance() {        return INSTANCE;    }  }         这样写就会避免出现两个INSTANCE了。 比较： 饿汉式是线程安全的,在类创建的同时就已经创建好一个静态的对象供系统使用,以后不在改变。 懒汉式适合单线程，多线程情况下如果在创建实例对象时不加上synchronized则会导致对对象的访问不是线程安全的。 从实现方式来讲他们最大的区别就是懒汉式是延时加载,  他是在需要的时候才创建对象,而饿汉式在加载类时创建实例。  饿汉式无需关注多线程问题、写法简单明了、能用则用。但是它是加载类时创建实例（上面有个朋友写错了）、所以如果是一个工厂模式、缓存了很多实例、那么就得考虑效率问题，因为这个类一加载则把所有实例不管用不用一块创建。 懒汉式的优点是延时加载、缺点是应该用同步。","title":"浅学设计模式之单例<singleton>模式 ."},{"content":"参考书籍 1.      GＯＦ设计模式。    《Design Patterns: Elements of Reusable Object-Oriented Software》，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-     Wesley，1995）。这几位作者常被称为\"四人组（Gang of Four）\"。 2.       Head First Design Patterns  第一本比较学术性，第二本比较通俗易懂。随后会上传相关资料。 不要为了模式而模式，在实际的工作中要合适的使用。","title":"设计模式参考书籍"},{"content":"创建型模式 工厂方法（Factory Method） 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节。工厂方法模式的核心是一个抽象工厂类，各种具体工厂类通过抽象工厂类将工厂方法继承下来。如此使得客户可以只关心抽象产品和抽象工厂，完全不用理会返回的是哪一种具体产品，也不用关系它是如何被具体工厂创建的。 抽象工厂模式（Abstract Factory） 抽象工厂模式的主要优点是隔离了具体类的生成，使得客户不需要知道什么被创建了。犹豫这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变这个软件的系统的行为。另外，应用抽象工厂模式符合GRASP纯虚构的模式，可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛应用。 建造者模式（Builder Pattern） 建造者模式将一个复杂对象的生成责任作了很好的分配。它把构造过程放在指挥者的方法中，把装配过程放到具体建造者类中。建造者模式的产品之间都有共通点，但有时候，产品之间的差异性很大，这就需要借助工厂方法模式或抽象工厂模式。另外，如果产品的内部变化复杂，Builder的每一个子类都需要对应到不同的产品去做构建的动作、方法，这就需要定义很多个具体建造类来实现这种变化。 单件模式（Single Pattern） Singleton单例模式为一个面向对象的应用程序提供了对象唯一的访问点，不管它实现何种功能，此种模式都为设计及开发团队提供了共享的概念。然而，Singleton对象类派生子类就有很大的困难，只有在父类没有被实例化时才可以实现。值得注意的是，有些对象不可以做成Singleton，比如.net的数据库链接对象(Connection)，整个应用程序同享一个Connection对象会出现连接池溢出错误。另外，.net提供了自动废物回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是废物，自动消灭它并回收它的资源，下次利用时又会重新实例化，这种情况下应注意其状态的丢失。 原型模式（Protype Pattern） 原型模式得到了广泛的应用，特别是在创建对象成本较大的情况下(初始化需占用较长时间，占用太多CPU资源或网络资源。比如通过Webservice或DCOM创建对象，或者创建对象要装载大文件)，系统如果需要重复利用，新的对象可以通过原型模式对已有对象的属性进行复制并稍作修改来取得。另外，如果系统要保存对象的状态而对象的状态变化很小，或者对象本身占内存不大的时候，也可以用原型模式配合备忘录模式来应用。相反地，如果对象的状态变化很大，或者对象占用内存很大，那么采用状态模式会比原型模式更好。原型模式的缺点是在实现深层复制时需要编写复杂的代码。 结构型模式 适配器模式（Adapter Pattern） 适配器模式可以将一个类的接口和另一个类的接口匹配起来，使用的前提是你不能或不想修改原来的适配器母接口(adaptee)。例如，你向第三方购买了一些类、控件，但是没有源程序，这时，使用适配器模式，你可以统一对象访问接口。但客户调用可能需要变动。 桥接模式（Bridge Pattern） 桥接模式可以从接口中分离实现功能，使得设计更具扩展性，这样，客户调用方法时根本不需要知道实现的细节。 桥接模式减少了子类，假设程序要在2个操作系统中处理6种图像格式，纯粹的继承就需要(2*6)12个子类，而应用桥接模式，只需要(2+6)8个子类。它使得代码更清洁，生成的执行程序文件更小。　　 桥接模式的缺陷是抽象类与实现类的双向连接使得运行速度减慢。 组合模式（Composite Pattern） 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，使得增加新部件也更容易，因为它让客户忽略了层次的不同性，而它的结构又是动态的，提供了对象管理的灵活接口。组合模式对于树结构的控制有着神奇的功效，例如在人力资源系统的组织架构及ERP系统的BOM设计中，组合模式得到重点应用。 组合模式的缺陷是使得设计变得更加抽象。对象的商业规则如果很复杂，则实现组合模式具有很大挑战性，并且，不是所有的方法都与叶部件子类有关联。 装饰模式（Decorator Pattern） 装饰模式提供了比静态继承更好的柔韧性，它允许开发一系列的功能类用来代替增加对象的行为，这既不会污染原来对象的源码，还能使代码更容易编写，使类更具扩展性，因为变化都是由新的装饰类来完成。还可以建立连接的装饰对象关系链。 需要注意的是，装饰链不宜过长。装饰链太长会使系统花费较长时间用于初始化对象，同时信息在链中的传递也会浪费太多的时间。这个情况好比物品包装，包了一层又一层，大包套小包。另外，如果原来的对象接口发生变化，它所以的装饰类都要修改以匹配它的变化。派生子类会影响对象的内部，而一个Decorator只会影响对象的外表。 外观模式（Fa&ccedil;ade Pattern） 外观模式提供了一个简单且公用的接口去处理复杂的子系统，并且没有减少子系统的功能。它遮蔽了子系统的复杂性，避免了客户与子系统直接链接，它也减少了子系统与子系统间的连接，每个子系统都有它的Facade模式，每个子系统采用Facade模式去访问其他子系统。外观模式的劣势就是限制了客户的自由，减少了可变性。 享元模式（Flyweight Pattern） Flyweight模式需要你认真考虑如何能细化对象，以减少处理的对象数量，从而减少存留对象在内存或其他存储设备中的占用量。然而，此模式需要维护大量对象的外部状态，如果外部状态的数据量大，传递、查找、计算这些恶数据会变得非常复杂。当外部和内部的状态很难分清时，不宜采用flyweight模式。 代理模式（Proxy Pattern） 当对象在远程机器上，要通过网络来生成时，速度可能会慢，此时应用Remote Proxy模式，可以掩蔽对象由网络生成的过程，系统的速度会加快；对于大图片的加载，Virtual Proxy模式可以让加载在后台进行，前台用的Proxy对象使得整体运行速度得到优化；Protect Proxy可以验证对真实对象的引用权限。 代理模式的缺陷是请求的处理速度会变慢，并且实现Proxy模式需要额外的工作。 行为型模式 职责链模式（Chain of Responsibility） 责任链模式可以减少对象的连接，为对象责任分配增加了很大的灵活性。该模式允许把一组类作为一个类来使用，并且在类的组合中，一个类的事件可以发送到另一个类并由其处理。 责任链模式通常应用与图形用户界面中，窗体的部件可能会包含其他几个小部件，就如同Windows窗体应用程序中，控件中又可以放置其他控件，控件边界会决定是否处理事件，或者将事件传递给父控件来处理。 另外，责任链还会以树状出现，这样，一个事件可以传给多个类，或者，多个类的信息可以提交到一个类。树状责任链能够提供更灵活的技巧，但缺点是信息在树中容易迷失。 命令模式（Command Pattern） 命令模式分离了接受请求的对象与实现处理请求工作的对象，这样，已经存在的类可以保持不变，使得增加新类的工作更简单。例如，很多软件的宏命令就提高了系统的自动化程度。 命令模式还可以分离用户界面和业务对象，降低系统的耦合度。 但是，命令模式最主要的缺陷就是，类的数量增加了，系统变得更复杂，程序的调试工作也相应变得困难。 解释器模式（Interpreter Pattern） 解释器模式的作用很强大，它使得改变和扩展文法变得容易，实现文法也变得简单明了，很多编译器，包括文本编辑器、网页浏览器及VRML都应用解释器模式。 解释器模式的缺陷就是，因为文句会分析成树结构，解释器需要递归访问它，所以效率会受影响。这种情况开发人员会有所体会，编译整个工程源码耗费时间都比较长。 模版方法模式（Template Method） 模版方法模式在一个类中形式化地定义算法，而由它的子类实现细节的处理。模版方法模式的优势是，在子类定义处理算法时不会改变算法的结构。 模版方法的特点在于，每个不同的实现都需要定义一个子类，这也复合高内聚的责任分配模式，不能说成是它的缺点。 迭代器模式（Iterator Pattern） 迭代器模式支持在聚集中移动游标，使得访问聚合中的元素变得简单，简化了聚集的接口，封装了聚合的对象。 迭代器模式还可以应用于对树结构的访问，程序不需要从头逐行代码查找相应位置，可控制到从子集开始查找，对于加快程序的运行速度有很重要的作用。 迭代器模式的缺点是聚合密切相关，增加了耦合。但将这种耦合定义在抽象基类，可解决这个问题。 观察者模式（Oberver Pattern） 观察者模式抽象了被观察对象与观察者对象的连接，提供了广播式的对象间通信，并且容易增加新的观察者对象。观察者模式的缺陷是对象间的关系难以理解，在某种情况下会表现低效能。 中介者模式（Mediator Pattern） 中介者模式分离了两个同事类，简化了对象协议，中央控制对象交互，从而使个体对象变得更容易且更简单，因为它不需要传递数据给其他个体对象，仅仅传给中介者就可以了。个体对象不需要具有处理内部交流的逻辑，所以更加突出它的面向对象特性。 备忘录模式（Memento Pattern） Memento模式保存了封装的边界，一个Memento对象是另一种原发器对象的表示，不会被其他代码改动。这种模式简化了原发器对象，Memento只保存原发器的状态。采用堆栈备忘对象，可以实现多次取消操作。 状态模式（State Pattern） 状态模式在对象内保存特定的状态并且就不同的状态履行不同的行为，它使状态的变化显得清晰明了，也很容易创建对象的新状态。 状态模式在工作流或游戏等各种系统中大量使用，例如在政府OA系统中，一个批文的状态有多种：未办、正在处理、正在批示、正在审核和已经完成等各种状态。在网络游戏中，一个游戏活动存在开始、开玩、正在玩、输赢等各种状态。使用状态模式就可以实现游戏状态的总控，而游戏状态决定了游戏的各个方面。 策略模式（Strategy Pattern） 策略模式提供了替代派生的子类，并定义类的每个行为，剔除了代码中条件的判断语句，使得扩展和结合新的行为变得更容易，根本不需要变动应用程序。策略模式可以避免使用多重条件转移语句，系统变得更新灵活。应用策略模式会产生很多子类，这符合高内聚的责任分配模式。 访问者模式（Visitor Pattern） Visitor(访问者)模式使得增加新的操作变得容易，它可以收集有关联的方法，而分离没有关联的方法，特别适用于分离因为不同原因而变化的事物，如“在男人中分离出男孩”。但Visitor模式常常要打破对象的封装性，visitor与element需要达成某些共识。","title":"C# WP7 23种设计模式汇总"},{"content":"      抽象工厂模式：提供一个创建一个一系列相关或互相依赖对象的接口，而无需指定他们具体的类。(针对的是一个系列) 类图：   代码： 产品类： publicclass AbstractProductA  {} publicclass ProductA1 extends AbstractProductA {} publicclass ProductA2 extends AbstractProductA{} publicclass AbstractProductB {} publicclass ProductB1 extends AbstractProductB {} publicclass ProductB2 extends AbstractProductB {} 工厂类： publicinterface IFactory {     AbstractProductA CreateProductA();     AbstractProductB CreateProductB(); } publicclass ConcreteFactory1 implements IFactory {     @Override     public AbstractProductA CreateProductA() {        returnnew ProductA1();     }     @Override     public AbstractProductB CreateProductB() {        returnnew ProductB1();     } } publicclass ConcreteFactory2 implements IFactory {     @Override     public AbstractProductA CreateProductA() {        returnnew ProductA2();     }     @Override     public AbstractProductB CreateProductB() {        returnnew ProductB2();     } } 优点：可以解决表格型结构对象的创建。如下图： 缺点：抽象工厂结构比较复杂，而且增加一个功能(功能C)就要修改所有的工厂类。 工厂的比较：3个工厂比较像是一个进化的过程！简单工厂针对于单个对象，工厂方法针对抽象对象，而抽象工厂针对的是一个系列的抽象对象。个人感觉抽象工厂其实是相对完善的（完善=复杂）。不是每一个程序都选择完善，而是选择简单。","title":"抽象工厂"},{"content":"桥接模式的本质：分离抽象与实现。 桥接模式的优点： ●分离抽象与实现部分 这样极大地提高了系统的灵活性。让抽象与实现部分独立开来，分别定义自己的接口，这有助于对系统进行分层，从而产生更好的结构 化的系统。对于系统的高级部分，只需要知道抽象部分和实现部分的接口就可以了。 ●更好的扩展性 由于把抽象部分和实现部分开了，而且分别定义了接口，这就使得抽象部分和实现部分可以分别独立地扩展，而不会相互影响，从而大 大地提高了系统的扩展性。 ●可动态地切换实现 由于把抽象部分和实现部分开了，所以实现桥接的时候，就可以实现动态的选择和使用具体的实现。也就是说一个实现不再是固定地绑 定在一个抽象接口上，可以实现运行期间动态切换。 ●可以减少子类的个数 对于有两个变化维度的情况，如果采用继承的实现方式，大约需要两个维度上的可变化数量的乘积个子类；采用桥接模式来实现，大约 需要两个维度上的可变化数量的和个子类。可以明显减少子类的个数。 桥接模式还很好地体现了：多用对象组合，少用对象继承。采用对象组合，松散了对象之间的耦合。 桥接模式的结构与说明 ● Abstraction：抽象部分得到接口。通常在这个对象中，要维护一个实现部分的对象引用，抽象对象里面的方法，需要调用实现部分来完 成。这个对象中的方法，通常都是和具体的业务相关的方法。 ●RefinedAbstraction：扩展抽象部分的接口。通常在这些对象中，定义跟实际业务相关的方法，这些方法的实现通常会使用Abstraction中 定义的方法，也可能需要调用实现部分的对象来完成。 ● Implementor：定义实现部分的接口。这个接口不用和Abstraction中的方法一致，通常是由Implementor接口提供基本的操作。而 Abstraction中定义的是基于这些基本操作的业务方法，也就是说Abstraction定义了基于这些基本操作的业务方法，也就是说Abstractiond 定义了基于这些基本操作的较高层次的操作。 ●ConcreteImplementor：真正实现Implementor接口的对象。 样例 /** * 定义实现部分的接口,实现发送消息的统一接口 * */ public interface MessageImplementor{ /** * 发送消息 * @param message * @param toUser */ publicvoid send(String message, String toUser); } /** * 使用短消息方式发送消息 * */ public class MessageSMS implements MessageImplementor { @Override public void send(String message, String toUser) { System.out.println(\"使用短消息发送消息：\" + message + \" 给 \" + toUser); } } /** * 以E-Mail方式发送 * */ public class MessageEmail implements MessageImplementor { @Override publicvoid send(String message, String toUser) { System.out.println(\"使用E-Mail发送消息：\" + message +\" 给 \" + toUser); } } /** * 以手机发送消息 * */ public class MessageMobile implements MessageImplementor { @Override publicvoid send(String message, String toUser) { System.out.println(\"使用手机发送消息：\" + message + \" 给 \" + toUser); } } /** * 抽象的消息对象 * */ public abstract class AbstractMessage{ /** * 持有一个实现部分的对象 */ protected MessageImplementor impl; publicAbstractMessage(MessageImplementor impl) { this.impl = impl; } public void sendMessage(String message, StringtoUser) { this.impl.send(message,toUser); } } /** * 普通消息 * */ public class CommonMessage extends AbstractMessage { publicCommonMessage(MessageImplementor impl) { super(impl); } @Override public void sendMessage(String message, StringtoUser) { super.sendMessage(message,toUser); } } /** * 紧急消息 * */ public class UrgencyMessage extends AbstractMessage { publicUrgencyMessage(MessageImplementor impl) { super(impl); } @Override public void sendMessage(String message,String toUser) { message = \"加急：\" + message; super.sendMessage(message,toUser); } /** * 扩展功能：监视消息的处理对象 * @param messageId * @return */ publicObject watch(String messageId) { return null; } } public class SpecialUrgencyMessage extends AbstractMessage { publicSpecialUrgencyMessage(MessageImplementor impl) { super(impl); } @Override publicvoid sendMessage(String message, String toUser) { message = \"特急：\" + message; super.sendMessage(message,toUser); } public void hurry(String messageId){ //执行催促的任务，发出催促的信息 } } public class Client { public static void main(String[] args) { //使用短信发方式 MessageImplementor impl = new MessageSMS(); AbstractMessage m = new CommonMessage(impl); m.sendMessage(\"请喝一杯茶\",\"Henry\"); m = new UrgencyMessage(impl); m.sendMessage(\"请喝一杯茶\",\"Henry\"); m = new SpecialUrgencyMessage(impl); m.sendMessage(\"请喝一杯茶\",\"Henry\"); //使用手机方式 impl = new MessageMobile(); m = new CommonMessage(impl); m.sendMessage(\"请喝一杯茶\",\"Henry\"); m = new UrgencyMessage(impl); m.sendMessage(\"请喝一杯茶\",\"Henry\"); m = new SpecialUrgencyMessage(impl); m.sendMessage(\"请喝一杯茶\",\"Henry\"); } }","title":"Java 设计模式之桥接模式"},{"content":"一、单态模式的定义 Singleton模式要求一个类有且仅有一个实例，并且提供一个全局的访问点。 二、使用Singleton注意事项： 有时在某些情况下，使用Singleton并不能达到Singleton的目的，如有多个Singleton对象同时被不同的类装入器装载；在EJB（Enterprise Java Beans）这样的分布式系统中使用也要注意这种情况，因为EJB是跨服务器，跨JVM的 （我们以SUN公司的宠物店源码(Pet Store 1.3.1)的ServiceLocator为例稍微分析一下： 在Pet Store中ServiceLocator有两种，一个是EJB目录下；一个是WEB目录下，我们检查这两个ServiceLocator会发现内容差不多，都是提供EJB的查询定位服务，可是为什么要分开呢？仔细研究对这两种ServiceLocator才发现区别：在WEB中的ServiceLocator的采取Singleton模式，ServiceLocator属于资源定位，理所当然应该使用Singleton模式。但是在EJB中，Singleton模式已经失去作用，所以ServiceLocator才分成两种，一种面向WEB服务的，一种是面向EJB服务的。 ） 三、使用单态模式的优点： 1.控制资源的使用，通过线程同步来控制资源的并发访问； 2.控制实例产生的数量，节省内存，有利于垃圾回收。 3.作为通信媒介使用，也就是数据共享，它可以在不建立直接关联的条件下，让多个不相关的两个线程或者进程之间实现通信。 比 如，数据库连接池的设计一般采用单例模式，数据库连接是一种数据库资源。软件系统中使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗，这种效率上的损耗还是非常昂贵的。当然，使用数据库连接池还有很多其它的好处，可以屏蔽不同数据数据库之间的差异，实现系统对数据库的低度耦合，也可 以被多个系统同时使用，具有高可复用性，还能方便对数据库连接的管理等等。数据库连接池属于重量级资源，一个应用中只需要保留一份即可，既节省了资源又方便管理。所以数据库连接池采用单例模式进行设计会是一个非常好的选择。 四、生活中的例子： 1.每台计算机可以有若干个打印机，如果每一个进程或者线程都独立地使用打印机资源的话，那么我们打印出来的结果就有可能既包含这个打印任务的一部分，又包含另外一个打印任务的一部分。所以，大多数的操作系统最终为打印任务设计了一个单例模式的假脱机服务Printer Spooler，所有的打印任务都需要通过假脱机服务进行。 2.在我们日常使用的在Windows中也有不少单例模式设计的组件，象常用的文件管理器。由于Windows操作系统是一个典型的多进程多线程系统，那么在创建或者删除某个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象。采用单例模式设计的文件管理器就可以完美的解决这个问题，所有的文件操作都必须通过唯一的实例进行，这样就不会产生混乱的现象。 五、2种实现： 实现原理：首先必须将类的构造方法的访问权限设为private，这样就不能用new操作符在类的外部产生该类的对象实例了。其次在类的内部产生一个静态的对象，再产生该类的静态方法返回内部创建的对象实例以便外部来访问这个唯一的对象实例。（外部要访问唯一对象，只有内部来创建，需定义一个方法来返回对象，而且必须是静态的，静态的方法只能访问静态变量，所以定义的对象变量也必须是静态的。） 1.第一种形式: Java代码 1.public classSingleton { 2.　　private Singleton(){} 3.　　//注意这个实例是private的， 只供内部调用 4.　　private staticSingleton instance = new Singleton(); 5.　　//这里提供了一个供外部访问本class的静态方法，可以直接访问　　 6.　　public staticSingleton getInstance() { 7.　　　　return instance; 　　 8.　　 } 9.} public class Singleton { 　　private Singleton(){} 　　//注意这个实例是private的， 只供内部调用 　　private static Singletoninstance = new Singleton(); 　　//这里提供了一个供外部访问本class的静态方法，可以直接访问　　 　　public static SingletongetInstance() { 　　　　return instance; 　　 　　 } } 2.第二种形式: Java代码 1.public classSingleton { 2.　　private staticSingleton instance = null; 3.　　public staticsynchronized Singleton getInstance() { 4.　　//这个方法比上面有所改进，不用每次都进行生成对象，只是第一次　　　　 5.　　//使用时生成实例，提高了效率！ 6.　　if (instance==null) 7.　　　　instance＝new Singleton(); 8.　　return instance; 　　} 9.} public class Singleton { 　　private static Singletoninstance = null; 　　public staticsynchronized Singleton getInstance() { 　　//这个方法比上面有所改进，不用每次都进行生成对象，只是第一次　　　　 　　//使用时生成实例，提高了效率！ 　　if (instance==null) 　　　　instance＝new Singleton(); 　　return instance; 　　} } 使用Singleton.getInstance()可以访问单态类。 第二种形式是lazy initialization，也就是说第一次调用时初始Singleton，以后就不用再生成了。 注意到lazy initialization形式中的synchronized（线程同步），这个synchronized很重要，如果没有synchronized，那么使用getInstance()是有可能得到多个Singleton实例。在一个多线程的程序中，如果同步的消耗是很大的，很容易造成瓶颈。 一般认为第一种形式要更加安全些。 一、单态模式的定义 Singleton模式要求一个类有且仅有一个实例，并且提供一个全局的访问点。 二、使用Singleton注意事项： 有时在某些情况下，使用Singleton并不能达到Singleton的目的，如有多个Singleton对象同时被不同的类装入器装载；在EJB（Enterprise Java Beans）这样的分布式系统中使用也要注意这种情况，因为EJB是跨服务器，跨JVM的 （我们以SUN公司的宠物店源码(Pet Store 1.3.1)的ServiceLocator为例稍微分析一下： 在Pet Store中ServiceLocator有两种，一个是EJB目录下；一个是WEB目录下，我们检查这两个ServiceLocator会发现内容差不多，都是提供EJB的查询定位服务，可是为什么要分开呢？仔细研究对这两种ServiceLocator才发现区别：在WEB中的ServiceLocator的采取Singleton模式，ServiceLocator属于资源定位，理所当然应该使用Singleton模式。但是在EJB中，Singleton模式已经失去作用，所以ServiceLocator才分成两种，一种面向WEB服务的，一种是面向EJB服务的。 ） 三、使用单态模式的优点： 1.控制资源的使用，通过线程同步来控制资源的并发访问； 2.控制实例产生的数量，节省内存，有利于垃圾回收。 3.作为通信媒介使用，也就是数据共享，它可以在不建立直接关联的条件下，让多个不相关的两个线程或者进程之间实现通信。 比 如，数据库连接池的设计一般采用单例模式，数据库连接是一种数据库资源。软件系统中使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗，这种效率上的损耗还是非常昂贵的。当然，使用数据库连接池还有很多其它的好处，可以屏蔽不同数据数据库之间的差异，实现系统对数据库的低度耦合，也可 以被多个系统同时使用，具有高可复用性，还能方便对数据库连接的管理等等。数据库连接池属于重量级资源，一个应用中只需要保留一份即可，既节省了资源又方便管理。所以数据库连接池采用单例模式进行设计会是一个非常好的选择。 四、生活中的例子： 1.每台计算机可以有若干个打印机，如果每一个进程或者线程都独立地使用打印机资源的话，那么我们打印出来的结果就有可能既包含这个打印任务的一部分，又包含另外一个打印任务的一部分。所以，大多数的操作系统最终为打印任务设计了一个单例模式的假脱机服务Printer Spooler，所有的打印任务都需要通过假脱机服务进行。 2.在我们日常使用的在Windows中也有不少单例模式设计的组件，象常用的文件管理器。由于Windows操作系统是一个典型的多进程多线程系统，那么在创建或者删除某个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象。采用单例模式设计的文件管理器就可以完美的解决这个问题，所有的文件操作都必须通过唯一的实例进行，这样就不会产生混乱的现象。 五、2种实现： 实现原理：首先必须将类的构造方法的访问权限设为private，这样就不能用new操作符在类的外部产生该类的对象实例了。其次在类的内部产生一个静态的对象，再产生该类的静态方法返回内部创建的对象实例以便外部来访问这个唯一的对象实例。（外部要访问唯一对象，只有内部来创建，需定义一个方法来返回对象，而且必须是静态的，静态的方法只能访问静态变量，所以定义的对象变量也必须是静态的。） 1.第一种形式: Java代码 1.public classSingleton { 2.　　private Singleton(){} 3.　　//注意这个实例是private的， 只供内部调用 4.　　private staticSingleton instance = new Singleton(); 5.　　//这里提供了一个供外部访问本class的静态方法，可以直接访问　　 6.　　public staticSingleton getInstance() { 7.　　　　return instance; 　　 8.　　 } 9.} public class Singleton { 　　private Singleton(){} 　　//注意这个实例是private的， 只供内部调用 　　private static Singletoninstance = new Singleton(); 　　//这里提供了一个供外部访问本class的静态方法，可以直接访问　　 　　public static SingletongetInstance() { 　　　　return instance; 　　 　　 } } 2.第二种形式: Java代码 1.public classSingleton { 2.　　private staticSingleton instance = null; 3.　　public staticsynchronized Singleton getInstance() { 4.　　//这个方法比上面有所改进，不用每次都进行生成对象，只是第一次　　　　 5.　　//使用时生成实例，提高了效率！ 6.　　if (instance==null) 7.　　　　instance＝new Singleton(); 8.　　return instance; 　　} 9.} public class Singleton { 　　private static Singletoninstance = null; 　　public staticsynchronized Singleton getInstance() { 　　//这个方法比上面有所改进，不用每次都进行生成对象，只是第一次　　　　 　　//使用时生成实例，提高了效率！ 　　if (instance==null) 　　　　instance＝new Singleton(); 　　return instance; 　　} } 使用Singleton.getInstance()可以访问单态类。 第二种形式是lazy initialization，也就是说第一次调用时初始Singleton，以后就不用再生成了。 注意到lazy initialization形式中的synchronized（线程同步），这个synchronized很重要，如果没有synchronized，那么使用getInstance()是有可能得到多个Singleton实例。在一个多线程的程序中，如果同步的消耗是很大的，很容易造成瓶颈。 一般认为第一种形式要更加安全些。","title":"JAVA设计模式之单态模式 （创建模式）"},{"content":" Java阵营一直倡导开源，开源运动如火如荼展开，催生了无数组件。但是，坦率的讲，这些开源的组件中，能够直接拿过来，不做任何改造，就能用于商业软件构建，满足功能和性能的要求，这样的优秀组件不多见。因此，核心软件开发者时常面对的尴尬局面是：大量的开源资源，都不满足我的要求。     实际上，组件设计是软件设计开发最精髓所在，凝聚了数据结构、面向对象、设计模式、线程并发同步、操作系统等诸多领域的最核心技术，一直是设计开发领域彰显技术水准的最高领地。     一个组件，要想被广泛重用，满足不同系统的使用要求，就要求组件有足够的能力适应不同的应用场合，提供满足需要的功能，并表现出优秀的性能。因此，组件设计过程中，组件设计者要考虑的问题非常广泛而复杂，组件设计者需要具备的知识、技能和经验要求非常高，一般工作经验至少在5年以上才有可能涉足组件设计这个领域。这也就解释了，为什么优秀组件不多的原因了。     接下来将对目前业界存在的诸多技术争论、误区进行澄清，让读者从所谓的“业界潮流”、教条、“黄金定律”中走出来，真正理解组件设计过程的核心原则。这些核心原则如下： 原则一、精准解决共性问题 原则二、无配置文件 原则三、与使用者概念一致 原则四、业务无关的中立性 原则五、对使用环境无依赖 原则六：单类设计和实现","title":"JAVA组件设计原则(一)概述(摘自《java组件设计》)"},{"content":"本文是由敏捷宣言签署人之一、《 Clean Code(代码整洁之道)》一书的作者Robert C. Martin为他的《Applying Principles and Patterns》这本书搜集整理而来。 单一责任原则(SRP) 只有一个理由去修改一个类。例如，如果一个业务规则的改变会导致这个类的修改，那么，数据库、界面、报表格式或系统任何其它的部分的改变都不该迫使这个类做修改。 http://davidhayden.com/blog/dave/archive/2005/05/29/1066.aspx http://c2.com/cgi/wiki?SingleResponsibilityPrinciple 《Head First 设计模式》 第 185, 336, 339, 367 页 http://msdn.microsoft.com/en-us/magazine/cc546578.aspx http://codebetter.com/blogs/david_laribee/archive/2008/09/09/why-solid-gimme-an-s.aspx 开发/关闭原则(OCP) 软件构成(类，模块，方法等)向扩展行为开放，向修改行为关闭。 http://davidhayden.com/blog/dave/archive/2005/06/04/1096.aspx http://en.wikipedia.org/wiki/Open/closed_principle 《Head First 设计模式》第 86-87, 407 页 http://c2.com/cgi/wiki?OpenClosedPrinciple http://codebetter.com/blogs/david_laribee/archive/2008/09/11/why-solid-gimme-an-quot-o-quot.aspx Liskov替换原则(LSP) 子类必须能够用来当作基类使用。如果类A继承类B，任何能使用A的地方，B也同样可以使用。例如，是否还记得，正方形可以看作是矩形！当进行扩展时：前提条件不许绕过，后置条件不能放宽限制，可见常量不能被修改(?)。常量：在扩展之前或之后，用户都需要依靠这个常量来传递信息。正确的使用set形式的继承关系。不遵守set语义是非常危险的。归纳：使用超类的引用的任何上下文中也可以使用其子类的引用替代。这个原则极大的限制了在纯扩展(继承)机制里可以做的事情。不遵守会带来风险。 http://davidhayden.com/blog/dave/archive/2005/06/10/1226.aspx 《敏捷软件开发——原则、模式与实践》 页码 ? http://c2.com/cgi/wiki?LiskovSubstitutionPrinciple http://en.wikipedia.org/wiki/Liskov_substitution_principle http://javaboutique.internet.com/tutorials/JavaOO/ http://codebetter.com/blogs/david_laribee/archive/2008/09/22/why-solid-gimme-an-l.aspx 接口分离原则(ISP) 一个类对另一个类的依赖应该限制在最小化的接口上。 http://davidhayden.com/blog/dave/archive/2005/06/15/1482.aspx http://c2.com/cgi/wiki?InterfaceSegregationPrinciple http://www.google.com/search?q=interface+segration+principle http://doodleproject.sourceforge.net/articles/2001/interfaceSegregationPrinciple.html 反向依赖原则(DIP) 依赖抽象层(接口)，而不是具体类。 http://davidhayden.com/blog/dave/archive/2005/06/10/1261.aspx http://en.wikipedia.org/wiki/Dependency_inversion_principle 《Head First 设计模式》第 139-143 页 http://c2.com/cgi/wiki?DependencyInversionPrinciple Demeter定律 也被称做封锁信息原则：只跟朋友交流 一个对象O的任何一个方法M只能调用下列类型的对象的方法： 它自己 它的参量 它创建/实例化的对象 它的直接组件对象 参考 http://en.wikipedia.org/wiki/Principle_of_Least_Knowledge http://ctrl-shift-b.blogspot.com/2008/06/distilling-law-of-demeter.html 《Head First 设计模式》第 265 页 好莱坞原则 不要调用我，我会调用你的。 http://en.wikipedia.org/wiki/Hollywood_Principle 《Head First 设计模式》第 296 页 不要自我重复(DRY) 去掉重复代码。 《程序员修炼之道》(Pragmatic Programmer) ，第 27 页 http://en.wikipedia.org/wiki/Don%27t_repeat_yourself http://c2.com/cgi/wiki?DontRepeatYourself 对接口编程，而不是对实现 反向依赖的另外一种说法。 《Head First 设计模式》第 11, 110-111, 243, 335 页 http://www.artima.com/lejava/articles/designprinciples.html 你不需要它(YAGNI) 不要添加你“认为以后可能有用”的代码。只在“事到临头”时才添加代码。 http://c2.com/xp/YouArentGonnaNeedIt.html http://en.wikipedia.org/wiki/You_Ain%27t_Gonna_Need_It 简单化，傻瓜化(KISS) 让它能工作的最简单的方法是什么？ http://c2.com/cgi/wiki?DoTheSimplestThingThatCouldPossiblyWork http://en.wikipedia.org/wiki/KISS_principle","title":"S.O.L.I.D.类设计原则"},{"content":"  单例模式确保一个类在应用中只有一个实例。        我们以依赖注入创建bean实例为线索分析一下spring中单例模式。        Spring的依赖注入（包括lazy-init方式）都是发生在AbstractBeanFactory的getBean里。getBean的doGetBean方法调用getSingleton进行bean的创建。lazy-init方式，在容器初始化时候进行调用，非lazy-init方式，在用户向容器第一次索要bean时进行调用。 带同步的单例模式 下面是单例模式的核心代码。 protected Object getSingleton(String beanName, boolean allowEarlyReference) {  Object singletonObject = this.singletonObjects.get(beanName);  if (singletonObject == null) {   synchronized (this.singletonObjects) {    singletonObject = this.earlySingletonObjects.get(beanName);    if (singletonObject == null && allowEarlyReference) {     ObjectFactory singletonFactory = this.singletonFactories.get(beanName);     if (singletonFactory != null) {      singletonObject = singletonFactory.getObject();      this.earlySingletonObjects.put(beanName, singletonObject);      this.singletonFactories.remove(beanName);     }    }   }  }  return (singletonObject != NULL_OBJECT ? singletonObject : null); }      从上面代码可以看到，spring依赖注入时，使用了双重判断加锁的单例模式，首先从缓存中获取bean实例，如果为null，对缓存map加锁，然后再从缓存中获取bean，如果继续为null，就创建一个bean。这样双重判断，能够避免在加锁的瞬间，有其他依赖注入引发bean实例的创建，从而造成重复创建的结果。       在这里Spring并没有使用私有构造方法来创建bean，而是通过singletonFactory.getObject()返回具体beanName对应的ObjectFactory来创建bean。我们一路跟踪下去，发现实际上是调用了AbstractAutowireCapableBeanFactory的doCreateBean方法，返回了BeanWrapper包装并创建的bean实例。 （ObjectFactory主要检查是否有用户定义的BeanPostProcessor后处理内容，并在创建bean时进行处理，如果没有，就直接返回bean本身）   见如下代码： 8行创建bean实例返回给BeanWrapper 30行addSingletonFactory增加beanName和ObjectFactory的键值对应关系。 protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) {\t\t// Instantiate the bean.\t\tBeanWrapper instanceWrapper = null;\t\tif (mbd.isSingleton()) {\t\t\tinstanceWrapper = this.factoryBeanInstanceCache.remove(beanName);\t\t}\t\tif (instanceWrapper == null) {\t\t\tinstanceWrapper = createBeanInstance(beanName, mbd, args);\t\t}\t\tfinal Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);\t\tClass beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);\t\t// Allow post-processors to modify the merged bean definition.\t\tsynchronized (mbd.postProcessingLock) {\t\t\tif (!mbd.postProcessed) {\t\t\t\tapplyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\t\t\t\tmbd.postProcessed = true;\t\t\t}\t\t}\t\t// Eagerly cache singletons to be able to resolve circular references\t\t// even when triggered by lifecycle interfaces like BeanFactoryAware.\t\tboolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&\t\t\t\tisSingletonCurrentlyInCreation(beanName));\t\tif (earlySingletonExposure) {\t\t\tif (logger.isDebugEnabled()) {\t\t\t\tlogger.debug(\"Eagerly caching bean '\" + beanName +\t\t\t\t\t\t\"' to allow for resolving potential circular references\");\t\t\t}\t\t\taddSingletonFactory(beanName, new ObjectFactory() {\t\t\t\tpublic Object getObject() throws BeansException {\t\t\t\t\treturn getEarlyBeanReference(beanName, mbd, bean);\t\t\t\t}\t\t\t});\t\t}.... getEarlyBeanReference获取bean的所有后处理器，并进行处理。如果是SmartInstantiationAwareBeanPostProcessor类型，就进行处理，如果没有相关处理内容，就返回默认的实现。 protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {\t\tObject exposedObject = bean;\t\tif (bean != null && !mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\t\t\tfor (BeanPostProcessor bp : getBeanPostProcessors()) {\t\t\t\tif (bp instanceof SmartInstantiationAwareBeanPostProcessor) {\t\t\t\t\tSmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;\t\t\t\t\texposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);\t\t\t\t\tif (exposedObject == null) {\t\t\t\t\t\treturn exposedObject;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t\treturn exposedObject;\t} 另外，在Spring的其他代码中也有使用的单例模式，如AOP的切点定义中。 公有静态成员，私有构造函数的单例模式。 class TruePointcut implements Pointcut, Serializable {\t\tprivate static final TruePointcut INSTANCE = new TruePointcut();\t\t/**\t * Enforce Singleton pattern.\t */\tprivate TruePointcut() {\t}\t....       public static TruePointcut getInstance（）{        return INSTANCE;      }} 上面的代码可以改成：静态工厂方法的单例模式 class TruePointcut implements Pointcut, Serializable {        private static final TruePointcut INSTANCE = new TruePointcut();        /**     * Enforce Singleton pattern.     */    private TruePointcut() {    }    ....       public static TruePointcut getInstance（）{        return INSTANCE;      }} 或者改成：用枚举实现单例模式 enum TruePointcut implements Pointcut, Serializable {        INSTANCE ;...    }","title":"[置顶] Spring中的设计模式-单例模式"},{"content":"建造者模式(生成器模式) GOOD：在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用。 转载请注明，文章来自：http://blog.csdn.net/windows_nt 示例1： #include <string>#include <iostream>#include <vector>using namespace std;//最终的产品类class Product {private:\tvector<string> m_product;public:\tvoid Add(string strtemp)\t{\t\tm_product.push_back(strtemp);\t}\tvoid Show()\t{\t\tvector<string>::iterator p=m_product.begin();\t\twhile (p!=m_product.end())\t\t{\t\t\tcout<<*p<<endl;\t\t\tp++;\t\t}\t}};//建造者基类class Builder{public:\tvirtual void BuilderA()=0;\tvirtual void BuilderB()=0;\tvirtual Product* GetResult()=0;};//第一种建造方式class ConcreteBuilder1 : public Builder{private:\tProduct* m_product;public:\tConcreteBuilder1()\t{\t\tm_product=new Product();\t}\tvirtual void BuilderA()\t{\t\tm_product->Add(\"one\");\t}\tvirtual void BuilderB()\t{\t\tm_product->Add(\"two\");\t}\tvirtual Product* GetResult()\t{\t\treturn m_product;\t}};//第二种建造方式class ConcreteBuilder2 : public Builder{private:\tProduct * m_product;public:\tConcreteBuilder2()\t{\t\tm_product=new Product();\t}\tvirtual void BuilderA()\t{\t\tm_product->Add(\"A\");\t}\tvirtual void BuilderB()\t{\t\tm_product->Add(\"B\");\t}\tvirtual Product* GetResult()\t{\t\treturn m_product;\t}};//指挥者类class Direct{public:\tvoid Construct(Builder* temp)\t{\t\ttemp->BuilderA();\t\ttemp->BuilderB();\t}};//客户端int main(){\tDirect *p=new Direct();\tBuilder* b1=new ConcreteBuilder1();\tBuilder* b2=new ConcreteBuilder2();\tp->Construct(b1);\t\t\t\t//调用第一种方式\tProduct* pb1=b1->GetResult();\tpb1->Show();\tp->Construct(b2);\t\t\t\t//调用第二种方式\tProduct * pb2=b2->GetResult();\tpb2->Show();\treturn 0;} 示例2： #include <string>#include <iostream>#include <vector>using namespace std;class Person{public:\tvirtual void CreateHead()=0;\tvirtual void CreateHand()=0;\tvirtual void CreateBody()=0;\tvirtual void CreateFoot()=0;};class ThinPerson : public Person{public:\tvirtual void CreateHead()\t{\t\tcout<<\"thin head\"<<endl;\t}\tvirtual void CreateHand()\t{\t\tcout<<\"thin hand\"<<endl;\t}\tvirtual void CreateBody()\t{\t\tcout<<\"thin body\"<<endl;\t}\tvirtual void CreateFoot()\t{\t\tcout<<\"thin foot\"<<endl;\t}};class ThickPerson : public Person{public:\tvirtual void CreateHead()\t{\t\tcout<<\"ThickPerson head\"<<endl;\t}\tvirtual void CreateHand()\t{\t\tcout<<\"ThickPerson hand\"<<endl;\t}\tvirtual void CreateBody()\t{\t\tcout<<\"ThickPerson body\"<<endl;\t}\tvirtual void CreateFoot()\t{\t\tcout<<\"ThickPerson foot\"<<endl;\t}};//指挥者类class Direct{private:\tPerson* p;public:\tDirect(Person* temp) { p = temp;}\tvoid Create()\t{\t\tp->CreateHead();\t\tp->CreateBody();\t\tp->CreateHand();\t\tp->CreateFoot();\t}};//客户端代码：int main(){\tPerson *p=new ThickPerson();\tDirect *d= new Direct(p);\td->Create();\tdelete d;\tdelete p;\treturn 0;}  ","title":"设计模式学习-----建造者模式（生成器模式）"},{"content":"观察者模式 GOOD：定义了一种一对多的关系，让多个观察对象（公司员工）同时监听一个主题对象（秘书），主题对象状态发生变化时，会通知所有的观察者，使它们能够更新自己。 转载请注明，文章来自：http://blog.csdn.net/windows_nt 示例： #include <string>#include <iostream>#include <vector>using namespace std;class Secretary;//看股票的同事类（观察对象，观察者）class StockObserver{private:\tstring name;\tSecretary* sub;public:\tStockObserver(string strname,Secretary* strsub)\t{\t\tname=strname;\t\tsub=strsub;\t}\tvoid Update();};//秘书类（主题对象，通知者）class Secretary{private:\tvector<StockObserver> observers;public:\tstring action;\tvoid Add(StockObserver ob)\t{\t\tobservers.push_back(ob);\t}\tvoid Notify()\t{\t\tvector<StockObserver>::iterator p = observers.begin();\t\twhile (p!=observers.end())\t\t{\t\t\t(*p).Update();\t\t\tp++;\t\t}\t}};void StockObserver::Update(){\tcout<<name<<\":\"<<sub->action<<\",不要玩股票了，要开始工作了\"<<endl;}//客户端int main(){\tSecretary *p=new Secretary();  //创建通知者\t//观察者\tStockObserver *s1= new StockObserver(\"小李\",p);\tStockObserver *s2 = new StockObserver(\"小赵\",p);\t//加入通知队列\tp->Add(*s1);\tp->Add(*s2);\t//事件\tp->action=\"老板来了\";\t//通知\tp->Notify();\treturn 0;} #include <string>#include <iostream>#include <vector>using namespace std;class SecretaryBase;//抽象观察者class CObserverBase{protected:\tstring name;\tSecretaryBase* sub;public:\tCObserverBase(string strname,SecretaryBase* strsub)\t{\t\tname=strname;\t\tsub=strsub;\t}\tvirtual void Update()=0;};//具体的观察者，看股票的class StockObserver : public CObserverBase{public:\tStockObserver(string strname,SecretaryBase* strsub) : CObserverBase(strname,strsub)\t{\t}\tvirtual void Update();};//具体观察者，看NBA的class NBAObserver : public CObserverBase{public:\tNBAObserver(string strname,SecretaryBase* strsub) : CObserverBase(strname,strsub){}\tvirtual void Update();};//抽象通知者class SecretaryBase{public:\tstring action;\tvector<CObserverBase*> observers;public:\tvirtual void Attach(CObserverBase* observer)=0;\tvirtual void Notify()=0;};//具体通知者class Secretary :public SecretaryBase{public:\tvoid Attach(CObserverBase* ob)\t{\t\tobservers.push_back(ob);\t}\tvoid Notify()\t{\t\tvector<CObserverBase*>::iterator p = observers.begin();\t\twhile (p!=observers.end())\t\t{\t\t\t(*p)->Update();\t\t\tp++;\t\t}\t}};void StockObserver::Update(){\tcout<<name<<\":\"<<sub->action<<\",不要玩股票了，要开始工作了\"<<endl;}void NBAObserver::Update(){\tcout<<name<<\":\"<<sub->action<<\",不要看NBA了，老板来了\"<<endl;}//客户端：int main(){\tSecretaryBase *p=new Secretary();  //创建观察者\t//被观察的对象\tCObserverBase *s1= new NBAObserver(\"小李\",p);\tCObserverBase *s2 = new StockObserver(\"小赵\",p);\t//加入观察队列\tp->Attach(s1);\tp->Attach(s2);\t//事件\tp->action=\"老板来了\";\t//通知\tp->Notify();\treturn 0;} 智能化观察者模式，不用客户端手动把被观察者加入观察队列 #include <string>#include <iostream>#include <vector>using namespace std;class CObserverBase;\t\t//抽象观察者//具体通知者class Secretary{public:\tstatic vector<CObserverBase*> m_ObServerBase;public:\tSecretary() {}\tvirtual ~Secretary() {}\tstatic void Attach(CObserverBase* ob)\t{\t\tm_ObServerBase.push_back(ob);\t}\tstatic void Notify();};//抽象观察者class CObserverBase{public:\tCObserverBase* m_pObserverBase;public:\tCObserverBase() { m_pObserverBase = NULL; Connect(); }\tvirtual CObserverBase::~CObserverBase() { Disconnect(); }\tvoid Connect()\t{\t\tif (m_pObserverBase) return;\t\tSecretary::Attach(this);\t\tm_pObserverBase = this;\t}\tvoid Disconnect() {}\tvirtual void OnUpdate() {}};void Secretary::Notify(){\tvector<CObserverBase*>::iterator p = m_ObServerBase.begin();\twhile (p != m_ObServerBase.end())\t{\t\t(*p)->OnUpdate();\t\tp++;\t}}//具体的观察者，看股票的class StockObserver : public CObserverBase{public:\tStockObserver(string strname,Secretary* strsub)\t{\t}\tvirtual void OnUpdate();};//具体观察者，看NBA的class NBAObserver : public CObserverBase{public:\tNBAObserver(string strname,Secretary* strsub) \t{\t}\tvirtual void OnUpdate();};void StockObserver::OnUpdate(){\tcout<<\"CBA:\"<<\"不要玩股票了，要开始工作了\"<<endl;}void NBAObserver::OnUpdate(){\tcout<<\"NBA:\"<<\"不要看NBA了，老板来了\"<<endl;}vector<CObserverBase*> Secretary::m_ObServerBase;//客户端：int main(){\t //创建观察者\tSecretary* p = new Secretary; \t//被观察的对象\tNBAObserver *s1= new NBAObserver(\"小李\",p);\tStockObserver *s2 = new StockObserver(\"小赵\",p);\t//通知\tp->Notify();\treturn 0;}  ","title":"设计模式学习-----观察者模式"},{"content":"      (6) 观察者模式      联机射击游戏可以实时显示队友和敌人的存活信息，如果有队友或敌人阵亡，所有在线游戏玩家将收到相应的消息，可以提供一个统一的中央角色控制类(CenterController)来实现消息传递机制，在中央角色控制器中定义一个集合用于存储所有的玩家信息，如果某玩家角色(Player)阵亡，则调用CenterController的通知方法notifyPlayers()，该方法将遍历用户信息集合，调用每一个Player的display()方法显示阵亡信息，队友阵亡和敌人阵亡的提示信息有所不同，在使用notifyPlayers()方法通知其他用户的同时，阵亡的角色对象将从用户信息集合中被删除。可使用观察者模式来实现信息的一对多发送，类图如图6所示： 图6 观察者模式实例类图       在图6中，CenterController充当观察目标，Observer充当抽象观察者，Player充当具体观察者。在Player类中，name属性表示角色名，type属性表示角色类型，如“战队A”或“战队B”等。Player的die()方法执行时将调用CenterController的notifyPlayers()方法，在notifyPlayers()方法中调用其他Player对象的提示方法，如果是队友阵亡则调用displayTeam()，如果是敌人阵亡则调用displayEnemy()；还将调用detach()方法删除阵亡的Player对象，其中CenterController类的notifyPlayers()方法代码片段如下所示： for(Object player : players) {    if(player.getName().equals(name)) {      this.detach(player);  //删除阵亡的角色     }    else {        if(player.getType().equals(type)) {            player.displayTeam(name);  //队友显示提示信息         }        else {            player.displayEnemy(name);  //敌人显示提示信息          }    }}         (7) 单例模式       为了节约系统资源，在联机射击游戏中可以使用单例模式来实现一些管理器(Manager)，如场景管理器(SceneManager)、声音管理器(SoundManager)等，如图7所示的场景管理器SceneManager类： 图7 单例模式实例类图        SceneManager类的实现代码片段如下所示【注：以下代码未考虑多线程访问的问题】： class SceneManager {\tprivate static SceneManager sManager = null;\tprivate SceneManager() {\t\t//初始化代码\t}\tpublic synchronized static SceneManager getInstance() {\t\tif(sManager==null) {\t\t\tsManager = new SceneManager();\t\t}\t\treturn sManager;\t}\tpublic void manage() {\t\t//业务方法\t}}       (8) 状态模式       在射击游戏中，游戏角色存在几种不同的状态，如正常状态、暂停状态、阵亡状态等，在不同状态下角色对象的行为不同，可使用状态模式来设计和实现角色状态的转换，类图如图8所示： 图8 状态模式实例类图        在图8中，游戏角色类Player充当环境类，State充当抽象状态类，其子类NormalState、PauseState和DeathState充当具体状态类，在具体状态类的pause()、start()、beAttacked()等方法中可实现状态转换，其中NormalState类的代码片段如下所示： class NormalState extends State{\tpublic void pause()  //游戏暂停\t{\t\t//暂停代码省略\t\tplayer.setState(new PauseState(this));  //转为暂停状态\t}\tpublic void start()  //游戏启动\t{\t\t//游戏程序正在运行中，该方法不可用\t}\tpublic void beAttacked()  //被攻击\t{\t\t//其他代码省略\t\tif(lifeValue<=0)\t\t{\t\t\tplayer.setState(new DeathState(this));  //转为阵亡状态\t\t}\t}\tpublic void shot()  //射击\t{\t\t//代码省略\t}\tpublic void move()  //移动\t{\t\t//代码省略\t}}        (9) 适配器模式        为了增加游戏的灵活性，某些射击游戏还可以通过游戏手柄来进行操作，游戏手柄的操作程序和驱动程序由游戏手柄制造商提供，为了让当前的射击游戏可以与游戏手柄兼容，可使用适配器模式来进行设计，类图如图9所示： 图9 适配器模式实例类图        在图9中，GamepadsAdapter充当适配器，它将游戏手柄中按键(GamepadsKey)的方法适配到现有系统中，在其move()方法中可以调用MoveKey类的handle()方法，在其shot()方法中可以调用ShotKey的handle()方法，从而实现通过手柄来控制游戏运行。   【作者：刘伟 http://blog.csdn.net/lovelion】","title":"多人联机射击游戏中的设计模式应用（二）"},{"content":"开篇-模式和原则 前言 正式接触使用设计模式近两年了，一直想写点东西来巩固所学，但是迟迟没有动作，总想时间和见识再多一些的时候再动笔，但是拖得越久越感觉合适的时机永远不会有，只有不断实践才能换来进步，也许再不写就永远也写不出来了，于是我终于开始了。 谈到设计模式，应该还没有人能超越GOF的开山之作，所以谈不上什么创新，归根结底还是重复前人的论述和思想，更多的只能是整理和个人的一些心得体会。因为从设计模式诞生以来，业界还是发生了很大的变化的，开发工具和开发过程已经更新换代了很多次，所以很多模式在现在已经不是很常用了，这次计划只重点介绍最流行的模式，以后会逐渐补充其它的模式。(参看下面的提纲) 这个系列计划以《Head First Design Patterns》的结构为主线，也可以说是这本书的学习笔记，但是更多的是学习原书循序渐进的讲解方式，再争取加入更多个人的思想和见解，希望最后能引起大家的共鸣。 园子里已经有好几位大侠和前辈写过设计模式系列的文章了，我从他们那曾经吸收了太多的精华，大恩不言谢，我这里还是谢过了。 提纲 下面是这个系列的提纲初稿，将来会根据实际情况做适当的增删。   开篇-模式和原则 1.       鸭子-策略模式 2.       气象站的故事-观察者模式 3.       来杯咖啡-装饰者模式 4.       美味比萨-工厂模式 5.       巧克力-单件模式 6.       遥控器-命令模式 7.       家庭剧院-适配器和门面模式 8.       好莱坞原则-模板方法模式 9.       餐厅菜单-迭代器和合成模式 10.   糖果机-状态模式 11.   首席代表-代理模式 12.   鸭子重出江湖-复合使用模式 13.   用模式思考-与模式相处 14.   剩下的模式 设计模式介绍 模式：每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。 这是关于模式最经典的定义，作者是建筑大师Christopher Alexander。如果是第一次看到这句话，多数人会觉得有些抽象难懂。其实“模式”两个字只是一个代号，就像我叫Justin，如果我改叫Tom也没什么问题，只是我更喜欢Justin这个名字，所以从Christopher开始，有了“模式”这个词，人们也都把关于“重复发生的问题的描述和解决办法”统称为模式。 “模式”这个词是不局限于软件开发行业的，它几乎无处不在，它其实就是一种经验的积累，就象大多数人的教育经历都是从小学到初中再到高中再到大学，这也是一种模式，是中国的教育模式；现在越来越火的出国热，也是另一种模式，海外留学模式。因为GOF的《设计模式：可复用面向对象软件的基础》一书描述的23种经典设计模式，奠定了模式在软件行业的地位，从此人们提到“设计模式”就是默指“面向对象设计模式”，但是如前文所述，模式绝对不局限于软件行业，即使在软件行业，也不局限于GOF描述的23种设计模式，例如最著名的Martin Flower的《企业架构模式》，还有我们常用的MVC、IOC等。 [说到这里，有必要声明一下的是，在该系列文章中，凡提到模式，都是指软件行业的基于GOF的《设计模式：可复用面向对象软件的基础》一书的面向对象设计模式，GRASP模式除外。] 因为模式是一种经验的积累和总结，所以通过模式，我们可以站在巨人的肩膀上去思考问题、解决问题，熟练使用设计模式可以提高我们的工作效率，改善产品质量，最终带来经济效益。因此对于任何想开发出灵活高效、健壮的软件产品的个人或团体，熟练掌握并正确使用设计模式都是必须掌握的基本技能。 所以，让我们开始吧…… 比设计模式更重要：GRASP (职责分配原则) 要学习设计模式，有些基础知识是我们必须要先知道的，设计模式是关于类和对象的一种高效、灵活的使用方式，也就是说，必须先有类和对象，才能有设计模式的用武之地，否则一切都是空谈，那么类和对象是从那冒出来的呢？这时就需要比23种设计模式更重要更经典的GRASP模式登场了，嘿嘿，原来这才是老大！ GRASP(General Responsibility Assignment Software Patterns)，中文名称为“通用职责分配软件模式”，GRASP一共包括9种模式，它们描述了对象设计和职责分配的基本原则。也就是说，如何把现实世界的业务功能抽象成对象，如何决定一个系统有多少对象，每个对象都包括什么职责，GRASP模式给出了最基本的指导原则。初学者应该尽快掌握、理解这些原则，因为这是如何设计一个面向对象系统的基础。可以说，GRASP是学习使用设计模式的基础。 1.      Information Expert (信息专家) 信息专家模式是面向对象设计的最基本原则，是我们平时使用最多，应该跟我们的思想融为一体的原则。也就是说，我们设计对象(类)的时候，如果某个类拥有完成某个职责所需要的所有信息，那么这个职责就应该分配给这个类来实现。这时，这个类就是相对于这个职责的信息专家。 例如：常见的网上商店里的购物车(ShopCar),需要让每种商品(SKU)只在购物车内出现一次，购买相同商品，只需要更新商品的数量即可。如下图： 针对这个问题需要权衡的是，比较商品是否相同的方法需要放到那里类里来实现呢？分析业务得知需要根据商品的编号(SKUID)来唯一区分商品，而商品编号是唯一存在于商品类里的，所以根据信息专家模式，应该把比较商品是否相同的方法放在商品类里。   2.      Creator (创造者) 实际应用中，符合下列任一条件的时候，都应该由类Ａ来创建类Ｂ，这时Ａ是Ｂ的创建者： a.       Ａ是Ｂ的聚合 b.       Ａ是Ｂ的容器 c.       Ａ持有初始化Ｂ的信息(数据) d.       Ａ记录Ｂ的实例 e.       Ａ频繁使用Ｂ 如果一个类创建了另一个类，那么这两个类之间就有了耦合，也可以说产生了依赖关系。依赖或耦合本身是没有错误的，但是它们带来的问题就是在以后的维护中会产生连锁反应，而必要的耦合是逃不掉的，我们能做的就是正确地创建耦合关系，不要随便建立类之间的依赖关系，那么该如何去做呢？就是要遵守创建者模式规定的基本原则，凡是不符合以上条件的情况，都不能随便用A创建B。 例如：因为订单(Order)是商品(SKU)的容器，所以应该由订单来创建商品。如下图：        这里因为订单是商品的容器，也只有订单持有初始化商品的信息，所以这个耦合关系是正确的且没办法避免的，所以由订单来创建商品。   3.      Low coupling (低耦合) 低耦合模式的意思就是要我们尽可能地减少类之间的连接。 其作用非常重要： a.       低耦合降低了因一个类的变化而影响其他类的范围。 b.       低耦合使类更容易理解，因为类会变得简单，更内聚。 下面这些情况会造成类A、B之间的耦合： a.       A是B的属性 b.       A调用B的实例的方法 c.       A的方法中引用了B，例如B是A方法的返回值或参数。 d.       A是B的子类，或者A实现了B 关于低耦合，还有下面一些基本原则： a.       Don’t Talk to Strangers原则： 意思就是说，不需要通信的两个对象之间，不要进行无谓的连接，连接了就有可能产生问题，不连接就一了百了啦！ b.       如果A已经和B有连接，如果分配A的职责给B不合适的话(违反信息专家模式)，那么就把B的职责分配给A。 c.       两个不同模块的内部类之间不能直接连接，否则必招报应！嘿！ 例如：Creator模式的例子里，实际业务中需要另一个出货人来清点订单(Order)上的商品(SKU)，并计算出商品的总价，但是由于订单和商品之间的耦合已经存在了，那么把这个职责分配给订单更合适，这样可以降低耦合，以便降低系统的复杂性。如下图：        这里我们在订单类里增加了一个TotalPrice()方法来执行计算总价的职责，没有增加不必要的耦合。                4.      High cohesion (高内聚) 高内聚的意思是给类尽量分配内聚的职责，也可以说成是功能性内聚的职责。即功能性紧密相关的职责应该放在一个类里，并共同完成有限的功能，那么就是高内聚合。这样更有利于类的理解和重用，也便于类的维护。 高内聚也可以说是一种隔离，就想人体由很多独立的细胞组成，大厦由很多砖头、钢筋、混凝土组成，每一个部分(类)都有自己独立的职责和特性，每一个部分内部发生了问题，也不会影响其他部分，因为高内聚的对象之间是隔离开的。 例如：一个订单数据存取类(OrderDAO)，订单即可以保存为Excel模式，也可以保存到数据库中；那么，不同的职责最好由不同的类来实现，这样才是高内聚的设计，如下图：        这里我们把两种不同的数据存储功能分别放在了两个类里来实现，这样如果未来保存到Excel的功能发生错误，那么就去检查OrderDAOExcel类就可以了，这样也使系统更模块化，方便划分任务，比如这两个类就可以分配个不同的人同时进行开发，这样也提高了团队协作和开发进度。     5.      Controller (控制器) 用来接收和处理系统事件的职责，一般应该分配给一个能够代表整个系统的类，这样的类通常被命名为“XX处理器”、“XX协调器”或者“XX会话”。 关于控制器类，有如下原则： a.       系统事件的接收与处理通常由一个高级类来代替。 b.       一个子系统会有很多控制器类，分别处理不同的事务。 关于这个模式更详细的论述，请参考《UML和模式应用》第16章。      6.      Polymorphism (多态) 这里的多态跟OO三大基本特征之一的“多态”是一个意思。 例如：我们想设计一个绘图程序，要支持可以画不同类型的图形，我们定义一个抽象类Shape,矩形(Rectangle)、圆形(Round)分别继承这个抽象类，并重写(override)Shape类里的Draw()方法，这样我们就可以使用同样的接口(Shape抽象类)绘制出不同的图形，如下图： 这样的设计更符合高内聚和低耦合原则，虽然后来我们又增加了一个菱形(Diamond)类，对整个系统结构也没有任何影响，只要增加一个继承Shape的类就行了。     7.      Pure Fabrication (纯虚构) 这里的纯虚构跟我们常说的纯虚构函数意思相近。高内聚低耦合，是系统设计的终极目标，但是内聚和耦合永远都是矛盾对立的。高内聚以为这拆分出更多数量的类，但是对象之间需要协作来完成任务，这又造成了高耦合，反过来毅然。该如何解决这个矛盾呢，这个时候就需要纯虚构模式，由一个纯虚构的类来协调内聚和耦合，可以在一定程度上解决上述问题。 例如：上面多态模式的例子，如果我们的绘图程序需要支持不同的系统，那么因为不同系统的API结构不同，绘图功能也需要不同的实现方式，那么该如何设计更合适呢？如下图： 这里我们可以看到，因为增加了纯虚构类AbstractShape，不论是哪个系统都可以通过AbstractShape类来绘制图形，我们即没有降低原来的内聚性，也没有增加过多的耦合，可谓鱼肉和熊掌兼得，哈哈哈！          8.      Indirection (间接) “间接”顾名思义，就是这个事不能直接来办，需要绕个弯才行。绕个弯的好处就是，本来直接会连接在一起的对象彼此隔离开了，一个的变动不会影响另一个。就想我在前面的低耦合模式里说的一样，“两个不同模块的内部类之间不能直接连接”，但是我们可以通过中间类来间接连接两个不同的模块，这样对于这两个模块来说，他们之间仍然是没有耦合/依赖关系的。   9.      Protected Variations (受保护变化) 预先找出不稳定的变化点，使用统一的接口封装起来，如果未来发生变化的时候，可以通过接口扩展新的功能，而不需要去修改原来旧的实现。也可以把这个模式理解为OCP(开闭原则)原则，就是说一个软件实体应当对扩展开发，对修改关闭。在设计一个模块的时候，要保证这个模块可以在不需要被修改的前提下可以得到扩展。这样做的好处就是通过扩展给系统提供了新的职责，以满足新的需求，同时又没有改变系统原来的功能。关于OCP原则，后面还会有单独的论述。   比设计模式更重要：设计原则 我们生活在一个充满规则的世界里，在复杂多变的外表下，万事万物都被永恒的真理支配并有规律的运行着。模式也是一样，不论那种模式，其背后都潜藏着一些“永恒的真理”，这个真理就是设计原则。记得一次参加微软的架构师培训，期间讲到设计模式，有人问了老师一个问题：“什么东西比设计模式更重要？”，老师是一位有多年丰富实践经验的开发者，他毫不犹豫地回答到：“比模式更重要的是原则”。这句话我时常能够想起，越来越觉得这是一个伟大的答案。的确，还有什么比原则更重要呢？就像人的世界观和人生观一样，那才是支配你一切行为的根本，而对于设计模式来说，为什么这个模式要这样解决这个问题，而另一个模式要那样，它们背后都遵循的就是永恒的设计原则。可以说，设计原则是设计模式的灵魂。 对于设计原则的深入探讨我还没有那个深度，推荐大家去看《敏捷软件开发—原则、模式与实践》，下面仅对部分常用的设计原则做些简单的讲解：    1. 单一职责原则(SRP)    “就一个类而言，应该仅有一个引起它变化的原因。”也就是说，不要把变化原因各不相同的职责放在一起，因为不同的变化会影响到不相干的职责。再通俗一点地说就是，不该你管的事情你不要管，管好自己的事情就可以了，多管闲事害了自己也害了别人。(当然这里说的多管闲事跟见义勇为是两回事，我们提倡见义勇为！)        例如：参考下图中的设计，图形计算程序只使用了正方形的Area()方法，永远不会使用Draw()方法，而它却跟Draw方法关联了起来。这违反了单一原则，如果未来因为图形绘制程序导致Draw()方法产生了变化，那么就会影响到本来毫不关系的图形计算程序。             那么我们该怎么做呢？如下图，将不同的职责分配给不同的类，使单个类的职责尽量单一，就隔离了变化，这样他们也不会互相影响了。               2. 开放—封闭原则(OCP)    “软件实体(类、模块、函数等)应该是可以扩展的，但是不可修改。”嘿！多么朴实的话语，第一次看这个原则的时候我都看傻了，我当时在想“这不是&#%做白日梦吗！不修改怎么扩展啊？”但是随着学习的深入，理解了这个“不修改”是什么意思，意思是“你可以随便增加新的类，但是不要修改原来的类”。从这个角度去理解就好多了，其实这里还是一个隔离变化的问题。        例如：如下图，有一个客户端程序通过数据访问接口操作数据，对于这套系统来说，一开始计划使用的是SQL Server或Oracle数据库，但是后来考虑到成本，改用免费的MySQL；那么对于客户端程序来说，后来数据的扩展对它没有任何影响，它在不知不觉间就用上了免费好用的MySQL数据库，这全要感谢OCP原则。       3. 依赖倒置原则(DIP) “抽象不应该依赖于细节。细节应该依赖于抽象。”关于这个原则，还有种说法是.“高层不应该依赖于底层，两者都应该依赖于抽象。”其实怎么说都是对的，关键就是要理解一点，只有抽象的东西才是最稳定的，也就是说，我们依赖的是它的稳定。如果将来“抽象”也不稳定了，那么谁稳定我跟谁，其实说白了不就是傍大款吗！哈哈！ 例如：参考下图的设计，一个开关跟灯直接连接在一起了，也就是说开关依赖于灯的打开和关闭方法，那么如果我想用这个开关也可以打开其他东西呢，比如电视、音响。显然这个设计是无法满足这个要了，因为我们依赖了细节而不是抽象，这个开关已经等价于“灯的开关”。        那么我们该如何来设计一个通用的开关呢？参考下图的设计，OK！现在我们不仅可以打开灯，还可以打开电视和音响，甚至未来任何实现了“开关接口”的任何东西。                4. 接口隔离原则(ISP) “不应该强迫客户依赖于它们不用的方法。接口属于客户，不属于它所在的类层次结构。”这个说得很明白了，再通俗点说，不要强迫客户使用它们不用的方法，如果强迫用户使用它们不使用的方法，那么这些客户就会面临由于这些不使用的方法的改变所带来的改变。  例如：参考下图的设计，在这个设计里，取款、存款、转帐都使用一个通用界面接口，也就是说，每一个类都被强迫依赖了另两个类的接口方法，那么每个类有可能因为另外两个类的方法(跟自己无关)而被影响。拿取款来说，它根本不关心“存款操作”和“转帐操作”，可是它却要受到这两个方法的变化的影响，真是土鳖！！！         那么我们该如何解决这个问题呢？参考下图的设计，为每个类都单独设计专门的操作接口，使得它们只依赖于它们关系的方法，这样就不会互相影响，也就不会在发生土鳖的事情了！             5. 替换原则(LSP) “子类型必须能够替换掉它们的基类型。”也就是说继承中的“IS A”关系是必须保证的，否则还算什么继承啊！如果违反了LSP原则，常会导致在运行时(RTTI)的类型判断违反OCP原则。 例如：函数A的参数是基类型，调用时传递的对象是子类型，正常情况下，增加子类型都不会影响到函数A的，如果违反了LSP，则函数A必须小心的判断传进来的具体类型，否则就会出错，这就已经违反了OCP原则。 关于模式学习 深刻理解面向对象是学好设计模式的基础，掌握一定的面向对象设计原则才能掌握面向对象设计模式的精髓，从而实现灵活运用设计模式。仅知道OO的语言机制是不够的，懂得语言里的封装、继承、多态，只是满足了最最基础的条件，要真正发挥OO的强大的作用，关键是要深刻理解以上的GRASP模式和设计原则，在此基础上去再深入理解设计模式，并在实践中不断磨练。 模式跟OO原则相比其实并不重要，如果你能设计出基本符合以上原则的程序，那么可能就已经总结出了新的模式，所以学习模式的根本是为了深入理解OO思想和原则，使我们可以写出高内聚低耦合的程序。 另外最近在学习李建忠老师的“C#面向对象设计模式纵横谈系列课程”时候，李老师提出了一个“重构到模式”的理论，感觉十分有道理，模式不完全是供我们套用的模版，在特定的业务环境下，我们实现的可能只是“类似XX模式”的设计模式，因为针对这个环境，这么使用就是最合适的，而不是什么时候都必须完全照搬GOF的23种设计模式的格式，模式是死的，而人是活的，找到最合适的实现方式就好，不要为了设计模式而使用设计模式。 作者 王晓亮/Justin MSN:xiaoliang203@hotmail.com Mail:xiaoliang.justin@gmail.com 参考资料 《UML和模式应用》 《敏捷软件开发—原则、模式与实践》 李建忠老师的《C#面向对象设计模式纵横谈系列课程》 作者：Justin 出处：http://justinw.cnblogs.com/  本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。","title":"模式和原则"},{"content":"windows应用程序，操作系统，计算机硬件之间的相互关系。 内部原理是一种事件驱动的方式的程序设计模式，主要是基于消息的。 当用户需要完成某种功能时，会调用操作系统的某种支持，然后操作系统将用户的需要包装成消息，并投递到消息队列中，最后应用程序 从消息队列中取得消息并进行响应。 1，表示操作系统能够操作输出设备，执行特定的功能，比如让声卡发出声音，让显卡画出图形。 2，表示操系统能够感知输入设备状态的变化，比如，鼠标移动，键盘按下，并且能够知道鼠标移动的具体位置，键盘按下的是哪个字符。 3，表示应用程序可以通知操作系统执行某个具体的动作，如操作能够控制声卡发出的声音，但不知道应该何时发出何种声音。需要应用程序告诉操作系统。 操作系统把它所能够完成的功能以函数的形式提供给应用程序，应用程序对这些函数的调用就叫做系统调用。这些函数的集合就是windows操作系统提供绘就有出入编程的接口，简称WINDOWS API。 4，表示操作系统能够将输入设备的变化上传给应用程序。如用户在某个程序活动时按下了键盘，操作系统马上就能够感知到这一事件，并且能够知道用户按下的是哪一个键盘国，操作系统并不决定对这一事件如何作出反应，而是将这一事件转交给应用程序，由应用程序决定如何对这一事件作出反应。 对事件作出反应的过程就是消息响应。 操作系统是怎么将感知到的事件传递给应用程序的呢？是通过消息机制来实现的。 操作系统将每个事件都包装成消息的结构体MSG来传递给应用程序。 MSG结构定义如下。 typedef struct tagMSG {         HWND   hwnd;     //HWND类型，窗口句柄。    UINT   message;  //无符号整型，消息类型，表示具体一个消息，比如按下键盘上的按键，就有一个按键消息，就是message消息传输出去。    WPARAM wParam;   //WPARAM和LPARAM都是一个整型，是消息的附加参数    LPARAM lParam; \t\t    DWORD  time;     //消息被投递的时间。    POINT  pt;       //点的结构体，当消息被投递的时候，光标在屏幕上的位置。} MSG; 句柄 HANDLE，资源的标识，类似于指针。 细分为，图标句柄HICON，光标句柄HCURSOR，窗口句柄HWND，应用程序实例句柄，HINSTANCE 操作系统给每一个窗口指定唯一一个标识号即窗口句柄 消息 队列 操作系统给每一个应用程序都建立了一个消息队列。 消息队列是一个，先进先出的缓冲区。每一条元素都是一条消息。应用程序总是取走消息队列中的第一条消息。取走第一条消息的时候，第二条就成为第一条消息。 WinMain函数 windows程序的入口函数 int WINAPI WinMain(  HINSTANCE hInstance,  // 当前运行的一个实例句柄。  HINSTANCE hPrevInstance,  // 先前实例的句柄，这个参数总是为空，不在需要  LPSTR lpCmdLine,      // LP表示是一个长指针，STR表示一个字符串，表示字符串的一个指针。命令行的一个参数。  int nCmdShow          // 窗口的状态，最大化，最小化还是隐藏。);WinMain函数由操作系统调用。","title":"windows 程序内部运行原理"},{"content":"工厂方法模式     GOOD：修正了简单工厂模式中不遵守开放－封闭原则。     工厂方法模式把选择判断移到了客户端去实现，如果想添加新功能就不用修改原来的类，直接修改客户端即可。 转载请注明，文章来自：http://blog.csdn.net/windows_nt 例： #include <string>#include <iostream>using namespace std;//实例基类，相当于Product(为了方便，没用抽象)class LeiFeng{public:\tvirtual void Sweep()\t{\t\tcout<<\"雷锋扫地雷\"<<endl;\t}};//学雷锋的大学生，相当于ConcreteProductclass Student: public LeiFeng{public:\tvirtual void Sweep()\t{\t\tcout<<\"大学生扫地\"<<endl;\t}};//学雷锋的志愿者，相当于ConcreteProductclass Volenter: public LeiFeng{public :\tvirtual void Sweep()\t{\t\tcout<<\"志愿者坑蒙拐骗\"<<endl;\t}};//工场基类Creatorclass LeiFengFactory{public:\tvirtual LeiFeng* CreateLeiFeng()\t{\t\treturn new LeiFeng();\t}};//工场具体类class StudentFactory : public LeiFengFactory{public :\tvirtual LeiFeng* CreateLeiFeng()\t{\t\treturn new Student();\t}};class VolenterFactory : public LeiFengFactory{public:\tvirtual LeiFeng* CreateLeiFeng()\t{\t\treturn new Volenter();\t}};//客户端int main(){\tLeiFengFactory *sf=new LeiFengFactory();\tLeiFeng *s=sf->CreateLeiFeng();\ts->Sweep();\tdelete s;\tdelete sf;\treturn 0;}","title":"设计模式学习-----工厂方法模式"},{"content":"今天一直心绪不宁，被一些事情所困扰，希望能有个好的过程以及结果而不是自己的空想。看一下桥接模式吧，个人感觉这个模式是个比较容易理解的模式，但是在真正应用的时候还是需要一定的经验。 概述 在软件系统中，某些类型由于自身的逻辑，它具有两个或多个维度的变化，那么如何应对这种“多维度的变化”？如何利用面向对象的技术来使得该类型能够轻松的沿着多个方向进行变化，而又不引入额外的复杂度？这就要使用Bridge模式。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。 模式定义：     桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。（Bridge Pattern: Decouple an abstraction from its implementation so that the two can vary independently.） 结构： Abstraction 定义抽象的接口 该接口包含实现具体行为、具体特征的Implementor接口 Refined Abstraction 抽象接口Abstraction的子类，依旧是一个抽象的事物名 Implementor 定义具体行为、具体特征的应用接口 ConcreteImplementor 实现Implementor接口 模式分析： 理解桥接模式，重点需要理解如何将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化。     •抽象化：抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面向对象中，将对象的共同性质抽取出来形成类的过程即为抽象化的过程。     •实现化：针对抽象化给出的具体实现，就是实现化，抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是对抽象化事物的进一步具体化的产物。     •脱耦：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意。 代码实现： 这个例子用画笔和颜色搭配比较合适： Abstraction [java] view plaincopy public abstract class Brush {       Color mColor;       public Brush(Color color) {           mColor = color;       }              //默认画笔为黑色       public Brush() {           mColor = new BlackColor();       }              public void setColor(Color color) {           mColor = color;       }       public abstract void draw();   }   Refined Abstraction 小号笔： [java] view plaincopy public class SmallBrush extends Brush {              public SmallBrush(){           super();       }              public SmallBrush(Color color) {           super(color);       }          @Override       public void draw() {           System.out.println(\" in smallBrush, begin to draw\");           mColor.draw();       }      }   中号笔： [java] view plaincopy public class MiddleBrush extends Brush {              public MiddleBrush() {           super();       }          public MiddleBrush(Color color) {           super(color);       }              @Override       public void draw() {           System.out.println(\" in MiddleBrush, begin to draw\");           mColor.draw();       }      }   大号笔： [java] view plaincopy public class BigBrush extends Brush {              public BigBrush() {           super();       }          public BigBrush(Color color) {           super(color);       }          @Override       public void draw() {           System.out.println(\" in BigBrush, begin to draw\");           mColor.draw();       }      }   Implementor [java] view plaincopy public interface Color {       void draw();   }   ConcreteImplementor 红色： [java] view plaincopy public class RedColor implements Color {          @Override       public void draw() {           System.out.println(\"this is red color...\");       }      }   黑色： [java] view plaincopy public class BlackColor implements Color {          @Override       public void draw() {           System.out.println(\"this is black color...\");       }      }   蓝色： [java] view plaincopy public class BlueColor implements Color {          @Override       public void draw() {           System.out.println(\"this is blue color...\");       }      }   绿色： [java] view plaincopy public class GreenColor implements Color {          @Override       public void draw() {           System.out.println(\"this is green color...\");       }      }   Client [java] view plaincopy public class Client {          public static void main(String[] args) {           //生成五种颜色           Color blackColor = new BlackColor();           Color blueColor = new BlueColor();           Color greenColor = new GreenColor();           Color redColor = new RedColor();                      //生成三种笔           Brush smallBrush = new SmallBrush(redColor);           Brush middleBrush = new MiddleBrush();           //设置成蓝颜色           middleBrush.setColor(blueColor);           //默认黑颜色           Brush bigBrush = new BigBrush();                      //开始画           smallBrush.draw();           middleBrush.draw();           bigBrush.draw();                      //把大号笔换成绿颜色，中号换成黑颜色           bigBrush.setColor(greenColor);           middleBrush.setColor(blackColor);           bigBrush.draw();           middleBrush.draw();       }      }   再扩展下： 如果我们需要用不同颜色不同型号的笔画出不同的图形： 图形接口： [java] view plaincopy public interface Shape {       void create();   }   图形实现： 正方形： [java] view plaincopy public class Square implements Shape {          @Override       public void create() {           System.out.println(\"Square\");       }      }   圆形： [java] view plaincopy public class Circle implements Shape {          @Override       public void create() {           System.out.println(\"cricle\");       }      }   心形： [java] view plaincopy public class HeartShaped implements Shape {          @Override       public void create() {           System.out.println(\"love heart-shaped\");       }      }   修改一下画笔类： [java] view plaincopy public abstract class Brush {       Color mColor;       public Brush(Color color) {           mColor = color;       }              //默认画笔为黑色       public Brush() {           mColor = new BlackColor();       }              public void setColor(Color color) {           mColor = color;       }              public void drawShape(Shape shape){           draw();           shape.create();       }              public abstract void draw();   }   然后客户端调用： [java] view plaincopy public class Client {          public static void main(String[] args) {           //生成五种颜色           Color blackColor = new BlackColor();           Color blueColor = new BlueColor();           Color greenColor = new GreenColor();           Color redColor = new RedColor();                      //生成三种笔           Brush smallBrush = new SmallBrush(redColor);           Brush middleBrush = new MiddleBrush();           //设置成蓝颜色           middleBrush.setColor(blueColor);           //默认黑颜色           Brush bigBrush = new BigBrush();                      //开始画           smallBrush.draw();           middleBrush.draw();           bigBrush.draw();                      //把大号笔换成绿颜色，中号换成黑颜色           bigBrush.setColor(greenColor);           middleBrush.setColor(blackColor);           bigBrush.draw();           middleBrush.draw();                      //用小号笔画一个红心           smallBrush.drawShape(new HeartShaped());           //中号笔画一个黑色圆形           middleBrush.drawShape(new Circle());           //用大号笔画一个绿色正方形           bigBrush.drawShape(new Square());       }      }   模式优点： 分离抽象和实现部分 桥接模式分离了抽象部分和实现部分，从而极大地提高了系统的灵活性。让抽象部分和实现部分独立开来，分别定义接口，这有助于对系统进行分层，从而产生更好的结构化的系统。对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了。 更好的扩展性 由于桥接模式把抽象部分和实现部分分离开了，而且分别定义接口，这就使得抽象部分和实现部分可以分别独立地扩展，而不会相互影响，从而大大地提高了系统的可扩展性。 可动态地切换实现 由于桥接模式把抽象部分和实现部分分离开了，所以在实现桥接的时候，就可以实现动态的选择和使用具体的实现。也就是说一个实现不再是固定的绑定在一个抽象接口上了，可以实现运行期间动态地切换。 可减少子类的个数 根据前面的讲述，对于有两个变化纬度的情况，如果采用继承的实现方式，大约需要两个纬度上的可变化数量的乘积个子类；而采用桥接模式来实现，大约需要两个纬度上的可变化数量的和个子类。可以明显地减少子类的个数。 桥接模式的缺点 桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。 适用环境 如果你不希望在抽象部分和实现部分采用固定的绑定关系，可以采用桥接模式，来把抽象部分和实现部分分开，然后在程序运行期间来动态地设置抽象部分需要用到的具体的实现，还可以动态地切换具体的实现。 如果出现抽象部分和实现部分都能够扩展的情况，可以采用桥接模式，让抽象部分和实现部分独立地变化，从而灵活地进行单独扩展，而不是搅在一起，扩展一边就会影响到另一边。 如果希望实现部分的修改不会对客户产生影响，可以采用桥接模式。由于客户是面向抽象的接口在运行，实现部分的修改可以独立于抽象部分，并不会对客户产生影响，也可以说对客户是透明的。 如果采用继承的实现方案，会导致产生很多子类，对于这种情况，可以考虑采用桥接模式，分析功能变化的原因，看看是否能分离成不同的纬度，然后通过桥接模式来分离它们，从而减少子类的数目。 模式扩展 适配器模式与桥接模式 桥接模式和适配器模式用于设计的不同阶段，桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，当发现系统与已有类无法协同工作时，可以采用适配器模式。但有时候在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况。 桥接模式和策略模式 这两个模式有很大的相似之处。 如果把桥接模式的抽象部分简化来看，暂时不去扩展Abstraction，也就是去掉RefinedAbstraction。桥接模式简化后的结构图如图24.13所示。再看看策略模式的结构图，参见图17.1。会发现，这个时候它们的结构都类似图24.18所示。 这两个模式虽然相似，但也还是有区别的。最主要的是模式的目的不一样，策略模式的目的是封装一系列的算法，使得这些算法可以相互替换；而桥接模式的目的是分离抽象部分和实现部分，使得它们可以独立地变化。通过上面的结构图，可以体会到桥接模式和策略模式是如此相似。可以把策略模式的Context当做是使用接口的对象，而Strategy就是某个接口了，具体的策略实现就相当于接口的具体实现。这样看来的话，某些情况下，可以使用桥接模式来模拟实现策略模式的功能。 桥接模式和状态模式 由于从模式结构上看，状态模式和策略模式是一样的，因此这两个模式的关系也基本上类似于桥接模式和策略模式的关系。 只不过状态模式的目的是封装状态对应的行为，并在内部状态改变的时候改变对象的行为。 桥接模式和模板方法模式 这两个模式有相似之处。 虽然标准的模板方法模式是采用继承来实现的，但是模板方法也可以通过回调接口的方式来实现。如果把接口的实现独立出去，那就类似于模板方法通过接口去调用具体的实现方法了，这样的结构就和简化的桥接模式类似了。 可以使用桥接模式来模拟实现模板方法模式的功能。如果在实现Abstraction对象的时候，在其中定义方法，方法中就是某个固定的算法骨架，也就是说这个方法就相当于模板方法。在模板方法模式中，是把不能确定实现的步骤延迟到子类去实现；现在在桥接模式中，把不能确定实现的步骤委托给具体实现部分去完成，通过回调实现部分的接口，来完成算法骨架中的某些步骤。这样一来，就可以实现使用桥接模式来模拟实现模板方法模式的功能。 使用桥接模式来模拟实现模板方法模式的功能，还有一个潜在的好处，就是模板方法也可以很方便地扩展和变化。在标准的模板方法中，一个问题就是当模板发生变化的时候，所有的子类都要变化，非常不方便。而使用桥接模式来实现类似的功能，就没有这个问题。 另外，这里只是说从实现具体的业务功能上，桥接模式可以模拟实现模板方法模式能实现的功能，并不是说桥接模式和模板方法模式就变成一样的，或者是桥接模式就可以替换模板方法模式了。要注意它们本身的功能、目的、本质思想都是不一样的。 桥接模式和抽象工厂模式 这两个模式可以组合使用。 桥接模式中，抽象部分需要获取相应的实现部分的接口对象，那么谁来创建实现部分的具体实现对象呢？这就是抽象工厂模式派上用场的地方。也就是使用抽象工厂模式来创建和配置一个特定的具体的实现对象。 事实上，抽象工厂主要是用来创建一系列对象的，如果创建的对象很少，或者是很简单，还可以采用简单工厂，也能达到同样的效果，但是会比抽象工厂来得简单。 桥接模式和适配器模式 这两个模式可以组合使用。 这两个模式功能是完全不一样的，适配器模式的功能主要是用来帮助无关的类协同工作，重点在解决原本由于接口不兼容而不能一起工作的那些类，使得它们可以一起工作。而桥接模式则重点在分离抽象部分和实现部分。 所以在使用上，通常在系统设计完成以后，才会考虑使用适配器模式；而桥接模式。是在系统开始的时候就要考虑使用。 虽然功能上不一样，这两个模式还是可以组合使用的，比如，已有实现部分的接口，但是有些不太适应现在新的功能对接口的需要，完全抛弃吧，有些功能还用得上，该怎么办呢？那就使用适配器来进行适配，使得旧的接口能够适应新的功能的需要。","title":"浅学设计模式之桥接<bridge>模式"},{"content":"原型模式     GOOD：从一个对象再创建另外一个可定制的对象，而无需知道任何创建的细节。并能提高创建的性能。 说白了就COPY技术，把一个对象完整的COPY出一份。 转载请注明，文章来自：http://blog.csdn.net/windows_nt 例： #include<iostream>#include <vector>#include <string>using namespace std;class Prototype //抽象基类 { private:\tstring m_strName;public: \tPrototype(string strName) { m_strName = strName; }\tPrototype() { m_strName = \"我的名字叫刘彦敏，你呢？\"; }\tvoid Show() \t{\t\tcout<<m_strName<<endl;\t}\tvirtual Prototype* Clone() = 0 ; } ; // class ConcretePrototype1 class ConcretePrototype1 : public Prototype { public: \tConcretePrototype1(string strName) : Prototype(strName){}\tConcretePrototype1(){}\tvirtual Prototype* Clone() \t{ \t\tConcretePrototype1 *p = new ConcretePrototype1() ; \t\t*p = *this ; //复制对象 \t\treturn p ; \t} } ; // class ConcretePrototype2 class ConcretePrototype2 : public Prototype { public: \tConcretePrototype2(string strName) : Prototype(strName){}\tConcretePrototype2(){}\tvirtual Prototype* Clone() \t{ \t\tConcretePrototype2 *p = new ConcretePrototype2() ; \t\t*p = *this ; //复制对象 \t\treturn p ; \t} } ; //客户端int main(){\tConcretePrototype1* test = new ConcretePrototype1(\"刘彦敏\");\tConcretePrototype2* test2 = (ConcretePrototype2*)test->Clone();\ttest->Show();\ttest2->Show();\treturn 0;}","title":"设计模式学习-----原型模式"},{"content":"原型模式  : 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 类图： 代码： publicclass Propotype {     publicintid;     public String name;     public Propotype clone(){        returnthis.clone();     } } publicclass ConcretePropotype1 extends Propotype {     publicintage;         public Propotype clone(){        ConcretePropotype1 clone=new ConcretePropotype1();        clone.age=this.age;        clone.id=super.id;        clone.name=super.name;        return clone;     } } publicclass ConcretePropotype2 extends Propotype {     public String sex;         public Propotype clone(){        ConcretePropotype2 clone=new ConcretePropotype2();        clone.sex=this.sex;        clone.id=super.id;        clone.name=super.name;        return clone;     } } publicstaticvoid main(String[] args) {        Propotype obj=new ConcretePropotype2();        obj.name=\"jeor\";        Propotype obj2= obj.clone();        System.out.println(\"改变值前\");        System.out.println(obj.name);        System.out.println(obj2.name);               obj.name=\"JEOR\";        System.out.println(\"\\n改变值后\");        System.out.println(obj.name);        System.out.println(obj2.name);     } 看法： 原型模式就是克隆对象，克隆分为深克隆（对象里的对象也克隆）和浅克隆（对象里的对象是同一个对象）。java已经实现了此模式objec类的c lone方法，调用clone方法返回一个克隆体。","title":"原型模式"},{"content":"装饰模式     动态地给一个对象添加一些额外的职责（不重要的功能，只是偶然一次要执行），就增加功能来说，装饰模式比生成子类更为灵活。建造过程不稳定，按正确的顺序串联起来进行控制。     GOOD:当你向旧的类中添加新代码时，一般是为了添加核心职责或主要行为。而当需要加入的仅仅是一些特定情况下才会执行的特定的功能时（简单点就是不是核心应用的功  能），就会增加类的复杂度。装饰模式就是把要添加的附加功能分别放在单独的类中，并让这个类包含它要装饰的对象，当需要执行时，客户端就可以有选择地、按顺序地使用装  饰功能包装对象。 转载请注明，文章来自：http://blog.csdn.net/windows_nt 例: #include <string>#include <iostream>using namespace std;//人class Person{private:\tstring m_strName;public:\tPerson(string strName)\t{\t\tm_strName=strName;\t}\tPerson(){}\tvirtual void Show()\t{\t\tcout<<\"装扮的是:\"<<m_strName<<endl;\t}};//装饰类class Finery :public Person{protected:\tPerson* m_component;public:\tvoid Decorate(Person* component)\t{\t\tm_component=component;\t}\tvirtual void Show()\t{\t\t   m_component->Show();\t}};//T恤class TShirts: public Finery{public:\tvirtual void Show()\t{\t\tcout<<\"T Shirts\"<<endl;\t\tm_component->Show();\t}};//裤子class BigTrouser :public  Finery{public:\tvirtual void Show()\t{\t\tcout<<\" Big Trouser\"<<endl;\t\tm_component->Show();\t}};//客户端int main(){\tPerson *p=new Person(\"小李\");\tBigTrouser *bt=new BigTrouser();\tTShirts *ts=new TShirts();\tbt->Decorate(p);\tts->Decorate(bt);\tts->Show();\treturn 0;}","title":"设计模式学习-----装饰模式"},{"content":"策略模式 定义算法家族，分别封装起来，让它们之间可以互相替换，让算法变化，不会影响到用户 GOOD:适合类中的成员以方法为主，算法经常变动；简化了单元测试（因为每个算法都有自己的类，可以通过自己的接口单独测试。 　　策略模式和简单工厂基本相同，但简单工厂模式只能解决对象创建问题，对于经常变动的算法应使用策略模式。 BUG:客户端要做出判断 转载请注明，文章来自：http://blog.csdn.net/windows_nt 例： #include <iostream>using namespace std;class COperation{public:\tint m_nFirst;\tint m_nSecond;\tvirtual double GetResult()\t{\t\tdouble dResult=0;\t\treturn dResult;\t}};//策略具体类—加法类class AddOperation : public COperation{public:\tAddOperation(int a,int b)\t{\t\tm_nFirst=a;\t\tm_nSecond=b;\t}\tvirtual double GetResult()\t{\t\treturn m_nFirst+m_nSecond;\t}};class Context{private:\tCOperation* op;public:\tContext(COperation* temp)\t{\t\top=temp;\t}\tdouble GetResult()\t{\t\treturn op->GetResult();\t}};//客户端int main(){\tint a,b;\tchar c;\tcin>>a>>b;\tcout<<\"请输入运算符：\";\tcin>>c;\tContext *context = NULL;\tswitch(c)\t{\tcase '+':\t\tcontext = new Context(new AddOperation(a,b));\t\tcout<<context->GetResult()<<endl;\t\tbreak;\tdefault:\t\tcontext = new Context(new AddOperation(a,b));\t\tcout<<context->GetResult()<<endl;\t\tbreak;\t}\treturn 0;} 策略与工厂结合 GOOD:客户端只需访问Context类，而不用知道其它任何类信息，实现了低耦合。 在上例基础上，修改下面内容 class Context{private:\tCOperation* op;public:\tContext(char cType)\t{\t\tswitch (cType)\t\t{\t\tcase '+':\t\t\top=new AddOperation(3,8);\t\t\tbreak;\t\tdefault:\t\t\top=new AddOperation(3,8);\t\t\tbreak;\t\t}\t}\tdouble GetResult()\t{\t\treturn op->GetResult();\t}};//客户端int main(){\tint a,b;\tcin>>a>>b;\tContext *test=new Context('+');\tcout<<test->GetResult()<<endl;\treturn 0;} 单一职责原则 就一个类而言，应该仅有一个引起它变化的原因。 　　如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其它职责能力。这种耦合会导制脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。 　　如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。 开放――封闭原则 　　软件实体可以扩展，但是不可修改。即对于扩展是开放的，对于修改是封闭的。面对需求，对程序的改动是通过增加代码来完成的，而不是改动现有的代码。 　　当变化发生时，我们就创建抽象来隔离以后发生同类的变化。 　　开放――封闭原则是面向对象的核心所在。开发人员应该对程序中呈现出频繁变化的那部分做出抽象，拒绝对任何部分都刻意抽象及不成熟的抽象。 里氏代换原则 　　一个软件实体如果使用的是一个父类的话，那么一定适用其子类。而且它察觉不出父类对象和子类对象的区别。也就是说：在软件里面，把父类替换成子类，程序的行为没有变化。 　　子类型必须能够替换掉它们的父类型。 依赖倒转原则 　　抽象不应该依赖细节，细节应该依赖抽象。即针对接口编程，不要对实现编程。 　　高层模块不能依赖低层模块，两者都应依赖抽象。 　　依赖倒转原则是面向对象的标志，用哪种语言编写程序不重要，如果编写时考虑的是如何针对抽象编程而不是针对细节编程，即程序的所有依赖关系都终止于抽象类或接口。那就是面向对象设计，反之那就是过程化设计。","title":"设计模式学习-----策略模式"},{"content":"简单工厂模式 　　主要用于创建对象。新添加类时，不会影响以前的系统代码。核心思想是用一个工厂来根据输入的条件产生不同的类，然后根据不同类的virtual函数得到不同的结果。 GOOD:适用于不同情况创建不同的类时 BUG：客户端必须要知道基类和工厂类，耦合性差 转载请注明，文章来自：http://blog.csdn.net/windows_nt   例： #include <iostream>using namespace std;class COperation{public:\tint m_nFirst;\tint m_nSecond;\tvirtual double GetResult()\t{\t\tdouble dResult=0;\t\treturn dResult;\t}};//加法class AddOperation : public COperation{public:\tvirtual double GetResult()\t{\t\treturn m_nFirst+m_nSecond;\t}};//减法class SubOperation : public COperation{public:\tvirtual double GetResult()\t{\t\treturn m_nFirst-m_nSecond;\t}};//工厂类class CCalculatorFactory{public:\tstatic COperation* Create(char cOperator);};COperation* CCalculatorFactory::Create(char cOperator){\tCOperation *oper;\t//在C#中可以用反射来取消判断时用的switch，在C++中用什么呢？RTTI？？\tswitch (cOperator)\t{\tcase '+':\t\toper=new AddOperation();\t\tbreak;\tcase '-':\t\toper=new SubOperation();\t\tbreak;\tdefault:\t\toper=new AddOperation();\t\tbreak;\t}\treturn oper;}int main(){\tint a,b;\tcin >> a >> b;\tCOperation* op=CCalculatorFactory::Create('-');\top->m_nFirst=a;\top->m_nSecond=b;\tcout<<op->GetResult()<<endl;\treturn 0;}    ","title":"设计模式学习-----简单工厂模式"},{"content":"1、关联 双向关联： C1-C2：指双方都知道对方的存在，都可以调用对方的公共属性和方法。 在GOF的设计模式书上是这样描述的：虽然在分析阶段这种关系是适用的，但我们觉得它对于描述设计模式内的类关系来说显得太抽象了，因为在设计阶段关联关系必须被映射为对象引用或指针。对象引用本身就是有向的，更适合表达我们所讨论的那种关系。所以这种关系在设计的时候比较少用到，关联一般都是有向的。 使用ROSE 生成的代码是这样的： class C1  ...{ public:     C2* theC2; }; class C2  ...{ public:     C1* theC1; }; 双向关联在代码的表现为双方都拥有对方的一个指针，当然也可以是引用或者是值。 单向关联: C3->C4：表示相识关系，指C3知道C4，C3可以调用C4的公共属性和方法。没有生命期的依赖。一般是表示为一种引用。 生成代码如下： class C3  ...{ public:     C4* theC4; }; class C4  ...{ }; 单向关联的代码就表现为C3有C4的指针，而C4对C3一无所知。 自身关联（反身关联）： 自己引用自己，带着一个自己的引用。 代码如下： class C14  ...{ public:     C14* theC14; }; 就是在自己的内部有着一个自身的引用。 2、聚合/组合 当类之间有整体-部分关系的时候，我们就可以使用组合或者聚合。 聚合：表示C9聚合C10，但是C10可以离开C9而独立存在（独立存在的意思是在某个应用的问题域中这个类的存在有意义。这句话怎么解，请看下面组合里的解释）。 代码如下： class C9  ...{ public:     C10 theC10; }; class C10  ...{ };   组合（也有人称为包容）：一般是实心菱形加实线箭头表示，如上图所示，表示的是C8被C7包容，而且C8不能离开C7而独立存在。但这是视问题域而定的，例如在关心汽车的领域里，轮胎是一定要组合在汽车类中的，因为它离开了汽车就没有意义了。但是在卖轮胎的店铺业务里，就算轮胎离开了汽车，它也是有意义的，这就可以用聚合了。在《敏捷开发》中还说到，A组合B，则A需要知道B的生存周期，即可能A负责生成或者释放B，或者A通过某种途径知道B的生成和释放。 他们的代码如下： class C7  ...{ public:     C8 theC8; }; class C8  ...{ }; 可以看到，代码和聚合是一样的。具体如何区别，可能就只能用语义来区分了。 3、依赖 依赖: 指C5可能要用到C6的一些方法，也可以这样说，要完成C5里的所有功能，一定要有C6的方法协助才行。C5依赖于C6的定义，一般是在C5类的头文件中包含了C6的头文件。ROSE对依赖关系不产生属性。 注意，要避免双向依赖。一般来说，不应该存在双向依赖。 ROSE生成的代码如下： // C5.h #include \"C6.h\" class C5  ...{ }; // C6.h #include \"C5.h\" class C6 ...{ }; 虽然ROSE不生成属性，但在形式上一般是A中的某个方法把B的对象作为参数使用(假设A依赖于B)。如下： #include \"B.h\" class A ...{           void Func(B &b); } 那依赖和聚合\\组合、关联等有什么不同呢？ 关联是类之间的一种关系，例如老师教学生，老公和老婆，水壶装水等就是一种关系。这种关系是非常明显的，在问题领域中通过分析直接就能得出。 依赖是一种弱关联，只要一个类用到另一个类，但是和另一个类的关系不是太明显的时候（可以说是“uses”了那个类），就可以把这种关系看成是依赖，依赖也可说是一种偶然的关系，而不是必然的关系，就是“我在某个方法中偶然用到了它，但在现实中我和它并没多大关系”。例如我和锤子，我和锤子本来是没关系的，但在有一次要钉钉子的时候，我用到了它，这就是一种依赖，依赖锤子完成钉钉子这件事情。 组合是一种整体-部分的关系，在问题域中这种关系很明显，直接分析就可以得出的。例如轮胎是车的一部分，树叶是树的一部分，手脚是身体的一部分这种的关系，非常明显的整体-部分关系。 上述的几种关系（关联、聚合/组合、依赖）在代码中可能以指针、引用、值等的方式在另一个类中出现，不拘于形式，但在逻辑上他们就有以上的区别。 这里还要说明一下，所谓的这些关系只是在某个问题域才有效，离开了这个问题域，可能这些关系就不成立了，例如可能在某个问题域中，我是一个木匠，需要拿着锤子去干活，可能整个问题的描述就是我拿着锤子怎么钉桌子，钉椅子，钉柜子；既然整个问题就是描述这个，我和锤子就不仅是偶然的依赖关系了，我和锤子的关系变得非常的紧密，可能就上升为组合关系（让我突然想起武侠小说的剑不离身，剑亡人亡...）。这个例子可能有点荒谬，但也是为了说明一个道理，就是关系和类一样，它们都是在一个问题领域中才成立的，离开了这个问题域，他们可能就不复存在了。 4、泛化（继承） 泛化关系：如果两个类存在泛化的关系时就使用，例如父和子，动物和老虎，植物和花等。 ROSE生成的代码很简单，如下： #include \"C11.h\" class C12 : public C11 ...{ }; 5、这里顺便提一下模板 上面的图对应的代码如下： template<int> class C13  ...{ }; 这里再说一下重复度，其实看完了上面的描述之后，我们应该清楚了各个关系间的关系以及具体对应到代码是怎么样的，所谓的重复度，也只不过是上面的扩展，例如A和B有着“1对多”的重复度，那在A中就有一个列表，保存着B对象的N个引用，就是这样而已。 好了，到这里，已经把上面的类图关系说完了，希望你能有所收获了，我也费了不少工夫啊（画图、生成代码、截图、写到BLOG上，唉，一头大汗）。不过如果能让你彻底理解UML类图的这些关系，也值得了。:) +++++++++++++++++++++++++++++++++++++++++++++++++++++ 在UML建模中，对类图上出现元素的理解是至关重要的。开发者必须理解如何将类图上出现的元素转换到Java中。以java为代表结合网上的一些实例，下面是个人一些基本收集与总结：   基本元素符号：   1. 类（Classes） 类包含3个组成部分。第一个是Java中定义的类名。第二个是属性（attributes）。第三个是该类提供的方法。 属性和操作之前可附加一个可见性修饰符。加号（+）表示具有公共可见性。减号（-）表示私有可见性。#号表示受保护的可见性。省略这些修饰符表示具有package（包）级别的可见性。如果属性或操作具有下划线，表明它是静态的。在操作中，可同时列出它接受的参数，以及返回类型，如下图所示：   　　2. 包（Package） 包是一种常规用途的组合机制。UML中的一个包直接对应于Java中的一个包。在Java中，一个包可能含有其他包、类或者同时含有这两者。进行建模时，你通常拥有逻辑性的包，它主要用于对你的模型进行组织。你还会拥有物理性的包，它直接转换成系统中的Java包。每个包的名称对这个包进行了惟一性的标识。 　　3. 接口（Interface） 接口是一系列操作的集合，它指定了一个类所提供的服务。它直接对应于Java中的一个接口类型。接口既可用下面的那个图标来表示（上面一个圆圈符号，圆圈符号下面是接口名，中间是直线，直线下面是方法名），也可由附加了<<interface>>的一个标准类来表示。通常，根据接口在类图上的样子，就能知道与其他类的关系。 关　系：   1. 依赖（Dependency） 实体之间一个“使用”关系暗示一个实体的规范发生变化后，可能影响依赖于它的其他实例。更具体地说，它可转换为对不在实例作用域内的一个类或对象的任何类型的引用。其中包括一个局部变量，对通过方法调用而获得的一个对象的引用（如下例所示），或者对一个类的静态方法的引用（同时不存在那个类的一个实例）。也可利用“依赖”来表示包和包之间的关系。由于包中含有类，所以你可根据那些包中的各个类之间的关系，表示出包和包的关系。 　　2. 关联（Association） 实体之间的一个结构化关系表明对象是相互连接的。箭头是可选的，它用于指定导航能力。如果没有箭头，暗示是一种双向的导航能力。在Java中，关联转换为一个实例作用域的变量，就像图E的“Java”区域所展示的代码那样。可为一个关联附加其他修饰符。多重性（Multiplicity）修饰符暗示着实例之间的关系。在示范代码中，Employee可以有0个或更多的TimeCard对象。但是，每个TimeCard只从属于单独一个Employee。     3. 聚合（Aggregation） 聚合是关联的一种形式，代表两个类之间的整体/局部关系。聚合暗示着整体在概念上处于比局部更高的一个级别，而关联暗示两个类在概念上位于相同的级别。聚合也转换成Java中的一个实例作用域变量。 关联和聚合的区别纯粹是概念上的，而且严格反映在语义上。聚合还暗示着实例图中不存在回路。换言之，只能是一种单向关系。 　　4. 合成（Composition） 合成是聚合的一种特殊形式，暗示“局部”在“整体”内部的生存期职责。合成也是非共享的。所以，虽然局部不一定要随整体的销毁而被销毁，但整体要么负责保持局部的存活状态，要么负责将其销毁。 局部不可与其他整体共享。但是，整体可将所有权转交给另一个对象，后者随即将承担生存期职责。Employee和TimeCard的关系或许更适合表示成“合成”，而不是表示成“关联”。 　　5. 泛化（Generalization） 泛化表示一个更泛化的元素和一个更具体的元素之间的关系。泛化是用于对继承进行建模的UML元素。在Java中，用extends关键字来直接表示这种关系。   　　6. 实现（Realization） 实例关系指定两个实体之间的一个合同。换言之，一个实体定义一个合同，而另一个实体保证履行该合同。对Java应用程序进行建模时，实现关系可直接用implements关键字来表示。 像聚合还分为：非共享聚合、共享聚合、复合聚合等。以及其它内容，下次再补充。","title":"UML类图关系大全"},{"content":"工厂方法模式  ：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 类图： 实现代码： class Product {} class ConcreteProduct extends Product {} abstractclass Creator {     publicabstract Product factoryMethod(); } class ConcreteCreator extends Creator {     @Override     public Product factoryMethod() {        returnnew ConcreteProduct();     }   } publicstaticvoid main(String[] args) {        //1.创建对应的工厂对象        Creator factory=new ConcreteCreator();        //2.工厂对象生产产品        Product product=factory.factoryMethod();        //3.得到产品        System.out.println(product);     } 运行结果： Factory_Method.ConcreteProduct@1bab50a 得到的是ConcreteProduct对象。 优点：封装了产品对象的创建过程；因为有Creator作为父类，如果想要扩展直接添加其子类就可以了。这样扩展性比较高。。   缺点：产品类和工厂类的耦合度很高。 简单工厂和工厂方法的区别：个人认为简单工厂和工厂方法最大的区别就是简单工厂需要判断参数来产生对象，但如果简单工厂和工厂方法用上反射后差别并不大。但还是有的，简单工厂+反射只能返回产品；工厂方法+反射可以在创建对象的时候做其他事情（输出helloWord）。所以初始化时不需要做额外的东西可以用简单工厂。","title":"工厂方法"},{"content":"设计模式主要分三个类型:创建型、结构型和行为型。 工厂模式属于创建型的设计模式 工厂模式主要是为创建对象提供过渡接口，以便创建对象具体过程屏蔽隔离起来，达到提高灵活性的目的。 其中工厂模式又分为三类 1）简单工厂模式（Simple Factory） 2）工厂方法模式（Factory Method） 3）抽象工厂模式（Abstract Factory） 这三种模式从上到下逐步抽象，并且更具一般性。 GOF在《设计模式》一书中讲工厂模式分为两类：工厂方法模式（Factory Method）和抽象工厂模式（Abstract Factory）， 将简单工厂模式（Simple Factory）看做工厂方法模式（Factory Method）的一种特例，两者归为一类。   下面我们来介绍下简单工厂模式（Simple Factory） 简单工厂模式又称作静态工厂方法模式。重命名上就可以看出这种模式一定很简单，它存在的目的很简单：定义一个用户创建对象的接口。 先看看它的组成 1）工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑。在java中它往往由一个具体类实现。 2）抽象产品角色：它一般是由具体产品继承的父类或者实现的接口。在java中它往往由一个抽象类或者接口实现。 3）具体产品角色：工厂类所创建的对象就是此角色的实例。在java中它往往由一个具体类实现。   抽象产品角色（我们定义了一个打印机） public interface Printer{\tpublic void out();\t\tpublic void getData(String msg);} 具体产品角色 具体产品角色（我们定义两个产品，一个是普通打印机，一个是高速打印机） 普通打印机 public class CommonPrinter implements Printer{\tprivate  final int MAX_CACHE_LINE = 10;\tprivate String[] printData = new String[MAX_CACHE_LINE];\t\tprivate int dataNum = 0;\t@Override\tpublic void getData(String msg)\t{\t\tif(dataNum >= MAX_CACHE_LINE)\t\t{\t\t\tSystem.out.println(\"输出队列已满,添加失败\");\t\t}\t\telse\t\t{\t\t\tprintData[dataNum++] = msg;\t\t}\t}\t@Override\tpublic void out()\t{\t\twhile(dataNum>0)\t\t{\t\t\tSystem.out.println(\"普通打印机打印: \"+printData[0]);\t\t\t\t\t\tSystem.arraycopy(printData,1,printData,0,--dataNum);\t\t}\t}}    高速打印机 public class BetterPrinter implements Printer{\tprivate  final int MAX_CACHE_LINE = 10;\tprivate String[] printData = new String[MAX_CACHE_LINE * 2];\t\tprivate int dataNum = 0;\t@Override\tpublic void getData(String msg)\t{\t\tif(dataNum >= MAX_CACHE_LINE * 2)\t\t{\t\t\tSystem.out.println(\"输出队列已满,添加失败\");\t\t}\t\telse\t\t{\t\t\tprintData[dataNum++] = msg;\t\t}\t}\t@Override\tpublic void out()\t{\t\twhile(dataNum>0)\t\t{\t\t\tSystem.out.println(\"高速打印机打印: \"+printData[0]);\t\t\t\t\t\tSystem.arraycopy(printData,1,printData,0,--dataNum);\t\t}\t}} 工厂类角色 public class PrinterFactory{\tpublic Printer getPrinter(String type)\t{\t\tif(\"common\".equals(type))\t\t{\t\t\treturn new CommonPrinter();\t\t}\t\telse if(\"better\".equals(type))\t\t{\t\t\treturn new BetterPrinter();\t\t}\t\telse \t\t{\t\t\treturn null;\t\t}\t}}    最后是测试了，我们定义一台计算机，由它调用工厂去生产我们需要的打印机 public class Computer{\tprivate Printer out;\tpublic Computer(Printer out)\t{\t\tthis.out = out;\t}\tpublic void keyIn(String msg)\t{\t\tout.getData(msg);\t}\tpublic void print()\t{\t\tout.out();\t}\tpublic static void main(String[] args)\t{\t\tPrinterFactory of = new PrinterFactory();\t\t\t\tComputer c = new Computer(of.getPrinter(\"common\"));\t\t\t\tc.keyIn(\"hello\");\t\tc.keyIn(\"world\");\t\t\t\tc.print();\t}} 这便是简单工厂模式了，怎么样使用起来简单吧，那么它带来了什么好处呢？ 首先使用了简单工厂模式后，我们的程序不在“有病”，更加符合现实中的情况，而且客户端避免除了直接创建产品对象的责任，而仅仅负责“消费”产品  ","title":"java设计模式（1）：简单工厂模式（Simple Factory）"},{"content":"参考：http://blog.csdn.net/cjjky/article/details/7318506 【1】基本概念        Singleton 是一种创建性模式,它用来确保只产生一个实例,并提供一个访问它的全局访问点。对一些类来说,保证只有一个实例是很重要的，比如有的时候，数据库连接或 Socket 连接要受到一定的限制,必须保持同一时间只能有一个连接的存在。 【2】简单分析         我们先来看一下该设计模式的UML结构图： 为了实现 Singleton 模式，我们需要的是一个静态的变量，能够在不创建对象的情况下记忆是否已经产生过实例了。静态变量或静态方法都可以在不产生具体实例的情况下直接调用,这样的变量或方法不会因为类的实例化而有所改变。在上面的模式结构图中的 uniqueInstance 就是这个独立的静态变量，它可以记忆对象是否已经实例化了，在静态方法 getInstance() 中对这个变量进行判断，若没有实例化过就产生一个新的对象，如果已经实例化了则不再产生新的对象，仍然返回以前产生的实例。 【3】如何用java语言来实现该设计模式：以下采用2种方法来实现该模式。 第一种方法：用静态方法实现 Singleton 这种方法是使用静态方法来监视实例的创建。为了防止创建一个以上的实例，我们把构造器声明为 private。这样可以防止客户端程序员通过除由我们提供的方法之外的任意方式来创建一个实例。如果不把构造器声明为private，编译器则会创建一个默认的public的构造器。 具体实现的代码如下： package com.andyidea.patterns.singleton;public class Singleton {\t\tprivate static Singleton s;\t\t/**\t * 把构造函数设置为private\t */\tprivate Singleton(){\t\t\t}\t\t/**\t * 实例化对象的唯一接口\t * @return\t */\tpublic static Singleton getInstance(){\t\tif(s == null){\t\t\ts = new Singleton();\t\t}\t\treturn s;\t}} 测试类代码如下： package com.andyidea.patterns.client;import com.andyidea.patterns.singleton.Singleton;/** * 设计模式测试类 * @author Andy.Chen * */public class MainClient {\tpublic static void main(String[] args) {\t    Singleton s1 = Singleton.getInstance();\t    Singleton s2 = Singleton.getInstance();\t    \t    System.out.println(\"Welcome to Andy.Chen Blog!\" +\"\\n\" \t\t           +\"Singleton Patterns.\" +\"\\n\"\t\t           +\"-------------------------------\");\t    \t    if (s1==s2)\t      System.out.println(\"s1 is the same instance with s2\");\t    else\t      System.out.println(\"s1 is not the same instance with s2\");\t}} 程序运行的结果如下： Welcome to Andy.Chen Blog!Singleton Patterns.-------------------------------s1 is the same instance with s2 第二种方法：以静态变量为标志实现 Singleton 在类中嵌入一个静态变量做为标志，每次都在进入构造器的时候进行检查。问题在于构造器没有返回类型，如果确定创建一个实例成功与否.一个方法是调用一个函数来检查创建是否成功，然后简单的返回一个来自静态变量的值,但是这样做是不优雅的，而且容易发生错误。比较好的做法是创建一个当创建了一个以上的实例时可以抛出异常的类，这个类仅仅是调用父类方法，好处是用了自己创建的异常类型，错误信息更加清晰。 具体实现的代码如下： package com.andyidea.patterns.singleton;public class Singleton {\t\t  static boolean instance_flag = false;\t  public Singleton() {\t    if (instance_flag)\t      throw new SingletonException(\"Only one instance allowed\");\t    else\t      instance_flag = true;\t  }} 异常类代码如下： package com.andyidea.patterns.singleton;/** * 异常类 * @author Andy.Chen * */public class SingletonException extends RuntimeException{\tpublic SingletonException(String exception){\t\tsuper(exception);\t}} 测试类代码如下： package com.andyidea.patterns.client;import com.andyidea.patterns.singleton.Singleton;import com.andyidea.patterns.singleton.SingletonException;/** * 设计模式测试类 * @author Andy.Chen * */public class MainClient {\tpublic static void main(String[] args) {\t\t\t    System.out.println(\"Welcome to Andy.Chen Blog!\" +\"\\n\"         +\"Singleton Patterns.\" +\"\\n\"        +\"-------------------------------\");\t    \t    Singleton s1, s2;\t    // create one incetance--this should always work\t    System.out.println(\"Creating one instance\");\t    try {\t      s1 = new Singleton();\t    } catch (SingletonException e) {\t      System.out.println(e.getMessage());\t    }\t    // try to create another incetanced\t    System.out.println(\"Creating two instance\");\t    try {\t      s2 = new Singleton();\t    } catch (SingletonException e) {\t      System.out.println(e.getMessage());\t    }\t}} 运行结果如下： Welcome to Andy.Chen Blog!Singleton Patterns.-------------------------------Creating one instanceCreating two instanceOnly one instance allowed 从输出的结果可以看出，第一个实例可以顺利创建，创建第二个实例的时候抛出了我们自定义的异常信息。","title":"设计模式之一 Singleton (单例)模式"},{"content":"Singleton pattern Singleton模式在维基百科上的定义如下： In computer science, the singleton design pattern is designed to restrict instantiation of aclass to one (or a few) objects. This is useful when exactly one object is needed to coordinate actionsacross the system. Sometimes it is generalized to systems that operate moreefficiently when only one or a few objects exist. It is also considered an Anti-patternsince it is often used as a politically correct term for global variable -andhence frowned upon. 翻译成中文如下： Singleton模式是用于限制类的实例对象个数到一个（或一些）。系统中当需要一个具有特定的功能的对象时比较有用，因为有时当只有一个或者有限个的对象存在是系统运行的效率比较高。同样也因为全局特性被看成是Anti- pattern！ 可以说这个解释是相当完美的，如下提供代码的实现来看看具体的功能特性。 [code = cpp] // singleton.cpp #     include <iostream> using namespace std;   template <typename _Tp> class Singleton { public:        typedef _Tp value_type;          ~Singleton()        {               if(_instance != NULL)               {                      delete_instance;                      _instance =NULL;               }        }          // singleton implement        // tip: the retrieved variableshould be a pointer instead of a reference        // if so all the things wouldrefer to the singleton rather than assignment of which        //static Singleton&instance()        static Singleton* instance()        {               if(_instance == NULL)               {                      _instance = newSingleton();               }                 //if(_instance != NULL)               //{               //     return *_instance;               //}               return _instance;        }          _Tp& data()        {               return _data;        } private:        static Singleton * _instance;   private:        Singleton(){}        Singleton& operator=(const Singleton&){} private:        _Tp _data; };   template <typename _Tp> Singleton<_Tp> * Singleton<_Tp>::_instance = NULL;   void main() {        // Singleton<int> sngltn= Singleton<int>::instance();        // theSingleton<int>::instance() impls as following within class singleton        // static Singleton&instance() { // ... }        // this line calls instance()and initializes sngltn just as default assignment        // which means modificationson sngltn won't affect the singleton instance.          Singleton<int> * ps1 =Singleton<int>::instance();           ps1->data() = 1;        Singleton<int> * ps2 =Singleton<int>::instance();        ps2->data() = 2;        cout << ps1->data()<< endl;         // output ”2” interminer } [/code] 从代码可以看出在main中使用时不需要了解有多少个指针引用了The Singleton Object只需要调用instance()就可以引用了。但是正如定义中指出，The Singleton Object具有全局特性不同的地方引用时使用的是同一个对象那么就会出现一个安全隐患！ 本人在实现的过程中是通过使用模板来实现泛化的，此外还添加了 associated type特性只要对模板类进行特化基本上就可以添加到自己的STL中了。 那么就剩下最后一个问题了：用Singleton来实现什么功能呢？这个问题先留着。","title":"Singleton Pattern"},{"content":"外观模式 GOOD：为子系统的一组接口提供一个一致的界面。使用户使用起来更加方便。 转载请注明，文章来自：http://blog.csdn.net/windows_nt 例： #include<iostream>#include <string>using namespace std;class SubSysOne{public:\tvoid MethodOne()\t{\t\tcout<<\"方法一\"<<endl;\t}};class SubSysTwo{public:\tvoid MethodTwo()\t{\t\tcout<<\"方法二\"<<endl;\t}};class SubSysThree{public:\tvoid MethodThree()\t{\t\tcout<<\"方法三\"<<endl;\t}};//外观类class Facade{private:\tSubSysOne* sub1;\tSubSysTwo* sub2;\tSubSysThree* sub3;public:\tFacade()\t{\t\tsub1 = new SubSysOne();\t\tsub2 = new SubSysTwo();\t\tsub3 = new SubSysThree();\t}\t~Facade()\t{\t\tdelete sub1;\t\tdelete sub2;\t\tdelete sub3;\t}\tvoid FacadeMethod()\t{\t\tsub1->MethodOne();\t\tsub2->MethodTwo();\t\tsub3->MethodThree();\t}};//客户端int main(){\tFacade* test = new Facade();\ttest->FacadeMethod();\treturn 0;}  ","title":"设计模式学习-----外观模式"},{"content":"概述      迭代器（Iterator）模式，又叫做游标（Cursor）模式。GOF给出的定义为：提供一种方法访问一个容器（container）对象中各个元素，而又不需暴露该对象的内部细节。 在面向对象的软件设计中，我们经常会遇到一类集合对象，这类集合对象的内部结构可能有着各种各样的实现，但是归结起来，无非有两点是需要我们去关心的：一是集合内部的数据存储结构，二是遍历集合内部的数据。面向对象设计原则中有一条是类的单一职责原则，所以我们要尽可能的去分解这些职责，用不同的类去承担不同的职责。Iterator模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明的访问集合内部的数据。 1.通俗的来说，就是，别人可能要用到我们的容器元素，但是我只想让他用元素，不想让他知道容器是怎么样的。也就是最基本的，访问各个元素而不暴露容器内部细节。 2.我们有可能以一种以上的方式遍历容器元素 3.同时对容器元素进行多次遍历。因为迭代器会保存当前的遍历状态，所以可以通过迭代器模式来达到这种需求。 意图     提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。[GOF 《设计模式》] 结构图     Iterator模式结构图如下： 由下面四个角色： 　　1) 迭代器角色（Iterator）：迭代器角色负责定义访问和遍历元素的接口。 　　2) 具体迭代器角色（Concrete Iterator）：具体迭代器角色要实现迭代器接口，并要记录遍历中的当前位置。 　　3) 容器角色（Container）：容器角色负责提供创建具体迭代器角色的接口。 　　4) 具体容器角色（Concrete Container）：具体容器角色实现创建具体迭代器角色的接口——这个具体迭代器角色于该容器的结构相关。 代码小例子        迭代器(Iterator) [java] view plaincopy public interface Iterator {       String next();       boolean haveNext();   }       具体迭代器角色（Concrete Iterator） [java] view plaincopy public class TVChannel implements Iterator{       private String[] tvChannel ={\"cctv-1\",\"cctv-2\",\"cctv-3\",\"cctv-4\",\"cctv-5\",\"cctv-6\",\"cctv-7\"};       private int current = 0;       @Override       public String next() {           if(haveNext()){               return tvChannel[current++];           }           return null;           // TODO Auto-generated method stub                  }          @Override       public boolean haveNext() {           // TODO Auto-generated method stub                      if(current<tvChannel.length){               return true;           }           return false;       }      }   容器角色（Container） [java] view plaincopy public interface IContainer {       Iterator createrIterator();   }   具体容器角色（Concrete Container）： [java] view plaincopy public class TV implements IContainer{       public TV(){           System.out.println(\"open a tv\");       }       public Iterator createrIterator(){           return new TVChannel();       }   }   测试使用： [java] view plaincopy public static void main(String[] args) {           // TODO Auto-generated method stub           IContainer tv = new TV();           Iterator iterator = tv.createrIterator();           while(iterator.haveNext()){               System.out.println(\"TVChennel:\"+iterator.next());           }       }   一个简单的容器为什么还要定义成一个接口呢？想想针对接口编程，不针对具体实现编程！如果要拓展，使用接口更方便些。 测试结果： [java] view plaincopy open a tv   TVChennel:cctv-1   TVChennel:cctv-2   TVChennel:cctv-3   TVChennel:cctv-4   TVChennel:cctv-5   TVChennel:cctv-6   TVChennel:cctv-7   效果及实现要点    迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示。    迭代多态：为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。    迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题。 总结     Iterator模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明的访问集合内部的数据。 迭代器模式的作用： 它支持以不同的方式遍历一个聚合对象 ： 复杂的聚合可用多种方式进行遍历。迭代器模式使得改变遍历算法变得很容易 : 仅需用一个不同的迭代器的实例代替原先的实例即可。你也可以自己定义迭代器的子类以支持新的遍历。  迭代器简化了聚合的接口 有了迭代器的遍历接口，聚合本身就不再需要类似的遍历接口了。这样就简化了聚合的接口。 在同一个聚合上可以有多个遍历 每个迭代器保持它自己的遍历状态。因此你可以同时进行多个遍历。 在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足“开闭原则”的要求。 迭代器模式的缺点        由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。 适用情况 由上面的讲述，我们可以看出迭代器模式给容器的应用带来以下好处： 　　支持以不同的方式遍历一个容器角色。根据实现方式的不同，效果上会有差别。 　　简化了容器的接口。但是在java Collection中为了提高可扩展性，容器还是提供了遍历的接口。 　　对同一个容器对象，可以同时进行多个遍历。因为遍历状态是保存在每一个迭代器对象中的。 　　由此也能得出迭代器模式的适用范围： 　　访问一个容器对象的内容而无需暴露它的内部表示。 　　支持对容器对象的多种遍历。 　　为遍历不同的容器结构提供一个统一的接口（多态迭代）。","title":"浅学设计模式之迭代器<Iterator>模式"},{"content":"外观模式是软件工程中常用的一种软件设计模式。它为子系统中的一组接口提供一个统一的高层接口。使用子系统更容易使用。 下图是状态模式的UML图。   结构 　　Facade 　　这个外观类为子系统中Packages 1、2、3提供一个共同的对外接口 　　Clients 　　客户对象通过一个外观接口读写子系统中各接口的数据资源。 　　Packages 　　客户可以通过外观接口读取的内部库。    下面看下一个小例子吧，看DVD的故事： 先得有个电视： [java] view plaincopy public class TV {       public void turnOn(){           System.out.println(\"打开电视\");       }              public void turnOff(){           System.out.println(\"关闭电视\");       }   }   ＤＶＤ： [java] view plaincopy public class DVD {       public void turnOn(){           System.out.println(\"打开DVD\");       }              public void putDVD(MovieDisc movie){           System.out.println(\"放进碟片\");           System.out.println(\"现在开始播放：\"+movie.getMovieName());       }              public void takeOut(MovieDisc movie){           System.out.println(\"停止播放：\"+movie.getMovieName());           System.out.println(\"取出碟片\");       }              public void turnOff(){           System.out.println(\"关闭DVD\");       }   }   影片： [java] view plaincopy public class MovieDisc {       private String movieName ;              public MovieDisc(String movieName){           this.movieName = movieName;           System.out.println(\"这个电影名字叫做：\"+movieName);       }              public String getMovieName(){           return movieName;       }   }   我们想看电影的时候： [java] view plaincopy //打开电视，dvd，放进影片，开始看电影           tv.turnOn();           dvd.turnOn();           dvd.putDVD(movie);                      //看完了，接着看另外一部           dvd.takeOut(movie);           MovieDisc movie2 = new MovieDisc(\"黄金大劫案\");           dvd.putDVD(movie2);                      //看完了，关机睡觉           dvd.takeOut(movie);           dvd.turnOff();           tv.turnOff();   客户调用非常复杂，什么事都得自己做。。。 使用外观模式： [java] view plaincopy public class HomeTheater {       DVD dvd = null;       TV tv =null;       MovieDisc movie = null;              public HomeTheater(DVD dvd,TV tv,MovieDisc movie){           this.dvd = dvd;           this.movie = movie;           this.tv =tv;       }              public void watchMovie() {           tv.turnOn();           dvd.turnOn();           dvd.putDVD(movie);       }              public void endMovie(){           dvd.takeOut(movie);           dvd.turnOff();           tv.turnOff();       }              public void chageMovie(MovieDisc movie2){           dvd.takeOut(movie);           dvd.putDVD(movie2);           this.movie = movie2;       }          }   当想看电影的时候呢： [java] view plaincopy HomeTheater homeTheater = new HomeTheater(dvd, tv, movie);           homeTheater.watchMovie();           homeTheater.chageMovie(movie2);           homeTheater.endMovie();   只需要调用几个简单的接口就可以了。 看下完整的测试类： [java] view plaincopy public class Tets {       public static void main(String[] args){           //生成电视,DVD,碟片           TV tv = new TV();           DVD dvd = new DVD();           MovieDisc movie = new MovieDisc(\"桃姐\");           //打开电视，dvd，放进影片，开始看电影           tv.turnOn();           dvd.turnOn();           dvd.putDVD(movie);                      //看完了，接着看另外一部           dvd.takeOut(movie);           MovieDisc movie2 = new MovieDisc(\"黄金大劫案\");           dvd.putDVD(movie2);                      //看完了，关机睡觉           dvd.takeOut(movie);           dvd.turnOff();           tv.turnOff();                                            System.out.println(\"--------使用家庭影院-------\");           HomeTheater homeTheater = new HomeTheater(dvd, tv, movie);           homeTheater.watchMovie();           homeTheater.chageMovie(movie2);           homeTheater.endMovie();       }   }   结果： 这个电影名字叫做：桃姐 打开电视 打开DVD 放进碟片 现在开始播放：桃姐 停止播放：桃姐 取出碟片 关闭DVD 关闭电视 停止播放：桃姐 取出碟片 这个电影名字叫做：黄金大劫案 放进碟片 现在开始播放：黄金大劫案 --------使用家庭影院------- 打开电视 打开DVD 放进碟片 现在开始播放：桃姐 停止播放：桃姐 取出碟片 放进碟片 现在开始播放：黄金大劫案 停止播放：黄金大劫案 取出碟片 关闭DVD 关闭电视 客户端，只短短调用几行代码，就实现了功能，没那么繁琐。 注意和其他设计模式的区别   代理模式 1 代理模式中的原类和代理类继承同一父类； 2 原类对象与代理类对象接口相同，功能一致； 3 起到了隐藏原类的作用。 适配器模式 1 只有适配器继承目标接口； 2 将原有类接口转换为目标代码需求的接口。 外观模式 是多个类的集成、统一适配。 学习外观模式很好的资料： http://www.cnblogs.com/hegezhou_hot/archive/2010/12/06/1897398.html","title":"浅学设计模式之外观<Facade>模式"},{"content":"模板方法模式                  GOOD：把不变的代码部分都转移到父类中，将可变的代码用virtual留到子类重写。 迪米特法则 　　　　　如果两个类不直接通信，那么这两个类就不应当发生直接的相互作用。如果一个类需要调用另一个类的某个方法的话，可以通过第三个类转发这个调用。 　　　　　在类的结构设计上，每一个类都应该尽量降低成员的访问权限。                  该法则在后面的适配器模式、解释模式等中有强烈的体现。   转载请注明，文章来自：http://blog.csdn.net/windows_nt 例： #include<iostream>#include <vector>#include <string>using namespace std;class AbstractClass{public:\tvoid Show()\t{\t\tcout<<\"我是\"<<GetName()<<endl;\t}protected:\tvirtual string GetName()=0;};class Naruto : public AbstractClass{protected:\tvirtual string GetName()\t{\t\treturn \"火影史上最帅的六代目---一鸣惊人naruto\";\t}};class OnePice : public AbstractClass{protected:\tvirtual string GetName()\t{\t\treturn \"我是无恶不做的大海贼---路飞\";\t}};//客户端int main(){\tNaruto* man = new Naruto();\tman->Show();\tOnePice* man2 = new OnePice();\tman2->Show();\treturn 0;}","title":"设计模式学习-----模板方法模式"},{"content":"State模式定义：       不同的状态,不同的行为; 或者说,每个状态有着相应的行为. 使用情况：         状态模式在工作流或游戏等各种系统中有大量使用，甚至是这些系统的核心功能设计，例如在典型的OA中，一个批文的状态有多种：未办；正在办理；正在批示；正在审核；已经完成等各种状态，使用状态机可以封装这个状态的变化规则，从而达到扩充状态时，不必涉及到状态的使用者。        在网游中，一个游戏活动存在开始、开玩、正在玩、输赢等状态，使用状态模式就可以实现游戏状态的总控，而游戏状态决定了游戏的各个方面，使用状态模式可以对整个游戏架构功能实现起到决定的主导作用。         状态模式可以有效的替换充满在程序中的if else语句：将不同条件下的行为封装在一个类里面，再给这些类一个统一的父类来约束他们。看一下状态模式的角色组成： 使用环境（Context）角色：客户程序是通过它来满足自己的需求。它定义了客户程序需要的接口；并且维护一个具体状态角色的实例，这个实例来决定当前的状态。  状态（State）角色：定义一个接口以封装与使用环境角色的一个特定状态相关的行为。 具体状态（Concrete State）角色：实现状态角色定义的接口。 之间的协作关系：  Context将于状态相关的请求委托给当前的ConcreteState对象处理。  Context可将自身作为一个参数传递给处理该请求的状态对象，这使得状态对象在必要的时候可访问Context。  Context是客户使用的主要接口，客户可用状态对象来配置一个Context，一旦一个Context配置完毕，他的客户不再需要直接与状态对象打交道。 Context或者ConcreteState子类都可以决定哪个状态是另外那个状态的后继者，以及是在何种条件下进行状态转换。 状态模式实质： 使用状态模式前，客户端外界需要介入改变状态，而状态改变的实现是琐碎或复杂的。 使用状态模式后，客户端外界可以直接使用事件Event实现，根本不必关心该事件导致如何状态变化，这些是由状态机等内部实现。 这是一种Event-condition-State，状态模式封装了condition-State部分。 每个状态形成一个子类，每个状态只关心它的下一个可能状态，从而无形中形成了状态转换的规则。如果新的状态加入，只涉及它的前一个状态修改和定义。 状态转换有几个方法实现：一个在每个状态实现next()，指定下一个状态；还有一种方法，设定一个StateOwner，在StateOwner设定stateEnter状态进入和stateExit状态退出行为。 状态从一个方面说明了流程，流程是随时间而改变，状态是截取流程某个时间片。 适用场合：        (1)         State模式在实际使用中比较多,适合\"状态的切换\".因为我们经常会使用If elseif else 进行状态切换, 如果针对状态的这样判断切换反复出现,我们就要联想到是否可以采取State模式了.适合于内部状态,不断循环变化的.      (2) 一个state,包括两部分: 对象 + 对象内部的属性(属性接口+具体属性) 一个对象,要有其属性,以及其setter,getter.且设置好其初始状态+一个调用显示状态的方法(里面就是状态调用自身的显示方法). 一个属性接口,应该有一个执行的方法. 一个具体属性,须包含对象进去,实现方法中,须设置对象下一个要显示的属性-->从而在对象下次调用方法时,其属性值会变化. 代码例子： 该代码使用电梯作为模板，设置了四种状态        State接口： [java] view plaincopy public interface IState {       void open();       void close();       void runing();       void stop();   }   具体角色(Concrete State) [java] view plaincopy public class OpenState implements IState {       private Lift lift;              public OpenState(Lift lift){           this.lift = lift;       }          @Override       public void open() {           // TODO Auto-generated method stub           System.out.println(\"门已经开了!!!\");       }          @Override       public void close() {           // TODO Auto-generated method stub           System.out.println(\"好的,现在关门\");           lift.setState(lift.getCloseState());       }          @Override       public void runing() {           // TODO Auto-generated method stub           System.out.println(\"现在门开着,电梯没办法运行\");       }          @Override       public void stop() {           // TODO Auto-generated method stub           System.out.println(\"现在门开着,电梯是停止状态\");       }      }   [java] view plaincopy ublic class RunState implements IState {       private Lift lift;              public RunState(Lift lift){           this.lift = lift;       }          @Override       public void open() {           // TODO Auto-generated method stub           System.out.println(\"现在正在运行,没办法开门\");       }          @Override       public void close() {           // TODO Auto-generated method stub           System.out.println(\"现在是运行状态,门已经关闭\");       }          @Override       public void runing() {           // TODO Auto-generated method stub           System.out.println(\"电梯正在运行中....\");       }          @Override       public void stop() {           // TODO Auto-generated method stub           System.out.println(\"让电梯停止\");           lift.setState(lift.getStopState());       }      }   [java] view plaincopy public class StopState implements IState {       private Lift lift;       public StopState(Lift lift){           this.lift = lift;       }          @Override       public void open() {           // TODO Auto-generated method stub           System.out.println(\"现在打开电梯\");           lift.setState(lift.getOpenState());       }          @Override       public void close() {           // TODO Auto-generated method stub           System.out.println(\"电梯现在关闭\");           lift.setState(lift.getStopState());       }          @Override       public void runing() {           // TODO Auto-generated method stub           System.out.println(\"好吧,让电梯开始运行\");           lift.setState(lift.getRunState());       }          @Override       public void stop() {           // TODO Auto-generated method stub           System.out.println(\"现在正是在停止状态\");       }      }   [java] view plaincopy public class CloseState implements IState {       private Lift lift;              public CloseState(Lift lift){           this.lift = lift;       }          @Override       public void open() {           // TODO Auto-generated method stub           System.out.println(\"正要准备打开门\");           lift.setState(lift.getOpenState());       }          @Override       public void close() {           // TODO Auto-generated method stub           System.out.println(\"现在门正在关着\");       }          @Override       public void runing() {           // TODO Auto-generated method stub           System.out.println(\"现在让电梯运行\");           lift.setState(lift.getRunState());       }          @Override       public void stop() {           // TODO Auto-generated method stub           System.out.println(\"现在让电梯停止\");           lift.setState(lift.getStopState());       }      }   context类： [java] view plaincopy public class Lift {       private IState openState;       private IState closeState;       private IState runState;       private IState stopState;              private IState state ;              public Lift(){           openState = new OpenState(this);           closeState = new CloseState(this);           runState = new RunState(this);           stopState = new StopState(this);           state = stopState;       }              public void openLift(){           state.open();       }              public void runLift(){           state.runing();       }              public void stopLift(){           state.stop();       }              public void closeLift(){           state.close();       }              public void setState(IState state){           this.state = state;       }                     public IState getOpenState() {           return openState;       }       public IState getCloseState() {           return closeState;       }       public IState getRunState() {           return runState;       }       public IState getStopState() {           return stopState;       }          }   测试类： [java] view plaincopy public class Test {       public static void main(String[] args){           Lift lift = new Lift();           //好,现在打开电梯门进去           lift.openLift();           //关闭电梯门           lift.closeLift();           //让电梯开始运行           lift.runLift();           //电梯到了,停止           lift.stopLift();           //打开电梯门           lift.openLift();                      //现在一个小朋友乱按电梯           Lift lift2 = new Lift();           //好,现在打开电梯门进去           lift2.openLift();           //又按了次开门           lift2.openLift();           //开门状态下,让电梯运行           lift2.runLift();           //好吧,不玩了,关闭电梯门           lift2.closeLift();           //让电梯开始运行           lift2.runLift();           //在运行过程中想打开门           lift2.openLift();           //电梯到了,停止           lift2.stopLift();           //打开电梯门           lift2.openLift();       }   }   测试结果： [java] view plaincopy 现在打开电梯   好的,现在关门   现在让电梯运行   让电梯停止   现在打开电梯   ---------   现在打开电梯   门已经开了!!!   现在门开着,电梯没办法运行   好的,现在关门   现在让电梯运行   现在正在运行,没办法开门   让电梯停止   现在打开电梯   状态模式与观察者模式的区别： 状态模式，也跟观察者模式一样，是一对多的模式。但观察者模式是“一”变了，所有的“多”也会更新。 状态模式，强调的是：“多”是“一”的各个状态，“一”的各个状态，进行不断的循环。   如何建立一与多的关系：         “多”，都是实现一个接口的。所以，在“一”的类中，声明的是“多”的接口；若“多”中要建立与“一”的关系，只须直接在类中声明“一”即可。 状态模式与其他模式的区别： 状态模式，也跟观察者模式一样，是一对多的模式。但观察者模式是“一”变了，所有的“多”也会更新。状态模式，强调的是：“多”是“一”的各个状态，“一”的各个状态，进行不断的循环。 状态模式的主要使用方法，是作为实例变量，通过set属性方法，或者构造器把状态接口的具体实现类的实例传递进来 通常命令模式的接口中只有一个方法。而状态模式的接口中有1个或者多个方法。命令模式的主要的使用方式是参数回调模式。命令接口作为方法的参数传递进来。然后，在方法体内回调该接口。","title":"浅学设计模式之状态<state>模式"},{"content":"代理模式 GOOD：远程代理，可以隐藏一个对象在不同地址空间的事实 　　　　虚拟代理：通过代理来存放需要很长时间实例化的对象 　　　　安全代理：用来控制真实对象的访问权限 　　　　智能引用：当调用真实对象时，代理处理另外一些事 转载请注明，文章来自：http://blog.csdn.net/windows_nt 例： #include <string>#include <iostream>using namespace std;//定义接口class Interface{public:\tvirtual void Request()=0;};//真实类class RealClass : public Interface{public:\tvirtual void Request()\t{\t\tcout<<\"真实的请求\"<<endl;\t}};//代理类class ProxyClass : public Interface{private:\tRealClass* m_realClass;public:\tvirtual void Request()\t{\t\tm_realClass= new RealClass();\t\tm_realClass->Request();\t\tdelete m_realClass;\t}};//客户端：int main(){\tProxyClass* test=new ProxyClass();\ttest->Request();\treturn 0;}","title":"设计模式学习-----代理模式"},{"content":"在阅读过程中有任何问题，请及时联系：egg。 邮箱：xtfggef@gmail.com 微博：http://weibo.com/xtfggef 转载请说明出处:http://blog.csdn.net/zhangerqing 其实每个设计模式都是很重要的一种思想，看上去很熟，其实是因为我们在学到的东西中都有涉及，尽管有时我们并不知道，其实在Java本身的设计之中处处都有体现，像AWT、JDBC、集合类、IO管道或者是Web框架，里面设计模式无处不在。因为我们篇幅有限，很难讲每一个设计模式都讲的很详细，不过我会尽我所能，尽量在有限的空间和篇幅内，把意思写清楚了，更好让大家明白。本章不出意外的话，应该是设计模式最后一讲了，首先还是上一下上篇开头的那个图： 本章讲讲第三类和第四类。 19、备忘录模式（Memento） 主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象，个人觉得叫备份模式更形象些，通俗的讲下：假设有原始类A，A中有各种属性，A可以决定需要备份的属性，备忘录类B是用来存储A的一些内部状态，类C呢，就是一个用来存储备忘录的，且只能存储，不能修改等操作。做个图来分析一下： Original类是原始类，里面有需要保存的属性value及创建一个备忘录类，用来保存value值。Memento类是备忘录类，Storage类是存储备忘录的类，持有Memento类的实例，该模式很好理解。直接看源码： public class Original {\t\tprivate String value;\t\tpublic String getValue() {\t\treturn value;\t}\tpublic void setValue(String value) {\t\tthis.value = value;\t}\tpublic Original(String value) {\t\tthis.value = value;\t}\tpublic Memento createMemento(){\t\treturn new Memento(value);\t}\t\tpublic void restoreMemento(Memento memento){\t\tthis.value = memento.getValue();\t}} public class Memento {\t\tprivate String value;\tpublic Memento(String value) {\t\tthis.value = value;\t}\tpublic String getValue() {\t\treturn value;\t}\tpublic void setValue(String value) {\t\tthis.value = value;\t}} public class Storage {\t\tprivate Memento memento;\t\tpublic Storage(Memento memento) {\t\tthis.memento = memento;\t}\tpublic Memento getMemento() {\t\treturn memento;\t}\tpublic void setMemento(Memento memento) {\t\tthis.memento = memento;\t}} 测试类： public class Test {\tpublic static void main(String[] args) {\t\t\t\t// 创建原始类\t\tOriginal origi = new Original(\"egg\");\t\t// 创建备忘录\t\tStorage storage = new Storage(origi.createMemento());\t\t// 修改原始类的状态\t\tSystem.out.println(\"初始化状态为：\" + origi.getValue());\t\torigi.setValue(\"niu\");\t\tSystem.out.println(\"修改后的状态为：\" + origi.getValue());\t\t// 回复原始类的状态\t\torigi.restoreMemento(storage.getMemento());\t\tSystem.out.println(\"恢复后的状态为：\" + origi.getValue());\t}} 输出： 初始化状态为：egg 修改后的状态为：niu 恢复后的状态为：egg 简单描述下：新建原始类时，value被初始化为egg，后经过修改，将value的值置为niu，最后倒数第二行进行恢复状态，结果成功恢复了。其实我觉得这个模式叫“备份-恢复”模式最形象。 20、状态模式（State） 核心思想就是：当对象的状态改变时，同时改变其行为，很好理解！就拿QQ来说，有几种状态，在线、隐身、忙碌等，每个状态对应不同的操作，而且你的好友也能看到你的状态，所以，状态模式就两点：1、可以通过改变状态来获得不同的行为。2、你的好友能同时看到你的变化。看图： State类是个状态类，Context类可以实现切换，我们来看看代码： package com.xtfggef.dp.state;/** * 状态类的核心类 * 2012-12-1 * @author erqing * */public class State {\t\tprivate String value;\t\tpublic String getValue() {\t\treturn value;\t}\tpublic void setValue(String value) {\t\tthis.value = value;\t}\tpublic void method1(){\t\tSystem.out.println(\"execute the first opt!\");\t}\t\tpublic void method2(){\t\tSystem.out.println(\"execute the second opt!\");\t}} package com.xtfggef.dp.state;/** * 状态模式的切换类   2012-12-1 * @author erqing *  */public class Context {\tprivate State state;\tpublic Context(State state) {\t\tthis.state = state;\t}\tpublic State getState() {\t\treturn state;\t}\tpublic void setState(State state) {\t\tthis.state = state;\t}\tpublic void method() {\t\tif (state.getValue().equals(\"state1\")) {\t\t\tstate.method1();\t\t} else if (state.getValue().equals(\"state2\")) {\t\t\tstate.method2();\t\t}\t}}测试类： public class Test {\tpublic static void main(String[] args) {\t\t\t\tState state = new State();\t\tContext context = new Context(state);\t\t\t\t//设置第一种状态\t\tstate.setValue(\"state1\");\t\tcontext.method();\t\t\t\t//设置第二种状态\t\tstate.setValue(\"state2\");\t\tcontext.method();\t}}输出： execute the first opt! execute the second opt! 根据这个特性，状态模式在日常开发中用的挺多的，尤其是做网站的时候，我们有时希望根据对象的某一属性，区别开他们的一些功能，比如说简单的权限控制等。 21、访问者模式（Visitor） 访问者模式把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。访问者模式适用于数据结构相对稳定算法又易变化的系统。因为访问者模式使得算法操作增加变得容易。若系统数据结构对象易于变化，经常有新的数据对象增加进来，则不适合使用访问者模式。访问者模式的优点是增加操作很容易，因为增加操作意味着增加新的访问者。访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。其缺点就是增加新的数据结构很困难。—— From 百科 简单来说，访问者模式就是一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。简单关系图： 来看看原码：一个Visitor类，存放要访问的对象， public interface Visitor {\tpublic void visit(Subject sub);} public class MyVisitor implements Visitor {\t@Override\tpublic void visit(Subject sub) {\t\tSystem.out.println(\"visit the subject：\"+sub.getSubject());\t}}Subject类，accept方法，接受将要访问它的对象，getSubject()获取将要被访问的属性， public interface Subject {\tpublic void accept(Visitor visitor);\tpublic String getSubject();} public class MySubject implements Subject {\t@Override\tpublic void accept(Visitor visitor) {\t\tvisitor.visit(this);\t}\t@Override\tpublic String getSubject() {\t\treturn \"love\";\t}}测试： public class Test {\tpublic static void main(String[] args) {\t\t\t\tVisitor visitor = new MyVisitor();\t\tSubject sub = new MySubject();\t\tsub.accept(visitor);\t\t}}输出：visit the subject：love 该模式适用场景：如果我们想为一个现有的类增加新功能，不得不考虑几个事情：1、新功能会不会与现有功能出现兼容性问题？2、以后会不会再需要添加？3、如果类不允许修改代码怎么办？面对这些问题，最好的解决方法就是使用访问者模式，访问者模式适用于数据结构相对稳定的系统，把数据结构和算法解耦， 22、中介者模式（Mediator） 中介者模式也是用来降低类类之间的耦合的，因为如果类类之间有依赖关系的话，不利于功能的拓展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。如果使用中介者模式，只需关心和Mediator类的关系，具体类类之间的关系及调度交给Mediator就行，这有点像spring容器的作用。先看看图： User类统一接口，User1和User2分别是不同的对象，二者之间有关联，如果不采用中介者模式，则需要二者相互持有引用，这样二者的耦合度很高，为了解耦，引入了Mediator类，提供统一接口，MyMediator为其实现类，里面持有User1和User2的实例，用来实现对User1和User2的控制。这样User1和User2两个对象相互独立，他们只需要保持好和Mediator之间的关系就行，剩下的全由MyMediator类来维护！基本实现： public interface Mediator {\tpublic void createMediator();\tpublic void workAll();} public class MyMediator implements Mediator {\tprivate User user1;\tprivate User user2;\t\tpublic User getUser1() {\t\treturn user1;\t}\tpublic User getUser2() {\t\treturn user2;\t}\t@Override\tpublic void createMediator() {\t\tuser1 = new User1(this);\t\tuser2 = new User2(this);\t}\t@Override\tpublic void workAll() {\t\tuser1.work();\t\tuser2.work();\t}} public abstract class User {\t\tprivate Mediator mediator;\t\tpublic Mediator getMediator(){\t\treturn mediator;\t}\t\tpublic User(Mediator mediator) {\t\tthis.mediator = mediator;\t}\tpublic abstract void work();} public class User1 extends User {\tpublic User1(Mediator mediator){\t\tsuper(mediator);\t}\t\t@Override\tpublic void work() {\t\tSystem.out.println(\"user1 exe!\");\t}} public class User2 extends User {\tpublic User2(Mediator mediator){\t\tsuper(mediator);\t}\t\t@Override\tpublic void work() {\t\tSystem.out.println(\"user2 exe!\");\t}}测试类： public class Test {\tpublic static void main(String[] args) {\t\tMediator mediator = new MyMediator();\t\tmediator.createMediator();\t\tmediator.workAll();\t}}输出： user1 exe! user2 exe! 23、解释器模式（Interpreter） 解释器模式是我们暂时的最后一讲，一般主要应用在OOP开发中的编译器的开发中，所以适用面比较窄。 Context类是一个上下文环境类，Plus和Minus分别是用来计算的实现，代码如下： public interface Expression {\tpublic int interpret(Context context);} public class Plus implements Expression {\t@Override\tpublic int interpret(Context context) {\t\treturn context.getNum1()+context.getNum2();\t}} public class Minus implements Expression {\t@Override\tpublic int interpret(Context context) {\t\treturn context.getNum1()-context.getNum2();\t}} public class Context {\t\tprivate int num1;\tprivate int num2;\t\tpublic Context(int num1, int num2) {\t\tthis.num1 = num1;\t\tthis.num2 = num2;\t}\t\tpublic int getNum1() {\t\treturn num1;\t}\tpublic void setNum1(int num1) {\t\tthis.num1 = num1;\t}\tpublic int getNum2() {\t\treturn num2;\t}\tpublic void setNum2(int num2) {\t\tthis.num2 = num2;\t}\t\t} public class Test {\tpublic static void main(String[] args) {\t\t// 计算9+2-8的值\t\tint result = new Minus().interpret((new Context(new Plus()\t\t\t\t.interpret(new Context(9, 2)), 8)));\t\tSystem.out.println(result);\t}}最后输出正确的结果：3。 基本就这样，解释器模式用来做各种各样的解释器，如正则表达式等的解释器等等！ 设计模式基本就这么大概讲完了，总体感觉有点简略，的确，这么点儿篇幅，不足以对整个23种设计模式做全面的阐述，此处读者可将它作为一个理论基础去学习，通过这四篇博文，先基本有个概念，虽然我讲的有些简单，但基本都能说明问题及他们的特点，如果对哪一个感兴趣，可以继续深入研究！同时我也会不断更新，尽量不全遗漏、修正不足，欢迎广大读者及时提出好的建议，我们一起学习！项目中涉及到的代码，已经放到了我的资源里：http://download.csdn.net/detail/zhangerqing/4835830（因为我不喜欢不劳而获，所以没有免积分，只设置了5个，如果有人实在没积分又急要，那么联系我吧，我给你发过去）。 在阅读的过程中，有任何问题，请联系：egg。 邮箱：xtfggef@gmail.com   微博：http://weibo.com/xtfggef","title":"Java之美[从菜鸟到高手演变]之设计模式四"},{"content":" 今天一直心绪不宁，被一些事情所困扰，希望能有个好的过程以及结果而不是自己的空想。看一下桥接模式吧，个人感觉这个模式是个比较容易理解的模式，但是在真正应用的时候还是需要一定的经验。 如果这篇文章对您有用，劳烦几秒钟帮忙投下票：http://vote.blog.csdn.net/item/blogstar/aomandeshangxiao，谢谢！！！ 概述 在软件系统中，某些类型由于自身的逻辑，它具有两个或多个维度的变化，那么如何应对这种“多维度的变化”？如何利用面向对象的技术来使得该类型能够轻松的沿着多个方向进行变化，而又不引入额外的复杂度？这就要使用Bridge模式。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。 模式定义：     桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。（Bridge Pattern: Decouple an abstraction from its implementation so that the two can vary independently.） 结构： Abstraction 定义抽象的接口 该接口包含实现具体行为、具体特征的Implementor接口 Refined Abstraction 抽象接口Abstraction的子类，依旧是一个抽象的事物名 Implementor 定义具体行为、具体特征的应用接口 ConcreteImplementor 实现Implementor接口 模式分析： 理解桥接模式，重点需要理解如何将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化。     •抽象化：抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面向对象中，将对象的共同性质抽取出来形成类的过程即为抽象化的过程。     •实现化：针对抽象化给出的具体实现，就是实现化，抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是对抽象化事物的进一步具体化的产物。     •脱耦：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意。 代码实现： 这个例子用画笔和颜色搭配比较合适： Abstraction public abstract class Brush {\tColor mColor;\tpublic Brush(Color color) {\t\tmColor = color;\t}\t\t//默认画笔为黑色\tpublic Brush() {\t\tmColor = new BlackColor();\t}\t\tpublic void setColor(Color color) {\t\tmColor = color;\t}\tpublic abstract void draw();} Refined Abstraction小号笔： public class SmallBrush extends Brush {\t\tpublic SmallBrush(){\t\tsuper();\t}\t\tpublic SmallBrush(Color color) {\t\tsuper(color);\t}\t@Override\tpublic void draw() {\t\tSystem.out.println(\" in smallBrush, begin to draw\");\t\tmColor.draw();\t}} 中号笔： public class MiddleBrush extends Brush {\t\tpublic MiddleBrush() {\t\tsuper();\t}\tpublic MiddleBrush(Color color) {\t\tsuper(color);\t}\t\t@Override\tpublic void draw() {\t\tSystem.out.println(\" in MiddleBrush, begin to draw\");\t\tmColor.draw();\t}} 大号笔： public class BigBrush extends Brush {\t\tpublic BigBrush() {\t\tsuper();\t}\tpublic BigBrush(Color color) {\t\tsuper(color);\t}\t@Override\tpublic void draw() {\t\tSystem.out.println(\" in BigBrush, begin to draw\");\t\tmColor.draw();\t}} Implementor public interface Color {\tvoid draw();} ConcreteImplementor 红色： public class RedColor implements Color {\t@Override\tpublic void draw() {\t\tSystem.out.println(\"this is red color...\");\t}}黑色： public class BlackColor implements Color {\t@Override\tpublic void draw() {\t\tSystem.out.println(\"this is black color...\");\t}}蓝色： public class BlueColor implements Color {\t@Override\tpublic void draw() {\t\tSystem.out.println(\"this is blue color...\");\t}}绿色： public class GreenColor implements Color {\t@Override\tpublic void draw() {\t\tSystem.out.println(\"this is green color...\");\t}} Client public class Client {\tpublic static void main(String[] args) {\t\t//生成五种颜色\t\tColor blackColor = new BlackColor();\t\tColor blueColor = new BlueColor();\t\tColor greenColor = new GreenColor();\t\tColor redColor = new RedColor();\t\t\t\t//生成三种笔\t\tBrush smallBrush = new SmallBrush(redColor);\t\tBrush middleBrush = new MiddleBrush();\t\t//设置成蓝颜色\t\tmiddleBrush.setColor(blueColor);\t\t//默认黑颜色\t\tBrush bigBrush = new BigBrush();\t\t\t\t//开始画\t\tsmallBrush.draw();\t\tmiddleBrush.draw();\t\tbigBrush.draw();\t\t\t\t//把大号笔换成绿颜色，中号换成黑颜色\t\tbigBrush.setColor(greenColor);\t\tmiddleBrush.setColor(blackColor);\t\tbigBrush.draw();\t\tmiddleBrush.draw();\t}} 再扩展下： 如果我们需要用不同颜色不同型号的笔画出不同的图形： 图形接口： public interface Shape {\tvoid create();} 图形实现： 正方形： public class Square implements Shape {\t@Override\tpublic void create() {\t\tSystem.out.println(\"Square\");\t}} 圆形： public class Circle implements Shape {\t@Override\tpublic void create() {\t\tSystem.out.println(\"cricle\");\t}} 心形： public class HeartShaped implements Shape {\t@Override\tpublic void create() {\t\tSystem.out.println(\"love heart-shaped\");\t}} 修改一下画笔类： public abstract class Brush {\tColor mColor;\tpublic Brush(Color color) {\t\tmColor = color;\t}\t\t//默认画笔为黑色\tpublic Brush() {\t\tmColor = new BlackColor();\t}\t\tpublic void setColor(Color color) {\t\tmColor = color;\t}\t\tpublic void drawShape(Shape shape){\t\tdraw();\t\tshape.create();\t}\t\tpublic abstract void draw();}然后客户端调用： public class Client {\tpublic static void main(String[] args) {\t\t//生成五种颜色\t\tColor blackColor = new BlackColor();\t\tColor blueColor = new BlueColor();\t\tColor greenColor = new GreenColor();\t\tColor redColor = new RedColor();\t\t\t\t//生成三种笔\t\tBrush smallBrush = new SmallBrush(redColor);\t\tBrush middleBrush = new MiddleBrush();\t\t//设置成蓝颜色\t\tmiddleBrush.setColor(blueColor);\t\t//默认黑颜色\t\tBrush bigBrush = new BigBrush();\t\t\t\t//开始画\t\tsmallBrush.draw();\t\tmiddleBrush.draw();\t\tbigBrush.draw();\t\t\t\t//把大号笔换成绿颜色，中号换成黑颜色\t\tbigBrush.setColor(greenColor);\t\tmiddleBrush.setColor(blackColor);\t\tbigBrush.draw();\t\tmiddleBrush.draw();\t\t\t\t//用小号笔画一个红心\t\tsmallBrush.drawShape(new HeartShaped());\t\t//中号笔画一个黑色圆形\t\tmiddleBrush.drawShape(new Circle());\t\t//用大号笔画一个绿色正方形\t\tbigBrush.drawShape(new Square());\t}} 模式优点： 分离抽象和实现部分 桥接模式分离了抽象部分和实现部分，从而极大地提高了系统的灵活性。让抽象部分和实现部分独立开来，分别定义接口，这有助于对系统进行分层，从而产生更好的结构化的系统。对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了。 更好的扩展性 由于桥接模式把抽象部分和实现部分分离开了，而且分别定义接口，这就使得抽象部分和实现部分可以分别独立地扩展，而不会相互影响，从而大大地提高了系统的可扩展性。 可动态地切换实现 由于桥接模式把抽象部分和实现部分分离开了，所以在实现桥接的时候，就可以实现动态的选择和使用具体的实现。也就是说一个实现不再是固定的绑定在一个抽象接口上了，可以实现运行期间动态地切换。 可减少子类的个数 根据前面的讲述，对于有两个变化纬度的情况，如果采用继承的实现方式，大约需要两个纬度上的可变化数量的乘积个子类；而采用桥接模式来实现，大约需要两个纬度上的可变化数量的和个子类。可以明显地减少子类的个数。 桥接模式的缺点 桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。 适用环境 如果你不希望在抽象部分和实现部分采用固定的绑定关系，可以采用桥接模式，来把抽象部分和实现部分分开，然后在程序运行期间来动态地设置抽象部分需要用到的具体的实现，还可以动态地切换具体的实现。 如果出现抽象部分和实现部分都能够扩展的情况，可以采用桥接模式，让抽象部分和实现部分独立地变化，从而灵活地进行单独扩展，而不是搅在一起，扩展一边就会影响到另一边。 如果希望实现部分的修改不会对客户产生影响，可以采用桥接模式。由于客户是面向抽象的接口在运行，实现部分的修改可以独立于抽象部分，并不会对客户产生影响，也可以说对客户是透明的。 如果采用继承的实现方案，会导致产生很多子类，对于这种情况，可以考虑采用桥接模式，分析功能变化的原因，看看是否能分离成不同的纬度，然后通过桥接模式来分离它们，从而减少子类的数目。 模式扩展 适配器模式与桥接模式 桥接模式和适配器模式用于设计的不同阶段，桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，当发现系统与已有类无法协同工作时，可以采用适配器模式。但有时候在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况。 桥接模式和策略模式 这两个模式有很大的相似之处。 如果把桥接模式的抽象部分简化来看，暂时不去扩展Abstraction，也就是去掉RefinedAbstraction。桥接模式简化后的结构图如图24.13所示。再看看策略模式的结构图，参见图17.1。会发现，这个时候它们的结构都类似图24.18所示。 这两个模式虽然相似，但也还是有区别的。最主要的是模式的目的不一样，策略模式的目的是封装一系列的算法，使得这些算法可以相互替换；而桥接模式的目的是分离抽象部分和实现部分，使得它们可以独立地变化。通过上面的结构图，可以体会到桥接模式和策略模式是如此相似。可以把策略模式的Context当做是使用接口的对象，而Strategy就是某个接口了，具体的策略实现就相当于接口的具体实现。这样看来的话，某些情况下，可以使用桥接模式来模拟实现策略模式的功能。 桥接模式和状态模式 由于从模式结构上看，状态模式和策略模式是一样的，因此这两个模式的关系也基本上类似于桥接模式和策略模式的关系。 只不过状态模式的目的是封装状态对应的行为，并在内部状态改变的时候改变对象的行为。 桥接模式和模板方法模式 这两个模式有相似之处。 虽然标准的模板方法模式是采用继承来实现的，但是模板方法也可以通过回调接口的方式来实现。如果把接口的实现独立出去，那就类似于模板方法通过接口去调用具体的实现方法了，这样的结构就和简化的桥接模式类似了。 可以使用桥接模式来模拟实现模板方法模式的功能。如果在实现Abstraction对象的时候，在其中定义方法，方法中就是某个固定的算法骨架，也就是说这个方法就相当于模板方法。在模板方法模式中，是把不能确定实现的步骤延迟到子类去实现；现在在桥接模式中，把不能确定实现的步骤委托给具体实现部分去完成，通过回调实现部分的接口，来完成算法骨架中的某些步骤。这样一来，就可以实现使用桥接模式来模拟实现模板方法模式的功能。 使用桥接模式来模拟实现模板方法模式的功能，还有一个潜在的好处，就是模板方法也可以很方便地扩展和变化。在标准的模板方法中，一个问题就是当模板发生变化的时候，所有的子类都要变化，非常不方便。而使用桥接模式来实现类似的功能，就没有这个问题。 另外，这里只是说从实现具体的业务功能上，桥接模式可以模拟实现模板方法模式能实现的功能，并不是说桥接模式和模板方法模式就变成一样的，或者是桥接模式就可以替换模板方法模式了。要注意它们本身的功能、目的、本质思想都是不一样的。 桥接模式和抽象工厂模式 这两个模式可以组合使用。 桥接模式中，抽象部分需要获取相应的实现部分的接口对象，那么谁来创建实现部分的具体实现对象呢？这就是抽象工厂模式派上用场的地方。也就是使用抽象工厂模式来创建和配置一个特定的具体的实现对象。 事实上，抽象工厂主要是用来创建一系列对象的，如果创建的对象很少，或者是很简单，还可以采用简单工厂，也能达到同样的效果，但是会比抽象工厂来得简单。 桥接模式和适配器模式 这两个模式可以组合使用。 这两个模式功能是完全不一样的，适配器模式的功能主要是用来帮助无关的类协同工作，重点在解决原本由于接口不兼容而不能一起工作的那些类，使得它们可以一起工作。而桥接模式则重点在分离抽象部分和实现部分。 所以在使用上，通常在系统设计完成以后，才会考虑使用适配器模式；而桥接模式。是在系统开始的时候就要考虑使用。 虽然功能上不一样，这两个模式还是可以组合使用的，比如，已有实现部分的接口，但是有些不太适应现在新的功能对接口的需要，完全抛弃吧，有些功能还用得上，该怎么办呢？那就使用适配器来进行适配，使得旧的接口能够适应新的功能的需要。如果这篇文章对您有用，劳烦几秒钟帮忙投下票：http://vote.blog.csdn.net/item/blogstar/aomandeshangxiao，谢谢！！！","title":"浅学设计模式之桥接<bridge>模式"},{"content":"单例：确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。   类图： 单例模式应该是23种设计模式中最简单的一种模式了。它有以下几个要素： 私有的构造方法 指向自己实例的私有静态引用 以自己实例为返回值的静态的公有的方法         单例模式根据实例化对象时机的不同分为两种：一种是饿汉式单例，一种是懒汉式单例。饿汉式单例在单例类被加载时候，就实例化一个对象交给自己的引用；而懒汉式在调用取得实例方法的时候才会实例化对象。代码如下：     饿汉式单例 public class Singleton {\tprivate static Singleton singleton = new Singleton();\tprivate Singleton(){}\tpublic static Singleton getInstance(){\t\treturn singleton;\t}}   懒汉式单例 public class Singleton {\tprivate static Singleton singleton;\tprivate Singleton(){}\t\tpublic static synchronized Singleton getInstance(){\t\tif(singleton==null){\t\t\tsingleton = new Singleton();\t\t}\t\treturn singleton;\t}}   单例模式的优点： 在内存中只有一个对象，节省内存空间。 避免频繁的创建销毁对象，可以提高性能。 避免对共享资源的多重占用。 可以全局访问。 适用场景：由于单例模式的以上优点，所以是编程中用的比较多的一种设计模式。我总结了一下我所知道的适合使用单例模式的场景： 需要频繁实例化然后销毁的对象。 创建对象时耗时过多或者耗资源过多，但又经常用到的对象。 有状态的工具类对象。 频繁访问数据库或文件的对象。 以及其他我没用过的所有要求只有一个对象的场景。 单例模式注意事项： 只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。 不要做断开单例类对象与类中静态引用的危险操作。 多线程使用单例使用共享资源时，注意线程安全问题。 在一个jvm中会出现多个单例吗         在分布式系统、多个类加载器、以及序列化的的情况下，会产生多个单例，这一点是无庸置疑的。那么在同一个jvm中，会不会产生单例呢？使用单例提供的getInstance()方法只能得到同一个单例，除非是使用反射方式，将会得到新的单例。代码如下 Class c = Class.forName(Singleton.class.getName());Constructor ct = c.getDeclaredConstructor();ct.setAccessible(true);Singleton singleton = (Singleton)ct.newInstance(); 这样，每次运行都会产生新的单例对象。所以运用单例模式时，一定注意不要使用反射产生新的单例对象。   懒汉式单例线程安全吗         主要是网上的一些说法，懒汉式的单例模式是线程不安全的，即使是在实例化对象的方法上加synchronized关键字，也依然是危险的，但是笔者经过编码测试，发现加synchronized关键字修饰后，虽然对性能有部分影响，但是却是线程安全的，并不会产生实例化多个对象的情况。   饿汉式单例好还是懒汉式单例好         在java中，饿汉式单例要优于懒汉式单例 转载：http://blog.csdn.net/zhengzhb/article/details/7331369","title":"单例模式"},{"content":"        -----引言：因为实验室开例会要分享点东西，我就被提议分享设计模式了，也了PPT（用HTML/CSS写的），顺便也记录下来。还有以下代码为伪代码，我用记事本随便写的，那些UML图由于时间和其他原因，没有用工具去画，只是随便P了几张图，也没有去细想，假如有错，请提醒下我这个菜鸟。(迟点有空会补上正确的UML图)                                                                 工厂模式：    设计原则:找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。    抽象定义:很多人都知道，工厂模式通俗来说就是给它原料，不管它如何运作，总之只需要最后的结果对就行了，但是却有很多人对工厂模式误解了。    看图说话:     简单的工厂模式:  (其实这种是比较2B的方法，而且严格上来说其实这种不属于工厂模式，呵呵！)   Public class pizzaFactory(String type){          If(type.equal(“pizza1”)){                    XXOO…..          }          Elseif( type.equal(“pizza1”){                    XXOO….. } ……………. Else {          XXOO….. } } 好吧，虽然只是一种比较2B的方法，但我们的营业额上去了，要开分店了，但是这种工厂模式.   那我们来看一下比较优雅的工厂模式,顺便来拓展一下: 继续看图:     PizzaStores是一个抽象类，PizzaStore1和PizzaStore1分别继承它。 而他们生产的Pizza也是一个抽象类，具体的pizza1和pizza2和pizza3和pizza4都是pizza的子类。   大家会疑惑，这不是更复杂么？这么多继承的关系，我倒不如还是if好了！ 优点： 1：你用if的话，我现在2间分店，你只有一个工厂，所以只能在大混杂了….. 2：好，我要修改在工厂1中的pizza1的烹饪方法，好吧，我就会痛苦地在你那堆if,else,if,else……..if else中挣扎着！我只需要看看在具体的那个pizza类找找就OK了。 好吧，我就随手写下代码给大家看看吧:   Public abstractclass PizzaStore{ Public abstract voidcreatepizza(String type); Public abstract voidorder(); }   Public abstract class Store1 extendsPizzaStore{          Public void order(){ } Public void createpizza(type){     Pizzapizza = Factory.createPizza(type); } }   Public abstract class pizza{          publicabstract void dojob1();          publicabstract void dojob2(); }   Public class Pizza1{          Publicvoid dojob1(){                    XXOO… } Public voiddojob2(){          XXOO… } }   Public class Factory {          Pizzapizza;          PublicPizzacreatePizza(String type){                    If(type.equal.(“pizza1”)){                             pizza =new Pizaa1(); } Else if(…..){     ……. } ……. Else{          …… } } } 这个是比较优雅的工厂模式，其实工厂模式还有抽象的工厂模式的。 抽象工厂的定义:提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定的具体类。","title":"模式设计（一）------工厂模式"},{"content":"        本章是关于设计模式的最后一讲，会讲到第三种设计模式——行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。这段时间一直在写关于设计模式的东西，终于写到一半了，写博文是个很费时间的东西，因为我得为读者负责，不论是图还是代码还是表述，都希望能尽量写清楚，以便读者理解，我想不论是我还是读者，都希望看到高质量的博文出来，从我本人出发，我会一直坚持下去，不断更新，源源动力来自于读者朋友们的不断支持，我会尽自己的努力，写好每一篇文章！希望大家能不断给出意见和建议，共同打造完美的博文！ 学会技术，懂得分享！ 有任何想法，请联系：egg email:xtfggef@gmail.com   微博：http://weibo.com/xtfggef 如有转载，请说明出处：http://blog.csdn.net/zhangerqing 先来张图，看看这11中模式的关系： 第一类：通过父类与子类的关系进行实现。第二类：两个类之间。第三类：类的状态。第四类：通过中间类 13、策略模式（strategy） 策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供同意的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数，关系图如下： 图中ICalculator提供同意的方法， AbstractCalculator是辅助类，提供辅助方法，接下来，依次实现下每个类： 首先统一接口： public interface ICalculator {\tpublic int calculate(String exp);} 辅助类： public abstract class AbstractCalculator {\t\tpublic int[] split(String exp,String opt){\t\tString array[] = exp.split(opt);\t\tint arrayInt[] = new int[2];\t\tarrayInt[0] = Integer.parseInt(array[0]);\t\tarrayInt[1] = Integer.parseInt(array[1]);\t\treturn arrayInt;\t}} 三个实现类： public class Plus extends AbstractCalculator implements ICalculator {\t@Override\tpublic int calculate(String exp) {\t\tint arrayInt[] = split(exp,\"\\\\+\");\t\treturn arrayInt[0]+arrayInt[1];\t}} public class Minus extends AbstractCalculator implements ICalculator {\t@Override\tpublic int calculate(String exp) {\t\tint arrayInt[] = split(exp,\"-\");\t\treturn arrayInt[0]-arrayInt[1];\t}} public class Multiply extends AbstractCalculator implements ICalculator {\t@Override\tpublic int calculate(String exp) {\t\tint arrayInt[] = split(exp,\"\\\\*\");\t\treturn arrayInt[0]*arrayInt[1];\t}} 简单的测试类： public class StrategyTest {\tpublic static void main(String[] args) {\t\tString exp = \"2+8\";\t\tICalculator cal = new Plus();\t\tint result = cal.calculate(exp);\t\tSystem.out.println(result);\t}} 输出：10 策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。 14、模板方法模式（Template Method） 解释一下模板方法模式，就是指：一个抽象类中，有一个主方法，在定义1...n个方法，可以是抽象的，也可以是实际的方法，定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用，先看个关系图： 就是在AbstractCalculator类中定义一个主方法calculate，calculate()调用spilt()等，Plus和Minus分别继承AbstractCalculator类，通过对AbstractCalculator的调用实现对子类的调用，看下面的例子： public abstract class AbstractCalculator {\t\t/*主方法，实现对本类其它方法的调用*/\tpublic final int calculate(String exp,String opt){\t\tint array[] = split(exp,opt);\t\treturn calculate(array[0],array[1]);\t}\t\t/*被子类重写的方法*/\tabstract public int calculate(int num1,int num2);\t\tpublic int[] split(String exp,String opt){\t\tString array[] = exp.split(opt);\t\tint arrayInt[] = new int[2];\t\tarrayInt[0] = Integer.parseInt(array[0]);\t\tarrayInt[1] = Integer.parseInt(array[1]);\t\treturn arrayInt;\t}} public class Plus extends AbstractCalculator {\t@Override\tpublic int calculate(int num1,int num2) {\t\treturn num1 + num2;\t}} 测试类： public class StrategyTest {\tpublic static void main(String[] args) {\t\tString exp = \"8+8\";\t\tAbstractCalculator cal = new Plus();\t\tint result = cal.calculate(exp, \"\\\\+\");\t\tSystem.out.println(result);\t}} 我跟踪下这个小程序的执行过程：首先将exp和\"\\\\+\"做参数，调用AbstractCalculator类里的calculate(String,String)方法，在calculate(String,String)里调用同类的split()，之后再调用calculate(int ,int)方法，从这个方法进入到子类中，执行完return num1 + num2后，将值返回到AbstractCalculator类，赋给result，打印出来。正好验证了我们开头的思路。 15、观察者模式（Observer） 包括这个模式在内的接下来的四个模式，都是类和类之间的关系，不涉及到继承，学的时候应该 记得归纳，记得本文最开始的那个图。观察者模式很好理解，类似于邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，经常会看到RSS图标，就这的意思是，当你订阅了该文章，如果后续有更新，会及时通知你。其实，简单来讲就一句话：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。先来看看关系图： 我解释下这些类的作用：MySubject类就是我们的主对象，Observer1和Observer2是依赖于MySubject的对象，当MySubject变化时，Observer1和Observer2必然变化。AbstractSubject类中定义着需要监控的对象列表，可以对其进行修改：增加或删除被监控对象，且当MySubject变化时，负责通知在列表内存在的对象。我们看实现代码： 一个Observer接口： public interface Observer {\tpublic void update();} 两个实现类： public class Observer1 implements Observer {\t@Override\tpublic void update() {\t\tSystem.out.println(\"observer1 has received!\");\t}} public class Observer2 implements Observer {\t@Override\tpublic void update() {\t\tSystem.out.println(\"observer2 has received!\");\t}} Subject接口及实现类： public interface Subject {\t\t/*增加观察者*/\tpublic void add(Observer observer);\t\t/*删除观察者*/\tpublic void del(Observer observer);\t\t/*通知所有的观察者*/\tpublic void notifyObservers();\t\t/*自身的操作*/\tpublic void operation();} public abstract class AbstractSubject implements Subject {\tprivate Vector<Observer> vector = new Vector<Observer>();\t@Override\tpublic void add(Observer observer) {\t\tvector.add(observer);\t}\t@Override\tpublic void del(Observer observer) {\t\tvector.remove(observer);\t}\t@Override\tpublic void notifyObservers() {\t\tEnumeration<Observer> enumo = vector.elements();\t\twhile(enumo.hasMoreElements()){\t\t\tenumo.nextElement().update();\t\t}\t}} public class MySubject extends AbstractSubject {\t@Override\tpublic void operation() {\t\tSystem.out.println(\"update self!\");\t\tnotifyObservers();\t}} 测试类： public class ObserverTest {\tpublic static void main(String[] args) {\t\tSubject sub = new MySubject();\t\tsub.add(new Observer1());\t\tsub.add(new Observer2());\t\t\t\tsub.operation();\t}} 输出： update self! observer1 has received! observer2 has received!  这些东西，其实不难，只是有些抽象，不太容易整体理解，建议读者：根据关系图，新建项目，自己写代码（或者参考我的代码）,按照总体思路走一遍，这样才能体会它的思想，理解起来容易！ 欢迎广大读者随时指正，一起讨论，一起进步！ 有问题，联系：egg email：xtfggef@gmail.com      微博：http://weibo.com/xtfggef 16、迭代子模式（Iterator） 顾名思义，迭代器模式就是顺序访问聚集中的对象，一般来说，集合中非常常见，如果对集合类比较熟悉的话，理解本模式会十分轻松。这句话包含两层意思：一是需要遍历的对象，即聚集对象，二是迭代器对象，用于对聚集对象进行遍历访问。我们看下关系图：   这个思路和我们常用的一模一样，MyCollection中定义了集合的一些操作，MyIterator中定义了一系列迭代操作，且持有Collection实例，我们来看看实现代码： 两个接口： public interface Collection {\t\tpublic Iterator iterator();\t\t/*取得集合元素*/\tpublic Object get(int i);\t\t/*取得集合大小*/\tpublic int size();} public interface Iterator {\t//前移\tpublic Object previous();\t\t//后移\tpublic Object next();\tpublic boolean hasNext();\t\t//取得第一个元素\tpublic Object first();} 两个实现： public class MyCollection implements Collection {\tpublic String string[] = {\"A\",\"B\",\"C\",\"D\",\"E\"};\t@Override\tpublic Iterator iterator() {\t\treturn new MyIterator(this);\t}\t@Override\tpublic Object get(int i) {\t\treturn string[i];\t}\t@Override\tpublic int size() {\t\treturn string.length;\t}} public class MyIterator implements Iterator {\tprivate Collection collection;\tprivate int pos = -1;\t\tpublic MyIterator(Collection collection){\t\tthis.collection = collection;\t}\t\t@Override\tpublic Object previous() {\t\tif(pos > 0){\t\t\tpos--;\t\t}\t\treturn collection.get(pos);\t}\t@Override\tpublic Object next() {\t\tif(pos<collection.size()-1){\t\t\tpos++;\t\t}\t\treturn collection.get(pos);\t}\t@Override\tpublic boolean hasNext() {\t\tif(pos<collection.size()-1){\t\t\treturn true;\t\t}else{\t\t\treturn false;\t\t}\t}\t@Override\tpublic Object first() {\t\tpos = 0;\t\treturn collection.get(pos);\t}} 测试类： public class Test {\tpublic static void main(String[] args) {\t\tCollection collection = new MyCollection();\t\tIterator it = collection.iterator();\t\t\t\twhile(it.hasNext()){\t\t\tSystem.out.println(it.next());\t\t}\t}} 输出：A B C D E 此处我们貌似模拟了一个集合类的过程，感觉是不是很爽？其实JDK中各个类也都是这些基本的东西，加一些设计模式，再加一些优化放到一起的，只要我们把这些东西学会了，掌握好了，我们也可以写出自己的集合类，甚至框架！ 17、责任链模式（Chain of Responsibility） 接下来我们将要谈谈责任链模式，有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。先看看关系图： Abstracthandler类提供了get和set方法，方便MyHandle类设置和修改引用对象，MyHandle类是核心，实例化后生成一系列相互持有的对象，构成一条链。 public interface Handler {\tpublic void operator();} public abstract class AbstractHandler {\t\tprivate Handler handler;\tpublic Handler getHandler() {\t\treturn handler;\t}\tpublic void setHandler(Handler handler) {\t\tthis.handler = handler;\t}\t} public class MyHandler extends AbstractHandler implements Handler {\tprivate String name;\tpublic MyHandler(String name) {\t\tthis.name = name;\t}\t@Override\tpublic void operator() {\t\tSystem.out.println(name+\"deal!\");\t\tif(getHandler()!=null){\t\t\tgetHandler().operator();\t\t}\t}} public class Test {\tpublic static void main(String[] args) {\t\tMyHandler h1 = new MyHandler(\"h1\");\t\tMyHandler h2 = new MyHandler(\"h2\");\t\tMyHandler h3 = new MyHandler(\"h3\");\t\th1.setHandler(h2);\t\th2.setHandler(h3);\t\th1.operator();\t}} 输出： h1deal! h2deal! h3deal! 此处强调一点就是，链接上的请求可以是一条链，可以是一个树，还可以是一个环，模式本身不约束这个，需要我们自己去实现，同时，在一个时刻，命令只允许由一个对象传给另一个对象，而不允许传给多个对象。  18、命令模式（Command） 命令模式很好理解，举个例子，司令员下令让士兵去干件事情，从整个事情的角度来考虑，司令员的作用是，发出口令，口令经过传递，传到了士兵耳朵里，士兵去执行。这个过程好在，三者相互解耦，任何一方都不用去依赖其他人，只需要做好自己的事儿就行，司令员要的是结果，不会去关注到底士兵是怎么实现的。我们看看关系图： Invoker是调用者（司令员），Receiver是被调用者（士兵），MyCommand是命令，实现了Command接口，持有接收对象，看实现代码： public interface Command {\tpublic void exe();} public class MyCommand implements Command {\tprivate Receiver receiver;\t\tpublic MyCommand(Receiver receiver) {\t\tthis.receiver = receiver;\t}\t@Override\tpublic void exe() {\t\treceiver.action();\t}} public class Receiver {\tpublic void action(){\t\tSystem.out.println(\"command received!\");\t}} public class Invoker {\t\tprivate Command command;\t\tpublic Invoker(Command command) {\t\tthis.command = command;\t}\tpublic void action(){\t\tcommand.exe();\t}} public class Test {\tpublic static void main(String[] args) {\t\tReceiver receiver = new Receiver();\t\tCommand cmd = new MyCommand(receiver);\t\tInvoker invoker = new Invoker(cmd);\t\tinvoker.action();\t}} 输出：command received! 这个很哈理解，命令模式的目的就是达到命令的发出者和执行者之间解耦，实现请求和执行分开，熟悉Struts的同学应该知道，Struts其实就是一种将请求和呈现分离的技术，其中必然涉及命令模式的思想！ 本篇暂时就到这里，因为考虑到将来博文会不断的更新，不断的增加新内容，所以当前篇幅不易过长，以便大家阅读，所以接下来的放到另一篇里。敬请关注！","title":"Java之美[从菜鸟到高手演变]之设计模式三"},{"content":"首先定义了一个虚类，表示菜单组件 import java.util.*;public abstract class MenuComponent {   \tpublic void add(MenuComponent menuComponent) {\t\tthrow new UnsupportedOperationException();\t}\tpublic void remove(MenuComponent menuComponent) {\t\tthrow new UnsupportedOperationException();\t}\tpublic MenuComponent getChild(int i) {\t\tthrow new UnsupportedOperationException();\t}  \tpublic String getName() {\t\tthrow new UnsupportedOperationException();\t}\tpublic String getDescription() {\t\tthrow new UnsupportedOperationException();\t}\tpublic double getPrice() {\t\tthrow new UnsupportedOperationException();\t}\tpublic boolean isVegetarian() {\t\tthrow new UnsupportedOperationException();\t}\tpublic abstract Iterator createIterator(); \tpublic void print() {\t\tthrow new UnsupportedOperationException();\t}} 其次是两个子类，分别是菜单的具体实现，以及菜单中的菜~ 因为主要说的是迭代器以及组合两种设计模式结合，所以只列出两个子类的打印方法 \tpublic void print() {\t\tSystem.out.print(\"\\n\" + getName());\t\tSystem.out.println(\", \" + getDescription());\t\tSystem.out.println(\"---------------------\");  \t\tIterator iterator = menuComponents.iterator();\t\twhile (iterator.hasNext()) {\t\t\tMenuComponent menuComponent = \t\t\t\t(MenuComponent)iterator.next();\t\t\tmenuComponent.print();\t\t}\t} 上面是菜单类Menu类的打印方法，可以看到，使用了迭代器。 \tpublic void print() {\t\tSystem.out.print(\"  \" + getName());\t\tif (isVegetarian()) {\t\t\tSystem.out.print(\"(v)\");\t\t}\t\tSystem.out.println(\", \" + getPrice());\t\tSystem.out.println(\"     -- \" + getDescription());\t}具体菜的子类，直接打印菜名价格以及一些说明。 因为餐馆的特殊性，菜单不止一份，可能有早餐菜单，午餐菜单，晚餐菜单，以及vegetarian(素食)菜单，而相同的菜可能在不同的菜单中，一个菜单也可能在另一个菜单中被包含，所以两个类都继承自MenuComponent虚类。 而Menu类具有ArrayList menuComponents属性，用于储存包含在它下面的菜单以及具体的菜（因为都继承自同一虚类，所以。。） 接下来，设计迭代器 import java.util.*;  public class CompositeIterator implements Iterator {\tStack stack = new Stack();   \tpublic CompositeIterator(Iterator iterator) {\t\tstack.push(iterator);\t}   \tpublic Object next() {\t\tif (hasNext()) {\t\t\tIterator iterator = (Iterator) stack.peek();\t\t\tMenuComponent component = (MenuComponent) iterator.next();\t\t\tif (component instanceof Menu) {\t\t\t\tstack.push(component.createIterator());\t\t\t} \t\t\treturn component;\t\t} else {\t\t\treturn null;\t\t}\t}  \tpublic boolean hasNext() {\t\tif (stack.empty()) {\t\t\treturn false;\t\t} else {\t\t\tIterator iterator = (Iterator) stack.peek();\t\t\tif (!iterator.hasNext()) {\t\t\t\tstack.pop();\t\t\t\treturn hasNext();\t\t\t} else {\t\t\t\treturn true;\t\t\t}\t\t}\t}   \tpublic void remove() {\t\tthrow new UnsupportedOperationException();\t}} 因为利用了组合，这种结构是树形结构，所以它的迭代器与一般list等得迭代器不同，得做特殊处理，代码中利用了栈，首先构造器执行时，将树根迭代器压栈，在hasNext()方法中，判断栈是否为空，然后对栈顶元素进行处理。如果当前元素没有子菜单或者菜，就让当前元素出栈，然后递归hasNext()，继续处理栈里元素。在next中，对是否是菜单进行了判断，如果是就压栈，保证hasNext结果正确。 再来一个负责报菜单菜名的服务生类 import java.util.Iterator;  public class Waitress {\tMenuComponent allMenus; \tpublic Waitress(MenuComponent allMenus) {\t\tthis.allMenus = allMenus;\t} \tpublic void printMenu() {\t\tallMenus.print();\t}  \tpublic void printVegetarianMenu() {\t\tIterator iterator = allMenus.createIterator();\t\tSystem.out.println(\"\\nVEGETARIAN MENU\\n----\");\t\twhile (iterator.hasNext()) {\t\t\tMenuComponent menuComponent = \t\t\t\t\t(MenuComponent)iterator.next();\t\t\ttry {\t\t\t\tif (menuComponent.isVegetarian()) {\t\t\t\t\tmenuComponent.print();\t\t\t\t}\t\t\t} catch (UnsupportedOperationException e) {}\t\t}\t}} 可以看到，这个类的作用，仅仅是拿到菜单之后，执行print方法，而print方法之中具体是如何实现的，则不属于这个类的范围，如果有客人是素食主义者，可以由服务生在报菜名时只报素食。 注：这里的try..catch是因为menu不支持isVegetarian方法，所以将异常捕获而不做任何处理。 最后，设计复杂点的菜单，让服务生报出来 public class MenuTestDrive {\tpublic static void main(String args[]) {\t\tMenuComponent pancakeHouseMenu = \t\t\tnew Menu(\"PANCAKE HOUSE MENU\", \"Breakfast\");\t\tMenuComponent dinerMenu = \t\t\tnew Menu(\"DINER MENU\", \"Lunch\");\t\tMenuComponent cafeMenu = \t\t\tnew Menu(\"CAFE MENU\", \"Dinner\");\t\tMenuComponent dessertMenu = \t\t\tnew Menu(\"DESSERT MENU\", \"Dessert of course!\");  \t\tMenuComponent allMenus = new Menu(\"ALL MENUS\", \"All menus combined\");  \t\tallMenus.add(pancakeHouseMenu);\t\tallMenus.add(dinerMenu);\t\tallMenus.add(cafeMenu);  \t\tpancakeHouseMenu.add(new MenuItem(\t\t\t\"K&B's Pancake Breakfast\", \t\t\t\"Pancakes with scrambled eggs, and toast\", \t\t\ttrue,\t\t\t2.99));\t\tpancakeHouseMenu.add(new MenuItem(\t\t\t\"Regular Pancake Breakfast\", \t\t\t\"Pancakes with fried eggs, sausage\", \t\t\tfalse,\t\t\t2.99));\t\tpancakeHouseMenu.add(new MenuItem(\t\t\t\"Blueberry Pancakes\",\t\t\t\"Pancakes made with fresh blueberries, and blueberry syrup\",\t\t\ttrue,\t\t\t3.49));\t\tpancakeHouseMenu.add(new MenuItem(\t\t\t\"Waffles\",\t\t\t\"Waffles, with your choice of blueberries or strawberries\",\t\t\ttrue,\t\t\t3.59));\t\tdinerMenu.add(new MenuItem(\t\t\t\"Vegetarian BLT\",\t\t\t\"(Fakin') Bacon with lettuce & tomato on whole wheat\", \t\t\ttrue, \t\t\t2.99));\t\tdinerMenu.add(new MenuItem(\t\t\t\"BLT\",\t\t\t\"Bacon with lettuce & tomato on whole wheat\", \t\t\tfalse, \t\t\t2.99));\t\tdinerMenu.add(new MenuItem(\t\t\t\"Soup of the day\",\t\t\t\"A bowl of the soup of the day, with a side of potato salad\", \t\t\tfalse, \t\t\t3.29));\t\tdinerMenu.add(new MenuItem(\t\t\t\"Hotdog\",\t\t\t\"A hot dog, with saurkraut, relish, onions, topped with cheese\",\t\t\tfalse, \t\t\t3.05));\t\tdinerMenu.add(new MenuItem(\t\t\t\"Steamed Veggies and Brown Rice\",\t\t\t\"A medly of steamed vegetables over brown rice\", \t\t\ttrue, \t\t\t3.99)); \t\tdinerMenu.add(new MenuItem(\t\t\t\"Pasta\",\t\t\t\"Spaghetti with Marinara Sauce, and a slice of sourdough bread\",\t\t\ttrue, \t\t\t3.89));   \t\tdinerMenu.add(dessertMenu);  \t\tdessertMenu.add(new MenuItem(\t\t\t\"Apple Pie\",\t\t\t\"Apple pie with a flakey crust, topped with vanilla icecream\",\t\t\ttrue,\t\t\t1.59));\t\tdessertMenu.add(new MenuItem(\t\t\t\"Cheesecake\",\t\t\t\"Creamy New York cheesecake, with a chocolate graham crust\",\t\t\ttrue,\t\t\t1.99));\t\tdessertMenu.add(new MenuItem(\t\t\t\"Sorbet\",\t\t\t\"A scoop of raspberry and a scoop of lime\",\t\t\ttrue,\t\t\t1.89));\t\tcafeMenu.add(new MenuItem(\t\t\t\"Veggie Burger and Air Fries\",\t\t\t\"Veggie burger on a whole wheat bun, lettuce, tomato, and fries\",\t\t\ttrue, \t\t\t3.99));\t\tcafeMenu.add(new MenuItem(\t\t\t\"Soup of the day\",\t\t\t\"A cup of the soup of the day, with a side salad\",\t\t\tfalse, \t\t\t3.69));\t\tcafeMenu.add(new MenuItem(\t\t\t\"Burrito\",\t\t\t\"A large burrito, with whole pinto beans, salsa, guacamole\",\t\t\ttrue, \t\t\t4.29)); \t\tWaitress waitress = new Waitress(allMenus);   \t\twaitress.printVegetarianMenu(); \t}} 可以看到，迭代器加组合的设计，非常方便的处理了复杂的菜单业务，不仅代码层次清晰，各司其职，非常好的处理了耦合问题，而且使菜单与菜单、菜单与菜之间可以随意组合，将它们遍历也和遍历一个普通的list差不多，非常简单。","title":"迭代器和组合——head_first_DP"},{"content":"一. 写在前面的 这么多的设计模式，我觉得职责链是我第一次看上去最简单，可是回想起来却又最复杂的一个模式。 因此，这个文章我酝酿了很久，一直也没有胆量发出来，例子也是改了又改，可是仍然觉得不够合理。所以希望各位多多指教。 二. 什么是链 文章伊始，先让我们了解这个最基本的概念，什么是链。 我给链下了这样的定义： 1. 链是一系列节点的集合。 2. 链的各节点可灵活拆分再重组。 三. 何为职责链 职责链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。 图如下： UML很简单，让我们先来看一个简单的例子。 四. 职责链模式应用之请假管理 请假这个事情，相信每个人都不陌生。 我们公司是个相对很宽松的公司。 在公司里，如果你的请假时间小于0.5天，那么只需要向项目经理打声招呼就OK了。 如果超过了0.5天，但是还小于2天，那么就要去找人事部处理，当然，这就要扣工资了。 如果超过了2天，你就需要去找总经理了，工资当然也玩完了。 那么，对于我们来说，这个流程就是这样的。 也就是这样一个过程，你需要和你的直接上级——项目经理去打交道，最终可能是项目经理给你回邮件，可能是人事部给你回邮件，也可能是总经理给你回邮件。内部的过程其实应该是个黑盒子，你并不知道内部的消息是如何处理的。你需要找到的，只是你想要第一个交付的对象而已。 那么我们的代码应该是这样的。 首先我们要写一个请求的类。 class Request{    private int day;    private string reason;    public int Day    {        get { return day; }        set { day = value; }    }    public string Reason    {        get { return reason; }        set { reason = value; }    }    public Request(int day, string reason)    {        this.day = day;        this.reason = reason;    }} 接下来看下请求相应者，他们有两个核心方法，一个是相应操作，一个是选择继任者。 abstract class Boss{    private string name;    public string Name    {        get { return name; }        set { name = value; }    }    private Boss successor;    public Boss Successor    {        get { return successor; }        set { successor = value; }    }    public Boss(string name)    {        this.name = name;    }    public abstract bool PassRequest(Request request);}class PM:Boss{    public PM(string name)        : base(name)    { }    public override bool PassRequest(Request request)    {        int day = request.Day;        string reason = request.Reason;        if (day <= 0.5)        {            return true;        }        return Successor.PassRequest(request);    }}class HR:Boss{    public HR(string name)        : base(name)    { }    public override bool PassRequest(Request request)    {        int day = request.Day;        string reason = request.Reason;        if (day > 0.5&&day<=2)        {            return true;        }        return Successor.PassRequest(request);    }}class Manager : Boss{    public Manager(string name)        : base(name)    { }    public override bool PassRequest(Request request)    {        int day = request.Day;        string reason = request.Reason;        if (reason.Equals(\"正当理由\"))        {            return true;        }        return false;    }} 那么我们调用的时候就很简单了！ static void Main(string[] args){    Request request = new Request(3, \"非正当理由\");    Boss pm = new PM(\"pm\");    Boss hr = new HR(\"hr\");    Boss manager = new Manager(\"manager\");    pm.Successor = hr;    hr.Successor = manager;    bool pass = pm.PassRequest(request);    Console.Write(pass);} 五. 灵活在哪？ 让我们来看下职责链究竟灵活在哪？ 1. 改变内部的传递规则。 在内部，项目经理完全可以跳过人事部到那一关直接找到总经理。 每个人都可以去动态地指定他的继任者。 2. 可以从职责链任何一关开始。 如果项目经理不在，那么完全可以写这样的代码： static void Main(string[] args){    Request request = new Request(3, \"非正当理由\");    Boss pm = new PM(\"pm\");    Boss hr = new HR(\"hr\");    Boss manager = new Manager(\"manager\");    pm.Successor = hr;    hr.Successor = manager;    //bool pass = pm.PassRequest(request);    bool pass = hr.PassRequest(request);    Console.Write(pass);}   3. 我们来比较一下，用职责链和不用职责链的区别： 这是不用职责链我们的结构，我们需要和公司中的每一个层级都发生耦合关系。 如果反映在代码上即使我们需要在一个类中去写上很多丑陋的if….else语句。 如果用了职责链，相当于我们面对的是一个黑箱，我们只需要认识其中的一个部门，然后让黑箱内部去负责传递就好了。 六. 职责链 != 链表 很多人都愿意把职责链和链表混为一谈，确实，从字面意思上理解，链，链表，很像。可是他们一样么？ 他们区别在哪里： 让我们看一个链表的典型结构： 让我们来看一下链表的典型特征： 1. 链表是一个链状结构，每个节点有一个next属性去指向他的下一节点。 2. 链表有一个Header节点，然后用户每次必须通过头节点，然后去遍历寻找每一个节点。 3. 链表遍历操作的复杂度是O(n)，但是插入和删除指定节点的复杂度是常数级。 让我们来着重看这第二点： 我们来想想在文章开始时我们画出的那个链，一个链，我们可以从头将他拿起，也可以从中间将他拿起： 也就是说我们用户可以去访问节点中的任何一个节点作为开始节点，这就是链表与职责链不同的地方。 七. 职责链的扩展——树状链结构 职责链中，我们之前看到的都是一些单链结构，但是其实在很多情况下，每一个节点都对应着很多其他的部分。   那么这样，我们的每一个节点都可以使用一个List来维护他节点的下一节点，甚至可以用组合模式来分别设计每一节点。 八. 由法律想到——职责链的兜底条款 仔细想想法律条文，尤其是刑法，经常可以看到这样的条文： 1. 如果*********，则处以拘役处分。 2. 如果*********，则处以有期徒刑一年到十年。 3. 如果*********，则处以有期徒刑十年以上。 4. 如果*********，则**********。 5. 如果以上条件皆不满足，则*****************。 其实最后一条就叫做法律的兜底条款。这给了法官很大的自由裁量权，在一定程度上也降低了犯罪分子钻法律空子的可能性。 在我们的职责链中，如果不存在这样的兜底条款，那么用户如果不从首节点开始访问，那么就很可能出现异常的情况。于是我们应该为职责链设置一个默认的条款： 这样的话，任何一个处理无论如何访问，都能得到一个正常的处理。 九. 职责链的缺点 让我们继续回到上面的例子，我们发现，其实当请假时间超过2天的时候，PM和HR其实没有做任何的事情，而只是做了一个传递工作。 而传递工作之后，他们就成了垃圾对象。 也就是说，他们在实际的处理中，并没有发挥任何的作用。 那么当这个链结构比较长，比较复杂的话，会产生很多的内存垃圾对象。 这也就是职责链的最大缺点之所在。 十. 职责链的乱用 在和其他的人的讨论中，我发现他们的观点是： 只要一者传一者，那么就要用职责链。在我们的项目中，他们这样去用： abstract class DBHelper{     }interface IRequestHandler{    IDBHelper ReturnHelper(string dbName);}class RequestHandler:IRequestHandler{    private RequestHandler successor;    public RequestHandler Successor    {        get { return successor; }        set { successor = value; }    }    public abstract IDBHelper ReturnHelper(string dbName);}class SQLHelper : DBHelper{ }class OracleHelper : DBHelper{ }class DB2Helper : DBHelper{ }class SQL : RequestHandler{    public override IDBHelper ReturnHelper(string dbName)    {        if (dbName.Equals(\"SQL Server\"))        {            return new SQLHelper();        }        return Successor.ReturnHelper(dbName);    }}class Oracle : RequestHandler{    public override IDBHelper ReturnHelper(string dbName)    {        if (dbName.Equals(\"Oracle\"))        {            return new OracleHelper();        }        return Successor.ReturnHelper(dbName);    }}class DB2 : RequestHandler{    public override IDBHelper ReturnHelper(string dbName)    {        if (dbName.Equals(\"DB2\"))        {            return new DB2Helper();        }        return new SQLHelper();    }}   这样的话，每个类相当于只负责一个操作。 那么我们如何改进呢？第一，我们可以用一个工厂来实现。另外，我们可以用表驱动的方式来解决问题。 十一. 表驱动改进职责链 表驱动（Table driven），其实就是指用查表的方式来获取值。 那么我们用标驱动法来改进上面的例子： class HelperRequest{    private Dictionary<String, DBHelper> dic = new Dictionary<string, DBHelper>();    public void Add(string name,DBHelper helper)    {        dic.Add(name, helper);    }    public DBHelper GetHelper(string name)    {        DBHelper helper;        bool temp = dic.TryGetValue(name, out helper);        if (temp)        {            return helper;        }        return null;    }} 我想一个没有学过设计模式的人都会这样写的。一个学过设计模式很多年的人也会这样写的。 而怕的就是为了模式而模式，为了职责链而职责链了。 十二. 职责链在java script中的应用 我们想象这样一种情况： 我们都知道，在ASP.NET 的 Webform模型中页面是以控件树的形式去组织的。那么我们用右键点击其中的一个页面，那么这个事件就会找离他最近的控件，如果不存在，那么就去找他的父控件，如此递归下去，直到找到为止。 这其实就是一种职责链的体现！ 十三. 深析职责链的使用 职责链模式不能乱用，否则非常容易变成因为模式而模式的反例。 下面是我归纳出来的一些关于职责链方面的使用规则，只是个人的意见，还希望大家指教。 1， 如果存在N对N，或者是一般的常规线性关系，那么我们完全可以用表驱动来取代职责链。 2， 对象本身要经过什么处理是通过每个链上元素通过运行态来决定的，决定的因素是取决于对象的属性或者一些其他方面的策略。 3， 用户无论是从哪一个节点作为他的请求头节点，最终用户都可以得到一个请求的反馈。 4， 应怪怪建议，补充同级的处理！职责链并非是严格的上下级的传递，其中也包括同级的传递，职责链一样可以在同级之间做传递。 例如，继续用我们上面请假的那个做例子，也许我们公司有两个HR，事实上也是这样的，我们把前台“MM”也美称为人力资源部： static void Main(string[] args){    Request request = new Request(3, \"非正当理由\");    Boss pm = new PM(\"pm\");    Boss hr1 = new HR(\"Real HR\");    Boss hr2 = new HR(\"QiantaiMM\");    Boss manager = new Manager(\"manager\");    pm.Successor = hr1;    hr1.Successor = hr2;    hr2.Successor = manager;    bool pass = pm.PassRequest(request);    Console.Write(pass);} 其实这样也未尝不可。有人也许会说，那么这样的同样一个类的两个对象又有什么意义呢？ 那么我们不妨去试着这样改造这个HR的类。 enum HRType{    RealHR,    Qiantai}class HR:Boss{    private HRType type;    public HR(string name,HRType type)        : base(name)    {        this.type = type;    }    public override bool PassRequest(Request request)    {        int day = request.Day;        if (day>=0.5&&day<2)        {            switch (type)            {                 case HRType.RealHR:                    //扣工资                    return true;                    break;                case HRType.Qiantai:                    //不扣工资                    return true;                    break;            }        }        return Successor.PassRequest(request);    }} 这样，因为前台MM容易说话，很可能他就不去扣你的工资，如果你去先找的HR，那么你这天的工资就报销了。 同理，我们一样可以让他们的职责细化，比如说Real Hr负责0.5天到1天的，而Qiantai去负责1天到2天的，也未尝不可。 总之，职责链并非是单一的上下级的传递，一样可以实现同级的传递。   十四. 职责链总结 职责链是使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。 今天就写到这了，希望大家多多指教。","title":"行为模式——责任链(Chain of Responsibility)模式"},{"content":"最近参加面试，总是被问到设计模式的问题。本人作为一个实用派，完全没搞懂作为一个功能的实现者，设计模式到底有多重要。当然，本人的意思不是说设计模式没用或者不该了解，但是这是一个度的问题，简单的模式，常用的模式，了解并会用，是必然的，但是其他模式，更深层的东西，也许留给架构师来理解更好。毕竟程序员不是架构师，要是程序员懂的知识和架构师一样多，那么，还要架构师来干什么呢？ 　　于此苦闷中，特出来分享一下比较好的设计模式的介绍，以求朋友们能去应付那些蛋疼的笔试。 　　1、FACTORY——工程模式？ 　　追MM少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是MM爱吃的东西，虽然口味有所不同，但不管你带MM去麦当劳或肯德基，只管向服务员说“来四个鸡翅”就行了。麦当劳和肯德基就是生产鸡翅的Factory 　　工厂模式：客户类和工厂类分开。消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。 　　2、BUILDER——建造模式？ 　　MM最爱听的就是“我爱你”这句话了，见到不同地方的MM,要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到MM我只要按对应的键，它就能够用相应的语言说出“我爱你”这句话了，国外的MM也可以轻松搞掂，这就是我的“我爱你”builder。（这一定比美军在伊拉克用的翻译机好卖） 　　建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。 　　3、FACTORY METHOD——工厂方法模式？ 　　请MM去麦当劳吃汉堡，不同的MM有不同的口味，要每个都记住是一件烦人的事情，我一般采用Factory Method模式，带着MM到服务员那儿，说“要一个汉堡”，具体要什么样的汉堡呢，让MM直接跟服务员说就行了。 　　工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。 　　4、PROTOTYPE——原始模型模式？ 　　跟MM用QQ聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要copy出来放到QQ里面就行了，这就是我的情话prototype了。（100块钱一份，你要不要） 原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。 　　原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。 　　5、SINGLETON——单例模式？ 　　俺有6个漂亮的老婆，她们的老公都是我，我就是我们家里的老公Sigleton，她们只要说道“老公”，都是指的同一个人，那就是我(刚才做了个梦啦，哪有这么好的事) 　　单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的“单一实例”的需求时才可使用。 [b:9ceca65206]结构型模式[/b:9ceca65206] 　　6、ADAPTER——适配器模式？ 　　在朋友聚会上碰到了一个美女Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友kent了，他作为我和Sarah之间的Adapter，让我和Sarah可以相互交谈了(也不知道他会不会耍我) 　　适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。 　　7、BRIDGE——桥梁模式？ 　　早上碰到MM，要说早上好，晚上碰到MM，要说晚上好；碰到MM穿了件新衣服，要说你的衣服好漂亮哦，碰到MM新做的发型，要说你的头发好漂亮哦。不要问我“早上碰到MM新做了个发型怎么说”这种问题，自己用BRIDGE组合一下不就行了 　　桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以独立的变化。 　　8、COMPOSITE——合成模式？ 　　Mary今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件T恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM都会用Composite模式了，你会了没有？ 　　合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。 　　9、DECORATOR——装饰模式？ 　　Mary过完轮到Sarly过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上“最好的的礼物，就是爱你的Fita”，再到街上礼品店买了个像框（卖礼品的MM也很漂亮哦），再找隔壁搞美术设计的Mike设计了一个漂亮的盒子装起来……，我们都是Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？ 　　装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。 　　10、FACADE——门面模式？ 　　我有一个专业的Nikon相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但MM可不懂这些，教了半天也不会。幸好相机有Facade设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样MM也可以用这个相机给我拍张照片了。 　　门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。 　　11、FLYWEIGHT——享元模式？ 　　每天跟MM发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上MM的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是Flyweight，MM的名字就是提取出来的外部特征，根据上下文情况使用。 　　享元模式：FLYWEIGHT在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。 　　12、PROXY——代理模式？ 　　跟MM在网上聊天，一开头总是“hi,你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？”这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自己的回答，接收到其他的话时再通知我回答，怎么样，酷吧。 　　代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。 [b:9ceca65206]行为模式[/b:9ceca65206] 　　13、CHAIN OF RESPONSIBLEITY——责任链模式？ 　　晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上“Hi,可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条传给老师了，听说是个老处女呀，快跑! 　　责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接 起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。 　　14、COMMAND——命令模式？ 　　俺有一个MM家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送COMMAND，就数你最小气，才请我吃面。” 　　命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。 　　15、INTERPRETER——解释器模式？ 　　俺有一个《泡MM真经》，上面有各种泡MM的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟MM约会时，只要做一个Interpreter，照着上面的脚本执行就可以了。 　　解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。 　　16、ITERATOR——迭代子模式？ 　　我爱上了Mary，不顾一切的向她求婚。 Mary：“想要我跟你结婚，得答应我的条件” 我：“什么条件我都答应，你说吧” Mary：“我看上了那个一克拉的钻石” 我：“我买，我买，还有吗？” Mary：“我看上了湖边的那栋别墅” 我：“我买，我买，还有吗？” Mary：“我看上那辆法拉利跑车” 我脑袋嗡的一声，坐在椅子上，一咬牙：“我买，我买，还有吗？” …… 　　迭代子模式：迭代子模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代子模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。 　　17、MEDIATOR——调停者模式？ 　　四个MM打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就OK啦，俺得到了四个MM的电话。 　　调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。 　　18、MEMENTO——备忘录模式？ 　　同时跟几个MM聊天时，一定要记清楚刚才跟MM说了些什么话，不然MM发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个MM说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。 　　备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。 　　19、OBSERVER——观察者模式？ 　　想知道咱们公司最新MM情报吗？加入公司的MM情报邮件组就行了，tom负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦 　　观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。 　　20、STATE——状态模式？ 　　跟MM交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的MM就会说“有事情啦”，对你不讨厌但还没喜欢上的MM就会说“好啊，不过可以带上我同事么？”，已经喜欢上你的MM就会说“几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把MM的状态从不讨厌不喜欢变成喜欢哦。 　　状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。 　　21、STRATEGY——策略模式？ 　　跟不同类型的MM约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到MM的芳心，我的追MM锦囊中有好多Strategy哦。 　　策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。 　　22、TEMPLATE METHOD——模板模式？ 　　看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤(Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦(具体实现)； 　　模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。 　　23、VISITOR——访问者模式？ 　　情人节到了，要给每个MM送一束鲜花和一张卡片，可是每个MM送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下Visitor，让花店老板根据MM的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了； 　　访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。 ————————————————————————————————————————————— 这篇文章用一种通俗易懂的方式，简单地讲述了设计模式的作用，读者可以从中对设计模式有一个大概的了解，对以后更加具体地学习设计模式有一定地帮助。但要更加深入详细地了解各个设计模式，类之间的关系，还是要找一本专门的书。   转载地址：http://www.kuqin.com/design-patterns/20121011/332161.html","title":"转：恼人的设计模式"},{"content":"-潘宏 -2012年11月 -本人水平有限，疏忽错误在所难免，还请各位高手不吝赐教 -email: popyy@netease.com -weibo.com/panhong101 在游戏引擎以及产品开发中，程序员需要让大量的系统模块相互进行通信。在大多数时候，模块的数量是巨大的。在最坏的情况下，N个相互通信的模块需要N*(N-1)/2种依赖关系。就算是最简单的游戏产品，N的数目也是可观的。 如果设计者放任这种相互依赖的模块关系于不顾，整个系统将高度耦合，代码牵一发而动全身。对一个模块的修改，将导致多个模块无法工作，必须进行相应调整。这将导致程序员的焦躁情绪，从而很容易让局面难以控制。 此外，还需要忍受长时间的重新编译、长时间加班修补bug。这些是OOP设计模式（指GoF的经典著作所描述的）所要努力避免的。 一个设计合理、高效的系统，需要对模块进行解耦——使得模块间的依赖关系减少。同时开发者将获得更好的代码维护性和扩展性，并节省大量的编译时间。本文描述了一种基于observer模式的事件分发系统（Event Dispatch System，EDS），用来进行游戏模块的相互通信。在一般的情况下，N个模块的相互通讯只需要N种依赖关系（借助于EDS）。 我们通过描述基本知识来逐步构成我们对系统的深层理解。 Observer模式 Observer模式也叫publish/subscribe模式或listener模式，它实际上是一种利用callback方法进行通信的机制。依照GoF的描述，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。如下图所示， 我把上面的图帮你解释一下（如果你是该模式的专家，可以忽略解释）：一个Subject关联任意多个Observer，这在多态下也一样，一个子类ConcreteSubject也可以关联任意多个Observer。而Observer也自成体系，但Subject体系一般只操作基类Observer。开发者可以通过Subject::Attach和Subject::Detach将目标Observer绑定到它所关心的Subject身上，当Subject产生任何变化需要通知Observer的时候，Subject::Notify方法会通知所有被绑定的Observer。同时，得到通知的Observer都可以访问到它们所关心的Subject，得到它们相应的状态。 通俗地说，一个模块A如果想在模块B进入某种状态的时候，做一些事情，我们需要知道B进入状态的时机，并在该时机通知A。这引出我们所说的通知模型概念，在软件开发中，有两种通知模型被使用：Poll和Callback。 Poll通知模型 一种最简单的通知方法叫作轮询（poll）——模块A需要在每个CPU周期中查询B是否进入了该状态——这其实是一种主动的自我通知。比如： class B{public://...bool isFinished() const { return m_isFinished; }void cycle() { //...}private:// ...bool m_isFinished;};class A{public:void poll( B& b ){if( b.isFinished() ){// Do something}}};int main(){A a;B b;for(;;){b.cycle();a.poll( b );// ... }return 0;} A类的class object a，在每一个主循环周期中通过A::poll对B类的class object b进行状态查询，当发现B::isFinished返回true，也就是条件满足，则进行相应的操作。 这就是状态轮询惯用法——简单、直接，也有些野蛮！它有两个致命的缺点： 1）轮询代码是查询方主动调用，查询方不知道对方何时完成，因此如果需要对查询结果进行快速反应，需要在每个周期中进行查询调用，大量的CPU周期被浪费在无效的查询指令中。 2）当模块的数量提高，这种轮询方式将产生代码急剧膨胀，每两个有依赖关系的模块，都需要在周期中进行相互查询。这样的代码将难以甚至无法维护。 因此，轮询一般只在规模不大的几个模块间调用，并且模块状态不能太多。 Callback通知模型 和轮询相对的，是让B主动的通知A，A被动等待B的完成并通知，在这段等待时间中A可以继续做其他的事情，不用浪费CPU周期无谓地查询目标状态，这叫作callback——回调，也是observer模式的实现策略。很明显，callback克服了poll模型的两个致命缺点，但代码相对复杂一些。在C++ OOP中，我们一般有三种方式来实现callback。 1 使用静态成员函数 class A{public:static void onBFinished( void* param ){A* _this = static_cast<A*>(param);// ... Do something using _this}void cycle(){// Do something... }};typedef void (*FPtrOnBFinished)( void* param );class B{public:void setCallback( FPtrOnBFinished callback, void* param ) { m_callback = callback; m_param = param; }void cycle(){// Finished in some casesm_callback(m_param); // Notify the subscriber }private:FPtrOnBFinished   m_callback;void* m_param;};int main(){A a;B b;b.setCallback( A::onBFinished, &a );for(;;){a.cycle();b.cycle();}return 0;} 可以看到B存储了A的静态方法地址以及A class object指针，该指针将作为参数传递给A的静态方法，以决定到底是谁——哪个对象对该事件感兴趣，并通知它。 该指针实际上充当了非静态成员函数中this指针的作用——我们给static方法显示地放置了一个“this指针”——实参param，编译器不需要、也不可能干预static成员函数的this指针安插。这可以通过A::onBFinished看出，实参param被转换为A*，然后针对该指针（也就是subscriber本身——希望得到通知的观察者）进行相应操作。 很容易想到，class B的subscriber可以是多个，这也是observer的设计初衷。你可以扩展B的类接口来增加、减少subscriber和它们相应的callback。将它们妥善保存在一个容器里面，并在B::cycle中通过迭代通知每一个subscriber。 回调方法中的形参类型void*保证了subscriber对于publisher是类型无关的，只要它能够在相应的callback方法中被正确的cast成真实的类型，就可以了。这提供了很大的灵活性，是这种回调方法的中心思想。另一方面，这种方式也会导致潜在的类型安全问题——这要求客户程序员必须保证subscriber类型的一致性。如果把一个错误的类型对象作为param给了publisher，程序仍可以经过编译，但在运行期subscriber的callback方法中的cast会以失败告终，这通常是危险的。 2 使用指向成员函数的指针 class A{public:void onBFinished();void cycle(){// Do something...}};typedef void (A::*onBFinished)();class B{public:void setCallback( onBFinished callback, A* a ) { m_callback = callback; m_a = a; }void cycle(){// ...// Finished in some cases(m_a->*m_callback)();}private:onBFinished m_callback;A* m_a;};int main(){A a;B b;b.setCallback( &A::onBFinished, &a );for(;;){a.cycle();b.cycle();}return 0;  } static member function被替换成了指向成员函数的指针。 这对类型安全性起到了一定促进作用：在B::cycle中对指向成员函数的指针进行调用的时候，编译器会进行type-checking，从而将错误的类型匹配拦截在编译期。 另一方面，由于必须指定指向成员函数指针的类作用域，比如A::，B需要知道所有subscriber的类型。这在一定程度上增加了类的耦合性：系统每增加一个subscriber类，就需要在publisher类中定义相应的callback typedef，这将带来维护开销，并增加重编译时间。而这个问题在上面的static方法中是不存在的。 下面的方法则解决了类型安全和类耦合两个问题（这也是observer模式的一种正规实现方式）。 3 使用Listener类 建立一个监听器基类，使用多态方法进行通知。 class Listener{public:virtual ~Listener() {}virtual void onSomeEventReceive() = 0;};class A : public Listener{public:virtual void onSomeEventReceive(){//...Do something}};class B{public:void setListener( Listener* l ) { m_listener = l; }void cycle(){// Finished in some casesm_listener->onSomeEventReceive();}private:Listener* m_listener;};int main(){A a;B b;b.setListener( &a );for(;;){b->cycle();}return 0;  } 这种方法中，B不需要知道listener的具体类，它只需处理listener抽象类。系统通过多态来高效地复用基类代码。这很好地解决了上述的类型安全和类耦合两个问题： a）至少在B的层面上，B处理的必须是listener类，B只调用它的方法，编译器保证了这一点。 b）增加任何一个新的listener子类，B都不需要关心，它只处理listener类。B的代码不需要重新编译。 该方法有缺点吗？当然。缺点主要在于它使用了C++的virtual机制，这是C++的性能落后于C的主要开销之一——通过增加间阶层来提高设计抽象性而带来的开销。但，这样的性能损失相对于该结构所带来的设计优势而言，是可以接受甚至忽略的。 通过以上三个方法，我们看到了每种回调方式的优缺点。后面我们会使用listener方式来构建我们的事件系统，因为对于我们的系统来说，它更易于维护、扩展，更符合OOP精神。 游戏事件系统 现在我们回到游戏消息系统主题中来。首先我们已经决定使用回调方式来进行消息通知，更进一步来说，我们打算采用listener方案。接下来我们要考虑我们如何定义模块结构。 为了避免文章开头所说的N个模块的最差依赖关系N*(N-1)/2，同时为了保证每两个模块之间都可以进行通信，我们的事件系统将采用一个中介模块，这实际上是一个mediator模式（如果对mediator模式感兴趣，请参考GoF的书）的简化版本。整个系统结构如图所示： A到H每个模块都和mediator通信，Mediator会把相应的消息发给相应的模块。这样，N个模块的依赖关系只有N个——每个模块只和mediator相依赖。 为了设计出这个系统，我们开始结合observer模式思考，在listener例子里面，我们把subscriber作为一个listener指针存在于publisher中，我们说这个subscriber对这个publisher要发布的内容感兴趣——它等待着publisher的一个特定的条件产生，从而通知subscriber，它会做它该做的事情。然而，在那个例子中，两个模块是直接依赖的，并不适用于我们现在设计的这个系统，我们要实现的系统将提供一种“多路分派”——可以有多个subscriber接收同一个事件。在该系统中，需要把“特定条件的产生”变成一个实体用来在模块和mediator之间传递来进行间接依赖，一个很自然的方案就是command模式（ 如果对command模式感兴趣，请参考GoF的书），它封装着通信接收者需要完成的工作信息，将工作延迟到真正的目标。 这里，我不想牵扯太多的模式，因为这样会导致大量的题外细节。因此，我们暂时不使用标准的command模式，改用一个简单的事件结构体： struct GameEvent { int m_eventID; int m_params[6]; }; 一个整型事件ID和若干个自定义整型参数。对，没错，只有整型参数。那我们如何传递其他类型的东西呢？比如一个字符串什么的。一般来说，需要采用辅助数据结构，这和你的游戏引擎结构有很大的关系。比如用一个字符串池，用m_param来传递池索引等等类似的方案。 一个game event的数据类似这样： #define GAME_EVENT_ID_CLICK_BUTTON   1000 GameEvent event; event.m_eventID = GAME_EVENT_ID_CLICK_BUTTON; event.m_params[0] = 15; event.m_params[1] = 2666; 上面的event可能在游戏中解释为：一个按下按钮的事件，按下的按钮索引为15，这将产生ID为2666的脚本执行。具体的事件参数由接收它的模块来进行解释。 有了这样一个结构，我们就可以把它和对它感兴趣的模块进行关联。比如对GAME_EVENT_ID_CLICK_BUTTON事件感兴趣的是模块A、C、E、F。则在mediator中可以建立一个关联数组保存下面的关联： {GAME_EVENT_ID_CLICK_BUTTON, {A, C, E, F}} 每当一个publisher发送了一个GAME_EVENT_ID_CLICK_BUTTON事件给mediator，它都会把该消息转发给{A, C, E, F}模块组。这样，在系统运行的某个时刻，mediator将保存一个映射表，描述了注册的游戏事件以及要响应的模块，比如： {GAME_EVENT_ID_1, {A, B}} {GAME_EVENT_ID_5, {C}} {GAME_EVENT_ID_6, {A, M}} {GAME_EVENT_ID_11, {F, K, M, S}} {GAME_EVENT_ID_99, {D, B, P, T, X, Z}} ... 系统结构如下所示： 对该系统的实现 接下来我打算给该系统一个简单实现。给模块设计的类为： 中介模块Mediator： EventDispatcher 通信模块A-H： EventListener EventDispatcher* dispatcher;class EventDispatcher{public:EventDispatcher() { dispatcher = this; }void dispatchEvent( const GameEvent& event ){ListenerGroup::iterator it = m_listeners.find( event.m_eventID );if( it != m_listeners.end() ){list< EventListener* >& listeners = it->second; for( list< EventListener* >::iterator it2 = listeners.begin(); it2 != listeners.end(); ++it2 ){it2->handleEvent( event );}}}private:typedef map< int, list< EventListener* > > ListenerGroup;private:ListenerGroup m_listeners;friend class EventListener;};class EventListener{public:virtual ~EventListener() {}void addListener( int eventID, EventListener* listener ){EventDispatcher::ListenerGroup::iterator it = dispatcher->m_listeners.find( eventID );if( it == dispatcher->m_listeners.end() ){list<EventListener*> l;l.insert( l.begin, listener );dispatcher->m_listeners.insert( make_pair(eventID, l ) );}else{list<EventListener*>::iterator it2;for( it2 = it->second.begin(); it2 != it->second.end(); ++it2 ){if( *it2 == listener )continue;}it->second.insert( it->second.begin(), listener );}}void removeListener( int eventID, EventListener* listener ){EventDispatcher::ListenerGroup::iterator it = dispatcher->m_listeners.find( eventID );if( it != dispatcher->m_listeners.end() ){for( list<EventListener*>::iterator it2 = it->second.begin(); it2 != it->second.end(); ++it2 ){if( *it2 == listener ){it->second.erase(it2);break;}}if( it->second.empty() )dispatch->m_listeners.erase(it);}}virtual void handleEvent( const GameEvent& event ) = 0;private:};class A : public EventListener{public:A() { addListener( 5, this ); }virtual ~A() { removeListener( 5, this ); }virtual void handleEvent( const GameEvent& event ){assert( event.m_eventID == 5 );assert( event.m_params[0] == 1 );assert( event.m_params[1] == 2 );}};int main(){EventDispatcher eventDispatcher;A a;GameEvent event;event.m_eventID = 5;event.m_params[0] = 1;event.m_params[1] = 2;eventDispatcher.dispatchEvent( event );return 0;} （为了阅读方便，我把类的方法实现直接和声明放到了一起，在实际的开发中，除了需要inline的方法，应该将实现和声明分离） EventDispatch类即mediator保存了事件－模块映射表m_listeners。EventDispatch::dispatchEvent方法用来处理相应事件。 EventListener类是一个监听器基类，任何一个想成为subscriber的模块都该继承于它。两个方法 EventListener::addListener EventListener::removeListener 用来将subscriber增加到事件－模块映射表中，或将模块从表中删除。 EventListener::handleEvent方法是一个纯虚方法，subscriber子类应该实现该方法来处理它感兴趣的事件。比如class A就是一个subscriber，它将自己和ID为5的事件绑定——表明它对该事件感兴趣。当在main中通过EventDispatcher发送了一个5号事件的时候，A::handleEvent就会被callback并将5号事件发送给它进行处理。这里的模块传递为： main模块 -> event dispatcher(mediator) -> class A object 改进方向 以上实现只是一个基本结构——它完成基本的功能，但要让该事件系统达到工程级别并使用，还需要进一步的努力。以下几个改进留给感兴趣的读者当作练习完成。 1 将事件分发方法改为异步方式 这个改进是必须的！问题在于我们在EventDispatcher::dispatchEvent中使用了STL的容器迭代器进行事件分发，当一个事件被EventListener的子类模块通过EventListener::handleEvent进行处理的时候，可能会产生另一个event（比如在A::handleEvent里面再用EventDispatch分发一个事件），这会导致EventDispatcher::dispatchEvent中的迭代器被重复使用，STL不允许这种情况产生，程序崩溃！ 解决方案是在EventDispatcher::dispatchEvent中只把event存入一个pending容器中而不调用EventListener::handleEvent。然后给EventDispatcher安插一个flushEvents的接口，在里面统一调用EventListener::handleEvent来处理pending events然后清除掉它们。 2 将EventDispatcher设计为singleton模式 EventDispatcher应该只有一个，并应该被各个通信模块方便地访问。这意味着把它写成一个singleton模式是理所当然。就这么做吧！（关于singleton模式，请参考GoF的书） 3 增加通道 为了在不同的游戏界面中采用不同的事件表布局，可以给监听器组增加不同的通道，简单来说就是把EventDispatcher::m_listeners变成一个数组 EventDispatcher::m_listeners[N] 然后增加一个变量 EventDispatcher::m_curChannel 来表示当前使用的是数组的哪个维度——哪个通道。这样，我们就能够保留不同的界面事件布局而不用频繁的重新初始化。 4 增加Listener的优先级属性 可以给listener增加优先级，这样在EventDispatcher::dispatchEvent中对listener进行调用的时候将按照listener的优先级调用。这种特性可以用来实现一个很酷的功能——消息独占模块：把一个模块的优先级调成最大，然后给该listener增加一个“事件处理后中断后续listener处理”标志，可以让dispatcher在EventDispatcher::dispatchEvent的循环中只调用该优先级最大的listener的事件处理方法，然后终止掉循环。一个标准的模态对话框就可以用该特性实现。 总结 以上我们循序渐进地实现了一个基本的事件分发系统，它实现了对模块的解耦——通过一个中介模块event dispatcher。在一个普通的游戏中，事件的数量是很大的，但该方案保证了增加游戏事件的便利性。它保证了最小的耦合度——事件是完全独立的。理论上，发送者和接收者彼此都不需要了解彼此，这更像是一个广播系统，收听者可以随时打开或关闭收音机，广播电台根本不知道谁在收听广播。 这个系统已经在我们自己的多个项目中被使用，它确实提供给开发者一定的便利性和健壮性。希望你能够从这个系统中有所收获。","title":"一个基于observer模式的游戏事件分发系统"},{"content":"总感觉上一篇文章说的太过于简洁，无法阐明我对TabHost的理解。下面我用一张自己的画的图，来讲述我对TabHost的理解。 话不多说，上图： 还记得我们AddTab的时候，参数是一个TabSpec吗？ 好吧，我们来稍微了解一下TabSpec，这个类实在是非常简单，以至于我对于它甚至觉得没有什么可讲解的。  public class TabSpec {        private String mTag;        private IndicatorStrategy mIndicatorStrategy;        private ContentStrategy mContentStrategy;        private TabSpec(String tag) {            mTag = tag;        }        /**         * Specify a label as the tab indicator.         */        public TabSpec setIndicator(CharSequence label) {            mIndicatorStrategy = new LabelIndicatorStrategy(label);            return this;        }        /**         * Specify a label and icon as the tab indicator.         */        public TabSpec setIndicator(CharSequence label, Drawable icon) {            mIndicatorStrategy = new LabelAndIconIndicatorStrategy(label, icon);            return this;        }        /**         * Specify a view as the tab indicator.         */        public TabSpec setIndicator(View view) {            mIndicatorStrategy = new ViewIndicatorStrategy(view);            return this;        }        /**         * Specify the id of the view that should be used as the content         * of the tab.         */        public TabSpec setContent(int viewId) {            mContentStrategy = new ViewIdContentStrategy(viewId);            return this;        }        /**         * Specify a {@link android.widget.TabHost.TabContentFactory} to use to         * create the content of the tab.         */        public TabSpec setContent(TabContentFactory contentFactory) {            mContentStrategy = new FactoryContentStrategy(mTag, contentFactory);            return this;        }        /**         * Specify an intent to use to launch an activity as the tab content.         */        public TabSpec setContent(Intent intent) {            mContentStrategy = new IntentContentStrategy(mTag, intent);            return this;        }        public String getTag() {            return mTag;        }    } 相信对设计模式有所的了解的人一下就看出来了，           IndicatorStrategy mIndicatorStrategy;       ContentStrategy mContentStrategy; 正是两个策略接口，它们的意图是创建Indicator和Content的View以及如何Close这个View。而TabSpec正是承载这一切的一个实体类。 继续看上一篇文章，这回再结合图来看addTab这个函数，是不是有些清晰了呢？     public void addTab(TabSpec tabSpec) {        ......//得到你创建的IndicatorView        View tabIndicator = tabSpec.mIndicatorStrategy.createIndicatorView();        //在TabWidget（线性布局）中加入你所创建的IndicatorView        mTabWidget.addView(tabIndicator);        mTabSpecs.add(tabSpec);        if (mCurrentTab == -1) {            setCurrentTab(0);        }    } 这样，你所创建的TabSpec就变成Tab的模样显示在了View中。TabHost 的源码应该不难理解，我所阐述的不一定非常正确，希望大家还是多看看源码。经过这两篇文章，我相信自定义TabHost的布局应该没有任何难度了吧。","title":"浅谈Android的TabHost（二）"},{"content":"在阅读过程中有任何问题，请及时联系：egg。 邮箱：xtfggef@gmail.com 微博：http://weibo.com/xtfggef 如有转载，请说明出处：http://blog.csdn.net/zhangerqing 我们接着讨论设计模式，上篇文章我讲完了5种创建型模式，这章开始，我将讲下7种结构型模式：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。其中对象的适配器模式是各种模式的起源，我们看下面的图： 6、适配器模式（Adapter）  适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。首先，我们来看看类的适配器模式，先看类图： 核心思想就是：有一个Source类，拥有一个方法，待适配，目标接口时Targetable，通过Adapter类，将Source的功能扩展到Targetable里，看代码： public class Source {\tpublic void method1() {\t\tSystem.out.println(\"this is original method!\");\t}} public interface Targetable {\t/* 与原类中的方法相同 */\tpublic void method1();\t/* 新类的方法 */\tpublic void method2();} public class Adapter extends Source implements Targetable {\t@Override\tpublic void method2() {\t\tSystem.out.println(\"this is the targetable method!\");\t}} Adapter类继承Source类，实现Targetable接口，下面是测试类： public class AdapterTest {\tpublic static void main(String[] args) {\t\tTargetable target = new Adapter();\t\ttarget.method1();\t\ttarget.method2();\t}} 输出： this is original method! this is the targetable method! 这样Targetable接口的实现类就具有了Source类的功能。 对象的适配器模式 基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。看图：   只需要修改Adapter类的源码即可： public class Wrapper implements Targetable {\tprivate Source source;\t\tpublic Wrapper(Source source){\t\tsuper();\t\tthis.source = source;\t}\t@Override\tpublic void method2() {\t\tSystem.out.println(\"this is the targetable method!\");\t}\t@Override\tpublic void method1() {\t\tsource.method1();\t}} 测试类： public class AdapterTest {\tpublic static void main(String[] args) {\t\tSource source = new Source();\t\tTargetable target = new Wrapper(source);\t\ttarget.method1();\t\ttarget.method2();\t}} 输出与第一种一样，只是适配的方法不同而已。 第三种适配器模式是接口的适配器模式，接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。看一下类图： 这个很好理解，在实际开发中，我们也常会遇到这种接口中定义了太多的方法，以致于有时我们在一些实现类中并不是都需要。看代码： public interface Sourceable {\t\tpublic void method1();\tpublic void method2();} 抽象类Wrapper2： public abstract class Wrapper2 implements Sourceable{\t\tpublic void method1(){}\tpublic void method2(){}} public class SourceSub1 extends Wrapper2 {\tpublic void method1(){\t\tSystem.out.println(\"the sourceable interface's first Sub1!\");\t}} public class SourceSub2 extends Wrapper2 {\tpublic void method2(){\t\tSystem.out.println(\"the sourceable interface's second Sub2!\");\t}} public class WrapperTest {\tpublic static void main(String[] args) {\t\tSourceable source1 = new SourceSub1();\t\tSourceable source2 = new SourceSub2();\t\t\t\tsource1.method1();\t\tsource1.method2();\t\tsource2.method1();\t\tsource2.method2();\t}} 测试输出： the sourceable interface's first Sub1! the sourceable interface's second Sub2! 达到了我们的效果！  讲了这么多，总结一下三种适配器模式的应用场景： 类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。 对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。 接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。 7、装饰模式（Decorator） 顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例，关系图如下： Source类是被装饰类，Decorator类是一个装饰类，可以为Source类动态的添加一些功能，代码如下： public interface Sourceable {\tpublic void method();} public class Source implements Sourceable {\t@Override\tpublic void method() {\t\tSystem.out.println(\"the original method!\");\t}} public class Decorator implements Sourceable {\tprivate Sourceable source;\t\tpublic Decorator(Sourceable source){\t\tsuper();\t\tthis.source = source;\t}\t@Override\tpublic void method() {\t\tSystem.out.println(\"before decorator!\");\t\tsource.method();\t\tSystem.out.println(\"after decorator!\");\t}} 测试类： public class DecoratorTest {\tpublic static void main(String[] args) {\t\tSourceable source = new Source();\t\tSourceable obj = new Decorator(source);\t\tobj.method();\t}} 输出： before decorator! the original method! after decorator! 装饰器模式的应用场景： 1、需要扩展一个类的功能。 2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。） 缺点：产生过多相似的对象，不易排错！ 8、代理模式（Proxy） 其实每个模式名称就表明了该模式的作用，代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候回去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的带你就是这个意思。再如我们有的时候打官司，我们需要请律师，因为律师在法律方面有专长，可以替我们进行操作，表达我们的想法。先来看看关系图： 根据上文的阐述，代理模式就比较容易的理解了，我们看下代码： public interface Sourceable {\tpublic void method();} public class Source implements Sourceable {\t@Override\tpublic void method() {\t\tSystem.out.println(\"the original method!\");\t}} public class Proxy implements Sourceable {\tprivate Source source;\tpublic Proxy(){\t\tsuper();\t\tthis.source = new Source();\t}\t@Override\tpublic void method() {\t\tbefore();\t\tsource.method();\t\tatfer();\t}\tprivate void atfer() {\t\tSystem.out.println(\"after proxy!\");\t}\tprivate void before() {\t\tSystem.out.println(\"before proxy!\");\t}} 测试类： public class ProxyTest {\tpublic static void main(String[] args) {\t\tSourceable source = new Proxy();\t\tsource.method();\t}} 输出： before proxy! the original method! after proxy! 代理模式的应用场景： 如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法： 1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。 2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。 使用代理模式，可以将功能划分的更加清晰，有助于后期维护！ 9、外观模式（Facade） 外观模式是为了解决类与类之家的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口，看下类图：（我们以一个计算机的启动过程为例） 我们先看下实现类： public class CPU {\t\tpublic void startup(){\t\tSystem.out.println(\"cpu startup!\");\t}\t\tpublic void shutdown(){\t\tSystem.out.println(\"cpu shutdown!\");\t}} public class Memory {\t\tpublic void startup(){\t\tSystem.out.println(\"memory startup!\");\t}\t\tpublic void shutdown(){\t\tSystem.out.println(\"memory shutdown!\");\t}} public class Disk {\t\tpublic void startup(){\t\tSystem.out.println(\"disk startup!\");\t}\t\tpublic void shutdown(){\t\tSystem.out.println(\"disk shutdown!\");\t}} public class Computer {\tprivate CPU cpu;\tprivate Memory memory;\tprivate Disk disk;\t\tpublic Computer(){\t\tcpu = new CPU();\t\tmemory = new Memory();\t\tdisk = new Disk();\t}\t\tpublic void startup(){\t\tSystem.out.println(\"start the computer!\");\t\tcpu.startup();\t\tmemory.startup();\t\tdisk.startup();\t\tSystem.out.println(\"start computer finished!\");\t}\t\tpublic void shutdown(){\t\tSystem.out.println(\"begin to close the computer!\");\t\tcpu.shutdown();\t\tmemory.shutdown();\t\tdisk.shutdown();\t\tSystem.out.println(\"computer closed!\");\t}} User类如下： public class User {\tpublic static void main(String[] args) {\t\tComputer computer = new Computer();\t\tcomputer.startup();\t\tcomputer.shutdown();\t}} 输出： start the computer! cpu startup! memory startup! disk startup! start computer finished! begin to close the computer! cpu shutdown! memory shutdown! disk shutdown! computer closed! 如果我们没有Computer类，那么，CPU、Memory、Disk他们之间将会相互持有实例，产生关系，这样会造成严重的依赖，修改一个类，可能会带来其他类的修改，这不是我们想要看到的，有了Computer类，他们之间的关系被放在了Computer类里，这样就起到了解耦的作用，这，就是外观模式！ 10、桥接模式（Bridge） 桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化，像我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。我们来看看关系图： 实现代码： 先定义接口： public interface Sourceable {\tpublic void method();} 分别定义两个实现类： public class SourceSub1 implements Sourceable {\t@Override\tpublic void method() {\t\tSystem.out.println(\"this is the first sub!\");\t}} public class SourceSub2 implements Sourceable {\t@Override\tpublic void method() {\t\tSystem.out.println(\"this is the second sub!\");\t}} 定义一个桥，持有Sourceable的一个实例： public abstract class Bridge {\tprivate Sourceable source;\tpublic void method(){\t\tsource.method();\t}\t\tpublic Sourceable getSource() {\t\treturn source;\t}\tpublic void setSource(Sourceable source) {\t\tthis.source = source;\t}} public class MyBridge extends Bridge {\tpublic void method(){\t\tgetSource().method();\t}} 测试类： public class BridgeTest {\t\tpublic static void main(String[] args) {\t\t\t\tBridge bridge = new MyBridge();\t\t\t\t/*调用第一个对象*/\t\tSourceable source1 = new SourceSub1();\t\tbridge.setSource(source1);\t\tbridge.method();\t\t\t\t/*调用第二个对象*/\t\tSourceable source2 = new SourceSub2();\t\tbridge.setSource(source2);\t\tbridge.method();\t}} output： this is the first sub! this is the second sub! 这样，就通过对Bridge类的调用，实现了对接口Sourceable的实现类SourceSub1和SourceSub2的调用。接下来我再画个图，大家就应该明白了，因为这个图是我们JDBC连接的原理，有数据库学习基础的，一结合就都懂了。 11、组合模式（Composite） 组合模式有时又叫部分-整体模式在处理类似树形结构的问题时比较方便，看看关系图： 直接来看代码： public class TreeNode {\t\tprivate String name;\tprivate TreeNode parent;\tprivate Vector<TreeNode> children = new Vector<TreeNode>();\t\tpublic TreeNode(String name){\t\tthis.name = name;\t}\tpublic String getName() {\t\treturn name;\t}\tpublic void setName(String name) {\t\tthis.name = name;\t}\tpublic TreeNode getParent() {\t\treturn parent;\t}\tpublic void setParent(TreeNode parent) {\t\tthis.parent = parent;\t}\t\t//添加孩子节点\tpublic void add(TreeNode node){\t\tchildren.add(node);\t}\t\t//删除孩子节点\tpublic void remove(TreeNode node){\t\tchildren.remove(node);\t}\t\t//取得孩子节点\tpublic Enumeration<TreeNode> getChildren(){\t\treturn children.elements();\t}} public class Tree {\tTreeNode root = null;\tpublic Tree(String name) {\t\troot = new TreeNode(name);\t}\tpublic static void main(String[] args) {\t\tTree tree = new Tree(\"A\");\t\tTreeNode nodeB = new TreeNode(\"B\");\t\tTreeNode nodeC = new TreeNode(\"C\");\t\t\t\tnodeB.add(nodeC);\t\ttree.root.add(nodeB);\t\tSystem.out.println(\"build the tree finished!\");\t}} 使用场景：将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，数等。 12、享元模式（Flyweight） 享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。 FlyWeightFactory负责创建和管理享元单元，当一个客户端请求时，工厂需要检查当前对象池中是否有符合条件的对象，如果有，就返回已经存在的对象，如果没有，则创建一个新对象，FlyWeight是超类。一提到共享池，我们很容易联想到Java里面的JDBC连接池，想想每个连接的特点，我们不难总结出：适用于作共享的一些个对象，他们有一些共有的属性，就拿数据库连接池来说，url、driverClassName、username、password及dbname，这些属性对于每个连接来说都是一样的，所以就适合用享元模式来处理，建一个工厂类，将上述类似属性作为内部数据，其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。 看个例子： 看下数据库连接池的代码： public class ConnectionPool {\t\tprivate Vector<Connection> pool;\t\t/*公有属性*/\tprivate String url = \"jdbc:mysql://localhost:3306/test\";\tprivate String username = \"root\";\tprivate String password = \"root\";\tprivate String driverClassName = \"com.mysql.jdbc.Driver\";\tprivate int poolSize = 100;\tprivate static ConnectionPool instance = null;\tConnection conn = null;\t/*构造方法，做一些初始化工作*/\tprivate ConnectionPool() {\t\tpool = new Vector<Connection>(poolSize);\t\tfor (int i = 0; i < poolSize; i++) {\t\t\ttry {\t\t\t\tClass.forName(driverClassName);\t\t\t\tconn = DriverManager.getConnection(url, username, password);\t\t\t\tpool.add(conn);\t\t\t} catch (ClassNotFoundException e) {\t\t\t\te.printStackTrace();\t\t\t} catch (SQLException e) {\t\t\t\te.printStackTrace();\t\t\t}\t\t}\t}\t/* 返回连接到连接池 */\tpublic synchronized void release() {\t\tpool.add(conn);\t}\t/* 返回连接池中的一个数据库连接 */\tpublic synchronized Connection getConnection() {\t\tif (pool.size() > 0) {\t\t\tConnection conn = pool.get(0);\t\t\tpool.remove(conn);\t\t\treturn conn;\t\t} else {\t\t\treturn null;\t\t}\t}} 通过连接池的管理，实现了数据库连接的共享，不需要每一次都重新创建连接，节省了数据库重新创建的开销，提升了系统的性能！本章讲解了7种结构型模式，因为篇幅的问题，剩下的11种行为型模式，我们将另起篇章，敬请读者朋友们持续关注！ 有问题请联系egg: email:xtfggef@gmail.com    微博：http://weibo.com/xtfggef  ","title":"Java之美[从菜鸟到高手演变]之设计模式二"},{"content":"创建型设计模式、行为型设计模式以及结构型设计模式。 创建型的设计模式：单例模式(Singleton)、构建模式(Builder)、原型模式(Prototype)、抽象工厂模式(Abstract Factory)、工厂方法模式(Factory Method) 行为设计模式：策略模式(Strategy)、状态模式(State)、责任链模式(Chain of Responsibility)、解释器模式(Interpreter)、命令模式(Command)、观察者模式(Observer)、备忘录模式(Memento)、迭代器模式(Iterator)、模板方法模式(Template Method)、访问者模式(Visitor)、中介者模式(Mediator) 结构型设计模式：装饰者模式(Decorator)、代理模式(Proxy)、组合模式(Composite)、桥连接模式(Bridge)、适配器模式(Adapter)、蝇量模式(Flyweight)、外观模式(Facade)   简单工厂模式是属于创建型模式，又叫做静态工厂方法（StaticFactory Method）模式，但不属于23种GOF设计模式之一。 工厂角色、抽象产品角色、具体产品角色     工厂方法模式   工厂方法模式是类的创建模式，又叫虚拟构造子（Virtual Constructor）模式或者多态性工厂（Polymorphic Factory）模式。 工厂方法模式角色与结构 1.抽象工厂(Creator)角色：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。 　 2.具体工厂(Concrete Creator)角色：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建产品对象。 3.抽象产品(Product)角色：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。 4.具体产品(Concrete Product)角色：这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应。       抽象工厂模式 抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。      ","title":"设计模式"},{"content":"      单例模式（Singleton）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。懒汉式单例模式（返回时才创建对象，下面的例子就是）和饿汉式单例模式（在声明变量的时候就创建对象）。 类图： 代码实现： publicclass Singleton {     //1.构造方法私有化，不能在类的外部创建类。     private Singleton(){}     //2.创建私有的唯一实例。     privatestatic Singleton instance;     //3.创建公共的访问方法。（获取实例）     publicstatic Singleton getInstance(){        if(instance==null){            instance=new Singleton();        }        returninstance;     } } publicstaticvoid main(String[] args) {        Singleton sing1=Singleton.getInstance();        Singleton sing2=Singleton.getInstance();        Singleton sing3=Singleton.getInstance();               System.out.println(sing1);        System.out.println(sing2);        System.out.println(sing3);     } 运行结果：     Singleton.Singleton@1fc4bec     Singleton.Singleton@1fc4bec     Singleton.Singleton@1fc4bec 但是这还有问题！getInstance方法不是线程安全的，如果是多线程程序就可能产生两个对象。所以还要在getInstance方法加上synchronized关键字声明，synchronized关键字声明线程安全。 优点：统一管理数据，节省空间。 缺点：降低程序的效率。       本模式节省空间，降低了效率。就是用效率来换空间。（伦：设计程序在很多时候就是要找空间和效率的平衡点；达：在如今信息化的时代，速度比空间要重要）","title":"单例模式"},{"content":"框架代码下载地址：Demo代码下载 关于框架有意见 欢迎联系我一起探讨。 联系方式 我的QQ是275518834 问答是happy 操作方式：输入文本框设置线程数 点击第一个按钮请求10个地址信息 点击第二个按钮中断10个地址信息 1：判断当前网络环境 2：编写了3套方案 Old_GridViewActivity  简单线程回调   AsyncTask_GridViewActivity  使用android自带的AsyncTask类实现 Demo_GridViewActivity   队列任务管理  线程控制 1：队列优先级  （如果想要listview中移动的区域优先被显示，而不是从上到下显示图片，可以把新建的任务提到任务队列前端） 2：实现了：中断任务的功能（比如进入一个Activity会开启大量任务，如果退出这个Activity 则应该停止此Activity中驻留的任务） 3：为何采用drawable不用bitmap bitmap优点是位图运算效率优秀 但drawable的存储体积比bitmap小 4：如果任务被起名字则禁止重复提交任务  （避免某些请求未处理完又被创建） 5：先执行缓存数据后执行请求数据      （缓存性能） 6：使用状态模式 观察者模式更好的处理多线程  最初的想法：网络优化开发框架  (移除任务未完成） 网络稳定，系统运行稳定性，大内存消耗稳定，长时间运行稳定性 （旧的系统症结所在） 开启过多线程，导致系统频繁切换多个线程，导致处理速度过慢，经常出现未响应。 代码经常写的换繁多无序，维护困难。 使用类似银行叫号系统 线程池内等待网络请求的任务=（排队的人） 最大三个线程=（银行柜台处理业务的窗口） 依次处理任务=（将排队的人依次被叫到处理的号，完成业务的窗口叫号后面排队的人） 如果抛出异常则通知相关单位=（如果银行柜台处理不了一个人的业务就打电话给大堂经理） 设置柜台的监听回调=（A委托B去银行请求数据，当B去银行处理业务失败了，通知A。） 设置撤销机制和线程安全=     某机关让A和B去银行申请业务，A在排队，B正在柜台处理业务，此时机关打来电话说，     这申请业务的需求现在不做，A取消排队,B也‘礼貌的退出’     《例如退出A页面时，终止A页面所有的请求》 任务状态标示-还没处理 处理中 处理结束 处理异常 （有结果但不通知）=（排队人的状态） 任务名          排队人的名字 强制退出    强制退出 抛出强制退出的异常 package lxz.utils.android.network;import java.util.HashMap;import java.util.HashSet;import java.util.Observable;import java.util.Observer;import android.content.Context;import android.os.Handler;public abstract class Task implements Runnable, Observer {\tString debug = getClass().getSimpleName();\t// 名字映射\tprivate static HashMap<String, Task> nameTasks = new HashMap<String, Task>();\tpublic static HashMap<String, Task> getNameTask() {\t\treturn nameTasks;\t}\tpublic void setSingletonName(String singletonName) {\t\tthis.singletonName = singletonName;\t}\tpublic String getSingletonName() {\t\treturn singletonName;\t}\tpublic interface OnStartListen {\t\tvoid onStart(int taskID);\t}\tpublic interface OnProgressListen {\t\tvoid onProgress(int taskID, int progress);\t}\tpublic interface OnFinishListen {\t\tBoolean OnFinish(int taskID, Object data);\t}\tpublic interface OnSystemStartListen {\t\tvoid onSystemStart(int taskID);\t}\tpublic interface OnSystemFinishListen {\t\tBoolean OnSystemFinish(int taskID, Object data, Task t);\t}\t/** 请求参数 */\tprotected Object parameter;\t/** 任务开始监听 */\tprotected OnStartListen onStartListen;\t/** 任务进度监听 */\tprotected OnProgressListen onProgressListen;\t/** 任务完成监听 */\tprotected OnFinishListen onFinishListen;\t/** 任务在队列中完成 监听 */\tprotected OnSystemStartListen onSystemStartListen;\t/** 任务在队列中开始 监听 */\tprotected OnSystemFinishListen onSystemFinishListen;\t/** 用于任务完成后发送消息 */\tprotected Handler handler;\t/** 结果 */\tprotected Object result;\t/** 任务编号标示 */\tprotected int taskID;\t/** 任务名字标示 */\t/** 设置此任务名是否为单例，单例模式下，如果相同名字的任务未执行完，则无法添加新任务 */\tprotected String singletonName;\t/** 保存一个对象 */\tprotected Object tag;\t/** 获得当前自身线程的引用 在threadRun方法 */\tprotected Thread thread;\t/** 重连次数 */\tprotected int tryAgainCount = 1;\t/** 重连间隔 */\tprotected int tryAgainTime = 1000;\t/** 视图绑定 */\tprotected TaskViewHolder taskViewHolder;\t/** 任务观察者 */\tprotected TaskObservable taskObservable;\tprotected Context context;\tprotected Task() {\t}\tprotected Task(TaskViewHolder taskViewHolder) {\t\tsuper();\t\tthis.taskViewHolder = taskViewHolder;\t\tthis.handler = taskViewHolder.getActivityHandler();\t\tthis.taskViewHolder.getTaskObservable().addObserver(this);\t\tthis.context = taskViewHolder.getContext();\t\tthis.taskObservable = this.taskViewHolder.getTaskObservable();\t}\tprotected Task(TaskObservable taskObservable) {\t\tsuper();\t\ttaskObservable.addObserver(this);\t}\tpublic TaskViewHolder getTaskViewHolder() {\t\treturn taskViewHolder;\t}\tpublic void setTaskViewHolder(TaskViewHolder taskViewHolder) {\t\tthis.taskViewHolder = taskViewHolder;\t}\t/** 状态 */\tint status = UNTREATED;\tfinal static int ERROR = -1;\tfinal static int UNTREATED = 0;\tfinal static int FINSH = 1;\tfinal static int TREATEDING = 2;\t// 不处理\tfinal static int WITHOUT = 3;\t/** 启动线程 */\tpublic void threadRun() {\t\tthread = new Thread(this);\t\tthread.start();\t}\t// 中断Execute方法\tpublic abstract void shutDownExecute();\tpublic abstract Object cacheData(Object parameter);\t// 禁止被重写\tpublic final Object Execute() throws Exception {\t\t// TODO Auto-generated method stub\t\tif (onStartListen != null)\t\t\tonStartListen.onStart(taskID);\t\t// 队列中回调\t\tif (onSystemStartListen != null)\t\t\tonSystemStartListen.onSystemStart(taskID);\t\t// 状态从未处理改变为处理中\t\tstatus = TREATEDING;\t\t// 是否有缓存数据如果没有\t\tif ((result = cacheData(parameter)) == null) {\t\t\t// 失败重联次数\t\t\tfor (int i = 0; i < tryAgainCount; i++) {\t\t\t\ttry {\t\t\t\t\tresult = obtainData(result, parameter);\t\t\t\t\tbreak;\t\t\t\t} catch (Exception e) {\t\t\t\t\t// TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t\ttry {\t\t\t\t\t\tThread.sleep(tryAgainTime);\t\t\t\t\t} catch (Exception e1) {\t\t\t\t\t\t// TODO Auto-generated catch block\t\t\t\t\t\te1.printStackTrace();\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}      \t\t// 如果状态改变为处理完但不通知\t\tif (status != WITHOUT) {\t\t\tif (handler != null) {\t\t\t\thandler.obtainMessage(taskID, result).sendToTarget();\t\t\t}\t\t\tif (onFinishListen != null) {\t\t\t\tonFinishListen.OnFinish(taskID, result);\t\t\t}\t\t}\t\t  if (onSystemFinishListen != null) {\t\t\t\tonSystemFinishListen.OnSystemFinish(taskID, result, this);\t\t\t}\t\tstatus = FINSH;\t\treturn result;\t}\tpublic int getTryAgainCount() {\t\treturn tryAgainCount;\t}\tpublic void setTryAgainCount(int tryAgainCount) {\t\tthis.tryAgainCount = tryAgainCount;\t}\tpublic int getTryAgainTime() {\t\treturn tryAgainTime;\t}\tpublic void setTryAgainTime(int tryAgainTime) {\t\tthis.tryAgainTime = tryAgainTime;\t}\tpublic abstract Object obtainData(Object result, Object parameter)\t\t\tthrows Exception;\t@Override\tpublic void update(Observable observable, Object data) {\t\t// 移除观察\t\tobservable.deleteObserver(this);\t\t// 中断 停止关闭连接\t\tthis.shutDownExecute();\t\tthis.setWithout();\t\tif (this.thread != null) {\t\t\tthis.thread.interrupt();\t\t}\t\t// 错误尝试次数为0\t\tthis.tryAgainCount = 0;\t};\t@Override\tpublic void run() {\t\ttry {\t\t\tExecute();\t\t} catch (Exception e) {\t\t\ttaskID = ERROR;\t\t\t// 如果状态改变为处理完但不通知\t\t\tif (status != WITHOUT) {\t\t\t\tif (handler != null) {\t\t\t\t\thandler.obtainMessage(taskID, e).sendToTarget();\t\t\t\t}\t\t\t\tif (onFinishListen != null) {\t\t\t\t\tonFinishListen.OnFinish(taskID, e);\t\t\t\t}\t\t\t}\t\t\tif (onSystemFinishListen != null) {\t\t\t\tonSystemFinishListen.OnSystemFinish(taskID, e, this);\t\t\t}\t\t}\t}\tpublic void setWithout() {\t\tthis.status = WITHOUT;\t}\tpublic Object getTag() {\t\treturn tag;\t}\tpublic void setTag(Object tag) {\t\tthis.tag = tag;\t}\tpublic Thread getThread() {\t\treturn thread;\t}\tpublic int getStatus() {\t\treturn status;\t}\tpublic void setStatus(int status) {\t\tthis.status = status;\t}\tpublic Object getParameter() {\t\treturn parameter;\t}\tpublic void setParameter(Object parameter) {\t\tthis.parameter = parameter;\t}\tpublic OnStartListen getOnStartListen() {\t\treturn onStartListen;\t}\tpublic void setOnStartListen(OnStartListen onStartListen) {\t\tthis.onStartListen = onStartListen;\t}\tpublic OnProgressListen getOnProgressListen() {\t\treturn onProgressListen;\t}\tpublic void setOnProgressListen(OnProgressListen onProgressListen) {\t\tthis.onProgressListen = onProgressListen;\t}\tpublic OnFinishListen getOnFinishListen() {\t\treturn onFinishListen;\t}\tpublic void setOnFinishListen(OnFinishListen onFinishListen) {\t\tthis.onFinishListen = onFinishListen;\t}\tpublic OnSystemStartListen getOnSystemStartListen() {\t\treturn onSystemStartListen;\t}\tpublic OnSystemFinishListen getOnSystemFinishListen() {\t\treturn onSystemFinishListen;\t}\tpublic void setOnSystemFinishListen(\t\t\tOnSystemFinishListen onSystemFinishListen) {\t\tthis.onSystemFinishListen = onSystemFinishListen;\t}\tpublic Handler getHandler() {\t\treturn handler;\t}\tpublic void setHandler(Handler handler) {\t\tthis.handler = handler;\t}\tpublic int getTaskID() {\t\treturn taskID;\t}\tpublic void setTaskID(int taskID) {\t\tthis.taskID = taskID;\t}\tpublic Object getResult() {\t\treturn result;\t}\tpublic void setResult(Object result) {\t\tthis.result = result;\t}\tpublic void cacheClear() {\t\tif(parameter!=null)parameter=null;\t\tif(onStartListen!=null)onStartListen=null;\t\tif(onProgressListen!=null)onProgressListen=null;\t\tif(onFinishListen!=null)onFinishListen=null;\t\tif(onSystemStartListen!=null)onSystemStartListen=null;\t\tif(onSystemFinishListen!=null)onSystemFinishListen=null;\t\tif(handler!=null)handler=null;\t\tif(result!=null)result=null;\t\tif(singletonName!=null)singletonName=null;\t\tif(tag!=null)tag=null;\t\tif(thread!=null)thread=null;\t\tif(taskViewHolder!=null)taskViewHolder=null;\t\tif(taskObservable!=null)taskObservable=null;\t\tif(context!=null)context=null;\t}} package lxz.utils.android.network;import java.util.ArrayList;import java.util.LinkedList;import android.util.Log;import lxz.utils.android.network.Task.OnSystemFinishListen;public class TaskQueue implements Runnable, OnSystemFinishListen {\tstatic String debug = \"TaskQueue\";\t@SuppressWarnings(\"unchecked\")\t// 在等待的任务队列\tstatic LinkedList<Task> tasks_wait = new LinkedList<Task>();\t// 正在执行的任务\tstatic ArrayList<Task> tasks_running = new ArrayList<Task>();\t// 是否持续运行\tpublic static boolean isRun;\t// 队列线程\tprivate static Thread taskQueueThread;\t// runnable保证线程安全\tprivate static TaskQueue runnable = new TaskQueue();;\t// 最大线程数\tstatic int ThreadMaxNum = 1;\t// 如果队列线程为空或者停止则重新开启\tpublic static void serivesRun() {\t\t// TODO Auto-generated method stub\t\tif (taskQueueThread == null\t\t\t\t|| (taskQueueThread != null && taskQueueThread.getState() == Thread.State.TERMINATED)) {\t\t\ttaskQueueThread = new Thread(runnable);\t\t\t// taskQueueThread.setPriority(Thread.MAX_PRIORITY);\t\t\ttaskQueueThread.start();\t\t}\t}\t// 线程锁 如果等待队列的任务数不为空，并且当前线程数字少于最大线程数\tpublic static boolean taskRun() {\t\tsynchronized (tasks_wait) {\t\t\tsynchronized (tasks_running) {\t\t\t\treturn !tasks_wait.isEmpty()\t\t\t\t\t\t&& tasks_running.size() < ThreadMaxNum;\t\t\t}\t\t}\t}\tpublic void run() {\t\t// 线程锁 如果等待队列的任务数不为空，并且当前线程数字少于最大线程数\t\t\twhile (taskRun()) {\t\t\t// 添加带执行中动态数组中\t\t\tTask h;\t\t\tsynchronized (tasks_wait) {\t\t\t\t// 从等待任务的队列中获取并移除此列表的头（第一个元素）\t\t\t\th = tasks_wait.poll();\t\t\t\t// 如果h为空则从队列重新取对象或者任务绑定的状态变化了\t\t\t\tif (h == null || h.status == Task.WITHOUT) {\t\t\t\t\tLog.i(debug , \"任务取消 编号\" + h.getTaskID());      \t\t        //移除此名字映射\t\t             if(h.getSingletonName()!=null)\t\t             {\t\t            \t Task.getNameTask().remove(h.getSingletonName());\t\t             }\t\t\t\t\t\t\t\t\t\tcontinue;\t\t\t\t}\t\t\t\tsynchronized (tasks_running) {\t\t\t\t\ttasks_running.add(h);\t\t\t\t}\t\t\t\t\t Log.i(debug , \"正在执行任务数\"\t\t\t\t + tasks_running.size()+ \"/上限\" + ThreadMaxNum);\t\t\t\t// 为h设置完成或者报错进行监听\t\t\t\th.setOnSystemFinishListen(runnable);\t\t\t\t// 启动此线程\t\t\t\t\t\t\t}                h.threadRun();\t\t}\t}\t@Override\tpublic Boolean OnSystemFinish(int taskID, Object data, Task t) {\t\t// TODO Auto-generated method stub\t\tsynchronized (tasks_running) {\t\t\t// 从处理中的动态数组中移除此任务\t\t\ttasks_running.remove(t);\t\t\tLog.i(debug,\"执行队列中移除任务taskid=\" + t.taskID);\t\t\t// 通知执行后续未处理的任务\t\t\t Log.i(debug , \"正在执行任务数\"\t\t\t\t\t + tasks_running.size()+ \"/上限\" + ThreadMaxNum);\t\t\t \t\t\t //移除此名字映射             if(t.getSingletonName()!=null)             {            \t Task.getNameTask().remove(t.getSingletonName());             }\t\t}\t\trunnable.run();\t\tsynchronized (tasks_wait) {\t\t\t// 如果等待队列中的任务\t\t\tif (tasks_wait.isEmpty())\t\t\t\ttaskQueueThread = null;\t\t}\t\tt.cacheClear();\t\treturn true;\t}\t} 框架代码下载地址：Demo代码下载","title":"android 网络应用轻量框架"},{"content":"优点： 1、抽象工厂模式隔离了具体类的生产，使得客户并不需要知道什么被创建。 2、当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 3、增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。   缺点： 增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。","title":"抽象工厂模式的优缺点"},{"content":"1、一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。 2、系统中有多于一个的产品族，而每次只使用其中某一产品族。 3、属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。 4、系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。","title":"抽象工厂模式适用环境"},{"content":"      程序可以分为健壮的程序（扩展性强&效率高&人性化）和虚弱的程序（扩展性弱&效率不高&很难操作）。那怎么做程序才健壮呢？遵循设计原则。  原则的描述       设计原则不像设计模式那么多，原则只有7个而已。。。如下： 单一职责原则(Single Responsibility Principle,SRP): 概念：就一个类而言，应该仅有一个引起他变化的原因。（把变与不变的东西分离开来） 适应场景：如一个动物类有运动和休息两个职责，如果运动||休息责需要修改动物类都要修改，这样就有两个引起动物类变化的原因。 实现模式例子：把动物类细分为动物运动类和动物休息类，这样不管是运动功能需要修改还是休息功能需要修改都不会影响到另外的功能。 优点：修改一个功能时对其他功能的影响降低。 缺点：过分地遵循单一职责原则会产生职责扩散（产生大量的类），不过可以用一个大管家来管理。 里氏替换原则(The Liskov Substitution Principle,LSP）: 概念：子类型必须能够替换掉它们的父类型，而功能不变；子类可以扩展父类的功能，但不改变父类原有的功能。（继承不要重写方法） 适应场景：动物类有体力属性和跑&进食两个方法，一个狮子类继承了动物类重写了进食方法，跑方法必须有体力才成运行，动物类的进食方法增加体力。但狮子类的进食没有增加体力。这狮子就跑不动了。。 实现模式例子：狮子类添加新的进食方法，而不是重写进食方法。 优点：扩展对原来的功能的影响会降低。 缺点：只能实现编译时多态，不能实现运行时多态。 依赖倒转原则（Dependency Inversion Principle ,DIP）: 概念：高层模块不应该依赖底层模块，两者都应依赖抽象；抽象不应依赖细节，细节应依赖抽象。（面向接口编程） 适应场景：肉类和人类，中国人类有吃的方法需要肉类作为参数。3天后中国人类都变成素食者，程序就实现不了。 实现模式例子：但如果原本吃方法的参数是食物抽象类就可以解决这个问题。新建一个菜类继承食物类，把食物作为吃方法的参数。就可以实现素食啦。。 优点：大大提高了程序的扩展性。 缺点：增加了抽象类和接口。其实个人感觉不是问题。 接口分离原则（Interface Segregation Principle, ISP）: 概念：应当为客户提供尽可能小的单独的接口，而不是大的总接口。（不能分得太小） 适应场景：接口1有10个功能，有AB两个类实现它。但B类只需要3个功能。 实现模式例子：把这3个功能写成一个接口，然后接口1继承这接口。这样B类就不用实现它不需要的功能。就是把接口的粒度放小。 优点：不需要编写多余的代码，这多余的代码肯能会导致程序出错。 缺点：和单一职责原则一样会产生职责扩散。 合成/聚合复用原则(Composition/Aggregation Reuse Principle,CARP): 概念：要尽量使用合成/聚合，而不是继承关系达到复用。（组合胜于继承） 适应场景：一个很多内容的A类，只想修改A类的一个内容不懂其他东西。 实现模式例子：新建一个B类。创建A类属性和相同的方法签名，在方法里调用相应的方法。（达：这种方法用于重构比较好） 优点：聚合不像继承那么复杂，也可以很好的扩展。 缺点：A类和B类的耦合度很高。 迪米特法则/最少知识原则（Law of Demeter/Least Knowledge principle，LKP）: 概念：一个软件实体应当与尽可能少的其它实体发生作用。(接口也算第三者) 适应场景：A类调用B类。（适合任何的解耦） 实现模式例子： 创建C类调用B类，A类调用C类。（B类创建实现一个接口） 优点：很好的解耦。 缺点：过度遵循此原则会有大量的第三者。 开-闭原则（Open Closed Principle, OCP）: 概念：软件模块（类，模块，函数等等）应该可以在不可修改的情况下扩展。（程序无法做到完全的关闭；但类可以做到，如后面说到的BaseDao。） 适应场景：任何场景。 实现模式例子：此原则跟前面的6种有所不同，此原则只是告诉我们要做到怎样，但没有说要怎样做。。此模式更像是前面6种原则的结果。如果能把握好前面的6种原则扩展性自然就会加强。 优点：程序的扩展性。 缺点：无法完全实现，   原则间的关系        * LSP是DIP的基础，DIP是LSP的重要补充。        *OCP与DIP是目标和手段的关系。OCP是目标, DIP是到达OCP的手段。DIP是对\"抽象化\"的最好规范；由于OCP依赖DIP，LSP是DIP的基础，所以LSP也是OCP基础。        *ISP也是OCP的一个重要手段。 温情提示：除了OCP之外其他原则都要把握好“度”。","title":"OO设计原则"},{"content":"概述 代理模式，即ProxyPattern，java常用设计模式之一，动态代理实现了著名的AOP思想。代理模式的思想是为了提供额外的处理或者不同的操作而在实际对象与调用者之间插入一个代理对象。这些额外的操作通常需要与实际对象进行通信。 通俗的讲，可以拿到现实中来举例，可能说的并不准确，比如，苹果出了一款iphone手机，拿到中国交给代理商来卖，如联通、电信，就是所谓的定制机，联通电信又给iphone手机植入了一些软件，再卖给使用者。我们最后买到的手机就是代理商处理过的。 静态代理 静态代理很好理解，代码类似如下： 原类： package staticProxy; public class Object {    public void service() {       // do something    } }   代理类： package staticProxy; public class ProxyObject {    private staticProxy.Object obj;    public ProxyObject(staticProxy.Object obj) {       this.obj = obj;    }    public void service() {       // do something       this.obj.service();    } } 静态代理需要对每个原类创建一个代理类，这样做需要代理的情况少的话还可以接受，如果多的话，就无法接受了，所以我们需要一种动态创建代理类的方式。 动态代理 Java支持动态代理，可以在运行期根据原对象来动态创建代理对象。有两种方式可以实现动态代理，一种是通过JDK Proxy，另一种是第三方类库CGLIB，前者得到的代理对象是实现和原类相同的接口，后者得到的是继承自原类。下面主要介绍的是JDK Proxy。 Proxy类中有个newProxyInstance方法，可以通过该方法得到代理对象，该方法有三个参数： ClassLoader loader：原类的类加载器； Class[] interfaces：原类实现的接口列表； InvocationHandler handler：指派方法调用的调用处理程序。 调用该方法创建代理对象时，会把InvocationHandler传入$Proxy内，并根据相应接口生成方法，每个方法内都调用InvocationHandler中的invoke方法，在invoke方法中执行相应方法。 原理图 实现 Advice.java，增强类，用于创建代理对象时增强功能。 public class Advice {    /** 前置增强 */    public void beforeMethod() {       System.out.println(\"前置增强\");    }    /** 后置增强 */    public void afterMethod() {       System.out.println(\"后置增强\");    }    /** 异常增强 */    public void catchMethod() {       System.out.println(\"异常增强\");    }    /** 最后执行增强 */    public void finallyMethod() {       System.out.println(\"最后增强\");    } }   ProxyFactory.java，代理类工厂，用于产生代理对象。 public class ProxyFactory {    /** 代理类的增强对象 */    private Advice advice;    /** 代理的目标对象 */    private Object target;    public ProxyFactory() {}    public ProxyFactory(Advice advice, Object target) {       this.advice = advice;       this.target = target;    }    /**     * 得到代理对象     * @return     */    public Object getProxy() {       Object proxy = Proxy.newProxyInstance(            target.getClass().getClassLoader(),            target.getClass().getInterfaces(), new InvocationHandler() {               /**                * 代理对象需要执行的方法                */               public Object invoke(Object proxy, Method method, Object[] args) {                  Object result = null;                  advice.beforeMethod();                  try {                     result = method.invoke(target, args);                     advice.afterMethod();                  } catch (Exception e) {                     advice.catchMethod();                  } finally {                     advice.finallyMethod();                  }                  return result;               }            });       return proxy;    }    public void setAdvice(Advice advice) {       this.advice = advice;    }    public void setTarget(Object target) {       this.target = target;    } }   ITest.java，目标对象接口。 public interface ITest {    void test(); }   Test.java，目标对象类。 public class Test implements ITest {    public void test() {       System.out.println(\"目标对象\");    }    public static void main(String[] args) {       ProxyFactory pf = new ProxyFactory(new Advice(), new Test());       ITest test = (ITest) pf.getProxy();       test.test();    } }   输出结果： 前置增强 目标对象 后置增强 最后增强 总结 动态代理实现了AOP思想，AOP弥补了OOP的不足。本篇主要介绍的是jdk proxy动态代理的使用方式，对AOP没有特意说明。","title":"代理模式"},{"content":"                                                    状态模式 本来我还在纠结要说什么模式好，但前几天听到了一件有趣的事，有个研究生曾经把几千行的代码写在一个类里面（里面有无数个if else if else….if else，而且那些方法都在里面实现），然后编译之后根本没错，但是却把系统拖垮了？什么原因了，一位大神帮他找了很久很久都找不出错误。却在最后发觉那个类编译后的class文件大于64KB…….这警示我们写代码要有点技巧，好吧！那我就说一下状态模式，让大家摆脱一下if else痛苦的挣扎吧！   顺便看看我真实例子，我记得我曾经做过一个android的考试系统，会有2个状态：用户没WIFI或者Internet不能上网和用户能够上网： （1）假如能够上网 网上拿考试题目 （2）假如不能上网 数据库拿考试题目 由于以前写代码太年轻了   If(State ==1){        XXOO… } Else if(State==2){     XXOO…. } …….   （可能我毕业了，你们来维护我的代码，谁能明白1，2，3，4这些魔鬼数字呢？）     好吧，后来我从2B青年进化为普通青年了，请看下面：   public static final int INTER_EXAM=1; public static final int DB_EXAM=2; if(State == INTER_EXAM){        XXOO… } ……   这样会不会好一点点呢？呵呵，后面看了设计模式，就变为文艺青年了: Public abstract class State{        dojob(); } Public class InternetState implements State{        dojob(){               XXOO… } } Public class DBState implements State{        dojob(){               XXOO… } } Public class Handle { State Internet_State; State  DB_State; State  state =null;        Public voidinit(){               Internet_State  =  newInternetState();               DB_State= new DBState(); } Public void dojob(){        If(能上网){               state = Internet_State;               state.dojob(); } Else{               state = DB_State;               state.dojob(); } } }     好处： （1）             为了方便举例，所以状态少了点，优势不太多，但当你有上十种状态的时候，而且手机的状态是在无时无刻变化的，这样就很容易管理了 （2）             当你要修改代码时，只需要找到具体State那个类，修改dojob就OK了。 （3）             当需要添加状态的时候，只需要再写一个具体的State来实现抽象State的接口就OK了   你想宁愿在你那堆无限冗余复杂的if else 里面痛苦挣扎，还是比较喜欢这种优雅的管理方式呢？  ","title":"模式设计（三）------状态模式"},{"content":"  单例模式： 抽象定义：顾名思义，就是只有一个实例。 作为对象的创建模式， 单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类。 简介：很多人以为单例模式很简单，几行代码之内搞掂,其实这是比较2的。   Public class Test{        Privatestatic Test instance = null; Public static TestgetInstance(){        If(instace == null)           instace = new Test();        return instance; } ………. ………. }     在没看设计模式之前，其实我自己也很2，自以为是很聪明，其实打错特错了。 请看以下分析就知道： 有些小聪明的人觉得，这还是不很简单的问题，自己加锁就OK啦，只需轻轻加上synchronized就收工了 Public class Test{        Privatestatic Test instance = null; Public static synchronizedTest getInstance(){        If(instace == null)           instace = new Test();        return instance; } ………. ………. } 当然这也是一种解决方法，只是因为加锁的原因，每个时刻只能是单一线程来访问，假如很多很多线程同时访问，就只能在队列中慢慢等候了……   学问是永无止境的，其实有更加优雅的方法来解决这个问题----“双重检查加锁”   Public class Test{        Privatevolatile static Test instance;        Publicstatic Test getInstance(){               If(instance== null){                      Synchronized(Test.class){                             If(instance== null)                             Instance= new Test(); } } Return instance;  } }   到这里我们是不是觉得我们以前写代码弱爆，而且很多误区。","title":"模式设计（二）------单例模式"},{"content":"序：         在杰哥和谢老师的交导下，我一个不小心接触到了设计模式。加上自己强烈的求知欲，不小心研究了一下。但是觉得 自己没有掌握到。所以开个博客和网友们探讨探讨。 我们就带着下面的问题来探讨吧（如果有不同意见的网友可以留言）：        什么是设计模式？什么时候要用设计模式？为什么要用设计模式？设计模式用来做什么？有哪些设计模式？   1.设计模式简介         设计模式是一套前人总结的解决方案（解决问题的方法，后面\"模式\"==\"设计模式\"），就好像36计，72变等。GoF把他 们写出一本书《设计模式》，每个模式都有一个特定的适用场合。在遇到适当的环境使用模式会提高程序的扩张性，如果在 不适当的环境中用模式会怎样呢？举个例吧：A国派15个兵攻打B国，B国有1W兵守城，B国用走为上策。简单点说就是很糟。 所以有这样的一个说法（滥用设计模式）。   2.设计模式的分类         通常说的设计模式是指GoF的《设计模式》一书所说的23种设计模式。23种设计模式又分为3个类别：如下 创建型：单例模式，工厂方法，抽象工厂，原型模式，建造者模式。 结构型：适配器模式，外观模式，代理模式，装饰模式，桥接模式，组合模式，享元模式。 行为型：模板方法模式，策略模式，中介者/调停者模式，观察者模式，访问者模式，命令模式，                 责任链模式，状态模式，解析器模式，迭代器模式，备忘录模式，   3.设计模式的四个基本要素         不止这23中模式，任何的模式也有以下四种特点： *模式名字：每一个模式都有相对应的名字，用于与人讨论。 *适用场景：每个设计模式都一个对应此模式的场景。（认清场景，不适合就不要用。）遇到以后扩展可能要用一个模式，这          时就不知道这么办了。 *好处：可以提高程序的灵活性、扩充性、可移植性和健壮性等。。。 *坏处：任何事都会有反作用的，程序变得复杂；一个模式解决了一个问题有可能会出现另一个问题（模式的不完善）。         4.设计原则         前面说到模式是前人总结的。但前人是怎样发现模式的呢？是基于什么发现模式的呢？答案是设计原则。模式是把 设计原则作为基石而形成的物体。设计原则有7个： *单一职责原则：类的职责一致。（啊伦：把变与不变的东西分离开来） *里氏替换原则：子类能替代父类的出现。（继承不要重写方法） *依赖倒转原则：高模块不应以来底模块，两者依赖抽象。（类的关系终止于抽象） *接口分离原则：接口的内容量尽量少。（但不能分得太小） *合成/聚合复用原则：尽量用组合形式扩展而不是用继承。 *迪米特法则/最少知识原则：一个对象内尽量不要出现别的对象，如果要调用就使用第三者。（过度遵循此原则会有大量的第三者） *开-闭原则：对扩展开放，对修改封闭。对扩展开放，对修改封闭。（这只是一个概念不能完全封闭） 5.设计模式和框架         在这也顺便谈谈对设计模式和框架的看法。设计模式是一套被反复使用、经过分类编目的、代码设计经验的总结。而架构是一个 完成了一部分的程序。 共同点：都是抽象出来的东西！模式是抽象解决事情的方法，架构也是抽象解决问题的方法。但架构的粒度比模式要高。 不同点：构件是代码重用，模式是设计重用，而架构是构件和模式的集合体。既有代码重用也有设计重用；因为构件局限了架构，所以 模式比架构更通用（抽象）。   本人是第一次写这些东东&文化低，可能写得不是很好！希望网友们体谅~~~~谢谢。。","title":"设计模式开章"},{"content":"一、设计模式的分类 总体来说设计模式分为三大类： 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 其实还有两类：并发型模式和线程池模式。用一个图片来整体描述一下： 二、设计模式的六大原则 1、开闭原则（Open Close Principle） 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle） 里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 3、依赖倒转原则（Dependence Inversion Principle） 这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 5、迪米特法则（最少知道原则）（Demeter Principle） 为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle） 原则是尽量使用合成/聚合的方式，而不是使用继承。 三、Java的23中设计模式 从这一块开始，我们详细介绍Java中23种设计模式的概念，应用场景等情况，并结合他们的特点及设计模式的原则进行分析。 1、工厂方法模式 工厂方法模式分为三种： 11、普通工厂模式，就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。首先看下关系图： 举例如下：（我们举一个发送邮件和短信的例子） 首先，创建二者的共同接口： [java] view plaincopyprint? public interface Sender { public void Send(); } public interface Sender {\tpublic void Send();} 其次，创建实现类： [java] view plaincopyprint? public class MailSender implements Sender { @Override public void Send() { System.out.println(\"this is mailsender!\"); } } public class MailSender implements Sender {\t@Override\tpublic void Send() {\t\tSystem.out.println(\"this is mailsender!\");\t}} [java] view plaincopyprint? public class SmsSender implements Sender { @Override public void Send() { System.out.println(\"this is sms sender!\"); } } public class SmsSender implements Sender {\t@Override\tpublic void Send() {\t\tSystem.out.println(\"this is sms sender!\");\t}} 最后，建工厂类： [java] view plaincopyprint? public class SendFactory { public Sender produce(String type) { if (\"mail\" == type) { return new MailSender(); } else if (\"sms\" == type) { return new SmsSender(); } else { System.out.println(\"请输入正确的类型!\"); return null; } } } public class SendFactory {\tpublic Sender produce(String type) {\t\tif (\"mail\" == type) {\t\t\treturn new MailSender();\t\t} else if (\"sms\" == type) {\t\t\treturn new SmsSender();\t\t} else {\t\t\tSystem.out.println(\"请输入正确的类型!\");\t\t\treturn null;\t\t}\t}} 我们来测试下： [java] view plaincopyprint? public class FactoryTest { public static void main(String[] args) { SendFactory factory = new SendFactory(); Sender sender = factory.produce(\"sms\"); sender.Send(); } } public class FactoryTest {\tpublic static void main(String[] args) {\t\tSendFactory factory = new SendFactory();\t\tSender sender = factory.produce(\"sms\");\t\tsender.Send();\t}} 输出：this is sms sender! 22、多个工厂方法模式，是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。关系图： 将上面的代码做下修改，改动下SendFactory类就行，如下： [java] view plaincopyprint? public class SendFactory { public Sender produceMail(){ return new MailSender(); } public Sender produceSms(){ return new SmsSender(); } } public class SendFactory {\t\tpublic Sender produceMail(){\t\treturn new MailSender();\t}\t\tpublic Sender produceSms(){\t\treturn new SmsSender();\t}} 测试类如下： [java] view plaincopyprint? public class FactoryTest { public static void main(String[] args) { SendFactory factory = new SendFactory(); Sender sender = factory.produceMail(); sender.Send(); } } public class FactoryTest {\tpublic static void main(String[] args) {\t\tSendFactory factory = new SendFactory();\t\tSender sender = factory.produceMail();\t\tsender.Send();\t}} 输出：this is mailsender! 33、静态工厂方法模式，将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。 [java] view plaincopyprint? public class SendFactory { public static Sender produceMail(){ return new MailSender(); } public static Sender produceSms(){ return new SmsSender(); } } public class SendFactory {\t\tpublic static Sender produceMail(){\t\treturn new MailSender();\t}\t\tpublic static Sender produceSms(){\t\treturn new SmsSender();\t}} [java] view plaincopyprint? public class FactoryTest { public static void main(String[] args) { Sender sender = SendFactory.produceMail(); sender.Send(); } } public class FactoryTest {\tpublic static void main(String[] args) {\t\t\tSender sender = SendFactory.produceMail();\t\tsender.Send();\t}} 输出：this is mailsender! 总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。 2、抽象工厂模式 工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。因为抽象工厂不太好理解，我们先看看图，然后就和代码，就比较容易理解。 请看例子： [java] view plaincopyprint? public interface Sender { public void Send(); } public interface Sender {\tpublic void Send();} 两个实现类： [java] view plaincopyprint? public class MailSender implements Sender { @Override public void Send() { System.out.println(\"this is mailsender!\"); } } public class MailSender implements Sender {\t@Override\tpublic void Send() {\t\tSystem.out.println(\"this is mailsender!\");\t}} [java] view plaincopyprint? public class SmsSender implements Sender { @Override public void Send() { System.out.println(\"this is sms sender!\"); } } public class SmsSender implements Sender {\t@Override\tpublic void Send() {\t\tSystem.out.println(\"this is sms sender!\");\t}} 两个工厂类： [java] view plaincopyprint? public class SendMailFactory implements Provider { @Override public Sender produce(){ return new MailSender(); } } public class SendMailFactory implements Provider {\t\t@Override\tpublic Sender produce(){\t\treturn new MailSender();\t}} [java] view plaincopyprint? public class SendSmsFactory implements Provider{ @Override public Sender produce() { return new SmsSender(); } } public class SendSmsFactory implements Provider{\t@Override\tpublic Sender produce() {\t\treturn new SmsSender();\t}} 在提供一个接口： [java] view plaincopyprint? public interface Provider { public Sender produce(); } public interface Provider {\tpublic Sender produce();} 测试类： [java] view plaincopyprint? public class Test { public static void main(String[] args) { Provider provider = new SendMailFactory(); Sender sender = provider.produce(); sender.Send(); } } public class Test {\tpublic static void main(String[] args) {\t\tProvider provider = new SendMailFactory();\t\tSender sender = provider.produce();\t\tsender.Send();\t}} 其实这个模式的好处就是，如果你现在想增加一个功能：发及时信息，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！ 3、单例模式 单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处： 1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。 2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。 3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。 首先我们写一个简单的内部类： [java] view plaincopyprint? public class Singleton { /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */ private static Singleton instance = null; /* 私有构造方法，防止被实例化 */ private Singleton() { } /* 静态工程方法，创建实例 */ public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */ public Object readResolve() { return instance; } } public class Singleton {\t/* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */\tprivate static Singleton instance = null;\t/* 私有构造方法，防止被实例化 */\tprivate Singleton() {\t}\t/* 静态工程方法，创建实例 */\tpublic static Singleton getInstance() {\t\tif (instance == null) {\t\t\tinstance = new Singleton();\t\t}\t\treturn instance;\t}\t/* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */\tpublic Object readResolve() {\t\treturn instance;\t}} 这个类可以满足基本要求，但是，像这样毫无线程安全保护的类，如果我们把它放入多线程的环境下，肯定就会出现问题了，如何解决？我们首先会想到对getInstance方法加synchronized关键字，如下： [java] view plaincopyprint? public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } public static synchronized Singleton getInstance() {\t\tif (instance == null) {\t\t\tinstance = new Singleton();\t\t}\t\treturn instance;\t} 但是，synchronized关键字锁住的是这个对象，这样的用法，在性能上会有所下降，因为每次调用getInstance()，都要对对象上锁，事实上，只有在第一次创建对象的时候需要加锁，之后就不需要了，所以，这个地方需要改进。我们改成下面这个： [java] view plaincopyprint? public static Singleton getInstance() { if (instance == null) { synchronized (instance) { if (instance == null) { instance = new Singleton(); } } } return instance; } public static Singleton getInstance() {\t\tif (instance == null) {\t\t\tsynchronized (instance) {\t\t\t\tif (instance == null) {\t\t\t\t\tinstance = new Singleton();\t\t\t\t}\t\t\t}\t\t}\t\treturn instance;\t} 似乎解决了之前提到的问题，将synchronized关键字加在了内部，也就是说当调用的时候是不需要加锁的，只有在instance为null，并创建对象的时候才需要加锁，性能有一定的提升。但是，这样的情况，还是有可能有问题的，看下面的情况：在Java指令中创建对象和赋值操作是分开进行的，也就是说instance = new Singleton();语句是分两步执行的。但是JVM并不保证这两个操作的先后顺序，也就是说有可能JVM会为新的Singleton实例分配空间，然后直接赋值给instance成员，然后再去初始化这个Singleton实例。这样就可能出错了，我们以A、B两个线程为例： a>A、B线程同时进入了第一个if判断 b>A首先进入synchronized块，由于instance为null，所以它执行instance = new Singleton(); c>由于JVM内部的优化机制，JVM先画出了一些分配给Singleton实例的空白内存，并赋值给instance成员（注意此时JVM没有开始初始化这个实例），然后A离开了synchronized块。 d>B进入synchronized块，由于instance此时不是null，因此它马上离开了synchronized块并将结果返回给调用该方法的程序。 e>此时B线程打算使用Singleton实例，却发现它没有被初始化，于是错误发生了。 所以程序还是有可能发生错误，其实程序在运行过程是很复杂的，从这点我们就可以看出，尤其是在写多线程环境下的程序更有难度，有挑战性。我们对该程序做进一步优化： [java] view plaincopyprint? private static class SingletonFactory{ private static Singleton instance = new Singleton(); } public static Singleton getInstance(){ return SingletonFactory.instance; } private static class SingletonFactory{                 private static Singleton instance = new Singleton();             }             public static Singleton getInstance(){                 return SingletonFactory.instance;             } 实际情况是，单例模式使用内部类来维护单例的实现，JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。这样当我们第一次调用getInstance的时候，JVM能够帮我们保证instance只被创建一次，并且会保证把赋值给instance的内存初始化完毕，这样我们就不用担心上面的问题。同时该方法也只会在第一次调用的时候使用互斥机制，这样就解决了低性能问题。这样我们暂时总结一个完美的单例模式： [java] view plaincopyprint? public class Singleton { /* 私有构造方法，防止被实例化 */ private Singleton() { } /* 此处使用一个内部类来维护单例 */ private static class SingletonFactory { private static Singleton instance = new Singleton(); } /* 获取实例 */ public static Singleton getInstance() { return SingletonFactory.instance; } /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */ public Object readResolve() { return getInstance(); } } public class Singleton {\t/* 私有构造方法，防止被实例化 */\tprivate Singleton() {\t}\t/* 此处使用一个内部类来维护单例 */\tprivate static class SingletonFactory {\t\tprivate static Singleton instance = new Singleton();\t}\t/* 获取实例 */\tpublic static Singleton getInstance() {\t\treturn SingletonFactory.instance;\t}\t/* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */\tpublic Object readResolve() {\t\treturn getInstance();\t}} 其实说它完美，也不一定，如果在构造函数中抛出异常，实例将永远得不到创建，也会出错。所以说，十分完美的东西是没有的，我们只能根据实际情况，选择最适合自己应用场景的实现方法。 通过单例模式的学习告诉我们： 1、单例模式理解起来简单，但是具体实现起来还是有一定的难度。 2、synchronized关键字锁定的是对象，在用的时候，一定要在恰当的地方使用（注意需要使用锁的对象和过程，可能有的时候并不是整个对象及整个过程都需要锁）。 到这儿，单例模式基本已经讲完了，结尾处，笔者突然想到另一个问题，就是采用类的静态方法，实现单例模式的效果，也是可行的，此处二者有什么不同？ 首先，静态类不能实现接口。（从类的角度说是可以的，但是那样就破坏了静态了。因为接口中不允许有static修饰的方法，所以即使实现了也是非静态的） 其次，单例可以被延迟初始化，静态类一般在第一次加载是初始化。之所以延迟加载，是因为有些类比较庞大，所以延迟加载有助于提升性能。 再次，单例类可以被继承，他的方法可以被覆写。但是静态类内部方法都是static，无法被覆写。 最后一点，但例类比较灵活，毕竟从实现上只是一个普通的Java类，只要满足单例的基本需求，你可以在里面随心所欲的实现一些其它功能，但是静态类不行。从上面这些概括中，基本可以看出二者的区别，但是，从另一方面讲，我们上面最后实现的那个单例模式，内部就是用一个静态类来实现的，所以，二者有很大的关联，只是我们考虑问题的层面不同罢了。两种思想的结合，才能造就出完美的解决方案，就像HashMap采用数组+链表来实现一样，其实生活中很多事情都是这样，单用不同的方法来处理问题，总是有优点也有缺点，最完美的方法是，结合各个方法的优点，才能最好的解决问题！ 4、建造者模式 工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的Test结合起来得到的。我们看一下代码： 还和前面一样，一个Sender接口，两个实现类MailSender和SmsSender。最后，建造者类如下： [java] view plaincopyprint? public class Builder { private List<Sender> list = new ArrayList<Sender>(); public void produceMailSender(int count){ for(int i=0; i<count; i++){ list.add(new MailSender()); } } public void produceSmsSender(int count){ for(int i=0; i<count; i++){ list.add(new SmsSender()); } } } public class Builder {\t\tprivate List<Sender> list = new ArrayList<Sender>();\t\tpublic void produceMailSender(int count){\t\tfor(int i=0; i<count; i++){\t\t\tlist.add(new MailSender());\t\t}\t}\t\tpublic void produceSmsSender(int count){\t\tfor(int i=0; i<count; i++){\t\t\tlist.add(new SmsSender());\t\t}\t}} 测试类： [java] view plaincopyprint? public class Test { public static void main(String[] args) { Builder builder = new Builder(); builder.produceMailSender(10); } } public class Test {\tpublic static void main(String[] args) {\t\tBuilder builder = new Builder();\t\tbuilder.produceMailSender(10);\t}} 从这点看出，建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。所以与工程模式的区别就是：工程模式关注的是创建单个产品，而建造者模式则关注创建符合对象，多个部分。因此，是选择工程模式还是建造者模式，依实际情况而定。 5、原型模式 原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。本小结会通过对象的复制，进行讲解。在Java中，复制对象是通过clone()实现的，先创建一个原型类： [java] view plaincopyprint? public class Prototype implements Cloneable { public Object clone() throws CloneNotSupportedException { Prototype proto = (Prototype) super.clone(); return proto; } } public class Prototype implements Cloneable {\tpublic Object clone() throws CloneNotSupportedException {\t\tPrototype proto = (Prototype) super.clone();\t\treturn proto;\t}} 很简单，一个原型类，只需要实现Cloneable接口，覆写clone方法，此处clone方法可以改成任意的名称，因为Cloneable接口是个空接口，你可以任意定义实现类的方法名，如cloneA或者cloneB，因为此处的重点是super.clone()这句话，super.clone()调用的是Object的clone()方法，而在Object类中，clone()是native的，具体怎么实现，我会在另一篇文章中，关于解读Java中本地方法的调用，此处不再深究。在这儿，我将结合对象的浅复制和深复制来说一下，首先需要了解对象深、浅复制的概念： 浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。 深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。 此处，写一个深浅复制的例子： [java] view plaincopyprint? public class Prototype implements Cloneable, Serializable { private static final long serialVersionUID = 1L; private String string; private SerializableObject obj; /* 浅复制 */ public Object clone() throws CloneNotSupportedException { Prototype proto = (Prototype) super.clone(); return proto; } /* 深复制 */ public Object deepClone() throws IOException, ClassNotFoundException { /* 写入当前对象的二进制流 */ ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); /* 读出二进制流产生的新对象 */ ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return ois.readObject(); } public String getString() { return string; } public void setString(String string) { this.string = string; } public SerializableObject getObj() { return obj; } public void setObj(SerializableObject obj) { this.obj = obj; } } class SerializableObject implements Serializable { private static final long serialVersionUID = 1L; } public class Prototype implements Cloneable, Serializable {\tprivate static final long serialVersionUID = 1L;\tprivate String string;\tprivate SerializableObject obj;\t/* 浅复制 */\tpublic Object clone() throws CloneNotSupportedException {\t\tPrototype proto = (Prototype) super.clone();\t\treturn proto;\t}\t/* 深复制 */\tpublic Object deepClone() throws IOException, ClassNotFoundException {\t\t/* 写入当前对象的二进制流 */\t\tByteArrayOutputStream bos = new ByteArrayOutputStream();\t\tObjectOutputStream oos = new ObjectOutputStream(bos);\t\toos.writeObject(this);\t\t/* 读出二进制流产生的新对象 */\t\tByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());\t\tObjectInputStream ois = new ObjectInputStream(bis);\t\treturn ois.readObject();\t}\tpublic String getString() {\t\treturn string;\t}\tpublic void setString(String string) {\t\tthis.string = string;\t}\tpublic SerializableObject getObj() {\t\treturn obj;\t}\tpublic void setObj(SerializableObject obj) {\t\tthis.obj = obj;\t}}class SerializableObject implements Serializable {\tprivate static final long serialVersionUID = 1L;} 要实现深复制，需要采用流的形式读入当前对象的二进制输入，再写出二进制数据对应的对象。","title":"Java之美[从菜鸟到高手演变]之设计模式"},{"content":"场景问题 　　举个生活中常见的例子——组装电脑，我们在组装电脑的时候，通常需要选择一系列的配件，比如CPU、硬盘、内存、主板、电源、机箱等。为讨论使用简单点，只考虑选择CPU和主板的问题。 　　事实上，在选择CPU的时候，面临一系列的问题，比如品牌、型号、针脚数目、主频等问题，只有把这些问题都确定下来，才能确定具体的CPU。 　　同样，在选择主板的时候，也有一系列问题，比如品牌、芯片组、集成芯片、总线频率等问题，也只有这些都确定了，才能确定具体的主板。 　　选择不同的CPU和主板，是每个客户在组装电脑的时候，向装机公司提出的要求，也就是我们每个人自己拟定的装机方案。 　　在最终确定这个装机方案之前，还需要整体考虑各个配件之间的兼容性。比如：CPU和主板，如果使用Intel的CPU和AMD的主板是根本无法组装的。因为Intel的CPU针脚数与AMD主板提供的CPU插口不兼容，就是说如果使用Intel的CPU根本就插不到AMD的主板中，所以装机方案是整体性的，里面选择的各个配件之间是有关联的。 　　对于装机工程师而言，他只知道组装一台电脑，需要相应的配件，但是具体使用什么样的配件，还得由客户说了算。也就是说装机工程师只是负责组装，而客户负责选择装配所需要的具体的配件。因此，当装机工程师为不同的客户组装电脑时，只需要根据客户的装机方案，去获取相应的配件，然后组装即可。 使用简单工厂模式的解决方案 　　考虑客户的功能，需要选择自己需要的CPU和主板，然后告诉装机工程师自己的选择，接下来就等着装机工程师组装电脑了。 　　对装机工程师而言，只是知道CPU和主板的接口，而不知道具体实现，很明显可以用上简单工厂模式或工厂方法模式。为了简单，这里选用简单工厂。客户告诉装机工程师自己的选择，然后装机工程师会通过相应的工厂去获取相应的实例对象。 源代码 CPU接口与具体实现 public interface Cpu {    public void calculate();} public class IntelCpu implements Cpu {    /**     * CPU的针脚数     */    private int pins = 0;    public  IntelCpu(int pins){        this.pins = pins;    }    @Override    public void calculate() {        // TODO Auto-generated method stub        System.out.println(\"Intel CPU的针脚数：\" + pins);    }} public class AmdCpu implements Cpu {    /**     * CPU的针脚数     */    private int pins = 0;    public  AmdCpu(int pins){        this.pins = pins;    }    @Override    public void calculate() {        // TODO Auto-generated method stub        System.out.println(\"AMD CPU的针脚数：\" + pins);    }} 主板接口与具体实现 public interface Mainboard {    public void installCPU();} public class IntelMainboard implements Mainboard {    /**     * CPU插槽的孔数     */    private int cpuHoles = 0;    /**     * 构造方法，传入CPU插槽的孔数     * @param cpuHoles     */    public IntelMainboard(int cpuHoles){        this.cpuHoles = cpuHoles;    }    @Override    public void installCPU() {        // TODO Auto-generated method stub        System.out.println(\"Intel主板的CPU插槽孔数是：\" + cpuHoles);    }} public class AmdMainboard implements Mainboard {    /**     * CPU插槽的孔数     */    private int cpuHoles = 0;    /**     * 构造方法，传入CPU插槽的孔数     * @param cpuHoles     */    public AmdMainboard(int cpuHoles){        this.cpuHoles = cpuHoles;    }    @Override    public void installCPU() {        // TODO Auto-generated method stub        System.out.println(\"AMD主板的CPU插槽孔数是：\" + cpuHoles);    }} CPU与主板工厂类 public class CpuFactory {    public static Cpu createCpu(int type){        Cpu cpu = null;        if(type == 1){            cpu = new IntelCpu(755);        }else if(type == 2){            cpu = new AmdCpu(938);        }        return cpu;    }} public class MainboardFactory {    public static Mainboard createMainboard(int type){        Mainboard mainboard = null;        if(type == 1){            mainboard = new IntelMainboard(755);        }else if(type == 2){            mainboard = new AmdMainboard(938);        }        return mainboard;    }} 装机工程师类与客户类运行结果如下： public class ComputerEngineer {    /**     * 定义组装机需要的CPU     */    private Cpu cpu = null;    /**     * 定义组装机需要的主板     */    private Mainboard mainboard = null;    public void makeComputer(int cpuType , int mainboard){        /**         * 组装机器的基本步骤         */        //1:首先准备好装机所需要的配件        prepareHardwares(cpuType, mainboard);        //2:组装机器        //3:测试机器        //4：交付客户    }    private void prepareHardwares(int cpuType , int mainboard){        //这里要去准备CPU和主板的具体实现，为了示例简单，这里只准备这两个        //可是，装机工程师并不知道如何去创建，怎么办呢？                //直接找相应的工厂获取        this.cpu = CpuFactory.createCpu(cpuType);        this.mainboard = MainboardFactory.createMainboard(mainboard);                //测试配件是否好用        this.cpu.calculate();        this.mainboard.installCPU();    }} public class Client {    public static void main(String[]args){        ComputerEngineer cf = new ComputerEngineer();        cf.makeComputer(1,1);    }} 运行结果如下： 上面的实现，虽然通过简单工厂方法解决了：对于装机工程师，只知CPU和主板的接口，而不知道具体实现的问题。但还有一个问题没有解决，那就是这些CPU对象和主板对象其实是有关系的，需要相互匹配的。而上面的实现中，并没有维护这种关联关系，CPU和主板是由客户任意选择，这是有问题的。比如在客户端调用makeComputer时，传入参数为(1,2)，运行结果如下： 观察上面结果就会看出问题。客户选择的是Intel的CPU针脚数为755，而选择的主板是AMD，主板上的CPU插孔是938，根本无法组装，这就是没有维护配件之间的关系造成的。该怎么解决这个问题呢？　　 引进抽象工厂模式 　　每一个模式都是针对一定问题的解决方案。抽象工厂模式与工厂方法模式的最大区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则需要面对多个产品等级结构。 　　在学习抽象工厂具体实例之前，应该明白两个重要的概念：产品族和产品等级。 　　所谓产品族，是指位于不同产品等级结构中，功能相关联的产品组成的家族。比如AMD的主板、芯片组、CPU组成一个家族，Intel的主板、芯片组、CPU组成一个家族。而这两个家族都来自于三个产品等级：主板、芯片组、CPU。一个等级结构是由相同的结构的产品组成，示意图如下： 　显然，每一个产品族中含有产品的数目，与产品等级结构的数目是相等的。产品的等级结构与产品族将产品按照不同方向划分，形成一个二维的坐标系。横轴表示产品的等级结构，纵轴表示产品族，上图共有两个产品族，分布于三个不同的产品等级结构中。只要指明一个产品所处的产品族以及它所属的等级结构，就可以唯一的确定这个产品。 　　上面所给出的三个不同的等级结构具有平行的结构。因此，如果采用工厂方法模式，就势必要使用三个独立的工厂等级结构来对付这三个产品等级结构。由于这三个产品等级结构的相似性，会导致三个平行的工厂等级结构。随着产品等级结构的数目的增加，工厂方法模式所给出的工厂等级结构的数目也会随之增加。如下图： 　　　　那么，是否可以使用同一个工厂等级结构来对付这些相同或者极为相似的产品等级结构呢？当然可以的，而且这就是抽象工厂模式的好处。同一个工厂等级结构负责三个不同产品等级结构中的产品对象的创建。 可以看出，一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象。显然，这时候抽象工厂模式比简单工厂模式、工厂方法模式更有效率。对应于每一个产品族都有一个具体工厂。而每一个具体工厂负责创建属于同一个产品族，但是分属于不同等级结构的产品。 抽象工厂模式结构 　　抽象工厂模式是对象的创建模式，它是工厂方法模式的进一步推广。 　　假设一个子系统需要一些产品对象，而这些产品又属于一个以上的产品等级结构。那么为了将消费这些产品对象的责任和创建这些产品对象的责任分割开来，可以引进抽象工厂模式。这样的话，消费产品的一方不需要直接参与产品的创建工作，而只需要向一个公用的工厂接口请求所需要的产品。 　　通过使用抽象工厂模式，可以处理具有相同（或者相似）等级结构中的多个产品族中的产品对象的创建问题。如下图所示： 由于这两个产品族的等级结构相同，因此使用同一个工厂族也可以处理这两个产品族的创建问题，这就是抽象工厂模式。 　　根据产品角色的结构图，就不难给出工厂角色的结构设计图。 可以看出，每一个工厂角色都有两个工厂方法，分别负责创建分属不同产品等级结构的产品对象。 源代码 　　前面示例实现的CPU接口和CPU实现对象，主板接口和主板实现对象，都不需要变化。 　　前面示例中创建CPU的简单工厂和创建主板的简单工厂，都不再需要。 　　新加入的抽象工厂类和实现类： public interface AbstractFactory {    /**     * 创建CPU对象     * @return CPU对象     */    public Cpu createCpu();    /**     * 创建主板对象     * @return 主板对象     */    public Mainboard createMainboard();} public class IntelFactory implements AbstractFactory {    @Override    public Cpu createCpu() {        // TODO Auto-generated method stub        return new IntelCpu(755);    }    @Override    public Mainboard createMainboard() {        // TODO Auto-generated method stub        return new IntelMainboard(755);    }} public class AmdFactory implements AbstractFactory {    @Override    public Cpu createCpu() {        // TODO Auto-generated method stub        return new IntelCpu(938);    }    @Override    public Mainboard createMainboard() {        // TODO Auto-generated method stub        return new IntelMainboard(938);    }} 装机工程师类跟前面的实现相比，主要的变化是：从客户端不再传入选择CPU和主板的参数，而是直接传入客户已经选择好的产品对象。这样就避免了单独去选择CPU和主板所带来的兼容性问题，客户要选就是一套，就是一个系列。 public class ComputerEngineer {    /**     * 定义组装机需要的CPU     */    private Cpu cpu = null;    /**     * 定义组装机需要的主板     */    private Mainboard mainboard = null;    public void makeComputer(AbstractFactory af){        /**         * 组装机器的基本步骤         */        //1:首先准备好装机所需要的配件        prepareHardwares(af);        //2:组装机器        //3:测试机器        //4：交付客户    }    private void prepareHardwares(AbstractFactory af){        //这里要去准备CPU和主板的具体实现，为了示例简单，这里只准备这两个        //可是，装机工程师并不知道如何去创建，怎么办呢？                //直接找相应的工厂获取        this.cpu = af.createCpu();        this.mainboard = af.createMainboard();                //测试配件是否好用        this.cpu.calculate();        this.mainboard.installCPU();    }} 客户端代码： public class Client {    public static void main(String[]args){        //创建装机工程师对象        ComputerEngineer cf = new ComputerEngineer();        //客户选择并创建需要使用的产品对象        AbstractFactory af = new IntelFactory();        //告诉装机工程师自己选择的产品，让装机工程师组装电脑        cf.makeComputer(af);    }} 抽象工厂的功能是为一系列相关对象或相互依赖的对象创建一个接口。一定要注意，这个接口内的方法不是任意堆砌的，而是一系列相关或相互依赖的方法。比如上面例子中的主板和CPU，都是为了组装一台电脑的相关对象。不同的装机方案，代表一种具体的电脑系列。 由于抽象工厂定义的一系列对象通常是相关或相互依赖的，这些产品对象就构成了一个产品族，也就是抽象工厂定义了一个产品族。 　　这就带来非常大的灵活性，切换产品族的时候，只要提供不同的抽象工厂实现就可以了，也就是说现在是以一个产品族作为一个整体被切换。 在什么情况下应当使用抽象工厂模式 　　1.一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的。 　　2.这个系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。 　　3.同属于同一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来。（比如：Intel主板必须使用Intel CPU、Intel芯片组） 　　4.系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。 抽象工厂模式的起源 　　抽象工厂模式的起源或者最早的应用，是用于创建分属于不同操作系统的视窗构建。比如：命令按键（Button）与文字框（Text)都是视窗构建，在UNIX操作系统的视窗环境和Windows操作系统的视窗环境中，这两个构建有不同的本地实现，它们的细节有所不同。 　　在每一个操作系统中，都有一个视窗构建组成的构建家族。在这里就是Button和Text组成的产品族。而每一个视窗构件都构成自己的等级结构，由一个抽象角色给出抽象的功能描述，而由具体子类给出不同操作系统下的具体实现。 可以发现在上面的产品类图中，有两个产品的等级结构，分别是Button等级结构和Text等级结构。同时有两个产品族，也就是UNIX产品族和Windows产品族。UNIX产品族由UNIX Button和UNIX Text产品构成；而Windows产品族由Windows Button和Windows Text产品构成。 系统对产品对象的创建需求由一个工程的等级结构满足，其中有两个具体工程角色，即UnixFactory和WindowsFactory。UnixFactory对象负责创建Unix产品族中的产品，而WindowsFactory对象负责创建Windows产品族中的产品。这就是抽象工厂模式的应用，抽象工厂模式的解决方案如下图 显然，一个系统只能够在某一个操作系统的视窗环境下运行，而不能同时在不同的操作系统上运行。所以，系统实际上只能消费属于同一个产品族的产品。 　　在现代的应用中，抽象工厂模式的使用范围已经大大扩大了，不再要求系统只能消费某一个产品族了。因此，可以不必理会前面所提到的原始用意。 抽象工厂模式的优点 分离接口和实现 　　客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体的实现是谁，客户端只是面向产品的接口编程而已。也就是说，客户端从具体的产品实现中解耦。 使切换产品族变得容易 　　因为一个具体的工厂实现代表的是一个产品族，比如上面例子的从Intel系列到AMD系列只需要切换一下具体工厂。 抽象工厂模式的缺点 不太容易扩展新的产品 　　如果需要给整个产品族添加一个新的产品，那么就需要修改抽象工厂，这样就会导致修改所有的工厂实现类。 转载自： http://www.cnblogs.com/java-my-life/archive/2012/03/28/2418836.html","title":"设计模式(23) ------------抽象工厂模式"},{"content":"在阎宏博士的《JAVA与模式》一书中开头是这样描述单例模式的： 　　作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类。 单例模式的结构 　　单例模式的特点： 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 　　饿汉式单例类 public class EagerSingleton {    private static EagerSingleton instance = new EagerSingleton();    /**     * 私有默认构造子     */    private EagerSingleton(){}    /**     * 静态工厂方法     */    public static EagerSingleton getInstance(){        return instance;    }} 上面的例子中，在这个类被加载时，静态变量instance会被初始化，此时类的私有构造子会被调用。这时候，单例类的唯一实例就被创建出来了。 　　饿汉式其实是一种比较形象的称谓。既然饿，那么在创建对象实例的时候就比较着急，饿了嘛，于是在装载类的时候就创建对象实例。 private static EagerSingleton instance = new EagerSingleton(); 饿汉式是典型的空间换时间，当类装载的时候就会创建类的实例，不管你用不用，先创建出来，然后每次调用的时候，就不需要再判断，节省了运行时间。   　　懒汉式单例类 public class LazySingleton {    private static LazySingleton instance = null;    /**     * 私有默认构造子     */    private LazySingleton(){}    /**     * 静态工厂方法     */    public static synchronized LazySingleton getInstance(){        if(instance == null){            instance = new LazySingleton();        }        return instance;    }} 上面的懒汉式单例类实现里对静态工厂方法使用了同步化，以处理多线程环境。 　　懒汉式其实是一种比较形象的称谓。既然懒，那么在创建对象实例的时候就不着急。会一直等到马上要使用对象实例的时候才会创建，懒人嘛，总是推脱不开的时候才会真正去执行工作，因此在装载对象的时候不创建对象实例。 private static LazySingleton instance = null; 懒汉式是典型的时间换空间,就是每次获取实例都会进行判断，看是否需要创建实例，浪费判断的时间。当然，如果一直没有人使用的话，那就不会创建实例，则节约内存空间 　　由于懒汉式的实现是线程安全的，这样会降低整个访问的速度，而且每次都要判断。那么有没有更好的方式实现呢？   　　双重检查加锁 　　可以使用“双重检查加锁”的方式来实现，就可以既实现线程安全，又能够使性能不受很大的影响。那么什么是“双重检查加锁”机制呢？ 　　所谓“双重检查加锁”机制，指的是：并不是每次进入getInstance方法都需要同步，而是先不同步，进入方法后，先检查实例是否存在，如果不存在才进行下面的同步块，这是第一重检查，进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来，就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间。 　　“双重检查加锁”机制的实现会使用关键字volatile，它的意思是：被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。 　　注意：在java1.4及以前版本中，很多JVM对于volatile关键字的实现的问题，会导致“双重检查加锁”的失败，因此“双重检查加锁”机制只只能用在java5及以上的版本。 public class Singleton {    private volatile static Singleton instance = null;    private Singleton(){}    public static Singleton getInstance(){        //先检查实例是否存在，如果不存在才进入下面的同步块        if(instance == null){            //同步块，线程安全的创建实例            synchronized (Singleton.class) {                //再次检查实例是否存在，如果不存在才真正的创建实例                if(instance == null){                    instance = new Singleton();                }            }        }        return instance;    }} 这种实现方式既可以实现线程安全地创建实例，而又不会对性能造成太大的影响。它只是第一次创建实例的时候同步，以后就不需要同步了，从而加快了运行速度。 　　提示：由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高。因此一般建议，没有特别的需要，不要使用。也就是说，虽然可以使用“双重检查加锁”机制来实现线程安全的单例，但并不建议大量采用，可以根据情况来选用。 　　根据上面的分析，常见的两种单例实现方式都存在小小的缺陷，那么有没有一种方案，既能实现延迟加载，又能实现线程安全呢？ 　　 　　Lazy initialization holder class模式 　　这个模式综合使用了Java的类级内部类和多线程缺省同步锁的知识，很巧妙地同时实现了延迟加载和线程安全。 　　1.相应的基础知识 　什么是类级内部类？ 　　简单点说，类级内部类指的是，有static修饰的成员式内部类。如果没有static修饰的成员式内部类被称为对象级内部类。 　　类级内部类相当于其外部类的static成分，它的对象与外部类对象间不存在依赖关系，因此可直接创建。而对象级内部类的实例，是绑定在外部对象实例中的。 　　类级内部类中，可以定义静态的方法。在静态方法中只能够引用外部类中的静态成员方法或者成员变量。 　　类级内部类相当于其外部类的成员，只有在第一次被使用的时候才被会装载。 　多线程缺省同步锁的知识 　　大家都知道，在多线程开发中，为了解决并发问题，主要是通过使用synchronized来加互斥锁进行同步控制。但是在某些情况中，JVM已经隐含地为您执行了同步，这些情况下就不用自己再来进行同步控制了。这些情况包括： 　　1.由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时 　　2.访问final字段时 　　3.在创建线程之前创建对象时 　　4.线程可以看见它将要处理的对象时 　　2.解决方案的思路 　　要想很简单地实现线程安全，可以采用静态初始化器的方式，它可以由JVM来保证线程的安全性。比如前面的饿汉式实现方式。但是这样一来，不是会浪费一定的空间吗？因为这种实现方式，会在类装载的时候就初始化对象，不管你需不需要。 　　如果现在有一种方法能够让类装载的时候不去初始化对象，那不就解决问题了？一种可行的方式就是采用类级内部类，在这个类级内部类里面去创建对象实例。这样一来，只要不使用到这个类级内部类，那就不会创建对象实例，从而同时实现延迟加载和线程安全。 　　示例代码如下： public class Singleton {        private Singleton(){}    /**     *    类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例     *    没有绑定关系，而且只有被调用到时才会装载，从而实现了延迟加载。     */    private static class SingletonHolder{        /**         * 静态初始化器，由JVM来保证线程安全         */        private static Singleton instance = new Singleton();    }        public static Singleton getInstance(){        return SingletonHolder.instance;    }} 　当getInstance方法第一次被调用的时候，它第一次读取SingletonHolder.instance，导致SingletonHolder类得到初始化；而这个类在装载并被初始化的时候，会初始化它的静态域，从而创建Singleton的实例，由于是静态的域，因此只会在虚拟机装载类的时候初始化一次，并由虚拟机来保证它的线程安全性。 　　这个模式的优势在于，getInstance方法并没有被同步，并且只是执行一个域的访问，因此延迟初始化并没有增加任何访问成本。 　　 　　单例和枚举 　　按照《高效Java 第二版》中的说法：单元素的枚举类型已经成为实现Singleton的最佳方法。用枚举来实现单例非常简单，只需要编写一个包含单个元素的枚举类型即可。 public enum Singleton {    /**     * 定义一个枚举的元素，它就代表了Singleton的一个实例。     */        uniqueInstance;        /**     * 单例可以有自己的操作     */    public void singletonOperation(){        //功能处理    }} 使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。 转载自：http://www.cnblogs.com/java-my-life/archive/2012/03/31/2425631.html","title":"设计模式(24) ------------单例模式"},{"content":"在阎宏博士的《JAVA与模式》一书中开头是这样描述简单工厂模式的：简单工厂模式是类的创建模式，又叫做静态工厂方法（Static Factory Method）模式。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。 那么简单工厂模式是在什么场景下使用呢，下面就以本人的理解举例说明: 　　就拿登录功能来说，假如应用系统需要支持多种登录方式如：口令认证、域认证（口令认证通常是去数据库中验证用户，而域认证则是需要到微软的域中验证用户）。那么自然的做法就是建立一个各种登录方式都适用的接口，如下图所示： public interface Login {    //登录验证    public boolean verify(String name , String password);} public class DomainLogin implements Login {    @Override    public boolean verify(String name, String password) {        // TODO Auto-generated method stub        /**         * 业务逻辑         */        return true;    }} public class PasswordLogin implements Login {    @Override    public boolean verify(String name, String password) {        // TODO Auto-generated method stub        /**         * 业务逻辑         */        return true;    }} 我们还需要一个工厂类LoginManager，根据调用者不同的要求，创建出不同的登录对象并返回。而如果碰到不合法的要求，会返回一个Runtime异常。 public class LoginManager {    public static Login factory(String type){        if(type.equals(\"password\")){                        return new PasswordLogin();                    }else if(type.equals(\"passcode\")){                        return new DomainLogin();                    }else{            /**             * 这里抛出一个自定义异常会更恰当             */            throw new RuntimeException(\"没有找到登录类型\");        }    }} 测试类： public class Test {    public static void main(String[] args) {        // TODO Auto-generated method stub        String loginType = \"password\";        String name = \"name\";        String password = \"password\";        Login login = LoginManager.factory(loginType);        boolean bool = login.verify(name, password);        if (bool) {            /**             * 业务逻辑             */        } else {            /**             * 业务逻辑             */        }    }} 简单工厂模式的结构如下图： 我们可以设想一下真实的场景，如果把上面的Test当做一个servlet的话，当客户端发起登录请求——>请求交给服务端的Servlet——>Servlet根据客户端传递的loginType调用工厂类LoginManager的factory()方法——>factory()方法根据参数loginType创建相应的登录验证类(DomainLogin或PasswordLogin)并返回——>登录验证类调用方法verify()验证用户名密码是否正确 假如不使用简单工厂模式则验证登录Servlet代码如下（假设Test为一个Servlet，变量loginType、name、password表示从客户端传递过来的参数）： public class Test {    public static void main(String[] args) {        // TODO Auto-generated method stub                String loginType = \"password\";        String name = \"name\";        String password = \"password\";        //处理口令认证        if(loginType.equals(\"password\")){            PasswordLogin passwordLogin = new PasswordLogin();            boolean bool = passwordLogin.verify(name, password);            if (bool) {                /**                 * 业务逻辑                 */            } else {                /**                 * 业务逻辑                 */            }        }        //处理域认证        else if(loginType.equals(\"passcode\")){            DomainLogin domainLogin = new DomainLogin();            boolean bool = domainLogin.verify(name, password);            if (bool) {                /**                 * 业务逻辑                 */            } else {                /**                 * 业务逻辑                 */            }            }else{            /**             * 业务逻辑             */        }    }} 上面的代码会不会很蛋疼啊。。。呵呵 《JAVA与模式》一书中使用java.text.DataFormat类作为简单工厂模式的典型例子叙述。 简单工厂模式的优点 　　模式的核心是工厂类。这个类含有必要的逻辑判断，可以决定在什么时候创建哪一个登录验证类的实例，而调用者则可以免除直接创建对象的责任。简单工厂模式通过这种做法实现了对责任的分割，当系统引入新的登录方式的时候无需修改调用者。 简单工厂模式的缺点 　　这个工厂类集中了所以的创建逻辑，当有复杂的多层次等级结构时，所有的业务逻辑都在这个工厂类中实现。什么时候它不能工作了，整个系统都会受到影响。 转载自：http://www.cnblogs.com/java-my-life/archive/2012/03/22/2412308.html","title":"设计模式(21) ------------简单工厂模式"},{"content":"在阎宏博士的《JAVA与模式》一书中开头是这样描述工厂方法模式的： 　　工厂方法模式是类的创建模式，又叫做虚拟构造子(Virtual Constructor)模式或者多态性工厂（Polymorphic Factory）模式。 　　工厂方法模式的用意是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。 那么工厂方法模式是在什么场景下使用呢，下面就以本人的理解举例说明: 　　相信很多人都做过导入导出功能，就拿导出功能来说。有这么一个需求：XX系统需要支持对数据库中的员工薪资进行导出，并且支持多种格式如：HTML、CSV、PDF等，每种格式导出的结构有所不同，比如：财务跟其他人对导出薪资的HTML格式要求可能会不一样，因为财务可能需要特定的格式方便核算或其他用途。 　　如果使用简单工厂模式，则工厂类必定过于臃肿。因为简单工厂模式只有一个工厂类，它需要处理所有的创建的逻辑。假如以上需求暂时只支持3种导出的格式以及2种导出的结构，那工厂类则需要6个if else来创建6种不同的类型。如果日后需求不断增加，则后果不堪设想。 　　这时候就需要工厂方法模式来处理以上需求。在工厂方法模式中，核心的工厂类不再负责所有的对象的创建，而是将具体创建的工作交给子类去做。这个核心类则摇身一变，成为了一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个类应当被实例化这种细节。 　　这种进一步抽象化的结果，使这种工厂方法模式可以用来允许系统在不修改具体工厂角色的情况下引进新的产品，这一特点无疑使得工厂方法模式具有超过简单工厂模式的优越性。下面就针对以上需求设计UML图： 从上图可以看出，这个使用的工厂方法模式的系统涉及到以下角色：   　　抽象工厂（ExportFactory）角色：担任这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口。在实际的系统中，这个角色也常常使用抽象类实现。 　　具体工厂（ExportHtmlFactory、ExportPdfFactory）角色：担任这个角色的是实现了抽象工厂接口的具体JAVA类。具体工厂角色含有与业务密切相关的逻辑，并且受到使用者的调用以创建导出类（如：ExportStandardHtmlFile）。 　　抽象导出（ExportFile）角色：工厂方法模式所创建的对象的超类，也就是所有导出类的共同父类或共同拥有的接口。在实际的系统中，这个角色也常常使用抽象类实现。 　　具体导出（ExportStandardHtmlFile等）角色：这个角色实现了抽象导出（ExportFile）角色所声明的接口，工厂方法模式所创建的每一个对象都是某个具体导出角色的实例。 源代码 　　首先是抽象工厂角色源代码。它声明了一个工厂方法，要求所有的具体工厂角色都实现这个工厂方法。参数type表示导出的格式是哪一种结构，如：导出HTML格式有两种结构，一种是标准结构，一种是财务需要的结构。 public interface ExportFactory {    public ExportFile factory(String type);} 具体工厂角色类源代码： public class ExportHtmlFactory implements ExportFactory{    @Override    public ExportFile factory(String type) {        // TODO Auto-generated method stub        if(\"standard\".equals(type)){                        return new ExportStandardHtmlFile();                    }else if(\"financial\".equals(type)){                        return new ExportFinancialHtmlFile();                    }else{            throw new RuntimeException(\"没有找到对象\");        }    }} public class ExportPdfFactory implements ExportFactory {    @Override    public ExportFile factory(String type) {        // TODO Auto-generated method stub        if(\"standard\".equals(type)){                        return new ExportStandardPdfFile();                    }else if(\"financial\".equals(type)){                        return new ExportFinancialPdfFile();                    }else{            throw new RuntimeException(\"没有找到对象\");        }    }} 抽象导出角色类源代码： public interface ExportFile {    public boolean export(String data);} 具体导出角色类源代码，通常情况下这个类会有复杂的业务逻辑。 public class ExportFinancialHtmlFile implements ExportFile{    @Override    public boolean export(String data) {        // TODO Auto-generated method stub        /**         * 业务逻辑         */        System.out.println(\"导出财务版HTML文件\");        return true;    }} public class ExportFinancialPdfFile implements ExportFile{    @Override    public boolean export(String data) {        // TODO Auto-generated method stub        /**         * 业务逻辑         */        System.out.println(\"导出财务版PDF文件\");        return true;    }} public class ExportStandardHtmlFile implements ExportFile{    @Override    public boolean export(String data) {        // TODO Auto-generated method stub        /**         * 业务逻辑         */        System.out.println(\"导出标准HTML文件\");        return true;    }} public class ExportStandardPdfFile implements ExportFile {    @Override    public boolean export(String data) {        // TODO Auto-generated method stub        /**         * 业务逻辑         */        System.out.println(\"导出标准PDF文件\");        return true;    }} 客户端角色类源代码： public class Test {    /**     * @param args     */    public static void main(String[] args) {        // TODO Auto-generated method stub        String data = \"\";        ExportFactory exportFactory = new ExportHtmlFactory();        ExportFile ef = exportFactory.factory(\"financial\");        ef.export(data);    }} 工厂方法模式的活动序列图 客户端创建ExportHtmlFactory对象，这时客户端所持有变量的静态类型为ExportFactory，而实际类型为ExportHtmlFactory。然后客户端调用ExportHtmlFactory对象的工厂方法factory()，接着后者调用ExportFinancialHtmlFile的构造子创建出导出对象。 工厂方法模式和简单工厂模式 　　工厂方法模式和简单工厂模式在结构上的不同很明显。工厂方法模式的核心是一个抽象工厂类，而简单工厂模式把核心放在一个具体类上。 　　工厂方法模式退化后可以变得很像简单工厂模式。设想如果非常确定一个系统只需要一个具体工厂类，那么不妨把抽象工厂类合并到具体工厂类中去。由于只有一个具体工厂类，所以不妨将工厂方法改为静态方法，这时候就得到了简单工厂模式。 　　如果系统需要加入一个新的导出类型，那么所需要的就是向系统中加入一个这个导出类以及所对应的工厂类。没有必要修改客户端，也没有必要修改抽象工厂角色或者其他已有的具体工厂角色。对于增加新的导出类型而言，这个系统完全支持“开-闭原则”。 　　 完结 　　一个应用系统是由多人开发的，导出的功能是你实现的，但是使用者（调用这个方法的人）可能却是其他人。这时候你应该设计的足够灵活并尽可能降低两者之间的耦合度，当你修改或增加一个新的功能时，使用者不需要修改任何地方。假如你的设计不够灵活，那么将无法面对客户多变的需求。可能一个极小的需求变更，都会使你的代码结构发生改变，并导致其他使用你所提供的接口的人都要修改他们的代码。牵一处而动全身，这就使得日后这个系统将难以维护。 转载自：http://www.cnblogs.com/java-my-life/archive/2012/03/25/2416227.html","title":"设计模式(22) ------------工厂方法模式"},{"content":"以下是个人学习的办法。不一定是最好的，也不一定是最适合你的，但或许是一种可以选择的学习方法。废话不多说，进入主题。 1.语言基础 对个人来说这是最困难也是最容易的地方，容易是学的东西都不复杂，困难是接触的是一门新学习的语言，从基础概念到语法都不熟悉。希望大家在这里多花些时间，磨刀不误砍柴工，基础打好才是关键。有很多适合入门的书籍，这里就不重复了。 2.DEMO例子 把这个作为自学的一个步骤，可见其重要性，作为一个程序员，如果你不敲代码，再好的理论基础，也只是理论。好的DEMO例子，可以看官方的API或是找一本语言之父的书籍，里面每个DEMO都深入理解。并且一定要自己独立地敲出来，我想大家都明白独立的意思。 3.设计模式 这里多说一句，只有在1，2都完成的不错，特别是代码有一定量的时候，才可以进行这一步，不然个人觉得设计模式只能是空谈。前面讲的是基础，这里讲的是想法。如果你已经接触到这一步，恭喜你，你离项目的距离很近了。不要问什么是设计模式，上网相信都可以搜到。自学一定要懂得搜索工具的使用，论坛之类的都将是你以后离不开的。 4.项目Product 做了如此多的准备，我们其实最后需要完成的任务，就是项目。做项目是你作为程序员必须经历的一个阶段，我们不应该永远停留在DEMO，如果做好项目，每个人的理解不一样，我这里强调一点，就是先分析需求再设计功能的实现，不要一上来就直接代码编写。当然除非你牛的已经不行了。 5.系统机制了解（可选） 如果你研发的是系统，或是修改的是系统的模块，这一步相信有过开发经历的人都明白，如果你不了解系统实现的机制，你想很好的研发出一个符合系统的模块，可以说是不可能的，这里建议你了解一些系统的基本概念。这块涉及比较复杂，但机制的了解相信是大家研究系统的第一步。 如果你选择了成为一个程序员，请相信没有捷径，有的只是代码。一个好的程序必须具备的条件是坚持和努力！","title":"关于程序员自学的一点心得"},{"content":"学习java快一年了，一开始学习java是为了编写android软件，最近花了一个月做出了个android小软件，开发完了才觉得java学的有点不是很牢固，所以想找几本关于java的书看看。前几天上微薄一个大神介绍了几本java初级的书，其中就这本《Head First设计模式》，于是就打算把这本书好好看看。感觉这本书很适合初学者，而且讲解的挺有趣的，不会让你感到有种压力。以前也学了一点设计模式，但没怎么搞明白，这本书刚看了第一章就感觉收获挺大的，于是就乘热打铁写写笔记来加深记忆。 目前刚看了两章，先来个策略模式（Strage pattern） 书中举得例子是鸭子游戏的实现，为了实现这个鸭子游戏的弹性，引出了三条设计原则： 1.找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。 例子中将鸭子飞行行为和鸣叫行为（各种鸭子的飞行行为和鸣叫行为有所不同）和鸭子的游泳行为分开独立出来。 2.针对接口编程，而不是针对实现编程 鸭子的行为和鸭子种类都是实现了Interface，而不是针对真实的类。 3.多用组合（composition），少用继承 书中提出：有一个比是一个更好，鸭子的行为是一个一个组合而来的，每一个行为都实现一个行为接口，这样更易于对鸭子行为的添加与修改 策略模式（Strage pattern）的正式定义：定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户 下面完成了设计谜题中的习题： //抽象环境角色，Character超类，所有人物角色都继承自该类public abstract class Character{\tWeaponBehavior weapon;\tpublic void fight();\tpublci void setWeapon(WeaponBehavior w){\t\tthis.weapon=w;\t}} //皇后类，具体环境角色，持有一个策略类的引用，最终给客户端调用的，继承自人物类public class Queen extends Character{\tpublic Queen(){\t\tweapon=new KnifeBehavior();//持有匕首\t}\tpublic void fight(){\t\tweapon.useWeapon();\t}} //国王类，具体环境角色，持有一个策略类的引用，最终给客户端调用的，继承自人物类public class King extends Character{\tpublic King(){\t\tweapon=new SwordBehavior();//持有宝剑\t}\tpublic void fight(){\t\tweapon.useWeapon();\t}} //抽象策略角色：策略类，通常由一个接口或者抽象类实现，武器接口public interface WeaponBehavior{\tpublic void useWeapon();} //具体策略角色，包装了相关的算法和行为，匕首武器，实现了武器接口public class SwordBehavior implements WeaponBehavior{\tpublic void useWeapon(){\t\tSystem.out.println(\"I use sword!\");\t}} //具体策略角色，包装了相关的算法和行为，宝剑武器，实现了武器接口public class KnifeBehavior implements WeaponBehavior{\tpublic void useWeapon(){\t\tSystem.out.println(\"I use knife!\");\t}} 为了动态的改变人物的武器行为，我们可以为Character类编写setWeapon(WeaponBehavior weapon)方法，于是当我们要为国王调用匕首武器时，就可以调用此方法！ 其实策略模式也有缺点，比如客户必须要知道所有的策略类，并自行决定使用哪一个策越类，另一个问题是会造成许多的具体的策略类 策略模式介绍到此！","title":"《Head First设计模式》读书笔记之策略模式"},{"content":"　Observer模式定义对象间的一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。JDK里提供的observer设计模式的实现由java.util.Observable类和 java.util.Observer接口组成。从名字上可以清楚的看出两者在Observer 设计模式中分别扮演的角色：Observer是观察者角色，Observable是被观察目标(subject)角色。 编辑本段实例 　　该实例模拟了烧水的过程，涉及三个对象，Heater(热水器),Display（显示器）,Alarm(报警器). 　　模拟过程：为了便于运行，水的初始化温度为90，沸点为95，显示器依据热水器显示温度，显示器显示温度为95时，报警器开始报警。明显可以看出Heater是subject ,Display 是它的 Obsrver，同时Display亦是subject，因为它要被报警器观察，所以Alarm是Display的Observer. 　　实现过程： 　　a.Heater.java 　　Java代码 　　import java.util.Observable; 　　public class Heater extends Observable { 　　private int temperature; 　　public int getTemperature() { 　　return temperature; 　　} 　　public void setTemperature(int temperature) { 　　this.temperature = temperature; 　　} 　　public void boilWater() { 　　for (int i = 90; i < 100; i++) { 　　temperature = i; 　　this.setChanged(); 　　this.notifyObservers(); 　　} 　　} 　　} 　　b.Display.java 　　Java代码 　　 import java.util.Observable; 　　import java.util.Observer; 　　public class Display extends Observable implements Observer { 　　private String status = \"未开\"; 　　public void setStatus(String status) { 　　this.status = status; 　　} 　　public void displayTemputer(int temperature) { 　　if (temperature > 95) { 　　this.setStatus(\"沸腾\"); 　　this.setChanged(); 　　this.notifyObservers(); 　　} 　　System.out.println(\"状态：\" + status + \" 现在温度：\" + temperature + \"\"); 　　} 　　public void update(Observable o, Object arg) { 　　displayTemputer(((Heater) o).getTemperature());//这里不是很好 　　} 　　} 　　c.Alarm.java 　　Java代码 　　 import java.util.Observable; 　　import java.util.Observer; 　　public class Alarm implements Observer { 　　public void makeAlarm() { 　　System.out.println(\"嘀嘀嘀...水已经烧开 \"); 　　} 　　public void update(Observable o, Object arg) { 　　makeAlarm(); 　　} 　　} 　　d.测试类testObserver.java 　　Java代码 　　public class testObserver { 　　public static void main(String[] args) { 　　Heater heater = new Heater(); 　　Display display = new Display(); 　　Alarm alarm = new Alarm(); 　　heater.addObserver(display); 　　display.addObserver(alarm); 　　heater.boilWater(); 　　} 　　} 　　e.运行结果： 　　引用 　　状态：未开 现在温度：90 　　状态：未开 现在温度：91 　　状态：未开 现在温度：92 　　状态：未开 现在温度：93 　　状态：未开 现在温度：94 　　状态：未开 现在温度：95 　　嘀嘀嘀...水已经烧开 　　状态：沸腾 现在温度：96 　　嘀嘀嘀...水已经烧开 　　状态：沸腾 现在温度：97 　　嘀嘀嘀...水已经烧开 　　状态：沸腾 现在温度：98 　　嘀嘀嘀...水已经烧开 　　状态：沸腾 现在温度：99 编辑本段应用 　　1、 对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变。 　　2、 对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。 编辑本段优缺点 　　观察者模式的优点： 　　1、 Subject和Observer之间是松偶合的，分别可以各自独立改变。 　　2、 Subject在发送广播通知的时候，无须指定具体的Observer，Observer可以自己决定是否要订阅Subject的通知。 　　3、 遵守大部分GRASP原则和常用设计原则，高内聚、低偶合。 　　观察者模式的缺陷： 　　1、 松偶合导致代码关系不明显，有时可能难以理解。(废话) 　　2、 如果一个Subject被大量Observer订阅的话，在广播通知的时候可能会有效率问题。（毕竟只是简单的遍历）","title":"Observer模式"},{"content":"摘要：Java编程最基本的原则就是要追求高内聚和低耦合的解决方案和代码模块设计。查看Apache和Sun的开放源代码能帮助你发现其他Java设计原则在这些代码中的实际运用。 面向对象设计原则是OOPS（Object-Oriented Programming System，面向对象的程序设计系统）编程的核心，但大多数Java程序员追逐像Singleton、Decorator、Observer这样的设计模式，而不重视面向对象的分析和设计。甚至还有经验丰富的Java程序员没有听说过OOPS和SOLID设计原则，他们根本不知道设计原则的好处，也不知道如何依照这些原则来进行编程。 众所周知，Java编程最基本的原则就是要追求高内聚和低耦合的解决方案和代码模块设计。查看Apache和Sun的开放源代码能帮助你发现其他Java设计原则在这些代码中的实际运用。Java Development Kit则遵循以下模式：BorderFactory类中的工厂模式、Runtime类中的单件模式。你可以通过Joshua Bloch的《Effective Java》一书来了解更多信息。我个人偏向的另一种面向对象的设计模式是Kathy Sierra的Head First Design Pattern以及Head First Object Oriented Analysis and Design。 虽然实际案例是学习设计原则或模式的最佳途径，但通过本文的介绍，没有接触过这些原则或还在学习阶段的Java程序员也能够了解这10个面向对象的设计原则。其实每条原则都需要大量的篇幅才能讲清楚，但我会尽力做到言简意赅。 原则1：DRY（Don't repeat yourself） 即不要写重复的代码，而是用“abstraction”类来抽象公有的东西。如果你需要多次用到一个硬编码值，那么可以设为公共常量；如果你要在两个以上的地方使用一个代码块，那么可以将它设为一个独立的方法。SOLID设计原则的优点是易于维护，但要注意，不要滥用，duplicate 不是针对代码，而是针对功能。这意味着，即使用公共代码来验证OrderID和SSN，二者也不会是相同的。使用公共代码来实现两个不同的功能，其实就是近似地把这两个功能永远捆绑到了一起，如果OrderID改变了其格式，SSN验证代码也会中断。因此要慎用这种组合，不要随意捆绑类似但不相关的功能。 原则2：封装变化 在软件领域中唯一不变的就是“Change”，因此封装你认为或猜测未来将发生变化的代码。OOPS设计模式的优点在于易于测试和维护封装的代码。如果你使用Java编码，可以默认私有化变量和方法，并逐步增加访问权限，比如从private到protected和not public。有几种Java设计模式也使用封装，比如Factory设计模式是封装“对象创建”，其灵活性使得之后引进新代码不会对现有的代码造成影响。 原则3：开闭原则 即对扩展开放，对修改关闭。这是另一种非常棒的设计原则，可以防止其他人更改已经测试好的代码。理论上，可以在不修改原有的模块的基础上，扩展功能。这也是开闭原则的宗旨。 原则4：单一职责原则 类被修改的几率很大，因此应该专注于单一的功能。如果你把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，有可能中止另一个功能，这时就需要新一轮的测试来避免可能出现的问题。 原则5：依赖注入或倒置原则 这个设计原则的亮点在于任何被DI框架注入的类很容易用mock对象进行测试和维护，因为对象创建代码集中在框架中，客户端代码也不混乱。有很多方式可以实现依赖倒置，比如像AspectJ等的AOP（Aspect Oriented programming）框架使用的字节码技术，或Spring框架使用的代理等。 原则6：优先利用组合而非继承 如果可能的话，优先利用组合而不是继承。一些人可能会质疑，但我发现，组合比继承灵活得多。组合允许在运行期间通过设置类的属性来改变类的行为，也可以通过使用接口来组合一个类，它提供了更高的灵活性，并可以随时实现。《Effective Java》也推荐此原则。 原则7：里氏代换原则（LSP） 根据该原则，子类必须能够替换掉它们的基类，也就是说使用基类的方法或函数能够顺利地引用子类对象。LSP原则与单一职责原则和接口分离原则密切相关，如果一个类比子类具备更多功能，很有可能某些功能会失效，这就违反了LSP原则。为了遵循该设计原则，派生类或子类必须增强功能。 原则8：接口分离原则 采用多个与特定客户类有关的接口比采用一个通用的涵盖多个业务方法的接口要好。设计接口很棘手，因为一旦释放接口，你就无法在不中断执行的情况下改变它。在Java中，该原则的另一个优势在于，在任何类使用接口之前，接口不利于实现所有的方法，所以单一的功能意味着更少的实现方法。 原则9：针对接口编程，而不是针对实现编程 该原则可以使代码更加灵活，以便可以在任何接口实现中使用。因此，在Java中最好使用变量接口类型、方法返回类型、方法参数类型等。《Effective Java》 和《head first design pattern》书中也有提到。 原则10：委托原则 该原则最典型的例子是Java中的equals() 和 hashCode() 方法。为了平等地比较两个对象，我们用类本身而不是客户端类来做比较。这个设计原则的好处是没有重复的代码，而且很容易对其进行修改。 总之，希望这些面向对象的设计原则能帮助你写出更灵活更好的代码。理论是第一步，更重要的是需要开发者在实践中去运用和体会。 译文出自：ITeye","title":"Java程序员应该了解的10个面向对象设计原则"},{"content":"1 什么是开闭原则         开-闭原则（Open_Closed Principle）:一个软件实体应当对扩展开放，对修改关闭。（SoftWare entities should be open for extension,but closed formodification）   也就是说设计一个模块的时候，应当使这个模块可以被不修改的前提下被扩展。 2 如何实现开闭原则（对扩展开放，对修改关闭）       实现开闭原则可以从抽象化和对可变性封装两个方面考虑。     一、一种可变性不应当散落在代码的很多角落里，而应当被封装在一个对象里面。对这众多的同一层次上的可变性进行抽象得到它们的抽象类，使这些同一层次上的可变性是 这个抽象类的具体子类。这个抽象类不可更改。      二、当系统需要增加一个可变性的时候，只需继承实现该抽象类即可达到这些不同可变性之间能够相互替换。 从以上两点我们可以看出第一点满足了开闭原则的对修改关闭，第二点满足了对扩展开放。      等看到设计模式中的策略模式时就刻意很容易理解，策略模式讲的就是有一组算法，将每一个算法封装起来，使得它们之间刻意相互替换，策略模式就是开闭原则的一个范例。 3 开闭原则与其他几大原则的关系     开闭原则是面向对象复用的基石，我们设计系统要达到到的目标就是对修改关闭对扩展开放。     里氏代换原则:里氏代换原则是对开闭原则的补充，开闭原则告诉我们任何基类出现的地方子类一定可以出现，开闭原则就是将关键步骤就是抽象化，在子类中实现扩展。     依赖倒转：讲的是要依赖于抽象而不要依赖于实现，它是实现开闭原则的手段，违反依赖倒转的原则就不可能达到开闭原则的要求     单一职责原则：类中的职责要单一，不能将不同的可变性封装在一个子类当中。     接口隔离原则：它讲的是应当为客户端提供尽可能小的单独接口，而不要提供打的接口，它使软件系统在功能扩展的过程中不会将修改的压力扩展到其他对象中。     迪米特法则：它将的是一个软件实体应当尽可能少的与其他实体发生作用。遵守迪米特法则会相对容易地做到对修改关闭。     合成/聚合复用原则：它讲的是优先使用组合而非继承。它是与里氏代换原则相辅相成的 4    开闭原则的优越性     一、提供扩展新的行为，满足对软件新的需求，使软件系统具有一定的适应性和灵活性。      二、对抽象层不能修改，保证了系统的稳定性和延续性。","title":"[置顶] 面向对象设计原则之开闭原则（OCP）"},{"content":"小弟是大三本科生，个人偏向于网络游戏开发，曾经也为此自学了OPENGL，也在北京一个游戏公司呆过一个月时间，个人感觉进步不大，主要原因也分析了一下，是因为以前没有学过关于windows SDK相关的知识，为此，今年暑假，我去了北京一家软件公司参加了实习，了解了一些windows开发方面的知识，主要是了解了软件开发的主要流程，个人感觉收益颇多，前面我自己贴了一些小代码，如果对大家有所帮助，小弟不胜荣幸，所有代码您都可以放心使用，不存在任何版权问题,不过有些代码可能存在一些小BUG，如果调试不了，可以与小弟联系（QQ:2538698032,你也可以留言），小弟曾经也自学了设计模式和mysql,后面会陆续贴上自己的一些学习心得，如果对于小弟贴上的一些稿子有什么问题，还是希望您能留言批评指正，小弟将不胜感激!!!!!!!!!!!!!!","title":"我的小窝"},{"content":"Android系统：2.3.1 IPCamera：F系列 开发板:A8-Tiny210   这几天一直在研究Android上的IPCamera实时监控功能。业务流程是这样的： 用户申请监控后，Android端打开一个线程每隔200ms向服务器发送HTTP请求（请求获取当前的摄像头图片，是的，我也是用了刷图片的效果）。 服务器端向IPCamera发送一段带有cgi参数的http请求到IPCamera，获取到图片流信息，然后封装成字符串（byteàString），发送到客户端，经过解析（byteàbitmap）,然后经过宽和高的设置，刷到ImageView上。 首先，Android端开启了一个线程，当用户按下ImageView时启动，实现代码如下： private Runnable refreshCameraRunnable = new Runnable() {          @Override        publicvoid run() {              while (cameraFlag) {                 try {                      //这是一个ThreadHandler,且看下面介绍.                   cameraHanler.sendEmptyMessage(0);                   Thread.sleep(150);               } catch (InterruptedException e) {                     e.printStackTrace();               }            }             //向用户线程发送消息，刷新一下ImageView。            Message msg = new Message();            recoverHandler.sendMessage(msg);        }          private Handler recoverHandler = new Handler() {              @Override            publicvoid handleMessage(Message msg) {               // TODO Auto-generated method stub               super.handleMessage(msg);                    //这是最开始ImageView的默认图片，在用户申请关闭监控后，恢复之               ivCamera.setImageResource(R.drawable.esto_main_new_2);            }          };     }; 我重新定义了一个MyThreadHandler，继承自ThreadHanler,在这里面做ImageView刷新图片的功能（所以，在构造的时候要把ImageView传递过去了！）在handleMessage中，发送HTTP请求，获取InputStream，解析成Bitmap，在用户线程上重新set一下Image，这样客户端就好了。代码如下： @Override publicboolean handleMessage(Message arg0) {          Message msg = new Message();        refreshImg.sendMessage(msg);        returntrue;     } //我说明一下，Android的消息机制恐怕我学习的还是太浅了，这样AàB,B再给A发消息这//样的操作感觉非常冗余。 private Handler refreshImg = new Handler() {          @Override        publicvoid handleMessage(Message msg) {            super.handleMessage(msg);            refreshImg();        }   };   privatestaticvoid refreshImg() {        try {              URL url = new URL(strURL);            HttpURLConnection con = (HttpURLConnection) url.openConnection();            con.setReadTimeout(5 * 1000);            con.setRequestMethod(\"POST\");            con.setRequestProperty(\"Charset\", \"UTF-8\");         con.setRequestProperty(\"Content-Type\",\"multipart/form-data\");            con.setChunkedStreamingMode(1024 * 100);            con.setDoOutput(true);            OutputStream out = con.getOutputStream();            out.flush();            out.close();            if (con.getResponseCode() == HttpURLConnection.HTTP_OK) {                 InputStream inputStream = con.getInputStream();               String strCamera = \"\";               byte[] membytes = newbyte[1024];               int bLength = 0;               while ((bLength = inputStream.read(membytes)) != -1) {                   strCamera += new String(membytes, 0, bLength);               }               Bitmap bitmap = null;                 try {                     byte[] bitmapArray;                   bitmapArray = Base64.decode(strCamera, Base64.DEFAULT);                   bitmap = BitmapFactory.decodeByteArray(bitmapArray, 0,bitmapArray.length);                 } catch (Exception e) {                   e.printStackTrace();               }                          int width = ivPlayVedio.getWidth();               int height = ivPlayVedio.getHeight();                  //这里，限制Bitmap的长度和宽度与ImageView的w、h相同。               ivPlayVedio.setImageBitmap(BitMapUtils.scaleImg(bitmap, width,height));               inputStream.close();              }        } catch (Exception e) {            e.printStackTrace();        }     } 客户端完毕. 服务器端，拦截到android的http请求后，执行响应的post方法，我的IPCamera的IP是XXX,端口是81,所以URL就是http://XXX:81/, IPCamera是以CGI的格式获取用户名、密码等信息的，所以这块要好好的研究一下ＡＰＩ了，我这边是F系列的，查看了文档之后，完成的URL如下：          http://XXX:81/snapshot.cgi?user=admin&pwd=&next_url=0 CGI的参数不同的型号可能不一样，详细的自己去看相关API吧！ 同样是发送HTTP请求，这边的数据流是这样处理的： InputStream inputStream = con.getInputStream();              int len = 0;              byte[] img = newbyte[1024];              ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();             while ((len = inputStream.read(img)) != -1) {                     byteArrayOutputStream.write(img, 0, len);            }               byte byteImg[] = byteArrayOutputStream.toByteArray();            byteArrayOutputStream.close();            inputStream.close();            result += (new BASE64Encoder().encode(byteImg)); 把result发送给客户端，这样一个完整的   客户端ß-à服务器ß-àIPCamera的请求与处理就完成了。呵呵，java的InputStream和outputStream给我们节省了很多复杂的事情。三天的时间，从对IPCamera一无所知到将摄像头功能加入到项目中，真的很高兴啊！   我的xt210手机的300W像素一般啊，不过我的板子2G的内存，实现这个实时监控的功能，效果非常非常好呢！ 呵呵","title":"JOIM：Android通过IPCamera通过互联网实时监控功能的实现"},{"content":"观察者模式，是一种非常常见的设计模式，在很多系统中随处可见，尤其是涉及到数据状态发生变化需要通知的情况下。 本文以AbstractCursor为例子，展开分析。 观察者模式，Observer Pattern,是一个很实用的模式，本人曾经接触到的各种平台以及曾经参与项目中打印模板解释器中都用到了此模式。 1.意图 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 热门词汇：依赖 发布-订阅 事件 通知 更新 监听  2.结构 这是一个最简单的观察者模式，目标对象能够添加和删除观察者，当自己某种状态或者行为发生改变时，可通过notify通知注册的观察者进行更新操作。 分析AbstractCursor的具体情况，我们发现实际工作有时需要对观察者进行统一管理，甚至观察者类型有很多种而又可以分成几个系列，这个时候是要复杂的多，通过合理的分层这个问题很好解决。下面根据具体情况，我们画出android中abstractCurosr中用到的观察者模式结构图： 观察者分成了两个系列。 3.代码 列举其中相关核心代码如下： public abstract class AbstractCursor {    //定义管理器    DataSetObservable mDataSetObservable = new DataSetObservable();    ContentObservable mContentObservable = new ContentObservable();         //注册和卸载两类观察者    public void registerContentObserver(ContentObserver observer) {        mContentObservable.registerObserver(observer);    }     public void unregisterContentObserver(ContentObserver observer) {        // cursor will unregister all observers when it close        if (!mClosed) {            mContentObservable.unregisterObserver(observer);        }    }     public void registerDataSetObserver(DataSetObserver observer) {        mDataSetObservable.registerObserver(observer);             }     public void unregisterDataSetObserver(DataSetObserver observer) {        mDataSetObservable.unregisterObserver(observer);    }     //2类通知方法    protected void onChange(boolean selfChange) {        synchronized (mSelfObserverLock) {            mContentObservable.dispatchChange(selfChange);            if (mNotifyUri != null && selfChange) {                mContentResolver.notifyChange(mNotifyUri, mSelfObserver);            }        }    }     protected void notifyDataSetChange() {        mDataSetObservable.notifyChanged();    }} 再看看Observable<T>类和DataSetObservable类: public abstract class Observable<T> {    /**     * 观察者列表     */    protected final ArrayList<T> mObservers = new ArrayList<T>();     public void registerObserver(T observer) {        if (observer == null) {            throw new IllegalArgumentException(\"The observer is null.\");        }        synchronized(mObservers) {            if (mObservers.contains(observer)) {                throw new IllegalStateException(\"Observer \" + observer + \" is already registered.\");            }            mObservers.add(observer);        }    }      public void unregisterObserver(T observer) {        if (observer == null) {            throw new IllegalArgumentException(\"The observer is null.\");        }        synchronized(mObservers) {            int index = mObservers.indexOf(observer);            if (index == -1) {                throw new IllegalStateException(\"Observer \" + observer + \" was not registered.\");            }            mObservers.remove(index);        }    }         public void unregisterAll() {        synchronized(mObservers) {            mObservers.clear();        }            }} 和 public class DataSetObservable extends Observable<DataSetObserver> {    /**     * 数据发生变化时，通知所有的观察者     */    public void notifyChanged() {        synchronized(mObservers) {            for (DataSetObserver observer : mObservers) {                observer.onChanged();            }        }    }    //... ... (其他方法)} 观察者DataSetObserver类是一个抽象类： public abstract class DataSetObserver {    public void onChanged() {        // Do nothing    }} 所以我们具体看它的子类： public class AlphabetIndexer extends DataSetObserver{    /*     * @hide 被android系统隐藏起来了     */    @Override    public void onChanged() {        //观察到数据变化，观察者做自己该做的事情        super.onChanged();        mAlphaMap.clear();    }} ContentObserver也是类似。 4.效果 (1).行为型模式 (2).目标和观察者间的抽象耦合(经典实现)。 (3).支持广播通信(相信这点android开发者看到后应该有启发吧)。 (4).注意意外的更新，这也是观察者更新进行管理的原因之一。 --------------------------------- 转自：http://www.cnblogs.com/qianxudetianxia/archive/2011/08/07/2129731.html","title":"Android设计模式系列--SDK源码之观察者模式"},{"content":"          设计模式（Design Patterns）                                   ——可复用面向对象软件的基础 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。本章系Java之美[从菜鸟到高手演变]系列之设计模式，我们会以理论与实践相结合的方式来进行本章的学习，希望广大程序爱好者，学好设计模式，做一个优秀的软件工程师！ 在阅读过程中有任何问题，请及时联系：egg。 邮箱：xtfggef@gmail.com 微博：http://weibo.com/xtfggef 如有转载，请说明出处：http://blog.csdn.net/zhangerqing 一、设计模式的分类 总体来说设计模式分为三大类： 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 其实还有两类：并发型模式和线程池模式。用一个图片来整体描述一下： 二、设计模式的六大原则 1、开闭原则（Open Close Principle） 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle） 里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 3、依赖倒转原则（Dependence Inversion Principle） 这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 5、迪米特法则（最少知道原则）（Demeter Principle） 为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle） 原则是尽量使用合成/聚合的方式，而不是使用继承。 三、Java的23中设计模式 从这一块开始，我们详细介绍Java中23种设计模式的概念，应用场景等情况，并结合他们的特点及设计模式的原则进行分析。 1、工厂方法模式（Factory Method） 工厂方法模式分为三种： 11、普通工厂模式，就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。首先看下关系图： 举例如下：（我们举一个发送邮件和短信的例子） 首先，创建二者的共同接口： public interface Sender {\tpublic void Send();} 其次，创建实现类： public class MailSender implements Sender {\t@Override\tpublic void Send() {\t\tSystem.out.println(\"this is mailsender!\");\t}} public class SmsSender implements Sender {\t@Override\tpublic void Send() {\t\tSystem.out.println(\"this is sms sender!\");\t}} 最后，建工厂类： public class SendFactory {\tpublic Sender produce(String type) {\t\tif (\"mail\".equals(type)) {\t\t\treturn new MailSender();\t\t} else if (\"sms\".equals(type)) {\t\t\treturn new SmsSender();\t\t} else {\t\t\tSystem.out.println(\"请输入正确的类型!\");\t\t\treturn null;\t\t}\t}} 我们来测试下： public class FactoryTest {\tpublic static void main(String[] args) {\t\tSendFactory factory = new SendFactory();\t\tSender sender = factory.produce(\"sms\");\t\tsender.Send();\t}} 输出：this is sms sender! 22、多个工厂方法模式，是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。关系图： 将上面的代码做下修改，改动下SendFactory类就行，如下： public class SendFactory {\t\tpublic Sender produceMail(){\t\treturn new MailSender();\t}\t\tpublic Sender produceSms(){\t\treturn new SmsSender();\t}} 测试类如下： public class FactoryTest {\tpublic static void main(String[] args) {\t\tSendFactory factory = new SendFactory();\t\tSender sender = factory.produceMail();\t\tsender.Send();\t}} 输出：this is mailsender! 33、静态工厂方法模式，将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。 public class SendFactory {\t\tpublic static Sender produceMail(){\t\treturn new MailSender();\t}\t\tpublic static Sender produceSms(){\t\treturn new SmsSender();\t}} public class FactoryTest {\tpublic static void main(String[] args) {\t\t\tSender sender = SendFactory.produceMail();\t\tsender.Send();\t}} 输出：this is mailsender! 总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。 2、抽象工厂模式（Abstract Factory） 工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。因为抽象工厂不太好理解，我们先看看图，然后就和代码，就比较容易理解。 请看例子： public interface Sender {\tpublic void Send();} 两个实现类： public class MailSender implements Sender {\t@Override\tpublic void Send() {\t\tSystem.out.println(\"this is mailsender!\");\t}} public class SmsSender implements Sender {\t@Override\tpublic void Send() {\t\tSystem.out.println(\"this is sms sender!\");\t}} 两个工厂类： public class SendMailFactory implements Provider {\t\t@Override\tpublic Sender produce(){\t\treturn new MailSender();\t}} public class SendSmsFactory implements Provider{\t@Override\tpublic Sender produce() {\t\treturn new SmsSender();\t}} 在提供一个接口： public interface Provider {\tpublic Sender produce();} 测试类： public class Test {\tpublic static void main(String[] args) {\t\tProvider provider = new SendMailFactory();\t\tSender sender = provider.produce();\t\tsender.Send();\t}} 其实这个模式的好处就是，如果你现在想增加一个功能：发及时信息，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！ 3、单例模式（Singleton） 单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处： 1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。 2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。 3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。 首先我们写一个简单的单例类： public class Singleton {\t/* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */\tprivate static Singleton instance = null;\t/* 私有构造方法，防止被实例化 */\tprivate Singleton() {\t}\t/* 静态工程方法，创建实例 */\tpublic static Singleton getInstance() {\t\tif (instance == null) {\t\t\tinstance = new Singleton();\t\t}\t\treturn instance;\t}\t/* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */\tpublic Object readResolve() {\t\treturn instance;\t}} 这个类可以满足基本要求，但是，像这样毫无线程安全保护的类，如果我们把它放入多线程的环境下，肯定就会出现问题了，如何解决？我们首先会想到对getInstance方法加synchronized关键字，如下： public static synchronized Singleton getInstance() {\t\tif (instance == null) {\t\t\tinstance = new Singleton();\t\t}\t\treturn instance;\t} 但是，synchronized关键字锁住的是这个对象，这样的用法，在性能上会有所下降，因为每次调用getInstance()，都要对对象上锁，事实上，只有在第一次创建对象的时候需要加锁，之后就不需要了，所以，这个地方需要改进。我们改成下面这个： public static Singleton getInstance() {\t\tif (instance == null) {\t\t\tsynchronized (instance) {\t\t\t\tif (instance == null) {\t\t\t\t\tinstance = new Singleton();\t\t\t\t}\t\t\t}\t\t}\t\treturn instance;\t} 似乎解决了之前提到的问题，将synchronized关键字加在了内部，也就是说当调用的时候是不需要加锁的，只有在instance为null，并创建对象的时候才需要加锁，性能有一定的提升。但是，这样的情况，还是有可能有问题的，看下面的情况：在Java指令中创建对象和赋值操作是分开进行的，也就是说instance = new Singleton();语句是分两步执行的。但是JVM并不保证这两个操作的先后顺序，也就是说有可能JVM会为新的Singleton实例分配空间，然后直接赋值给instance成员，然后再去初始化这个Singleton实例。这样就可能出错了，我们以A、B两个线程为例： a>A、B线程同时进入了第一个if判断 b>A首先进入synchronized块，由于instance为null，所以它执行instance = new Singleton(); c>由于JVM内部的优化机制，JVM先画出了一些分配给Singleton实例的空白内存，并赋值给instance成员（注意此时JVM没有开始初始化这个实例），然后A离开了synchronized块。 d>B进入synchronized块，由于instance此时不是null，因此它马上离开了synchronized块并将结果返回给调用该方法的程序。 e>此时B线程打算使用Singleton实例，却发现它没有被初始化，于是错误发生了。 所以程序还是有可能发生错误，其实程序在运行过程是很复杂的，从这点我们就可以看出，尤其是在写多线程环境下的程序更有难度，有挑战性。我们对该程序做进一步优化： private static class SingletonFactory{                 private static Singleton instance = new Singleton();             }             public static Singleton getInstance(){                 return SingletonFactory.instance;             } 实际情况是，单例模式使用内部类来维护单例的实现，JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。这样当我们第一次调用getInstance的时候，JVM能够帮我们保证instance只被创建一次，并且会保证把赋值给instance的内存初始化完毕，这样我们就不用担心上面的问题。同时该方法也只会在第一次调用的时候使用互斥机制，这样就解决了低性能问题。这样我们暂时总结一个完美的单例模式： public class Singleton {\t/* 私有构造方法，防止被实例化 */\tprivate Singleton() {\t}\t/* 此处使用一个内部类来维护单例 */\tprivate static class SingletonFactory {\t\tprivate static Singleton instance = new Singleton();\t}\t/* 获取实例 */\tpublic static Singleton getInstance() {\t\treturn SingletonFactory.instance;\t}\t/* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */\tpublic Object readResolve() {\t\treturn getInstance();\t}} 其实说它完美，也不一定，如果在构造函数中抛出异常，实例将永远得不到创建，也会出错。所以说，十分完美的东西是没有的，我们只能根据实际情况，选择最适合自己应用场景的实现方法。也有人这样实现：因为我们只需要在创建类的时候进行同步，所以只要将创建和getInstance()分开，单独为创建加synchronized关键字，也是可以的： public class SingletonTest {\tprivate static SingletonTest instance = null;\tprivate SingletonTest() {\t}\tprivate static synchronized void syncInit() {\t\tif (instance == null) {\t\t\tinstance = new SingletonTest();\t\t}\t}\tpublic static SingletonTest getInstance() {\t\tif (instance == null) {\t\t\tsyncInit();\t\t}\t\treturn instance;\t}} 考虑性能的话，整个程序只需创建一次实例，所以性能也不会有什么影响。 补充：采用\"影子实例\"的办法为单例对象的属性同步更新 public class SingletonTest {\tprivate static SingletonTest instance = null;\tprivate Vector properties = null;\tpublic Vector getProperties() {\t\treturn properties;\t}\tprivate SingletonTest() {\t}\tprivate static synchronized void syncInit() {\t\tif (instance == null) {\t\t\tinstance = new SingletonTest();\t\t}\t}\tpublic static SingletonTest getInstance() {\t\tif (instance == null) {\t\t\tsyncInit();\t\t}\t\treturn instance;\t}\tpublic void updateProperties() {\t\tSingletonTest shadow = new SingletonTest();\t\tproperties = shadow.getProperties();\t}} 通过单例模式的学习告诉我们： 1、单例模式理解起来简单，但是具体实现起来还是有一定的难度。 2、synchronized关键字锁定的是对象，在用的时候，一定要在恰当的地方使用（注意需要使用锁的对象和过程，可能有的时候并不是整个对象及整个过程都需要锁）。 到这儿，单例模式基本已经讲完了，结尾处，笔者突然想到另一个问题，就是采用类的静态方法，实现单例模式的效果，也是可行的，此处二者有什么不同？ 首先，静态类不能实现接口。（从类的角度说是可以的，但是那样就破坏了静态了。因为接口中不允许有static修饰的方法，所以即使实现了也是非静态的） 其次，单例可以被延迟初始化，静态类一般在第一次加载是初始化。之所以延迟加载，是因为有些类比较庞大，所以延迟加载有助于提升性能。 再次，单例类可以被继承，他的方法可以被覆写。但是静态类内部方法都是static，无法被覆写。 最后一点，单例类比较灵活，毕竟从实现上只是一个普通的Java类，只要满足单例的基本需求，你可以在里面随心所欲的实现一些其它功能，但是静态类不行。从上面这些概括中，基本可以看出二者的区别，但是，从另一方面讲，我们上面最后实现的那个单例模式，内部就是用一个静态类来实现的，所以，二者有很大的关联，只是我们考虑问题的层面不同罢了。两种思想的结合，才能造就出完美的解决方案，就像HashMap采用数组+链表来实现一样，其实生活中很多事情都是这样，单用不同的方法来处理问题，总是有优点也有缺点，最完美的方法是，结合各个方法的优点，才能最好的解决问题！ 4、建造者模式（Builder） 工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的Test结合起来得到的。我们看一下代码： 还和前面一样，一个Sender接口，两个实现类MailSender和SmsSender。最后，建造者类如下： public class Builder {\t\tprivate List<Sender> list = new ArrayList<Sender>();\t\tpublic void produceMailSender(int count){\t\tfor(int i=0; i<count; i++){\t\t\tlist.add(new MailSender());\t\t}\t}\t\tpublic void produceSmsSender(int count){\t\tfor(int i=0; i<count; i++){\t\t\tlist.add(new SmsSender());\t\t}\t}} 测试类： public class Test {\tpublic static void main(String[] args) {\t\tBuilder builder = new Builder();\t\tbuilder.produceMailSender(10);\t}} 从这点看出，建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。所以与工程模式的区别就是：工程模式关注的是创建单个产品，而建造者模式则关注创建符合对象，多个部分。因此，是选择工程模式还是建造者模式，依实际情况而定。 5、原型模式（Prototype） 原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。本小结会通过对象的复制，进行讲解。在Java中，复制对象是通过clone()实现的，先创建一个原型类： public class Prototype implements Cloneable {\tpublic Object clone() throws CloneNotSupportedException {\t\tPrototype proto = (Prototype) super.clone();\t\treturn proto;\t}} 很简单，一个原型类，只需要实现Cloneable接口，覆写clone方法，此处clone方法可以改成任意的名称，因为Cloneable接口是个空接口，你可以任意定义实现类的方法名，如cloneA或者cloneB，因为此处的重点是super.clone()这句话，super.clone()调用的是Object的clone()方法，而在Object类中，clone()是native的，具体怎么实现，我会在另一篇文章中，关于解读Java中本地方法的调用，此处不再深究。在这儿，我将结合对象的浅复制和深复制来说一下，首先需要了解对象深、浅复制的概念： 浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。 深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。 此处，写一个深浅复制的例子： public class Prototype implements Cloneable, Serializable {\tprivate static final long serialVersionUID = 1L;\tprivate String string;\tprivate SerializableObject obj;\t/* 浅复制 */\tpublic Object clone() throws CloneNotSupportedException {\t\tPrototype proto = (Prototype) super.clone();\t\treturn proto;\t}\t/* 深复制 */\tpublic Object deepClone() throws IOException, ClassNotFoundException {\t\t/* 写入当前对象的二进制流 */\t\tByteArrayOutputStream bos = new ByteArrayOutputStream();\t\tObjectOutputStream oos = new ObjectOutputStream(bos);\t\toos.writeObject(this);\t\t/* 读出二进制流产生的新对象 */\t\tByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());\t\tObjectInputStream ois = new ObjectInputStream(bis);\t\treturn ois.readObject();\t}\tpublic String getString() {\t\treturn string;\t}\tpublic void setString(String string) {\t\tthis.string = string;\t}\tpublic SerializableObject getObj() {\t\treturn obj;\t}\tpublic void setObj(SerializableObject obj) {\t\tthis.obj = obj;\t}}class SerializableObject implements Serializable {\tprivate static final long serialVersionUID = 1L;} 要实现深复制，需要采用流的形式读入当前对象的二进制输入，再写出二进制数据对应的对象。 由于文章篇幅较长，为了更好的方便读者阅读，我将接下了的其它介绍放在另一篇文章中（也许会分两篇来），感谢大家提出宝贵的意见和建议！ 如有问题请联系：egg Email:xtfggef@gmail.com  微博：http://weibo.com/xtfggef","title":"Java之美[从菜鸟到高手演变]之设计模式"},{"content":"    看了很多年的设计模式，也看了很多种设计模式，也在工作中用了几个常见的设计模式。android中，包括源码和一些开源项目，用到了很多经典设计模式，而且也用的非常的精彩。学习android也有一些日子了，有空的时候看看源代码，看看开源项目的代码，自己也会再工作中写写代码。     今天，斗胆，基于android(其实就是java)，把自己对设计模式的一些粗浅认识，默默的分享出来，希望能得到各位同仁的指点，以期设计能力更进一步。我将以《设计模式:可复用面向对象软件的基础》为准，发掘android中各种设计模式的使用情况，提取核心部分，做为实例。     因为不需要写代码，应用场景又一般是android中自带的，所以文中可能会注重意图介绍和UML结构图的绘制，然后具体设计模式的本身和扩展还需要各位参考其他资料。     下面我列举一些重要的认识点: 设计模式，提供了很多软件工程问题所需处理的解决方案。 根据模式的目的可分为3类： 1.创建型模式：与对象的创建有关。 2.结构性模式：处理类与对象的组合。 3.行为性模式：对类或对象怎样交互和怎样 分配职责进行描述。 面向对象设计的2个基本原则: 1.针对接口编程，而不是针对实现编程。 2.优先使用对象组合，而不是类继承。  面向对象设计的5个设计原则： 1.单一职责原则(SRP) 2.开放封闭原则(OCP)  3.Liskov替换原则(LSP) 4.依赖倒置原则(DIP) 5.接口隔离原则(ISP)  23种设计模式： 1.创建型模式： (1).工厂方法模式 (2).抽象工厂模式 (3).创建者模式 (4).原型模式 (5).单例模式 2.结构型模式： (6).适配器模式 (7).桥模式 (8).组合模式 (9).装饰模式 (10).外观模式 (11).享元模式 (12).代理模式 3.行为型模式 (13).解释器模式 (14).模板方法模式 (15).职责链模式 (16).命令模式 (17).迭代器模式 (18).中介者模式 (19).备忘录模式 (20).观察者模式 (21).状态模式 (22).策略模式 (23).访问者模式  除此之外，后来人发现很多新的模式，如空模式等。 下面列举几个常见的问题导致重新设计，可能需要设计模式来分析解决： 1.通过显示的指定一个类来创建对象 2.对特殊操作的依赖 3.对硬件和软件平台的依赖 4.对对象表示或实现的依赖 5.算法依赖 6.紧耦合 7.通过生产子类来扩展功能 8.不能方便的对类进行修改 软件的设计臭味： 1.僵化性 2.脆弱性 3.顽固性 4.粘滞性 5.不必要的复杂性 6.不必要的重复 7.晦涩性  ... ... 总而言之，一句话，面向对象特性+原则+模式，折腾来折腾去就是这么个回事。 ------------------------------- 转自：http://www.cnblogs.com/qianxudetianxia/archive/2011/07/29/2121547.html","title":"Android设计模式系列(0)--开篇"},{"content":"按照目的分类： 创建型、结构型、行为型三种 1、创建型模式主要是目的是创建对象（一共有5种）： 工厂方法模式（Factory Method）、抽象方法模式（Abstract Factory）、建造者模式（Bulder）、原型模式（Prototype）、单例模式（Singleton） 2、结构型模式主要用于处理类或对象的组合（一共有7种）： 适配器模式（Adapter）、桥接模式（Bridge）、组合模式（Composite）、装饰模式（Decorator）、外观模式（Facade）、享元模式（Flyweight）、代理模式（Prxy） 3、行为型模式主要用于描述对类或对象怎样交互和怎样分配职责（一共有11种）： 职责链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式   按照范围分类： 类模式、对象模式两种 1、类模式处理类和子类之间的关系，这些关系通过继承建立，在编译时就被确定了，属于静态的； 2、对象模式处理对象间的关系，这些关系在运行时才被确定，属于动态的。","title":"设计模式的分类"},{"content":"C++设计模式之一 工厂模式（简单工厂、工厂和抽象工厂） 转发来自：http://blog.csdn.net/windiewang/article/details/5991626 //------------------------------------------------  开始设计模式自然而然到提到几个原则：I、开闭法则（OCP）；II、里氏代换法则（LSP）；III、依赖倒置法则(DIP)；IV、接口隔离法则（ISP）；V、合成/聚合复用原则（CARP）；VI、迪米特法则（LoD），这几个法则在吕震宇  老师的设计模式（二）和设计模式（三）中有非常详尽的阐述和深入浅出的举例分析。有兴趣的朋友打开链接看一下就可以了。 补充说明： 我这里所以代码都是用VS2005的C++编译器实现。所以不能保证在其他IDE中能顺利编译，但是我想如果你使用其他编译器，也应该不会有太大问题，主要也应该是stdafx.h文件中包含的头文件问题。 里面出行的结构图都是用微软的Visio2003 绘制，大家下载后可以直接用Visio打开。 在以后所有的模式例子中都有客户程序，客户程序这个角色不是模式本身的内容，它是模式之外的部分，但是正是这个客户程序完成了对模式的使用，模式本身的结构是讲解的重点，但是客户程序如何使用模式也是理解模式的一个重要方面，因此在我后续的介绍中都有客户程序这个角色，并会说明究竟调用模式中的哪些角色完成对模式的使用。 简单工厂模式 生活例子 吃饭是人的基本需求，如果人类不需要吃饭，可能我们就能活得清闲许多，也就不需要像现在一样没日没夜的工作，学习。我们学习是为了找到更好的工作，好工作为了赚更多的钱，最终为了吃饱饭，吃好饭。因此可以说吃饭是与人息息相关，下面就从吃饭的例子来引入工厂模式的学习。 如果你想吃饭了，怎么办自己做吗？自己做就相当于程序中直接使用new。当然是自己下个指令，别人来做更爽。那就把做饭的任务交给你的老婆吧，那么她就是一个做饭的工厂了，你告诉她要要吃红烧肉，等会她就从厨房给你端出来一盘香喷喷的红烧肉了，再来个清蒸鱼吧，大鱼大肉不能太多，那就再来个爆炒空心菜，最后再来个西红柿鸡蛋汤。下图  1) 就是这个问题的模型。 （图1） 显然到了这里，你是Client，你老婆就是工厂，她拥有做红烧肉的方法，做清蒸鱼的方法，做爆炒空心菜、西红柿鸡蛋汤的方法，这些方法返回值就是食物抽象。红烧肉、清蒸鱼、爆炒空心菜、西红柿鸡蛋汤就是食物的继承类，到这里你就可以大吃二喝了。简单工厂模式也成型了。哈哈，娶一个手艺不错的老婆还真好，吃的好，吃的爽，又清闲。 下面来看标准的简单工厂模式的分析。  意图 把一系列拥有共同特征的产品的创建封装 结构图 （图2） 角色分析 产品基类： 工厂创建的所有产品的基类, 它负责描述所有实例所共有的公共接口。它用来作为工厂方法的返回参数。 代码实现： //---这时一个系列的产品基类 class Product { protected: Product(void); public: virtual ~Product(void); public: virtual void Function() = 0; }; //cpp Product:roduct(void) { } Product::~Product(void) { } 具体产品类：产品1和产品2，这个角色实现了抽象产品角色所定义的接口。 代码实现： //产品A class ConcreteProductA:public Product { public: ConcreteProductA(void); public: virtual ~ConcreteProductA(void); public: virtual void Function(); }; //cpp ConcreteProductA::ConcreteProductA() { cout<<\"创建 A 产品\"<<endl; } ConcreteProductA::~ConcreteProductA() { cout<<\"释放 A 产品\"<<endl; } void ConcreteProductA::Function() { cout<<\"这是产品 A 具有的基本功能\"<<endl; } //产品B与A类似不这里不再给出，大家可以下载源码 工厂类：负责具体产品的创建，有两种方式实现产品的创建，I、创建不同的产品用不同的方法；II、创建不同产品用相同的方法，然后通过传递参数实现不同产品的创建。本实例中两种模式都给出了，大家自行分析。  //简单工厂，此类不需要继承，直接硬编码实现生成的产品 class SimpleFactory { public: SimpleFactory(){} public: ~SimpleFactory(){} public: Product *CreateProduct(int ProuctType); Product *CreateProductA(); Product *CreateProductB(); }; //CPP Product * SimpleFactory::CreateProduct(int ProductType=0) { Product *p = 0; switch(ProductType) { case 0: p= new ConcreteProductA(); break; case 1: p= new ConcreteProductB(); break; default: p= new ConcreteProductA(); break; } return p; } Product *SimpleFactory::CreateProductA() { return new ConcreteProductA(); } Product *SimpleFactory::CreateProductB() { return new ConcreteProductB(); } 客户端程序：访问的角色包括产品基类、工厂类。不直接访问具体产品类。通过基类指针的多态实现产品功能的调用。 访问描述：客户程序通过调用工厂的方法返回抽象产品，然后执行产品的方法。 //调用代码 SimpleFactory sf; Product *p = sf.CreateProductA(); p->Function(); delete p; p = sf.CreateProductB(); p->Function(); delete p; 优缺点说明 优点：1) 首先解决了代码中大量New的问题。为何要解决这个问题，好处的说明我想放到结尾总结中。 2) 用工厂方法在一个类的内部创建对象通常比直接创建对象更灵活。  缺点：对修改不封闭，新增加产品您要修改工厂。违法了鼎鼎大名的开闭法则（OCP）。 附加说明 大家可以参看 吕震宇 老师的C#设计模式（四）参看这个模式的分析，里面还给出了这个模式的两个变体，实现比较简单，有兴趣的朋友可以自行用C++实现一下。 产品基类的代码中构造函数我用了Protected，而没有使用Public，主要是为了体现编码中的一个最小权限原则。说明此类不许用户直接实例化。虽然这里使用了virtual void Function() = 0;编译器也会控制不让用户直接实例化，不过我依然认为使用私有化构造函数来保护类不直接实例化是一个良好的编程风格。 工厂方法模式 生活例子: 人是最贪得无厌的动物，老婆手艺再好，总有不会做的菜，你想吃回锅肉，怎么办，让老婆学呗，于是就给她就新增了做回锅肉的方法，以后你再想吃一个新菜，就要给你老婆新加一个方法，显然用老婆做菜的缺点也就暴露出来了，用程序设计的描述就是对修改永远不能封闭。当然优点也是有的，你有了老婆这个工厂，这些菜不用你自己做了，只要直接调用老婆这个工厂的方法就可以了。  面对上面对修改不能封闭的问题，有没有好的解决方案吗，如果你有钱，问题就迎刃而解了，把老婆抽象变成一个基类，你多娶几个具体的老婆，分别有做鱼的，做青菜的，炖汤的老婆，如果你想吃一个新菜，就再新找个女人，从你的老婆基类继承一下，让她来做这个新菜。显然多多的老婆这是所有男人的梦想，没有办法，法律不允许，那么咱们只是为了做饭，老婆这个抽象类咱们不叫老婆了，叫做厨师吧，她的子类也自然而然的该叫做鱼的厨师、炖汤的厨师了。现在来看这个模式发生了变化，结构中多了一个厨师的抽象，抽象并不具体的加工产品了，至于是炖汤还是炖鱼，是由这个抽象工厂的继承子类来实现，现在的模式也就变成工厂方法模式了，这个上面的结构图1)就变成了下面的图3的结构了。 （图3） 现在再来分析现在的模式，显然简单工厂的缺陷解决了，新增加一个菜只需要新增加一个厨师就行了，原来的厨师还在做原来的工作，这样你的设计就对修改封闭了。你看把老婆解放出来，招聘大量的厨师到你家里这个方案多么的完美，你老婆也会爱死你了。当然前提就是你要有多多的钱噢，当然这里的钱的多少在软件领域应该看你的客户软件投资方的要求。  下面来一下标准的工厂模式的实现 意图 定义一个用户创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。 上面是GOF关于此模式的意图描述，我想补充的是您可以这样理解：为了改善简单工厂对修改不能关闭的问题。 结构 图4 角色分析 产品基类：同简单工厂的产品基类，其实就是用和简单工厂中的是同一个类，这里并没有重写。 具体产品类：也是用的简单工厂的具体产品类，为了体现对修改的关闭这里为系统新添加了一个具体产品类，就是“新产品”，代码中叫做“ConcreteProductANew” 工厂基类：定义了工厂创建产品的接口，但是没有实现，具体创建工作由其继承类实现。 代码实例  //工厂模式，此模式的工厂只定义加工产品的接口，具体生成交予其继承类实现 //只有具体的继承类才确定要加工何种产品 class Factory { public: Factory(void); public: virtual ~Factory(void); public: virtual Product* CreateProduct(int ProductType = 0) =0; }; //CPP Factory::Factory(void) { } Factory::~Factory(void) { } 具体工厂类：工厂基类的具体实现，由此类决定创建具体产品，这里 ConcreteFactory1 对于与图中的 工厂实现，ConcreteFactory2 对于与图中的新工厂。 下面给出实现代码 //工厂实现 class ConcreteFactory1:public Factory { public: ConcreteFactory1(); public: virtual ~ConcreteFactory1(); public : Product* CreateProduct(int ProductType); }; //新工厂，当要创建新类是实现此新工厂 class ConcreteFactory2:public Factory { public: ConcreteFactory2(); public: virtual ~ConcreteFactory2(); public : Product* CreateProduct(int ProductType); }; //CPP ConcreteFactory1::ConcreteFactory1() { } ConcreteFactory1::~ConcreteFactory1() { } Product * ConcreteFactory1::CreateProduct(int ProductType = 0) { Product *p = 0; switch(ProductType) { case 0: p= new ConcreteProductA(); break; case 1: p= new ConcreteProductB(); break; default: p= new ConcreteProductA(); break; } return p; } ConcreteFactory2::ConcreteFactory2() { } ConcreteFactory2::~ConcreteFactory2() { } Product * ConcreteFactory2::CreateProduct(int ProductType = 0) { return new ConcreteProductANew(); } 客户端调用：访问角色（产品基类、工厂基类、工厂实现类） 调用描述：客户程序通过工厂基类的方法调用工厂实现类用来创建所需要的具体产品。从而实现产品功能的访问。 代码实现 Factory*fct = new ConcreteFactory1(); Product *p = fct->CreateProduct(0); p->Function(); delete p; p = fct->CreateProduct(1); p->Function(); delete p; delete fct; fct = new ConcreteFactory2(); p=fct->CreateProduct(); delete p; delete fct; 优缺点分析 优点 简单工厂具有的优点 解决了简单工厂的修改不能关闭的问题。系统新增产品，新增一个产品工厂即可，对抽象工厂不受影响。 缺点：对于创建不同系列的产品无能为力 适用性 当一个类不知道它所必须创建的对象的类的时候。 当一个类希望由它的子类来指定它所创建的对象的时候。 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。 其他参考 吕震宇的C#设计模式（5）－Factory Method Pattern TerryLee 的.NET设计模式（5）：工厂方法模式（Factory Method） 抽象工厂模式 生活例子 世事多变，随着时间的推移，走过的地方越来越多，你天南海北的朋友也越来越多。你发现菜原来还分了许多菜系，鲁菜、粤菜、湘菜等等，它们各有各的风味，同样是红烧肉由不同菜系出来的味道也各不相同，你招待不同的朋友要用不同的菜系，这下难办了，你的厨师都是鲁菜风味，怎么办，广东的朋友来了吃不惯。现在我们再回到简单工厂模式（就是老婆做菜的模式），我们把红烧肉再向下继承，生成鲁菜红烧肉、粤菜红烧肉、湘菜红烧肉；清蒸鱼向下继承为鲁菜清蒸鱼、粤菜清蒸鱼、湘菜清蒸鱼，其它也以此类推。我们也修改一下老婆的这个类，不让其返回食物基类，而是返回红烧肉、清蒸鱼、爆炒空心菜、西红柿鸡蛋汤这一层次，并把这些方法抽象化，作为菜系工厂基类，然后再从此基类继承出，鲁菜工厂、粤菜工厂、湘菜工厂等等，再由这些具体工厂实现创建具体菜的工作，哈哈你如果招待广东朋友就用粤菜工厂，返回的就是一桌粤菜菜系的红烧肉、清蒸鱼、空心菜和西红柿鸡蛋汤了，你的广东朋友一定会吃的非常合乎胃口了。噢，非常好，你已经实现了抽象工厂模式了。结构模型图也变成了下图 6)的样子了。 （图6） 现在可以看到，想新来做一个菜系，只需新聘请一个厨师就可以了，多么完美，但是你先别高兴太早，如果你想新增加一个菜就变得非常困难了。 意图 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。  结构 角色分析 产品基类：这里包含产品基类A和产品基类B，实际上在我的示例代码中，这两个产品都从共同的基类继承而来，但是这个继承关系却是在这个模式之外的部分，而本身这个模式关心的是这两个产品基类的差异部分。  代码实现：这里的代码就是借用的简单工厂模式中具体产品类的代码实现部分，为了大家阅读方便，下面重新给出一下。 //产品A class ConcreteProductA:public Product { public: ConcreteProductA(void); public: virtual ~ConcreteProductA(void); public: virtual void Function(); }; //cpp ConcreteProductA::ConcreteProductA() { cout<<\"创建 A 产品\"<<endl; } ConcreteProductA::~ConcreteProductA() { cout<<\"释放 A 产品\"<<endl; } void ConcreteProductA::Function() { cout<<\"这是产品 A 具有的基本功能\"<<endl; } //产品B与A类似不这里不再给出，大家可以下载源码 具体产品类：这里的具体产品类是产品A1，A2，B1、B2等， 代码实现：A1对应的实现就是“” class ConcreteProductA1:public ConcreteProductA { public: ConcreteProductA1(void); public: virtual ~ConcreteProductA1(void); public: virtual void Function(); }; //CPP ConcreteProductA1::ConcreteProductA1() { cout<<\"创建 A1 产品\"<<endl; } ConcreteProductA1::~ConcreteProductA1() { cout<<\"释放 A1 产品\"<<endl; } void ConcreteProductA1::Function() { cout<<\"这时产品 A1 具有的基本功能\"<<endl; } 工厂抽象接口：定义了创建产品的接口，这里返回参数是返回的产品A，产品B，而本身产品A和B的共同基类，小弟认为正是这个特征构成了抽象工厂和工厂模式的区别。 代码实现 //抽象工厂模式 class AbstractFactory { public: AbstractFactory(); public: virtual ~AbstractFactory(); public: virtual ConcreteProductA* CreateA() = 0; virtual ConcreteProductB* CreateB() = 0; }; //CPP AbstractFactory::AbstractFactory() { } AbstractFactory::~AbstractFactory() { } 具体工厂实现类：工厂1和工厂2。新增加系列，只需新实现一个工厂。 代码实现: 工厂1的就是ConcreteAbsFactory1，工厂2的代码类似，这里没有给出，可以在下载代码中看到 ////工厂1----- class ConcreteAbsFactory1:public AbstractFactory { public: ConcreteAbsFactory1(); public: virtual ~ConcreteAbsFactory1(); public: virtual ConcreteProductA* CreateA(); virtual ConcreteProductB* CreateB(); }; //CPP ConcreteAbsFactory1::ConcreteAbsFactory1() { } ConcreteAbsFactory1::~ConcreteAbsFactory1() { } ConcreteProductA* ConcreteAbsFactory1::CreateA() { return new ConcreteProductA1(); } ConcreteProductB * ConcreteAbsFactory1::CreateB() { return new ConcreteProductB1(); } 客户端访问： 访问角色（产品基类、抽象工厂、具体工厂实现类） 访问描述： 通过抽象工厂的指针访问具体工厂实现来创建对应系列的产品，然后通过产品基类指针访问产品功能。 调用代码： AbstractFactory *absfct = new ConcreteAbsFactory1(); ConcreteProductA *cpa = absfct->CreateA(); cpa->Function(); delete cpa; ConcreteProductB *cpb = absfct->CreateB(); cpb->Function(); delete cpb; delete absfct; absfct = new ConcreteAbsFactory2(); cpa = absfct->CreateA(); cpa->Function(); delete cpa; cpb = absfct->CreateB(); cpb->Function(); delete cpb; 和工厂模式的分析比较 现在可以和工厂模式对比一下，抽象工厂返回的接口不再是产品A和产品B的共同基类Product了，而是产品A、产品B基类（在工厂模式中它们为具体实现类，这里变成了基类）了。此时工厂的抽象和简单工厂中的工厂方法也很类似，就是这些特征区使其别于工厂模式而变成抽象工厂模式了，因此抽象工厂解决的是创建一系列有共同风格的产品（鲁菜还是粤菜），而工厂方法模式解决的创建有共同特征的一系列产品（红烧肉、清蒸鱼它们都是食物）。当然简单工厂的缺陷在抽象工厂中又再次出现了，我要新增加一个产品，工厂抽象接口就要改变了。因此抽象工厂并不比工厂模式完美，只不过是各自的适用领域不同而已。其实，这里如果把抽象工厂模式的接口返回产品A和产品B的共同基类（工厂模式返回的参数），你会发现，奇怪这个模式怎么这么眼熟，它不是恰恰退化成工厂模式了。 类模式与对象模式的区别讨论：先看定义类“模式使用继承关系，把对象的创建延迟的子类，对象模式把对象的创建延迟到另一个对象中”。分析：首先它们创建对象都不是在基类中完成，都是在子类中实现，因此都符合类模式的概念；但是工厂模式的创建产品对象是在编译期决定的，要调用某个工厂固定的，而抽象工厂模式对产品的创建是在运行时动态决定的，只有到运行时才确定要调用那个工厂，调用工厂随运行环境而改变。（这里我一直很混乱，欢迎大家讨论） 适用性 一个系统要独立于它的产品的创建、组合和表示时 一个系统要由多个 产品系列中的一个来配置时 当你要强调一个系列相关的产品对象的设计以便进行联合使用时 当你提供一个产品类库，而只想显示它们的接口而不是实现时。 参考 吕震宇的C#设计模式（6） TerryLee 的.NET设计模式（3）：抽象工厂模式（Abstract Factory） 总结 工厂本质就是用工厂方法替代直接New来创建对象。这里不是指的让用户重载一个新操作符号来进行创建对象的操作，而是说把New 操作封装在一个方法中，等用户需要创建对象时调用此方法而避免直接使用New而已。这样做的目的就是之一就是封装，避免代码中大量New的运算符，这当然不是主要目的，因为这样虽然New少了，CreateObject方法却多了，但是如果产品类的构造函数变了，我想常用工厂模式的修改源代码的工作应该简便许多吧，当然这算不上这个模式的好处，它的真正强大的功能其实在于适应变化，这也是整个设计模式最根本的目的；还有一点就是体现了抽象于实现的分离，当然创建型模式都具有这个特点，工厂模式非常明显吧了，把具体创建工作放置到工厂中，使客户端程 序更专注与业务逻辑的，这样的代码结构也更进行合理。","title":"C++设计模式之一 工厂模式（简单工厂、工厂和抽象工厂）"},{"content":"一、 门面（Facade）模式 外部与一个子系统的通信必须通过一个统一的门面(Facade)对象进行，这就是门面模式。 医院的例子 用一个例子进行说明，如果把医院作为一个子系统，按照部门职能，这个系统可以划分为挂号、门诊、划价、化验、收费、取药等。看病的病人要与这些部门打交道，就如同一个子系统的客户端与一个子系统的各个类打交道一样，不是一件容易的事情。 首先病人必须先挂号，然后门诊。如果医生要求化验，病人必须首先划价，然后缴款，才能到化验部门做化验。化验后，再回到门诊室。 解决这种不便的方法便是引进门面模式。可以设置一个接待员的位置，由接待员负责代为挂号、划价、缴费、取药等。这个接待员就是门面模式的体现，病人只接触接待员，由接待员负责与医院的各个部门打交道。 什么是门面模式 门面模式要求一个子系统的外部与其内部的通信必须通过一个统一的门面(Facade)对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。 就如同医院的接待员一样，门面模式的门面类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与门面对象打交道，而不需要与子系统内部的很多对象打交道。 二、 门面模式的结构 门面模式是对象的结构模式。门面模式没有一个一般化的类图描述，下图演示了一个门面模式的示意性对象图：   在这个对象图中，出现了两个角色： 门面(Facade)角色：客户端可以调用这个角色的方法。此角色知晓相关的(一个或者多个)子系统的功能和责任。在正常情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去。 子系统(subsystem)角色：可以同时有一个或者多个子系统。每一个子系统都不是一个单独的类，而是一个类的集合。每一个子系统都可以被客户端直接调用，或者被门面角色调用。子系统并不知道门面的存在，对于子系统而言，门面仅仅是另外一个客户端而已。 三、 门面模式的实现 一个系统可以有几个门面类 【GOF】的书中指出：在门面模式中，通常只需要一个门面类，并且此门面类只有一个实例，换言之它是一个单例类。当然这并不意味着在整个系统里只能有一个门面类，而仅仅是说对每一个子系统只有一个门面类。或者说，如果一个系统有好几个子系统的话，每一个子系统有一个门面类，整个系统可以有数个门面类。 为子系统增加新行为 初学者往往以为通过继承一个门面类便可在子系统中加入新的行为，这是错误的。门面模式的用意是为子系统提供一个集中化和简化的沟通管道，而不能向子系统加入新的行为。 四、 在什么情况下使用门面模式 为一个复杂子系统提供一个简单接口 提高子系统的独立性 在层次化结构中，可以使用Facade模式定义系统中每一层的入口。 五、 一个例子 我们考察一个保安系统的例子，以说明门面模式的功效。一个保安系统由两个录像机、三个电灯、一个遥感器和一个警报器组成。保安系统的操作人员需要经常将这些仪器启动和关闭。 不使用门面模式的设计 首先，在不使用门面模式的情况下，操作这个保安系统的操作员必须直接操作所有的这些部件。下图所示就是在不使用门面模式的情况下系统的设计图。   可以看出，Client对象需要引用到所有的录像机(Camera)、电灯(Light)、感应器(Sensor)和警报器(Alarm)对象。代码如下： using System; public class Camera {   public void TurnOn()   {     Console.WriteLine(\"Turning on the camera.\");   }   public void TurnOff()   {     Console.WriteLine(\"Turning off the camera.\");   }   public void Rotate(int degrees)   {     Console.WriteLine(\"Rotating the camera by {0} degrees.\", degrees);   } } public class Light {   public void TurnOff()   {     Console.WriteLine(\"Turning on the light.\");   }   public void TurnOn()   {     Console.WriteLine(\"Turning off the light.\");   }   public void ChangeBulb()   {     Console.WriteLine(\"changing the light-bulb.\");   } } public class Sensor {   public void Activate()   {     Console.WriteLine(\"Activating the sensor.\");   }   public void Deactivate()   {     Console.WriteLine(\"Deactivating the sensor.\");   }   public void Trigger()   {     Console.WriteLine(\"The sensor has triggered.\");   } } public class Alarm {   public void Activate()   {     Console.WriteLine(\"Activating the alarm.\");   }   public void Deactivate()   {     Console.WriteLine(\"Deactivating the alarm.\");   }   public void Ring()   {     Console.WriteLine(\"Ringing the alarm.\");   }   public void StopRing()   {     Console.WriteLine(\"Stop the alarm.\");   } } public class Client {   private static Camera camera1, camera2;   private static Light light1, light2, light3;   private static Sensor sensor;   private static Alarm alarm;   static Client()   {     camera1 = new Camera();     camera2 = new Camera();     light1 = new Light();     light2 = new Light();     light3 = new Light();     sensor = new Sensor();     alarm = new Alarm();   }     public static void Main( string[] args )   {     camera1.TurnOn();     camera2.TurnOn();     light1.TurnOn();     light2.TurnOn();     light3.TurnOn();     sensor.Activate();     alarm.Activate();   } }   六、 使用门面模式的设计 一个合情合理的改进方法就是准备一个系统的控制台，作为保安系统的用户界面。如下图所示：   程序代码如下： using System; public class Camera {   public void TurnOn()   {     Console.WriteLine(\"Turning on the camera.\");   }   public void TurnOff()   {     Console.WriteLine(\"Turning off the camera.\");   }   public void Rotate(int degrees)   {     Console.WriteLine(\"Rotating the camera by {0} degrees.\", degrees);   } } public class Light {   public void TurnOff()   {     Console.WriteLine(\"Turning on the light.\");   }   public void TurnOn()   {     Console.WriteLine(\"Turning off the light.\");   }   public void ChangeBulb()   {     Console.WriteLine(\"changing the light-bulb.\");   } } public class Sensor {   public void Activate()   {     Console.WriteLine(\"Activating the sensor.\");   }   public void Deactivate()   {     Console.WriteLine(\"Deactivating the sensor.\");   }   public void Trigger()   {     Console.WriteLine(\"The sensor has triggered.\");   } } public class Alarm {   public void Activate()   {     Console.WriteLine(\"Activating the alarm.\");   }   public void Deactivate()   {     Console.WriteLine(\"Deactivating the alarm.\");   }   public void Ring()   {     Console.WriteLine(\"Ringing the alarm.\");   }   public void StopRing()   {     Console.WriteLine(\"Stop the alarm.\");   } } public class SecurityFacade {   private static Camera camera1, camera2;   private static Light light1, light2, light3;   private static Sensor sensor;   private static Alarm alarm;   static SecurityFacade()   {     camera1 = new Camera();     camera2 = new Camera();     light1 = new Light();     light2 = new Light();     light3 = new Light();     sensor = new Sensor();     alarm = new Alarm();   }      public void Activate()   {     camera1.TurnOn();     camera2.TurnOn();     light1.TurnOn();     light2.TurnOn();     light3.TurnOn();     sensor.Activate();     alarm.Activate();   }   public void Deactivate()   {     camera1.TurnOff();     camera2.TurnOff();     light1.TurnOff();     light2.TurnOff();     light3.TurnOff();     sensor.Deactivate();     alarm.Deactivate();   } } public class Client {   private static SecurityFacade security;   public static void Main( string[] args )   {     security = new SecurityFacade();     security.Activate();     Console.WriteLine(\"\\n--------------------\\n\");     security.Deactivate();   } }   参考文献： 阎宏，《Java与模式》，电子工业出版社 [美]James W. Cooper，《C#设计模式》，电子工业出版社 [美]Alan Shalloway  James R. Trott，《Design Patterns Explained》，中国电力出版社 [美]Robert C. Martin，《敏捷软件开发－原则、模式与实践》，清华大学出版社 [美]Don Box, Chris Sells，《.NET本质论 第1卷：公共语言运行库》，中国电力出版社","title":"门面（Facade）模式"},{"content":"1、FACTORY-追MM少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是MM爱吃的东西，虽然口味有所不同，但不管你带MM去麦当劳或肯德基，只管向服务员说\"来四个鸡翅\"就行了。麦当劳和肯德基就是生产鸡翅的Factory 　　工厂模式：客户类和工厂类分开。消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。 　　2、BUILDER-MM最爱听的就是\"我爱你\"这句话了，见到不同地方的MM,要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到MM我只要按对应的键，它就能够用相应的语言说出\"我爱你\"这句话了，国外的MM也可以轻松搞掂，这就是我的\"我爱你\"builder。（这一定比美军在伊拉克用的翻译机好卖） 　　建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。 　　3、FACTORY METHOD-请MM去麦当劳吃汉堡，不同的MM有不同的口味，要每个都记住是一件烦人的事情，我一般采用Factory Method模式，带着MM到服务员那儿，说\"要一个汉堡\"，具体要什么样的汉堡呢，让MM直接跟服务员说就行了。 　　工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。 　　4、PROTOTYPE-跟MM用QQ聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要copy出来放到QQ里面就行了，这就是我的情话prototype了。（100块钱一份，你要不要） 　　原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。 　　5、SINGLETON-俺有6个漂亮的老婆，她们的老公都是我，我就是我们家里的老公Sigleton，她们只要说道\"老公\"，都是指的同一个人，那就是我(刚才做了个梦啦，哪有这么好的事) 　　单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的\"单一实例\"的需求时才可使用。 结构型模式 　　6、ADAPTER-在朋友聚会上碰到了一个美女Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友kent了，他作为我和Sarah之间的Adapter，让我和Sarah可以相互交谈了(也不知道他会不会耍我) 　　适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。 　　7、BRIDGE-早上碰到MM，要说早上好，晚上碰到MM，要说晚上好；碰到MM穿了件新衣服，要说你的衣服好漂亮哦，碰到MM新做的发型，要说你的头发好漂亮哦。不要问我\"早上碰到MM新做了个发型怎么说\"这种问题，自己用BRIDGE组合一下不就行了 　　桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以独立的变化。 　　8、COMPOSITE-Mary今天过生日。\"我过生日，你要送我一件礼物。\"\"嗯，好吧，去商店，你自己挑。\"\"这件T恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。\"\"喂，买了三件了呀，我只答应送一件礼物的哦。\"\"什么呀，T恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。\"\"......\"，MM都会用Composite模式了，你会了没有？ 　　合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。 　　9、DECORATOR-Mary过完轮到Sarly过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上\"最好的的礼物，就是爱你的Fita\"，再到街上礼品店买了个像框（卖礼品的MM也很漂亮哦），再找隔壁搞美术设计的Mike设计了一个漂亮的盒子装起来......，我们都是Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？ 　　装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。 　　10、FACADE-我有一个专业的Nikon相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但MM可不懂这些，教了半天也不会。幸好相机有Facade设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样MM也可以用这个相机给我拍张照片了。 　　门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。 　　11、FLYWEIGHT-每天跟MM发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上MM的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是Flyweight，MM的名字就是提取出来的外部特征，根据上下文情况使用。 　　享元模式：FLYWEIGHT在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。 　　12、PROXY-跟MM在网上聊天，一开头总是\"hi,你好\",\"你从哪儿来呀？\"\"你多大了？\"\"身高多少呀？\"这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自动的回答，接收到其他的话时再通知我回答，怎么样，酷吧。 　　代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。 行为模式 　　13、CHAIN OF RESPONSIBLEITY-晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上\"Hi,可以做我的女朋友吗？如果不愿意请向前传\"，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条传给老师了，听说是个老处女呀，快跑! 　　责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接 　　起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。 　　14、COMMAND-俺有一个MM家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：\"我同时给我姐姐三个男朋友送COMMAND，就数你最小气，才请我吃面。\"， 　　命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。 　　15、INTERPRETER-俺有一个《泡MM真经》，上面有各种泡MM的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟MM约会时，只要做一个Interpreter，照着上面的脚本执行就可以了。 　　解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。 　　16、ITERATOR-我爱上了Mary，不顾一切的向她求婚。 　　Mary：\"想要我跟你结婚，得答应我的条件\" 　　我：\"什么条件我都答应，你说吧\" 　　Mary：\"我看上了那个一克拉的钻石\" 　　我：\"我买，我买，还有吗？\" 　　Mary：\"我看上了湖边的那栋别墅\" 　　我：\"我买，我买，还有吗？\" 　　Mary：\"我看上那辆法拉利跑车\" 　　我脑袋嗡的一声，坐在椅子上，一咬牙：\"我买，我买，还有吗？\" 　　...... 　　迭代子模式：迭代子模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代子模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。 　　17、MEDIATOR-四个MM打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就OK啦，俺得到了四个MM的电话。 　　调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。 　　18、MEMENTO-同时跟几个MM聊天时，一定要记清楚刚才跟MM说了些什么话，不然MM发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个MM说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。 　　备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。 　　19、OBSERVER-想知道咱们公司最新MM情报吗？加入公司的MM情报邮件组就行了，tom负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦 　　观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。 　　20、STATE-跟MM交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的MM就会说\"有事情啦\"，对你不讨厌但还没喜欢上的MM就会说\"好啊，不过可以带上我同事么？\"，已经喜欢上你的MM就会说\"几点钟？看完电影再去泡吧怎么样？\"，当然你看电影过程中表现良好的话，也可以把MM的状态从不讨厌不喜欢变成喜欢哦。 　　状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。 　　21、STRATEGY-跟不同类型的MM约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到MM的芳心，我的追MM锦囊中有好多Strategy哦。 　　策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模式把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。 　　22、TEMPLATE METHOD--看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤(Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦(具体实现)； 　　模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。 　　23、VISITOR-情人节到了，要给每个MM送一束鲜花和一张卡片，可是每个MM送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下Visitor，让花店老板根据MM的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了； 　　访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。","title":"追MM与23种设计模式"},{"content":"在包含访问数据库代的代理类中综合运用各种设计模式：工厂化方法，数目访问对象，各种ORM技术（Hibernate，EJB）； MVC： M：模型。代表了该应用程序的核心功能，负责处理用户的数据，实现业务逻辑； V：视图。代表了界面。 C：控制器。负责接收用户的请求和数据，接着做出判断将请求和数据交由哪一个模型来处理，最后调用视图来显示模型返回的数据。   Java Web领域存在两种经典模型，也称实现模式，分别是Model1和Moder2. Model1：JSP（V和C）+JavaBean（M）：大量的HTML标记与Java语句的混合物，不利于维护； Model2：JSP（V）+Servlet（C）+JavaBean（M）。当用户通过浏览器向服务器发请求时，接收请求的组件从原先的JSP换成了Servlet。Servlet通过自身的逻辑判断调用相应的JavaBean处理用户请求，JavaBean则负责业务逻辑的处理和数据持久化等工作。待到处理完成，JavaBean将结果返回，再由JSP页面返回给客户浏览器，完成一次操作。 小结：在B/S结构中，一般将应用划分为表示层、业务逻辑层和数据持久层，访问数据库的操作对应的就是持久层。 对持久层的封装，当前最通用的方法就是数据访问对象模式（DAO）。","title":"JavaWeb学习笔记之MVC"},{"content":"DECORATOR 装饰模式   1、 意图 动态地给一个对象添加一些额外的职责。就添加功能来说，Decorator模式就比生成子类更灵活。 2、 适用性 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。 处理那些可以撤销的职责。 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。 3、 结构 4、 参与者 Component ——定义一个对象接口，可以给这些对象动态地添加职责。 ConcreteComponent ——定义一个对象，可以给这些对象添加一些职责。 Decorator ——维持一个指向Component对象的指针，并定义一个与Component接口一致的接口。 ConcreteDecorator ——向组件添加职责。 5、 协作 Decorator将请求转发给它的Component对象，并有可能在转发请求前后执行一些附加的动作。 6、 效果 Decorator模式至少有两个主要优点和两个缺点： 1）  比静态继承更灵活。与对象的静态继承（多重继承）相比，Decorator模式提供了更加灵活的向对象添加职责的方式。可以用添加和分离的方法，用装饰在运行时刻添加或删除职责。 2）  避免在层次结构高层的类有太多的特征。Decorator模式提供了一种“即用即付”的方法来添加职责。它并不试图在一个复杂的可定制的类中支持所有可预见的特征，相反，你可以定义一个简单的类，并且用Decorator类给它逐渐地添加功能。 3）  Decorator与它的Component不一样。Decorator是一个透明的包装。如果我们从对象标识的观点出发，一个被装饰了的组件与这个组件是有差别的，因此，使用装饰时不应该依赖对象标识。 4）  有很多的小对象。采用Decorator模式进行系统设计往往会产生许多看上去类似的小对象，这些对象仅仅在他们互相连接的方式上有所不同，而不是它们的类或是它们的属性值有所不同。 7、 实现 1）  接口的一致性。装饰对象的接口必须与它所装饰的Component的接口是一致的，因此，所有的ConcreteDecorator类必须有一个公共的父类。 2）  省略抽象的Decorator类；当你仅需要添加一个职责时，没有必要定义抽象Decorator类。 3）  保持Component类的简单性。为了保证接口的一致性，组件和装饰必须有一个公共的Component父类。因此保持这个类的简单性很重要；即，它应集中与定义接口而不是存储数据。 4）  改变对象外壳与改变对象内核；我们可以将Decorator看作一个对象的外壳，它可以改变对象的行为。另一种方法是改变对象的内核。 8、 代码示例 Component package com.examples.pattern.decorator;/** * 组件对象的接口，可以给这些对象动态地添加职责 */public abstract class Component {\tpublic abstract void operation();} ConcreteComponent package com.examples.pattern.decorator;/** * 具体实现组件对象接口的对象 */public class ConcreteComponent extends Component {\t@Override\tpublic void operation() {\t\tSystem.out.println(\"operation....\");\t}} Decorator package com.examples.pattern.decorator;/** * 装饰器接口，维持一个指向组件对象的接口对象，并定义一个与组件接口一致的接口 */public abstract class Decorator extends Component {\tprotected Component component;\t/**\t * 构造方法，传入组件对象\t * \t * @param component\t *            组件对象\t */\tpublic Decorator(Component component) {\t\tthis.component = component;\t}\t@Override\tpublic void operation() {\t\t// 转发请求给组件对象，可以在转发前后执行一些附加动作\t\tcomponent.operation();\t}} ConcreteDecorator package com.examples.pattern.decorator;/** * 装饰器的具体实现对象，向组件对象添加职责 */public class ConcreteDecoratorA extends Decorator {\tpublic ConcreteDecoratorA(Component component) {\t\tsuper(component);\t}\t/**\t * 添加的状态\t */\tprivate String addedState;\tpublic String getAddedState() {\t\treturn addedState;\t}\tpublic void setAddedState(String addedState) {\t\tthis.addedState = addedState;\t}\tpublic void operation() {\t\tsuper.operation();\t\tSystem.out.println(\"ConcreteDecoratorA :\" + addedState);\t}} package com.examples.pattern.decorator;/** * 装饰器的具体实现对象，向组件对象添加职责 */public class ConcreteDecoratorB extends Decorator {\tpublic ConcreteDecoratorB(Component component) {\t\tsuper(component);\t}\t/**\t * 添加的状态\t */\tprivate String addedState;\tpublic String getAddedState() {\t\treturn addedState;\t}\tpublic void setAddedState(String addedState) {\t\tthis.addedState = addedState;\t}\tpublic void operation() {\t\tsuper.operation();\t\tSystem.out.println(\"ConcreteDecoratorB :\" + addedState);\t}}Client package com.examples.pattern.decorator;public class Client {\t/**\t * @param args\t */\tpublic static void main(String[] args) {\t\tConcreteComponent cc = new ConcreteComponent();\t\tConcreteDecoratorA cda = new ConcreteDecoratorA(cc);\t\tConcreteDecoratorB cdb = new ConcreteDecoratorB(cc);\t\tcda.setAddedState(\"this is a\");\t\tcdb.setAddedState(\"this is b\");\t\tcda.operation();\t\tcdb.operation();\t}} 9、 相关模式  Adapter模式：Decorator模式不同于Adapter模式，因为装饰仅改变对象的职责而不改变它的接口；而适配器将给对象一个全新的接口。 Composite模式：可以将装饰视为一个退化的、仅有一个组件的组合。然而，装饰仅给对象添加一些额外的职责——它的目的不在于对象聚集。 Strategy模式：用一个装饰你可以改变对象的外表；而Strategy模式使得你可以改变对象的内核。这是改变对象的两种途径。","title":"设计模式——装饰模式"},{"content":"FLYWEIGHT享元模式 1、 意图 运用共享技术有效地支持大量细粒度的对象。 2、 适用性 在下面情况下可以使用FLYWEIGHT模式 一个应用程序使用了大量的对象。 完全由于使用大量的对象，造成很大的存储开销。 对象的大多数状态都可变为外部状态。 如果删除了对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。 应用程序不依赖与对象标识。由于Flyweight对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。 3、 结构 4、 参与者 Flyweight ——描述一个接口，通过这个接口flyweight可以接受并作用于外部状态。 ConcreteFlyweight ——实现Flyweight接口，并为内部状态（如果有的话）增加存储空间。ConcreteFlyweight对象必须是可共享的。它所存储的状态必须是内部的；即，它必须独立于ConcreteFlyweight对象的场景。 UnsharedConcreteFlyweight ——并非所有的Flyweight子类都需要被共享。Flyweight接口使共享成为可能，但它并不强制共享。在Flyweight对象结构的某些层次，UnsharedConcreteFlyweight对象通常将ConcreteFlyweight对象作为子节点。 FlyweightFactory ——创建并管理flyweight对象。 ——确保合理地共享flyweight。当用户请求一个flyweight时，FlyweightFactory对象提供一个已经创建的实例或者创建一个。 Client ——维持一个对Flyweight的引用。 ——计算或存储一个（多个）flyweight的外部状态。 5、 协作 1）  Flyweight执行时所需的状态必定是内部或外部的。内部状态存储于ConcreteFlyweight对象之中；而外部对象则由Client对象存储或计算。当用户调用Flyweight对象的操作时，将该状态传递给它。 2）  用户不应直接对ConcreteFlyweight类进行实例化，而只能从FlyweightFactory对象得到ConcreteFlyweight对象，这可以保证他们适当地进行共享。 6、 效果 使用Flyweight模式时，传输、查找和/或计算外部状态都会产生运行时的开销，尤其当flyweight原先被存储为内部状态时。然而，空间上的节省抵消了这些开销。共享的Flyweight越多，空间节省越大。节约空间由以下几个元素决定：  因为共享，实例总数减少的数目 对象内部状态的平均数目 外部状态是计算的还是存储的 共享的Flyweight越多，存储节约也就越多。节约量随着共享状态的增多而增大。当对象使用大量的内部及外部状态，并且外部状态是计算出来的而非存储的时候，节约量将达到最大。所以，可以使用两种方法来节约存储：用共享减少内部状态的消耗，用计算时间换取对外步状态的存储。 7、 实现 在实现Flyweight模式时应该注意以下： 1）删除外部状态；该状态的可用性在很大程度上取决于是否容易识别外部状态并将它从共享对象中删除。如果不同种类的外部状态和共享前对象的数目是相同的话，删除外部状态不会降低存储消耗。理想的状况是，外部状态可以由一个单独的对象结构计算得到，且该结构的存储要求非常小。 2）管理共享对象；因为对象是共享的，用户不能直接对它进行实例化，因此FlyweightFactory可以帮助用户查找某个特定的Flyweight对象。FlyweightFactory对象经常使用关联存储帮助用户查找感兴趣的Flyweight。 8、 代码示例 Flyweight： package com.examples.pattern.flyweight;/** * 享元接口，通过这个接口享元可以接受并作用于外部状态 */public interface Flyweight {\tpublic void operation(String extrinsicState);} ConcreteFlyweight： package com.examples.pattern.flyweight;/** * 享元对象 */public class ConcreteFlyweight implements Flyweight {\tprivate String intrinsicState;\t/**\t * 构造方法，传入享元对象的内部状态的数据\t * \t * @param intrinsicState\t */\tpublic ConcreteFlyweight(String intrinsicState) {\t\tthis.intrinsicState = intrinsicState;\t}\t@Override\tpublic void operation(String extrinsicState) {\t\t// 具体的功能处理，可能会用到享元内部、外部状态\t\tSystem.out.println(\"ConcreteFlyweight: \" + extrinsicState);\t}} UnsharedConcreteFlyweight： package com.examples.pattern.flyweight;/** * 不需要共享的Flyweight对象； 通常是将被共享的享元对象作为子节点组合出来的对象。 */public class UnsharedConcreteFlyweight implements Flyweight {\tprivate String allState;\t@Override\tpublic void operation(String extrinsicState) {\t\tSystem.out.println(\"UnsharedConcreteFlyweight: \" + extrinsicState);\t}}FlyweightFactory： package com.examples.pattern.flyweight;import java.util.HashMap;import java.util.Map;/** * 享元工厂 */public class FlyweightFactory {\t/**\t * 缓存多个Flyweight对象\t */\tprivate Map<String, Flyweight> fsMap = new HashMap<String, Flyweight>();\tpublic Flyweight getFlyweight(String key) {\t\t// 1： 先从缓存中查找，是否存在key对应的Flyweight对象\t\tFlyweight f = fsMap.get(key);\t\t// 2: 如果存在，就返回相对的Flyweight对象\t\tif (f == null) {\t\t\t// 3: 如果不存在\t\t\t// 3.1 创建一个新的Flyweight对象\t\t\tf = new ConcreteFlyweight(key);\t\t\t// 3.2把这个新的Flyweight对象添加到缓存中\t\t\tfsMap.put(key, f);\t\t}\t\t// 3.3然后返回这个新的Flyweight对象\t\treturn f;\t}\tpublic int getSize() {\t\treturn fsMap.size();\t}} Client： package com.examples.pattern.flyweight;public class Client {\t/**\t * @param args\t */\tpublic static void main(String[] args) {\t\tFlyweightFactory ff = new FlyweightFactory();\t\tFlyweight fw_1 = ff.getFlyweight(\"fw_1\");\t\tfw_1.operation(\"fw_1\");\t\tFlyweight fw_2 = ff.getFlyweight(\"fw_2\");\t\tfw_2.operation(\"fw_2\");\t\tFlyweight fw_3 = ff.getFlyweight(\"fw_2\");\t\tfw_3.operation(\"fw_2\");\t\tSystem.out.println(ff.getSize());\t}} 9、 相关模式 Flyweight模式通常和Composite模式结合起来，用共享叶节点的有向无环图实现一个逻辑上的层次结构。","title":"设计模式——享元模式"},{"content":"Java语言提供的对观察者模式的支持 　　在Java语言的java.util库里面，提供了一个Observable类以及一个Observer接口，构成Java语言对观察者模式的支持。 　　Observer接口 　　这个接口只定义了一个方法，update()。当被观察者对象的状态发生变化时，这个方法就会被调用。这个方法的实现应当调用每一个被观察者对象的notifyObservers()方法，从而通知所有的观察对象。 图6、java.util提供的Observer接口的类图。 package java.util; public interface Observer { /** * 当被观察的对象发生变化时，这个方法会被调用。 */ void update(Observable o, Object arg); } 代码清单5、java.util.Observer接口的源代码。 　　Observable类 　　被观察者类都是java.util.Observable类的子类。java.util.Observable提供公开的方法支持观察者对象，这些方法中有两个对Observable的子类非常重要：一个是setChanged()，另一个是notifyObservers()。第一个方法setChanged()被调用之后会设置一个内部标记变量，代表被观察者对象的状态发生了变化。第二个是notifyObservers()，这个方法被调用时，会调用所有登记过的观察者对象的update()方法，使这些观察者对象可以更新自己。 　　java.util.Observable类还有其它的一些重要的方法。比如，观察者对象可以调用java.util.Observable类的addObserver()方法，将对象一个一个加入到一个列表上。当有变化时，这个列表可以告诉notifyObservers()方法那些观察者对象需要通知。由于这个列表是私有的，因此java.util.Observable的子对象并不知道观察者对象一直在观察着它们。 图7、Java语言提供的被观察者的类图。 　　被观察者类Observable的源代码： package java.util; public class Observable { private boolean changed = false; private Vector obs; /** *//** 用0个观察者构造一个被观察者。**/ public Observable() { obs = new Vector(); } /** *//** * 将一个观察者加到观察者列表上面。 */ public synchronized void addObserver(Observer o) { if (!obs.contains(o)) { obs.addElement(o); } } /** *//** * 将一个观察者对象从观察者列表上删除。 */ public synchronized void deleteObserver(Observer o) { obs.removeElement(o); } /** *//** * 相当于 notifyObservers(null) */ public void notifyObservers() { notifyObservers(null); } /** *//** * 如果本对象有变化（那时hasChanged 方法会返回true） * 调用本方法通知所有登记在案的观察者，即调用它们的update()方法， * 传入this和arg作为参量。 */ public void notifyObservers(Object arg) { /** *//** * 临时存放当前的观察者的状态。参见备忘录模式。 */ Object[] arrLocal; synchronized (this) { if (!changed) return; arrLocal = obs.toArray(); clearChanged(); } for (int i = arrLocal.length-1; i>=0; i--) ((Observer)arrLocal[i]).update(this, arg); } /** *//** * 将观察者列表清空 */ public synchronized void deleteObservers() { obs.removeAllElements(); } /** *//** * 将“已变化”设为true */ protected synchronized void setChanged() { changed = true; } /** *//** * 将“已变化”重置为false */ protected synchronized void clearChanged() { changed = false; } /** *//** * 探测本对象是否已变化 */ public synchronized boolean hasChanged() { return changed; } /** *//** * 返还被观察对象（即此对象）的观察者总数。 */ public synchronized int countObservers() { return obs.size(); } } 代码清单6、java.util.Observer接口的源代码。 　　这个Observable类代表一个被观察者对象。一个被观察者对象可以有数个观察者对象，一个观察者可以是一个实现Observer接口的对象。在被观察者对象发生变化时，它会调用Observable的notifyObservers方法，此方法调用所有的具体观察者的update()方法，从而使所有的观察者都被通知更新自己。见下面的类图： 图8、使用Java语言提供的对观察者模式的支持。 　　发通知的次序在这里没有指明。Observerable类所提供的缺省实现会按照Observers对象被登记的次序通知它们，但是Observerable类的子类可以改掉这一次序。子类并可以在单独的线程里通知观察者对象；或者在一个公用的线程里按照次序执行。 　　当一个可观察者对象刚刚创立时，它的观察者集合是空的。两个观察者对象在它们的equals()方法返回true时，被认为是两个相等的对象。 　　怎样使用Java对观察者模式的支持 　　为了说明怎样使用Java所提供的对观察者模式的支持，本节给出一个非常简单的例子。在这个例子里，被观察对象叫做Watched，也就是被监视者；而观察者对象叫做Watcher。Watched对象继承自java.util.Obsevable类；而Watcher对象实现了java.util.Observer接口。另外有一个对象Tester，扮演客户端的角色。 　　这个简单的系统的结构如下图所示。 图9、一个使用Observer接口和Observable类的例子。 　　在客户端改变Watched对象的内部状态时，Watched就会通知Watcher采取必要的行动。 package com.javapatterns.observer.watching; import java.util.Observer; public class Tester { static private Watched watched; static private Observer watcher; public static void main(String[] args) { watched = new Watched(); watcher = new Watcher(watched); watched.changeData(\"In C, we create bugs.\"); watched.changeData(\"In Java, we inherit bugs.\"); watched.changeData(\"In Java, we inherit bugs.\"); watched.changeData(\"In Visual Basic, we visualize bugs.\");  } } 　　代码清单7、Tester类的源代码。 package com.javapatterns.observer.watching; import java.util.Observable; public class Watched extends Observable { private String data = \"\"; public String retrieveData() { return data; } public void changeData(String data) { if ( !this.data.equals( data) ) { this.data = data; setChanged(); } notifyObservers(); } } 　　代码清单8、Watched类的源代码。 package com.javapatterns.observer.watching; import java.util.Observable; import java.util.Observer; public class Watcher implements Observer { public Watcher(Watched w) { w.addObserver(this); } public void update( Observable ob, Object arg) { System.out.println(\"Data has been changed to: '\" + ((Watched)ob).retrieveData() + \"'\"); } } 　　代码清单9、Watcher类的源代码。 　　可以看出，虽然客户端将Watched对象的内部状态赋值了四次，但是值的改变只有三次： watched.changeData(\"In C, we create bugs.\"); watched.changeData(\"In Java, we inherit bugs.\"); watched.changeData(\"In Java, we inherit bugs.\"); watched.changeData(\"In Visual Basic, we visualize bugs.\");  　　代码清单10、被观察者的内部状态发生了改变。 　　对应地，Watcher对象汇报了三次改变，下面就是运行时间程序打印出的信息： Data has been changed to: 'In C, we create bugs.' Data has been changed to: 'In Java, we inherit bugs.' Data has been changed to: 'In Visual Basic, we visualize bugs.' 　　代码清单11、运行的结果。 　　菩萨的守瓶龟 　　想当年齐天大圣为解救师傅唐僧，前往南海普陀山请菩萨降伏妖怪红孩儿：“菩萨听说...恨了一声，将手中宝珠净瓶往海心里扑的一掼...只见那海当中，翻波跳浪，钻出个瓶来，原来是一个怪物驮着出来...要知此怪名和姓，兴风作浪恶乌龟。” 　　使用面向对象的语言描述，乌龟便是一个观察者对象，它观察的主题是菩萨。一旦菩萨将净瓶掼到海里，就象征着菩萨作为主题调用了notifyObservers()方法。在西游记中，观察者对象有两个，一个是乌龟，另一个是悟空。悟空的反应在这里暂时不考虑，而乌龟的反应便是将瓶子驮回海岸。 图10、菩萨和菩萨的守瓶乌龟。 　 　　菩萨作为被观察者对象，继承自Observable类；而守瓶乌龟作为观察者，继承自Observer接口；这个模拟系统的实现可以采用Java对观察者模式的支持达成。","title":"Java语言提供的对观察者模式的支持"},{"content":"书接上文，若开车的流程因车而异呢，又该怎么处理呢！这时候我们需要知道顺序了，但是顺序不是我们所能决定的，所以了需要一个参数，来决定开车的操作顺序，因此呢，虚拟方法改为： package mode.test5.impler; import java.util.ArrayList; import java.util.Iterator; import java.util.List; /**  * 开车——抽象类  * @author 张义  *  */ public abstract class DriveCar {  // 顺序  private List list = new ArrayList();  // 打开车门  protected abstract void openDoor();  // 启动引擎  protected abstract void startEngine();  // 踩油门  protected abstract void treadGun();  // 挂档  protected abstract void engageGear();  // 跑  protected abstract void run();  // 停下来  protected abstract void stopCar();  // 开动  模板方法 因为所有的开车动作都相同  public void startCar(){   if(list != null){    for (Iterator iterator = list.iterator(); iterator.hasNext();) {     String str = (String) iterator.next();     if(\"open\".equals(str)){      openDoor();     }else if(\"start\".equals(str)){      startEngine();     }else if(\"tread\".equals(str)){      engageGear();     }else if(\"engage\".equals(str)){      treadGun();     }else if(\"run\".equals(str)){      run();     }else if(\"stop\".equals(str)){      stopCar();     }    }   }  }  public void setSEQ(List list){   this.list = list;  } } 而继承类呢，则不需要发生任何改变，需要把调用客户端改为： package mode.test5; import java.util.ArrayList; import java.util.List; import mode.test5.impl.DriveBMWCar; public class Main {  public static void main(String[] args) {   DriveBMWCar dc1 = new DriveBMWCar();   List list = new ArrayList();   list.add(\"start\");   list.add(\"stop\");   dc1.setSEQ(list);   dc1.startCar();  } } 由此呢，我们可以完成顺序的排列问题，也满足了不同的车型，有不同的操作。但是我们回头想一想这样的需求，如果在来一个人开车呢，又在需要new 一次，如果顺序发生了改变还需要重写List，这样的话比较麻烦。在这种时候呢，我们就需要用到建造者，建造者呢，里面负责建造顺序以及最终的建造结果，用于整合这些逻辑。 由此我们现在需要跑增加一个CarBuilder抽象类，由它来组装各个开车顺序，要什么类型什么顺序的开车模型，都由相关的子类完成，首先编写CarBuilder代码： package mode.test5.impler; import java.util.List; public abstract class CarBuilder {  //建造一个模型，你要给我一个顺序要，就是组装顺序  public abstract void setSequence(List<String> sequence);  //设置完毕顺序后，就可以直接拿到这个模型  public abstract DriveCar getCarModel(); } 再者实现相应的建造着： 宝马车型实现： package mode.test5.impl; import java.util.List; import mode.test5.impler.CarBuilder; import mode.test5.impler.DriveCar; /**  * 宝马车型开车建造者实现类  * @author 张义  *  */ public class BMWCarBuilder extends CarBuilder {  private DriveBMWCar dbmw = new DriveBMWCar();  public DriveCar getCarModel() {   return this.dbmw;  }  public void setSequence(List<String> list) {   this.dbmw.setSEQ(list);  } } 再次实现大众车： package mode.test5.impl; import java.util.List; import mode.test5.impler.CarBuilder; import mode.test5.impler.DriveCar; /**  * 大众车型开车建造者实现类  * @author 张义  *  */ public class VMCarBuilder extends CarBuilder {  private DriveVWCar dvw = new DriveVWCar();  public DriveCar getCarModel() {   return this.dvw;  }  public void setSequence(List<String> list) {   this.dvw.setSEQ(list);  } } 调用建造者类： package mode.test5; import java.util.ArrayList; import mode.test5.impl.DriveVWCar; import mode.test5.impl.VMCarBuilder; /**  * 客户端调用建造者实现类  * @author 张义  *  */ public class Main {  public static void main(String[] args) {   // 开大众车   VMCarBuilder vmb = new VMCarBuilder();   ArrayList<String> list = new ArrayList<String>(); //存放run的顺序   list.add(\"start\"); //启动起来   list.add(\"stop\"); //开了一段就停下来   vmb.setSequence(list);   // 建造   DriveVWCar dvw = (DriveVWCar)vmb.getCarModel();   dvw.startCar();   // 再来一个人，再开   DriveVWCar dvw_new = (DriveVWCar)vmb.getCarModel();   dvw_new.startCar();  } } 到此呢，同样运行顺序的大众车也生产出来了，而且代码比刚开始直接访问开车类简单了很多。如果开车类型固定的话，比如说就那么几种，同样呢，我们可以采用一个导演类，把模式和建造者组合起来，从而达到一个分装固定模型的目的。如下： package mode.test5; import java.util.ArrayList; import java.util.List; import mode.test5.impl.BMWCarBuilder; import mode.test5.impl.DriveBMWCar; import mode.test5.impl.VMCarBuilder; /**  * 导演类  * @author 张义  *  */ public class Director {  // 顺序  private List list = new ArrayList();  private BMWCarBuilder bmwb = new BMWCarBuilder();  private VMCarBuilder vwb = new VMCarBuilder();  /**   * 返回宝马开车教程1   * @return   */  public DriveBMWCar getBMW1(){   // 因为成员变量  要事先清空   this.list.clear();   //执行顺序   this.list.add(\"start\");   this.list.add(\"stop\");   //按照顺序返回一个奔驰车   this.bmwb.setSequence(list);   return (DriveBMWCar)this.bmwb.getCarModel();  }  /**   * 返回宝马开车教程1   * @return   */  public DriveBMWCar getBMW2(){   this.list.clear();   //执行顺序   this.list.add(\"start\");   //按照顺序返回一个奔驰车   this.bmwb.setSequence(list);   return (DriveBMWCar)this.bmwb.getCarModel();  } } 客户端调用：   package mode.test5; import java.util.ArrayList; import mode.test5.impl.DriveVWCar; import mode.test5.impl.VMCarBuilder; /**  * 客户端调用建造者实现类  * @author 张义  *  */ public class Main {  public static void main(String[] args) {   Director d1 = new Director();   d1.getBMW1().startCar();      Director d2 = new Director();   d2.getBMW2().startCar();  } } 总结：以上就是建造者模式的完整实例。   建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 1. 建造者模式的优点 封装性 使用建造者模式可以使客户端不必知道产品内部组成的细节，如例子中我们就不需要关心每一个具体的模型内部是如何实现的，产生的对象类型就是CarModel。 建造者独立，容易扩展 建造者的实现是相互独立的，对系统的扩展非常有利。 便于控制细节风险 由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。 2. 建造者模式的使用场景 相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式。 多个部件或零件,都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以使用该模式。 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式是非常合适。 在对象创建过程中会使用到系统中的一些其它对象，这些对象在产品对象的创建过程中不易得到时，也可以采用建造者模式封装该对象的创建过程。该种场景，只能是一个补偿方法，因为一个对象不容易获得，而在设计阶段竟然没有发觉，而要通过创建者模式柔化创建过程，本身已经违反设计最初目标。  3.在建造者模式中，有如下四个角色： Product 产品类 通常是实现了模板方法模式，也就是有模板方法和基本方法，这个参考上一章节的模板方法模式。在例子中，开车的具体实现就属于产品类。 Builder 抽象建造者 规范产品的组建，一般是由子类实现。在例子中，CarBuilder属于抽象建造者。 ConcreteBuilder 具体建造者 实现抽象类定义的所有方法，并且返回一个组件好的对象。在例子中，BMWCarBuilder和VWCarBuilder就属于具体建造者。 Director 导演 负责安排已有模块的顺序，然后告诉Builder开始建造。","title":"java_23种设计模式之建造者模式"},{"content":"因为该模式有以下部分组成所以 –过滤器Filter –数据源Source –数据池Sink –管道Pipe   所以首先来写filter，但是在写filter之前必须有pipe也就是管道，所以先来定义管道 pipe类 package ch03.pipesfilteres; import java.util.ArrayDeque; public class Pipe {  private ArrayDeque<Packet> packets = new ArrayDeque<Packet>();    public void write(Packet packet) {   packets.addFirst(packet);   //System.out.println(\"\"+packet+\" is written into pipe.\");     }  public int size() {   return packets.size();  }  public Packet read() throws EmptyPipeException {   if (size() == 0) {    throw new EmptyPipeException();   }   Packet p = packets.getLast();   packets.pollLast();   return p;  } }     写完pipe之后，就可以写filter类了 首先是一个抽象类 package ch03.pipesfilteres; public abstract class Filter {  protected Pipe input;  protected Pipe output;    public Filter(Pipe in, Pipe out) {   input=in;   output=out;  }    public abstract void process(); } 他的实现：   package ch03.pipesfilteres; public class FilterImpl extends Filter {  public FilterImpl(Pipe in,Pipe out) {   super(in,out);  }  public void customNotify() {   process();  }  @Override  public void process() {   while (input.size() > 0) {    try {     Packet packet=input.read();//     //packet.setContent(\"\");     output.write(packet);     System.out.println(\"已经将\"+packet+\"写入到了pipe2\");         }  catch (EmptyPipeException e) {     // TODO Auto-generated catch block     e.printStackTrace();    }   }  } }   写完这个之后就要把pipe放入数据source中，那么source是如何实现的呢？可想而知，其接受pipe   package ch03.pipesfilteres; public class DataSource extends Filter{     public DataSource(Pipe out) {   super(null,out);    }  @Override  public void process() {   for(int i=1;i<5;i++) {    System.out.println(\"DataSource: packet(\"+i+\") is created.\");    Packet p=new Packet(i);    p.setContent(\"第\"+i+\"已经写入pipe\");    System.out.println(\"第\"+i+\"已经写入pipe\");    output.write(p);           }     } } filter写完之后就要开始完成sink的编写了，也就是要将经过filer处理过的pipe输入到终点 package ch03.pipesfilteres; import java.util.ArrayDeque; public class DataSink extends Filter{  private FilterImpl observer;    protected ArrayDeque<Packet> received = new ArrayDeque<Packet>();    public DataSink(Pipe in) {   super(in,null);   observer = null;  }  public int size() {   return received.size();  }    public Packet nextPacket() {   Packet p = received.getLast();   received.pollLast();   return p;  }  public void customNotify() {   try {    while(input.size() > 0) {     received.addFirst(input.read());    }   } catch (EmptyPipeException e) {    System.err.println(\" empty pipe. \");   }   if(observer != null)    observer.customNotify();  }  public void setObserver(FilterImpl observer) {   this.observer = observer;  }  public FilterImpl getObserver() {   return observer;  }  @Override  public void process() {   try {    int i=0;    for(i=0;i<4;i++){     System.out.println(input.read()+\"已经进入了数据池\");     }       } catch (EmptyPipeException e) {    e.printStackTrace();   }     } } 这些写完之后就是其他一些类的编写了 package ch03.pipesfilteres; public class Packet {  //标号  private int pno = -1;  //标号对应的内容  private String content;  public Packet() {  }  public Packet(int no) {   pno = no;  }  public  void setContent(String c) {   content=c;  }  public String toString() {   return \"Packet(\" + pno + \"):\"+content;  } } package ch03.pipesfilteres; public class EmptyPipeException extends Exception { } package ch03.pipesfilteres; public class NoOutputPipeException extends Exception {   } 最后就可以编写一个测试类来测试了 package ch03.pipesfilteres; public class TestPipes {  public static void main(String[] args) {     /** Instantiate our pattern blueprint classes. */      Pipe pipe1 = new Pipe();     Pipe pipe2= new Pipe();   DataSource source = new DataSource(pipe1);   source.process();   FilterImpl filter=new FilterImpl(pipe1,pipe2);   filter.process();   DataSink sink = new DataSink(pipe2);   sink.process();          } }   得到以下的运行结果 DataSource: packet(1) is created. 第1已经写入pipe DataSource: packet(2) is created. 第2已经写入pipe DataSource: packet(3) is created. 第3已经写入pipe DataSource: packet(4) is created. 第4已经写入pipe 已经将Packet(1):第1已经写入pipe写入到了pipe2 已经将Packet(2):第2已经写入pipe写入到了pipe2 已经将Packet(3):第3已经写入pipe写入到了pipe2 已经将Packet(4):第4已经写入pipe写入到了pipe2 Packet(1):第1已经写入pipe已经进入了数据池 Packet(2):第2已经写入pipe已经进入了数据池 Packet(3):第3已经写入pipe已经进入了数据池 Packet(4):第4已经写入pipe已经进入了数据池 目录结构如下：     代码在我的资源中，如果需要请下载      ","title":"管道过滤器的实现---java语言"},{"content":"管道-过滤器体系结构模式为处理数据流的系统提供了一种结构 –工业中的流处理系统-水处理系统   –整个系统分为多个处理单元，由管道将多个处理单元连接起来；管道用来输送流，处理单元用于流的加工和处理；流从一个处理单元出口输出， 经过管道输送到下一个处理单元的入口，经过每个处理单元的加工处理，最后由输出管道输出到使用地。   •软件系统中管道-过滤器结构的应用—操作系统 –UNIX系统中，可以将某个命令的标准输出与另一命令的标准输入相连。 •语法：命令1 | 命令2 | 命令3 | … | 命令N •例如：ls –l | more –Windows •Dir  *.exe | sort > exe.txt   –软件系统中管道-过滤器结构的应用—传统的语言编译器     •结构描述 –数据流的处理过程分成几个顺序执行的处理步骤，每个处理步骤由一个过滤器组件实现。每个过滤器组件有一组输入和一组输出。 –每个过滤器组件都会对输入的数据采用渐进方式进行局部处理，一个过滤器组件的输出是下一个过滤器的输入。 –系统的初始数据流由数据源（DataSource）输入，系统的处理结果数据流输出到数据池（Data Sink）。 –数据源、过滤器和数据池由管道pipe顺序连接起来，每个管道承担相邻过滤器之间的数据传输。     •主要组成： –过滤器Filter –数据源Source –数据池Sink –管道Pipe   •过滤器Filter –封装数据处理功能的功能单元，是管道-过滤器结构中的主要处理单元。 –每个过滤器组件有一组输入和一组输出，从连接它的输入管道中读取数据，数据经过加工处理，输出到连接它的输出管道。   •过滤器Filter –3种激活方式 •pull拉出式 –后续组件从当前过滤器中拉出数据。 •push推入式 –前邻组件向当前过滤器推入数据。 •主动过滤器ActiveFilter –激活状态下，以循环方式不断从前邻组件中拉出数据，并向后续组件推入数据。   •管道Pipe –管道是相邻过滤器之间的连接。 –连接两个主动过滤器的管道是一个先进先出的缓冲器，用以完成同步。 –连接被动过滤器的管道可以通过对被动过滤器的调用来实现。   •数据源DataSource –数据源是系统的输入。向系统提供相同结构或类型的数据序列。如标准输入流、文本文件或传感器采集的数据等。 –数据源可以主动把数据推入过滤器，也可以在过滤器需要数据时被动地提供数据。   •数据池DataSink –汇集系统处理的结果数据。如文本文件、数据库、标准输出等。 –主动数据池把过滤器的结果拉出来，而被动数据池等待过滤器把结果推入进来。     •实现的主要步骤 1.把系统任务分成几个独立的处理阶段。 2.定义沿着每个管道传输的数据格式。 3.决定管道的连接。 4.设计和实现过滤器。 5.设计出错处理。 6.建立、处理流水线。     •步骤1：把系统任务分成几个独立的处理阶段。 –每个处理阶段完成一个独立的处理功能。 –每个处理阶段必须只依赖其前一阶段的输出。   •步骤2：定义沿着每个管道传输的数据格式。 –如果整个系统定义统一的数据格式，则使得过滤器组件的重组变得容易，系统可以获取极大的灵活性。但是，单一的数据格式在某些情况下，在不同的过滤器组件择偶观需要频繁进行格式转换，大大降低了系统的数据处理效率。 –如果需要选择不同的数据格式，又需要一定的灵活性，则需要在系统中建立专门的格式转换过滤器组件。 •步骤3：决定管道的连接。 –首先，需要确定把过滤器作为被动过滤器还是主动过滤器来实现。 –被动过滤器的连接简单，一般直接使用调用来拉出或推入数据即可。需要注意的是，重组和替换过滤器组件时必须设计代码修改，另外这种过滤器难以独立开发和测试。 –使用主动过滤器，可以借助管道的同步化分离机制提高系统的灵活性。如果所有的管道都使用这种方式，系统的过滤器可以做到随意重组。   •步骤4：设计和实现过滤器。 –过滤器的设计必须同时考虑需要完成的任务，和与它相邻的管道。 •如果是被动过滤器，拉入数据可以通过函数（function）实现，推出数据可以通过过程（process）实现。如果是主动过滤器，可以实现为线程（Thread）。 •在过程1之间和在地址空间之间的数据复制的需要，会影响到系统的性能；因此，管道缓冲区的大小是一个值得考虑的附加参数。在多个关联转换和数据复制总开销一定情况下，使用小的主动过滤器组件，可以获得较高的灵活性。 •为了方便重用过滤器组件，需要控制过滤器组件行为时，可以通过下列常用方式将参数传递给相应的过滤器组件： –在命令行传递参数。 –在启动过滤器组件时，让过滤器使用可以访问得到的全局环境或者仓库2，这些可以通过操作系统、配置文件或者shell程序来支持实现。 •设计和实现过滤器时，要注意灵活性和易用性的均衡，一般一个过滤器只需做好一件事即可。   •步骤5：设计出错处理。 –管线（pipeline）上的组件不能共享全局状态，但错误可以探测到。 •例如，在unix系统中，为错误消息定义了一个特殊的输出通道stderr1;但是，当多个过滤器组件并行运行时，stderr会以不可预测的方式混合来自不同过滤器组件的错误信息。 –错误处理实现比较困难。 •如果一个过滤器组件在输入数据中探测到错误，它可以忽略后面输入的数据，直到明确的分隔符出现为止。因此，当可能会有不可预料的输入数据时，如果允许容忍不精确的结果，这种错误处理的方法还是很有效的。 •重启系统，希望继续运行 à再同步问题 à 添加固定标识。 •步骤6：建立处理流水线 –如果系统只需处理单一任务，可以用一个主程序来创建管道流水线，由主程序调用主动过滤器启动处理过程。 –增加灵活性： •通过提供shell程序或用户终端工具，使用它们从你的过滤器组件集中装配出不同的流水线。 •如果允许中间处理结果存放到文件中，并支持把文件作为后续组件的输入，这样可以支持流水线的增量式开发。   •如果系统中的过滤器严格限制为单输入、单输出，则这种结构的系统被称为管线或流水线（pipeline）。 •如果允许过滤器的输入或输出多于一个，这种系统的结构可以用一个有向图表示。这种系统的结构需要经过严格的理论分析，以保证系统可以终止和输出正确结果。 •在过滤器之间使用命名的管道（如文件）传送数据，这种系统称为有名管道。有名管道限制过滤器之间数据传送只能在命名的管道中，给系统的维护和重组带来了困难。   •优点 –系统易于重组，增加了系统的灵活性。 –系统易于更新、升级和维护。 –过滤器组件易于重用。 –并行处理提高了系统的效率。 –支持快速原型系统的设计和实现。 –系统具有清晰的拓扑结构，方便进行某些系统性能的分析。   •缺点 –管道-过滤器结构会经常导致数据的批处理方式。 –管道-过滤器结构不适合处理交互式应用要求。 –数据转换增加了系统的开销和复杂性。 –共享状态信息代价高且不灵活。 –用并行方式获得高效率往往不可行。 –难于进行错误处理。    ","title":"管道过滤器"},{"content":"    第1章 软件体系结构基本概念 1.1软件体系结构基本概念 1.2软件体系结构风格、模式和框架 1.3软件结构的基本元素和连接 1.4软件体系结构设计的基本原则   1.1 软件体系结构的基本概念 软件体系结构是软件工程的重要研究领域，软件体系结构并没有统一的定义。 90年代开始，很多专家学者对软件体系结构引起广泛关注，综合软件体系结构的定义，比较权威性的论述是: 总体组织 全局控制 通讯、同步、协议 设计元素的功能 物理分布和集成     软件体系结构要点： •软件体系结构是软件设计过程的一个层面，是相对独立的、有价值的软件设计方法的总结，可作为软件开发指导性的策略和途径。 •强调设计过程，而非分析的过程。分析的目标是理解和表示，设计的目标是实现。 •非用户的观点及非功能的观点。对于用户，结构是软件系统功能的组合。对于设计者，结构是为特定目标而设立的软件成分以及成分之间的关系。   1.2 软件体系结构风格、模式和框架 •软件体系结构风格(Architecture Styles)  风格是表达特定系统元素和组织方式的通用范例（idiomaticparadigm）。软件体系结构风格，反映众多系统共有结构的习惯用法和语义，表述系统的静态结构方式，强调软件元素的组织形式和通常用法。 •软件设计模式（DesignPattern)  设计模式是软件问题高效和成熟的设计模板（pattern)，模板包含了固有的问题的处理逻辑，强调处理逻辑采用方式的直接复用。 •软件应用框架(Application Framework)  框架是待实例化的、可复用的大粒度部件结构。框架面向不同规模的应用问题，是通用的结构。强调针对实际问题和通用结构。   1.3软件结构的基本元素和连接 软件结构的表示从低层到高层，高层软件结构是建立在基础结构之上的。 软件构成的基础结构包括： ①数据类型结构 ②控制流连接结构 ③中断触发连接结构 ④层次结构   ①数据类型结构 数据类型是最基本的软件结构元素，是描述复杂算法和软件结构的基础，即数据结构。 数据类型包括： 基本数据类型 抽象数据类型 ②控制流连接结构 Ø控制流结构直接对应程序结构  包括： •条件连接 •循环连接 •控制转向连接 Ø控制流连接方式 进程中的控制连接（内部调用）进程之间的连接 同一机器空间  链询调用方式分 析调用方式 不同机器空间（远程过程调用） ④软件的层次结构 层次结构是分析和解决问题普遍适用的方法 •单项依赖层次结构： 下层仅向相邻的上层提供支持，上层依赖相邻的下层被建造 •开放式层次结构： 使用及支持关系不仅限制在相邻的层次之间   1.4软件体系结构设计的基本原则 在大量的软件开发实践中，对于软件结构的设计有被普遍性采用的原则，这些原则和策略多年来一直被广泛地运用着。它们独立于具体的软件开发方法。 基本原则包括：  •抽象  •分而治之  •信息隐蔽      •模块化 •高内聚和低耦合 •关注点分离 •策略和实现分离 •接口和实现分离   Ø抽象的原则 •抽象： 人们认识复杂事物的基本方法。抽象的实质是突出表现事物的主要特征和属性，忽略细节部分；并且，运用这些特征和属性，提取具有普遍意义的事物行为。 •软件设计中的抽象： 数据抽象：描述特定数据对象的属性集合 过程抽象：特定操作过程命名的操作序列 控制抽象：隐含内部细节的控制逻辑             Ø分而治之原则 将大的问题分解，分别处理分解的局部问题，会降低问题的复杂性和难度。 软件设计中运用的分解包括： •纵向分解： 按照事务的过程方式分解，将整体问题分解成为多层，每层完成同一过程的各项处理，并提取规范统一形式的接口，以提供对下层（下一过程）的支持。 •横向分解： 在每一层面，将问题分成多项独立的处理部分，它们原则上不要直接的联系，而是通过集中的控制。   Ø信息隐蔽的原则 •局部化设计： 处理中的所有信息和操作被限制在局部过程中，尽量减少外部的直接接触与共享，提高独立性，减小相互的耦合性。 •封装设计： 将处理过程尽量隐蔽，使外界只了解其简单、统一的可访问形式。以减少外界可能的错误干扰和破坏。   Ø模块化的原则 模块：可被独立命名、具有独立作用的软件成分 •模块可分解：整体问题可被分解成多个模块来解决 •模块可组装：现有的模块可被组装用以解决问题 •模块可理解：模块可作为独立作用的成分被理解 •模块连续性好：对系统的修改只作用于单个的模块 •模块保护性好：模块出现异常的影响，仅在模块内部   Ø高内聚和低耦合原则 •内聚性： 指软件成份内部各处理单元的关系程度。能做到每个成分都有必然关系，缺一不可的紧密程度是最好的内聚形式。 •耦合性： 指软件成份之间的关系特性。软件成份之间应尽量做到没有直接关系，使其保持相对独立、松散耦合的关系会使未来的修改、复用简单，出错带来的影响小。   常见的耦合形式 内容耦合：一个软件成份直接修改另一个软件成份的内容 公共耦合：多个软件成份需要处理同一个外部的公共数据 控制耦合：软件成份的动作依赖于接收的控制信号 标记耦合：软件成份的接口参数具有一个复杂的内部结构 数据耦合：软件成份之间仅通过简单类型的形式参数传递   常见的内聚形式 偶然内聚：将没有直接关系，只是分散在多处的成分合起来 逻辑内聚：将仅是逻辑相关的处理成分合起来 时间内聚：将需在同一时间执行并无直接关系的处理成分合起来 过程内聚：将过程顺序相关的处理成分合起来 通讯内聚：将需要对同一个外部数据操作的处理成分合起来 顺序内聚：将两个具有输入输出顺序关系的软件成份合起来 功能内聚：保证每个成分只完成单一的功能   Ø关注点分离原则 •关注点： 关注点是软件系统中特别需要考虑的多变部分。例如，软件成分的执行会受到运行环境、设备条件，以及通信设施等的制约和限制，为了适应不同的运行环境和条件，需要进行必要的参数调整和驱动配置。为此进行的这部分设计和开发，即是所谓的关注点。 •关注点分离设计： 软件系统中涉及关注点的成分应该与非关注点的成分分为相互独立的部分，这样的设计会使未来的系统容易配置，实现机器无关性。   Ø策略和实现分离原则 •策略： 策略是指软件中用于处理选择控制的决策成分。通过上下文相关的决策分析、信息语义解释分析、参数选择等进行判断，以决定怎样地具体数据加工和功能实现。 •实现： 实现是指软件系统中有规范步骤及完整执行算法的成分 •策略和实现分离的设计： 通常，决策部分是异变的成分，而实现部分相对稳定，并可多次复用。将策略成分和实现成分分别设计成独立的部分，使系统维护的范围减小，以提高系统的维护性和复用性。   Ø接口和实现分离原则 •接口 接口是软件成分对外规范形式的、可访问的操作集合，提供软件成分的功能及使用方式。一个软件成分可以不只一个接口，每个接口提供不同的一组相关的操作。 •实现 实现是软件成分外部不可见的操作执行部分 •接口和实现分离的设计 为了达到软件成分的高复用，为适应多种形式的访问，可采用分设多种接口来实现。这就需要采用接口和实现独立设计的方式，以提高系统的可移植性和复用性。","title":"软件体系结构课程"},{"content":"设计模式： 是面向对象的软件开发经验的总结，其中包含了软件设计中很多问题的解决方案和设计思路，是可直接利用的程序结构。 按照以下要点讨论设计模： l模式名称：表达设计思想的简单名字 l设计意图：针对的问题和解决问题的思路 l实现效果：达到的实际效果及作用 l技术途径：采用的技术方法和策略 设计模式分类： ①构造式：涉及对象创建过程的模式 ②结构式：涉及对象类组合的模式 ③行为式：涉及对象之间交互操作的模式 4.2构造型设计模式 •构造型设计模式，提供在系统中创建独立对象、创建组合对象，创建系列对象的基本方法。 •构造型模式中，始终围绕的问题： Ø将结构不同、功能不同的“产品”对象，用灵活的配置方式来创建，以适应未来的变化。 Ø怎样创建对象的问题，在何时创建？由谁来创建？ （1）抽象工厂（Abstract Factory）模式 将系列产品的制造责任和部件封装起来,因为系列产品有着相同的构件部分,但每个系列产品的部件又有所不同。 应用可根据不同系列的产品需求，组织不同产品部件对象的创建，完成系列产品的制造。 利用多态性的动态绑定机制： ·用抽象类描述系列产品的制造部件； ·用继承来描述具体产品的实现； ·在应用中利用抽象类的各种操作设计系列产品的接口函数； ·在用应用中通过接口函数实现不同产品的统一建造过程。 AbstractFactory适用的软件问题： •希望系统可以由不确定的系列产品来配置，仅提供一个配置的框架 •强调一系列相关对象的预先存在，以便进行组装和使用 •使系统能适由于对象不同、组合不同，以及表示不同的多种情况 •通常是与工厂方法配合使用的 （2）工厂方法（Factory Method）模式 对相同结构的不同应用实体，需要向不同的实体发送相应的操作请求，以完成各自不同的同一形式的操作。 在抽象类中利用的工厂方法由子类具体化，以得到结构相同的不同的对象实体。这样，可以向不同的实体发出消息，灵活地实现同类结构的不同实体的操作。 •在类的内部创建并得到对象，可以将类的某些职责委托给一个独立的类，用以扩充类的某种操作，达到平行扩展效果。 建立应用操作类与需要的对象实体类关联，用工厂方法创建并返回实际的对象实体，然后可以利用该实体对象完成必要的操作请求。 FactoryMethod适用的软件问题： •当一个类不确定它所必须创建的对象的类时 •希望由子类来指定所创建的对象时 •当希望由子类来代理完成局部功能时，将创建对象的职责委托给某个子类。 （3）转换器/生成器（Converter/Builder）模式 将不同对象的不同操作以同样的过程统一起来。 引导器通过关联Builder，完成统一的构造过程。 Builder子类中的各项操作，无论数量和内容都可能各不相同。 •在应用中定义所需要的引导器,用以完成统一步骤的处理,并用关联的构造器实例来完成相应的处理； •根据需要从构造器继承子类来实现不同的处理方式。 Builder适用的软件问题： •当需要将对象的某些复杂处理过程或算法，与他的创建和组装方式相互独立时 •当构造过程必须根据被构造的对象而有所不同时 对构造的三个模式的比较： 抽象工厂模式，定义一个创建系列产品的类，可根据需要定义相同系列的具体产品类，以适应需求的变化。 生成器模式，为解决系列产品的构造过程相同，但系列中的具体产品其部件成分可能不同。 工厂方法模式，针对产品的不可预定情况，用一个方法得到某个具体产品的实体，以完成不同产品的相同形式操作。 通常情况下，在Abstract Factory、Builder以及Factory Method是相互结合使用的。 4.3 结构式设计模式 结构型设计模式，涉及如何组织对象类，成为适用的更大结构问题。 　结构型设计模式，主要针对希望灵活地实现新的功能的方法。 　结构型设计模式有很强的相似性，应该注意区分它们的设计意图，了解各自的优势和必须付出的代价。 （1）适配器（Adapter）模式 为复用已有的成分，将不适应的接口转换成应用需要的另一个接口。 •用Adapter与原有的不同的Adaptee协同工作 •使原来的目标请求方法适配成已有的对象方法。 •Adapter模式是为解决两个已有接口之间的不匹配问题。 当需要不加修改地利用已有类的对象协同工作时，即协同两个不兼容的类时，可采用Adapter模式。 Adapter适用的软件问题： •需要使用一个已经存在的类，而它的接口不符合需求 •需要创建一个可复用的类，该类可以与其它不相关或不可预见的类协同工作（不相关或不可预见表明接口不兼容） •需要使用一些已经存在的子类，但不可能对其一一匹配，可以适配它们的父类接口 （2）桥（Bridge）模式 未来的需求，能应对操作接口和相关实现的操作独立演变。 分离与实现相关的部分，因为它们虽然有相同的操作，但却有不同的操作处理情况。用关联及多态机制建造稳定的接口，执行多种情况的不同实现。 •将与实现环境相关操作部分独立 •对外隐藏实现细节，实现应用透明访问 •目的是为提供稳定的操作接口。将一般操作接口与实现环境相关的操作接口进行桥接，相关实现部分可能不同，替换实现而不用改变接口。当然修改操作接口也不会影响相关实现的操作部分。 Bridge适用的软件问题： •希望在抽象类和它的实现部分之间有一个固定的绑定关系 •需要抽象类和它的实现部分分别加以扩充 •希望实现部分的修改对外不产生影响。即客户代码不必重新编译 •希望在客户不知道的情况下，多个对象间共享实现 （3）代理（Proxy）模式 当直接访问某实体对象不合需求，又不希望对其直接修改，这样，可以为该实体提供一个替代者并采用相同的操作形式访问它，已完成某些必要操作，之后再由代理向主体转发实际的操作请求。 •远程代理：可隐藏实际主体存在的不同地址空间 •虚代理：可以实现优化处理，根据要求创建对象 •保护代理：在访问实际主体时附加必要的处理。   Proxy模式由实际主体定义关键的功能，而代理在完成必要的操作后，转发实际的访问请求，它强调这种固定的关系。 Proxy适用的软件问题： •需要用通用或复杂的对象的引用代替简单的引用，例如：远程代理、虚代理、保护代理、只能引导 •对指针实际对象引用的计数 •当第一次引用一个持久对象时，需要将其装入内存 •在访问一个实际对象前，检查是否锁定了它，以确保其它对象不能改变它 （4）装饰（Decorator）模式 将装饰器嵌入组件，用以完成对组件的必要的多项操作，这样可以回避使用多重继承解决方案带来的复杂性。 •使用组件接口，为给定的对象类动态添加操作 •通过装饰器的关联，使继承的每个操作责任类能够既执行自身的操作，又可转接执行给定对象类的操作。 Decorator适用的软件问题： •在不影响其它对象的情况下，以动态方式给对象添加职责 •需要处理可以撤销的职责 •当不能采用生成子类方式进行系统扩充时。 两种情况不能采用生成子类来扩充系统： 1）为支持大量独立扩充，而产生大量子类 2）类定义被隐藏或不能用于生成子类 ‘ 4.4 行为式设计模式 •行为型设计模式主要针对算法和对象之间的职责分配问题。 •行为型设计模式不仅描述类或对象的结构模式，还要描述类或对象之间的通信模式。 •对象之间的通信联系方式，反映了运行时难以跟踪的复杂的控制流。 •行为型设计模式的基本策略是封装行为。 （1）责任链（Chain Responsibility）模式 使请求和接收之间形成松散耦合关系。对象之间连成一条链，使对象沿着这条链传递请求，直到有一个对象处理它。这样，每个对象都有机会处理请求。 •降低耦合。请求对象不用知道哪个对象处理请求，链中的对象也不用知道链的结构。 •提高灵活性。可以方便简单地对链进行动态增加或改变处理责任。 •代价是效率问题，以及并不保证请求一定能被接收处理。 ChainResponsibility适用的软件问题： •有多个对象处理一个请求，可在运行时自动确定由哪个对象来处理该请求 •在不明确指定接收者的情况下，向多个对象中的某一个提交请求 •可处理动态指定的一个请求的对象集合 （2）观察者（Observer）模式结构 针对对象之间的一对多关系，当一个对象的状态发生变化时，所有依赖于它的对象都得到通知并被自动更新。这种模式起源于经典的MVC模式，也叫（publish/subscribe）发布/订阅模式。 •当目标发生变化时，观察者与目标的状态产生不一致，目标需要通知各个观察者； •当观察者得到改变的通知后，向目标对象发出查询信息请求，用得到的查询信息使自己与目标对象状态保持一致。 •可独立改变目标和观察者，可单独复用目标对象及观察者对象。 •支持广播通信，目标发送通知不需要指定接收者，通知被自动广播给所有已向目标对象登记了的观察者，对于是否处理通知，完全取决与观察者，观察者的自由度很高。 •如果观察者之间存在相关性，则存在意外的、不该更新的操作，必要时需要更复杂的约束条件和协议。 Observer适用的软件问题： •当一个抽象模型的两个方面，一个依赖于另一个时，将二者封装在独立对象中，以使它们可以各自独立改变和复用 •当对一个对象的改变需要通知改变其它对象，而不知道具体有多少对象有待改变 •当一个对象必须通知其它对象，而又不确定其他对象是谁，即不希望它们是紧密耦合的 （3）状态模式 •将与特定状态相关的行为局部化，将不同的行为分割开，每个特定状态所相关的行为被封装在一个独立的类中，这样，可以通过定义新的子类，来增加状态的方式转换。 •使状态转换显式化，对不同的状态设立独立的对象，使状态转换明确。同时，由于状态转换操作的原子性，可保证状态的一致性。 将对象的状态作为一个对象类，封装状态类的行为，当对象的状态改变时，行为随之改变。 （4）循环器（Iterater）模式 提供顺序访问聚合Aggregate对象（如：列表对象）的循环器超类，用继承方式封装不同聚合对象的不同遍历操作。每个聚合对象，都可以执行创建循环器的操作，并带着指向自身的指针作为操作的主体。 •每个不同的具体循环器，支持以不同的方式遍历聚合的实体群。 •循环器可简化聚合的操作接口，因为有了循环器的遍历操作接口，不再需要聚合操作接口了。 •可以在同一个聚合上完成多种的遍历操作。 （5）中介（Mediator）模式 用中介对象来封装同僚对象之间的交互行为，它使他们之间不需要显式地相互引用，构成松散耦合，可独立地改变它们之间的交互。 •将分布于多个对象间的行为形成统一的行为。 •各同僚对象实现解耦，可独立改变，并可复用Colleague和Mediator •使多对多协议简化为一对多协议，关系易于理解和维护 •交互的复杂性集中于中介者。 （6）策略（Strategy）模式 把一系列同类的算法封装起来，使算法独立于应用，对同类算法的利用灵活可变。 •策略Strategy类提供了可重用的算法或行为。 •将算法或行为封装在Strategy类中，可以独立于Context改变它。 在三种类型的设计模式中，似乎有很多相似的模式。 了解模式之间的差异非常重要，因为它们针对的是面向对象设计过程中，一些特定的、经常发生的问题，给出了相应解决问题的方法和途径。      模式总是相互结合使用的，当在设计中需要权衡利弊、决定取舍时，了解多个模式，并能准确地区分它们，可以提供更大的设计空间和更多的选择余地。 • Adapter模式主要是为了解决两个已有接口之间的不匹配问题。它不去考虑接口是怎样实现的，也不考虑重新设计某个类，只是将已有类的对象不加修改地利用起来，协同工作。 • Bridge模式的主要目的是为提供稳定的接口。对接口与对应的实现部分进行桥接。对应的实现部分可能有多个，修改实现而不用改变接口。当然修改接口也不会影响实现。    这样，在选择采用模式时，当需要协同两个不兼容的类时，采用Adapter模式；当接口和实现可能会独立演变时，采用Bridge模式 Proxy模式的目的是，当直接访问一个实体不方便或不合需求时，为该实体提供一个替代者。 Proxy模式构成一个对象，并为应用提供一致的接口，但不能动态地添加或取消某种属性。 Proxy模式中，由实体定义关键的功能，而Proxy仅提供对实体的访问，它强调一种固定的关系，因此这种关系可以静态表达。    行为是程序中最有可能改变的因素。封状行为，为避免对象中的不定因素成为不可分割的部分，封装包括两种：    •封装某种行为特征的新对象    •封装某种行为特征的已有的对象 Strategy封装算法或行为 State封装状态相关的行为 Mediator封装对象之间的协议 Iterator封装访问和遍历的聚集对象 Observer与 Mediator模式的区别： • Observer引入观察者和目标的相互协助来维持约束。一个目标可以有多个观察者，一个观察者也能够成为目标被观察。观察者和目标创建后立即被连接起来，需要知道它们之间的连接方式。观察者和目标是松散耦合。 • Mediator的目标是集中维护一个整体的约束。它使信息流简单，容易理解，不需要知道目标间的连接方式    合作的对象之间直接引用，会使它们相互依赖。这给系统的分层和重用带来困难。Observer、Mediator和Chain of Responsibility 模式，都涉及了将发送和接收解耦的问题。它们使用了不同的方式，有各自的权衡考虑。 • Observer观察者模式：通过定义一个接口来通知目标发生变化，使发送者和接收者解耦，它是为处理变化而考虑的。 • Mediator中介者模式：使对象通过中介对象间接相互引用，从而达到解耦。中介为各Colleague对象请求提供路由，采用分发策略。它是为不限定请求操作的数目而考虑的。 •责任链模式：通过沿着一个潜在的接收者链传递请求，这样，使发送者和接收者解耦。责任链也需要分发策略。它更多地考虑接收者和发送者的变化和扩充。","title":"每种设计模式的特点"},{"content":"我们看一下模板方法模式的定义：一个操作中算法的骨架，而将这些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。 具体适应情况如下： 例如在学开车过程中，我们都知道应该打开车门、启动引擎、挂档、踩油门、车开动。如果一个新开车的人，不知道这些步骤，则我们需要按照操作顺序写上这些步骤，然后每完成一步，去看一下步骤，最终会完成车的开动。而不同的车，步骤虽然一样，但是具体的实现还是不同的。这种时候呢，我们就需要使用模板方法了。 所以上面的情况可以描述为： 把按照顺序写上的这些步骤写成一个超类，在上面声明一些子类必须实现的方法（抽象方法），而在超类中不需实现，再定义一个方法来安排各个操作的步骤顺序，然后在创建一些子类来继承父类，在这些子类中必须实现超类的方法（学员必须按照要求进行步骤的具体操作的学习）,各个子类也不必再重新定义一个方法来安排整个制作过程，因为可以利用默认从超类继承的制作过程方法。 下面我给出具体的java代码实现： 1.package mode.test4; /**  * 开车——抽象类  * @author 张义  *  */ public abstract class DriveCar { // 打开车门 public abstract void openDoor(); // 启动引擎 public abstract void startEngine(); // 踩油门 public abstract void treadGun(); // 挂档 public abstract void engageGear(); // 跑 public abstract void run(); // 停下来 public abstract void stopCar(); // 开动  模板方法 因为所有的开车动作都相同 public void startCar(){ openDoor(); startEngine(); engageGear(); treadGun(); run(); stopCar(); } } 2.package mode.test4.impl;   import mode.test4.DriveCar; /**  * 开大众车——开车具体实现  * @author 张义  *  */ public class DriveVWCar extends DriveCar {   public void engageGear() { System.out.println(\"大众车挂档\"); }   public void openDoor() { System.out.println(\"大众车打开车门\"); }   public void run() { System.out.println(\"大众车跑了起来\"); }   public void startEngine() { System.out.println(\"大众车启动引擎\"); }   public void stopCar() { System.out.println(\"大众车停车\"); }   public void treadGun() { System.out.println(\"大众车踩油门\"); } } 3.package mode.test4.impl;   import mode.test4.DriveCar; /**  * 开宝马车——开车具体实现  * @author 张义  *  */ public class DriveBMWCar extends DriveCar { public void engageGear() { System.out.println(\"宝马车挂档\"); } public void openDoor() { System.out.println(\"宝马车打开车门\"); }  public void run() { System.out.println(\"宝马车跑了起来\"); }  public void startEngine() { System.out.println(\"宝马车启动引擎\"); } public void stopCar() { System.out.println(\"宝马车停车\"); } public void treadGun() { System.out.println(\"宝马车踩油门\"); }} 4.package mode.test4; import mode.test4.impl.DriveBMWCar; import mode.test4.impl.DriveVWCar;  /**  * 调用客户端  * @author 张义  *  */ public class Main { public static void main(String[] args) { DriveBMWCardc1 = new DriveBMWCar(); dc1.startCar();  DriveVWCar dc2 = new DriveVWCar(); dc2.startCar(); }} 以上代码的客户调用时，只需要知道最终的方法即可，具体的操作不在与我客户端相关联。所以在抽象类以及实现类中，其中的各个操作方法可以改为protected类型。 优点：利用多态来实现代码复用","title":"java_23种设计模式之模板方法模式"},{"content":"在展开讨论前，我们先来回顾下什么是面向对象，明确一下面向对象的定义。 面向对象是一种抽象方式 首先根据客户需求抽象出业务对象； 然后对需求进行合理分层，构建相对独立的业务模块； 之后设计业务逻辑，利用多态、继承、封装、抽象的编程思想，实现业务需求； 最后通过整合各模块，达到高内聚、低耦合的效果，从而满足客户要求。 这里把面向对象的编程方式用C++的相应概念描述下： 首先根据客户需求抽象出特定Class； 然后对需求决定继承树，构建相对独立的业务模块； 之后设计业务逻辑，利用多态、继承、封装、抽象的编程思想，实现业务需求； 可以看出面向对象的重点就在于抽象出继承树，而实现方法中最常用的手段就是虚函数。 面向对象的集大成者莫过于GANG OF FOUR的设计模式，面向对象界圣经般的存在。 里面用到了大量的继承和虚函数来抽象业务逻辑。 可是大家有没有想过为什么唯独面向对象出了设计模式的书而面向过程，函数式编程，多重范式编程没有出设计模式？ 这是因为别的方法太复杂了以至于写不成书么？ 错！这是因为面向对象的抽象方式太难了。 绝大多数程序员根本没法正确使用面向对象而要借鉴成熟的模式来帮助设计。 你可能觉得不同意，设计模式上的例子都很基本，有何难？ 的确，但是模式虽简单，具体用起来就不是那么回事了。 我们来看看面向对象的难点在哪里。 面向对象的核心在于虚函数，没有虚函数的继承只是为了封装数据，不会有太多有意思的地方。无法完成诸如设计模式里的复杂逻辑。 而一旦开始使用虚函数，面向对象的噩梦就开始了。 使用虚函数，一般有两种情况： １．简单的多态实现，此时继承层数一般只有１层，接口比较容易实现，虚函数的完美应用。 ２．对象要用于多处业务逻辑，需要满足各种不同的接口，也就是继承自多个虚基类（接口）。 第二种面向对象设计是非常困难的。 首先多继承要满足上接口之间不能有交集，否则会出现模糊性。这使得接口设计复杂化。 其次继承树要避免出现diamond of death，也就是菱形继承。这极大限制了代码的复用性，随意组合几乎不可能。 最后一旦要用于新业务逻辑，对象必须满足新接口，于是必须继承新的接口并加以实现，别无他法。 一旦面向对象进入情况２，类设计基本上就可以宣告死刑了，不会再有高内聚低耦合，也不会再有代码复用了。 为什么？ 矛盾1：对象为什么要实现业务逻辑的接口？对象只要管自己的数据就行了么，凭什么还要管业务逻辑？高内聚低耦合从何谈起。 矛盾2：用户不会把这个对象用于某个业务逻辑，为什么还要保留相应接口，为什么还要引入这么多不相关的类？？代码复用？ 呵呵 You wanted a banana but what you got was a gorilla holding the banana and the entire jungle. -Joe Armstrong, creator of Erlang, on software reusability. 情况2出现的根本原因就在于用虚函数实现多态，用了虚函数就必须用继承，即便对象和业务逻辑完全正交也要继承接口。 虚函数把多态关系强行嵌入到类层次结构中，使得每多一种多态就要多一种类层次，久而久之类设计变得极其困难，寸步难行。 所以说虚函数实现多态就是万恶的根源。 ----------------------------------------------------------------------- 那么我们再来分析下虚函数的问题到底出在哪里？ 虚函数要实现的是is-a关系，也就是我程序不管你苹果橘子，只要是水果就行。 你说我番茄不是水果怎么办，但我和水果一样啊？那就只能先把番茄变成水果再跑我这程序。 问题根源在于类型信息不足，即便番茄苹果差不多，但是没有类型信息就是没办法，要靠继承来补足信息。 但番茄我就是不想要水果接口怎么办？ 那就只能改动业务，让业务分清番茄与水果。并且传入额外类型信息，而不是通过虚函数来实现多态。 在面向过程的世界里我们一般用enum配合switch来解决动态类型信息(RTTI)的问题，可以看作是静态多态。 但弊病很多，容易忘改，类型cast不安全，需不断改动原代码，无法实现二进制复用。 而虚函数则是将其动态化的产物，消除了一些问题，但是引入了类层次的新问题。 除此之外还有没有别的安全的方法实现switch而无需使用虚函数以及继承？ 当然有。就像STL实现通用算法那样，我们可以用模板来实现switch的功能，而不是用虚函数。 我们已经有了现成的实现：boost::variant。 ------------------------------------------------------------------------------------- boost::variant可以看作是union+enum+switch的组合，可以保证类型信息不丢失。 使用boost::variant我们既可以保留面向对象的全部特性。 又可以针对特别的类提供特别调用。 最后还能用模板提供默认实现，这个代码自动生成的特性仅用switch + union是完全做不到的。 结果就是可以在不改动源代码的情况下实现静态多态，对象无需继承任何接口。 虽然不像面向对象那样可以二进制复用，但是代码复用还是做到了。 下面这个例子罗列了一些variant的设计手法，overload + 虚函数 + template，灵活又安全。 注意这只是个简单例子。为了将variant的visitor彻底范型化，还需要做更多的工作，这里就不展开了。 #include <string>#include <iostream>#include <boost/variant.hpp>class Fruit {public:    Fruit(){}    virtual ~Fruit(){}    virtual std::string getName() const = 0;};class Apple : public Fruit {public:    std::string getName() const {        return \"Apple\";    }};class Orange : public Fruit {public:    std::string getName() const {        return  \"Orange\";    }};class Tomato {public:    std::string getName() const {        return \"Tomato\";    }};struct NameVisitor1 : public boost::static_visitor<void> {    void operator()(const Fruit* fruit) const {        std::cout << \"Fruit: \" << fruit->getName() << std::endl;    }    void operator()(const Tomato* tomato) const {        std::cout << \"Tomato overloaded: \" << tomato->getName() << std::endl;    }};struct NameVisitor2 : public boost::static_visitor<void> {    void operator()(const Fruit* fruit) const {        std::cout << \"Fruit: \" << fruit->getName() << std::endl;    }    void operator()(const Apple* fruit) const {        std::cout << \"Apple overloaded: \" << fruit->getName() << std::endl;    }    void operator()(const Tomato* tomato) const {        std::cout << \"Tomato overloaded: \" << tomato->getName() << std::endl;    }};struct NameVisitor3 : public boost::static_visitor<void> {    template<class T>    void operator()(const T* fruit) const {        std::cout << \"Generic: \" << fruit->getName() << std::endl;    }};struct NameVisitor4 : public boost::static_visitor<void> {    void operator()(const Fruit* fruit) const {        std::cout << \"Fruit: \" << fruit->getName() << std::endl;    }    void operator()(const Apple* fruit) const {        std::cout << \"Apple overloaded: \" << fruit->getName() << std::endl;    }    template<class T>    void operator()(const T* fruit) const {        std::cout << \"Generic: \" << fruit->getName() << std::endl;    }};struct Deleter : public boost::static_visitor<void> {    template<class T>    void operator()(T* ptr) const {        if (ptr) {            std::cout << \"delete \" << ptr->getName() << std::endl;            delete ptr;        }    }};typedef boost::variant<Fruit*, Tomato*, Apple*> FruitPtr; int main(int argc, char* argv[]){    FruitPtr apple(new Apple());    FruitPtr orange(new Orange());    FruitPtr tomato(new Tomato());    {        std::cout << \"Name1 \" << std::endl;        boost::apply_visitor(NameVisitor1(), apple);        boost::apply_visitor(NameVisitor1(), orange);        boost::apply_visitor(NameVisitor1(), tomato);        std::cout << std::endl;    }    {        std::cout << \"Name2 \" << std::endl;        boost::apply_visitor(NameVisitor2(), apple);        boost::apply_visitor(NameVisitor2(), orange);        boost::apply_visitor(NameVisitor2(), tomato);        std::cout << std::endl;    }    {        std::cout << \"Name3 \" << std::endl;        boost::apply_visitor(NameVisitor3(), apple);        boost::apply_visitor(NameVisitor3(), orange);        boost::apply_visitor(NameVisitor3(), tomato);        std::cout << std::endl;    }    {        std::cout << \"Name4 \" << std::endl;        boost::apply_visitor(NameVisitor4(), apple);        boost::apply_visitor(NameVisitor4(), orange);        boost::apply_visitor(NameVisitor4(), tomato);        std::cout << std::endl;    }    boost::apply_visitor(Deleter(), apple);    boost::apply_visitor(Deleter(), orange);    boost::apply_visitor(Deleter(), tomato);\treturn 0;}运行结果： Name1 Fruit: Apple Fruit: Orange Tomato overloaded: Tomato Name2 Apple overloaded: Apple Fruit: Orange Tomato overloaded: Tomato Name3 Generic: Apple Generic: Orange Generic: Tomato Name4 Apple overloaded: Apple Fruit: Orange Generic: Tomato delete Apple delete Orange delete Tomato 综上所述，我们首先论证了面向对象本质上与低耦合高内聚矛盾，与代码复用矛盾。 然后给出了一个替代虚函数的variant方案，大幅简化类层次设计。把复杂度移到业务处，并用模板将业务范型化。 实际使用中可以发现架构程序原型比纯面向对象容易的多。因为面向对象一开始需求如果不明确，难以抽象出公共接口。 用variant可以无需烦恼接口与继承的问题，可以等架构成熟了之后再做抽象。 这种设计已经出现很久了，02年的时候已有雏形。boost::gil就是基于这种设计方法。 设计类层次的时候，单继承足以（不带虚函数的继承不算在内），不用继承更好。 只要把业务范型化既可。","title":"抛弃面向对象吧，c++有更好的设计方法"},{"content":"测试","title":"测试，索索索说"},{"content":"下面分别从基本概念，应该，形式，限制，等方面详细分析了单态设计模式，详细请看下文： AD： 1 基本概念 单态模式是设计模式中最为人熟知的也是形式最简单的。它的基本概念是一个类只生成一个实例。 2 应用 ingleton的应用有很多，譬如对数据库只能有一个连接，或者对网站的连接数的计数器。 3 几种形式 基本形式是使用private constructor和一个public的static方法来获得类的实例。 public class Singleton {      private static Singleton instance = new Singleton();         private Singleton(){}         public static Singleton getInstance() {          return instance;      }  } Snippet 1 constructor是private，所以如 Singleton s = new Singleton() 不再可行了。只能通过 Singleton s = Singleton.getInstance(); 来获得实例，而这个实例因为是static，全局共享一个，所以无论有多少个Singleton s = Singleton.getInstance(); 得到的实例都是同一个。 constructor是private，所以如 Singleton s = new Singleton() 不再可行了。只能通过Singleton s = Singleton.getInstance();来获得实例，而这个实例因为是static，全局共享一个，所以无论有多少个Singleton s = Singleton.getInstance(); 得到的实例都是同一个。 而Singleton 还有另外一种形式，采用lazy initialization： public class Singleton {      private static Singleton instance = null;         private Singleton(){}         public static Singleton getInstance() {          if(instance == null)              instance = new Singleton();          return instance;      }  } Snippet 2 Snippet 2同Snippet 1的区别在于： Snippet 1在load class阶段就创建对象了; 而Snippet 2只有第一次要实例化的时候才会创建对象。这就是所谓的lazy initialization。 多线程问题 我们来看snippet 2，如果是单线程，没问题，如果是多线程，问题就出现了，因为两个线程可以同时进入if(instance == null) 这个判断语句，所以有可能两个线程创建两个实例。 public class Singleton {      private static Singleton instance = null;         private Singleton(){}         public static syncronized  Singleton getInstance() {          if(instance == null)              instance = new Singleton();          return instance;      }  } Snippet 3 然而Snippet 3的问题是在创建了对象之后, instance = new Singleton() 这个语句就再也不会执行了，所以对整个方法进行同步的话效率低下，这样就有人想出了Double-checked locking的方法： public class Singleton {      private static Singleton instance = null;         private Singleton(){}         public static Singleton getInstance() {          if(instance == null)              syncronized(Singleton.class){                  if(instance == null)                      instance = new Singleton();              }             return instance;      }  } Snippet 4 这样就解决了问题，仅仅对 if(instance == null)       instance = new Singleton(); 这段代码进行同步，如果对象已经被创建，就不会进入到第一个if代码段里面，所以仅仅在第一次创建的时候会进行同步，效率自然高了。现在看来万无一失了。但问题还没有这么简单。 out-of-order write问题，更多相关资料请见： DoubleCheckedLocking instance = new Singleton();  的顺序应该是 分配内存  构造函数初始化  将对象的reference赋值给instance 但因为Java Memory Model的问题，可能出现下面的所谓out-of-order write的问题： 分配内存  将对象的reference赋值给instance  构造函数初始化 也就是还没对对象初始化，就已经instance != null了，这样如果另外一个线程这时候对实例进行操作，可能有意想不到的结果。 但仍旧没有好的办法可以完全解决这个问题。见 参考一 , 参考二 综上，采用Snippet 1或者Snippet 3比较安全。Snippet 2和Snippet 4最好在多线程的环境下不要使用，否则可能会出错。 4 限制 但Singleton的模式还是有限制的 1 因为采用private constructor，所以Singleton是不能被继承的。 2 如果应用是在容器中运行，就要小心，因为servlet可能在被几个classloader加载，同时有几个Singleton实例存在。 3 另外如果Singleton是可被序列化的(Serializable)，如果序列化一次而反序列化多次就有可能有多个Singleton实例存在。关于序列化见此文。 5 结论 所以就算是看起来最简单的设计模式也有这么多变数，一不小心就可能落入陷阱。不过当你知道陷阱在哪，也就能避免掉进去了。","title":"单态设计模式(Singleton Design Pattern)"},{"content":"设计模式（零）——面向对象基础        从今天开始我将给大家带来设计模式从零开始系列课程，本系列课程主要面对学完C++、java、C#等面向对象语言的同学们，如果你是大牛请直接略过，当然十分欢迎大家给我提出宝贵的意见，我将十分感激！希望本课程可以帮助同学们更好的使用设计模式，以及更好的理解面向对象的程序设计思想，同时也为了自己能够更加深入的理解和运用各种设计模式！（本教程将以C++作为标准语言，java或者C#程序员可以很容易将C++代码转化为自己语言的代码！因此一示例程序将会只有C++代码，时间不允许还望理解，如果遇到什么问题欢迎向我提问！）我会尽量做到每周五更新一篇的！还请大家多多支持啊！ 何为类？何为对象？        类（Class）：从字面意思可以看出，生活中的类就是对事物的分类，比如狗是一类，猫是另一类，两者并不相同；那么程序设计中的类又指什么呢？程序设计中的类是对现实生活中一类具体物体的抽象，根据抽象的程度不同，同一类物体可能会得到不同的抽象；比如：藏獒，可以抽象为藏獒类，也可以抽象为狗类。        对象（Object）：我认为这个词的英语去理解还是比较到位的，对象就是一个具体的东西，他是类的实例。如果把类看作是一张设计图纸的话，那么对象就是根据这张图纸生产出来的具体事物！比如说：藏獒类的一个对象就是一只实实在在价值很高的藏獒！        可以说，对象是类的一个具体表现，没有类的定义就没有办法实例化得到一个对象，就好比没有设计图纸就没有办法生产零件一样！下面介绍类的定义： class dog{private://访问权限声明      .....;//这里是数据成员，是描述类的属性；public://访问权限声明    dog();//这个是构造函数，它会在该类的一个实例被创建时调用；    void shout();//这个是成员函数，用来实现这个类所具有的功能；    ......    ~dog();//这里是析构函数，它会在该类的一个实例被delete时执行；};值得注意的是： 1、构造函数和析构函数也是成员函数； 2、构造函数和成员函数如果不定义的话，系统会提供默认的构造函数和析构函数，当然功能就不能保障了。 由于语言特性不是本教程讨论的重点，只是简单提及，如果想深入了解请查看相应的书籍或者资料；google一下，你就知道！ 如果对于自己语言的类相关的语法声明不太了解的话，我提供一下关键词，供大家搜索： 1、“java/C++/C#”+类与实例 2、“java/C++/C#”+构造方法（构造函数）、析构函数 3、“java/C++/C#”+方法重载 4、“java/C++/C#”+属性与修饰符 类与对象的基本概念告一段落，下面讨论一下面向对象的三大特性： 一、封装 将一类事物的属性（自有的变量）和行为（成员函数）放在同一个类中，功能和数据在类内部进行操作，对类外只留下相应的接口，这种程序设计的方式就叫做封装，就好比一个面包板内部实现了功能，对外只有管脚一样！ 那么好好地为什么要封装呢？自然是有它的好处： 1、良好的封装能够降低耦合（何为耦合？就是一个功能与外界的关联程度，比如外部代码变了，而你的功能模块不用修改或者很少的的修改就可以了，这就是耦合度低的表现！还不懂？嘿嘿，问问度娘或者谷哥吧）         2、类内部实现可以自由修改，或者可以表述为高内聚（什么叫高内聚？嘿嘿，问问度娘或者谷哥吧） 3、对外接口明显 二、继承 继承？继承财产？No，No，No程序设计中没有财产给你继承哦，嘿嘿，这里的继承表现出来的是一种A is B的关系，比如“藏獒是狗狗”，“男人是人”，“女人是人”等等，这样的 A是B 的关系就可以用继承来描述！ 在程序当中，如果A继承自B那么A就拥有B的一些特性（只包括protected和public特性）A就被称作B的派生类或者子类，B就叫做A的父类或者基类。 想学好继承可以记住并好好理解以下三句话： 1、子类继承父类，就继承了父类中非private的属性和方法 2、子类具有自己独有的属性和方法，就是子类可以扩展父类 3、子类可以重新实现父类的方法，即方法重载 三、多态 多态？变态？差不多一个意思，所谓多态就是指从同一父类继承得来的所有子类在执行父类中相同的函数是表现出不同的结果！什么意思呢？举个例子吧： 比如猫，狗都是从动物类继承来的，动物类中有一个shout方法，但是狗和猫总不能叫声一样吧，所以他们就会在自己的类中有不同的shout实现，当你用父类指针分别指向猫和狗并进行shout方法调用的时候，就会有不同的结果了！看看代码或许能够更好地理解： class animal{public:    animal(){}    void shout(){}    ~animal(){}};class dog:public animal      //继承animal的属性和方法{public:    void shout(){cout << \"wang\"<< endl;}};class cat:public animal     //继承animal的属性和方法{public:    void shout(){cout << \"miao\" << endl;}};void main(){    animal* ani;    ani=new cat();    ani->shout();    delete ani;    ani=new dog();    ani->shout();   //与上一次的shout()执行结果不一样就表现出了多态的性质    delete ani;}有关面向对象的基础就暂时讲到这里，如果有同学不太了解的话，可以问我，给我留言。由于个人精力问题（课程任务好重说！）如果有问题没有阐述清楚敬请谅解！ 最后希望大家多跟度娘和谷哥交流，他们会是最好的老师！那么下次课程再见！","title":"设计模式从零开始（一）"},{"content":"        最近做项目，写的代码不是很好，所以决定把这次代码中写的不好的部分——没有很好的运用Java的设计模式——整理一下，并扩展成一个专栏（哪天凑够字数就集结成书——玩笑。。）。这里我仅一个开发生手的角度写，尽量写的通俗易懂，给同样水平二把刀的人看，大虾高手及东方不败请绕行。这段算是个序吧。","title":"Java设计模式（1）——个人理解+个人写的实例"},{"content":"设计模式C++学习笔记之七（Facade门面模式） Facade门面模式，也是比较常用的一种模式，基本上所有软件系统中都会用到。GOF在《设计模式》一书中给出如下定义：为子系统中的一组接口提供一个一致的界面， Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。简单说，就是将复杂的逻辑封装起来，对外公开简单的接口，由客户程序调用。这里举了一个发送邮件的例子，我们理解为电子邮件吧，普通的邮件应该不需要告诉邮局，我们写的信件内容（呵呵有点较真了）。这个例子更详细的内容及说明可以参考原作者博客：cbf4life.cnblogs.com。 9.1.解释 main()，客户 ILetterProcess，接口 CLetterProcessImpl，信件处理的4个函数 CLetterPolice，警察 CModenPostOffice，邮局 说明：邮局对外只有一个窗口，接收信件内容和邮件地址。对内调用邮件处理的4个函数。将复杂逻辑封装在邮局的里面，当需要增加警察来检查信件时，只需在邮局内增加警察检查信件的方法。 注意：将复杂逻辑封装起来，对外只有一个简单的接口。 看代码： //ILetterProcess.h #pragma once #include <iostream> using std::string; class ILetterProcess { public:     ILetterProcess(void);     virtual ~ILetterProcess(void);     virtual void WriteContext(string context) = 0;     virtual void FillEnvelope(string address) = 0;     virtual void LetterIntoEnvelope() = 0;     virtual void SendLetter() = 0; }; //ILetterProcess.cpp #include \"StdAfx.h\" #include \"ILetterProcess.h\" ILetterProcess::ILetterProcess(void) { } ILetterProcess::~ILetterProcess(void) { } //LetterprocessImpl.h #pragma once #include \"iletterprocess.h\" class CLetterProcessImpl :     public ILetterProcess { public:     CLetterProcessImpl(void);     ~CLetterProcessImpl(void);     void WriteContext(string context);     void FillEnvelope(string address);     void LetterIntoEnvelope();     void SendLetter(); }; //LetterProcessImpl.cpp #include \"StdAfx.h\" #include \"LetterProcessImpl.h\" #include <iostream> using std::string; using std::cout; using std::endl; CLetterProcessImpl::CLetterProcessImpl(void) { } CLetterProcessImpl::~CLetterProcessImpl(void) { } void CLetterProcessImpl::WriteContext(string context) {     cout << \"填写信的内容... ...\" << endl; } void CLetterProcessImpl::FillEnvelope(string address) {     cout << \"填写收件人地址及姓名... ...\" << endl; } void CLetterProcessImpl::LetterIntoEnvelope() {     cout << \"把信放到信封中...\" << endl; } void CLetterProcessImpl::SendLetter() {     cout << \"邮递信件...\" << endl; } //ModenPostOffice.h #pragma once #include \"ILetterProcess.h\" #include \"LetterProcessImpl.h\" #include \"LetterPolice.h\" #include <iostream> using std::string; class CModenPostOffice { public:     CModenPostOffice(void);     ~CModenPostOffice(void);     void SendLetter(string context, string address); private:     ILetterProcess *m_pLetterProcess;     CLetterPolice *m_pLetterPolice; }; //ModenPostOffice.cpp #include \"StdAfx.h\" #include \"ModenPostOffice.h\" CModenPostOffice::CModenPostOffice(void) {     this->m_pLetterProcess = new CLetterProcessImpl();     this->m_pLetterPolice = new CLetterPolice(); } CModenPostOffice::~CModenPostOffice(void) {     delete m_pLetterProcess;     delete m_pLetterPolice; } void CModenPostOffice::SendLetter( string context, string address ) {     //帮忙写信     m_pLetterProcess->WriteContext(context);     //写好信封     m_pLetterProcess->FillEnvelope(address);     //警察要检查信件了     m_pLetterPolice->CheckLetter(m_pLetterProcess);     //把信放到信封中     m_pLetterProcess->LetterIntoEnvelope();     //邮递信件     m_pLetterProcess->SendLetter(); } //LetterPolice.h #pragma once #include \"ILetterProcess.h\" class CLetterPolice { public:     CLetterPolice(void);     ~CLetterPolice(void);     void CheckLetter(ILetterProcess *pLetterProcess); }; //LetterPolice.cpp #include \"StdAfx.h\" #include \"LetterPolice.h\" CLetterPolice::CLetterPolice(void) { } CLetterPolice::~CLetterPolice(void) { } void CLetterPolice::CheckLetter( ILetterProcess *pLetterProcess ) {     //检查信件，此处省略一万字。     return; } //Facade.cpp #include \"stdafx.h\" #include \"ILetterProcess.h\" #include \"LetterProcessImpl.h\" #include \"ModenPostOffice.h\" #include<iostream> using std::string; using std::cout; using std::endl; void DoItByPostOffice() {     CModenPostOffice modenPostOffice;     string context = \"Hello, It's me, do you know who I am? I'm your old lover. I'd like to ... ...\";     string address = \"Happy Road No. 666, Beijing City, China\";     modenPostOffice.SendLetter(context, address); } void DoItYourself() {     ILetterProcess *pLetterProcess = new CLetterProcessImpl();     pLetterProcess->WriteContext(\"Hello, It's me, do you know who I am? I'm your old lover. I'd like to ... ...\");     pLetterProcess->FillEnvelope(\"Happy Road No. 666, Beijing City, China\");     pLetterProcess->LetterIntoEnvelope();     pLetterProcess->SendLetter();     delete pLetterProcess; } int _tmain(int argc, _TCHAR* argv[]) {     //现在的调用方式。对于客户来说确实简单多了。     //如需要增加逻辑，例如让警察来检查邮件。可以在邮局里完成这项工作。     DoItByPostOffice();         //原来的调用方式。     DoItYourself();     _CrtSetDbgFlag(_CRTDBG_LEAK_CHECK_DF | _CRTDBG_ALLOC_MEM_DF);     _CrtDumpMemoryLeaks();     return 0; } 上面的图仍然只是类图而已，用于帮助理解代码中类之间的关系，而不是模式的抽象类图。CModenPostOffice封装了复杂的处理逻辑，对外只有SendLetter这个函数接口。使客户程序容易了解到想要做什么，应该告诉邮局什么内容，邮局才能正确的工作。 目前为止，还都是比较简单的模式，越到后面越复杂。我的理解是当没有模式的时候，大家编写代码也需要考虑扩展性、伸缩性、稳定性等等。那个时候大家写程序都是自己在摸索经验，逐渐的才意识到程序应该可以适应需求的变化。于是总结很多方法来，让程序既能适应变化，又有一定的可靠性。这使得编程序更有趣，也更抽象了。所以软件开发就是提炼和抽象的过程。类似于哲学的提炼，从特殊到一般。","title":"设计模式C++学习笔记之七（Facade门面模式）"},{"content":"INTERPRETER 解释器 1、 意图 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 2、 适用性 当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。而当存在以下情况时该模式效果最好： 该文法简单对于复杂的文法，文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是最好的选择。它们无需构建抽象语法树即可解释表达式，这样可以节省空间而且还可能节省时间。 效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的，而是首先将它们转换成另一种形式。 3、 结构 4、 参与者 AbstractExpression（抽象表达式） ——声明一个抽象的解释操作，这个接口为抽象语法树中所有的节点所共享。 TerminalExpression（终结符表达式） ——实现与文法中的终结符相关联的解释操作。 ——一个句子中的每个终结符需要该类的一个实例。 NonterminalExpression（非终结符表达式） ——对文法中的每一条规则R::=都需要一个NonterminalExpression。 ——为从到的每个符号都维护一个AbstractExpression类型的实例变量。 ——为文法中的非终结符实现解释操作。解释一般要递归地调用表示到的那些对象的解释操作。 Context（上下文） ——包含解释器之外的一些全局信息。 Client（客户） ——构建（或被给定）表示该文法定义的语言中一个特定的句子的抽象语法树。该抽象树语法由NonterminalExpression和TerminalExpression的实例装配而成。 ——调用解释操作。 5、 协作 l  Client构建（或被给定）一个句子，它是NonterminalExpression和TerminalExpression的实例的一个抽象语法树，然后初始化上下文并调用解释操作。 l  每一非终结符表达式节点定义相应子表达式的解释操作。而各终结符表达式的解释操作构成了递归的基础。 l  每一节点的解释操作用上下文来存储和访问解释器的状态。 6、 效果 解释器模式有下列的优点和不足： 1）  易于改变和扩展文法；因为该模式使用类来表示文法规则，你可使用继承来改变或扩展该文法。已有的表达式可被增量式地改变，而新的表达式可定义为旧表达式的变体。 2）  也易于实现文法；定义抽象语法树中各个节点的类的实现大体类似。这些类易于直接编写，通常它们也可用一个编译器或语法分析程序生成器自动生成。 3）  复杂的文法难以维护；解释器模式为文法中的每一条规则至少定义了一个类。因此包含许多规则的文法可能难以管理和维护。可应用其他的设计模式来缓解这一问题。 4）  增加了新的解释表达式的方式；解释器模式使得实现新表达式“计算”变得容易。 7、 实现 1）  创建抽象语法树；解释器模式并未解释如何创建一个抽象的语法树。换言之，它不涉及语法分析。抽象语法树可用一个表驱动的语法分析程序来生成，也可用手写的（通常为递归下降法）语法分析程序创建，或直接由Client提供。 2）  定义解释操作；并不一定要在表达式类中定义解释操作。如果经常要创建一种新的解释器，那么使用Visitor模式将解释放入一个独立的“发问者”对象更好。 3）  与Flyweight模式共享终结符；在一些文法中，一个句子可能多次出现同一个终结符。此时最好共享那个符号的单个拷贝。 终结节点通常不存储关于它们在抽象语法树中的位置的信息。在解释过程中，任何它们所需要的上下文信息都由父节点传递给它们。因此在共享的（内部的）状态和传入的（外部的）状态区分得很明确，这就用到了Flyweight模式。 8、 代码示例 AbstractExpression package com.examples.pattern.interpreter;/** * 抽象表达式 */public abstract class AbstractExpression {\tpublic abstract void interpret(Context ctx);} TerminalExpression package com.examples.pattern.interpreter;/** * 终结符表达式 */public class TerminalExpression extends AbstractExpression {\t@Override\tpublic void interpret(Context ctx) {\t\tSystem.out.println(\"this is terminalexpression\");\t}} NonterminalExpression package com.examples.pattern.interpreter;/** * 非终结符表达式 */public class NonterminalExpression extends AbstractExpression {\t@Override\tpublic void interpret(Context ctx) {\t\tSystem.out.println(\"this is nonterminalexpression\");\t}}Context package com.examples.pattern.interpreter;import java.util.ArrayList;import java.util.List;/** * 上下文 */public class Context {\tprivate String content;\tprivate List list = new ArrayList();\tpublic void setContent(String content) {\t\tthis.content = content;\t}\tpublic String getContent() {\t\treturn this.content;\t}\tpublic void add(AbstractExpression eps) {\t\tlist.add(eps);\t}\tpublic List getList() {\t\treturn list;\t}}Client package com.examples.pattern.interpreter;import java.util.Iterator;import java.util.List;public class Client {\tpublic static void main(String[] args) {\t\tContext ctx = new Context();\t\tctx.add(new TerminalExpression());\t\tctx.add(new NonterminalExpression());\t\tctx.add(new TerminalExpression());\t\tList list = ctx.getList();\t\tIterator it = list.iterator();\t\twhile (it.hasNext()) {\t\t\tAbstractExpression ae = (AbstractExpression) it.next();\t\t\tae.interpret(ctx);\t\t}\t}} 9、 相关模式  Composite模式：抽象语法树是一个复合模式的实例。 Flyweight模式：说明了如何在抽象语法树中共享终结符。 Iterator：解释器可用一个迭代器遍历该结构。 Visitor：可用来在一个类中维护抽象语法树中的各节点的行为。","title":"设计模式——解释器"},{"content":"1  定义      单一职责原则（SRP，SingleResonsibility  Principle）：一个类应当只有一个改变它的原因。(There should never be more than one reason for aclass to change)      换而言之就像人不能一心二用一样，一个类应该只做一件事和仅有一个使它改变的原因。如果一个类包含一个以上的职责的话，那么多个职责就会耦合一起，影响复用。例如在使用java web开发时n层架构模式就是单一职责的宏观体现，我们会把展示层、控制器、业务逻辑层、以及DAO层实现分离，每一层次的处理相互隔离，降低了耦合度，试想下我们如果将页面显示，业务逻辑处理，数据库的操作都写在页面上，将会出现什么样的后果？ 2 单一职责原则举例       单一职责原则从其定义非常好理解，虽然简单，却是非常重要的面向对象设计原则（当然单一职责原则并非面向对象设计独有）。回想一下我们曾经开发经历，虽然都知道应该设计类时应该职责分离，但是在开发的过程中，一时偷懒或者未经思考在一个类中临时加入一些不是此类职责的方法，积累变多时，发现系统应用变得杂乱不堪，业务逻辑也变得混乱，这时候维护也变得非常棘手，你是不是有过这样的经历呢？      下面看个例子：当我们设计一个购物系统时，会设计用户类（User）和订单类（Order）,如果我们的用户类是如下设计的话： public class User {    public void addUser(){       System.out.println(\"新增用户\");    }    public void deleteUser(){       System.out.println(\"新增用户\");    }    public void upateUser(){       System.out.println(\"更新用户\");    }    public void queryUser(){       System.out.println(\"查询用户\");    }    public void queryOrder(){       System.out.println(\"查询订单\");    }}        是不是看着都感觉别扭，用户类里出现订单的查询订单显得不伦不类，很明显用户类里出现了第二个改变它行为的原因即查询订单，违反了单一职责原则。因此我们需要对用户进行职责分离分成用户类（User）和订单类（Order类）。 User类： public class User {   public void addUser(){       System.out.println(\"新增用户\");    }    public void deleteUser(){       System.out.println(\"新增用户\");    }    public void upateUser(){       System.out.println(\"更新用户\");    }    public void queryUser(){       System.out.println(\"查询用户\");    }} Order订单类: public class Order {    public void queryOrder(){       System.out.println(\"查询订单\");    }}       这样User类和Order类的职责就会变得清晰不会耦合在一块了。这样系统设计的就会更健壮。 3 单一职责原则的优点       单一职责原则分离对象间的职责，降低了对象间的依赖关系，那么也就降低了耦合度。有利于对象的稳定。       它使得职责分离，代码更清晰，更易阅读。        降低耦合度自然也增加的类和对象的复用性，增强系统的可维护性。 4 使用单一职责原则需要注意的地方      使用单一职责原则有一个问题，“职责”没有一个明确的划分标准，如果把职责划分的太细的话会导致接口和实现类的数量剧增，反而提高了复杂度，降低了代码的可维护性。所以使用这个职责的时候还要具体情况具体分析。建议就是接口一定要采用单一职责原则，实现类的设计上尽可能做到单一职责原则，最好是一个原因引起一个类的变化。（引用别人的分析）","title":"[置顶] 面向对象的设计原则之单一职责原则"},{"content":"设计模式从目的来看可以分为： 1、创建型（Creational）模式负责对象创建 2、结构型（Structural）模式处理类与对象间的组合 3、行为型（Behavioral）模式类与对象交互中的职责分配","title":"设计模式(1)"},{"content":"定义 23种设计模式之一，英文叫DecoratorPattern，中文也叫装饰模式、修饰模式。装饰模式是在不改变类文件和不使用继承的情况下，运行期动态扩展一个对象的功能。原理是：增加一个修饰类包裹原来的类，包裹的方式一般是通过在将原来的对象作为修饰类的构造函数的参数。装饰类实现新的功能，但是，在不需要用到新功能的地方，它可以直接调用原来的类中的方法。修饰类必须和原来的类有相同的接口(没有接口可以直接继承自原来的类)。修饰模式是类继承的另外一种选择。类继承在编译时候增加行为，而装饰模式是在运行时增加行为。 UML 实现 Component.java，接口。 public interface Component {    void operation(); }   ConcreteComponent.java，原有类实现(需要扩展)。 public class ConcreteComponent implements Component {    public void operation() {       System.out.println(\"具体对象的操作\");    } }     Decorator.java，抽象修饰类。 public abstract class Decorator implements Component {    protected Componentcomponent;    public Decorator(Component component) {       this.component = component;    }    public void operation() {       if(component !=null)         component.operation();    } }   ConcreteDecoratorA.java，实际修饰类A。 public class ConcreteDecoratorA extends Decorator {    public ConcreteDecoratorA(Component component) {       super(component);    }    @Override    public void operation() {       super.operation();       System.out.println(\"对象A扩展的操作\");    } }   ConcreteDecoratorB.java，实际修饰类B。 public class ConcreteDecoratorB extends Decorator {    public ConcreteDecoratorB(Component component) {       super(component);    }    @Override    public void operation() {       super.operation();       System.out.println(\"对象B扩展的操作\");    } }   DecoratorTest.java，客户端。 public class DecoratorTest {    public static void main(String[] args) {       Component component =         new ConcreteDecoratorB(         new ConcreteDecoratorA(         new ConcreteComponent()));       component.operation();    } }   输出结果： 具体对象的操作 对象A扩展的操作 对象B扩展的操作   上面客户端的调用方式是不是和如下的代码有些类似，没错，Java中的I/O类库使用的就是装饰模式。 BufferedInputStream bis = new BufferedInputStream( new FileInputStream(\"\"));   上面就是装饰模式的模型，如果有不明白，可以结合代码、UML、定义一起看一下。 实例 需求 一个窗口系统中的窗口，允许这个窗口内容滚动，我们希望给它添加水平或垂直滚动条(维基百科)。 实现 Window.java，窗口接口。 public interface Window {    public void draw();    public String getDescription(); }   SimpleWindow.java，简单窗口，不带任何修饰。 public class SimpleWindow implements Window {    public void draw() {  // draw window   }    public String getDescription() {       return \"simple window\";    } }   WindowDecorator.java，窗口装饰抽象类。 public abstract class WindowDecoratorimplements Window {    protected WindowdecoratedWindow; // the Window being decorated    public WindowDecorator(Window decoratedWindow) {       this.decoratedWindow = decoratedWindow;    } }   HorizontalScrollBarDecorator.java，横向滚动条装饰类。 public class HorizontalScrollBarDecorator extends WindowDecorator {    public HorizontalScrollBarDecorator(Window decoratedWindow) {       super(decoratedWindow);    }    public void draw() {       drawHorizontalScrollBar();       decoratedWindow.draw();    }    private void drawHorizontalScrollBar() {       // draw the horizontal scrollbar    }    public String getDescription() {       return decoratedWindow.getDescription() + \", including horizontal scrollbars\";    } }   VerticalScrollBarDecorator.java，纵向滚动条装饰类。 public class VerticalScrollBarDecorator extends WindowDecorator {    public VerticalScrollBarDecorator(Window decoratedWindow) {       super(decoratedWindow);    }    public void draw() {       drawVerticalScrollBar();       decoratedWindow.draw();    }    private void drawVerticalScrollBar() {       // draw the vertical scrollbar    }    public String getDescription() {       return decoratedWindow.getDescription() + \", including vertical scrollbars\";    } }   DecoratedWindowTest.java，客户端。 public class DecoratedWindowTest {    public static void main(String[] args) {       // create a decorated Window with horizontal and vertical scrollbars       Window decoratedWindow =         new HorizontalScrollBarDecorator(         new VerticalScrollBarDecorator(         new SimpleWindow()));       // print the Window's description       System.out.println(decoratedWindow.getDescription());    } }   输出结果： simple window, including vertical scrollbars, including horizontal scrollbars   将不同的装饰区分开来，并且和原有的窗口分开，这样通过包装，我可以创建一个只带横向（纵向）滚动条的窗口，也可以创建不带滚动条的窗口，任意组合。 总结 装饰模式是不使用继承的情况下，可以动态扩展一个类，并且比继承更灵活(上面的实例)。","title":"装饰模式"},{"content":"引言 委托和 事件在 .Net Framework中的应用非常广泛，然而，较好地理解委托和事件对很多接触C#时间不长的人来说并不容易。它们就像是一道槛儿，过了这个槛的人，觉得真 是太容易了，而没有过去的人每次见到委托和事件就觉得心里别（biè）得慌，混身不自在。本文中，我将通过两个范例由浅入深地讲述什么是委托、为什么要使 用委托、事件的由来、.Net Framework中的委托和事件、委托和事件对Observer设计模式的意义，对它们的中间代码也做了讨论。 将方法作为方法的参数 我们先不管这个标题如何的绕口，也不管委托究竟是个什么东西，来看下面这两个最简单的方法，它们不过是在屏幕上输出一句问候的话语： public void GreetPeople(string name) {     // 做某些额外的事情，比如初始化之类，此处略     EnglishGreeting(name); } public void EnglishGreeting(string name) {     Console.WriteLine(\"Morning, \" + name); } 暂且不管这两个方法有没有什么实际意义。GreetPeople用于向某人问好，当我们传递代表某人姓名的name参数，比如说“Jimmy”，进 去的时候，在这个方法中，将调用EnglishGreeting方法，再次传递name参数，EnglishGreeting则用于向屏幕输出 “Morning, Jimmy”。 现在假设这个程序需要进行全球化，哎呀，不好了，我是中国人，我不明白“Morning”是什么意思，怎么办呢？好吧，我们再加个中文版的问候方法： public void ChineseGreeting(string name){     Console.WriteLine(\"早上好, \" + name); } 这时候，GreetPeople也需要改一改了，不然如何判断到底用哪个版本的Greeting问候方法合适呢？在进行这个之前，我们最好再定义一个枚举作为判断的依据： public enum Language{     English, Chinese } public void GreetPeople(string name, Language lang){     //做某些额外的事情，比如初始化之类，此处略     swith(lang){         case Language.English:            EnglishGreeting(name);            break;        case Language.Chinese:            ChineseGreeting(name);            break;     } } OK，尽管这样解决了问题，但我不说大家也很容易想到，这个解决方案的可扩展性很差，如果日后我们需要再添加韩文版、日文版，就不得不反复修改枚举和GreetPeople()方法，以适应新的需求。 在考虑新的解决方案之前，我们先看看 GreetPeople的方法签名： public void GreetPeople(string name, Language lang) 我们仅看 string name，在这里，string 是参数类型，name 是参数变量，当我们赋给name字符串“jimmy”时，它就代表“jimmy”这个值；当我们赋给它“张子阳”时，它又代表着“张子阳”这个值。然后， 我们可以在方法体内对这个name进行其他操作。哎，这简直是废话么，刚学程序就知道了。 如果你再仔细想想，假如GreetPeople()方法可以接受一个参数变量，这个变量可以代表另一个方法，当我们给这个变量赋值 EnglishGreeting的时候，它代表着 EnglsihGreeting() 这个方法；当我们给它赋值ChineseGreeting 的时候，它又代表着ChineseGreeting()方法。我们将这个参数变量命名为 MakeGreeting，那么不是可以如同给name赋值时一样，在调用 GreetPeople()方法的时候，给这个MakeGreeting 参数也赋上值么(ChineseGreeting或者EnglsihGreeting等)？然后，我们在方法体内，也可以像使用别的参数一样使用 MakeGreeting。但是，由于MakeGreeting代表着一个方法，它的使用方式应该和它被赋的方法(比如ChineseGreeting) 是一样的，比如： MakeGreeting(name); 好了，有了思路了，我们现在就来改改GreetPeople()方法，那么它应该是这个样子了： public void GreetPeople(string name, *** MakeGreeting){     MakeGreeting(name); } 注意到 *** ，这个位置通常放置的应该是参数的类型，但到目前为止，我们仅仅是想到应该有个可以代表方法的参数，并按这个思路去改写GreetPeople方法，现在就出现了一个大问题：这个代表着方法的MakeGreeting参数应该是什么类型的？ NOTE：这里已不再需要枚举了，因为在给MakeGreeting赋值的时候动态地决定使用哪个方法，是ChineseGreeting还是 EnglishGreeting，而在这个两个方法内部，已经对使用“morning”还是“早上好”作了区分。 聪明的你应该已经想到了，现在是委托该出场的时候了，但讲述委托之前，我们再看看MakeGreeting参数所能代表的 ChineseGreeting()和EnglishGreeting()方法的签名： public void EnglishGreeting(string name) public void ChineseGreeting(string name) 如同name可以接受String类型的“true”和“1”，但不能接受bool类型的true和int类型的1一样。MakeGreeting的 参数类型定义 应该能够确定 MakeGreeting可以代表的方法种类，再进一步讲，就是MakeGreeting可以代表的方法 的 参数类型和返回类型。 于是，委托出现了：它定义了MakeGreeting参数所能代表的方法的种类，也就是MakeGreeting参数的类型。 NOTE：如果上面这句话比较绕口，我把它翻译成这样：string 定义了name参数所能代表的值的种类，也就是name参数的类型。 本例中委托的定义： public delegate void GreetingDelegate(string name); 可以与上面EnglishGreeting()方法的签名对比一下，除了加入了delegate关键字以外，其余的是不是完全一样？ 现在，让我们再次改动GreetPeople()方法，如下所示： public void GreetPeople(string name, GreetingDelegate MakeGreeting){     MakeGreeting(name); } 如你所见，委托GreetingDelegate出现的位置与 string相同，string是一个类型，那么GreetingDelegate应该也是一个类型，或者叫类(Class)。但是委托的声明方式和类却 完全不同，这是怎么一回事？实际上，委托在编译的时候确实会编译成类。因为Delegate是一个类，所以在任何可以声明类的地方都可以声明委托。更多的 内容将在下面讲述，现在，请看看这个范例的完整代码： using System; using System.Collections.Generic; using System.Text; namespace Delegate {      //定义委托，它定义了可以代表的方法的类型      public delegate void GreetingDelegate(string name);         class Program {            private static void EnglishGreeting(string name) {                Console.WriteLine(\"Morning, \" + name);            }            private static void ChineseGreeting(string name) {                Console.WriteLine(\"早上好, \" + name);            }            //注意此方法，它接受一个GreetingDelegate类型的方法作为参数            private static void GreetPeople(string name, GreetingDelegate MakeGreeting) {                MakeGreeting(name);             }            static void Main(string[] args) {                GreetPeople(\"Jimmy Zhang\", EnglishGreeting);                GreetPeople(\"张子阳\", ChineseGreeting);                Console.ReadKey();            }         }     } 输出如下： Morning, Jimmy Zhang 早上好, 张子阳 我们现在对委托做一个总结： 委托是一个类，它定义了方法的类型，使得可以将方法当作另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量使用If-Else(Switch)语句，同时使得程序具有更好的可扩展性。 将方法绑定到委托 看到这里，是不是有那么点如梦初醒的感觉？于是，你是不是在想：在上面的例子中，我不一定要直接在GreetPeople()方法中给 name参数赋值，我可以像这样使用变量： static void Main(string[] args) {     string name1, name2;     name1 = \"Jimmy Zhang\";     name2 = \"张子阳\";      GreetPeople(name1, EnglishGreeting);      GreetPeople(name2, ChineseGreeting);     Console.ReadKey(); } 而既然委托GreetingDelegate 和 类型 string 的地位一样，都是定义了一种参数类型，那么，我是不是也可以这么使用委托？ static void Main(string[] args) {     GreetingDelegate delegate1, delegate2;     delegate1 = EnglishGreeting;     delegate2 = ChineseGreeting;     GreetPeople(\"Jimmy Zhang\", delegate1);         GreetPeople(\"张子阳\", delegate2);         Console.ReadKey(); } 如你所料，这样是没有问题的，程序一如预料的那样输出。这里，我想说的是委托不同于string的一个特性：可以将多个方法赋给同一个委托，或者叫将多个方法绑定到同一个委托，当调用这个委托的时候，将依次调用其所绑定的方法。在这个例子中，语法如下： static void Main(string[] args) {     GreetingDelegate delegate1;     delegate1 = EnglishGreeting; // 先给委托类型的变量赋值     delegate1 += ChineseGreeting;   // 给此委托变量再绑定一个方法      // 将先后调用 EnglishGreeting 与 ChineseGreeting 方法     GreetPeople(\"Jimmy Zhang\", delegate1);      Console.ReadKey(); } 输出为： Morning, Jimmy Zhang 早上好, Jimmy Zhang 实际上，我们可以也可以绕过GreetPeople方法，通过委托来直接调用EnglishGreeting和ChineseGreeting： static void Main(string[] args) {     GreetingDelegate delegate1;     delegate1 = EnglishGreeting; // 先给委托类型的变量赋值     delegate1 += ChineseGreeting;   // 给此委托变量再绑定一个方法     // 将先后调用 EnglishGreeting 与 ChineseGreeting 方法     delegate1 (\"Jimmy Zhang\");       Console.ReadKey(); }   NOTE：这在本例中是没有问题的，但回头看下上面GreetPeople()的定义，在它之中可以做一些对于EnglshihGreeting和ChineseGreeting来说都需要进行的工作，为了简便我做了省略。 注意这里，第一次用的“=”，是赋值的语法；第二次，用的是“+=”，是绑定的语法。如果第一次就使用“+=”，将出现“使用了未赋值的局部变量”的编译错误。 我们也可以使用下面的代码来这样简化这一过程： GreetingDelegate delegate1 = new GreetingDelegate(EnglishGreeting); delegate1 += ChineseGreeting;   // 给此委托变量再绑定一个方法 看到这里，应该注意到，这段代码第一条语句与实例化一个类是何其的相似，你不禁想到：上面第一次绑定委托时不可以使用“+=”的编译错误，或许可以用这样的方法来避免： GreetingDelegate delegate1 = new GreetingDelegate(); delegate1 += EnglishGreeting;   // 这次用的是 “+=”，绑定语法。 delegate1 += ChineseGreeting;   // 给此委托变量再绑定一个方法 但实际上，这样会出现编译错误： “GreetingDelegate”方法没有采用“0”个参数的重载。尽管这样的结果让我们觉得有点沮丧，但是编译的提示：“没有0个参数的重载”再次让我们联想到了类的构造函数。我知道你一定按捺不住想探个究竟，但再此之前，我们需要先把基础知识和应用介绍完。 既然给委托可以绑定一个方法，那么也应该有办法取消对方法的绑定，很容易想到，这个语法是“-=”： static void Main(string[] args) {     GreetingDelegate delegate1 = new GreetingDelegate(EnglishGreeting);     delegate1 += ChineseGreeting;   // 给此委托变量再绑定一个方法     // 将先后调用 EnglishGreeting 与 ChineseGreeting 方法     GreetPeople(\"Jimmy Zhang\", delegate1);      Console.WriteLine();     delegate1 -= EnglishGreeting; //取消对EnglishGreeting方法的绑定     // 将仅调用 ChineseGreeting     GreetPeople(\"张子阳\", delegate1);     Console.ReadKey(); } 输出为： Morning, Jimmy Zhang 早上好, Jimmy Zhang 早上好, 张子阳 让我们再次对委托作个总结： 使用委托可以将多个方法绑定到同一个委托变量，当调用此变量时(这里用“调用”这个词，是因为此变量代表一个方法)，可以依次调用所有绑定的方法。 事件的由来 我们继续思考上面的程序：上面的三个方法都定义在Programe类中，这样做是为了理解的方便，实际应用中，通常都是 GreetPeople 在一个类中，ChineseGreeting和 EnglishGreeting 在另外的类中。现在你已经对委托有了初步了解，是时候对上面的例子做个改进了。假设我们将GreetingPeople()放在一个叫 GreetingManager的类中，那么新程序应该是这个样子的： namespace Delegate {     //定义委托，它定义了可以代表的方法的类型     public delegate void GreetingDelegate(string name);         //新建的GreetingManager类     public class GreetingManager{        public void GreetPeople(string name, GreetingDelegate MakeGreeting) {            MakeGreeting(name);        }     }     class Program {        private static void EnglishGreeting(string name) {            Console.WriteLine(\"Morning, \" + name);        }        private static void ChineseGreeting(string name) {            Console.WriteLine(\"早上好, \" + name);        }        static void Main(string[] args) {            // ... ...         }     } } 这个时候，如果要实现前面演示的输出效果，Main方法我想应该是这样的： static void Main(string[] args) {     GreetingManager gm = new  GreetingManager();     gm.GreetPeople(\"Jimmy Zhang\", EnglishGreeting);     gm.GreetPeople(\"张子阳\", ChineseGreeting); } 我们运行这段代码，嗯，没有任何问题。程序一如预料地那样输出了： Morning, Jimmy Zhang 早上好, 张子阳 现在，假设我们需要使用上一节学到的知识，将多个方法绑定到同一个委托变量，该如何做呢？让我们再次改写代码： static void Main(string[] args) {     GreetingManager gm = new  GreetingManager();     GreetingDelegate delegate1;     delegate1 = EnglishGreeting;     delegate1 += ChineseGreeting;     gm.GreetPeople(\"Jimmy Zhang\", delegate1); } 输出： Morning, Jimmy Zhang 早上好, Jimmy Zhang 到了这里，我们不禁想到：面向对象设计，讲究的是对象的封装，既然可以声明委托类型的变量(在上例中是delegate1)，我们何不将这个变量封 装到 GreetManager类中？在这个类的客户端中使用不是更方便么？于是，我们改写GreetManager类，像这样： public class GreetingManager{     //在GreetingManager类的内部声明delegate1变量     public GreetingDelegate delegate1;      public void GreetPeople(string name, GreetingDelegate MakeGreeting) {        MakeGreeting(name);     } } 现在，我们可以这样使用这个委托变量： static void Main(string[] args) {     GreetingManager gm = new  GreetingManager();     gm.delegate1 = EnglishGreeting;     gm.delegate1 += ChineseGreeting;     gm.GreetPeople(\"Jimmy Zhang\", gm.delegate1); } 输出为： Morning, Jimmy Zhang 早上好, Jimmy Zhang 尽管这样做没有任何问题，但我们发现这条语句很奇怪。在调用gm.GreetPeople方法的时候，再次传递了gm的delegate1字段： gm.GreetPeople(\"Jimmy Zhang\", gm.delegate1); 既然如此，我们何不修改 GreetingManager 类成这样： public class GreetingManager{     //在GreetingManager类的内部声明delegate1变量     public GreetingDelegate delegate1;      public void GreetPeople(string name) {         if(delegate1!=null){     //如果有方法注册委托变量           delegate1(name);      //通过委托调用方法        }     } } 在客户端，调用看上去更简洁一些： static void Main(string[] args) {     GreetingManager gm = new  GreetingManager();     gm.delegate1 = EnglishGreeting;     gm.delegate1 += ChineseGreeting;     gm.GreetPeople(\"Jimmy Zhang\");      //注意，这次不需要再传递 delegate1变量 } 输出为： Morning, Jimmy Zhang 早上好, Jimmy Zhang 尽管这样达到了我们要的效果，但是还是存在着问题： 在这里，delegate1和我们平时用的string类型的变量没有什么分别，而我们知道，并不是所有的字段都应该声明成public，合适的做法是应该public的时候public，应该private的时候private。 我们先看看如果把 delegate1 声明为 private会怎样？结果就是：这简直就是在搞笑。因为声明委托的目的就是为了把它暴露在类的客户端进行方法的注册，你把它声明为private了，客户端对它根本就不可见，那它还有什么用？ 再看看把delegate1 声明为 public 会怎样？结果就是：在客户端可以对它进行随意的赋值等操作，严重破坏对象的封装性。 最后，第一个方法注册用“=”，是赋值语法，因为要进行实例化，第二个方法注册则用的是“+=”。但是，不管是赋值还是注册，都是将方法绑定到委托上，除了调用时先后顺序不同，再没有任何的分别，这样不是让人觉得很别扭么？ 现在我们想想，如果delegate1不是一个委托类型，而是一个string类型，你会怎么做？答案是使用属性对字段进行封装。 于是，Event出场了，它封装了委托类型的变量，使得：在类的内部，不管你声明它是public还是protected，它总是private的。在类的外部，注册“+=”和注销“-=”的访问限定符与你在声明事件时使用的访问符相同。 我们改写GreetingManager类，它变成了这个样子： public class GreetingManager{     //这一次我们在这里声明一个事件     public event GreetingDelegate MakeGreet;     public void GreetPeople(string name) {         MakeGreet(name);     } } 很容易注意到：MakeGreet 事件的声明与之前委托变量delegate1的声明唯一的区别是多了一个event关键字。看到这里，在结合上面的讲解，你应该明白到：事件其实没什么不好理解的，声明一个事件不过类似于声明一个进行了封装的委托类型的变量而已。 为了证明上面的推论，如果我们像下面这样改写Main方法： static void Main(string[] args) {     GreetingManager gm = new  GreetingManager();     gm.MakeGreet = EnglishGreeting;         // 编译错误1     gm.MakeGreet += ChineseGreeting;     gm.GreetPeople(\"Jimmy Zhang\"); } 会得到编译错误：事件“Delegate.GreetingManager.MakeGreet”只能出现在 += 或 -= 的左边(从类型“Delegate.GreetingManager”中使用时除外)。 事件和委托的编译代码 这时候，我们注释掉编译错误的行，然后重新进行编译，再借助Reflactor来对 event的声明语句做一探究，看看为什么会发生这样的错误： public event GreetingDelegate MakeGreet; 可以看到，实际上尽管我们在GreetingManager里将 MakeGreet 声明为public，但是，实际上MakeGreet会被编译成 私有字段，难怪会发生上面的编译错误了，因为它根本就不允许在GreetingManager类的外面以赋值的方式访问，从而验证了我们上面所做的推论。 我们再进一步看下MakeGreet所产生的代码： private GreetingDelegate MakeGreet; //对事件的声明 实际是 声明一个私有的委托变量   [MethodImpl(MethodImplOptions.Synchronized)] public void add_MakeGreet(GreetingDelegate value){     this.MakeGreet = (GreetingDelegate) Delegate.Combine(this.MakeGreet, value); } [MethodImpl(MethodImplOptions.Synchronized)] public void remove_MakeGreet(GreetingDelegate value){     this.MakeGreet = (GreetingDelegate) Delegate.Remove(this.MakeGreet, value); } 现在已经很明确了：MakeGreet事件确实是一个GreetingDelegate类型的委托，只不过不管是不是声明为public，它 总是被声明为private。另外，它还有两个方法，分别是add_MakeGreet和remove_MakeGreet，这两个方法分别用于注册委托类型的方法和取消注册。实际上也就是： “+= ”对应 add_MakeGreet，“-=”对应remove_MakeGreet。而这两个方法的访问限制取决于声明事件时的访问限制符。 在add_MakeGreet()方法内部，实际上调用了System.Delegate的Combine()静态方法，这个方法用于将当前的变量添加到委托链表中。我们前面提到过两次，说委托实际上是一个类，在我们定义委托的时候： public delegate void GreetingDelegate(string name); 当编译器遇到这段代码的时候，会生成下面这样一个完整的类： public sealed class GreetingDelegate:System.MulticastDelegate{     public GreetingDelegate(object @object, IntPtr method);     public virtual IAsyncResult BeginInvoke(string name, AsyncCallback callback, object @object);     public virtual void EndInvoke(IAsyncResult result);     public virtual void Invoke(string name); } 关于这个类的更深入内容，可以参阅《CLR Via C#》等相关书籍，这里就不再讨论了。 委托、事件与Observer设计模式 范例说明 上面的例子已不足以再进行下面的讲解了，我们来看一个新的范例，因为之前已经介绍了很多的内容，所以本节的进度会稍微快一些： 假设我们有个高档的热水器，我们给它通上电，当水温超过95度的时候：1、扬声器会开始发出语音，告诉你水的温度；2、液晶屏也会改变水温的显示，来提示水已经快烧开了。 现在我们需要写个程序来模拟这个烧水的过程，我们将定义一个类来代表热水器，我们管它叫：Heater，它有代表水温的字段，叫做 temperature；当然，还有必不可少的给水加热方法BoilWater()，一个发出语音警报的方法MakeAlert()，一个显示水温的方法，ShowMsg()。 namespace Delegate {     class Heater {     private int temperature; // 水温     // 烧水     public void BoilWater() {         for (int i = 0; i <= 100; i++) {            temperature = i;            if (temperature > 95) {                MakeAlert(temperature);                ShowMsg(temperature);             }         }     }     // 发出语音警报     private void MakeAlert(int param) {        Console.WriteLine(\"Alarm：嘀嘀嘀，水已经 {0} 度了：\" , param);     }         // 显示水温     private void ShowMsg(int param) {        Console.WriteLine(\"Display：水快开了，当前温度：{0}度。\" , param);     } } class Program {     static void Main() {        Heater ht = new Heater();        ht.BoilWater();     } } } Observer设计模式简介 上面的例子显然能完成我们之前描述的工作，但是却并不够好。现在假设热水器由三部分组成：热水器、警报器、显示器，它们来自于不同厂商并进行了组装。那么，应该是热水器仅仅负责烧水，它不能发出警报也不能显示水温；在水烧开时由警报器发出警报、显示器显示提示和水温。 这时候，上面的例子就应该变成这个样子：    // 热水器 public class Heater {     private int temperature;             // 烧水     private void BoilWater() {        for (int i = 0; i <= 100; i++) {            temperature = i;         }     } } // 警报器 public class Alarm{     private void MakeAlert(int param) {        Console.WriteLine(\"Alarm：嘀嘀嘀，水已经 {0} 度了：\" , param);     } } // 显示器 public class Display{     private void ShowMsg(int param) {        Console.WriteLine(\"Display：水已烧开，当前温度：{0}度。\" , param);     } } 这里就出现了一个问题：如何在水烧开的时候通知报警器和显示器？在继续进行之前，我们先了解一下Observer设计模式，Observer设计模式中主要包括如下两类对象： Subject：监视对象，它往往包含着其他对象所感兴趣的内容。在本范例中，热水器就是一个监视对象，它包含的其他对象所感兴趣的内容，就是temprature字段，当这个字段的值快到100时，会不断把数据发给监视它的对象。 Observer：监视者，它监视Subject，当Subject中的某件事发生的时候，会告知Observer，而Observer则会采取相应的行动。在本范例中，Observer有警报器和显示器，它们采取的行动分别是发出警报和显示水温。 在本例中，事情发生的顺序应该是这样的： 警报器和显示器告诉热水器，它对它的温度比较感兴趣(注册)。 热水器知道后保留对警报器和显示器的引用。 热水器进行烧水这一动作，当水温超过95度时，通过对警报器和显示器的引用，自动调用警报器的MakeAlert()方法、显示器的ShowMsg()方法。 类似这样的例子是很多的，GOF对它进行了抽象，称为Observer设计模式：Observer设计模式是为了定义对象间的一种一对多的依赖关系，以便于当一个对象的状态改变时，其他依赖于它的对象会被自动告知并更新。Observer模式是一种松耦合的设计模式。 实现范例的Observer设计模式 我们之前已经对委托和事件介绍很多了，现在写代码应该很容易了，现在在这里直接给出代码，并在注释中加以说明。 using System; using System.Collections.Generic; using System.Text; namespace Delegate {     // 热水器     public class Heater {        private int temperature;        public delegate void BoilHandler(int param);   //声明委托        public event BoilHandler BoilEvent;        //声明事件        // 烧水        public void BoilWater() {            for (int i = 0; i <= 100; i++) {               temperature = i;               if (temperature > 95) {                   if (BoilEvent != null) { //如果有对象注册                       BoilEvent(temperature);  //调用所有注册对象的方法                   }               }            }        }     }     // 警报器     public class Alarm {        public void MakeAlert(int param) {            Console.WriteLine(\"Alarm：嘀嘀嘀，水已经 {0} 度了：\", param);        }     }     // 显示器     public class Display {        public static void ShowMsg(int param) { //静态方法            Console.WriteLine(\"Display：水快烧开了，当前温度：{0}度。\", param);        }     }         class Program {        static void Main() {            Heater heater = new Heater();            Alarm alarm = new Alarm();            heater.BoilEvent += alarm.MakeAlert;    //注册方法            heater.BoilEvent += (new Alarm()).MakeAlert;   //给匿名对象注册方法            heater.BoilEvent += Display.ShowMsg;       //注册静态方法            heater.BoilWater();   //烧水，会自动调用注册过对象的方法        }     } } 输出为： Alarm：嘀嘀嘀，水已经 96 度了： Alarm：嘀嘀嘀，水已经 96 度了： Display：水快烧开了，当前温度：96度。 // 省略... .Net Framework中的委托与事件 尽管上面的范例很好地完成了我们想要完成的工作，但是我们不仅疑惑：为什么.Net Framework 中的事件模型和上面的不同？为什么有很多的EventArgs参数？ 在回答上面的问题之前，我们先搞懂 .Net Framework的编码规范： 委托类型的名称都应该以EventHandler结束。 委托的原型定义：有一个void返回值，并接受两个输入参数：一个Object 类型，一个 EventArgs类型(或继承自EventArgs)。 事件的命名为 委托去掉 EventHandler之后剩余的部分。 继承自EventArgs的类型应该以EventArgs结尾。 再做一下说明： 委托声明原型中的Object类型的参数代表了Subject，也就是监视对象，在本例中是 Heater(热水器)。回调函数(比如Alarm的MakeAlert)可以通过它访问触发事件的对象(Heater)。 EventArgs 对象包含了Observer所感兴趣的数据，在本例中是temperature。 上面这些其实不仅仅是为了编码规范而已，这样也使得程序有更大的灵活性。比如说，如果我们不光想获得热水器的温度，还想在Observer端(警报器或者显示器)方法中获得它的生产日期、型号、价格，那么委托和方法的声明都会变得很麻烦，而如果我们将热水器的引用传给警报器的方法，就可以在方法中直接访问热水器了。 现在我们改写之前的范例，让它符合 .Net Framework 的规范： using System; using System.Collections.Generic; using System.Text; namespace Delegate {     // 热水器     public class Heater {        private int temperature;        public string type = \"RealFire 001\";       // 添加型号作为演示        public string area = \"China Xian\";         // 添加产地作为演示        //声明委托        public delegate void BoiledEventHandler(Object sender, BoiledEventArgs e);        public event BoiledEventHandler Boiled; //声明事件        // 定义BoiledEventArgs类，传递给Observer所感兴趣的信息        public class BoiledEventArgs : EventArgs {            public readonly int temperature;            public BoiledEventArgs(int temperature) {               this.temperature = temperature;            }        }        // 可以供继承自 Heater 的类重写，以便继承类拒绝其他对象对它的监视        protected virtual void OnBoiled(BoiledEventArgs e) {            if (Boiled != null) { // 如果有对象注册               Boiled(this, e);  // 调用所有注册对象的方法            }        }               // 烧水。        public void BoilWater() {            for (int i = 0; i <= 100; i++) {               temperature = i;               if (temperature > 95) {                   //建立BoiledEventArgs 对象。                   BoiledEventArgs e = new BoiledEventArgs(temperature);                   OnBoiled(e);  // 调用 OnBolied方法               }            }        }     }     // 警报器     public class Alarm {        public void MakeAlert(Object sender, Heater.BoiledEventArgs e) {            Heater heater = (Heater)sender;     //这里是不是很熟悉呢？            //访问 sender 中的公共字段            Console.WriteLine(\"Alarm：{0} - {1}: \", heater.area, heater.type);            Console.WriteLine(\"Alarm: 嘀嘀嘀，水已经 {0} 度了：\", e.temperature);            Console.WriteLine();        }     }     // 显示器     public class Display {        public static void ShowMsg(Object sender, Heater.BoiledEventArgs e) {   //静态方法            Heater heater = (Heater)sender;            Console.WriteLine(\"Display：{0} - {1}: \", heater.area, heater.type);            Console.WriteLine(\"Display：水快烧开了，当前温度：{0}度。\", e.temperature);            Console.WriteLine();        }     }     class Program {        static void Main() {            Heater heater = new Heater();            Alarm alarm = new Alarm();            heater.Boiled += alarm.MakeAlert;   //注册方法            heater.Boiled += (new Alarm()).MakeAlert;      //给匿名对象注册方法            heater.Boiled += new Heater.BoiledEventHandler(alarm.MakeAlert);    //也可以这么注册            heater.Boiled += Display.ShowMsg;       //注册静态方法            heater.BoilWater();   //烧水，会自动调用注册过对象的方法        }     } } 输出为： Alarm：China Xian - RealFire 001: Alarm: 嘀嘀嘀，水已经 96 度了： Alarm：China Xian - RealFire 001: Alarm: 嘀嘀嘀，水已经 96 度了： Alarm：China Xian - RealFire 001: Alarm: 嘀嘀嘀，水已经 96 度了： Display：China Xian - RealFire 001: Display：水快烧开了，当前温度：96度。 // 省略 ...   原文:http://wenku.baidu.com/view/80af4e61ddccda38376baf8b.html","title":"C# 中的委托和事件"},{"content":"所谓多例模式，实际上就是单例模式的自然推广，单例类一般情况下只可以有一个实例，但单例类也可以推广到允许有限个实例，这种模式就是多例模式。作为对象的创建模式，多例模式有以下特点：       多例类可以有多个实例。       多例类必须自己创建、管理自己的实例，并向外界提供自己的实例。       多例类分为有上限多例类与无上限多例类。       一个有上限的多例类已经把实例的上限当作逻辑的一部分，并建造到了多例类的内部。如下： public class Multiton {       private static Multiton instance1=null;       private static Multiton instance2=null;       private Multiton() { }       public static Multiton getInstance(int whichOne)       {             if(whichOne==1)             {                   if(instance1==null)                   {                        instance1=new Multiton ();                   }                   return instance1;             }             else             {                   if(instance2==null)                   {                         instance2=new Multiton ();                   }                   return instance2;             }       } } 多例类的实例数目不需要有上限，实例数目没有上限的多例模式就叫做无上限多例模式。","title":"java_23种设计模式之多例模式"},{"content":"单例，顾名思义，就是在整个系统中只有一个实例，就是单一、独苗的意思。 单例模式有三个要点： 一是某个类只能有一个实例； 二是它必须自行创建这个实例； 三是它必须自行向整个系统提供这个实例。 其中该类我们称之为：单例类。 持有单例对象的客户类，共享同一个单例对象，对其中的单例资源拥有同样的操作权限。比如邮局里的电话簿只有一本，有需要的人就拿来看，没有必要每个人要查的时候工作人员就重新拿出新的一本出来，看完了再回收。。。 使用单例模式的时机可以是：当实例存在多个会引起程序逻辑错误的时候，比如类似有序的号码生成器这样的东西，不可能让号码生成器从在多个。 具体实例如下： 1.预先加载法 class S1 {  private S1() {  System.out.println(\"ok1\");   }    private finalstatic S1 instance =new S1();      publicstatic S1 getInstance() {         return instance;    }  }  优点：  1.线程安全的 2.在类加载的同时已经创建好一个静态对象,调用时反应速度快。 缺点： 资源利用效率不高，可能getInstance永远不会执行到，但是执行了该类的其他静态方法或者加载了该类（class.forName），那么这个实例仍然初始化了 2.initialization on demand,延迟加载法  (考虑多线程) class S2 {    private S2() {     System.out.println(\"ok2\");    }    privatestatic S2 instance =null;     publicstaticsynchronized S2 getInstance() {     if (instance ==null) instance =new S2();        return instance;    }   }  优点：资源利用率高,不执行getInstance就不会被实例，可以执行该类其他静态方法。 缺点： 第一次加载时发应不快  ，多线程使用不必要的同步开销大 3.initialization on demand double check 双重检测(考虑多线程) class S3 {     private S3() {     System.out.println(\"ok3\");    }      privatestatic S3 instance =null;      publicstatic S3 getInstance() {         if (instance ==null) {            synchronized (S3.class) {                if (instance ==null)                    instance = new S3();            }       }       return instance;    }   }  优点：资源利用率高, 不执行getInstance就不会被实例，可以执行该类其他静态方法。 缺点： 第一次加载时发应不快  ，由于java 内存模型一些原因偶尔会失败 4.initialization on demand holder  (考虑多线程) class S4 {    private S4() {      System.out.println(\"ok4\");    }    private static class S4Holder {       static S4 instance = new S4();   }        public static S4 getInstance() {     return S4Holder.instance;    }   }    优点：资源利用率高, 不执行getInstance就不会被实例，可以执行该类其他静态方法。 缺点： 第一次加载时发应不快    ","title":"java_23种设计模式之单例模式"},{"content":"简单代码示例如下： /************************************************************************/ /* 文件名：prototype.h ** 描述： prototype模式提供了一个根据已存在对象创建新对象的接口 ** 作者：zhoujj ** 时间：2012/11/18 ************************************************************************/ #ifndef _PROTOTYPE_H #define _PROTOTYPE_H class Prototype { public: virtual ~Prototype(); virtual Prototype* clone() const = 0; protected: Prototype(); }; class ConcretePrototype: public Prototype { public: ConcretePrototype(); ConcretePrototype(const ConcretePrototype & cp); ~ConcretePrototype(); Prototype * clone() const; }; #endif //prototype.c #include \"Prototype.h\" #include <iostream> using namespace std; Prototype::Prototype() { } Prototype::~Prototype() { } Prototype* Prototype::clone() const  { return 0; } ConcretePrototype::ConcretePrototype() { cout<<\"ConcretePrototype constructing...\"<<endl; } ConcretePrototype::ConcretePrototype(const ConcretePrototype &cp) { cout<<\"copy the ConcretePrototype...\"<<endl; } ConcretePrototype::~ConcretePrototype() { cout<<\"delete ConcretePrototype\"<<endl; } Prototype* ConcretePrototype::clone() const { return new ConcretePrototype(*this); } //main.c #include \"Prototype.h\" #include <iostream> using namespace std; int main() { Prototype * pro = new ConcretePrototype(); Prototype * newPro = pro->clone(); delete pro; pro = NULL; delete newPro; newPro = NULL; return 0; }","title":"设计模式-Prototype模式"},{"content":"什么是代理模式呢？我很忙，忙的没空理你，那你要找我呢，就先找我的代理人吧，那代理人总要知道被代理人能做哪些事情不能做哪些事情吧，那就是两个人具备同一个接口，代理人虽然不能干活，但是被代理的人能干活。 被代理人和被代理人继承同一个接口（抽象角色）：声明真实对象和代理对象的共同接口； 真实对象：实际上干活的那个人。 代理对象：代理对象内部包含对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，有相当于对真实对象进行了一次封装。 示例代码如下： 1.同一接口 package model; /**  * 代理模式接口_抽象角色  * @author 张义  *  */ public interface AgencyInterface {  /**   * 代理方法   */  public void add(); } 2. package model.impl; import model.AgencyInterface; /**  * 真实角色1  * @author 张义  *  */ public class RealObjectImpl1 implements AgencyInterface{  /**   * 实现代理方法   */  public void add() {   System.out.println(this.getClass().getName() + \"执行代理方法\");  } } 3. package model.impl; import model.AgencyInterface; /**  * 真实角色2  * @author 张义  *  */ public class RealObjectImpl2 implements AgencyInterface {  /**   * 实现代理方法   */  public void add() {   System.out.println(this.getClass().getName() + \"执行代理方法\");  } } 4.代理人角色 package model.impl; import model.AgencyInterface; /**  * 代理角色  * @author 张义  *  */ public class AgencyObject implements AgencyInterface {    private AgencyInterface ai;  public AgencyObject(AgencyInterface ai){   this.ai = ai;  }  public AgencyObject(){   this.ai = new RealObjectImpl1();  }  /**   * 实现代理方法   */  public void add() {   ai.add();  } } 5. package model.main; import model.impl.AgencyObject; import model.impl.RealObjectImpl2; /**  * 客户端  * @author 张义  *  */ public class Main {  public static void main(String[] args) {   // 代理方式1   AgencyObject ao1 = new AgencyObject();   ao1.add();   //代理方式2   AgencyObject ao2 = new AgencyObject(new RealObjectImpl2());   ao2.add();  } } 6.代理模式主要使用了Java 的多态，干活的是被代理类，代理类主要是接活，你让我干活，好，我交给幕后的类去干，你满意就成，那怎么知道被代理类能不能干呢？同根就成，大家知根知底，你能做啥，我能做啥都清楚的很，因为我们继承同一个接口。    ","title":"java_23种设计模式之代理模式"},{"content":"关于设计模式至今理解不是很深，在此发表文章一方面为了加深对设计模式的理解，另一方面希望由此与大家进行交流。 今天研究了一下策略模式，对策略模式理解为：通过对抽象策略角色（抽象类、接口）的实现的包装，从未进行动态操作的过程。 详细解释如下： 1.抽象策略角色：策略类，包含要做的事情（方法），通常有抽象类或接口进行实现； 2.策略类的实现：包装了对要做的事情的具体做法和行为； 3.动态操作：持有对策略类的引用，从而可以动态选择需要的实现，最终交给某一客户端进行调用。 对于策略模式来说，核心的部分是持有对策略类的引用。 具体代码示例如下： 1./**策略类*/   public interface IStrategy { /**策略方法*/ public abstract double add(); } 2./**策略类的实现，以下写了两个实现*/ public class ConcreteStrategy1 implements IStrategy { /**示意性算法*/ public double add() { // TODO 自动生成方法存根 System.out.println(this.getClass().getName() + \"的加法运算\"); return 0; } } public class ConcreteStrategy2 implements IStrategy { public double add() { // TODO 自动生成方法存根 System.out.println(this.getClass().getName() + \"的加法运算\"); return 0; } } 3./**对策略类的引用*/ public class Context { /**环境角色类*/ private IStrategy strategy; public Context(IStrategy strategy) { this.strategy = strategy; } /**策略方法*/ public double add() { this.strategy.add(); return 0; } } 4./**客户端调用*/ public class Main { /** *@paramargs */ public static void main(String[] args) { // TODO 自动生成方法存根 Context context = new Context(new ConcreteStrategy1()); context.add();//执行算法1 context = new Context(new ConcreteStrategy2()); context.add();//执行算法2 } } 5.执行结果如下： ConcreteStrategy1的加法运算 ConcreteStrategy2的加法运算 6.总结： 优点：可以动态的选择需要的实现； 缺点：需要自行去决定需要那些实现，即必须对每个实现类熟悉。      ","title":"java_23种设计模式之策略模式"},{"content":"今天学习了C++设计模式的工厂模式，提供的示例代码比较简单，但足以说明工厂模式是怎么实现的。 工厂模式的两个特点：         1、工厂模式封装了创造对象的接口         2、将对象的创建延迟到子类，具体的实例化由子类提供。 示例代码如下： //product.h #ifndef _PRODUCT_H #define _PRODUCT_H class Product { public: virtual ~Product() = 0; protected: Product(); }; class ConcreteProduct :public Product { public: ConcreteProduct(); ~ConcreteProduct(); }; #endif //product.c #include \"factory.h\" #include \"product.h\" #include <iostream> using namespace std; Factory::Factory() { } Factory::~Factory() { } ConcreteFactory::ConcreteFactory() { cout<<\"this is ConcreteFactory\"<<endl; } ConcreteFactory::~ConcreteFactory() { } Product* ConcreteFactory::CreateProduct() { return new ConcreteProduct(); } //factory.h #ifndef _FACTORY_H #define _FACTORY_H class Product; class Factory { public: virtual ~Factory() =0; virtual Product* CreateProduct()=0; protected: Factory(); }; class ConcreteFactory: public Factory { public: ConcreteFactory(); ~ConcreteFactory(); Product* CreateProduct(); }; #endif //factory.c #include \"factory.h\" #include \"product.h\" #include <iostream> using namespace std; Factory::Factory() { } Factory::~Factory() { } ConcreteFactory::ConcreteFactory() { cout<<\"this is ConcreteFactory\"<<endl; } ConcreteFactory::~ConcreteFactory() { } Product* ConcreteFactory::CreateProduct() { return new ConcreteProduct(); } 在这里为子类ConcreteProduct实现了自己的ConcreteFactory工厂，如果有更多的子类，可以为具体的子类实现自己的创建对象工厂，也可以在原有工厂类的基础上，让创建对象接口参数化，根据具体的参数，创建对应的对象。","title":"设计模式-工厂模式"},{"content":"  上回的最后，来了两个用户，分别提出了两个不同的需求。一个要求用两个开关控制一个灯，一个要求用一个开关控制所有的灯。本回将就这两个需求进行分析。我写这段话的时候并没有想出这个需求的具体方案，重要的过程，思路有时候比结果更重要。所以，我的方案可能会\"跑偏\"；但是如果你能从过程中体会到些什么，那这篇就没有白写。       两个开关控制一个灯。这个问题好像很简单，把两个Switcher的Switchee都设置为同一个灯不就结了吗？画个对象图会是这个样子。   图1 由双开关控制的灯     有问题吗？ 用户的真实需求      考虑一下这个问题。如果你用Switcher1开了灯，再去开一下Switcher2，灯应该是保持开着还是关了呢？从技术人员的角度来讲，调用的Switcher的开，当然应该保持开啦。但是策划会说，这两个开关应该是相互作用的，还拿出了电路图给我看。这是的确是张真实情况下的双开关电路图。 图2 双路开关电路      Switcher1的开关，拨到左边是开还是关，取决于Switcher2现在是拨在左边儿还是右边。电路图的天然连通性就自然而然地做到了这一点。现实中的Switcher1不会去问Switcher2：嘿，哥们，你现在是个啥状态？而我们的代码中的两个Switcher间也不应该有什么交集。      总而言之，在这个需求的要求下，用户要做的，就是拨一下开关而已（图3中JustSwitch方法的作用）。 对当前设计的改进      在以上需求的约束下，就第一篇开始所写的Switcher而言，就会存在着一个问题。先不说双开关，单单一个开关我们的设计就是不符合产品策划的要求。因为之前写的Switcher类是有两个函数作开关控制的。 public class Switcher {     public ISwitchable Switchee { get; set; }     public void TurnOn() { Switchee.TurnOn(); }     public void TurnOff() { Switchee.TurnOff(); } } 代码1      这是有问题的。因为Switcher是直接给用户用的。你觉得用户是想用哪种开关呢？ 是 还是 呢？      总不能让用户根据现在灯是开着还是关着让用户按不同的按钮。（使用不同的函数。）所以Switcher的代码应该是这个样子的。 public class Switcher {     private bool isOn;     public ISwitchable Switchee { get; set; }     public void JustSwitch()   {     // 根据当前状态选择正确的操作。     if (isOn)     {         Switchee.TurnOff();         isOn = false;     }     else     {         Switchee.TurnOn();         isOn = true;     }   } } 代码2      Switcher自己保存最后一次操作的结果（当前状态），并自动选择正确的操作。 支持双开关      当每个灯只有一个开关的时候，这个代码没有任何问题。但是出现两个开关的话就没这么好办了，自己保存的状态是无效的，可能会被另一个开关改掉。如果要达到和电路图一样的效果，Switcher1要么问Switcher2现在是什么状态，要么问Light是什么状态。      直觉上，问Switcher2这事儿不是个好选择，因为以后还可能会有Switcher3、4。但灯就一个。但是等等，我们现在的接口是什么样的？   图3. 现在的设计       ISwitchable接口只定义了TurnOn和TurnOff两个函数，没有可以用于查询灯的当前状态的方法。这太糟糕了，这意味着接口要改了。改接口永远是最糟糕的事情。《软件框架设计的艺术》里说\"API就如同恒星，一旦出现，便与我们永恒存在。\"，听上去接口写了就不能改，但是我们的情况要好很多，这个接口是公司自己定义的，没有别人用过。所以改改无妨。J只要小小的加一个方法就可以了。   图4. 添加查询接口以支持双开关       Switcher的代码会是这样的。Switcher暴露给用户的应该只有 一个接口。 public interface ISwitchable {     void TurnOn();     void TurnOff();     bool IsOn(); }   public class Switcher {     public ISwitchable Switchee { get; set; }       public void JustSwitch()     {         // 根据当前状态选择正确的操作。         if (Switchee.IsOn())             Switchee.TurnOff();         else             Switchee.TurnOn();     } } 代码3 另一个极品方案      软件开发与建筑施工的最大区别是，软件开发可以选择先盖地下室还是天花板。 ——我      当我们把要做的事情抽象一下，就能很容易地从更高的层次思考问题。比如上面，开关要知道灯的状态。可以抽象为： 图5. 开关开灯例子的高度抽象      各位可以想到什么设计上的问题？比较明显的问题有两个。 拉模式 VS推模式。既然图中为拉模式，那么另一个思路就是推模式。也许你听说一个说法，就是推模式比拉模式要好。但是如果真把推模式用在开关开灯的例子上，就成了灯的亮与熄，要去通知开关，以便开关下次Switch的时候，能做出正确地动作。想到这里，我邪恶地笑了。这得多蛋痛啊？模式的应用，永远要看上下文。为了抚慰一些推模式死忠们脆弱的心灵，下面会介绍一个可行的推模式开灯设计。 A依赖B。虽然我们有ISwitchable接口，开关不直接依赖灯，但是你看，我们为什么要在ISwitchable接口里加入IsOn函数呢？因为开关需要知道灯的状态。所以说，他们之间不但存在着依赖，而且还直接决定了接口的定义。但是与我第一篇文章中介绍的DIP原则是否冲突呢？这取决于你对开关的定位。如果只是单纯的开关，那么IsOn函数的引入，就是对灯的功能的抽象，也就违反了DIP原则；如果你希望开关有点儿AI，那么显然它得知道更多的信息（但是这违反了单一责任原则）。所以看上去，无论从哪个角度来讲，IsOn的引入都是要违反XXXX原则的。      好，为了不违反所有现有的原则。构想出设计出如下的设计：   图6. 引入AI系统对开关操作进行决策（拉模式）        理智一些吧，我们的开关公司没有上市，既没有资本做AI系统，也没有卡马克这种不要钱只要汉堡和网络的技术狂人，我们的用户也不会像暗黑的死忠一样傻等10年，然后等到一个需要接网线才能使用的电灯开关还能用得很愉悦。在这个发展阶段要做的，只是尽快满足当前的需求。      在达成需求前，技术方案的完美度，永远是第二位的。第一位的，是有效率地执行 + 新颖的思路和方向。思路放后面，是因为对99.9%的情况来说，最不值钱的就是点子，你能想到的，别人可能都已经做出来了。即使是Jobs这种用新意折服世界的人，也要靠\"现实扭曲力场\"的帮助把自己的观点有效地推行下去。 所以，这个方案虽然很不错，但是我不愿意继续讨论了，因为这在现实中没有意义，脱离现实的例子也就不再是好例子了。      我还想说一句，做项目和做人，都不能走极端。另一个极端是：以敏捷之名，无视一切编码前的设计。我猜这在群人眼中，这个系列的文章没有任何意义。 ———————————————————牢骚的休止符————————————————————— 再一个方案      有人可能会说，让灯自己控制自己的状态，也可以解决问题。像下面这样。   图7 另一种解决方案      然后把Light类实现成这个样子：（多酷啊，目前为止代码量最少的方案） public class Light : ISwitchable {     private bool isGlowing;       public void JustSwitch()     {         isGlowing = !isGlowing;     } } 代码 4      这个设计的确可行，但是哪个方案更好呢？这个问题就留给各位读者吧。就拿几个Principle逐个分析下应该就可以分析出个所以然来。（下一节有简单提示） 设计思想（原则）及技术方案的滥用       每种设计都有他的思路和道理。你觉得不可理喻的设计可能恰恰是别人深思熟虑的结果，只是每个人的思路不一样，结果自然也不相同。但是如果设计思路被某种设计思想占据了绝对主导的地位，就可能会出现设计上的偏差。      我把滥用大体上总结成如下三种： 单纯的滥用。因为我会这么做，所以就顺便这么做了。他们的理论基础是：虽然现在没有这要的需求，谁知道以后有没有呢？我多做一点儿还不好？最典型的症状是，所有的类，都有相应的接口，全部使用Dependency Injection来实例化。这不是有病么？      这会引出一个比较大的话题，就是怎样的设计算是过度设计？这需要单独写一节来讨论这个问题。就不在这里展开了。 程度上的滥用。图7的设计，就体现了一个叫做\"Tell, Don't Ask\"的原则，或者说是为了将这个原则\"发挥到极致\"而形成的设计。而在这个原则之下写出的代码4又是如此简洁和优美；以至于让想出这个方案的人，很难主动抛弃这个方案。直到看到这个方案不能满足的需求才肯承认问题。 适用范围滥用。把某个原则或是技术方案当万金油。只要能用得上，就一定要用上一用。导致一叶蔽目，不愿意寻求其它更加合适的技术方案（项目时间紧是个最常见的借口，一知道某个方案可行，就马上付诸行动）。一时兴起，画了个漫画。 图8. 因为熟悉或懒惰而舍近求远       第一篇就说过，优秀的设计不是藉由几个原则、模式就可以保证的。何况是某一个原则呢？物极必反。今天就不再啰嗦了。大家也都懂。设计过程中对某个特定的设计思想或是技术过于执着，往往会形成一个虽可行、却畸形的设计。图7即是一个例子。 一个真实的案例      有一家著名的咨询公司，2009年接了一个银行的大单，为期一年，预计可以赚到五个亿。但是这个项目现在都还没有结束，项目延期不仅要给银行赔偿，还要继续免费给银行把这个项目做完。（想想国内公司会怎么做？）2010-2011年度，公司接的其它项目赚的钱几乎全部贴给了这个项目。当年全公司员工没有奖金，部分相关高层降职降薪。      为什么？一个可以赚到五个亿的项目却亏了几个亿？      目前项目内员工的工作效率极低，一个普通开发者要两天才能完成一个报表的修改。（现阶段是修改，不是全新开发）。所以说人员成本非常大。项目拖上一个月，数百万就打了水漂。      那么效率为什么这么低？他们所有的业务逻辑都用PL-SQL实现，大的报表，涉及到的PL-SQL动辄上万行，而且层层调用，加之整个系统有数千个表。代码的测试，都要先去数据库造假数据。效率能高就怪了。      为什么要这么搞？因为一开始做系统设计的人，对PL-SQL比较熟悉，对Java不熟悉，所以就把Java当成了UI Wrapper来用。狗屎吧。当然还会有很多其它的因素，但是在技术层面，这绝对是重要因素之一。因为自己对某个技术比较熟悉，而不愿意在项目中了解和应用更适合的其它技术方案的人套上CTO之类的外衣，恒等于搅屎棍。 支持开关控制多个灯      简单而言，要让一个开关去控制所有的灯。听上去很简单，而且有很多种实现方式。但是如果仔细想想，会发现有很多问题。 需求分析，不同于简单的需求整理      用户给出的需求总会是很概括甚至模糊的，不是用户懒得说，而是用户觉得自己已经说清楚了。以开灯为例，用户需求就是：\"要有一个统一开关。\"，你如果再去追问用户，要怎么个统一法？用户可能就会不高兴了，因为他觉得这是你应该解决的问题。但是如果简单地把\"要有统一开关\"这个用户需求直接写进需求文档的话，就等着项目失败或是延期吧。     需求分析的第一步，就是要对用户的需求进行分解、细节，找出合理用例。比如：用户要求的是，要有统一开关，但是并没有说每个灯就没有自己的开关。如果每个灯又都有自己的开关，统一开关应该如何与各个专属开关协作呢？从这个角度，就可以找到一些用例。 两个灯，都开着。这时去按统一开关，应该是全关对吧。也就是说，统一开关应该知道当前灯的状态。并按当前灯的状态去执行操作。 三个灯，两个开着。这时去按统一开关呢？统一开关的意思就是要有统一的行为，用户肯定不会希望这个统一开关的行为是：把开着的灯关掉，把关着的灯打开。怎么办？统计现在开着的比率？开着的多就全关？那如果是两个灯，一个开着，一个关着呢？还有一个办法是，让统一开关使用代码2的方案：自己记住上次的操作结果。上次是全关，这次就全开；反之亦然。       也就是说，用例1和用例2都是合理的，但却是冲突的。这种冲突甚至是一种逻辑上的冲突，已经不是技术局限性的问题了。这种情况，在软件开发中也是很常见的。这时，我们拿着自己的分析、自己的想法去询问用户的意见，用户就会很乐意了。人们都喜欢做选择题，而不是做问答题。不是么？ 现实中的电路      现实中的电路图有两种做法。（非标准电路，请意会。强弱电相关专业也许可以参考这里）   图9. 现实中的两种简单的总控加分支开关电路      前一张图，分支开关有绝对的控制权；后一张图中开关中有一个二极管，开关的开合用于控制二极管的极性，总开关的作用就是：把开着的关掉，把关着的打开。      看上去就是两种开关嘛。 基于派生类的方案      为了让一个开关可以控制多个灯，对现有程序设计上的改动很小。类图如下：   图10. 多控开关设计      通过派生新的Switcher，来提供不同的功能。在当前的需求下，这个方案是可行的。未来的需求，就留给未来去解决吧。 小结       本节本来是想讲讲需求决定设计这个理念，从两个需求引出两个互不兼容的设计方案。所以找了两个需求一起讲，但是最后这两个需求并没多大的冲突，也就没有达到预期的目标。不过想说的倒是说出来了。就是项目的设计，最终还是要依赖于需求，任何要做出能够适应未来需求的设计的想法，都是不切实际、劳民伤财的。（不知道有多少人会把这句话曲解为\"设计无用论\"，如果我认为设计无用，还会写这个系列吗？）       这个系列并不是要讲设计模式，也不是用小例子做各种分析。只是想通过最简单的例子讲一些大道理（原则）。如果没有合适的大道理可说，分析出一百个需求、做出一百个设计，也只是鱼，而非我想说的渔。       距上节的发布也已经很久了，因为每回发表时，都会先想好下回写什么、怎么写，并结尾留个引子。这次很可惜，想好了下回写什么，却死活想不出合适的、简单的需求来引出这个问题，也就不知道怎么写了。所以下回什么能写好我也不知道。大体上，也许还会有下而一些道理希望能和大家分享： 过度设计及关于\"过度\"的度量。 局部设计最优化与全局次优化之间的权衡。 什么是设计经验及如何正确地借鉴。 新的用户      下一回讲哪个还没有讲好，但是用户的需求却如潮水般涌来。先权且记下： 在开关上加一个小灯，表示现在的灯是开还是关。（因为开关和灯可能并不在一起） 通过开关调节灯的亮度。 在开关上显示灯的耗电量、温度、预期寿命等。 定时开关。 开关声控、手势控。 开关权限控制。","title":"小例子背后的大道理——用户需求+设计原则+正确应用 =设计方案"},{"content":"小例子背后的大道理——从DIP中“倒置”的含义说接口的正确使用 提纲 开灯的例子 暗流涌动 Guru眼中的依赖 DIP（依赖倒置原则） 为什么要解耦合？ 接口的坏味道 同一张类图的不同解释——真假DIP 了解DIP有什么用？DIP用在什么地方？ 下回预告 参考文献 开灯的例子      选开灯做例子，是因为这个例子既常见又简单，而且潜在的需求多样。对于最简单的灯，从功能上讲，按下灯上的开关，灯就开了。      用代码实现这样一个有开关功能的灯，也是一件很容易的事情。 public class Light {     public void TurnOn() { Console.WriteLine(\"Light Turn On\"); }     public void TurnOff() { Console.WriteLine(\"Light Turn Off\"); } } 代码1      一个具有开关功能的灯就完成了。这个灯，功能完备、也满足当下的需求。一切美好。      直到有一天，有个客户说，灯上的开关坏了，能不能换一个？我才意识到这个灯的设计有问题——它的开关是换不了的。一面给用户解释，一面考虑着把灯和开关分开。      咱也是学过设计模式的人，知道要面向接口编程，绝不应该简单地把Light类拆解成Light和Switcher两个类。因为Switcher不应该依赖于具体实现，于是写出了下面的代码。   namespace Me.Lighting {     public interface ILightable     {         void ShowLight();         void HideLight();     }     public class Light : ILightable     {         public void ShowLight() { Console.WriteLine(\"Light Turn On\"); }         public void HideLight() { Console.WriteLine(\"Light Turn Off\"); }     } } namespace Me.Switch {     using Me.Lighting;       public class Switcher     {         public ILightable Light { get; set; }         public void TurnOn() { Light.ShowLight(); }         public void TurnOff() { Light.HideLight(); }     } } 代码 2      这个设计，不仅分离了灯和开关，甚至可以让这个开关灵活地控制要开关哪个灯。只要在开关前设置一下就可以，多方便。我自信满满地迁入了代码。      事实也证明这样的设计是成功的，产品的灵活设计得到了用户的认可，销量直线上升。       亲，请看下代码，在不使用什么别的设计模式的前提下，您觉得代码2有什么问题？无论是什么角度的都可以（当然，可能您的角度不是本文讨论的重点），最好先回复下留个底，别事后诸葛。      如果您一眼看到了问题，请直接阅读DIP那一节。 暗流涌动       公司壮大之后 ，开始考虑向收音机行业进军。而且公司希望，这种灵活的设计可以沿用下去，收音机和灯的开关应该可以通用，对用户而言，都是拨那么一下。       我听到这个信息也是相当兴奋，但是当我开始着手写代码时，发现一些坏味道，开关依赖于ILightable 接口，那么我的收音机不得不写成这个样子才能与现有的开关兼容。 public class Radio : ILightable {     public void ShowLight() { Console.WriteLine(\"Play radio\"); }     public void HideLight() { Console.WriteLine(\"Stop radio\"); } } 代码3      虽然可以工作，但是这是严重的坏味道。因为如果有一天，灯的接口变化，我却要连收音机的代码一起改。这种情况绝不应该出现。且不用把LSP（Liskov替换原则）搬出来说教，很显然Radio其实并没有完成ILightable所定义的功能——发光。无论从哪个角度讲都是错的。      一个可行的设计是，让开关支持收音机的开启和停止。像下面这样。 namespace Me.Radio {     public interface IRadio     {         void Play();         void Stop();     }     public class Radio : IRadio     {         public void Play() { Console.WriteLine(\"Play radio\"); }         public void Stop() { Console.WriteLine(\"Stop radio\"); }     } } namespace Me.Switch {     using Me.Lighting;     using Me.Radio;       public class Switcher     {         public ILightable Light { get; set; }         public IRadio Radio { get; set; }         public void TurnOn()         {             if (Light != null) Light.ShowLight();             else if (Radio != null) Radio.Play();         }         public void TurnOff() { Light.HideLight(); }     } } 代码4      我看来看去都觉得这个代码太恶心了，因为Switcher的实现方式违反了OCP（开放—封闭原则），如果这样发展下去，公司的产品越丰富，这坨代码就越难以维护。我的末日也就越近。      于是我的考虑Switcher的设计是不是有问题，我已经用上面向接口编程了，为什么还是有问题呢？ Guru眼中的依赖       我把代码发给了我的导师，一个设计Guru，他看完之后哭笑着说，你的基本功很扎实，理论知识也很全面，可惜却缺乏一定的经验。面向接口编程没有错，但是更重要的是模型的建立。      简单而言，你的开关的依赖关系错了。问你一个问题你就明白了，开关为什么要依赖ILightable呢？但是好在你有一定的设计基础，知道要提取出一个接口，所以要改成正确的设计也非常容易。你只需要把ILightable这个接口的名字改成ISwitchable，再把接口方法名字改下，并把它与Switcher放一起就行了。     听罢，我恍然大悟。原来接口的名字和位置，也会给使用者带来如此大的困扰。在先进的开发工具的帮助下，瞬间就完成了这个简单的重命名和移动操作。现在的代码像这个样子了。 namespace Me.Lighting {     using Me.Switch;     public class Light : ISwitchable     {         public void TurnOn() { Console.WriteLine(\"Light Turn On\"); }         public void TurnOff() { Console.WriteLine(\"Light Turn Off\"); }     } } namespace Me.Radio {     using Me.Switch;     public class Radio : ISwitchable     {         public void TurnOn() { Console.WriteLine(\"Play radio\"); }         public void TurnOff() { Console.WriteLine(\"Stop radio\"); }     } } namespace Me.Switch {     public interface ISwitchable     {         void TurnOn();         void TurnOff();     }     public class Switcher     {         public ISwitchable Switchee { get; set; }         public void TurnOn() { Switchee.TurnOn(); }         public void TurnOff() { Switchee.TurnOff(); }     } } 代码5     注意：这个代码与之前有问题的代码2，只是各种名称上的变化。结构上一点儿没变。     以后有新的产品，也只需要实现ISwitchable接口，就可以支持这个开关了。之前的失败设计，看似与这个设计相差无几，但是其中蕴含的设计思想天差地远，也正是在这种地方，才更能体现出设计师间的差距。这一种设计所体现的，即是DIP（依赖倒置原则），的表现之一，接口应当被其使用者所拥有，而非其实现者。1 DIP（依赖倒置原则）     具体问题解决了，还需要把整个问题抽象一下，从本质上了解一下DIP的含义。（我会尽量清楚，可能会有些啰嗦，但这比在回复里争论要舒坦得多。）     假设有如下所示的类图。假设我们要把这种关系解耦合。 图1 注：图1中的User表示使用者（调用者），而不是用户的意思。 为什么要解耦合？      我说“假设要解耦合”，是因为在尝试解耦这种依赖关系之前，应该先确定有没有解耦的必要。这种关系在代码中比比皆是，如果把所有的依赖都解耦，不仅工作量大、带不来任何好处，而且引入了不必要的复杂度，最终演变成了过度设计，增加了编码成本和维护成本。（我已经被人骂怕了，怕不说清楚这一点，总要有人跳出来说我滥用模式，说这种关系要不要解耦要看情况，云云。都是好意，我也心领了，谢谢。但被人假设狗屁不通，总不太舒服。）      明确某个依赖关系是否需要被分解，是一件很复杂的事情，个人觉得并没有什么准则能让你轻松地做出这个判断。因为几乎所有的依赖，在一句经典的“我以后可能会换一种方式实现它”面前，都变得似乎需要被解耦。这种理由，听上去合理，其实是狗屁。换一种方式实现它，并不意味着要用一个接口来抽象它，接口是用来抽象并解耦依赖关系的，应该被用在：同时存在多个实现、实现未知或需要模块化的情况下（还有一种情况，是方便多人开发时工作内容的解耦，但我还没有想明白，引入接口来达到这个目的是否合适：因管理需要导致的复杂度上升。所以先不讨论这种情况）。      具体解释一下，“同时存在多个实现”的意思。以IComparable接口为例，很多数据类（比如DTO）大都实现了这个接口，因为上层的功能（比如排序）依赖类的对象有相互比较的能力，同时每个类的实现方式又都不一样，即所谓的同时存在多个实现。      所以，对于需要“换一种方式实现它”的情况，大可以把原来的代码删除然后重新写一个。      有句话叫“拿着锤子，看什么都像钉子”。了解一项技术，不仅仅要了解他能做什么，更要了解这个技术适用在什么地方。所以千万别今天听了解耦的概念觉得很前卫，第二天就去把所有的类都提取出个接口。多数情况当然不会这么夸张，但滥用其实就在一念之间。 接口的坏味道      我承认，上面解释也许正确，但没什么用。懂的人懂，不懂的还是不懂；所以我还是举些接口有问题的坏味道吧。      最常见的接口坏味儿包括：（注意，总可以找到反例，所以一开始就说了，没有准则，总要具体问题具体分析，但是如果使用接口的原因是如下几种之下，我觉得应该再仔细考虑一下） 为了提取出某一个类所提供的Public方法。接口应该用来抽象依赖，而不是抽象实现。后面再解释。你想知道或控制一个类有哪些Method的方法有很多，但是引入一个接口，不仅达不到你的目的，还引入了复杂度——每当你要加一个方法，都要修改两个地方，一个是接口，一个是实现。 接口抽象出来了，但是和实现放了一起，或者根本没用到这个接口。比如，如果你写出了： Interface f = new Implementation(); 这样的代码，而且这个接口只被这样用过，那或许需要考虑一下使用这个接口的用法了。我并不是指你需要一个依赖注入的框架。但是这至少看上去不太对劲，像是为了使用接口而提取出了这个接口。 接口中包含了互不相关的方法。如果某个方法出现在这个接口里会让人觉得惊讶，那这个接口就是有问题的。不能因为有两个以上的类都有这个方法，所以就提取出来了。要看这两个方法有没有关系，还要看上层是不是一定会同时依赖这两个方法。使用者使用接口中的方法时，应该全部都用得到。如果没全用到，可能需要考虑一下这个接口划分的是否合理？的粒度是不是太粗了？还是把接口当成了Common Service Host来用了？ 同一张类图的不同解释——真假DIP     扯得有点儿远了。回来继续正题，考虑如何把User和Implementation解耦合。所有人都知道，解耦的方法是： 定义接口I Implementation实现接口I User使用接口I，则不是Implementation。     这个描述已经很细了，而且画出来的类图也是唯一的。但是很可惜，这个描述是不明确的，有歧义的。     代码2和代码5都符合这个描述，但是其实是不同的设计。用图来描述会更清楚一些。 图2 图3       或许有人一看到学术派的设计图就兴奋起来，一眼就看出有一个设计是有问题的。但是当你看到代码2时，你有一眼看出问题吗？到你自己的项目代码中，你能一眼看出问题吗？问题总是出现在“混乱”中，简化成图2、图3这样，只要知道DIP的人，恐怕都能看出问题。但到项目中，那就是另一回事儿了。就像多数人都很鄙视国家组织的“软考”，考得再好，也不表示有相当的设计水平。这种简化了的问题和考题一样，也许能明白，但是能在该用的时候记得用，并不是个容易的事儿。      我来解释一下，其中根本的区别在于谁依赖谁。至于谁持有接口，只是表象。从逻辑上，调用方很明显地依赖着实现方，因为实现方才是功能的实现者，没有实现方，调用方就工作不了。但是在图3的设计中，其设计意图是，实现方要实现的功能，由调用方来决定，而不是实现方实现了什么，调用方就用什么。也就是说，要让实现方依赖调用方。这，就是DIP（依赖倒置原则）的含义。其具体表现就是，调用方定义并持有接口。      从概念上来讲，DIP的定义如下2： 高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。 抽象(Abstractions)不应该依赖于实现(details)，实现应该依赖于抽象。      目前在网上找到的对DIP的解释，多数都停留在第一项，即模块依赖抽象上，都没有解释清楚“倒置”这个词的含义。希望本文中的图2和图3解释清楚了“倒置”的含义。从概念上来讲，“抽象不应该依赖于实现”，就是要求“倒置”。因为如果像图2那种思路，从实现中抽象出接口，那么这个接口就是依赖于实现的。重复一下之前说过的：接口，应该是对依赖的抽象，而不是对实现（底层功能）的抽象，这就是所谓的倒置。（这里的依赖的含义是，调用者所需要的功能，而不是实现者实现了的功能。） 另外，还是这个类图，还有一种常见的组织形式。像下面这样。 图4      从箭头的方向上来看，这个更倒置。但是模块的细分，箭头方向的颠倒，并不意味着这个设计真的是倒置的。这要取决于抽象层中的接口，是与图2中的接口定位一致呢？还是与图3中的接口定位一致？单纯地把接口放在抽象层里，就和单纯地定义一个接口，却没有地方用到它一样没有意义。      所以说，清楚地表达一个设计，并能让人确切地明白你的设计。其实是一件非常不容易的事情。可能把UML的所有功能都用上，才能做到这一点。仅仅画个框框、线线、写俩字儿，是很容易让人误会的。开会的时候有人解释着还好，如果写出的文档如果是这样，对新手而言还不如没有，因为基本上一定会被误解。 了解DIP有什么用？DIP能用在什么地方？      我猜不少人看到这里会很想问，知道“倒置”到底是什么意思有个鸟用？有好的创意去开发项目才是正经事儿，把项目按时保质地做出来才是正经事儿，老子按时下班才是正经事儿。      首先，我非常同意！然后，回答这个问题，这个每个人的个性使然。就像天天研究吃什么健康有个鸟用？中国的食品安全都保证不了，还健康？！但是就是有人就好这口，不是么？而且，我在这里只是解释DIP，也并没有说做的项目里，都要符合DIP啊。项目管理和架构是很灵活的，不是几个P就可以规范的起来的。有时候，直接找个开源的产品一搭，多快好省，一个P也用不着。如果非要给出个理由，我想恬不知耻地说句，追求卓越。（好吧，根本原因是，我喜欢得瑟，但是又不喜欢被明白人骂成猪头，所以我选择先搞明白了再去得瑟。）      但是我还是要说说了解这个原则的好处，不然写这文章不是打自己脸么？了解依赖倒置的意义，并不限于设计，还在于思想上的转变。理解这个原则之后，你会发现自己明明已经把这个原则用上了，比如做需求分析的时候，肯定是问用户想要什么，而不是我们能做到什么。      这个原则在协作上也有用处。请回想一下，在工作中，是否遇到过上层开发人员等下层开发接口的情况呢？如果遇到过，当时有没有想过，这个依赖关系是不是反了呢？其实，应该是下层模块的开发者依赖上层开发者呀。上层开发者定义好他依赖的接口，下层开发者来实现，同时，因为接口已经定义好了，上层也不用等下层开发者，完全可以用些Mock框架进行测试嘛。但是，如果让下层开发者定义接口，显然上层开发者就必须等，Mock类也写不了。      关于这个原则，我还见到过更广义，更天下大同的解释。在客户关系上，我们常见的依赖是开发者依赖客户，客户说什么我们就得做什么，一点主动权都没有。于是有人就把依赖倒置的原则拿来，说，应该让客户依赖开发者！大有，“我们说什么，客户就听什么！”的派头。到底哪个依赖是倒置的我就不在这儿争了，因为我觉得这完全不是依赖的方向性问题。而是店大欺客还是客大欺店的问题。如果你在IBM、在SAP、在四大，你可以让客户听你的。如果你在一个小屁公司，或者客户是政府部门，你倒置个试试？ 下回预告     自此之后，一切安好。     直到有一天，又有一个用户，他的灯上的开关也坏了，然后他试着把另外一家厂商的开关装了上去，却发现打不开灯。用户抱怨道，他的这个开关可是按国际标准实现的，我们的灯具应该支持这种标准开关。     如果有可能，我们一定会让这个灯支持这个国际标准。可是灯已经卖出去了，出厂的千千万万个灯都召回的代价也很大。     这个灯的设计，又要做出怎样的变化呢？ 参考文献： 1. 《敏捷软件开发 原则、模式与实践（C#版）》 第117页11.1.1节 2. 《敏捷软件开发 原则、模式与实践（C#版）》 第115页  ","title":"小例子背后的大道理——从DIP中“倒置”的含义说接口的正确使用"},{"content":"小例子背后的大道理——Adapter模式详解 上回问题回顾      前文说到一位用户拿着业界标准开关（一个标准的StandardSwitcher，它依赖IStandardSwitchable接口才能工作，然而目前我们的灯并不支持这个接口）出现在我面前，叫嚣着他的“标准开关”应该能打开我们的灯。好吧，这个需求是合理的，的确应该支持。但是该死的是，为什么没有早一点儿知道这个标准的存在呢？这样就不需要花费时间和人力定义这个接口，现在也不会这么纠结。和上次一样，先讲故事、演进方案，再分析背后的思想。      这回主要讲解Adapter模式，GoF讲解了这个模式是什么，怎么用，用在什么地方。我想来解释一下Adapter模式的要点是什么，对Adapter模式的延展，以及对Adapter模式的误用。顺便得瑟一下我对面向对象设计的理解。 两个方案      现在有两个选择。 让我们的灯直接支持标准开关。也就是让灯实现IStandardSwitchable接口。 好处：成本低，实现方式优雅。 坏处：相当于放弃了已经买了我们的灯，又想用标准开关的用户。 不改变现在的灯，让标准开关能打开我们的灯。标准接口我们改不了，灯也不能改。好在计算机界有句话，叫“加一层可以解决一切问题”。这让我想到了买外国电器附赠的那个电源接口转换器。现在，我们的灯需要个类似的玩意儿。 好处：支持所有的灯。 坏处：这东西都是要附赠的，会降低我们的利润。      第一个方案很简单，就是让Light多实现个接口就OK了。图就不给了。      现在分析第二个方案，标准接口依赖IStandardSwitchable接口，那我们必须有一个类来实现它，并完成所需要的功能——操作灯。咱也是学过设计模式的人，这个问题很明显可以用Adapter模式来解释。      相关类图很容易就可以画出来。 图1 让灯支持IStandardSwitchable接口的方案        其对应的代码会是这个样子：     public interface IStandardSwitchable     {         void TurnOn();         void TurnOff();     }       public class SwitcherAdapter : IStandardSwitchable     {         public Light Switchee { get; set; }           public void TurnOn()         {             Switchee.TurnOn();         }           public void TurnOff()         {             Switchee.TurnOff();         }     } 代码1      Job Done。Light通过SwitcherAdapter支持了新的接口，这简直就是应用适配器模式的典范啊。（嗯，这句的确是反话，不过你猜出来为什么这个Adapter不属于适配器模式吗？）      “上回真是白跟你说了那么多，平时没觉得你这么不开窍啊。你自己好好想想吧！”背后看着我画UML图的设计Guru好像有点儿生气。       上回？我冷静下来回想上回的内容和现在的问题。上回讲的DIP，讲不要依赖实现，要依赖抽象。再想想目前的需求，我们有灯，有收音机，如果用户说要用标准开关开收音机，难道还要实现一个RadioAdapter不成？这显然违反了OCP。       需求是要“通过加一层让灯支持标准开关”，但是并不是说这一层就要使用灯，为了让这个Adapter更加通用，应该让Adapter依赖ISwitchable接口。像下面这个样子。 图2 Adapter模式         与代码1的差别，仅仅是SwitcherAdapter里的Switchee属性的类型改成ISwitchable而已。代码就不再贴了。其所体现的原则就是上一篇讲的DIP。       这个事儿其实任何人静静地想想都能想到。但我绕这个弯子，其实是想顺便表达这样一个意思：一个紧急需求来了的时候，人们更容易倾向于把完成工作放在第一位，从而一时忽视了设计的严谨度，事后又忘了重构，于是Bad Smell就这样产生了。当然，这些大家也都知道。 面向对象的设计并不是对现实的模拟       （这一节算是一个插曲吧，因为这个论点太大，写出来都觉得不自量力，不写又觉得对不起自己爱得瑟的作风。一点拙见，大家多多批评。觉得偏题太远的话可以直接看一下节。）        但是（重点来了），为什么紧张时做出的直观设计更可能是错误的呢？因为人一紧张就容易凭感觉，而使用直觉做设计时，大都会以现实世界为原本，但是良好的面向对象设计，是绝对不能仅仅依靠现实世界的。其实图1 的设计从直觉上来讲是符合需求，也很符合人们对这个世界的认知的。但是它并不是一个良好的面向对象设计。图2是相对良好的设计，但是图2显然又没有图1 那么直观，那么好理解，那么符合这个世界的真实状态。       图2和图1 的差别仅仅在于Adapter要依赖谁上，Adapter要依赖于ISwitchable接口这个事儿，并不是为了更真实地模拟这个世界，而纯粹地是为了解耦合而出现（或者说，为了依赖抽象）。但是在现实世界中，是不存在解不解耦合的概念的。解耦合是为了保证设计上的灵活性引入的概念。         现实中事物间的依赖都是具体的，是为了复用、灵活性等才引入的抽象，客观现实是不存在抽象的。抽象是要取决于你是如何看待客观事物的。举个例子，在动物学家看来，人与动物间有IS-A关系；但是如果你是要开发一款MMORPG游戏，人（NPC和Avatar）和动物（一般会是怪物）应该是不会有IS-A关系的。观察的角度不同，就会得出不同的设计；这些设计没有对错之分，只有是否满足需求之别。      所以，有些地方，把面向对象的设计过程解释为对现实世界的模拟是很片面的。如果仅仅以现实世界的样子对系统进行设计，得出的设计很可能是僵化的，就像图1那样。（有人可能想说我曲解了人家的意思，但是我想说，你写成那个样子明明就是故意给人误解的，至少是很容易引导人误解。容易被误解，就是有问题。没什么好狡辩的。）      但是，这并不意味着做设计就要全面地抽象，模拟现实世界的好处是代码容易理解，但是如果全部抽象成图2那样，所有都抽象出个接口，所有都依赖抽象，那代码的可读性显然会下降。所以，好的面向对象设计，会是真实地模拟现实与抽象现实间的取舍的过程。如果你看过一些功能相似、但实现不同的开源框架，会发现有些好理解，有些不好理解，其根本原因就是其抽象的层次或者说抽象的程度不一样。抽象度过高，灵活性也许上去了，但是并不见得就是好事儿。过度设计，就是因为对现实的抽象度太高，造成可读性差，不好维护，还没解决问题，就先被问题解决掉了。      上面的例子可能依然没有什么说服力。我再举一个。上篇文章有人回复说，     “开关里面还包含一个开关接口 ，很奇怪的方式。      在我看来应该是灯光有开关”。      我想感谢一下这位朋友，因为他提出的这个思路，我一开始就潜意识地无视掉了。经他一提，我才意识这也是设计过程中一类常见的问题。这个设计是一个很真实地反应现实的设计。但是并不是一个可行的类设计。如果你按这个方案写代码，就会发现很多问题。原因我已经回复了。      总结一下，做面向对象设计的时候，请记得自己要做的是什么？不要让现实世界的“真实”的样子混淆了视听。面向对象设计，是以可复用地、灵活地实现需求为目标的，对现实的抽象，而不是对现实的模拟；抽象的结果很可能在现实中并不存在。 Adapter模式的关键      Adapter模式最关键的要求是：Adapter是对两个功能相近的接口间的适配。如果被适配的对象是个具体类，那么多数情况下，Adapter非但不会带来好处，反而是仅仅增加了维护成本，就像前面说的，有一个新的具体类出现，就要同时添加一个Adapter。      （如果你非说你见过很多 “适配”具体类的，你是对的，但是那叫Proxy，不叫Adapter，解决的也不是同一种问题，而且多数情况下，Proxy是可以自动生成的，所以不需要担心加一个类，就要自己实现一个对应的Proxy的问题。可以用下面这个图对比一下，来自《敏捷软件开发》） 图3 Proxy模式         这不是在死抠Adapter模式的含义。因为只有理解Adapter的目标、适用范围之后，才不会误用这个模式。见过不少人理解力很好或是英文很好，看到Adapter这个词是个模式就想当然地觉得自己“知道”了这个模式的用法（毕竟这个模式也的确不复杂），并“用”了起来。比如图1的那个例子，就是最常见的误用之一。      这也不是在死抠名词。给模式命名的好处之一就是让两个都懂模式的人沟通起来更顺畅。模式名所表达的，不是一个简单的类关系图，而是对要解决问题的类型的定位和解决问题的策略。      Adapter，表示遇到的问题是接口不匹配。      Proxy，表示遇到的问题是主体逻辑与附加逻辑（持久化、网络传输等）纠缠。      名词用错了，就可能会带来不必要的误会。      如果你就是觉得没必要死抠概念，下面的“广义Adapter模式”可能会比较适合你。 广义Adapter模式      这年头好像什么东西都非要搞出个狭义和广义之分。我个人比较反感这一点，因为狭广之分的存在，本身就是一种对概念的模糊。这导致人们在沟通时，如果遇到问题，常常要想一下对方说的是广义的还是狭义的，而不是把焦点放在问题本身。这像是给自己和对方找借口或是后路。或许是因为大家都想给自己留个后路，这东西才会这么流行。附经典对白一则：      “嗯？不对吧，不应该是XXXX吗？”     “呃，我说的是一种广义上的XXXX。”     “哦。（Shit!）”      每个人们学习模式，总会有自己的理解，自己的抽象。当理解的角度不同的时候，就会把Adapter模式的内涵延展到不同的地方。这就导致了不同人对广义Adapter的定义是不同的。      比如《敏捷软件开发》，从逻辑关系出发，把Adapter的概念延展为：使用一个特定的类，实现对方法调用的定向派发（我自己总结的，原文没这话）。从这个概念上讲，Adapter模式可以用于对具体类的适配。因为这个延展的概念实际上已经超出了原有的GoF的定义。这显然不能说是错误的，你甚至会觉得这个人水平真高，能对设计模式进行再抽象，再扩展。      但是问题是，不同人对同一概念的延展方向是不同的。你觉得Adapter和Delegate/Event有什么相似之处吗？我相信更多人会觉得Observer模式与Delegate/Event的相似之处更多些。因为无数的人和书都说过C#的Delegate/Event机制就是Observer模式的一种具体实现。如果你面试的时候说，Delegation就是一种Adapter，你的面试可能就直接Pass了。这事儿也的确真实地发生过。      但是如果去看《Pro Objective-C Design Pattern for iOS》第112页，对Adapter的描述真的是这样的。        “The Delegation pattern was once one of the inspirations for cataloging the Adapter           pattern in the “Gang of Four” book.”       如果你怕我断章取义，可以自己去看。       这个人是从类与类之间的关系出发，把具有相似结构、交互方式的类的组合都定义为Adapter。你说他的理解错了吗？我只能说：“狭义来讲，是错的，广义来讲，是对的。”但这是这个世界上最操蛋的答案之一。       像上面链接的博客里描述的那个面试者，显然就成了广义与狭义之分的牺牲品——他说的是广义的Adapter，但是面试官想听到的是狭义的Adapter。（不过从后面的叙述来看，那个面试官也是半瓶子醋，问Delegate的时候居然会顺便问异步，让我不得不怀疑他是不是认为事件是异步触发的。）       对Adapter有独特的理解很好，能把Adapter, Observer, Delegation, Proxy全统一起来理解更是NB。但是，其实在多数情况下，越是独到的见解，越可能会给面对面的沟通带来障碍。这些独到的见解在个人顿悟模式的过程中很有用，写到书里也很好，毕竟读者可以细细体味，帮助读者从不同的角度思考问题；但想在面试之类的当面沟通的场合上装逼，然后自己的口才又不咋地。怕只会画虎不成反类犬。 对Adapter模式的误用       学历史的时候，常常见到“左派”、“右派”这样的词，意思是他们走的路线不对。这个词用得很形象，都是走极端。 模式的误用，常见的误用之一也是走极端。       图2 的Adapter模式，成功的把标准的开关接口适配到了我们的接口上。于是便有了一个顺理成章的思路，ISwitchable和IStandardSwitchable接口都是对开关的定义，我们通过Adapter模式，让支持IStandardSwitchable的开关能够开我们的灯。       那么我们之前的这个设计： 图4. 第一回中提出的开关开灯方案（Abstract Server）         是不是应该改成这样？ 图5. 试图把Adapter模式用于实现DIP         这个设计相比原来的设计方案，抽象度更高、耦合性更低，Light甚至不需要依赖ISwitchable接口就可以工作，这样我们可以很有信心地说，我们可以让一切类都支持ISwitchable接口！ 这个想法很丰满，但是现实很骨感。如果你认真看过了前面的内容，应该已经知道这个方案其实很烂的原因了。       这个世界很微妙，《敏捷软件开发》（P370）的确就把图5称为Adapter模式，不过你应该懂的，他说的是广义的Adapter模式。并不是说对具体类的Adapter就一定是误用，如果没有违反OCP就不是误用，如果那个Light是个Utility类，就不算是误用。      （如果你想喷Adapter模式本来就有两种，一种是基于类的，一种是基于对象的，你最好先去把Adapter概念回个炉，我们说的根本不是一码事儿。） 误用的原因      我自己总结了一下出现这种误用的原因有三（这些原因会让人出现各种形式的误用，而不针对Adapter模式）： 想当然地类推。像上面那样，从适配IStandardSwitchable可行，直接推出适配ISwitchable也可以，毕竟这是同样功能的接口啊。但是，不能这样类推。 妄图用同一个方式解决所有问题的想法或创造出一个work for everything的东西的想法。我直觉上就想用热力学第二定律来反驳这想法（和work forever差不多意思），不过“no silver bullet”可能更合适些。但是有些人，尤其是Level越高的，就越容易陷入这个泥潭。可能他们觉得不创造些NB的东西出来，就太对不起大家了。当然，这个想法是很好的，但是也要讲求方法，拿着锤子就看什么都是钉子的做法是要不得的。 参考十条不错的编程观点。第一条就是，独立思考，妄图通过学习各种模式就可以应对一切设计问题的想法就是要不得的。还有一条让我印象很深的就是关于Google的使用，推荐大家也去看看。 对设计原则和设计模式的理解不透彻。如果真正理解了Adapter模式的意图、适用范围。是不会犯这样的错误的。但是很可惜，这个世界上的诱惑太多了，哪怕Wikipedia这样看似很权威的地方都在误导着别人（所以，自己思考，自己判断）。Wikipedia上对DIP的解释是这样的：“Applying the dependency inversion principle can also be seen as applying the Adapter pattern, i.e.”直译过来就是“遵循依赖倒置原则可被视同于应用适配器模式”。Oops…用了适配器模式，那的确是DIP了，但是适配器并不用来达到DIP这个目标的，适配器模式虽然DIP，但是如果用来现实DIP，效果却很糟糕，带来了更多 的问题。我猜作者的本意只是想表达：适配器模式本身是符合DIP原则的。这没错。但是我相信有一票人看到这里就去研究适配器模式并计划用它来实现DIP了。（有人嫌我啰嗦，我只是想把问题说清楚，让更多的人无可误解。）     这里说的缺乏经验可能并不是工作年限不足的问题，更可能的是态度的问题，要么是对Adapter模式想当然、觉得自己在字面上的理解就差不多，要么是想对Adapter模式进行所谓的“活用”，结果犯了激进冒险主义错误。 下回预告       我们的灯卖得好，用户就多了起来，需求也多了起来。这样一下子来了两个用户，一个要求，我要用两个开关控制同一个灯（床头一个，走廊一个，看来这用户晚上常起夜）；另一个要求，我想用一个开关控制屋子里所有的灯（看来这用户不差钱）。        那么，我们又需要做出怎样的设计来应对这些需求呢？","title":"小例子背后的大道理——Adapter模式详解"},{"content":"作用：它指导我们如何正确地消解模块间的依赖关系，同时它也是框架设计的核心原则。   依赖倒置原则的本质就是要求将类之间的关系建立在抽象接口的基础上的。Robert Martin这样描述依赖倒置原则[Martin 1996]： 传统的策略是把复杂的系统“化整为零，各个击破”。这就是通常所说的分解。SA方法（结构化的分析）也是采用这样的分解策略，把大型和复杂的软件系统分解成若干个人们易于理解和易于分析的子系统。这里的分解是根据软件系统的逻辑特性和系统内部各成分之间的逻辑关系进行的。在分解过程中，被分解的上层就是下层的抽象，下层为上层的具体细节。 我们尽量在抽象层进行控制编程，要针对接口编程，不要针对实现编程。 要依赖于抽象，不要依赖于具体。就是说我们尽量在抽象层进行控制编程，要针对接口编程，不要针对实现编程。 开闭原则是目标，而达到这一目标的手段是依赖倒转原则。 抽象层次包含的是应用系统的商务逻辑和宏观的、对整个系统来说重要的战略性决定，是必然性的体现，那么抽象层次就应当是较为稳定的，应当是复用的重点；也应当是维护的重点；而具体层次则含有一些次要的与实现有关的算法和逻辑，以及战术性的决定，带有相当大的偶然性选择。具体层次的代码是会经常有变动的，不能避免出现错误。","title":"依赖倒转原则（Dependency Inversion Principle）"},{"content":"在计算机编程中，适配器模式（有时候也称包装样式或者包装）将一个类的接口适配成用户所期待的。一个适配允许通常因为接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。   具体使用场景如下： 若在一个人力资源管理系统中，有人员的录入模块，刚刚开始时，人员信息管理的对象是所有员工的所有信息，也就是说：有一个对象 UserInfo 存储用户的所有信息，示例如下： 项目完成时，需要倒入一批人员数据，例如其他部门的人员数据，但是呢他部门的数据，与此人力资源管理系统不同，主要是表现在员工信息中： 其是把人的信息分为了三部分：基本信息，办公信息和个人家庭信息，并且都放到了 HashMap中，比如人员的姓名放到 BaseInfo信息中，家庭地址放到 HomeInfo 中。 此时录入的时候就是需要使用适配器了，使用适配器模式从而完成人员信息的正确交互和录入，进而尽量少的去动之前的代码。类图如下： 具体代码如下： 1.package mode.test3.impler; /**  * 用户信息接口类  * @author 张义  */ public interface IUserInfo {  //获得用户姓名  public String getUserName();  //获得家庭地址  public String getHomeAddress();  //手机号码  public String getMobileNumber();  //办公电话  public String getOfficeTelNumber();  //这个人的职位是啥  public String getJobPosition();  //获得家庭电话  public String getHomeTelNumber(); } 2.实现类 package mode.test3.impl; import mode.test3.impler.IUserInfo; public class UserInfo implements IUserInfo {  public String getHomeAddress() {   System.out.println(\"家庭住址是....\");   return null;  }  public String getHomeTelNumber() {   System.out.println(\"家庭电话是....\");   return null;  }  public String getJobPosition() {   System.out.println(\"员工职位是....\");   return null;  }  public String getMobileNumber() {   System.out.println(\"员工手机是....\");   return null;  }  public String getOfficeTelNumber() {   System.out.println(\"公司电话是....\");   return null;  }  public String getUserName() {   System.out.println(\"员工姓名是....\");   return null;  } } 3. package mode.test3; import mode.test3.impl.UserInfo; import mode.test3.impler.IUserInfo; /**  * 客户端调用类  * @author 张义  *  */ public class Client {  public static void main(String[] args) {   IUserInfo userInfo = new UserInfo();   userInfo.getHomeAddress();   userInfo.getHomeTelNumber();   userInfo.getJobPosition();   userInfo.getMobileNumber();   userInfo.getOfficeTelNumber();   userInfo.getUserName();  } } 若现加上员工的录入信息，如下： 1. package mode.test3.impler; import java.util.Map; /**  * 外来用户信息接口  * @author 张义  *  */ public interface IOuterUser {  //基本信息，比如名称，性别，手机号码了等  public Map getUserBaseInfo();     //工作区域信息  public Map getUserOfficeInfo();     //用户的家庭信息  public Map getUserHomeInfo(); } 2. package mode.test3.impl; import java.util.HashMap; import java.util.Map; import mode.test3.impler.IOuterUser; /**  * 外来用户实现  * @author 张义  *  */ public class OuterUser implements IOuterUser {  /*   * 员工的家庭信息   */  public Map getUserHomeInfo() {   HashMap homeInfo = new HashMap();   homeInfo.put(\"homeTelNumbner\", \"员工的家庭电话是....\");   homeInfo.put(\"homeAddress\", \"员工的家庭地址是....\");   return homeInfo;  }  /*   * 员工的工作信息，比如职位等   */  public Map getUserOfficeInfo() {   HashMap officeInfo = new HashMap();   officeInfo.put(\"jobPosition\", \"这个人的职位是BOSS...\");   officeInfo.put(\"officeTelNumber\", \"员工的办公电话是....\");   return officeInfo;  }  /*   * 用户的基本信息   */  public Map getUserBaseInfo() {   HashMap baseInfoMap = new HashMap();   baseInfoMap.put(\"userName\", \"这个员工叫混世魔王....\");   baseInfoMap.put(\"mobileNumber\", \"这个员工电话是....\");   return baseInfoMap;  } } 现需要两模块进行衔接，则需要一适配器模块（继承外来用户类，实现用户类接口），其如下： package mode.test3; import java.util.Map; import mode.test3.impl.OuterUser; import mode.test3.impler.IUserInfo; public class OuterUserInfo extends OuterUser implements IUserInfo {  private Map baseInfo = super.getUserBaseInfo(); // 员工的基本信息  private Map homeInfo = super.getUserHomeInfo(); // 员工的家庭 信息  private Map officeInfo = super.getUserOfficeInfo(); // 工作信息  /*   * 家庭地址   */  public String getHomeAddress() {   String homeAddress = (String) this.homeInfo.get(\"homeAddress\");   System.out.println(homeAddress);   return homeAddress;  }  /*   * 家庭电话号码   */  public String getHomeTelNumber() {   String homeTelNumber = (String) this.homeInfo.get(\"homeTelNumber\");   System.out.println(homeTelNumber);   return homeTelNumber;  }  /*   * 职位信息   */  public String getJobPosition() {   String jobPosition = (String) this.officeInfo.get(\"jobPosition\");   System.out.println(jobPosition);   return jobPosition;  }  /*   * 手机号码   */  public String getMobileNumber() {   String mobileNumber = (String) this.baseInfo.get(\"mobileNumber\");   System.out.println(mobileNumber);   return mobileNumber;  }  /*   * 办公电话   */  public String getOfficeTelNumber() {   String officeTelNumber = (String) this.officeInfo     .get(\"officeTelNumber\");   System.out.println(officeTelNumber);   return officeTelNumber;  }  /*   * 员工的名称   */  public String getUserName() {   String userName = (String) this.baseInfo.get(\"userName\");   System.out.println(userName);   return userName;  } } 最终版客户端： package mode.test3; import mode.test3.impl.UserInfo; import mode.test3.impler.IUserInfo; /**  * 客户端调用类_最终类  * @author 张义  *  */ public class Client {  public static void main(String[] args) {   /*IUserInfo userInfo = new UserInfo();*/   // 改正为   IUserInfo userInfo = new OuterUserInfo();   userInfo.getHomeAddress();   userInfo.getHomeTelNumber();   userInfo.getJobPosition();   userInfo.getMobileNumber();   userInfo.getOfficeTelNumber();   userInfo.getUserName();  } }   总结： 适配器模式不适合在系统设计阶段采用，没有一个系统分析师会在做详设的时候考虑使用适配器模式，这个模式使用的主要场景是扩展应用中，就像我们上面的那个例子一样，系统扩展了，不符合原有设计的时候才考虑通过适配器模式减少代码修改带来的风险。    ","title":"java_23种设计模式之适配器模式"},{"content":"在阎宏博士的《JAVA与模式》一书中开头是这样描述原型（Prototype）模式的： 　　原型模式属于对象的创建模式。通过给出一个原型对象来指明所有创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象。这就是选型模式的用意。 原型模式的结构 　　原型模式要求对象实现一个可以“克隆”自身的接口，这样就可以通过复制一个实例对象本身来创建一个新的实例。这样一来，通过原型实例创建新的对象，就不再需要关心这个实例本身的类型，只要实现了克隆自身的方法，就可以通过这个方法来获取新的对象，而无须再去通过new来创建。 　　原型模式有两种表现形式：（1）简单形式、（2）登记形式，这两种表现形式仅仅是原型模式的不同实现。 简单形式的原型模式 　　这种形式涉及到三个角色： 　　（1）客户(Client)角色：客户类提出创建对象的请求。 　　（2）抽象原型(Prototype)角色：这是一个抽象角色，通常由一个Java接口或Java抽象类实现。此角色给出所有的具体原型类所需的接口。 　　（3）具体原型（Concrete Prototype）角色：被复制的对象。此角色需要实现抽象的原型角色所要求的接口。 源代码 　　抽象原型角色 public interface Prototype{    /**     * 克隆自身的方法     * @return 一个从自身克隆出来的对象     */    public Object clone();} 具体原型角色 public class ConcretePrototype1 implements Prototype {    public Prototype clone(){        //最简单的克隆，新建一个自身对象，由于没有属性就不再复制值了        Prototype prototype = new ConcretePrototype1();        return prototype;    }} public class ConcretePrototype2 implements Prototype {    public Prototype clone(){        //最简单的克隆，新建一个自身对象，由于没有属性就不再复制值了        Prototype prototype = new ConcretePrototype2();        return prototype;    }} 客户端角色 public class Client {    /**     * 持有需要使用的原型接口对象     */    private Prototype prototype;    /**     * 构造方法，传入需要使用的原型接口对象     */    public Client(Prototype prototype){        this.prototype = prototype;    }    public void operation(Prototype example){        //需要创建原型接口的对象        Prototype copyPrototype = prototype.clone();            }} 登记形式的原型模式 作为原型模式的第二种形式，它多了一个原型管理器(PrototypeManager)角色，该角色的作用是：创建具体原型类的对象，并记录每一个被创建的对象。 源代码 　　抽象原型角色 public interface Prototype{    public Prototype clone();    public String getName();    public void setName(String name);} 具体原型角色 public class ConcretePrototype1 implements Prototype {    private String name;    public Prototype clone(){        ConcretePrototype1 prototype = new ConcretePrototype1();        prototype.setName(this.name);        return prototype;    }    public String toString(){        return \"Now in Prototype1 , name = \" + this.name;    }    @Override    public String getName() {        return name;    }    @Override    public void setName(String name) {        this.name = name;    }} public class ConcretePrototype2 implements Prototype {    private String name;    public Prototype clone(){        ConcretePrototype2 prototype = new ConcretePrototype2();        prototype.setName(this.name);        return prototype;    }    public String toString(){        return \"Now in Prototype2 , name = \" + this.name;    }    @Override    public String getName() {        return name;    }    @Override    public void setName(String name) {        this.name = name;    }} 原型管理器角色保持一个聚集，作为对所有原型对象的登记，这个角色提供必要的方法，供外界增加新的原型对象和取得已经登记过的原型对象。 public class PrototypeManager {    /**     * 用来记录原型的编号和原型实例的对应关系     */    private static Map<String,Prototype> map = new HashMap<String,Prototype>();    /**     * 私有化构造方法，避免外部创建实例     */    private PrototypeManager(){}    /**     * 向原型管理器里面添加或是修改某个原型注册     * @param prototypeId 原型编号     * @param prototype    原型实例     */    public synchronized static void setPrototype(String prototypeId , Prototype prototype){        map.put(prototypeId, prototype);    }    /**     * 从原型管理器里面删除某个原型注册     * @param prototypeId 原型编号     */    public synchronized static void removePrototype(String prototypeId){        map.remove(prototypeId);    }    /**     * 获取某个原型编号对应的原型实例     * @param prototypeId    原型编号     * @return    原型编号对应的原型实例     * @throws Exception    如果原型编号对应的实例不存在，则抛出异常     */    public synchronized static Prototype getPrototype(String prototypeId) throws Exception{        Prototype prototype = map.get(prototypeId);        if(prototype == null){            throw new Exception(\"您希望获取的原型还没有注册或已被销毁\");        }        return prototype;    }} 客户端角色 public class Client {    public static void main(String[]args){        try{            Prototype p1 = new ConcretePrototype1();            PrototypeManager.setPrototype(\"p1\", p1);            //获取原型来创建对象            Prototype p3 = PrototypeManager.getPrototype(\"p1\").clone();            p3.setName(\"张三\");            System.out.println(\"第一个实例：\" + p3);            //有人动态的切换了实现            Prototype p2 = new ConcretePrototype2();            PrototypeManager.setPrototype(\"p1\", p2);            //重新获取原型来创建对象            Prototype p4 = PrototypeManager.getPrototype(\"p1\").clone();            p4.setName(\"李四\");            System.out.println(\"第二个实例：\" + p4);            //有人注销了这个原型            PrototypeManager.removePrototype(\"p1\");            //再次获取原型来创建对象            Prototype p5 = PrototypeManager.getPrototype(\"p1\").clone();            p5.setName(\"王五\");            System.out.println(\"第三个实例：\" + p5);        }catch(Exception e){            e.printStackTrace();        }    }} 两种形式的比较 　　简单形式和登记形式的原型模式各有其长处和短处。 　　如果需要创建的原型对象数目较少而且比较固定的话，可以采取第一种形式。在这种情况下，原型对象的引用可以由客户端自己保存。 　　如果要创建的原型对象数目不固定的话，可以采取第二种形式。在这种情况下，客户端不保存对原型对象的引用，这个任务被交给管理员对象。在复制一个原型对象之前，客户端可以查看管理员对象是否已经有一个满足要求的原型对象。如果有，可以直接从管理员类取得这个对象引用；如果没有，客户端就需要自行复制此原型对象。   Java中的克隆方法 　　Java的所有类都是从java.lang.Object类继承而来的，而Object类提供protected Object clone()方法对对象进行复制，子类当然也可以把这个方法置换掉，提供满足自己需要的复制方法。对象的复制有一个基本问题，就是对象通常都有对其他的对象的引用。当使用Object类的clone()方法来复制一个对象时，此对象对其他对象的引用也同时会被复制一份 　　Java语言提供的Cloneable接口只起一个作用，就是在运行时期通知Java虚拟机可以安全地在这个类上使用clone()方法。通过调用这个clone()方法可以得到一个对象的复制。由于Object类本身并不实现Cloneable接口，因此如果所考虑的类没有实现Cloneable接口时，调用clone()方法会抛出CloneNotSupportedException异常。 克隆满足的条件 　　clone()方法将对象复制了一份并返还给调用者。所谓“复制”的含义与clone()方法是怎么实现的。一般而言，clone()方法满足以下的描述： 　　（1）对任何的对象x，都有：x.clone()!=x。换言之，克隆对象与原对象不是同一个对象。 　　（2）对任何的对象x，都有：x.clone().getClass() == x.getClass()，换言之，克隆对象与原对象的类型一样。 　　（3）如果对象x的equals()方法定义其恰当的话，那么x.clone().equals(x)应当成立的。 　　在JAVA语言的API中，凡是提供了clone()方法的类，都满足上面的这些条件。JAVA语言的设计师在设计自己的clone()方法时，也应当遵守着三个条件。一般来说，上面的三个条件中的前两个是必需的，而第三个是可选的。 浅克隆和深克隆 　　无论你是自己实现克隆方法，还是采用Java提供的克隆方法，都存在一个浅度克隆和深度克隆的问题。 　　浅度克隆 　　只负责克隆按值传递的数据（比如基本数据类型、String类型），而不复制它所引用的对象，换言之，所有的对其他对象的引用都仍然指向原来的对象。 　　深度克隆 　　除了浅度克隆要克隆的值外，还负责克隆引用类型的数据。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深度克隆把要复制的对象所引用的对象都复制了一遍，而这种对被引用到的对象的复制叫做间接复制。 　　深度克隆要深入到多少层，是一个不易确定的问题。在决定以深度克隆的方式复制一个对象的时候，必须决定对间接复制的对象时采取浅度克隆还是继续采用深度克隆。因此，在采取深度克隆时，需要决定多深才算深。此外，在深度克隆的过程中，很可能会出现循环引用的问题，必须小心处理。 利用序列化实现深度克隆 　　把对象写到流里的过程是序列化(Serialization)过程；而把对象从流中读出来的过程则叫反序列化(Deserialization)过程。应当指出的是，写到流里的是对象的一个拷贝，而原对象仍然存在于JVM里面。 　　在Java语言里深度克隆一个对象，常常可以先使对象实现Serializable接口，然后把对象（实际上只是对象的拷贝）写到一个流里（序列化），再从流里读回来（反序列化），便可以重建对象。 public  Object deepClone() throws IOException, ClassNotFoundException{        //将对象写到流里        ByteArrayOutputStream bos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(bos);        oos.writeObject(this);        //从流里读回来        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());        ObjectInputStream ois = new ObjectInputStream(bis);        return ois.readObject();    } 这样做的前提就是对象以及对象内部所有引用到的对象都是可序列化的，否则，就需要仔细考察那些不可序列化的对象可否设成transient，从而将之排除在复制过程之外。 　　浅度克隆显然比深度克隆更容易实现，因为Java语言的所有类都会继承一个clone()方法，而这个clone()方法所做的正式浅度克隆。 　　有一些对象，比如线程(Thread)对象或Socket对象，是不能简单复制或共享的。不管是使用浅度克隆还是深度克隆，只要涉及这样的间接对象，就必须把间接对象设成transient而不予复制；或者由程序自行创建出相当的同种对象，权且当做复制件使用。 　　   孙大圣的身外身法术 　　孙大圣的身外身本领如果在Java语言里使用原型模式来实现的话，会怎么样呢？首先，齐天大圣(The Greatest Sage)即TheGreatestSage类扮演客户角色。齐天大圣持有一个猢狲（Monkey）的实例，而猢狲就是大圣本尊。Monkey类具有继承自java.lang.Object的clone()方法，因此，可以通过调用这个克隆方法来复制一个Monkey实例。 　　孙大圣本人用TheGreatestSage类代表 public class TheGreatestSage {    private Monkey monkey = new Monkey();        public void change(){        //克隆大圣本尊        Monkey copyMonkey = (Monkey)monkey.clone();        System.out.println(\"大圣本尊的生日是：\" + monkey.getBirthDate());        System.out.println(\"克隆的大圣的生日是：\" + monkey.getBirthDate());        System.out.println(\"大圣本尊跟克隆的大圣是否为同一个对象 \" + (monkey == copyMonkey));        System.out.println(\"大圣本尊持有的金箍棒 跟 克隆的大圣持有的金箍棒是否为同一个对象？ \" + (monkey.getStaff() == copyMonkey.getStaff()));    }        public static void main(String[]args){        TheGreatestSage sage = new TheGreatestSage();        sage.change();    }} 　大圣本尊由Monkey类代表，这个类扮演具体原型角色： public class Monkey implements Cloneable {    //身高    private int height;    //体重    private int weight;    //生日    private Date birthDate;    //金箍棒    private GoldRingedStaff staff;    /**     * 构造函数     */    public Monkey(){        this.birthDate = new Date();        this.staff = new GoldRingedStaff();    }    /**     * 克隆方法     */    public Object clone(){        Monkey temp = null;        try {            temp = (Monkey) super.clone();        } catch (CloneNotSupportedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        } finally {            return temp;        }    }    public int getHeight() {        return height;    }    public void setHeight(int height) {        this.height = height;    }    public int getWeight() {        return weight;    }    public void setWeight(int weight) {        this.weight = weight;    }    public Date getBirthDate() {        return birthDate;    }    public void setBirthDate(Date birthDate) {        this.birthDate = birthDate;    }    public GoldRingedStaff getStaff() {        return staff;    }    public void setStaff(GoldRingedStaff staff) {        this.staff = staff;    }    } 大圣还持有一个金箍棒的实例，金箍棒类GoldRingedStaff: public class GoldRingedStaff {    private float height = 100.0f;    private float diameter = 10.0f;    /**     * 增长行为，每次调用长度和半径增加一倍     */    public void grow(){        this.diameter *= 2;        this.height *= 2;    }    /**     * 缩小行为，每次调用长度和半径减少一半     */    public void shrink(){        this.diameter /= 2;        this.height /= 2;    }} 当运行TheGreatestSage类时，首先创建大圣本尊对象，而后浅度克隆大圣本尊对象。程序在运行时打印出的信息如下： 可以看出，首先，复制的大圣本尊具有和原始的大圣本尊对象一样的birthDate，而本尊对象不相等，这表明他们二者是克隆关系；其次，复制的大圣本尊所持有的金箍棒和原始的大圣本尊所持有的金箍棒为同一个对象。这表明二者所持有的金箍棒根本是一根，而不是两根。 　　正如前面所述，继承自java.lang.Object类的clone()方法是浅克隆。换言之，齐天大圣的所有化身所持有的金箍棒引用全都是指向一个对象的，这与《西游记》中的描写并不一致。要纠正这一点，就需要考虑使用深克隆。 　　为做到深度克隆，所有需要复制的对象都需要实现java.io.Serializable接口。 　　孙大圣的源代码： public class TheGreatestSage {    private Monkey monkey = new Monkey();        public void change() throws IOException, ClassNotFoundException{        Monkey copyMonkey = (Monkey)monkey.deepClone();        System.out.println(\"大圣本尊的生日是：\" + monkey.getBirthDate());        System.out.println(\"克隆的大圣的生日是：\" + monkey.getBirthDate());        System.out.println(\"大圣本尊跟克隆的大圣是否为同一个对象 \" + (monkey == copyMonkey));        System.out.println(\"大圣本尊持有的金箍棒 跟 克隆的大圣持有的金箍棒是否为同一个对象？ \" + (monkey.getStaff() == copyMonkey.getStaff()));    }        public static void main(String[]args) throws IOException, ClassNotFoundException{        TheGreatestSage sage = new TheGreatestSage();        sage.change();    }} 在大圣本尊Monkey类里面，有两个克隆方法，一个是clone()，也即浅克隆；另一个是deepClone()，也即深克隆。在深克隆方法里，大圣本尊对象（一个拷贝）被序列化，然后又被反序列化。反序列化的对象就成了一个深克隆的结果。 public class Monkey implements Cloneable,Serializable {    //身高    private int height;    //体重    private int weight;    //生日    private Date birthDate;    //金箍棒    private GoldRingedStaff staff;    /**     * 构造函数     */    public Monkey(){        this.birthDate = new Date();        staff = new GoldRingedStaff();    }    /**     * 克隆方法     */    public Object clone(){        Monkey temp = null;        try {            temp = (Monkey) super.clone();        } catch (CloneNotSupportedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        } finally {            return temp;        }    }    public  Object deepClone() throws IOException, ClassNotFoundException{        //将对象写到流里        ByteArrayOutputStream bos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(bos);        oos.writeObject(this);        //从流里读回来        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());        ObjectInputStream ois = new ObjectInputStream(bis);        return ois.readObject();    }    public int getHeight() {        return height;    }    public void setHeight(int height) {        this.height = height;    }    public int getWeight() {        return weight;    }    public void setWeight(int weight) {        this.weight = weight;    }    public Date getBirthDate() {        return birthDate;    }    public void setBirthDate(Date birthDate) {        this.birthDate = birthDate;    }    public GoldRingedStaff getStaff() {        return staff;    }    public void setStaff(GoldRingedStaff staff) {        this.staff = staff;    }    } 可以看到，大圣本尊持有一个金箍棒（GoldRingedStaff）的实例。在大圣复制件里面，此金箍棒实例是原大圣本尊对象所持有的金箍棒对象的一个拷贝。在大圣本尊对象被序列化和反序列化时，它所持有的金箍棒对象也同时被序列化和反序列化，这使得复制的大圣的金箍棒和原大圣本尊对象所持有的金箍棒对象是两个独立的对象。 public class GoldRingedStaff implements Serializable{    private float height = 100.0f;    private float diameter = 10.0f;    /**     * 增长行为，每次调用长度和半径增加一倍     */    public void grow(){        this.diameter *= 2;        this.height *= 2;    }    /**     * 缩小行为，每次调用长度和半径减少一半     */    public void shrink(){        this.diameter /= 2;        this.height /= 2;    }} 运行结果： 　从运行的结果可以看出，大圣的金箍棒和他的身外之身的金箍棒是不同的对象。这是因为使用了深克隆，从而把大圣本尊所引用的对象也都复制了一遍，其中也包括金箍棒。 　　   原型模式的优点 　　原型模式允许在运行时动态改变具体的实现类型。原型模式可以在运行期间，由客户来注册符合原型接口的实现类型，也可以动态地改变具体的实现类型，看起来接口没有任何变化，但其实运行的已经是另外一个类实例了。因为克隆一个原型就类似于实例化一个类。 原型模式的缺点 　　原型模式最主要的缺点是每一个类都必须配备一个克隆方法。配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类来说不是很难，而对于已经有的类不一定很容易，特别是当一个类引用不支持序列化的间接对象，或者引用含有循环结构的时候。 转载自：http://www.cnblogs.com/java-my-life/archive/2012/04/11/2439387.html","title":"设计模式(19) ------------原型模式"},{"content":"在阎宏博士的《JAVA与模式》一书中开头是这样描述建造（Builder）模式的： 　　建造模式是对象的创建模式。建造模式可以将一个产品的内部表象（internal representation）与产品的生产过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。 产品的内部表象 　　一个产品常有不同的组成成分作为产品的零件，这些零件有可能是对象，也有可能不是对象，它们通常又叫做产品的内部表象（internal representation）。不同的产品可以有不同的内部表象，也就是不同的零件。使用建造模式可以使客户端不需要知道所生成的产品有哪些零件，每个产品的对应零件彼此有何不同，是怎么建造出来的，以及怎么组成产品。 对象性质的建造 　　有些情况下，一个对象会有一些重要的性质，在它们没有恰当的值之前，对象不能作为一个完整的产品使用。比如，一个电子邮件有发件人地址、收件人地址、主题、内容、附录等部分，而在最起码的收件人地址得到赋值之前，这个电子邮件不能发送。 　　有些情况下，一个对象的一些性质必须按照某个顺序赋值才有意义。在某个性质没有赋值之前，另一个性质则无法赋值。这些情况使得性质本身的建造涉及到复杂的商业逻辑。这时候，此对象相当于一个有待建造的产品，而对象的这些性质相当于产品的零件，建造产品的过程是建造零件的过程。由于建造零件的过程很复杂，因此，这些零件的建造过程往往被“外部化”到另一个称做建造者的对象里，建造者对象返还给客户端的是一个全部零件都建造完毕的产品对象。 　　建造模式利用一个导演者对象和具体建造者对象一个个地建造出所有的零件，从而建造出完整的产品对象。建造者模式将产品的结构和产品的零件的建造过程对客户端隐藏起来，把对建造过程进行指挥的责任和具体建造者零件的责任分割开来，达到责任划分和封装的目的。　 建造模式的结构 在这个示意性的系统里，最终产品Product只有两个零件，即part1和part2。相应的建造方法也有两个：buildPart1()和buildPart2()、同时可以看出本模式涉及到四个角色，它们分别是： 　　抽象建造者（Builder）角色：给 出一个抽象接口，以规范产品对象的各个组成成分的建造。一般而言，此接口独立于应用程序的商业逻辑。模式中直接创建产品对象的是具体建造者 (ConcreteBuilder)角色。具体建造者类必须实现这个接口所要求的两种方法：一种是建造方法(buildPart1和 buildPart2)，另一种是返还结构方法(retrieveResult)。一般来说，产品所包含的零件数目与建造方法的数目相符。换言之，有多少 零件，就有多少相应的建造方法。 　　具体建造者（ConcreteBuilder）角色：担任这个角色的是与应用程序紧密相关的一些类，它们在应用程序调用下创建产品的实例。这个角色要完成的任务包括：1.实现抽象建造者Builder所声明的接口，给出一步一步地完成创建产品实例的操作。2.在建造过程完成后，提供产品的实例。 　　导演者（Director）角色：担任这个角色的类调用具体建造者角色以创建产品对象。应当指出的是，导演者角色并没有产品类的具体知识，真正拥有产品类的具体知识的是具体建造者角色。 　　产品（Product）角色：产品便是建造中的复杂对象。一般来说，一个系统中会有多于一个的产品类，而且这些产品类并不一定有共同的接口，而完全可以是不相关联的。 　　 　　导演者角色是与客户端打交道的角色。导演者将客户端创建产品的请求划分为对各个零件的建造请求，再将这些请求委派给具体建造者角色。具体建造者角色是做具体建造工作的，但是却不为客户端所知。 　　一般来说，每有一个产品类，就有一个相应的具体建造者类。这些产品应当有一样数目的零件，而每有一个零件就相应地在所有的建造者角色里有一个建造方法。 源代码 　产品类Product public class Product {    /**     * 定义一些关于产品的操作     */    private String part1;    private String part2;    public String getPart1() {        return part1;    }    public void setPart1(String part1) {        this.part1 = part1;    }    public String getPart2() {        return part2;    }    public void setPart2(String part2) {        this.part2 = part2;    }} 抽象建造者类Builder public class ConcreteBuilder implements Builder {    private Product product = new Product();    /**     * 产品零件建造方法1     */    @Override    public void buildPart1() {        //构建产品的第一个零件 　　　　product.setPart1(\"编号：9527\");    }    /**     * 产品零件建造方法2     */    @Override    public void buildPart2() {        //构建产品的第二个零件 　　　　product.setPart2(\"名称：XXX\");    }    /**     * 产品返还方法     */    @Override    public Product retrieveResult() {        return product;    }} 导演者类Director public class Director {    /**     * 持有当前需要使用的建造器对象     */    private Builder builder;    /**     * 构造方法，传入建造器对象     * @param builder 建造器对象     */    public Director(Builder builder){        this.builder = builder;    }    /**     * 产品构造方法，负责调用各个零件建造方法     */    public void construct(){        builder.buildPart1();        builder.buildPart2();    }} 客户端类Client public class Client {    public static void main(String[]args){        Builder builder = new ConcreteBuilder();        Director director = new Director(builder);        director.construct();        Product product = builder.retrieveResult();        System.out.println(product.getPart1());        System.out.println(product.getPart2());    }} 时序图 客户端负责创建导演者和具体建造者对象。然后，客户端把具体建造者对象交给导演者，导演者操作具体建造者，开始创建产品。当产品完成后，建造者把产品返还给客户端。 　　把创建具体建造者对象的任务交给客户端而不是导演者对象，是为了将导演者对象与具体建造者对象的耦合变成动态的，从而使导演者对象可以操纵数个具体建造者对象中的任何一个。   使用场景 　　假设有一个电子杂志系统，定期地向用户的电子邮件信箱发送电子杂志。用户可以通过网页订阅电子杂志，也可以通过网页结束订阅。当客户开始订阅时，系统发送一个电子邮件表示欢迎，当客户结束订阅时，系统发送一个电子邮件表示欢送。本例子就是这个系统负责发送“欢迎”和“欢送”邮件的模块。 　　在本例中，产品类就是发给某个客户的“欢迎”和“欢送”邮件，如下图所示。 虽然在这个例子里面各个产品类均有一个共同的接口，但这仅仅是本例子特有的，并不代表建造模式的特点。建造模式可以应用到具有完全不同接口的产品类上。大多数情况下是不知道最终构建出来的产品是什么样的，所以在标准的建造模式里面，一般是不需要对产品定义抽象接口的，因为最终构造的产品千差万别，给这些产品定义公共接口几乎是没有意义的。 　　下图所示就是这个系统的类图。 这个系统含有客户端（Client）、导演者（Director）、抽象建造者（Builder）、具体建造者（WelcomeBuilder和GoodbyeBuilder）、产品（WelcomeMessage和GoodbyeMessage）等角色。 源代码 　　抽象类AutoMessage源代码，send()操作仅仅是示意性的，并没有给出任何发送电子邮件的代码。 public abstract class AutoMessage {    //收件人地址 private String to;    //发件人地址 private String from;    //标题 private String subject;    //内容 private String body;    //发送日期 private Date sendDate;    public void send(){        System.out.println(\"收件人地址：\" + to);        System.out.println(\"发件人地址：\" + from);        System.out.println(\"标题：\" + subject);        System.out.println(\"内容：\" + body);        System.out.println(\"发送日期：\" + sendDate);    }    public String getTo() {        return to;    }    public void setTo(String to) {        this.to = to;    }    public String getFrom() {        return from;    }    public void setFrom(String from) {        this.from = from;    }    public String getSubject() {        return subject;    }    public void setSubject(String subject) {        this.subject = subject;    }    public String getBody() {        return body;    }    public void setBody(String body) {        this.body = body;    }    public Date getSendDate() {        return sendDate;    }    public void setSendDate(Date sendDate) {        this.sendDate = sendDate;    }    } 具体产品类WelcomeMessage public class WelcomeMessage extends AutoMessage {    /**     * 构造子     */    public WelcomeMessage(){        System.out.println(\"发送欢迎信息\");    }} 具体产品类GoodbyeMessage public class GoodbyeMessage extends AutoMessage{    /**     * 构造子     */    public GoodbyeMessage(){        System.out.println(\"发送欢送信息\");    }} 抽象建造者类 public abstract class Builder {    protected AutoMessage msg;    //标题零件的建造方法 public abstract void buildSubject();    //内容零件的建造方法 public abstract void buildBody();    //收件人零件的建造方法 public void buildTo(String to){        msg.setTo(to);    }    //发件人零件的建造方法 public void buildFrom(String from){        msg.setFrom(from);    }    //发送时间零件的建造方法 public void buildSendDate(){        msg.setSendDate(new Date());    }    /**     * 邮件产品完成后，用此方法发送邮件     * 此方法相当于产品返还方法     */    public void sendMessage(){        msg.send();    }} 具体建造者WelcomeBuilder public class WelcomeBuilder extends Builder {    public WelcomeBuilder(){        msg = new WelcomeMessage();    }    @Override    public void buildBody() {        // TODO Auto-generated method stub 　　　　msg.setBody(\"欢迎内容\");    }    @Override    public void buildSubject() {        // TODO Auto-generated method stub 　　　　msg.setSubject(\"欢迎标题\");    }} 具体建造者GoodbyeBuilder public class GoodbyeBuilder extends Builder {    public GoodbyeBuilder(){        msg = new GoodbyeMessage();    }    @Override    public void buildBody() {        // TODO Auto-generated method stub 　　　　msg.setBody(\"欢送内容\");    }    @Override    public void buildSubject() {        // TODO Auto-generated method stub 　　　　msg.setSubject(\"欢送标题\");    }} 　导演者Director，这个类提供一个construct()方法，此方法调用建造者的建造方法，包括buildTo()、buildFrom()、buildSubject()、buildBody()、buildSendDate()等，从而一部分一部分地建造出产品对象，既AutoMessage对象。 public class Director {    Builder builder;    /**     * 构造子     */    public Director(Builder builder){        this.builder = builder;    }    /**     * 产品构造方法，负责调用各零件的建造方法     */    public void construct(String toAddress , String fromAddress){        this.builder.buildTo(toAddress);        this.builder.buildFrom(fromAddress);        this.builder.buildSubject();        this.builder.buildBody();        this.builder.buildSendDate();        this.builder.sendMessage();    }} 　客户端Client public class Client {    public static void main(String[] args) {        // TODO Auto-generated method stub 　　　　Builder builder = new WelcomeBuilder();        Director director = new Director(builder);        director.construct(\"toAddress@126.com\", \"fromAddress@126.com\");            }} 建造模式分成两个很重要的部分： 　　1. 一个部分是Builder接口，这里是定义了如何构建各个部件，也就是知道每个部件功能如何实现，以及如何装配这些部件到产品中去； 　　2. 另外一个部分是Director，Director是知道如何组合来构建产品，也就是说Director负责整体的构建算法，而且通常是分步骤地来执行。 　　不管如何变化，建造模式都存在这么两个部分，一个部分是部件构造和产品装配，另一个部分是整体构建的算法。认识这点是很重要的，因为在建造模式中，强调的是固定整体构建的算法，而灵活扩展和切换部件的具体构造和产品装配的方式。 　　再直白点说，建造模式的重心在于分离构建算法和具体的构造实现，从而使得构建算法可以重用。具体的构造实现可以很方便地扩展和切换，从而可以灵活地组合来构造出不同的产品对象。   使用建造模式构建复杂对象 　　考虑这样一个实际应用，要创建一个保险合同的对象，里面很多属性的值都有约束，要求创建出来的对象是满足这些约束规则的。约束规则比如：保险合同通常情况下可以和个人签订，也可以和某个公司签订，但是一份保险合同不能同时与个人和公司签订。这个对象里有很多类似这样的约束，采用建造模式来构建复杂的对象，通常会对建造模式进行一定的简化，因为目标明确，就是创建某个复杂对象，因此做适当简化会使程序更简洁。大致简化如下： 　　●　　由于是用Builder模式来创建某个对象，因此就没有必要再定义一个Builder接口，直接提供一个具体的建造者类就可以了。 　　●　　对于创建一个复杂的对象，可能会有很多种不同的选择和步骤，干脆去掉“导演者”，把导演者的功能和Client的功能合并起来，也就是说,Client这个时候就相当于导演者，它来指导构建器类去构建需要的复杂对象。 　　保险合同类 /** * 保险合同对象 */public class InsuranceContract {    //保险合同编号 　　private String contractId;    /**     * 被保险人员的名称，同一份保险合同，要么跟人员签订，要么跟公司签订     * 也就是说，“被保险人员”和“被保险公司”这两个属性，不可能同时有值     */    private String personName;    //被保险公司的名称 　　private String companyName;    //保险开始生效日期 　　private long beginDate;    //保险失效日期，一定会大于保险开始生效日期 　　private long endDate;    //其他数据 　　private String otherData;    //私有构造方法 　　private InsuranceContract(ConcreteBuilder builder){        this.contractId = builder.contractId;        this.personName = builder.personName;        this.companyName = builder.companyName;        this.beginDate = builder.beginDate;        this.endDate = builder.endDate;        this.otherData = builder.otherData;    }    /**     * 保险合同的一些操作     */    public void someOperation(){        System.out.println(\"当前正在操作的保险合同编号为【\"+this.contractId+\"】\");    }    public static class ConcreteBuilder{        private String contractId;        private String personName;        private String companyName;        private long beginDate;        private long endDate;        private String otherData;        /**         * 构造方法，传入必须要有的参数         * @param contractId     保险合同编号         * @param beginDate        保险合同开始生效日期         * @param endDate        保险合同失效日期         */        public ConcreteBuilder(String contractId,long beginDate,long endDate){            this.contractId = contractId;            this.beginDate = beginDate;            this.endDate = endDate;        }        //被保险人员的名称 　　　　public ConcreteBuilder setPersonName(String personName) {            this.personName = personName;            return this;        }        //被保险公司的名称 　　　　public ConcreteBuilder setCompanyName(String companyName) {            this.companyName = companyName;            return this;        }        //其他数据 　　　　public ConcreteBuilder setOtherData(String otherData) {            this.otherData = otherData;            return this;        }        /**         * 构建真正的对象并返回         * @return    构建的保险合同对象         */        public InsuranceContract build(){            if(contractId == null || contractId.trim().length()==0){                throw new IllegalArgumentException(\"合同编号不能为空\");            }            boolean signPerson = (personName != null && personName.trim().length() > 0);            boolean signCompany = (companyName != null && companyName.trim().length() > 0);            if(signPerson && signCompany){                throw new IllegalArgumentException(\"一份保险合同不能同时与个人和公司签订\");            }            if(signPerson == false && signCompany == false){                throw new IllegalArgumentException(\"一份保险合同不能没有签订对象\");            }            if(beginDate <= 0 ){                throw new IllegalArgumentException(\"一份保险合同必须有开始生效的日期\");            }            if(endDate <=0){                throw new IllegalArgumentException(\"一份保险合同必须有失效的日期\");            }            if(endDate < beginDate){                throw new IllegalArgumentException(\"一份保险合同的失效日期必须大于生效日期\");            }            return new InsuranceContract(this);        }    }} 客户端类 public class Client {    public static void main(String[]args){        //创建构建器对象 　　　　InsuranceContract.ConcreteBuilder builder =            new InsuranceContract.ConcreteBuilder(\"9527\", 123L, 456L);        //设置需要的数据，然后构建保险合同对象 　　　　InsuranceContract contract =             builder.setPersonName(\"小明\").setOtherData(\"test\").build();        //操作保险合同对象的方法 　　　　contract.someOperation();    }} 在本例中将具体建造者合并到了产品对象中，并将产品对象的构造函数私有化，防止客户端不使用构建器来构建产品对象，而是直接去使用new来构建产品对象所导致的问题。另外，这个构建器的功能就是为了创建被构建的对象，完全可以不用单独一个类。 在什么情况下使用建造模式 　　1. 需要生成的产品对象有复杂的内部结构，每一个内部成分本身可以是对象，也可以仅仅是一个对象（即产品对象）的一个组成部分。 　　2. 需要生成的产品对象的属性相互依赖。建造模式可以强制实行一种分步骤进行的建造过程，因此，如果产品对象的一个属性必须在另一个属性被赋值之后才可以被赋值，使用建造模式是一个很好的设计思想。 　　3. 在对象创建过程中会使用到系统中的其他一些对象，这些对象在产品对象的创建过程中不易得到。 转载自：http://www.cnblogs.com/java-my-life/archive/2012/04/07/2433939.html","title":"设计模式(20) ------------建造者模式"},{"content":"设计模式主要分三个类型:创建型、结构型和行为型。 其中创建型有： 一、Singleton，单例模式：保证一个类只有一个实例，并提供一个访问它的全局访问点 二、Abstract Factory，抽象工厂：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们的具体类。 三、Factory Method，工厂方法：定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到了子类。 四、Builder，建造模式：将一个复杂对象的构建与他的表示相分离，使得同样的构建过程可以创建不同的表示。 五、Prototype，原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新的对象。 行为型有： 六、Iterator，迭代器模式：提供一个方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部表示。 七、Observer，观察者模式：定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知自动更新。 八、Template Method，模板方法：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，TemplateMethod使得子类可以不改变一个算法的结构即可以重定义该算法得某些特定步骤。 九、Command，命令模式：将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队和记录请求日志，以及支持可撤销的操作。 十、State，状态模式：允许对象在其内部状态改变时改变他的行为。对象看起来似乎改变了他的类。 十一、Strategy，策略模式：定义一系列的算法，把他们一个个封装起来，并使他们可以互相替换，本模式使得算法可以独立于使用它们的客户。 十二、Chain of Responsibility，职责链模式：使多个对象都有机会处理请求，从而避免请求的送发者和接收者之间的耦合关系 十三、Mediator，中介者模式：用一个中介对象封装一些列的对象交互。 十四、Visitor，访问者模式：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这个元素的新操作。 十五、Interpreter，解释器模式：给定一个语言，定义他的文法的一个表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 十六、Memento，备忘录模式：在不破坏对象的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 结构型有： 十七、Composite，组合模式：将对象组合成树形结构以表示部分整体的关系，Composite使得用户对单个对象和组合对象的使用具有一致性。 十八、Facade，外观模式：为子系统中的一组接口提供一致的界面，fa?ade提供了一高层接口，这个接口使得子系统更容易使用。 十九、Proxy，代理模式：为其他对象提供一种代理以控制对这个对象的访问 二十、Adapter,适配器模式：将一类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作那些类可以一起工作。 二十一、Decrator，装饰模式：动态地给一个对象增加一些额外的职责，就增加的功能来说，Decorator模式相比生成子类更加灵活。 二十二、Bridge，桥模式：将抽象部分与它的实现部分相分离，使他们可以独立的变化。 二十三、Flyweight，享元模式","title":"23中设计模式小结"},{"content":"门面模式为了系统提供一个 统一的高层接口供外部客户使用。也就是提供一个更高的层次的接口，使得子系统更容易使用。 ◇定义一个（或多个）具备所需接口的新类（门面类） ； ◇新类门户使用原来的系统，负责原系统的逻辑操作； ◇客户使用门面类对象与原系统打交道，由此不再需要知道原系统的操作逻辑，从而避免逻辑混乱。 都写过纸质的信件吧，比如给女朋友写情书什么的，写信的过程大家都还记得吧，先写信的内容，然后写信封，然后把信放到信封中，封好，投递到信箱中进行邮递，这个过程还是比较简单的，虽然简单，这四个步骤都是要跑的呀，信多了还是麻烦，比如到了情人节，为了大海捞针，给十个女孩子发情书，都要这样跑一遍，你不要累死，更别说你要发个广告信啥的，一下子发 1 千万封邮件，那不就完蛋了？那怎么办呢？还好，现在邮局开发了一个新业务，你只要把信件的必要信息高速我，我给你发，我来做这四个过程，你就不要管了，只要把信件交给我就成了。  在这中环境下，最累的是写信的人，为了发送一封信出去要有四个步骤，而且这四个步骤还不能颠倒，你不可能没写信就把信放到信封吧，写信的人要知道这四个步骤，而且还要知道这四个步骤的顺序，恐怖吧。 先看写信的过程接口，定义了写信的四个步骤：    package com.cbf4life.facade;  /**   * 定义一个写信的过程   */  public interface LetterProcess {    //首先要写信的内容    public void writeContext(String context);    //其次写信封    public void fillEnvelope(String address);    //把信放到信封里    public void letterInotoEnvelope();    //然后邮递    public void sendLetter();  }  写信过程的具体实现：  package com.cbf4life.facade;  /**   * 写信的具体实现了   */  public class LetterProcessImpl implements LetterProcess {    //写信    public void writeContext(String context) {    System.out.println(\"填写信的内容....\" + context);   }    //在信封上填写必要的信息    public void fillEnvelope(String address) {    System.out.println(\"填写收件人地址及姓名....\" + address);   }    //把信放到信封中，并封好    public void letterInotoEnvelope() {    System.out.println(\"把信放到信封中....\");   }    //塞到邮箱中，邮递    public void sendLetter() {    System.out.println(\"邮递信件...\");   }  }  然后就有人开始用这个过程写信了：  package com.cbf4life.facade;  /**   * 我开始给朋友写信了   */  public class Client {    public static void main(String[] args) {     //创建一个处理信件的过程    LetterProcess letterProcess = new LetterProcessImpl();     //开始写信    letterProcess.writeContext(\"Hello,It's me,do you know who I am? I'm your  old lover. I'd like to....\");     //开始写信封    letterProcess.fillEnvelope(\"Happy Road No. 666,God Province,Heaven\");     //把信放到信封里，并封装好    letterProcess.letterInotoEnvelope();     //跑到邮局把信塞到邮箱，投递    letterProcess.sendLetter();   }  } 那这个过程与高内聚的要求相差甚远，你想，你要知道这四个步骤，而且还要知道这四个步骤的顺序，一旦出错，信就不可能邮寄出去，那我们如何来改进呢？   那就是使用门面模式，为了让调用者更方便的调用， 就对Sub  System进行了封装，增加了一个门面，Client 调用时，直接调用门面的方法就可以了，不用了解具体的实现方法以及相关的业务顺序，我们来看程序的改变，LetterProcess 接口和实现类都没有改变，只是增加了一个ModenPostOffice 类，我们这个 java程序清单如下：  package com.cbf4life.facade;  public class ModenPostOffice {    private LetterProcess letterProcess = new LetterProcessImpl();    //写信，封装，投递，一体化了    public void sendLetter(String context,String address){     //帮你写信     letterProcess.writeContext(context);     //写好信封     letterProcess.fillEnvelope(address);     //把信放到信封中     letterProcess.letterInotoEnvelope();     //邮递信件     letterProcess.sendLetter();   }  }  这个类是什么意思呢，就是说现在又一个叫 Hell Road PostOffice（地狱路邮局）提供了一种新型的服务，客户只要把信的内容以及收信地址给他们，他们就会把信写好，封好，并发送出去，这种服务提出时大受欢迎呀，这简单呀，客户减少了很多工作，那我们看看客户是怎么调用的，Client.java 的程序清单如下：  package com.cbf4life.facade;  /**   * 我开始给朋友写信了   */  public class Client {    public static void main(String[] args) {     //现代化的邮局，有这项服务，邮局名称叫Hell Road    ModenPostOffice hellRoadPostOffice = new ModenPostOffice();     //你只要把信的内容和收信人地址给他，他会帮你完成一系列的工作；    String address = \"Happy Road No. 666,God Province,Heaven\"; //定义一个地址    String context = \"Hello,It's me,do you know who I am? I'm your old lover.  I'd like to....\";    hellRoadPostOffice.sendLetter(context, address);  }  }    看到没，客户简单了很多，提供这种模式后，系统的扩展性也有了很大的提高，突然一个非常时期， 寄往 God Province（上帝省）的邮件都必须进行安全检查，那我们这个就很好处理了。   package com.cbf4life.facade;   public class ModenPostOffice {    private LetterProcess letterProcess = new LetterProcessImpl();    private Police letterPolice = new Police();       //写信，封装，投递，一体化了    public void sendLetter(String context,String address){         //帮你写信     letterProcess.writeContext(context);         //写好信封     letterProcess.fillEnvelope(address);       //警察要检查信件了     letterPolice.checkLetter(letterProcess);         //把信放到信封中     letterProcess.letterInotoEnvelope();     letterProcess.sendLetter();   }  }  只是增加了一个 letterPolice 变量的声明以及一个方法的调用，那这个写信的过程就变成了这样：先写信，然后写信封，然后警察开始检查，然后才把信放到信封，然后发送出去，那这个变更对客户来说，是透明的，他根本就看不到有人在检查他的邮件，他也不用了解，反正现代化的邮件都帮他做了，这也是他乐意的地方。  门面模式讲解完毕，这是一个很好的封装方法，一个子系统比较复杂的实话，比如算法或者业务比较复杂，就可以封装出一个或多个门面出来，项目的结构简单，而且扩展性非常好。还有，在一个较大项目中的时候，为了避免人员带来的风险，也可以使用这个模式，技术水平比较差的成员，尽量安排独立的模块（Sub System） ，然后把他写的程序封装到一个门面里，尽量让其他项目成员不用看到这些烂人的代码，看也看不懂，我也遇到过一个“高人”写的代码，private 方法、构造函数、常量基本都不用，你要一个public 方法，好，一个类里就一个 public 方法，所有代码都在里面，然后你就看吧，一大坨的程序，看着能把人逼疯，使用门面模式后，对门面进行单元测试，约束项目成员的代码质量，对项目整体质量的提升也是一个比较好的帮助。 ","title":"java_23种设计模式之门面模式"},{"content":"定义：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。 抽象工厂模式与工厂方法模式的区别         抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。         在抽象工厂模式中，有一个产品族的概念：所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。 示例如下： // 产品1接口 interface IProduct1 {  public void show(); } // 产品2接口 interface IProduct2 {  public void show(); } // 产品1实现 public class Product1 implements IProduct1 {  public void show() {   System.out.println(\"这是1型产品\");  } } // 产品2实现 public class Product2 implements IProduct2 {  public void show() {   System.out.println(\"这是2型产品\");  } } // 抽象工厂接口 interface IFactory {  public IProduct1 createProduct1();  public IProduct2 createProduct2(); } // 抽象工厂实现 public class Factory implements IFactory{  public IProduct1 createProduct1() {   return new Product1();  }  public IProduct2 createProduct2() {   return new Product2();  } } // 客户端 public class Client {  public static void main(String[] args){   IFactory factory = new Factory();   factory.createProduct1().show();   factory.createProduct2().show();  } } 抽象工厂模式的优点         抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。所谓的产品族，一般或多或少的都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理。 抽象工厂模式的缺点        产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。 适用场景        当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。 总结        无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。        所以，在使用工厂模式时，只需要关心降低耦合度的目的是否达到了。  ","title":"java_23种设计模式之抽象工厂模式"},{"content":"对于简单工厂模式来说其最大的缺点就是不完全满足OCP。为了解决这一缺点，设计师们提出了工厂方法模式。工厂方法模式和简单工厂模式最大的不同在于，简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。 下面我们通过修改简单工厂模式的实例来介绍工厂方法模式，其中红色的字体是与简单工程不同的地方，也就是实现了工厂的接口类。 1. package mode.test2.impler; /** * 运动员接口类——抽象产品类 * @author 张义 * */ public interface Sporters { /**   * 跑   */ public void run(); /**   * 跳   */ public void jump(); } 2. package mode.test2.impl; import mode.test2.impler.Sporters; /** * 篮球运动员——产品实现类 * @author 张义 * */ public class BasketballSporters implements Sporters { public void jump() {   System.out.println(\"篮球运动员跳......\"); } public void run() {   System.out.println(\"篮球运动员跑......\"); } } 3. package mode.test2.impl; import mode.test2.impler.Sporters; /** * 足球运动员——产品实现类 * @author 张义 * */ public class FootballSporters implements Sporters { public void jump() {   System.out.println(\"足球运动员跳......\"); } public void run() {   System.out.println(\"足球运动员跑......\"); } } 4. package mode.test2.factory; import mode.test2.impler.Sporters; /**  * 新的协会类——工厂类接口  * @author 张义  *  */ public interface SocietyNew {  /**   * 返回运动员   * @return 运动员   */  public Sporters returnSporters(); }   5. package mode.test2.factoryImpl; import mode.test2.factory.SocietyNew; import mode.test2.impl.BasketballSporters; import mode.test2.impler.Sporters; /**  * 新的协会类实现——工厂类实现  * @author 张义  *  */ public class BasketballSociety implements SocietyNew {  /**   * 返回篮球运动员   */  public Sporters returnSporters() {   return new BasketballSporters();  } }   6. package mode.test2.factoryImpl; import mode.test2.factory.SocietyNew; import mode.test2.impl.FootballSporters; import mode.test2.impler.Sporters; /**  * 新的协会类实现——工厂类实现  * @author 张义  *  */ public class FootballSocietyImpl implements SocietyNew {  /**   * 返回足球运动员   */  public Sporters returnSporters() {   return new FootballSporters();  } }   7.调用客户端 package mode.test2.main; import mode.test2.factoryImpl.BasketballSociety; import mode.test2.factoryImpl.FootballSocietyImpl; import mode.test2.impler.Sporters; /**  * 简单工厂模式_调用客户端  * @author 张义  *  */ public class Main {  /**   * 运动员1   */  private static Sporters s1;  /**   * 运动员3   */  private static Sporters s3;    public static void main(String[] args) {   s1 = new BasketballSociety().returnSporters();   s1.jump();   s1.run();   s3 = new FootballSocietyImpl().returnSporters();   s3.jump();   s3.run();  } } 以下为转载： 简单工厂模式与工厂方法模式大PK 从以上对两种模式的介绍可以了解到，工厂方法模式是为了克服简单工厂模式的缺点（主要是为了满足OCP）而设计出来的。但是，工厂方法模式就一定比简单工厂模式好呢？笔者的答案是不一定。下面笔者将详细比较两种模式。 1. 结构复杂度 从这个角度比较，显然简单工厂模式要占优。简单工厂模式只需一个工厂类，而工厂方法模式的工厂类随着产品类个数增加而增加，这无疑会使类的个数越来越多，从而增加了结构的复杂程度。 2.代码复杂度 代码复杂度和结构复杂度是一对矛盾，既然简单工厂模式在结构方面相对简洁，那么它在代码方面肯定是比工厂方法模式复杂的了。简单工厂模式的工厂类随着产品类的增加需要增加很多方法（或代码），而工厂方法模式每个具体工厂类只完成单一任务，代码简洁。 3.客户端编程难度 工厂方法模式虽然在工厂类结构中引入了接口从而满足了OCP，但是在客户端编码中需要对工厂类进行实例化。而简单工厂模式的工厂类是个静态类，在客户端无需实例化，这无疑是个吸引人的优点。 4.管理上的难度 这是个关键的问题。 我们先谈扩展。众所周知，工厂方法模式完全满足OCP，即它有非常良好的扩展性。那是否就说明了简单工厂模式就没有扩展性呢？答案是否定的。简单工厂模式同样具备良好的扩展性——扩展的时候仅需要修改少量的代码（修改工厂类的代码）就可以满足扩展性的要求了。尽管这没有完全满足OCP，但笔者认为不需要太拘泥于设计理论，要知道，sun提供的java官方工具包中也有想到多没有满足OCP的例子啊（java.util.Calendar这个抽象类就不满足OCP，具体原因大家可以分析下）。 然后我们从维护性的角度分析下。假如某个具体产品类需要进行一定的修改，很可能需要修改对应的工厂类。当同时需要修改多个产品类的时候，对工厂类的修改会变得相当麻烦（对号入座已经是个问题了）。反而简单工厂没有这些麻烦，当多个产品类需要修改是，简单工厂模式仍然仅仅需要修改唯一的工厂类（无论怎样都能改到满足要求吧？大不了把这个类重写）。 由以上的分析，笔者认为简单工厂模式更好用更方便些。当然这只是笔者的个人看法而已，毕竟公认的，工厂方法模式比简单工厂模式更“先进”。但有时过于先进的东西未必适合自己，这个见仁见智吧。  ","title":"java_23种设计模式之工厂方法模式"},{"content":"众所周知，JAVA最大的优点是他的完全OO化（面向对象）以及他多年的发展进程中吸收和总结的先进的架构和模式，其中呢，工厂模式是最常用的模式之一。 工厂模式包括三种：简单工厂模式、抽象工厂模式以及工厂方法模式。在此，现介绍一下简单工厂模式。 简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。 其包含的角色如下： 工厂角色：简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。 抽象产品角色：实质上是产品接口类，它负责描述所有实例所共有的公共接口。 具体产品角色：是简单工厂的实际创建目标，是抽象角色的具体实现。 具体示例如下： 1. package mode.test2.impler; /**  * 运动员接口类——抽象产品类  * @author 张义  *  */ public interface Sporters {  /**   * 跑   */  public void run();  /**   * 跳   */  public void jump(); } 2. package mode.test2.impl; import mode.test2.impler.Sporters; /**  * 篮球运动员——产品实现类  * @author 张义  *  */ public class BasketballSporters implements Sporters {  public void jump() {   System.out.println(\"篮球运动员跳......\");  }  public void run() {   System.out.println(\"篮球运动员跑......\");  } } 3. package mode.test2.impl; import mode.test2.impler.Sporters; /**  * 足球运动员——产品实现类  * @author 张义  *  */ public class FootballSporters implements Sporters {  public void jump() {   System.out.println(\"足球运动员跳......\");  }  public void run() {   System.out.println(\"足球运动员跑......\");  } } 4. package mode.test2.factory; import mode.test2.impl.BasketballSporters; import mode.test2.impl.FootballSporters; import mode.test2.impler.Sporters; /**  * 协会_工厂类  * @author 张义  *  */ public class Society {  /**   * 返回足球运动员   * @return 足球运动员   */  public static Sporters returnFootballSporters(){   return new FootballSporters();  }  /**   * 返回篮球运动员   * @return 篮球运动员   */  public static Sporters returnBasketballSporters(){   return new BasketballSporters();  } } 5. package mode.test2.main; import mode.test2.factory.Society; import mode.test2.impler.Sporters; /**  * 简单工厂模式_调用客户端  * @author 张义  *  */ public class Main {  /**   * 运动员1   */  private static Sporters s1;  /**   * 运动员3   */  private static Sporters s3;    public static void main(String[] args) {   // 运动员1 赋值   s1 = Society.returnFootballSporters();   s1.run();   s1.jump();   // 运动员3 赋值   s3 = Society.returnBasketballSporters();   s3.run();   s3.jump();  } } 6.优缺点： 优点：解决了不用知道具体的实现类就可以得到你想要的实例，从而不再需要把具体的实现类暴露给客户端了。 缺点：我们使用OCP（开放、封闭）原则看一下，不难看出，如果我们对系统进行拓展的话，如果添加一个乒乓球运动员，则我们需要添加一个实现类之外还需要修改工厂类，增加一个返回乒乓球运动员的方法。这一点上看不满足OCP原则。","title":"非23种GOF设计模式之简单工厂模式"},{"content":"1 作用 它指导我们如何提高代码的可重用度! 2 定义 一个类应该仅有一个引起它的变化的原因（职责），或者说一个类只负责一个功能领域中的相应职责。这条原则也称为类设计的“高内聚性原则”。 （l）含义之一：避免相同的职责（也称为功能）分散到不同的类中实现。 （2）含义之二：也应该要避免一个类承担过多的职责。 将过多的职责耦合在一个类中导致了脆弱设计。 软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。 3 单一职责原则分析 1)   一个类（或者大到模块，小到方法）承担的职责越多，它被复用的可能性越小。而且如果一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。 2)   类的职责主要包括两个方面：数据职责和行为职责，数据职责通过其属性来体现，而行为职责通过其方法来体现。 3)   单一职责原则是实现高内聚、低耦合的指导方针，在很多代码重构手法中都能找到它的存在，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。 4 为什么要遵守单一职责原则？ 可以减少类之间的耦合 当需求变化时，只修改一个类，从而也就隔离了变化； 如果一个类承担的职责过多，就等于把这些职责耦合在一块，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。 5 不遵守单一职责原则的后果 会影响到对该类的复用性。 当只需要复用该类的某一个职责时，但由于它和其它的职责耦合在一起，也就很难分离出。","title":"[置顶] 单一职责原则（Single Responsibility Principle）"},{"content":"作用 它指导我们如何正确地进行继承与派生，并合理地重用代码! 定义 子类型必须能够替换掉它们的父类型、并出现在父类能够出现的任何地方。 这个就是尽量用多态的方法编程，也就是GRASP模式中的多态。 如果对于每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有变化，那么类型T2是类型T1的子类型。 换言之，一个软件实体如果使用的是一个基类的话，那么一定适用于其子类，而且它根本不能察觉出基类对象和子类对象的区别。 反过来代换不成立。 里氏替换原则要点： 1)  对于LSP的违反也潜在的违反了OCP 2)  正方形从长方形继承的例子微妙的违反了这种原则 3)  在考虑一个特定的设计是否恰当时，不能孤立地来看这个解决方案，必须根据设计的使用者所做出的合理假设来审视它 4)  对象的行为方式是软件真正所关注的问题，IS A 关系是就行为而言的 5)  派生类只能使用相等或更弱的前置条件来替换原始的前置条件，只能使用相等或更强的前置条件来替换原始的后置条件。 6)  完成的功能少于基类的派生类通常不能替换基类，也不符合LSP 7)  派生类不应该抛出基类不能预计的异常，否则违反LSP 里氏代换原则分析 里氏代换原则可以通俗表述为：在软件中如果能够使用基类对象，那么一定能够使用其子类对象。把基类都替换成它的子类，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类的话，那么它不一定能够使用基类。 里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。","title":"里氏代换原则（Liskov Substitution Principle）"},{"content":"2012-05-20 21:36 （五）、生成器模式（建造者模式） 1、实现思维：将一个复杂的构建与其表示形式相分离。使得同样的构建过程可以创建不同的表示。 2、实例： 建造者模型（抽象类）： 具体建造者1：具体建造者2： 最终产品:指挥者： 客户端调用： 3、性能优缺：使得建造的代码与表示代码分离。构造者隐藏了产品的内部组合，如改变了产品的内部表示，则只需重新定义一个建造者就行。 （六）原型模式 1、实现思维：通过将一个原型对象传给一个要发动创建的对象，此对象通过请求原型对象拷贝他们自己来实施创建。 .Net中只要实现ICloneable接口的clone方法即可达到原型模型。 2、实例： 原型类： 使用实现： 结果截图： 3、性能优缺： 浅拷贝与深拷贝以及实现ICloneable接口的区别： 浅：只是单纯的对被复制对象成员的复制。不涉及被复制对象成员的成员。 深：把引用对象的变量指向复制的新对象，而不是原有的被引用的对象；对被复制对象成员的成员也进行了Clone()操作。 接口实现：在初始化信息不变的情况下，该方法最佳，它既隐藏了对象创建的细节，又对性能大大的提高。它不需要重新初始化对象，而是动态的获得对象运行时的状态。、 （七）桥接模式 1、实现思维：将类的接口与他的实现分离,无需修改客户端代码即可改或者替换实现过程。 用意(目录)：将抽象化与实现化脱耦，使得二者可独立改变。 脱耦：将抽象化与实现化的强关联改换成弱关联。 （合成/聚合复用原则在此处的体现） 2、实例： 用不同的画笔画出不同颜色的痕迹 类关系图： 父类颜色： 子类颜色1：子类颜色2： 父类画笔 子类画笔1：子类画笔2 使用实现： 3、性能优缺： 桥接模式很好的体现了“开放-封闭原则”和组合/聚合复用原则，而不是继承这2个面向对象的原则。 能力有限，有错之处，万望指出，非常感谢！","title":"设计模式二（建造者、原型、桥接）"},{"content":"2012-05-20 21:35   这2天为了设计模式搞晕了（因为在学校真的用的很少）所以又去把几个设计模式瞄了又瞄，想想每次都要重新敲一遍代码，干脆自己总结总结涨点经验，加深印象..... （一）简单工厂模式 1、实现思维：简单工厂模式是根据提供给他的数据，返回几个可能。类中的实例。通常他返回的是一个共同的父类和共同的方法，但是每个方法执行的任务不同，而且根据不同数据进行了优化。       2、实例：   父类：                        子类1：                                                        子类2：   工厂： 使用工厂： 1、 缺点：违反了“开放-封闭原则”。 2、  （二）工厂方法模式   1、实现思维：没有专门的类来决定所要实例化的子类，将此实现延迟到子类，这种模式实际没有决策点。   2、实例：   父类： 子类1：                                                  子类2： 基类工厂(接口)： 对应子类工厂1：                             对应子类工厂2：   使用：   3、性能优缺：虽然遵循了“开发-封闭原则”，但是当增加相应的产品时，必须增加一个相应的产品工厂，增大了开发量。 更换对象时，降低了客户程序与产品对象的耦合。 （三）抽象工厂模式    1、实现思维：提供一个创建一系列相关或者是相互依赖的对象接口，而不是需要指定他们具体的类。    2、实例：（反射机制在抽象工厂的应用）     反射机制：运行中的程序对自身进行检查（自审），并能直接操作程序的内部属性。 首先引用 父类（“工厂”,利用反射来取代工厂）： 子类：      反射机制的体现： 应用程序配置文件： 实现： (四)、单例模式   1、实现思维：确保某个类只有一个实例,而且自行实例化并向整个系统提供此类的实例（全局访问点）。此类成为单例类。（构造函数私有化）        2、实例（多线程）： 双重锁定。  以及静态初始化（密封类sealed）。 ①  、静态初始化实现单例类 ②  、双重锁定实现单例类 为什么使用2次判断？？解决了线程的并发问题，同时避免在每个instance属性方法的调用中出现独占锁定。        使用单例类（客户端实现）（多线程）       能力有限，有错之处望指出，非常感谢！","title":"设计模式一（工厂方法、抽象工厂、单例）"},{"content":"此范例共4个状态，2种操作，没用interface而是用abstract修饰的class实现。 调用：             TransServer ts = new TransServer();            Console.WriteLine(ts.StopServer());            Console.WriteLine(ts.StartServer());            Console.WriteLine(ts.StartServer());            Console.WriteLine(ts.StopServer());            Console.WriteLine(ts.StopServer());   实现：     internal abstract class State    {        internal TransServer transServer;        public abstract ErrorCode StartServer();        public abstract ErrorCode StopServer();    }    internal class StoppedState : State    {        public StoppedState(TransServer ts)        {            this.transServer = ts;        }        /// <summary>        /// Stopped --> Init --> Worked or Error or Others.        /// <\/summary>        /// <returns><\/returns>        public override ErrorCode StartServer()        {            // 下一个状态是initstate            this.transServer.SetState(this.transServer.GetInitState());            // do something...            // finishd...            // 下一个状态是WorkingState            this.transServer.SetState(this.transServer.GetWorkingState());            return ErrorCode.NoError;        }        /// <summary>        /// Do nothing.        /// <\/summary>        /// <returns><\/returns>        public override ErrorCode StopServer()        {            // it was already stopped!            return ErrorCode.AlreadyClosed;        }    }    internal class InitState : State    {        public InitState(TransServer ts)        {            this.transServer = ts;        }        /// <summary>        /// Do nothing.        /// <\/summary>        /// <returns><\/returns>        public override ErrorCode StartServer()        {            // 正在初始化，不应重复启动。            return ErrorCode.WaitUntilInitialed;        }        /// <summary>        /// Do nothing.        /// <\/summary>        /// <returns><\/returns>        public override ErrorCode StopServer()        {            // 初始化可以被终止吗？？            return ErrorCode.WaitUntilInitialed;        }    }    internal class WorkingState : State    {        /// <summary>        ///         /// <\/summary>        /// <param name=\"ts\"><\/param>        public WorkingState(TransServer ts)        {            this.transServer = ts;        }        /// <summary>        /// Do nothing.        /// <\/summary>        /// <returns><\/returns>        public override ErrorCode StartServer()        {            return ErrorCode.AlreadyStarted;        }        /// <summary>        /// Worked --> Stopped or Error or Others.        /// <\/summary>        /// <returns><\/returns>        public override ErrorCode StopServer()        {            // do something...            // finished            this.transServer.SetState(this.transServer.GetStoppedState());            return ErrorCode.NoError;        }    }    internal class ErrorState : State    {        public ErrorState(TransServer ts)        {            this.transServer = ts;        }        public override ErrorCode StartServer()        {            return ErrorCode.UnknowError;        }        public override ErrorCode StopServer()        {            return ErrorCode.UnknowError;        }    }    public class TransServer    {        State stoppedState;        internal State GetStoppedState()        {            return stoppedState;         }        State initState;        internal State GetInitState()        {            return initState;         }        State workingState;        internal State GetWorkingState()        {            return workingState;         }        State errorState;        internal State GetErrorState()        {            return errorState;         }        State state;        /// <summary>        /// 设置当前状态        /// <\/summary>        internal void SetState(State value)        {            state = value;        }        /// <summary>        /// 默认构造方法        /// <\/summary>        public TransServer()        {            stoppedState = new StoppedState(this);            initState = new InitState(this);            workingState = new WorkingState(this);            errorState = new ErrorState(this);            state = stoppedState;        }        public ErrorCode StartServer()        {            ErrorCode rv = state.StartServer();            return rv;        }        public ErrorCode StopServer()        {            ErrorCode rv = state.StopServer();            return rv;        }    }       /// <summary>    /// 错误码    /// <\/summary>    public enum ErrorCode    {        NoError = 0,        AlreadyClosed,        WaitUntilInitialed,        AlreadyStarted,        UnknowError,    }  ","title":"设计模式——状态，C# 语言范例"},{"content":"生成对象的代码封装在工厂类中                                                          public interface mobilePhone{\tpublic void call();}public class HTC implements mobilePhone{\tpublic void call(){\t\tSystem.out.println(\"HTC\");\t}}public class XIAOMI implements mobilePhone{\tpublic void call(){\t\tSystem.out.println(\"XIAOMI\");\t}}public class Factory{\t//返回类型为抽象产品\tpublic static mobilePhone produce(String s){\tif(s.equalsIgnoreCase(\"HTC\"))\t\treturn new HTC();\telse if(s.equalsIgnoreCase(\"XIAOMI\"))\t\treturn new XIAOMI();\t}}public class Magnate{\tpublic static void main(String[] args){\tmobilePhone phone=Factory.produce(\"HTC\");\tphone.call();\t}}","title":"设计模式(2)——简单工厂模式"},{"content":"工厂方法模式使用继承自抽象工厂角色的多个子类来代替简单工厂模式中的工厂类 public interface mobilePhone{\tpublic void call();}public interface Factory{\tpublic mobilePhone produce();}public class HTC implements mobilePhone{\tpublic void call(){\t\tSystem.out.println(\"HTC\");\t}}public class XIAOMI implements mobilePhone{\tpublic void call(){\t\tSystem.out.println(\"XIAOMI\");\t}}public class HTCFactory implements Factory{\tpublic mobilePhone  produce(){\treturn new HTC();\t}}public class XIAOMIFactory implements Factory{\tpublic mobilePhone  produce(){\treturn new XIAOMI();\t}}public class Magnate{\tpublic static void main(String[] args){\tFactory factory=new HTCFactory();\tmobilePhone phone=factory.produce();\tphone.call();\t}}","title":"设计模式(3)——工厂模式"},{"content":"  //抽象产品public interface smartPhone{\t}//抽象产品public interface commonPhone{}//抽象工厂public interface Factory{\tpublic smartPhone produceSP(String s);\tpublic commonPhone produceCP(String s);}public class MOTOSP implements smartPhone{\tpublic MOTOSP(String s){\tSystem.out.println(s);\t}}public class MOTOCP implements commonPhone{\tpublic MOTOCP(String s){\tSystem.out.println(s);\t}}public class NokiaSP implements smartPhone{\tpublic NokiaSP(String s){\tSystem.out.println(s);\t}}public class NokiaCP implements commonPhone{\tpublic NokiaCP(String s){\tSystem.out.println(s);\t}}public class MOTOFactory implements Factory{\tpublic smartPhone produceSP(String s){\treturn new MOTOSP(s);\t}\tpublic commonPhone produceCP(String s){\treturn new MOTOCP(s);\t}}public class NokiaFactory implements Factory{\tpublic smartPhone produceSP(String s){\treturn new NokiaSP(s);\t}\tpublic commonPhone produceCP(String s){\treturn new NokiaCP(s);\t}}public class Magnate{\tpublic static void main(String[] args){\tsmartPhone msp,nsp;\tcommonPhone mcp,ncp;\tNokiaFactory nf=new NokiaFactory();\tMOTOFactory mf=new MOTOFactory();\tmsp=mf.produceSP(\"milestone\");\tmcp=mf.produceCP(\"mm\");\tnsp=nf.produceSP(\"lumia\");\tncp=nf.produceCP(\"1120\");\t}}","title":"设计模式(4)——抽象工厂模式"},{"content":"概述：　　 迭代子模式又叫游标(Cursor)模式，是对象的行为模式。迭代子模式可以顺序地访问一个聚集中的元素而不必暴露聚集的内部表象（internal representation）。 参与者： Iterator：迭代器定义访问和遍历元素的接口。 ConcreteIterator(Controller)：具体迭代器实现迭代器接口，对该聚合遍历时跟踪当前位置。 Aggregate（Televation）:聚合定义了创建相应迭代器对象的接口。 ConcreteAggregate(HaierTV):具体聚合实现创建相应迭代器的接口，该操作返回ConcreteIterator的一个适当的实例。 协作关系：ConcreteIterator跟踪聚合中的当前对象，并能够计算出待遍历的后继对象。 使用迭代器的好处： 1. 他支持以不同的方式遍历一个聚合， 复杂的聚合可用多种方式进行遍历。 2. 迭代器简化了聚合的接口 有了迭代器的遍历接口，聚合本身就不需要类似的遍历接口了，这样就简化了聚合的接口。 3. 在同一个聚合上可以有多个遍历 每个迭代器保持它自己的遍历状态。因此你可以同时进行多个遍历。 例子： 在本例子中，Television定义了一个返回各个频道列表的接口，这实际上是一个工厂方法，只是生产出来的产品所属的类型支持Iterator的操作。 具体的代码如下所示： Iterator接口： package iterator;public interface Iterator{    public Item first();    public Item next();    public boolean isDone();    public Item currentItem();} Controller类实现了Iterator接口。 package iterator;import java.util.Vector;public class Controller implements Iterator{    private int current =0;    Vector channel;    public Controller(Vector v){       channel = v;    }    public Item first(){       current = 0;       return (Item)channel.get(current);    }    public Item next(){       current ++;       return (Item)channel.get(current);    }    public Item currentItem(){       return (Item)channel.get(current);    }    public boolean isDone(){       return current>= channel.size()-1;    }} Television接口： package iterator;import java.util.Vector;public interface Television{    public Iterator createIterator();    public Vector getChannel();} HaierTV类实现了Television接口 package iterator;import java.util.Vector;public class HaierTV implements Television{    private Vector channel;    public HaierTV(){       channel = new Vector();       channel.addElement(new Item(\"channel 1\"));       channel.addElement(new Item(\"channel 2\"));       channel.addElement(new Item(\"channel 3\"));       channel.addElement(new Item(\"channel 4\"));       channel.addElement(new Item(\"channel 5\"));       channel.addElement(new Item(\"channel 6\"));       channel.addElement(new Item(\"channel 7\"));    }    public Vector getChannel(){       return channel;    }    public Iterator createIterator(){       return new Controller(channel);    }}Client客户端： package iterator;public class Client{    public static void main(String[] args){       Television tv = new HaierTV();       Iterator it =tv.createIterator();       System.out.println(it.first().getName());       while(!it.isDone()){           System.out.println(it.next().getName());       }    }} Item类的接口： package iterator;public class Item{    private String name;    public Item(String aName){       name = aName;    }    public String getName(){       return name;    }} 总结：Iterator模式提供了一个访问聚合数据的简单思路，并支持多个迭代器同时访问。 转载自：http://tianli.blog.51cto.com/190322/37644/ 可参考：http://www.cnblogs.com/java-my-life/archive/2012/05/22/2511506.html","title":"设计模式(17) ------------迭代器模式"},{"content":"在阎宏博士的《JAVA与模式》一书中开头是这样描述备忘录（Memento）模式的： 　　备忘录模式又叫做快照模式(Snapshot Pattern)或Token模式，是对象的行为模式。 　　备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捕捉(Capture)住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。备忘录模式常常与命令模式和迭代子模式一同使用。 备忘录模式的结构 　　备忘录模式的结构图如下所示 备忘录模式所涉及的角色有三个：备忘录(Memento)角色、发起人(Originator)角色、负责人(Caretaker)角色。 　　备忘录(Memento)角色 　　备忘录角色又如下责任： 　　（1）将发起人（Originator）对象的内战状态存储起来。备忘录可以根据发起人对象的判断来决定存储多少发起人（Originator）对象的内部状态。 　　（2）备忘录可以保护其内容不被发起人（Originator）对象之外的任何对象所读取。 　　备忘录有两个等效的接口： 　　●　　窄接口：负责人（Caretaker）对象（和其他除发起人对象之外的任何对象）看到的是备忘录的窄接口(narrow interface)，这个窄接口只允许它把备忘录对象传给其他的对象。 　　●　　宽接口：与负责人对象看到的窄接口相反的是，发起人对象可以看到一个宽接口(wide interface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。 　　发起人（Originator）角色 　　发起人角色有如下责任： 　　（1）创建一个含有当前的内部状态的备忘录对象。 　　（2）使用备忘录对象存储其内部状态。 　　负责人（Caretaker）角色 　　负责人角色有如下责任： 　　（1）负责保存备忘录对象。 　　（2）不检查备忘录对象的内容。 　“白箱”备忘录模式的实现 　　备忘录角色对任何对象都提供一个接口，即宽接口，备忘录角色的内部所存储的状态就对所有对象公开。因此这个实现又叫做“白箱实现”。 　　“白箱”实现将发起人角色的状态存储在一个大家都看得到的地方，因此是破坏封装性的。但是通过程序员自律，同样可以在一定程度上实现模式的大部分用意。因此白箱实现仍然是有意义的。 　　下面给出一个示意性的“白箱实现”。 　源代码 　　发起人角色类，发起人角色利用一个新创建的备忘录对象将自己的内部状态存储起来。 public class Originator {    private String state;    /**     * 工厂方法，返回一个新的备忘录对象     */    public Memento createMemento(){        return new Memento(state);    }    /**     * 将发起人恢复到备忘录对象所记载的状态     */    public void restoreMemento(Memento memento){        this.state = memento.getState();    }        public String getState() {        return state;    }        public void setState(String state) {        this.state = state;        System.out.println(\"当前状态：\" + this.state);    }    } 备忘录角色类，备忘录对象将发起人对象传入的状态存储起来。 public class Memento {        private String state;        public Memento(String state){        this.state = state;    }    public String getState() {        return state;    }    public void setState(String state) {        this.state = state;    }    } 负责人角色类，负责人角色负责保存备忘录对象，但是从不修改（甚至不查看）备忘录对象的内容。 public class Caretaker {    private Memento memento;    /**     * 备忘录的取值方法     */    public Memento retrieveMemento(){        return this.memento;    }    /**     * 备忘录的赋值方法     */    public void saveMemento(Memento memento){        this.memento = memento;    }} 客户端角色类 public class Client {    public static void main(String[] args) {                Originator o = new Originator();        Caretaker c = new Caretaker();        //改变负责人对象的状态        o.setState(\"On\");        //创建备忘录对象，并将发起人对象的状态储存起来        c.saveMemento(o.createMemento());        //修改发起人的状态        o.setState(\"Off\");        //恢复发起人对象的状态        o.restoreMemento(c.retrieveMemento());                System.out.println(o.getState());    }} 在上面的这个示意性的客户端角色里面，首先将发起人对象的状态设置成“On”，并创建一个备忘录对象将这个状态存储起来；然后将发起人对象的状态改成“Off”；最后又将发起人对象恢复到备忘录对象所存储起来的状态，即“On”状态。 　　系统的时序图更能够反映出系统各个角色被调用的时间顺序。如下图是将发起人对象的状态存储到白箱备忘录对象中去的时序图。 可以看出系统运行的时序是这样的： 　　（1）将发起人对象的状态设置成“On”。 　　（2）调用发起人角色的createMemento()方法，创建一个备忘录对象将这个状态存储起来。 　　（3）将备忘录对象存储到负责人对象中去。 　　将发起人对象恢复到备忘录对象所记录的状态的时序图如下所示： 　可以看出，将发起人对象恢复到备忘录对象所记录的状态时，系统的运行时序是这样的： 　　（1）将发起人状态设置成“Off”。 　　（2）将备忘录对象从负责人对象中取出。 　　（3）将发起人对象恢复到备忘录对象所存储起来的状态，即“On”状态。 　“黑箱”备忘录模式的实现 　　备忘录角色对发起人（Originator）角色对象提供一个宽接口，而为其他对象提供一个窄接口。这样的实现叫做“黑箱实现”。 　　在JAVA语言中，实现双重接口的办法就是将备忘录角色类设计成发起人角色类的内部成员类。 　　将Memento设成Originator类的内部类，从而将Memento对象封装在Originator里面；在外部提供一个标识接口MementoIF给Caretaker以及其他对象。这样，Originator类看到的是Menmento的所有接口，而Caretaker以及其他对象看到的仅仅是标识接口MementoIF所暴露出来的接口。 　　使用内部类实现备忘录模式的类图如下所示。 源代码 　　发起人角色类Originator中定义了一个内部的Memento类。由于此Memento类的全部接口都是私有的，因此只有它自己和发起人类可以调用。 package memento.sample2;/** * @author chen_dz * @date ：2012-6-2 上午10:11:08 */public class Originator {    private String state;        public String getState() {        return state;    }    public void setState(String state) {        this.state = state;        System.out.println(\"赋值状态：\" + state);    }    /**     * 工厂方法，返还一个新的备忘录对象     */    public MementoIF createMemento(){        return new Memento(state);    }    /**     * 发起人恢复到备忘录对象记录的状态     */    public void restoreMemento(MementoIF memento){        this.setState(((Memento)memento).getState());    }        private class Memento implements MementoIF{                private String state;        /**         * 构造方法         */        private Memento(String state){            this.state = state;        }                private String getState() {            return state;        }        private void setState(String state) {            this.state = state;        }    }} 窄接口MementoIF，这是一个标识接口，因此它没有定义出任何的方法。 public interface MementoIF {} 负责人角色类Caretaker能够得到的备忘录对象是以MementoIF为接口的，由于这个接口仅仅是一个标识接口，因此负责人角色不可能改变这个备忘录对象的内容。 public class Caretaker {    private MementoIF memento;    /**     * 备忘录取值方法     */    public MementoIF retrieveMemento(){        return memento;    }    /**     * 备忘录赋值方法     */    public void saveMemento(MementoIF memento){        this.memento = memento;    }} 客户端角色类 public class Client {    public static void main(String[] args) {        Originator o = new Originator();        Caretaker c = new Caretaker();        //改变负责人对象的状态        o.setState(\"On\");        //创建备忘录对象，并将发起人对象的状态存储起来        c.saveMemento(o.createMemento());        //修改发起人对象的状态        o.setState(\"Off\");        //恢复发起人对象的状态        o.restoreMemento(c.retrieveMemento());    }} 客户端首先 　　（1）将发起人对象的状态设置为“On”。 　　（2）调用createMemento()方法，创建一个备忘录对象将这个状态存储起来（此时createMemento()方法还回的明显类型是MementoIF接口，真实类型为Originator内部的Memento对象）。 　　（3）将备忘录对象存储到负责人对象中去。由于负责人对象拿到的仅是MementoIF接口，因此无法读出备忘录对象内部的状态。 　　（4）将发起人对象的状态设置为“Off”。 　　（5）调用负责人对象的retrieveMemento()方法将备忘录对象取出。注意此时仅能得到MementoIF接口，因此无法读出此对象的内部状态。 　　（6）调用发起人对象的restoreMemento()方法将发起人对象的状态恢复成备忘录对象所存储的起来的状态，即“On”状态。由于发起人对象的内部类Memento实现了MementoIF接口，这个内部类是传入的备忘录对象的真实类型，因此发起人对象可以利用内部类Memento的私有接口读出此对象的内部状态。 　多重检查点 　　前面所给出的白箱和黑箱的示意性实现都是只存储一个状态的简单实现，也可以叫做只有一个检查点。常见的系统往往需要存储不止一个状态，而是需要存储多个状态，或者叫做有多个检查点。 　　备忘录模式可以将发起人对象的状态存储到备忘录对象里面，备忘录模式可以将发起人对象恢复到备忘录对象所存储的某一个检查点上。下面给出一个示意性的、有多重检查点的备忘录模式的实现。 　源代码 　　发起人角色源代码 public class Originator {    private List<String> states;    //检查点指数    private int index;    /**     * 构造函数     */    public Originator(){        states = new ArrayList<String>();        index = 0;    }    /**     * 工厂方法，返还一个新的备忘录对象     */    public Memento createMemento(){        return new Memento(states , index);    }    /**     * 将发起人恢复到备忘录对象记录的状态上     */    public void restoreMemento(Memento memento){        states = memento.getStates();        index = memento.getIndex();    }    /**     * 状态的赋值方法     */    public void setState(String state){        states.add(state);        index++;    }    /**     * 辅助方法，打印所有状态     */    public void printStates(){                for(String state : states){            System.out.println(state);        }    }} 备忘录角色类，这个实现可以存储任意多的状态，外界可以使用检查点指数index来取出检查点上的状态。　 public class Memento {    private List<String> states;    private int index;    /**     * 构造函数     */    public Memento(List<String> states , int index){        this.states = new ArrayList<String>(states);        this.index = index;    }    public List<String> getStates() {        return states;    }    public int getIndex() {        return index;    }    } 负责人角色类 public class Caretaker {    private Originator o;    private List<Memento> mementos = new ArrayList<Memento>();    private int current;    /**     * 构造函数     */    public Caretaker(Originator o){        this.o = o;        current = 0;    }    /**     * 创建一个新的检查点     */    public int createMemento(){        Memento memento = o.createMemento();        mementos.add(memento);        return current++;    }    /**     * 将发起人恢复到某个检查点     */    public void restoreMemento(int index){        Memento memento = mementos.get(index);        o.restoreMemento(memento);    }    /**     * 将某个检查点删除     */    public void removeMemento(int index){        mementos.remove(index);    }} 客户端角色源代码 public class Client {    public static void main(String[] args) {                Originator o = new Originator();        Caretaker c = new Caretaker(o);        //改变状态        o.setState(\"state 0\");        //建立一个检查点        c.createMemento();        //改变状态        o.setState(\"state 1\");        //建立一个检查点        c.createMemento();        //改变状态        o.setState(\"state 2\");        //建立一个检查点        c.createMemento();        //改变状态        o.setState(\"state 3\");        //建立一个检查点        c.createMemento();        //打印出所有检查点        o.printStates();        System.out.println(\"-----------------恢复检查点-----------------\");        //恢复到第二个检查点        c.restoreMemento(2);        //打印出所有检查点        o.printStates();    }} 运行结果如下： 　可以看出，客户端角色通过不断改变发起人角色的状态，并将之存储在备忘录里面。通过指明检查点指数可以将发起人角色恢复到相应的检查点所对应的状态上。 　　将发起人的状态存储到备忘录对象中的活动序列图如下： 系统运行的时序是这样的： 　　（1）将发起人对象的状态设置成某个有效状态； 　　（2）调用负责人角色的createMemento()方法，负责人角色会负责调用发起人角色和备忘录角色，将发起人对象的状态存储起来。 　　将发起人对象恢复到某一个备忘录对象的检查点的活动序列图如下： 由于负责人角色的功能被增强了，因此将发起人对象恢复到备忘录对象所记录的状态时，系统运行的时序被简化了： 　　（1）调用负责人角色的restoreMemento()方法，将发起人恢复到某个检查点。 　“自述历史”模式 　　所谓“自述历史”模式(History-On-Self Pattern)实际上就是备忘录模式的一个变种。在备忘录模式中，发起人(Originator)角色、负责人(Caretaker)角色和备忘录(Memento)角色都是独立的角色。虽然在实现上备忘录类可以成为发起人类的内部成员类，但是备忘录类仍然保持作为一个角色的独立意义。在“自述历史”模式里面，发起人角色自己兼任负责人角色。 　　“自述历史”模式的类图如下所示： 备忘录角色有如下责任： 　　（1）将发起人（Originator）对象的内部状态存储起来。 　　（2）备忘录可以保护其内容不被发起人（Originator）对象之外的任何对象所读取。 　　发起人角色有如下责任： 　　（1）创建一个含有它当前的内部状态的备忘录对象。 　　（2）使用备忘录对象存储其内部状态。 　　客户端角色有负责保存备忘录对象的责任。 　　源代码 　　窄接口MementoIF，这是一个标识接口，因此它没有定义出任何的方法。 public interface MementoIF {} 发起人角色同时还兼任负责人角色，也就是说它自己负责保持自己的备忘录对象。 public class Originator {    public String state;    /**     * 改变状态     */    public void changeState(String state){        this.state = state;        System.out.println(\"状态改变为：\" + state);    }    /**     * 工厂方法，返还一个新的备忘录对象     */    public Memento createMemento(){        return new Memento(this);    }    /**     * 将发起人恢复到备忘录对象所记录的状态上     */    public void restoreMemento(MementoIF memento){        Memento m = (Memento)memento;        changeState(m.state);    }        private class Memento implements MementoIF{                private String state;        /**         * 构造方法         */        private Memento(Originator o){            this.state = o.state;        }        private String getState() {            return state;        }            }} 客户端角色类 public class Client {    public static void main(String[] args) {        Originator o = new Originator();        //修改状态        o.changeState(\"state 0\");        //创建备忘录        MementoIF memento = o.createMemento();        //修改状态        o.changeState(\"state 1\");        //按照备忘录恢复对象的状态        o.restoreMemento(memento);    }} 　由于“自述历史”作为一个备忘录模式的特殊实现形式非常简单易懂，它可能是备忘录模式最为流行的实现形式。 转载自：http://www.cnblogs.com/java-my-life/archive/2012/06/06/2534942.html","title":"设计模式(18) ------------备忘录模式"},{"content":"JavaWeb技术之--面向对象设计模式 面向对象设计模式 面向对象软件开发领域中，设计模式包括一些规则来完成一定任务。设计模式针对一些特定的问题，提出一种解决方案。 常用的面向对象设计模式有4种： Factory模式、Singleton模式、Facade模式和MVC架构模式。 JSP设计模式 SUN公司推出JSP技术后，同时也推荐了两种web应用程序的开发模式，一种是JSP+JavaBean模式，一种是Servlet+JSP+JavaBean模式。 JSP设计模式包括两个： （1）Model1，JSP+JavaBean设计模式 （2）Model2，MVC设计模式 模式一JSP+JavaBean模式 在这种模式中，JSP页面独自响应请求并将处理结果返回客户，所有的数据库操作通过JavaBean来实现。 大量地使用这种模式，常会导致在JSP页面中嵌入大量的Java代码，当需要处理的商业逻辑非常复杂时，这种情况就会变得很糟糕。大量的Java代码使得JSP页面变得非常臃肿。前端的页面设计人员稍有不慎，就有可能破坏关系到商业逻辑的代码。 这种情况在大型项目中经常出现，造成了代码开发和维护的困难，同时会导致项目管理的困难。因此这种模式只适用于中小规模的项目。 JSP+JavaBean模式适合开发业务逻辑不太复杂的web应用程序，这种模式下，JavaBean用于封装业务数据，JSP即负责处理用户请求，又显示数据。 模式二 MVC模式 “MVC”模式即是：“Model-View-Controller”模式。在这种模式中，通过JSP技术来表现页面，通过Servlet技术来完成大量的事务处理工作，实现用户的商业逻辑。 在这种模式中，Servlet用来处理请求的事务，充当了控制器（Controller即“C”）的角色，Servlet负责响应客户对业务逻辑的请求并根据用户的请求行为，决定将哪个JSP页面发送给客户。JSP页面处于表现层，也就是视图（View即“V”）的角色。JavaBean则负责数据的处理，也就是模型（Model即“M”）的角色 Servlet+JSP+JavaBean(MVC)模式适合开发复杂的web应用，在这种模式下，servlet负责处理用户请求，jsp负责数据显示，javabean负责封装数据。 Servlet+JSP、JavaBean模式程序各个模块之间层次清晰，web开发推荐采用此种模式。 MVC架构 Model-View-Controller架构模式是80年代中期在Smalltalk-80 GUI（一种经典的面向对象程序设计语言）实验室发明的。 根据MVC模式，一个软件应该将商务逻辑（Model）和显示(View)分开。分开有许多好处，最主要的有两个方面： 1、同一的商务逻辑层（Model）可能会对应多个显示层（View），如果商务逻辑层和显示层放在一起的话，再添加一个显示层的时候就会极大的增加组件的复杂性。一个商务逻辑对着两个显示层的例子是：银行的帐户的商务逻辑层对应ATM和Internet两个显示层。 2、通常情况下，每次修改显示层的时候一般并不需要修改商务逻辑层。 MVC模式 MVC中三层的关系 MVC在JSP中的实现模型 目前有两种实现模型： （1）基于Bean的MVC模型。 （2）基于Stucts的MVC模型。 基于Bean的MVC模型 Bean可以利用JavaBean实现，也可以利用EJB来实现，分别构成的系统是： JavaBean（M）+JSP（V）+Servlet EJB（M）+JSP（V）+Servlet（C）实现。 基于Struts的MVC模型 Struts是Apache组织的一个项目，像其他的Apache组织的项目一样，它也是开放源码项目。 Struts是一个比较好的MVC框架提供了对开发MVC系统的底层支持，它采用的主要技术是Servlet，JSP和custom tag library。 Struts 是一组相互协作的类、Servlet和 JSP 标记，它们组成一个可重用的MVC设计。这个定义表示Struts是一个框架，而不是一个库，但Struts也包含了丰富的标记库和独立于该框架工作的实用程序类。Struts的基本结构如图所示。 JavaWeb技术之--面向对象设计模式 面向对象设计模式 面向对象软件开发领域中，设计模式包括一些规则来完成一定任务。设计模式针对一些特定的问题，提出一种解决方案。 常用的面向对象设计模式有4种： Factory模式、Singleton模式、Facade模式和MVC架构模式。 JSP设计模式 SUN公司推出JSP技术后，同时也推荐了两种web应用程序的开发模式，一种是JSP+JavaBean模式，一种是Servlet+JSP+JavaBean模式。 JSP设计模式包括两个： （1）Model1，JSP+JavaBean设计模式 （2）Model2，MVC设计模式 模式一JSP+JavaBean模式 在这种模式中，JSP页面独自响应请求并将处理结果返回客户，所有的数据库操作通过JavaBean来实现。 大量地使用这种模式，常会导致在JSP页面中嵌入大量的Java代码，当需要处理的商业逻辑非常复杂时，这种情况就会变得很糟糕。大量的Java代码使得JSP页面变得非常臃肿。前端的页面设计人员稍有不慎，就有可能破坏关系到商业逻辑的代码。 这种情况在大型项目中经常出现，造成了代码开发和维护的困难，同时会导致项目管理的困难。因此这种模式只适用于中小规模的项目。 JSP+JavaBean模式适合开发业务逻辑不太复杂的web应用程序，这种模式下，JavaBean用于封装业务数据，JSP即负责处理用户请求，又显示数据。 模式二 MVC模式 “MVC”模式即是：“Model-View-Controller”模式。在这种模式中，通过JSP技术来表现页面，通过Servlet技术来完成大量的事务处理工作，实现用户的商业逻辑。 在这种模式中，Servlet用来处理请求的事务，充当了控制器（Controller即“C”）的角色，Servlet负责响应客户对业务逻辑的请求并根据用户的请求行为，决定将哪个JSP页面发送给客户。JSP页面处于表现层，也就是视图（View即“V”）的角色。JavaBean则负责数据的处理，也就是模型（Model即“M”）的角色 Servlet+JSP+JavaBean(MVC)模式适合开发复杂的web应用，在这种模式下，servlet负责处理用户请求，jsp负责数据显示，javabean负责封装数据。 Servlet+JSP、JavaBean模式程序各个模块之间层次清晰，web开发推荐采用此种模式。 MVC架构 Model-View-Controller架构模式是80年代中期在Smalltalk-80 GUI（一种经典的面向对象程序设计语言）实验室发明的。 根据MVC模式，一个软件应该将商务逻辑（Model）和显示(View)分开。分开有许多好处，最主要的有两个方面： 1、同一的商务逻辑层（Model）可能会对应多个显示层（View），如果商务逻辑层和显示层放在一起的话，再添加一个显示层的时候就会极大的增加组件的复杂性。一个商务逻辑对着两个显示层的例子是：银行的帐户的商务逻辑层对应ATM和Internet两个显示层。 2、通常情况下，每次修改显示层的时候一般并不需要修改商务逻辑层。 MVC模式 MVC中三层的关系 MVC在JSP中的实现模型 目前有两种实现模型： （1）基于Bean的MVC模型。 （2）基于Stucts的MVC模型。 基于Bean的MVC模型 Bean可以利用JavaBean实现，也可以利用EJB来实现，分别构成的系统是： JavaBean（M）+JSP（V）+Servlet EJB（M）+JSP（V）+Servlet（C）实现。 基于Struts的MVC模型 Struts是Apache组织的一个项目，像其他的Apache组织的项目一样，它也是开放源码项目。 Struts是一个比较好的MVC框架提供了对开发MVC系统的底层支持，它采用的主要技术是Servlet，JSP和custom tag library。 Struts 是一组相互协作的类、Servlet和 JSP 标记，它们组成一个可重用的MVC设计。这个定义表示Struts是一个框架，而不是一个库，但Struts也包含了丰富的标记库和独立于该框架工作的实用程序类。Struts的基本结构如图所示。","title":"Java_常瑞鹏 jsp设计模式"},{"content":"《JAVA与模式》之命令模式 在阎宏博士的《JAVA与模式》一书中开头是这样描述命令（Command）模式的： 　　命令模式属于对象的行为模式。命令模式又称为行动(Action)模式或交易(Transaction)模式。 　　命令模式把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。 命令模式的结构 　　命令模式是对命令的封装。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。 　　每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。 　　命令允许请求的一方和接收请求的一方能够独立演化，从而具有以下的优点： 　　（1）命令模式使新的命令很容易地被加入到系统里。 　　（2）允许接收请求的一方决定是否要否决请求。 　　（3）能较容易地设计一个命令队列。 　　（4）可以容易地实现对请求的撤销和恢复。 　　（5）在需要的情况下，可以较容易地将命令记入日志。 　　下面以一个示意性的系统，说明命令模式的结构。 命令模式涉及到五个角色，它们分别是： 　　●　　客户端(Client)角色：创建一个具体命令(ConcreteCommand)对象并确定其接收者。 　　●　　命令(Command)角色：声明了一个给所有具体命令类的抽象接口。 　　●　　具体命令(ConcreteCommand)角色：定义一个接收者和行为之间的弱耦合；实现execute()方法，负责调用接收者的相应操作。execute()方法通常叫做执行方法。 　　●　　请求者(Invoker)角色：负责调用命令对象执行请求，相关的方法叫做行动方法。 　　●　　接收者(Receiver)角色：负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。 源代码 　　接收者角色类 public class Receiver {    /**     * 真正执行命令相应的操作     */    public void action(){        System.out.println(\"执行操作\");    }} 抽象命令角色类 public interface Command {    /**     * 执行方法     */    void execute();} 具体命令角色类 public class ConcreteCommand implements Command {    //持有相应的接收者对象    private Receiver receiver = null;    /**     * 构造方法     */    public ConcreteCommand(Receiver receiver){        this.receiver = receiver;    }    @Override    public void execute() {        //通常会转调接收者对象的相应方法，让接收者来真正执行功能        receiver.action();    }} 请求者角色类 public class Invoker {    /**     * 持有命令对象     */    private Command command = null;    /**     * 构造方法     */    public Invoker(Command command){        this.command = command;    }    /**     * 行动方法     */    public void action(){                command.execute();    }} 客户端角色类 public class Client {    public static void main(String[] args) {        //创建接收者        Receiver receiver = new Receiver();        //创建命令对象，设定它的接收者        Command command = new ConcreteCommand(receiver);        //创建请求者，把命令对象设置进去        Invoker invoker = new Invoker(command);        //执行方法        invoker.action();    }} AudioPlayer系统 　　小女孩茱丽(Julia)有一个盒式录音机，此录音机有播音(Play)、倒带(Rewind)和停止(Stop)功能，录音机的键盘便是请求者(Invoker)角色；茱丽(Julia)是客户端角色，而录音机便是接收者角色。Command类扮演抽象命令角色，而PlayCommand、StopCommand和RewindCommand便是具体命令类。茱丽(Julia)不需要知道播音(play)、倒带(rewind)和停止(stop)功能是怎么具体执行的，这些命令执行的细节全都由键盘(Keypad)具体实施。茱丽(Julia)只需要在键盘上按下相应的键便可以了。 　　录音机是典型的命令模式。录音机按键把客户端与录音机的操作细节分割开来。 源代码 　　接收者角色，由录音机类扮演 public class AudioPlayer {        public void play(){        System.out.println(\"播放...\");    }        public void rewind(){        System.out.println(\"倒带...\");    }        public void stop(){        System.out.println(\"停止...\");    }} 抽象命令角色类 public interface Command {    /**     * 执行方法     */    public void execute();} 具体命令角色类 public class PlayCommand implements Command {    private AudioPlayer myAudio;        public PlayCommand(AudioPlayer audioPlayer){        myAudio = audioPlayer;    }    /**     * 执行方法     */    @Override    public void execute() {        myAudio.play();    }} public class RewindCommand implements Command {    private AudioPlayer myAudio;        public RewindCommand(AudioPlayer audioPlayer){        myAudio = audioPlayer;    }    @Override    public void execute() {        myAudio.rewind();    }} public class StopCommand implements Command {    private AudioPlayer myAudio;        public StopCommand(AudioPlayer audioPlayer){        myAudio = audioPlayer;    }    @Override    public void execute() {        myAudio.stop();    }} 请求者角色，由键盘类扮演 public class Keypad {    private Command playCommand;    private Command rewindCommand;    private Command stopCommand;        public void setPlayCommand(Command playCommand) {        this.playCommand = playCommand;    }    public void setRewindCommand(Command rewindCommand) {        this.rewindCommand = rewindCommand;    }    public void setStopCommand(Command stopCommand) {        this.stopCommand = stopCommand;    }    /**     * 执行播放方法     */    public void play(){        playCommand.execute();    }    /**     * 执行倒带方法     */    public void rewind(){        rewindCommand.execute();    }    /**     * 执行播放方法     */    public void stop(){        stopCommand.execute();    }} 客户端角色，由茱丽小女孩扮演 public class Julia {    public static void main(String[]args){        //创建接收者对象        AudioPlayer audioPlayer = new AudioPlayer();        //创建命令对象        Command playCommand = new PlayCommand(audioPlayer);        Command rewindCommand = new RewindCommand(audioPlayer);        Command stopCommand = new StopCommand(audioPlayer);        //创建请求者对象        Keypad keypad = new Keypad();        keypad.setPlayCommand(playCommand);        keypad.setRewindCommand(rewindCommand);        keypad.setStopCommand(stopCommand);        //测试        keypad.play();        keypad.rewind();        keypad.stop();        keypad.play();        keypad.stop();    }} 运行结果如下： 宏命令 　　所谓宏命令简单点说就是包含多个命令的命令，是一个命令的组合。 　　设想茱丽的录音机有一个记录功能，可以把一个一个的命令记录下来，再在任何需要的时候重新把这些记录下来的命令一次性执行，这就是所谓的宏命令集功能。因此，茱丽的录音机系统现在有四个键，分别为播音、倒带、停止和宏命令功能。此时系统的设计与前面的设计相比有所增强，主要体现在Julia类现在有了一个新方法，用以操作宏命令键。 源代码 　　系统需要一个代表宏命令的接口，以定义出具体宏命令所需要的接口。 public interface MacroCommand extends Command {    /**     * 宏命令聚集的管理方法     * 可以添加一个成员命令     */    public void add(Command cmd);    /**     * 宏命令聚集的管理方法     * 可以删除一个成员命令     */    public void remove(Command cmd);} 具体的宏命令MacroAudioCommand类负责把个别的命令合成宏命令。 public class MacroAudioCommand implements MacroCommand {        private List<Command> commandList = new ArrayList<Command>();    /**     * 宏命令聚集管理方法     */    @Override    public void add(Command cmd) {        commandList.add(cmd);    }    /**     * 宏命令聚集管理方法     */    @Override    public void remove(Command cmd) {        commandList.remove(cmd);    }    /**     * 执行方法     */    @Override    public void execute() {        for(Command cmd : commandList){            cmd.execute();        }    }} 客户端类Julia public class Julia {        public static void main(String[]args){        //创建接收者对象        AudioPlayer audioPlayer = new AudioPlayer();        //创建命令对象        Command playCommand = new PlayCommand(audioPlayer);        Command rewindCommand = new RewindCommand(audioPlayer);        Command stopCommand = new StopCommand(audioPlayer);                MacroCommand marco = new MacroAudioCommand();                marco.add(playCommand);        marco.add(rewindCommand);        marco.add(stopCommand);        marco.execute();    }} 运行结果如下： 命令模式的优点 　　●　　更松散的耦合 　　命令模式使得发起命令的对象——客户端，和具体实现命令的对象——接收者对象完全解耦，也就是说发起命令的对象完全不知道具体实现对象是谁，也不知道如何实现。 　　●　　更动态的控制 　　命令模式把请求封装起来，可以动态地对它进行参数化、队列化和日志化等操作，从而使得系统更灵活。 　　●　　很自然的复合命令 　　命令模式中的命令对象能够很容易地组合成复合命令，也就是宏命令，从而使系统操作更简单，功能更强大。 　　●　　更好的扩展性 　　由于发起命令的对象和具体的实现完全解耦，因此扩展新的命令就很容易，只需要实现新的命令对象，然后在装配的时候，把具体的实现对象设置到命令对象中，然后就可以使用这个命令对象，已有的实现完全不用变化。 转载自：http://www.cnblogs.com/java-my-life/archive/2012/06/01/2526972.html","title":"设计模式(16) ------------命令模式"},{"content":"作用：它指导我们如何正确地消解模块间的依赖关系，同时它也是框架设计的核心原则。   依赖倒置原则的本质就是要求将类之间的关系建立在抽象接口的基础上的。Robert Martin这样描述依赖倒置原则[Martin 1996]： 传统的策略是把复杂的系统“化整为零，各个击破”。这就是通常所说的分解。SA方法（结构化的分析）也是采用这样的分解策略，把大型和复杂的软件系统分解成若干个人们易于理解和易于分析的子系统。这里的分解是根据软件系统的逻辑特性和系统内部各成分之间的逻辑关系进行的。在分解过程中，被分解的上层就是下层的抽象，下层为上层的具体细节。 我们尽量在抽象层进行控制编程，要针对接口编程，不要针对实现编程。 要依赖于抽象，不要依赖于具体。就是说我们尽量在抽象层进行控制编程，要针对接口编程，不要针对实现编程。 开闭原则是目标，而达到这一目标的手段是依赖倒转原则。 抽象层次包含的是应用系统的商务逻辑和宏观的、对整个系统来说重要的战略性决定，是必然性的体现，那么抽象层次就应当是较为稳定的，应当是复用的重点；也应当是维护的重点；而具体层次则含有一些次要的与实现有关的算法和逻辑，以及战术性的决定，带有相当大的偶然性选择。具体层次的代码是会经常有变动的，不能避免出现错误。","title":"依赖倒转原则（Dependency Inversion Principle）"},{"content":"public interface InterfaceTest{\tint a;}执行结果： D:\\src>javac InterfaceTest.java InterfaceTest.java:2: 错误: 需要=         int a;              ^ 1 个错误 【说明】:表示接口当中必须给其赋值。 public interface InterfaceTest{\tint a = 1;}编译通过 1. 接口中所声明的方法都是抽象方法。接口中的方法都是public的。 所以具体写法一般是这样:public static final int a = 1;但是通常情况下直接写为inta = 1； 2. 接口中也可以定义成员变量。接口中的成员变量都是 public、final、static 的。【很少有情况在接口里面定义属性，一般是在接口中定义方法的】接口主要主要是起到一个约定的作用，主要是定义一个规则比如访问修饰符、返回类型等。 3. 一个类不能既是final，又是abstract的。因为abstract的主要目的是定义一种约定，让子类去实现这种约定，而final表示该类不能被继承，这样abstract希望该类可以被继承而final明确说明该类不能被继承，两者矛盾。因此一个类不能既是final的，又是abstract的。 public abstract final class Test{}编译结果： D:\\src>javac Test.java Test.java:1: 错误: 非法的修饰符组合: abstract和final public abstract final class Test{                       ^ 1 个错误 4. Design Pattern（设计模式）：设计模式不是一种技术，而是解决问题的方式，不局限于Java，任何面向对象语言都可以实现，而且大量依托于多态，设计模式一种思想，经典的设计模式有23种。 5.单例模式（Singleton）：表示一个类只会生成唯一的一个对象。单例即只有一个实例。 单例模式设计思路： 1）先根据单例模式的定义写以下程序，再想思路。 public class SingletonTest{\tpublic static void main(String[] args){\t}}class Singleton{} 2）一个类生成一个对象，new出一个实例的时候势必会调用一次构造方法。 3）如果提供了构造方法，并且用private修饰这个构造方法，则这个构造方法就只能在Singleton类里面访问，此时外面就不能new这个对象了。 测试以下程序，验证用户在Singleton类外面不能new。 public class SingletonTest{\tpublic static void main(String[] args){\t\tSingleton singleton = new Singleton();\t}}class Singleton{\tprivate Singleton(){\t}} 编译结果： D:\\src>javac SingletonTest.java SingletonTest.java:3: 错误: Singleton()可以在Singleton中访问private                 Singleton singleton = new Singleton();                                       ^ 1 个错误 程序出现错误，所以可以把Singleton类里的构造函数用private修饰，通过这一点可以达到外部不能去访问Singleton类里的构造函数，从而达到不能new出Singleton的对象，此时距离只能new出一个实例接近了O(∩_∩)O~ 4）对于private的构造方法，只能在内部访问，所以在类里面是可以new的，具体思路是在Singleton里面new出一个对象，然后再提供一个方法，将这个对象想办法返回回来。然后在类的外部就不要new了就直接用提供的这个方法来接受返回回来的对象。 类似以下这个程序，当然只是作伪代码来分析。 public class SingletonTest{\tpublic static void main(String[] args){\t\tSingleton singleton = ...;\t}}class Singleton{\tprivate Singleton(){\t}\tpublic Singleton getInstance(){\t\treturn ...;\t}} 5）但是用下面这个程序执行的话，还是要new的，而之前定义的private的关系又导致不能new,所以此时应该换一种思路，将getInstance用static方法来修饰。这样外部就可以直接以类名.方法的形式调用了。 所以就有以下程序： public class SingletonTest{\tpublic static void main(String[] args){\t\tSingleton singleton = Singleton.getInstance();\t}}class Singleton{\tprivate Singleton(){\t}\tpublic static Singleton getInstance(){\t\treturn new Singleton();\t}}但是这种写法还不行，因为每次调用getInstance()都返回一个new出来的对象，这就不满足单例的需求。所以继续修改，我们可以先生成一个对象，然后调用一次就返回这个生成好的对象。 所以就有以下程序 public class SingletonTest{\tpublic static void main(String[] args){\t\tSingleton singleton = Singleton.getInstance();\t}}class Singleton{\tprivate Singleton singleton = new Singleton();\tprivate Singleton(){\t}\tpublic static Singleton getInstance(){\t\treturn singleton;\t}}在Singleton类里面，new一个对象，调用私有构造方法，返回一个实例给singleton，然后再方法getInstanc()里面返回这个实例，但是这个程序是没办法编译过的，因为getSingleton()方法是静态的，静态方法不能访问非静态方法，所以将private Singleton singleton = new Singleton();改为private static Singleton singleton = new Singleton(); 程序如下： public class SingletonTest{\tpublic static void main(String[] args){\t\tSingleton singleton = Singleton.getInstance();\t}}class Singleton{\tprivate static Singleton singleton = new Singleton();\tprivate Singleton(){\t}\tpublic static Singleton getInstance(){\t\treturn singleton;\t}} 此时，此时单例模式设计完成，但是还是看不出来是否这个程序是单例模式，所以我们可以生成两个实例，然后验证这两个实例是否是相同，如果相同则输出true，所以完整的程序如下所示 public class SingletonTest{      public static void main(String[] args){          Singleton singleton = Singleton.getInstance();          Singleton singleton2 = Singleton.getInstance();          System.out.println(singleton == singleton2);      }  }    class Singleton{      private static Singleton singleton = new Singleton();      private Singleton(){      }        public static Singleton getInstance(){          return singleton;      }  } 编译执行结果： D:\\src>java SingletonTest true 【说明】：如果这个实例singleton和singleton2是同一个实例，则这两个实例指向同一个对象则他们地址相同，所以输出为true。 第二种实现方式 public class SingletonTest{\tpublic static void main(String[] args){\t\tSingleton singleton = Singleton.getInstance();\t\tSingleton singleton2 = Singleton.getInstance();\t\tSystem.out.println(singleton == singleton2);\t}}class Singleton{\tprivate static Singleton singleton;\tprivate Singleton(){\t}\tpublic static Singleton getInstance(){\t\tif(singleton == null){\t\t\tsingleton = new Singleton();\t\t}\t\treturn singleton;\t\t\t}} 执行结果： D:\\src>java SingletonTest true 【说明】:这个程序是在getInstance()里面加一个判断，如果还没有生成实例，则new出一个实例，如果已经生成实例，就是不为空的时候，则返回这个实例。 这两种方式实现结果一样，但是在多线程环境中，第一种方式效果会好，以为第二种实现方式在多线程环境中可能会产生一些差异。","title":"JavaSE第二十五讲：单例模式详解"},{"content":"定义 又叫合成复用原则。原则就是在一个新的对象里面通过关联关系（包括组合关系和聚合关系）使用一些已有的对象，使之成为新对象的一部分，新对象通过委派调用已有对象的方法达到复用其已有功能的目的。也就是，要尽量使用类的合成复用，尽量不要使用继承。 组合/聚合复用原则要点： 就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，新的对象通过向这些对象的委派达到复用已有功能的目的。这个原则有一个简短的描述：要尽量使用合成、聚合，尽量不要使用继承。 1)  新对象存取成分对象的唯一方法是通过成分对象的接口 2)  这种复用是黑箱复用，因为成分对象的内部细节是新对象所看不到的 3)  这种复用可以在运行时间内动态进行，新对象可以动态的引用与成分对象类型相同的对象 4)  合成、聚合可以应用到任何环境中去，而继承只能应用到一些有限环境中去 5)  导致错误的使用合成、聚合与继承的一个常见原因是错误的把“Has-a”关系当作“Is-a”关系。如果两个类是“Has-a”关系那么应使用合成、聚合，如果是“Is-a”关系那么可使用继承 合成复用原则分析 在面向对象设计中，可以通过两种基本方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承。 1)   继承复用：实现简单，易于扩展。破坏系统的封装性，从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；只能在有限的环境中使用。（“白箱”复用 ） 2)   组合/聚合复用：耦合度相对较低，选择性地调用成员对象的操作；可以在运行时动态进行。（“黑箱”复用 ） 组合/聚合可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用； 其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。","title":"组合/聚合复用原则（Composition/Aggregation Principle）"},{"content":"迪米特法则(Law of Demeter, LoD)又称为最少知识原则(Least Knowledge Principle, LKP)，它有多种定义方法，其中几种典型定义如下： （1）   不要和“陌生人”说话。 （2）   只与你的直接朋友通信。 （3）   每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。 （4）   一个对象应当对其他对象有尽可能少的了解。 迪米特法则要点： 迪米特法则说的是一个对象应该对其它对象有尽可能少的了解。即只与你直接的朋友通信，不要跟陌生人说话。如果需要和陌生人通话，而你的朋友与陌生人是朋友，那么可以将你对陌生人的调用由你的朋友转发，使得某人只知道朋友，不知道陌生人。换言之，某人会认为他所调用的是朋友的方法。 以下条件称为朋友的条件： 1)  当前对象本身 2)  以参量的形式传入到当前对象方法中的对象 3)  当前对象的实例变量直接引用的对象 4)  当前对象的实例变量如果是一个聚集，那么聚集中的元素也都是朋友 5)  当前对象所创建的对象 迪米特法则的主要用意是控制信息的过载，在将其运用到系统设计中应注意以下几点： 1)  在类的划分上，应当创建有弱耦合的类。类之间的耦合越弱，就越有利于复用 2)  在类的结构设计上，每一个类都应当尽量降低成员的访问权限。一个类不应当public自己的属性，而应当提供取值和赋值的方法让外界间接访问自己的属性 3)  在类的设计上，只要有可能，一个类应当设计成不变类 4)  在对其它对象的引用上，一个类对其它对象的引用应该降到最低","title":"迪米特法则(Law of Demeter）"},{"content":"1、关联 双向关联： C1-C2：指双方都知道对方的存在，都可以调用对方的公共属性和方法。 在GOF的设计模式书上是这样描述的：虽然在分析阶段这种关系是适用的，但我们觉得它对于描述设计模式内的类关系来说显得太抽象了，因为在设计阶段关联关系必须被映射为对象引用或指针。对象引用本身就是有向的，更适合表达我们所讨论的那种关系。所以这种关系在设计的时候比较少用到，关联一般都是有向的。 使用ROSE 生成的代码是这样的： class C1  ...{ public:     C2* theC2; }; class C2  ...{ public:     C1* theC1; }; 双向关联在代码的表现为双方都拥有对方的一个指针，当然也可以是引用或者是值。 单向关联: C3->C4：表示相识关系，指C3知道C4，C3可以调用C4的公共属性和方法。没有生命期的依赖。一般是表示为一种引用。 生成代码如下： class C3  ...{ public:     C4* theC4; }; class C4  ...{ }; 单向关联的代码就表现为C3有C4的指针，而C4对C3一无所知。 自身关联（反身关联）： 自己引用自己，带着一个自己的引用。 代码如下： class C14  ...{ public:     C14* theC14; }; 就是在自己的内部有着一个自身的引用。 2、聚合/组合 当类之间有整体-部分关系的时候，我们就可以使用组合或者聚合。 聚合：表示C9聚合C10，但是C10可以离开C9而独立存在（独立存在的意思是在某个应用的问题域中这个类的存在有意义。这句话怎么解，请看下面组合里的解释）。 代码如下： class C9  ...{ public:     C10 theC10; }; class C10  ...{ };   组合（也有人称为包容）：一般是实心菱形加实线箭头表示，如上图所示，表示的是C8被C7包容，而且C8不能离开C7而独立存在。但这是视问题域而定的，例如在关心汽车的领域里，轮胎是一定要组合在汽车类中的，因为它离开了汽车就没有意义了。但是在卖轮胎的店铺业务里，就算轮胎离开了汽车，它也是有意义的，这就可以用聚合了。在《敏捷开发》中还说到，A组合B，则A需要知道B的生存周期，即可能A负责生成或者释放B，或者A通过某种途径知道B的生成和释放。 他们的代码如下： class C7  ...{ public:     C8 theC8; }; class C8  ...{ }; 可以看到，代码和聚合是一样的。具体如何区别，可能就只能用语义来区分了。 3、依赖 依赖: 指C5可能要用到C6的一些方法，也可以这样说，要完成C5里的所有功能，一定要有C6的方法协助才行。C5依赖于C6的定义，一般是在C5类的头文件中包含了C6的头文件。ROSE对依赖关系不产生属性。 注意，要避免双向依赖。一般来说，不应该存在双向依赖。 ROSE生成的代码如下： // C5.h #include \"C6.h\" class C5  ...{ }; // C6.h #include \"C5.h\" class C6 ...{ }; 虽然ROSE不生成属性，但在形式上一般是A中的某个方法把B的对象作为参数使用(假设A依赖于B)。如下： #include \"B.h\" class A ...{           void Func(B &b); } 那依赖和聚合\\组合、关联等有什么不同呢？ 关联是类之间的一种关系，例如老师教学生，老公和老婆，水壶装水等就是一种关系。这种关系是非常明显的，在问题领域中通过分析直接就能得出。 依赖是一种弱关联，只要一个类用到另一个类，但是和另一个类的关系不是太明显的时候（可以说是“uses”了那个类），就可以把这种关系看成是依赖，依赖也可说是一种偶然的关系，而不是必然的关系，就是“我在某个方法中偶然用到了它，但在现实中我和它并没多大关系”。例如我和锤子，我和锤子本来是没关系的，但在有一次要钉钉子的时候，我用到了它，这就是一种依赖，依赖锤子完成钉钉子这件事情。 组合是一种整体-部分的关系，在问题域中这种关系很明显，直接分析就可以得出的。例如轮胎是车的一部分，树叶是树的一部分，手脚是身体的一部分这种的关系，非常明显的整体-部分关系。 上述的几种关系（关联、聚合/组合、依赖）在代码中可能以指针、引用、值等的方式在另一个类中出现，不拘于形式，但在逻辑上他们就有以上的区别。 这里还要说明一下，所谓的这些关系只是在某个问题域才有效，离开了这个问题域，可能这些关系就不成立了，例如可能在某个问题域中，我是一个木匠，需要拿着锤子去干活，可能整个问题的描述就是我拿着锤子怎么钉桌子，钉椅子，钉柜子；既然整个问题就是描述这个，我和锤子就不仅是偶然的依赖关系了，我和锤子的关系变得非常的紧密，可能就上升为组合关系（让我突然想起武侠小说的剑不离身，剑亡人亡...）。这个例子可能有点荒谬，但也是为了说明一个道理，就是关系和类一样，它们都是在一个问题领域中才成立的，离开了这个问题域，他们可能就不复存在了。 4、泛化（继承） 泛化关系：如果两个类存在泛化的关系时就使用，例如父和子，动物和老虎，植物和花等。 ROSE生成的代码很简单，如下： #include \"C11.h\" class C12 : public C11 ...{ }; 5、这里顺便提一下模板 上面的图对应的代码如下： template<int> class C13  ...{ }; 这里再说一下重复度，其实看完了上面的描述之后，我们应该清楚了各个关系间的关系以及具体对应到代码是怎么样的，所谓的重复度，也只不过是上面的扩展，例如A和B有着“1对多”的重复度，那在A中就有一个列表，保存着B对象的N个引用，就是这样而已。 好了，到这里，已经把上面的类图关系说完了，希望你能有所收获了，我也费了不少工夫啊（画图、生成代码、截图、写到BLOG上，唉，一头大汗）。不过如果能让你彻底理解UML类图的这些关系，也值得了。:) +++++++++++++++++++++++++++++++++++++++++++++++++++++ 在UML建模中，对类图上出现元素的理解是至关重要的。开发者必须理解如何将类图上出现的元素转换到Java中。以java为代表结合网上的一些实例，下面是个人一些基本收集与总结：   基本元素符号：   1. 类（Classes） 类包含3个组成部分。第一个是Java中定义的类名。第二个是属性（attributes）。第三个是该类提供的方法。 属性和操作之前可附加一个可见性修饰符。加号（+）表示具有公共可见性。减号（-）表示私有可见性。#号表示受保护的可见性。省略这些修饰符表示具有package（包）级别的可见性。如果属性或操作具有下划线，表明它是静态的。在操作中，可同时列出它接受的参数，以及返回类型，如下图所示：   　　2. 包（Package） 包是一种常规用途的组合机制。UML中的一个包直接对应于Java中的一个包。在Java中，一个包可能含有其他包、类或者同时含有这两者。进行建模时，你通常拥有逻辑性的包，它主要用于对你的模型进行组织。你还会拥有物理性的包，它直接转换成系统中的Java包。每个包的名称对这个包进行了惟一性的标识。 　　3. 接口（Interface） 接口是一系列操作的集合，它指定了一个类所提供的服务。它直接对应于Java中的一个接口类型。接口既可用下面的那个图标来表示（上面一个圆圈符号，圆圈符号下面是接口名，中间是直线，直线下面是方法名），也可由附加了<<interface>>的一个标准类来表示。通常，根据接口在类图上的样子，就能知道与其他类的关系。 关　系：   1. 依赖（Dependency） 实体之间一个“使用”关系暗示一个实体的规范发生变化后，可能影响依赖于它的其他实例。更具体地说，它可转换为对不在实例作用域内的一个类或对象的任何类型的引用。其中包括一个局部变量，对通过方法调用而获得的一个对象的引用（如下例所示），或者对一个类的静态方法的引用（同时不存在那个类的一个实例）。也可利用“依赖”来表示包和包之间的关系。由于包中含有类，所以你可根据那些包中的各个类之间的关系，表示出包和包的关系。 　　2. 关联（Association） 实体之间的一个结构化关系表明对象是相互连接的。箭头是可选的，它用于指定导航能力。如果没有箭头，暗示是一种双向的导航能力。在Java中，关联转换为一个实例作用域的变量，就像图E的“Java”区域所展示的代码那样。可为一个关联附加其他修饰符。多重性（Multiplicity）修饰符暗示着实例之间的关系。在示范代码中，Employee可以有0个或更多的TimeCard对象。但是，每个TimeCard只从属于单独一个Employee。     3. 聚合（Aggregation） 聚合是关联的一种形式，代表两个类之间的整体/局部关系。聚合暗示着整体在概念上处于比局部更高的一个级别，而关联暗示两个类在概念上位于相同的级别。聚合也转换成Java中的一个实例作用域变量。 关联和聚合的区别纯粹是概念上的，而且严格反映在语义上。聚合还暗示着实例图中不存在回路。换言之，只能是一种单向关系。 　　4. 合成（Composition） 合成是聚合的一种特殊形式，暗示“局部”在“整体”内部的生存期职责。合成也是非共享的。所以，虽然局部不一定要随整体的销毁而被销毁，但整体要么负责保持局部的存活状态，要么负责将其销毁。 局部不可与其他整体共享。但是，整体可将所有权转交给另一个对象，后者随即将承担生存期职责。Employee和TimeCard的关系或许更适合表示成“合成”，而不是表示成“关联”。 　　5. 泛化（Generalization） 泛化表示一个更泛化的元素和一个更具体的元素之间的关系。泛化是用于对继承进行建模的UML元素。在Java中，用extends关键字来直接表示这种关系。   　　6. 实现（Realization） 实例关系指定两个实体之间的一个合同。换言之，一个实体定义一个合同，而另一个实体保证履行该合同。对Java应用程序进行建模时，实现关系可直接用implements关键字来表示。 像聚合还分为：非共享聚合、共享聚合、复合聚合等。以及其它内容，下次再补充。","title":"UML类图关系大全"},{"content":"三、组合模式     组合模式，也叫合成模式，树模式，它是一组对象的组合，这些对象可以是容器对象，表现为组的概念。     组合模式的意图是为了保证客户端调用单对象于组合对象的一致性。    涉及角色： 　　1.Component 是组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component 子部件。 　　2.Leaf 在组合中表示叶子结点对象，叶子结点没有子结点。 　　3.Composite 定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关操作，如增加(add)和删除(remove)等。     适用性 　　以下情况下适用组合模式： 　　1．你想表示对象的部分-整体层次结构 　　2．你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。    以下代码体现了组合模式的思想： package tree;public abstract class Tree {\t\t/**\t * 添加一个树节点\t * @param tree\t */\tpublic abstract void add(Tree tree);\t\t/**\t * 批量添加树节点\t * @param trees\t */\tpublic abstract void add(Tree[] trees);\t\t/**\t * 移除一个树节点\t * @param tree\t */\tpublic abstract void remove(Tree tree);\t} package cn.sunsharp.tbapp.util.tree;import java.util.ArrayList;import java.util.List;public class TreeNode extends Tree{        private Long id;        private Long parentId;        private List<Tree> children;        private String text;        private String state;        private Boolean checked;            public static class Builder{        private Long id;                private Long parentId;                private List<Tree> children = new ArrayList<Tree>();                private String text;                private String state;                private Boolean checked;                public Builder id(Long id){            this.id = id;            return this;        }                public Builder parentId(Long parentId){            this.parentId = parentId;            return this;        }                public Builder children(List<Tree> children){            this.children = children;            return this;        }                public Builder text(String text){            this.text = text;            return this;        }        public Builder state(String state){            this.state = state;            return this;        }                public Builder checked(Boolean checked){            this.checked = checked;            return this;        }        public Tree build(){            return new TreeNode(this);        }    }        @Override    public void add(Tree tree) {        children.add(tree);    }    @Override    public void remove(Tree tree) {        children.remove(tree);    }        @Override    public String toString() {        StringBuilder sb = new StringBuilder(1000);        sb.append(\"{id:\");        sb.append(id);        sb.append(\",text:\\\"\");        sb.append(text);        sb.append(\"\\\",iconCls:\");        sb.append(\"\\\"icon-ok\\\"\");        sb.append(\",children:\");        sb.append(children.toString());        sb.append(\"}\");        return sb.toString();    }            private TreeNode(Builder builder){        id = builder.id;        parentId = builder.parentId;        children = builder.children;        text = builder.text;        state = builder.state;        checked = builder.checked;    }    public Long getId() {        return id;    }        public Long getParentId() {        return parentId;    }        public String getText() {        return text;    }    public String getState() {        return state;    }    public Boolean getChecked() {        return checked;    }    public List<Tree> getChildren() {        return children;    }    @Override    public void add(Tree[] trees) {        for(Tree tree:trees){            children.add(tree);        }    }} public static void main(String[] args) {\t\tTree root = new TreeNode.Builder().text(\"根节点\").build();\t\tTree parent1 = new TreeNode.Builder().text(\"父节点1\").build();\t\tTree parent2 = new TreeNode.Builder().text(\"父节点2\").build();\t\troot.add(parent1);\t\troot.add(parent2);\t\tTree son11 = new TreeNode.Builder().text(\"子节点11\").build();\t\tTree son12 = new TreeNode.Builder().text(\"子节点12\").build();\t\tparent1.add(son11);\t\tparent1.add(son11);\t\tSystem.out.println(root.toString());\t}","title":"java23种设计模式三(连载)"},{"content":"设计原则名称 设计原则简介 重要性 单一职责原则 (Single Responsibility Principle, SRP) 类的职责要单一，不能将太多的职责放在一个类中。 ★★★★☆ 开闭原则 (Open-Closed Principle, OCP) 软件实体对扩展是开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展其功能。 ★★★★★ 里氏代换原则 (Liskov Substitution Principle, LSP) 在软件系统中，一个可以接受基类对象的地方必然可以接受一个子类对象。 ★★★★☆ 依赖倒转原则 (Dependency Inversion Principle, DIP) 要针对抽象层编程，而不要针对具体类编程。 ★★★★★ 接口隔离原则 (Interface Segregation Principle, ISP) 使用多个专门的接口来取代一个统一的接口。 ★★☆☆☆ 合成复用原则 (Composite Reuse Principle, CRP) 在系统中应该尽量多使用组合和聚合关联关系，尽量少使用甚至不使用继承关系。 ★★★★☆ 迪米特法则 (Law of Demeter, LoD) 一个软件实体对其他实体的引用越少越好，或者说如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，而是通过引入一个第三者发生间接交互。 ★★★☆☆","title":"面向对象设计原则"},{"content":"在阎宏博士的《JAVA与模式》一书中开头是这样描述模板方法（Template Method）模式的： 　　模板方法模式是类的行为模式。准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。 模板方法模式的结构 　　模板方法模式是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术。 　　模板方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)，这个设计模式的名字就是从此而来。 　　模板方法所代表的行为称为顶级行为，其逻辑称为顶级逻辑。模板方法模式的静态结构图如下所示： 这里涉及到两个角色： 　　抽象模板(Abstract Template)角色有如下责任： 　　■　　定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。 　　■　　定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。 　　具体模板(Concrete Template)角色又如下责任： 　　■　　实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。 　　■　　每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。 源代码 　　抽象模板角色类，abstractMethod()、hookMethod()等基本方法是顶级逻辑的组成步骤，这个顶级逻辑由templateMethod()方法代表。 public abstract class AbstractTemplate {    /**     * 模板方法     */    public void templateMethod(){        //调用基本方法        abstractMethod();        hookMethod();        concreteMethod();    }    /**     * 基本方法的声明（由子类实现）     */    protected abstract void abstractMethod();    /**     * 基本方法(空方法)     */    protected void hookMethod(){}    /**     * 基本方法（已经实现）     */    private final void concreteMethod(){        //业务相关的代码    }} 具体模板角色类，实现了父类所声明的基本方法，abstractMethod()方法所代表的就是强制子类实现的剩余逻辑，而hookMethod()方法是可选择实现的逻辑，不是必须实现的。 public class ConcreteTemplate extends AbstractTemplate{    //基本方法的实现    @Override    public void abstractMethod() {        //业务相关的代码    }    //重写父类的方法    @Override    public void hookMethod() {        //业务相关的代码    }} 模板模式的关键是：子类可以置换掉父类的可变部分，但是子类却不可以改变模板方法所代表的顶级逻辑。 　　每当定义一个新的子类时，不要按照控制流程的思路去想，而应当按照“责任”的思路去想。换言之，应当考虑哪些操作是必须置换掉的，哪些操作是可以置换掉的，以及哪些操作是不可以置换掉的。使用模板模式可以使这些责任变得清晰。 模板方法模式中的方法 　　模板方法中的方法可以分为两大类：模板方法和基本方法。 　　模板方法 　　一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。 　　一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法。 　　基本方法 　　基本方法又可以分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)。 　　●　　抽象方法：一个抽象方法由抽象类声明，由具体子类实现。在Java语言里抽象方法以abstract关键字标示。 　　●　　具体方法：一个具体方法由抽象类声明并实现，而子类并不实现或置换。 　　●　　钩子方法：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现。 　　在上面的例子中，AbstractTemplate是一个抽象类，它带有三个方法。其中abstractMethod()是一个抽象方法，它由抽象类声明为抽象方法，并由子类实现；hookMethod()是一个钩子方法，它由抽象类声明并提供默认实现，并且由子类置换掉。concreteMethod()是一个具体方法，它由抽象类声明并实现。 　　默认钩子方法 　　一个钩子方法常常由抽象类给出一个空实现作为此方法的默认实现。这种空的钩子方法叫做“Do Nothing Hook”。显然，这种默认钩子方法在缺省适配模式里面已经见过了，一个缺省适配模式讲的是一个类为一个接口提供一个默认的空实现，从而使得缺省适配类的子类不必像实现接口那样必须给出所有方法的实现，因为通常一个具体类并不需要所有的方法。 　　命名规则 　　命名规则是设计师之间赖以沟通的管道之一，使用恰当的命名规则可以帮助不同设计师之间的沟通。 　　钩子方法的名字应当以do开始，这是熟悉设计模式的Java开发人员的标准做法。在上面的例子中，钩子方法hookMethod()应当以do开头；在HttpServlet类中，也遵从这一命名规则，如doGet()、doPost()等方法。   使用场景 　　考虑一个计算存款利息的例子。假设系统需要支持两种存款账号，即货币市场(Money Market)账号和定期存款(Certificate of Deposite)账号。这两种账号的存款利息是不同的，因此，在计算一个存户的存款利息额时，必须区分两种不同的账号类型。 　　这个系统的总行为应当是计算出利息，这也就决定了作为一个模板方法模式的顶级逻辑应当是利息计算。由于利息计算涉及到两个步骤：一个基本方法给出账号种类，另一个基本方法给出利息百分比。这两个基本方法构成具体逻辑，因为账号的类型不同，所以具体逻辑会有所不同。 　　显然，系统需要一个抽象角色给出顶级行为的实现，而将两个作为细节步骤的基本方法留给具体子类实现。由于需要考虑的账号有两种：一是货币市场账号，二是定期存款账号。系统的类结构如下图所示。 　源代码 　　抽象模板角色类 public abstract class Account {    /**     * 模板方法，计算利息数额     * @return    返回利息数额     */    public final double calculateInterest(){        double interestRate = doCalculateInterestRate();        String accountType = doCalculateAccountType();        double amount = calculateAmount(accountType);        return amount * interestRate;    }    /**     * 基本方法留给子类实现     */    protected abstract String doCalculateAccountType();    /**     * 基本方法留给子类实现     */    protected abstract double doCalculateInterestRate();    /**     * 基本方法，已经实现     */    private double calculateAmount(String accountType){        /**         * 省略相关的业务逻辑         */        return 7243.00;    }} 具体模板角色类 public class MoneyMarketAccount extends Account {    @Override    protected String doCalculateAccountType() {                return \"Money Market\";    }    @Override    protected double doCalculateInterestRate() {                return 0.045;    }} public class CDAccount extends Account {    @Override    protected String doCalculateAccountType() {        return \"Certificate of Deposite\";    }    @Override    protected double doCalculateInterestRate() {        return 0.06;    }} 客户端类 public class Client {    public static void main(String[] args) {        Account account = new MoneyMarketAccount();        System.out.println(\"货币市场账号的利息数额为：\" + account.calculateInterest());        account = new CDAccount();        System.out.println(\"定期账号的利息数额为：\" + account.calculateInterest());    }} 转载自： http://www.cnblogs.com/java-my-life/archive/2012/05/14/2495235.html","title":"设计模式(15) ------------模板方法模式"},{"content":"在阎宏博士的《JAVA与模式》一书中开头是这样描述状态（State）模式的： 　　状态模式，又称状态对象模式（Pattern of Objects for States），状态模式是对象的行为模式。 　　状态模式允许一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样。 状态模式的结构 　　用一句话来表述，状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式的示意性类图如下所示： 注释：我认为我们在用的时候按下面这种方式好点（没有了像下面代码中过多的if else）： 　状态模式所涉及到的角色有： 　　●　　环境(Context)角色，也成上下文：定义客户端所感兴趣的接口，并且保留一个具体状态类的实例。这个具体状态类的实例给出此环境对象的现有状态。 　　●　　抽象状态(State)角色：定义一个接口，用以封装环境（Context）对象的一个特定的状态所对应的行为。 　　●　　具体状态(ConcreteState)角色：每一个具体状态类都实现了环境（Context）的一个状态所对应的行为。 源代码 　　环境角色类 public class Context {    //持有一个State类型的对象实例    private State state;    public void setState(State state) {        this.state = state;    }    /**     * 用户感兴趣的接口方法     */    public void request(String sampleParameter) {        //转调state来处理        state.handle(sampleParameter);    }} 　抽象状态类 public interface State {    /**     * 状态对应的处理     */    public void handle(String sampleParameter);} 具体状态类 public class ConcreteStateA implements State {    @Override    public void handle(String sampleParameter) {                System.out.println(\"ConcreteStateA handle ：\" + sampleParameter);    }} public class ConcreteStateB implements State {    @Override    public void handle(String sampleParameter) {                System.out.println(\"ConcreteStateB handle ：\" + sampleParameter);    }} 客户端类 public class Client {    public static void main(String[] args){        //创建状态        State state = new ConcreteStateB();        //创建环境        Context context = new Context();        //将状态设置到环境中        context.setState(state);        //请求        context.request(\"test\");    }} 从上面可以看出，环境类Context的行为request()是委派给某一个具体状态类的。通过使用多态性原则，可以动态改变环境类Context的属性State的内容，使其从指向一个具体状态类变换到指向另一个具体状态类，从而使环境类的行为request()由不同的具体状态类来执行。 使用场景 　　考虑一个在线投票系统的应用，要实现控制同一个用户只能投一票，如果一个用户反复投票，而且投票次数超过5次，则判定为恶意刷票，要取消该用户投票的资格，当然同时也要取消他所投的票；如果一个用户的投票次数超过8次，将进入黑名单，禁止再登录和使用系统。 　　要使用状态模式实现，首先需要把投票过程的各种状态定义出来，根据以上描述大致分为四种状态：正常投票、反复投票、恶意刷票、进入黑名单。然后创建一个投票管理对象（相当于Context）。 　　系统的结构图如下所示： 源代码 　　抽象状态类 public interface VoteState {    /**     * 处理状态对应的行为     * @param user    投票人     * @param voteItem    投票项     * @param voteManager    投票上下文，用来在实现状态对应的功能处理的时候，     *                         可以回调上下文的数据     */    public void vote(String user,String voteItem,VoteManager voteManager);} 具体状态类——正常投票 public class NormalVoteState implements VoteState {    @Override    public void vote(String user, String voteItem, VoteManager voteManager) {        //正常投票，记录到投票记录中        voteManager.getMapVote().put(user, voteItem);        System.out.println(\"恭喜投票成功\");    }} 具体状态类——重复投票 public class RepeatVoteState implements VoteState {    @Override    public void vote(String user, String voteItem, VoteManager voteManager) {        //重复投票，暂时不做处理        System.out.println(\"请不要重复投票\");    }} 　具体状态类——恶意刷票 public class SpiteVoteState implements VoteState {    @Override    public void vote(String user, String voteItem, VoteManager voteManager) {        // 恶意投票，取消用户的投票资格，并取消投票记录        String str = voteManager.getMapVote().get(user);        if(str != null){            voteManager.getMapVote().remove(user);        }        System.out.println(\"你有恶意刷屏行为，取消投票资格\");    }} 具体状态类——黑名单 public class BlackVoteState implements VoteState {    @Override    public void vote(String user, String voteItem, VoteManager voteManager) {        //记录黑名单中，禁止登录系统        System.out.println(\"进入黑名单，将禁止登录和使用本系统\");    }} 环境类 public class VoteManager {    //持有状体处理对象    private VoteState state = null;    //记录用户投票的结果，Map<String,String>对应Map<用户名称，投票的选项>    private Map<String,String> mapVote = new HashMap<String,String>();    //记录用户投票次数，Map<String,Integer>对应Map<用户名称，投票的次数>    private Map<String,Integer> mapVoteCount = new HashMap<String,Integer>();    /**     * 获取用户投票结果的Map     */    public Map<String, String> getMapVote() {        return mapVote;    }    /**     * 投票     * @param user    投票人     * @param voteItem    投票的选项     */    public void vote(String user,String voteItem){        //1.为该用户增加投票次数        //从记录中取出该用户已有的投票次数        Integer oldVoteCount = mapVoteCount.get(user);        if(oldVoteCount == null){            oldVoteCount = 0;        }        oldVoteCount += 1;        mapVoteCount.put(user, oldVoteCount);        //2.判断该用户的投票类型，就相当于判断对应的状态        //到底是正常投票、重复投票、恶意投票还是上黑名单的状态        if(oldVoteCount == 1){            state = new NormalVoteState();        }        else if(oldVoteCount > 1 && oldVoteCount < 5){            state = new RepeatVoteState();        }        else if(oldVoteCount >= 5 && oldVoteCount <8){            state = new SpiteVoteState();        }        else if(oldVoteCount > 8){            state = new BlackVoteState();        }        //然后转调状态对象来进行相应的操作        state.vote(user, voteItem, this);    }} 客户端类 public class Client {    public static void main(String[] args) {                VoteManager vm = new VoteManager();        for(int i=0;i<9;i++){            vm.vote(\"u1\",\"A\");        }    }} 　运行结果如下： 从上面的示例可以看出，状态的转换基本上都是内部行为，主要在状态模式内部来维护。比如对于投票的人员，任何时候他的操作都是投票，但是投票管理对象的处理却不一定一样，会根据投票的次数来判断状态，然后根据状态去选择不同的处理。 认识状态模式 　　●　　状态和行为 　　所谓对象的状态，通常指的就是对象实例的属性的值；而行为指的就是对象的功能，再具体点说，行为大多可以对应到方法上。 　　状态模式的功能就是分离状态的行为，通过维护状态的变化，来调用不同状态对应的不同功能。也就是说，状态和行为是相关联的，它们的关系可以描述为：状态决定行为。 　　由于状态是在运行期被改变的，因此行为也会在运行期根据状态的改变而改变。 　　●　　行为的平行性 　　注意平行线而不是平等性。所谓平行性指的是各个状态的行为所处的层次是一样的，相互独立的、没有关联的，是根据不同的状态来决定到底走平行线的哪一条。行为是不同的，当然对应的实现也是不同的，相互之间是不可替换的。 而平等性强调的是可替换性，大家是同一行为的不同描述或实现，因此在同一个行为发生的时候，可以根据条件挑选任意一个实现来进行相应的处理。 大家可能会发现状态模式的结构和策略模式的结构完全一样，但是，它们的目的、实现、本质却是完全不一样的。还有行为之间的特性也是状态模式和策略模式一个很重要的区别，状态模式的行为是平行性的，不可相互替换的；而策略模式的行为是平等性的，是可以相互替换的。 　　● 　　环境和状态处理对象 　　在状态模式中，环境(Context)是持有状态的对象，但是环境(Context)自身并不处理跟状态相关的行为，而是把处理状态的功能委托给了状态对应的状态处理类来处理。 　　在具体的状态处理类中经常需要获取环境(Context)自身的数据，甚至在必要的时候会回调环境(Context)的方法，因此，通常将环境(Context)自身当作一个参数传递给具体的状态处理类。 　　客户端一般只和环境(Context)交互。客户端可以用状态对象来配置一个环境(Context)，一旦配置完毕，就不再需要和状态对象打交道了。客户端通常不负责运行期间状态的维护，也不负责决定后续到底使用哪一个具体的状态处理对象。 转载自： http://www.cnblogs.com/java-my-life/archive/2012/06/08/2538146.html","title":"设计模式(14) ------------状态模式"},{"content":" 前一段时间接触到思维导图，感觉很好，今天自己弄了一个很简单的，简单记录下自己的android源码还有其他方面学习，内容会不断增加! 2012年11月13号之导图： 2012年11月14号之导图： 2012年11月18号之导图： 2012年11月28号之导图：                不知道这次提供的下载可不可以下载：                           http://download.csdn.net/detail/aomandeshangxiao/4782334 28号资源下载：http://download.csdn.net/detail/aomandeshangxiao/4823591 设计模式三种类型： 创建型模式主要用于创建对象 结构型模式主要用于处理类或对象的组合 行为型模式主要用于描述对类或对象怎样交互和怎样分配职责 范围\\目的 创建型模式 结构型模式 行为型模式 类模式 工厂方法模式 （类）适配器模式 解释器模式 模板方法模式 对象模式 抽象工厂模式 建造者模式 原型模式 单例模式 （对象）适配器模式 桥接模式 组合模式 装饰模式 外观模式 享元模式 代理模式 职责链模式 命令模式 迭代器模式 中介者模式 备忘录模式 观察者模式 状态模式 策略模式 访问者模式","title":"我的android学习思维导图（24号更新）"},{"content":"HeadFirst设计模式（中文版）－－68折，当当价：￥66.80 http://t.cn/zjzWUNh Strategy - 策略模式 策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模式把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。 不管当初软件设计得多好，一段时间之后，总是需要成长与改变，否则软件就会“死亡”。 设计原则(01): 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。 设计原则(02): 针对接口编程，而不是针对实现编程。 鸭子的子类将使用接口（FlyBehavior与QuackBehavior）所表示的行为，所以实际的“实现”不会被绑死在鸭子的子类中。","title":"设计模式（一）Strategy - 策略模式"},{"content":"简单工厂模式：又称静态工厂模式，它是用来实例化目标类的静态类。 工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到一个子类 抽象工厂模式：提供一个创建一系列相关或依赖对象的接串口，而无需指定它们具体的类 两者都是工厂模式，其目的都是对子类实例化的一个封装。但区别就在于一个是静态的，即实例化对象方法是固定的，而下面的实例化对象是由使用者来定义的。 下面我们通过例子来加强理解。 就拿现在的手机来说吧，现在手机的种类有很多很多，而且各式各样的，如果一个代工工厂代工生产有三种手机，比如诺基来的lumia920，三星的galaxy sIII，iphone 5的（此入打个比方）。三个手机运行着不同的操作系统，一个是wp8，一个android，一个ios，那么我们定义三个类 首先我们通过简单工厂模式来实现。 1‘、定义三者的通用接口 public interface  Product() {     public void showInfo(); } 2、三个实现 public class LumiaProduct implements Product {    public void showInfo()  {     System.out.Println(\"Lumia920 使用微软最新的windows 8操作系统\");  } } public class GalaxyProduct implements Product {  public void showInfo()  {    System.out.println(\"三星Galaxy SIII 是三星最新的旗舰机，运行着Android 操作系统\");  } } public class IphoneProduct implements Product {   public void showInfo()   {      System.out.println(\"iphone 5 是苹果工司最新的手机，运行着ios操作系统\");   } } 以上三个类分别表示了三种手机的基本信息。如果就这样让客户端调用的话，完全不符合面向对象的思想了。所以我们对其进行封装。以提高代码的重用性，以及代码的易用性 所以我们利用简单工厂模式对上述对象进行封装 public class ProductFactory   //工厂类 {    Product product;  public Product createProduct(String pro)  {     switch(pro)      {         case  \"lumia\" :         product=new LumiaProduct();        break;          case  \"galaxy\":         product=new GalaxyProduct();          break;          case  \"iphone\":          product=new IphoneProduct();          break;      }      return product;  } } 有了上述的工厂类，那么我们生产起手机来就方便了。 其它程序或函数调用就方便了 Product p; p=ProductFactory(\"lumia\"); p.showInfo(); p=ProductFactor(\"galaxy\"); p.showInfo(); p=ProductFactory(\"iphone\"); p.showInfo(); 从上述的例子中我们可以看出简单工厂模式的特点，就是实例化类的一个类，可以灵活的输出相应的子类，当然缺点也是显然的，如果这个工厂又要多加一款手机的话，那么要就修改工厂类了，这就不符合开放－封闭原则了。 所以我们就用工厂方法模式来修改，来使之能动态的实例化我们想要的类。 从简单工厂模式我们可以看出，其中的product接口是对三种手机的一个抽象，在工厂中其它的手机可以由它来表示。那么我们也定义这样的接口IFactory,来定义不同了子工厂类。 public interface IFactory() {    public  Product createProduct(); } 然后定义子工厂类 class LumiaFactory() implement IFactory {    public Product createProduct()   {     return new LumiaProduct();  } } class GalaxyFacotry implement IFactory {    public Product createProduct();     {        return new GalaxyProduct();     } } class IphoneFactory implement IFactory {     public Product createProduct()     {        return new IphoneProduct();      } } 那么我们在程序或函数中调用就可以方面了。 IFactory factory=new LumiaFactory(); Product pro=factory.createProduct(); pro.showInfo(); 其它同理 通过抽像工厂类，我们可以发现，如果要增加一款手机的手产，就不用改类了，只继承Product 类生成相应的手机类，然后继承IFactory 生成相就有工厂类就行了，那么就实现了动态的调用。 那么接下来我们再看看抽象工厂模式，抽象工厂模式其实是工厂模式的一个括充。比如我们这个工厂加在搞资，要增加平反电脑(我们在这里认为是另一种不同的product)，那我们如休在原来的基础上做出修改呢? 首先我们定义抽象 public interface NewProduct() {    public void showProduct(); } public void  iPad implement NewProduct {    public void showProduct()    {        System.out.println(\"Apple公司 新作\");      } public void NexusTen  implement NewProduct {     public void showProduct()     {        System.out.println(\"google公司新出的平板\");        } } 然后我们要定义工厂类了，于是我们在原先的工厂抽象类里面，加入新的定义，故IFactory可改为： public interface IFactory() {    public  Product createProduct();    public  NewProduct createNewProduct(); } 这样factor就能生产出新的平板了产品 public void IpadFactory implement IFacotry {      public NewProduct createNewProduct()     {          return new Ipad();      } } public void NexusTenFactory implement IFactory {    public NewProduct createNewProduct()    {       return new NexusTen();     } } 写到这大家一定可以发现利用工厂模式的好处了，无论是添加商品的个数，还是种类，都十分的方便，至于在程序中怎么调用，就比较简单了。 IFactory facotry=new IphomeFactory(); Product iphone=factory.createProduct(); NewProduct ipad=factory.createNewProduct(); iphone.showInfo(); ipad.showProduct(); 大功告成，是不是很神奇。。。。","title":"java 设计模式－－简单工厂模式,工厂方法模式，抽象工厂模式"},{"content":"二、外观模式     外观模式为他的子系统提供一个接口，使子系统能够更加方面的使用。使用外观模式，只需要少量代码，就能提供典型的、无修饰用法的类库中的类。一个外观就是一个类，它包含的功能介于工具包与完整的应用程序之间，为工具包或子系统的类提供了简单的用法。     外观类、工具类和示例类     外观类的方法可能都是静态方法，这种情况下，外观类在UML中被称作工具类。示例类就是演示如何使用类或子系统的例子。外观类所能提供的诸多使得之处，示例类也能提供。外观类可能属于类库，但实例类一定不属于类库。     在软件开发过程中，程序一般会越做越大，而这样系统中类及子系统之间的影响会使彼此间的关系变得错综复杂即过多的耦合，这就导致了随着系统中类或子系统发生变化，与之相关联的子系统或类就需要发生变化。 举例 电源总开关 为了使用方便，一个电源总开关可以控制两盏灯、一台空调和一台电视机的启动和关闭。通过该电源总开关可以同时控制上述所有电器设备，使用外观模式设计该系统。   外观模式的目的在于降低系统的复杂程度。 外观模式从很大程度上提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。   外观模式实例与解析 以计算机的加载和关闭过程为例   子系统角色：CPU、内存和硬盘。     外观角色：计算机。     客户：用户。 它们之间的依赖关系如图所示：   下面来看具体的实现。 （1）CPU类CPU.java  其中定义了启动和关闭CPU的函数。 CPU类CPU.java package structure.facade;   public class CPU {      public void startup() {  }           public void shutdown() {   }  } （2）内存类Memory.java其中定义了加载和清空内存的函数。     内存类Memory.java package structure.facade;   public class Memory {      public void startup() {  }       public void shutdown() { }  } （3）硬盘类Disk.java其中定义了加载和卸载硬盘的函数。   硬盘类Disk.java package structure.facade;   public class Disk {      public void startup() {    }           public void shutdown() {  }  } （4）外观模式类Computer.java 其中包含了CPU、内存和硬盘3个类对象，并定义了启动和关闭计算机的函数，在启动和关闭时批量地启动和关闭CPU、内存和硬盘。 外观模式类Computer.java package structure.facade;   /*  外观模式   */ public class Computer {        private CPU  cpu = new CPU(); …….        //声明对象          public void startup() { // 调用对象的方法   }          public void shutdown() {// 调用对象的方法 }  } （5）用户类User.java，我们只需要调用Computer.java的函数来启动和关闭计算机，而不需要依次加载和关闭CPU、内存和硬盘。 用户类User.java package structure.facade;   public class User {      public static void main(String args[]) {          Computer computer = new Computer();          computer.startup();  //调用        computer.shutdown();      }  } 总结： 从程序可以看出，通过Computer一个外观类即可实现计算机所有部件的控制，而不需要单独去控制其所有的部件，这正是外观模式的作用。","title":"java23种设计模式二(连载)"},{"content":"最近在学习设计模式，感觉简单的还是容易弄懂的，所以就写了个简单工厂模式，供学习设计模式的朋友一起学习。 楼主文笔不好，先贴上代码，供大家参考，如有错误，希望能留言指正。谢谢！ #include <iostream> using namespace std; class Product    //产品的基类 { public:  void virtual Show()=0; }; class ProductA:public Product   //产品A类 { public:  void Show()  {   cout<<\"ProductA is product\"<<endl;  } }; class ProductB:public Product   //产品B 类 { public:  void Show()  {   cout<<\"ProductB is product\"<<endl;  } }; class Factory     //工厂类 { public:  Product *producttype(int type)  {   if(type==0)    return new ProductA();   else    return new ProductB();  } }; int main()    //main函数入口 {  Factory factory;  Product *product;  product=factory.producttype(0);  product->Show();  delete product;  return 0; }      ","title":"C++设计模式之简单工厂模式"},{"content":"定义 策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。 UML 实现 Strategy.java，策略类，定义算法的公共接口。 public abstract class Strategy {    // 算法方法    public abstract void algorithmInterface(); }   ConcreteStrategyA.java，算法A，封装了具体算法，继承Strategy。 public class ConcreteStrategyA extends Strategy {    @Override    public void algorithmInterface() {       System.out.println(\"算法A实现\");    } }   ConcreteStrategyB.java，算法B。 public class ConcreteStrategyB extends Strategy {    @Override    public void algorithmInterface() {       System.out.println(\"算法B实现\");    } }   ConcreteStrategyC.java，算法C。 public class ConcreteStrategyC extends Strategy {    @Override    public void algorithmInterface() {       System.out.println(\"算法C实现\");    } }   Context.java，上下文环境，维护Strategy引用。 public class Context {    private Strategystrategy;    public Context(Strategy strategy) {       this.strategy = strategy;    }    public void contextInterface() {       strategy.algorithmInterface();    } }   StrategyTest.java，客户端代码。 public class StrategyTest {    public static void main(String[] args) {       Context context;       context = new Context(new ConcreteStrategyA());       context.contextInterface();       context = new Context(new ConcreteStrategyB());       context.contextInterface();       context = new Context(new ConcreteStrategyC());       context.contextInterface();    } } 优缺点 优点 1、   提供了一种替代继承的方法，而且既保持了继承的优点(代码重用)，还比继承更灵活(算法独立，可以任意扩展)； 2、   避免程序中使用多重条件转移语句，使系统更灵活，并易于扩展； 3、   遵守大部分GRASP原则和常用设计原则，高内聚、低偶合； 4、   易于进行单元测试，各个算法区分开，可以针对每个算法进行单元测试； 5、   …… 缺点 1、   因为每个具体策略类都会产生一个新类，所以会增加系统需要维护的类的数量； 2、   选择何种算法需要客户端来创建对象，增加了耦合，这里可以通过与工厂模式结合解决该问题； 3、   程序复杂化。 实例 需求 商场收银系统，实现对不同情况(正常收费、折扣收费、返利收费等)的收费。 实现 CashSuper.java，现金收费父类。 /* 现金收费父类 */ public abstract class CashSuper {    /* 收取现金方法，参数为商品原价，返回值为当前价 */    public abstract double acceptCash(double money); }   CashNormal.java，正常收费。 /* 正常收费 */ public class CashNormal extends CashSuper {    @Override    public double acceptCash(double money) {       return money;    } }   CashRebate.java，打折收费。 /* 打折收费 */ public class CashRebate extends CashSuper {    /* 折扣率 */    private double moneyRebate;       public CashRebate(double moneyRebate) {       this.moneyRebate = moneyRebate;    }      @Override    public double acceptCash(double money) {       return money *moneyRebate;    } }   CashReturn.java，返利收费。 /* 返利收费 */ public class CashReturn extends CashSuper {    /* 返利满足条件 */    private double moneyCondition;    /* 满足条件后返回值 */    private double moneyReturn;       public CashReturn(double moneyCondition,double moneyReturn) {       this.moneyCondition = moneyCondition;       this.moneyReturn = moneyReturn;    }      @Override    public double acceptCash(double money) {       double result = 0;       result = money - Math.floor(money / moneyCondition) * moneyReturn;       return result;    } }   CashContext.java，维护CashSuper对象。 public class CashContext {      private CashSupercs;       public CashContext(CashSuper cs) {       this.cs = cs;    }       public double getResult(double money) {       return cs.acceptCash(money);    } }   CashTest.java，客户端。 public class CashTest {    public static void main(String[] args) {       double money = 500;       CashContext context;       context = new CashContext(new CashNormal());       double normal = context.getResult(money);       System.out.println(\"正常收费：\" + normal);       context = new CashContext(new CashRebate(0.8));       double rebate = context.getResult(money);       System.out.println(\"八折收费：\" + rebate);       context = new CashContext(new CashReturn(200, 100));       double retur = context.getResult(money);       System.out.println(\"满200返100：\" + retur);    } } 总结 策略模式和简单工厂模式的区别 相同点 1、   都是用到了封装、继承、多态； 2、   都抽出一个接口或者抽象类，针对不同的情况，有不同的实现类。 不同点 1、   使用方式不同，工厂是静态的，策略的上下文是需要创建对象的； 2、   工厂产生的是对象，不同情况下产生不同的对象； 3、   策略产生的是策略，或者说是算法，不同情况下使用不同的算法。 结论 无论何种设计模式，都是基于面相对象的三大特性，即封装、继承、多态。","title":"策略模式"},{"content":"一、什么是解释器模式     Interpreter模式也叫解释器模式，是行为模式之一，它是一种特殊的设计模式，它建立一个解释器，对于特定的计算机程序设计语言，用来解释预先定义的文法。简单地说，Interpreter模式是一种简单的语法解释器构架。 二、解释器模式应用场景     当有一个语言需要解释执行,并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。     而当存在以下情况时该模式效果最好：     该文法简单对于复杂的文法,文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无需构建抽象语法树即可解释表达式,这样可以节省空间而且还可能节省时间。     效率不是一个关键问题，最高效的解释器通常不是通过直接解释语法分析树实现的,而是首先将它们转换成另一种形式。例如，正则表达式通常被转换成状态机。但即使在这种情况下,转换器仍可用解释器模式实现,该模式仍是有用的。 三、解释器模式的结构 四、解释器模式的角色和职责 Context     解释器上下文环境类。用来存储解释器的上下文环境，比如需要解释的文法等。 AbstractExpression     解释器抽象类。 ConcreteExpression     解释器具体实现类。  /*  * 上下文环境类，用来保存文法  */ public class Context {          private String input;     private int output;          public Context(String input) {         this.input = input;     }          public String getInput() {         return input;     }     public void setInput(String input) {         this.input = input;     }     public int getOutput() {         return output;     }     public void setOutput(int output) {         this.output = output;     } }/*  * 抽象解释器  */ public abstract class Expression {          public abstract void interpret(Context context);      }public class MinusExpression extends Expression {      public void interpret(Context context) {         System.out.println(\"自动递减\");         String input = context.getInput();         int inInput = Integer.parseInt(input); //      inInput--;         --inInput;         context.setInput(String.valueOf(inInput));         context.setOutput(inInput);     }  }public class PlusExpression extends Expression {      public void interpret(Context context) {         //提示信息         System.out.println(\"自动递增\");         //获得上下文环境         String input = context.getInput();         //进行类型转换         int intInput = Integer.parseInt(input);         //进行递增 //      intInput++;         ++intInput;         //对上下文环境重新进行赋值         context.setInput(String.valueOf(intInput));         context.setOutput(intInput);     }  }import java.util.ArrayList; import java.util.List;  /*  * client  */ public class MainClass {     public static void main(String[] args) {         String number = \"20\";         Context context = new Context(number);          //      Expression expression1 = new MinusExpression(); //      expression1.interpret(context); //      System.out.println(context.getOutput()); //       //      Expression expression2 = new PlusExpression(); //      expression2.interpret(context); //      System.out.println(context.getOutput()); //       //      Expression expression3 = new PlusExpression(); //      expression3.interpret(context); //      System.out.println(context.getOutput()); //       //      Expression expression4 = new PlusExpression(); //      expression4.interpret(context); //      System.out.println(context.getOutput());                  List<Expression> list = new ArrayList<Expression>();         list.add(new PlusExpression());         list.add(new PlusExpression());         list.add(new MinusExpression());         list.add(new MinusExpression());         list.add(new MinusExpression());         list.add(new MinusExpression());                  for(Expression ex : list) {             ex.interpret(context);             System.out.println(context.getOutput());         }     } } 转载自：http://www.java63.com/design_pattern/interpreter_pattern.html","title":"设计模式(11) ------------解释器模式"},{"content":"1.概述 在软件开发中也常常遇到类似的情况，实现某一个功能有多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能。如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…或者case等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。如果我们将这些策略包含在客户端，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。 例子1：一个菜单功能能够根据用户的“皮肤”首选项来决定是否采用水平的还是垂直的排列形式。同事可以灵活增加菜单那的显示样式。 例子2：出行旅游：我们可以有几个策略可以考虑：可以骑自行车，汽车，做火车，飞机。每个策略都可以得到相同的结果，但是它们使用了不同的资源。选择策略的依据是费用，时间，使用工具还有每种方式的方便程度 。 2.问题 如何让算法和对象分开来，使得算法可以独立于使用它的客户而变化？ 3.解决方案 策略模式：定义一系列的算法,把每一个算法封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。也称为政策模式(Policy)。（Definea family of algorithms,encapsulate each one, andmake them interchangeable. Strategy lets the algorithmvary independently from clients that use it. ） 策略模式把对象本身和运算规则区分开来，其功能非常强大，因为这个设计模式本身的核心思想就是面向对象编程的多形性的思想。 4.适用性 当存在以下情况时使用Strategy模式 1）• 许多相关的类仅仅是行为有异。 “策略”提供了一种用多个行为中的一个行为来配置一个类的方法。即一个系统需要动态地在几种算法中选择一种。 2）• 需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间 /时间权衡的算法。当这些变体实现为一个算法的类层次时 ,可以使用策略模式。 3）• 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。 4）• 一个类定义了多种行为 , 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。 5.结构 6.模式的组成 环境类(Context):用一个ConcreteStrategy对象来配置。维护一个对Strategy对象的引用。可定义一个接口来让Strategy访问它的数据。 抽象策略类(Strategy):定义所有支持的算法的公共接口。 Context使用这个接口来调用某ConcreteStrategy定义的算法。 具体策略类(ConcreteStrategy):以Strategy接口实现某具体算法。 7.效果 Strategy模式有下面的一些优点： 1) 相关算法系列 Strategy类层次为Context定义了一系列的可供重用的算法或行为。 继承有助于析取出这些算法中的公共功能。 2) 提供了可以替换继承关系的办法： 继承提供了另一种支持多种算法或行为的方法。你可以直接生成一个Context类的子类，从而给它以不同的行为。但这会将行为硬行编制到 Context中，而将算法的实现与Context的实现混合起来,从而使Context难以理解、难以维护和难以扩展，而且还不能动态地改变算法。最后你得到一堆相关的类 , 它们之间的唯一差别是它们所使用的算法或行为。 将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展。 3) 消除了一些if else条件语句 ：Strategy模式提供了用条件语句选择所需的行为以外的另一种选择。当不同的行为堆砌在一个类中时 ,很难避免使用条件语句来选择合适的行为。将行为封装在一个个独立的Strategy类中消除了这些条件语句。含有许多条件语句的代码通常意味着需要使用Strategy模式。 4) 实现的选择 Strategy模式可以提供相同行为的不同实现。客户可以根据不同时间 /空间权衡取舍要求从不同策略中进行选择。 Strategy模式缺点: 1)客户端必须知道所有的策略类，并自行决定使用哪一个策略类:  本模式有一个潜在的缺点，就是一个客户要选择一个合适的Strategy就必须知道这些Strategy到底有何不同。此时可能不得不向客户暴露具体的实现问题。因此仅当这些不同行为变体与客户相关的行为时 , 才需要使用Strategy模式。 2 ) Strategy和Context之间的通信开销 ：无论各个ConcreteStrategy实现的算法是简单还是复杂, 它们都共享Strategy定义的接口。因此很可能某些 ConcreteStrategy不会都用到所有通过这个接口传递给它们的信息；简单的 ConcreteStrategy可能不使用其中的任何信息！这就意味着有时Context会创建和初始化一些永远不会用到的参数。如果存在这样问题 , 那么将需要在Strategy和Context之间更进行紧密的耦合。 3 )策略模式将造成产生很多策略类：可以通过使用享元模式在一定程度上减少对象的数量。 增加了对象的数目 Strategy增加了一个应用中的对象的数目。有时你可以将 Strategy实现为可供各Context共享的无状态的对象来减少这一开销。任何其余的状态都由 Context维护。Context在每一次对Strategy对象的请求中都将这个状态传递过去。共享的 Strategy不应在各次调用之间维护状态。 8.实现 1)出行旅游： * 策略模式 * 定义一系列的算法,把每一个算法封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化 * */       /** * 出行旅游 * *  */  interface TravelStrategy{      public function travelAlgorithm();  }       /**  * 具体策略类(ConcreteStrategy)1：乘坐飞机  */  class AirPlanelStrategy implements TravelStrategy {      public function travelAlgorithm(){          echo \"travel by AirPlain\", \"<BR>\\r\\n\";       }  }       /**  * 具体策略类(ConcreteStrategy)2：乘坐火车  */  class TrainStrategy implements TravelStrategy {      public function travelAlgorithm(){          echo \"travel by Train\", \"<BR>\\r\\n\";       }  }     /**  * 具体策略类(ConcreteStrategy)3：骑自行车  */  class BicycleStrategy implements TravelStrategy {      public function travelAlgorithm(){          echo \"travel by Bicycle\", \"<BR>\\r\\n\";       }  }         /**  *   * 环境类(Context):用一个ConcreteStrategy对象来配置。维护一个对Strategy对象的引用。可定义一个接口来让Strategy访问它的数据。  * 算法解决类，以提供客户选择使用何种解决方案：  */  class PersonContext{      private $_strategy = null;        public function __construct(TravelStrategy $travel){          $this->_strategy = $travel;      }      /**     * 旅行     */      public function setTravelStrategy(TravelStrategy $travel){          $this->_strategy = $travel;      }      /**     * 旅行     */      public function travel(){          return $this->_strategy ->travelAlgorithm();      }  }     // 乘坐火车旅行  $person = new PersonContext(new TrainStrategy());  $person->travel();    // 改骑自行车  $person->setTravelStrategy(new BicycleStrategy());  $person->travel();     9.与其他相关模式 1）状态模式 策略模式和其它许多设计模式比较起来是非常类似的。策略模式和状态模式最大的区别就是策略模式只是的条件选择只执行一次，而状态模式是随着实例参数（对象实例的状态）的改变不停地更改执行模式。换句话说，策略模式只是在对象初始化的时候更改执行模式，而状态模式是根据对象实例的周期时间而动态地改变对象实例的执行模式。 •可以通过环境类状态的个数来决定是使用策略模式还是状态模式。 •策略模式的环境类自己选择一个具体策略类，具体策略类无须关心环境类；而状态模式的环境类由于外在因素需要放进一个具体状态中， 以便通过其方法实现状态的切换，因此环境类和状态类之间存在一种双向的关联关系。 •使用策略模式时，客户端需要知道所选的具体策略是哪一个，而使用状态模式时，客户端无须关心具体状态，环境类的状态会根据用户的操作自动转换。 •如果系统中某个类的对象存在多种状态，不同状态下行为有差异，而且这些状态之间可以发生转换时使用状态模式； 如果系统中某个类的某一行为存在多种实现方式，而且这些实现方式可以互换时使用策略模式。 2）简单工厂的区别： 工厂模式是创建型模式 ，它关注对象创建，提供创建对象的接口. 让对象的创建与具体的使用客户无关。 策略模式是对象行为型模式 ，它关注行为和算法的封装 。它定义一系列的算法,把每一个算法封装起来, 并且使它们可相互替换。使得算法可独立于使用它的客户而变化 用我们上面提到旅行的例子： 我们去旅行。策略模式的做法：有几种方案供你选择旅行，选择火车好呢还是骑自行车，完全有客户自行决定去构建旅行方案（比如你自己需要去买火车票，或者机票）。而工厂模式是你决定哪种旅行方案后，不用关注这旅行方案怎么给你创建，也就是说你告诉我方案的名称就可以了，然后由工厂代替你去构建具体方案（工厂代替你去买火车票）。 上面的例子里面client代码： $person = new PersonContext(new TrainStrategy()); $person->travel(); 我们看到客户需要自己去创建具体旅行（new TrainStrategy()）实例。传递的是具体实例。 而工厂模式你只要告诉哪种旅行就可以了，不是传递一个具体实例，而是一个标识（旅行方案标识）。 10.总结与分析 1）策略模式是一个比较容易理解和使用的设计模式，策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。 2）在策略模式中，应当由客户端自己决定在什么情况下使用什么具体策略角色。2） 3）策略模式仅仅封装算法，提供新算法插入到已有系统中，以及老算法从系统中“退休”的方便，策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定。这在一定程度上提高了系统的灵活性，但是客户端需要理解所有具体策略类之间的区别，以便选择合适的算法，这也是策略模式的缺点之一，在一定程度上增加了客户端的使用难度。 转载自：http://blog.csdn.net/hguisu/article/details/7558249","title":"设计模式(10) ------------策略模式"},{"content":"MEMENTO备忘录模式 1、 意图 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将对象恢复到原先保存的状态。 2、 适用性 在下面情况下可以使用MEMENTO模式 必须保存一个对象在某一时刻的（部分）状态，这样以后需要时它能恢复到先前的状态。  如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。 3、 结构 4、 参与者 Memento（备忘录） ——备忘录存储原发器对象的内部状态。原发器根据需要决定备忘录存储原发器的哪些内部状态。 ——防止原发器以外的其他对象访问备忘录。备忘录实际上有两个接口，管理者只能看到备忘录的窄接口——它只能将备忘录传递给其他对象。相反，原发器能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。理想的情况是只允许生成本备忘录的那个原发器访问本备忘录的内部状态。 Originator（原发器） ——原发器创建一个备忘录，用以记录当前时刻它的内部状态。 ——使用备忘录恢复内部状态。 Caretaker（负责人） ——负责保持好备忘录。 ——不能对备忘录的内容进行操作或检查。 5、 协作  管理器想原发器请求一个备忘录，保留一段时间后，将其送回给原发器。 备忘录是被动的。只有创建备忘录的原发器会对它的状态进行赋值和检索。 6、 效果 1）  保持封装边界。使用备忘录可以避免暴露一些只应由原发器管理却又必须存储在原发器之外的信息。 2）  它简化了原发器。在其他的保持封装性的设计中，Originator负责保持客户请求过的内部版本。这就把原有存储管理的重任交给了Originator。让客户管理它们请求的状态将会简化Originator，并且使得客户工作结束时无需通知原发器。 3）  使用备忘录可能代价很高。如果原发器在生成备忘录时必须拷贝并存储大量的信息，或者客户非常频繁地创建备忘录和恢复原发器状态，可能会导致非常大的开销。 4）  定义窄接口和宽接口。 5）  维护备忘录的潜在代价。管理器负责删除它所维护的备忘录。然而，管理器不知道备忘录中有多少个状态。因此当存储备忘录时，一个本来很小的管理器，可能会产生大量的存储开销。 7、 代码示例 1）  语言支持。备忘录有两个接口，一个为原发器准备的宽接口；一个为其他对象准备的窄接口。 2）  存储增量式改变。如果备忘录的创建及其返回（给它们的原发器）的顺序是可预测的，备忘录可以仅存储原发器内部状态的增量改变。 8、 代码示例 Memento package com.examples.pattern.memento;/** * 备忘录的窄接口，没有任何方法定义 */public interface Memento {}Originator package com.examples.pattern.memento;/** * 原发器对象 */public class Originator implements Memento {\t/**\t * 示意，原发器的状态\t */\tprivate String state = \"\";\tpublic Originator(String state) {\t\tthis.state = state;\t}\t/**\t * 创建保存原发器对象的状态的备忘录对象\t * \t * @return 创建好的备忘录对象\t */\tpublic Memento createMemento() {\t\treturn new MementoImpl(state);\t}\t/**\t * 重新设置原发器对象的状态，让其回到备忘录对象记录的状态\t * \t * @param memento\t *            记录有有原发器状态的备忘录对象\t */\tpublic void setMemento(Memento memento) {\t\tMementoImpl mementoImpl = (MementoImpl) memento;\t\tthis.state = mementoImpl.getState();\t}\tpublic void operate_1() {\t\tSystem.out.println(\"operate_1 :\" + this.state);\t}\tpublic void operate_2() {\t\tSystem.out.println(\"operate_2 :\" + this.state);\t}\tprivate static class MementoImpl implements Memento {\t\tprivate String state = \"\";\t\tpublic MementoImpl(String state) {\t\t\tthis.state = state;\t\t}\t\tpublic String getState() {\t\t\treturn state;\t\t}\t}}Caretaker package com.examples.pattern.memento;/** * 负责保存的备忘录对象 */public class Caretaker {\t/**\t * 记录被保存的备忘录对象\t */\tprivate Memento memento = null;\t/**\t * 保存备忘录对象\t * \t * @param memento\t *            被保存的备忘录对象\t */\tpublic void saveMemento(Memento memento) {\t\tthis.memento = memento;\t}\t/**\t * 获取被保存的备忘录对象\t * \t * @return 被保存的备忘录对象\t */\tpublic Memento retriveMemento() {\t\treturn this.memento;\t}}Client package com.examples.pattern.memento;public class Client {\t/**\t * @param args\t */\tpublic static void main(String[] args) {\t\tOriginator originator = new Originator(\"STATE\");\t\tCaretaker caretaker = new Caretaker();\t\tMemento memento = originator.createMemento();\t\tcaretaker.saveMemento(memento);\t\toriginator.operate_1();\t\toriginator.operate_2();\t}} 9、 相关模式 Command：命令可使用备忘录来为可撤销的操作维护状态。 Iterator：备忘录可用于迭代。","title":"设计模式——备忘录模式"},{"content":"作用：     提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。     UML结构图：     解析：     Iterator几乎是大部分人在初学C++的时候就无意之中接触到的第一种设计模式，因为在STL之中，所有的容器类都有与之相关的迭代器。以前初学STL的时候，时常在看到讲述迭代器作用的时候是这么说的：提供一种方式，使得算法和容器可以独立的变化，而且在访问容器对象的时候不必暴露容器的内部细节，具体是怎么做到这一点的呢？在STL的实现中，所有的迭代器（Iterator）都必须遵照一套规范，这套规范里面定义了几种类型的名称，比如对象的名称，指向对象的指针的名称，指向对象的引用的名称……等等，当新生成一个容器的时候与之对应的Iterator都要遵守这个规范里面所定义的名称，这样在外部看来虽然里面的实现细节不一样，但是作用（也就是对外的表象）都是一样的，通过某个名称可以得到容器包含的对象，通过某个名称可以得到容器包含的对象的指针等等的。而且，采用这个模式把访问容器的重任都交给了具体的iterator类中。于是，在使用Iterator来访问容器对象的算法不需要知道需要处理的是什么容器，只需要遵守事先约定好的Iterator的规范就可以了；而对于各个容器类而言，不管内部的事先如何，是树还是链表还是数组，只需要对外的接口也遵守Iterator的标准，这样算法（Iterator的使用者）和容器（IteIterator的提供者)就能很好的进行合作,而且不必关心对方是如何事先的,简而言之,Iterator就是算法和容器之间的一座桥梁. 在下面的实现中，抽象基类Iterator可以看做是前面提到的Iterator的规范，它提供了所有Iterator需要遵守的规范也就是对外的接口，而它的派生类ConcreateIterator则是ConcreateAggregate容器的迭代器，它遵照这个规范对容器进行迭代和访问操作。     实现：     1）Iterator.h     rator的提供者）就能很好的进行合作，而且不必关心对方是如何事先的，简而言之，Iterator就是算法和容器之间的一座桥梁 #ifndef ITERATOR_H #define ITERATOR_H typedef int DATA; class Iterater; // 容器的抽象基类 class Aggregate { public: 　　　 virtual ~Aggregate(){} 　　　 virtual Iterater* CreateIterater(Aggregate *pAggregate) = 0; 　　　 virtual int GetSize() = 0; 　　　 virtual DATA GetItem(int nIndex) = 0; }; // 迭代器的抽象基类 class Iterater { public: 　　　 virtual ~Iterater(){} 　　　 virtual void First()　　　　　　　 = 0; 　　　 virtual void Next()　　　　　　　　　　　 = 0; 　　　 virtual bool IsDone()　　　　　　　 = 0; 　　　 virtual DATA CurrentItem()　　　 = 0; private: }; // 一个具体的容器类,这里是用数组表示 class ConcreateAggregate 　　　 : public Aggregate { public: 　　　 ConcreateAggregate(int nSize); 　　　 virtual ~ConcreateAggregate(); 　　　 virtual Iterater* CreateIterater(Aggregate *pAggregate); 　　　 virtual int GetSize(); 　　　 virtual DATA GetItem(int nIndex); private: 　　　 int m_nSize; 　　　 DATA *m_pData; }; // 访问ConcreateAggregate容器类的迭代器类 class ConcreateIterater 　　　 : public Iterater { public: 　　　 ConcreateIterater(Aggregate* pAggregate); 　　　 virtual ~ConcreateIterater(){} 　　　 virtual void First(); 　　　 virtual void Next(); 　　　 virtual bool IsDone(); 　　　 virtual DATA CurrentItem(); private: 　　　 Aggregate　 *m_pConcreateAggregate; 　　　 int　　　　　　　　　　　 m_nIndex; }; #endif  2）Iterator.cpp #include <iostream> #include \"Iterator.h\" ConcreateAggregate::ConcreateAggregate(int nSize) 　　　 : m_nSize(nSize) 　　　 , m_pData(NULL) { 　　　 m_pData = new DATA[m_nSize]; 　　　 　　　 for (int i = 0; i < nSize; ++i) 　　　 { 　　　　　　　 m_pData[i] = i; 　　　 } } ConcreateAggregate::~ConcreateAggregate() { 　　　 delete [] m_pData; 　　　 m_pData = NULL; } Iterater* ConcreateAggregate::CreateIterater(Aggregate *pAggregate) { 　　　 return new ConcreateIterater(this); } int ConcreateAggregate::GetSize() { 　　　 return m_nSize; } DATA ConcreateAggregate::GetItem(int nIndex) { 　　　 if (nIndex < m_nSize) 　　　 { 　　　　　　　 return m_pData[nIndex]; 　　　 } 　　　 else 　　　 { 　　　　　　　 return -1; 　　　 } } ConcreateIterater::ConcreateIterater(Aggregate* pAggregate) 　　　 : m_pConcreateAggregate(pAggregate) 　　　 , m_nIndex(0) { } void ConcreateIterater::First() { 　　　 m_nIndex = 0; } void ConcreateIterater::Next() { 　　　 if (m_nIndex < m_pConcreateAggregate->GetSize()) 　　　 { 　　　　　　　 ++m_nIndex; 　　　 } } bool ConcreateIterater::IsDone() { 　　　 return m_nIndex == m_pConcreateAggregate->GetSize(); } DATA ConcreateIterater::CurrentItem() { 　　　 return m_pConcreateAggregate->GetItem(m_nIndex); }     3_Main.cpp #include \"Iterator.h\" #include <iostream> int main() { 　　　 Aggregate* pAggregate = new ConcreateAggregate(4); 　　　 Iterater*　 pIterater　 = new ConcreateIterater(pAggregate); 　　　 for (; false == pIterater->IsDone(); pIterater->Next()) 　　　 { 　　　　　　　 std::cout << pIterater->CurrentItem() << std::endl; 　　　 } 　　　 return 0; }","title":"设计模式的解析和实现(C++)之十八-Iterator模式"},{"content":"在阎宏博士的《JAVA与模式》一书中开头是这样描述观察者（Observer）模式的： 　　观察者模式是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。 　　观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 观察者模式的结构 　　一个软件系统里面包含了各种对象，就像一片欣欣向荣的森林充满了各种生物一样。在一片森林中，各种生物彼此依赖和约束，形成一个个生物链。一种生物的状态变化会造成其他一些生物的相应行动，每一个生物都处于别的生物的互动之中。 　　同样，一个软件系统常常要求在某一个对象的状态发生变化的时候，某些其他的对象做出相应的改变。做到这一点的设计方案有很多，但是为了使系统能够易于复用，应该选择低耦合度的设计方案。减少对象之间的耦合有利于系统的复用，但是同时设计师需要使这些低耦合度的对象之间能够维持行动的协调一致，保证高度的协作。观察者模式是满足这一要求的各种设计方案中最重要的一种。 　　下面以一个简单的示意性实现为例，讨论观察者模式的结构。 观察者模式所涉及的角色有： 　　●　　抽象主题(Subject)角色：抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。 　　●　　具体主题(ConcreteSubject)角色：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。 　　●　　抽象观察者(Observer)角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。 　　●　　具体观察者(ConcreteObserver)角色：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态 像协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。 　　源代码 　　　　抽象主题角色类 public abstract class Subject {    /**     * 用来保存注册的观察者对象     */    private    List<Observer> list = new ArrayList<Observer>();    /**     * 注册观察者对象     * @param observer    观察者对象     */    public void attach(Observer observer){                list.add(observer);        System.out.println(\"Attached an observer\");    }    /**     * 删除观察者对象     * @param observer    观察者对象     */    public void detach(Observer observer){                list.remove(observer);    }    /**     * 通知所有注册的观察者对象     */    public void nodifyObservers(String newState){                for(Observer observer : list){            observer.update(newState);        }    }} 具体主题角色类 public class ConcreteSubject extends Subject{        private String state;        public String getState() {        return state;    }    public void change(String newState){        state = newState;        System.out.println(\"主题状态为：\" + state);        //状态发生改变，通知各个观察者        this.nodifyObservers(state);    }} 抽象观察者角色类 public interface Observer {    /**     * 更新接口     * @param state    更新的状态     */    public void update(String state);} 具体观察者角色类 public class ConcreteObserver implements Observer {    //观察者的状态    private String observerState;        @Override    public void update(String state) {        /**         * 更新观察者的状态，使其与目标的状态保持一致         */        observerState = state;        System.out.println(\"状态为：\"+observerState);    }} 客户端类 public class Client {    public static void main(String[] args) {        //创建主题对象        ConcreteSubject subject = new ConcreteSubject();        //创建观察者对象        Observer observer = new ConcreteObserver();        //将观察者对象登记到主题对象上        subject.attach(observer);        //改变主题对象的状态        subject.change(\"new state\");    }} 运行结果如下 在运行时，这个客户端首先创建了具体主题类的实例，以及一个观察者对象。然后，它调用主题对象的attach()方法，将这个观察者对象向主题对象登记，也就是将它加入到主题对象的聚集中去。 　　这时，客户端调用主题的change()方法，改变了主题对象的内部状态。主题对象在状态发生变化时，调用超类的notifyObservers()方法，通知所有登记过的观察者对象。 推模型和拉模型 　　在观察者模式中，又分为推模型和拉模型两种方式。 　　●　　推模型 　　　　 主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。 　　●　　拉模型 　　　　 主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。 　　根据上面的描述，发现前面的例子就是典型的推模型，下面给出一个拉模型的实例。 　　拉模型的抽象观察者类 　　拉模型通常都是把主题对象当做参数传递。 public interface Observer {    /**     * 更新接口     * @param subject 传入主题对象，方面获取相应的主题对象的状态     */    public void update(Subject subject);} 拉模型的具体观察者类 public class ConcreteObserver implements Observer {    //观察者的状态    private String observerState;        @Override    public void update(Subject subject) {        /**         * 更新观察者的状态，使其与目标的状态保持一致         */        observerState = ((ConcreteSubject)subject).getState();        System.out.println(\"观察者状态为：\"+observerState);    }} 拉模型的抽象主题类 　　拉模型的抽象主题类主要的改变是nodifyObservers()方法。在循环通知观察者的时候，也就是循环调用观察者的update()方法的时候，传入的参数不同了。 public abstract class Subject {    /**     * 用来保存注册的观察者对象     */    private    List<Observer> list = new ArrayList<Observer>();    /**     * 注册观察者对象     * @param observer    观察者对象     */    public void attach(Observer observer){                list.add(observer);        System.out.println(\"Attached an observer\");    }    /**     * 删除观察者对象     * @param observer    观察者对象     */    public void detach(Observer observer){                list.remove(observer);    }    /**     * 通知所有注册的观察者对象     */    public void nodifyObservers(){                for(Observer observer : list){            observer.update(this);        }    }} 　拉模型的具体主题类 　　跟推模型相比，有一点变化，就是调用通知观察者的方法的时候，不需要传入参数了。 public class ConcreteSubject extends Subject{        private String state;        public String getState() {        return state;    }    public void change(String newState){        state = newState;        System.out.println(\"主题状态为：\" + state);        //状态发生改变，通知各个观察者        this.nodifyObservers();    }} 两种模式的比较 　　■　　推模型是假定主题对象知道观察者需要的数据；而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。 　　■　　推模型可能会使得观察者对象难以复用，因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者；而拉模型就不会造成这样的情况，因为拉模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。 JAVA提供的对观察者模式的支持 　　在JAVA语言的java.util库里面，提供了一个Observable类以及一个Observer接口，构成JAVA语言对观察者模式的支持。 　　Observer接口 　　这个接口只定义了一个方法，即update()方法，当被观察者对象的状态发生变化时，被观察者对象的notifyObservers()方法就会调用这一方法。 public interface Observer {    void update(Observable o, Object arg);} Observable类 　　被观察者类都是java.util.Observable类的子类。java.util.Observable提供公开的方法支持观察者对象，这些方法中有两个对Observable的子类非常重要：一个是setChanged()，另一个是notifyObservers()。第一方法setChanged()被调用之后会设置一个内部标记变量，代表被观察者对象的状态发生了变化。第二个是notifyObservers()，这个方法被调用时，会调用所有登记过的观察者对象的update()方法，使这些观察者对象可以更新自己。 public class Observable {    private boolean changed = false;    private Vector obs;       /** Construct an Observable with zero Observers. */    public Observable() {    obs = new Vector();    }    /**     * 将一个观察者添加到观察者聚集上面     */    public synchronized void addObserver(Observer o) {        if (o == null)            throw new NullPointerException();    if (!obs.contains(o)) {        obs.addElement(o);    }    }    /**     * 将一个观察者从观察者聚集上删除     */    public synchronized void deleteObserver(Observer o) {        obs.removeElement(o);    }    public void notifyObservers() {    notifyObservers(null);    }    /**     * 如果本对象有变化（那时hasChanged 方法会返回true）     * 调用本方法通知所有登记的观察者，即调用它们的update()方法     * 传入this和arg作为参数     */    public void notifyObservers(Object arg) {        Object[] arrLocal;    synchronized (this) {        if (!changed)                return;            arrLocal = obs.toArray();            clearChanged();        }        for (int i = arrLocal.length-1; i>=0; i--)            ((Observer)arrLocal[i]).update(this, arg);    }    /**     * 将观察者聚集清空     */    public synchronized void deleteObservers() {    obs.removeAllElements();    }    /**     * 将“已变化”设置为true     */    protected synchronized void setChanged() {    changed = true;    }    /**     * 将“已变化”重置为false     */    protected synchronized void clearChanged() {    changed = false;    }    /**     * 检测本对象是否已变化     */    public synchronized boolean hasChanged() {    return changed;    }    /**     * Returns the number of observers of this <tt>Observable<\/tt> object.     *     * @return  the number of observers of this object.     */    public synchronized int countObservers() {    return obs.size();    }} 这个类代表一个被观察者对象，有时称之为主题对象。一个被观察者对象可以有数个观察者对象，每个观察者对象都是实现Observer接口的对象。在被观察者发生变化时，会调用Observable的notifyObservers()方法，此方法调用所有的具体观察者的update()方法，从而使所有的观察者都被通知更新自己。 怎样使用JAVA对观察者模式的支持 　　这里给出一个非常简单的例子，说明怎样使用JAVA所提供的对观察者模式的支持。在这个例子中，被观察对象叫做Watched；而观察者对象叫做Watcher。Watched对象继承自java.util.Observable类；而Watcher对象实现了java.util.Observer接口。另外有一个Test类扮演客户端角色。 　　源代码 　　被观察者Watched类源代码 public class Watched extends Observable{        private String data = \"\";        public String getData() {        return data;    }    public void setData(String data) {                if(!this.data.equals(data)){            this.data = data;            setChanged();        }        notifyObservers();    }        } 观察者类源代码 public class Watcher implements Observer{        public Watcher(Observable o){        o.addObserver(this);    }        @Override    public void update(Observable o, Object arg) {                System.out.println(\"状态发生改变：\" + ((Watched)o).getData());    }} 测试类源代码 public class Test {    public static void main(String[] args) {                //创建被观察者对象        Watched watched = new Watched();        //创建观察者对象，并将被观察者对象登记        Observer watcher = new Watcher(watched);        //给被观察者状态赋值        watched.setData(\"start\");        watched.setData(\"run\");        watched.setData(\"stop\");    }} Test对象首先创建了Watched和Watcher对象。在创建Watcher对象时，将Watched对象作为参数传入；然后Test对象调用Watched对象的setData()方法，触发Watched对象的内部状态变化；Watched对象进而通知实现登记过的Watcher对象，也就是调用它的update()方法。 转载自：http://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html","title":"设计模式(12) ------------观察者模式"},{"content":"在阎宏博士的《JAVA与模式》一书中开头是这样描述调停者（Mediator）模式的： 　　调停者模式是对象的行为模式。调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显引用。从而使它们可以较松散地耦合。当这些对象中的某些对象之间的相互作用发生改变时，不会立即影响到其他的一些对象之间的相互作用。从而保证这些相互作用可以彼此独立地变化。 为什么需要调停者 　　如下图所示，这个示意图中有大量的对象，这些对象既会影响别的对象，又会被别的对象所影响，因此常常叫做同事(Colleague)对象。这些同事对象通过彼此的相互作用形成系统的行为。从图中可以看出，几乎每一个对象都需要与其他的对象发生相互作用，而这种相互作用表现为一个对象与另一个对象的直接耦合。这就是过度耦合的系统。 通过引入调停者对象(Mediator)，可以将系统的网状结构变成以中介者为中心的星形结构，如下图所示。在这个星形结构中，同事对象不再通过直接的联系与另一个对象发生相互作用；相反的，它通过调停者对象与另一个对象发生相互作用。调停者对象的存在保证了对象结构上的稳定，也就是说，系统的结构不会因为新对象的引入造成大量的修改工作。 一个好的面向对象的设计可以使对象之间增加协作性(Collaboration)，减少耦合度(Couping)。一个深思熟虑的设计会把一个系统分解为一群相互协作的同事对象，然后给每一个同事对象以独特的责任，恰当的配置它们之间的协作关系，使它们可以在一起工作。 如果没有主板 　　大家都知道，电脑里面各个配件之间的交互，主要是通过主板来完成的。如果电脑里面没有了主板，那么各个配件之间就必须自行相互交互，以互相传送数据。而且由于各个配件的接口不同，相互之间交互时，还必须把数据接口进行转换才能匹配上。 所幸是有了主板，各个配件的交互完全通过主板来完成，每个配件都只需要和主板交互，而主板知道如何跟所有的配件打交道，这样就简单多了。 调停者模式的结构 　　调停者模式的示意性类图如下所示： 调停者模式包括以下角色： 　　●　　抽象调停者(Mediator)角色：定义出同事对象到调停者对象的接口，其中主要方法是一个（或多个）事件方法。 　　●　　具体调停者(ConcreteMediator)角色：实现了抽象调停者所声明的事件方法。具体调停者知晓所有的具体同事类，并负责具体的协调各同事对象的交互关系。 　　●　　抽象同事类(Colleague)角色：定义出调停者到同事对象的接口。同事对象只知道调停者而不知道其余的同事对象。 　　●　　具体同事类(ConcreteColleague)角色：所有的具体同事类均从抽象同事类继承而来。实现自己的业务，在需要与其他同事通信的时候，就与持有的调停者通信，调停者会负责与其他的同事交互。 　　源代码 　　抽象调停者类 public interface Mediator {    /**     * 同事对象在自身改变的时候来通知调停者方法     * 让调停者去负责相应的与其他同事对象的交互     */    public void changed(Colleague c);} 具体调停者类 public class ConcreteMediator implements Mediator {    //持有并维护同事A    private ConcreteColleagueA colleagueA;    //持有并维护同事B    private ConcreteColleagueB colleagueB;            public void setColleagueA(ConcreteColleagueA colleagueA) {        this.colleagueA = colleagueA;    }    public void setColleagueB(ConcreteColleagueB colleagueB) {        this.colleagueB = colleagueB;    }    @Override    public void changed(Colleague c) {        /**         * 某一个同事类发生了变化，通常需要与其他同事交互         * 具体协调相应的同事对象来实现协作行为         */    }} 抽象同事类 public abstract class Colleague {    //持有一个调停者对象    private Mediator mediator;    /**     * 构造函数     */    public Colleague(Mediator mediator){        this.mediator = mediator;    }    /**     * 获取当前同事类对应的调停者对象     */    public Mediator getMediator() {        return mediator;    }    } 具体同事类 public class ConcreteColleagueA extends Colleague {    public ConcreteColleagueA(Mediator mediator) {        super(mediator);    }    /**     * 示意方法，执行某些操作     */    public void operation(){        //在需要跟其他同事通信的时候，通知调停者对象        getMediator().changed(this);    }} 使用电脑来看电影 　　在日常生活中，我们经常使用电脑来看电影，把这个过程描述出来，简化后假定会有如下的交互过程： 　　（1）首先是光驱要读取光盘上的数据，然后告诉主板，它的状态改变了。 　　（2）主板去得到光驱的数据，把这些数据交给CPU进行分析处理。 　　（3）CPU处理完后，把数据分成了视频数据和音频数据，通知主板，它处理完了。 　　（4）主板去得到CPU处理过后的数据，分别把数据交给显卡和声卡，去显示出视频和发出声音。 　　要使用调停者模式来实现示例，那就要区分出同事对象和调停者对象。很明显，主板是调停者，而光驱、声卡、CPU、显卡等配件，都是作为同事对象。 　抽象同事类 public abstract class Colleague {    //持有一个调停者对象    private Mediator mediator;    /**     * 构造函数     */    public Colleague(Mediator mediator){        this.mediator = mediator;    }    /**     * 获取当前同事类对应的调停者对象     */    public Mediator getMediator() {        return mediator;    }} 　同事类——光驱 public class CDDriver extends Colleague{    //光驱读取出来的数据    private String data = \"\";    /**     * 构造函数     */    public CDDriver(Mediator mediator) {        super(mediator);    }    /**     * 获取光盘读取出来的数据     */    public String getData() {        return data;    }    /**     * 读取光盘     */    public void readCD(){        //逗号前是视频显示的数据，逗号后是声音        this.data = \"One Piece,海贼王我当定了\";        //通知主板，自己的状态发生了改变        getMediator().changed(this);    }}　　同事类——CPU public class CPU extends Colleague {    //分解出来的视频数据    private String videoData = \"\";    //分解出来的声音数据    private String soundData = \"\";    /**     * 构造函数     */    public CPU(Mediator mediator) {        super(mediator);    }    /**     * 获取分解出来的视频数据     */    public String getVideoData() {        return videoData;    }    /**     * 获取分解出来的声音数据     */    public String getSoundData() {        return soundData;    }    /**     * 处理数据，把数据分成音频和视频的数据     */    public void executeData(String data){        //把数据分解开，前面是视频数据，后面是音频数据        String[] array = data.split(\",\");        this.videoData = array[0];        this.soundData = array[1];        //通知主板，CPU完成工作        getMediator().changed(this);    }    } 　同事类——显卡 public class VideoCard extends Colleague {    /**     * 构造函数     */    public VideoCard(Mediator mediator) {        super(mediator);    }    /**     * 显示视频数据     */    public void showData(String data){        System.out.println(\"您正在观看的是：\" + data);    }} 同事类——声卡 public class SoundCard extends Colleague {    /**     * 构造函数     */    public SoundCard(Mediator mediator) {        super(mediator);    }    /**     * 按照声频数据发出声音     */    public void soundData(String data){        System.out.println(\"画外音：\" + data);    }} 抽象调停者类 public interface Mediator {    /**     * 同事对象在自身改变的时候来通知调停者方法     * 让调停者去负责相应的与其他同事对象的交互     */    public void changed(Colleague c);} 具体调停者类 public class MainBoard implements Mediator {    //需要知道要交互的同事类——光驱类    private CDDriver cdDriver = null;    //需要知道要交互的同事类——CPU类    private CPU cpu = null;    //需要知道要交互的同事类——显卡类    private VideoCard videoCard = null;    //需要知道要交互的同事类——声卡类    private SoundCard soundCard = null;        public void setCdDriver(CDDriver cdDriver) {        this.cdDriver = cdDriver;    }    public void setCpu(CPU cpu) {        this.cpu = cpu;    }    public void setVideoCard(VideoCard videoCard) {        this.videoCard = videoCard;    }    public void setSoundCard(SoundCard soundCard) {        this.soundCard = soundCard;    }    @Override    public void changed(Colleague c) {        if(c instanceof CDDriver){            //表示光驱读取数据了            this.opeCDDriverReadData((CDDriver)c);        }else if(c instanceof CPU){            this.opeCPU((CPU)c);        }    }    /**     * 处理光驱读取数据以后与其他对象的交互     */    private void opeCDDriverReadData(CDDriver cd){        //先获取光驱读取的数据        String data = cd.getData();        //把这些数据传递给CPU进行处理        cpu.executeData(data);    }    /**     * 处理CPU处理完数据后与其他对象的交互     */    private void opeCPU(CPU cpu){        //先获取CPU处理后的数据        String videoData = cpu.getVideoData();        String soundData = cpu.getSoundData();        //把这些数据传递给显卡和声卡展示出来        videoCard.showData(videoData);        soundCard.soundData(soundData);    }} 客户端类 public class Client {    public static void main(String[] args) {        //创建调停者——主板        MainBoard mediator = new MainBoard();        //创建同事类        CDDriver cd = new CDDriver(mediator);        CPU cpu = new CPU(mediator);        VideoCard vc = new VideoCard(mediator);        SoundCard sc = new SoundCard(mediator);        //让调停者知道所有同事        mediator.setCdDriver(cd);        mediator.setCpu(cpu);        mediator.setVideoCard(vc);        mediator.setSoundCard(sc);        //开始看电影，把光盘放入光驱，光驱开始读盘        cd.readCD();            }} 运行结果如下： 调停者模式的优点 　　●　　松散耦合 　　调停者模式通过把多个同事对象之间的交互封装到调停者对象里面，从而使得同事对象之间松散耦合，基本上可以做到互补依赖。这样一来，同事对象就可以独立地变化和复用，而不再像以前那样“牵一处而动全身”了。 　　●　　集中控制交互 　　多个同事对象的交互，被封装在调停者对象里面集中管理，使得这些交互行为发生变化的时候，只需要修改调停者对象就可以了，当然如果是已经做好的系统，那么就扩展调停者对象，而各个同事类不需要做修改。 　　●　　多对多变成一对多 　　没有使用调停者模式的时候，同事对象之间的关系通常是多对多的，引入调停者对象以后，调停者对象和同事对象的关系通常变成双向的一对多，这会让对象的关系更容易理解和实现。 调停者模式的缺点 　　调停者模式的一个潜在缺点是，过度集中化。如果同事对象的交互非常多，而且比较复杂，当这些复杂性全部集中到调停者的时候，会导致调停者对象变得十分复杂，而且难于管理和维护。 转载自：http://www.cnblogs.com/java-my-life/archive/2012/06/20/2554024.html","title":"设计模式(13) ------------终结者模式"},{"content":"1.常用的面向对象设计模式有4种： Factory模式、Singleton模式、Facade模式和MVC架构模式。 SUN公司推出JSP技术后，同时也推荐了两种web应用程序的开发模式，一种是JSP+JavaBean模式，一种是Servlet+JSP+JavaBean(MVC)模式。 JSP设计模式包括两个： （1）Model1，JSP+JavaBean设计模式 （2）Model2，MVC设计模式 模式一JSP+JavaBean模式: 在这种模式中，JSP页面独自响应请求并将处理结果返回客户，所有的数据库操作通过JavaBean来实现。大量地使用这种模式，常会导致在JSP页面中嵌入大量的Java代码，当需要处理的商业逻辑非常复杂时，这种情况就会变得很糟糕。大量的Java代码使得JSP页面变得非常臃肿。前端的页面设计人员稍有不慎，就有可能破坏关系到商业逻辑的代码。这种情况在大型项目中经常出现，造成了代码开发和维护的困难，同时会导致项目管理的困难。因此这种模式只适用于中小规模的项目。JSP+JavaBean模式适合开发业务逻辑不太复杂的web应用程序，这种模式下，JavaBean用于封装业务数据，JSP即负责处理用户请求，又显示数据。 模式二  MVC模式 : “MVC”模式即是：“Model-View-Controller”模式。在这种模式中，通过JSP技术来表现页面，通过Servlet技术来完成大量的事务处理工作，实现用户的商业逻辑。在这种模式中，Servlet用来处理请求的事务，充当了控制器（Controller即“C”）的角色，Servlet负责响应客户对业务逻辑的请求并根据用户的请求行为，决定将哪个JSP页面发送给客户。JSP页面处于表现层，也就是视图（View即“V”）的角色。JavaBean则负责数据的处理，也就是模型（Model即“M”）的角色. Servlet+JSP+JavaBean(MVC)模式适合开发复杂的web应用，在这种模式下，servlet负责处理用户请求，jsp负责数据显示，javabean负责封装数据。 Servlet+JSP、JavaBean模式程序各个模块之间层次清晰，web开发推荐采用此种模式。 2.  MVC架构 Model-View-Controller架构模式是80年代中期在Smalltalk-80 GUI（一种经典的面向对象程序设计语言）实验室发明的。根据MVC模式，一个软件应该将商务逻辑（Model）和显示(View)分开。分开有许多好处，最主要的有两个方面： 1)、同一的商务逻辑层（Model）可能会对应多个显示层（View），如果商务逻辑层和显示层放在一起的话，再添加一个显示层的时候就会极大的增加组件的复杂性。一个商务逻辑对着两个显示层的例子是：银行的帐户的商务逻辑层对应ATM和Internet两个显示层。 2)、通常情况下，每次修改显示层的时候一般并不需要修改商务逻辑层。 基于Bean的MVC模型 ： Bean可以利用JavaBean实现，也可以利用EJB(企业级的javaBean，这里不多做介绍，关注以后会介绍)来实现，分别构成的系统是： n     JavaBean（M）+JSP（V）+Servlet n     EJB（M）+JSP（V）+Servlet（C）实现。 基于Struts的MVC模型 ： Struts是Apache组织的一个项目，像其他的Apache组织的项目一样，它也是开放源码项目。Struts是一个比较好的MVC框架提供了对开发MVC系统的底层支持，它采用的主要技术是Servlet，JSP和custom tag library。这里主要是想说Struts框架是基于MVC设计模式开发的。 Struts 是一组相互协作的类、Servlet 和 JSP 标记，它们组成一个可重用的MVC设计。这个定义表示Struts是一个框架，而不是一个库，但Struts也包含了丰富的标记库和独立于该框架工作的实用程序类。Struts的基本结构如图所示。","title":"心得9--jsp设计模版"},{"content":"面向对象设计模式 面向对象软件开发领域中，设计模式包括一些规则来完成一定任务。设计模式针对一些特定的问题，提出一种解决方案。 常用的面向对象设计模式有4种： Factory模式 Singleton模式 Facade模式 MVC架构模式。 JSP设计模式 SUN公司推出JSP技术后，同时也推荐了两种web应用程序的开发模式，一种是JSP+JavaBean模式，一种是Servlet+JSP+JavaBean模式。 JSP设计模式包括两个： Model1，JSP+JavaBean设计模式 在这种模式中，JSP页面独自响应请求并将处理结果返回客户，所有的数据库操作通过JavaBean来实现。 大量地使用这种模式，常会导致在JSP页面中嵌入大量的Java代码，当需要处理的商业逻辑非常复杂时，这种情况就会变得很糟糕。大量的Java代码使得JSP页面变得非常臃肿。前端的页面设计人员稍有不慎，就有可能破坏关系到商业逻辑的代码。 这种情况在大型项目中经常出现，造成了代码开发和维护的困难，同时会导致项目管理的困难。因此这种模式只适用于中小规模的项目 JSP+JavaBean模式适合开发业务逻辑不太复杂的web应用程序，这种模式下，JavaBean用于封装业务数据，JSP即负责处理用户请求，又显示数据。 Model2，MVC设计模式 “MVC”模式即是：“Model-View-Controller”模式。在这种模式中，通过JSP技术来表现页面，通过Servlet技术来完成大量的事务处理工作，实现用户的商业逻辑。 在这种模式中 M：JavaBean则负责数据的处理，也就是模型（Model即“M”）的角色 V：JSP页面处于表现层，也就是视图（View即“V”）的角色。 C：Servlet用来处理请求的事务，充当了控制器（Controller即“C”）的角色，Servlet负责响应客户对业务逻辑的请求并根据用户的请求行为，决定将哪个JSP页面发送给客户。 Servlet+JSP+JavaBean(MVC)模式适合开发复杂的web应用，在这种模式下，servlet负责处理用户请求，jsp负责数据显示，javabean负责封装数据。 Servlet+JSP、JavaBean模式程序各个模块之间层次清晰，web开发推荐采用此种模式。 MVC设计模式 MVC架构 Model-View-Controller架构模式是80年代中期在Smalltalk-80 GUI（一种经典的面向对象程序设计语言）实验室发明的。 根据MVC模式，一个软件应该将商务逻辑（Model）和显示(View)分开。分开有许多好处，最主要的有两个方面： 同一的商务逻辑层（Model）可能会对应多个显示层（View），如果商务逻辑层和显示层放在一起的话，再添加一个显示层的时候就会极大的增加组件的复杂性。一个商务逻辑对着两个显示层的例子是：银行的帐户的商务逻辑层对应ATM和Internet两个显示层。 通常情况下，每次修改显示层的时候一般并不需要修改商务逻辑层。 MVC三层关系 MVC实现模型 基于Bean的MVC模型。 Bean可以利用JavaBean实现，也可以利用EJB来实现，分别构成的系统是： JavaBean（M）+JSP（V）+Servlet EJB（M）+JSP（V）+Servlet（C）实现。 基于Stucts的MVC模型。 Struts是Apache组织的一个项目，像其他的Apache组织的项目一样，它也是开放源码项目。 Struts是一个比较好的MVC框架提供了对开发MVC系统的底层支持，它采用的主要技术是Servlet，JSP和custom tag library。 Struts 是一组相互协作的类、Servlet 和 JSP 标记，它们组成一个可重用的MVC设计。这个定义表示Struts是一个框架，而不是一个库，但Struts也包含了丰富的标记库和独立于该框架工作的实用程序类。Struts的基本结构如图所示。                   三层架构思想 web层负责与用户打交道业务处理层（服务层 service）数据访问层（dao） 用包来组织程序 com.hbsi.domain com.hbsi.dao com.hbsi.dao.impl com.hbsi.service com.hbsi.service.impl com.hbsi.web.controller com.hbsi.web.filter com.hbsi.web.listener com.hbsi.util junit.test jsp放到WEB-INF建一个文件夹  ","title":"【MVC设计模式】赵雅智_JavaWeb技术之--面向对象设计模式"},{"content":"简介 在游戏开发过程中，我们避免不了创建各种各样的人物职业，及怪物。试想一下，我有几十个大分类，复杂的层次结构，那么这个创建过程怎么维护。 不错，我们可以使用工厂模式进行创建过程，大大简化了维护方面的困难。 实现 开发游戏过程中一般都会有各种职业         Warrior 战士         Master 法师         Priest 牧师         Robber 盗贼         .... 我们可以使用简单工厂模式解决此类问题。简单工厂模式，在一定程度上支持了开闭原则，当增加一种职业的时候符合开闭原则         如下： 然而，如果是各种职业分了种族，试想一下，种族几个大分类，职业几个小分类等等，复杂的层次结构，那么这个工厂模式怎么维护。         于是我们用到了抽象工厂模式 如下： 抽象工厂模式与工厂方法模式的区别         抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。         在抽象工厂模式中，有一个产品族的概念：所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。 开发过程中，同样也会碰到各种怪物，并且各种不同的怪物又分等级（简单，一般，困难，或其它归类供玩家选择适合自己的娱乐） 同样，如果保证创建过程中不出错，不能在简单模式下创建困难的怪物，也不能在困难的模式下创建简单的物怪。 这样的话，游戏就完了。 这里同样我们也可以使用抽象工厂模式 整个工厂模式图 总结： 抽象工厂模式的优点         抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。所谓的产品族，一般或多或少的都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理。   抽象工厂模式的缺点        产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。   适用情况        当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。 运行结果： ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 以后的笔记潇汀会尽量详细讲解一些相关知识的，希望大家继续关注我的博客。 本节笔记到这里就结束了。 潇汀一有时间就会把自己的学习心得，觉得比较好的知识点写出来和大家一起分享。 游戏开发的路很长很长，非常希望能和大家一起交流，共同学习，共同进步。 如果文章中有什么疏漏的地方，也请大家指正。也希望大家可以多留言来和我探讨编程相关的问题。 最后，谢谢你们一直的支持~~~ 代码及下载地址 http://download.csdn.net/download/xiaoting451292510/4766488 -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- GAME_FACTORY_MonsterAbstractFactory.h /**   @file     GAME_FACTORY_MonsterAbstractFactory.h    @brief     the abstract factory of Monster, use to create Monster (different level)   @author   arvin   @version 1.0   2012/11/12  */ #ifndef CXX_GAME_FACTORY_MONSTERABSTRACTFACTORY_H #define CXX_GAME_FACTORY_MONSTERABSTRACTFACTORY_H class Monster; class MonsterAbstractFactory { /************************************************************************/ /*                               function                               */ public: /** * Destruction * * @param VOID * @return  */ virtual ~MonsterAbstractFactory(); /** * Create Monster * * @param VOID * @return Monster* * @use to create Monster (different level) */ virtual Monster* CreateMonsterA() = 0; /** * Create Monster * * @param VOID * @return Monster* * @use to create Monster (different level) */ virtual Monster* CreateMonsterB() = 0; /** * Create Monster * * @param VOID * @return Monster* * @use to create Monster (different level) */ virtual Monster* CreateMonsterC() = 0; protected: /** * Construction * * @param VOID * @return  */ MonsterAbstractFactory(); private: /************************************************************************/ /************************************************************************/ /*                               member                                 */ public: protected: private: /************************************************************************/ }; #endif /* >>CXX_GAME_FACTORY_MONSTERABSTRACTFACTORY_H<< */ /* EOF */ GAME_FACTORY_MonsterFactoryLevel1.h /**   @file     GAME_FACTORY_MonsterFactoryLevel1.h   @brief     the level 1 factory of Monster, use to create Monster (level 1)   @author   arvin   @version 1.0   2012/11/12  */ #ifndef CXX_GAME_FACTORY_MONSTERFACTORYLEVEL1_H #define CXX_GAME_FACTORY_MONSTERFACTORYLEVEL1_H #ifndef CXX_GAME_FACTORY_MONSTERABSTRACTFACTORY_H #include \"GAME_FACTORY_MonsterAbstractFactory.h\" #endif class MonsterFactoryLevel1 : public MonsterAbstractFactory { /************************************************************************/ /*                               function                               */ public: /** * Destruction * * @param VOID * @return  */ virtual ~MonsterFactoryLevel1(); /** * Instance * * @param VOID * @return MonsterFactoryLevel1* * @note singleton */ static MonsterFactoryLevel1* Instance(); /** * Destroy * * @param VOID * @return VOID * @note singleton */ static VOID Destroy(); /** * Create Monster * * @param VOID * @return Monster* * @use to create Monster (level 1) */ virtual Monster* CreateMonsterA(); /** * Create Monster * * @param VOID * @return Monster* * @use to create Monster (level 1) */ virtual Monster* CreateMonsterB(); /** * Create Monster * * @param VOID * @return Monster* * @use to create Monster (level 1) */ virtual Monster* CreateMonsterC(); protected: /** * Construction * * @param VOID * @return  */ MonsterFactoryLevel1(); private: /************************************************************************/ /************************************************************************/ /*                               member                                 */ public: protected: private: static MonsterFactoryLevel1* m_pInstance; /************************************************************************/ }; #endif /* >>CXX_GAME_FACTORY_MONSTERFACTORYLEVEL1_H<< */ /* EOF */ GAME_FACTORY_MonsterFactoryLevel2.h /**   @file     GAME_FACTORY_MonsterFactoryLevel1.h   @brief     the level 1 factory of Monster, use to create Monster (level 1)   @author   arvin   @version 1.0   2012/11/12  */ #ifndef CXX_GAME_FACTORY_MONSTERFACTORYLEVEL1_H #define CXX_GAME_FACTORY_MONSTERFACTORYLEVEL1_H #ifndef CXX_GAME_FACTORY_MONSTERABSTRACTFACTORY_H #include \"GAME_FACTORY_MonsterAbstractFactory.h\" #endif class MonsterFactoryLevel1 : public MonsterAbstractFactory { /************************************************************************/ /*                               function                               */ public: /** * Destruction * * @param VOID * @return  */ virtual ~MonsterFactoryLevel1(); /** * Instance * * @param VOID * @return MonsterFactoryLevel1* * @note singleton */ static MonsterFactoryLevel1* Instance(); /** * Destroy * * @param VOID * @return VOID * @note singleton */ static VOID Destroy(); /** * Create Monster * * @param VOID * @return Monster* * @use to create Monster (level 1) */ virtual Monster* CreateMonsterA(); /** * Create Monster * * @param VOID * @return Monster* * @use to create Monster (level 1) */ virtual Monster* CreateMonsterB(); /** * Create Monster * * @param VOID * @return Monster* * @use to create Monster (level 1) */ virtual Monster* CreateMonsterC(); protected: /** * Construction * * @param VOID * @return  */ MonsterFactoryLevel1(); private: /************************************************************************/ /************************************************************************/ /*                               member                                 */ public: protected: private: static MonsterFactoryLevel1* m_pInstance; /************************************************************************/ }; #endif /* >>CXX_GAME_FACTORY_MONSTERFACTORYLEVEL1_H<< */ /* EOF */ GAME_FACTORY_MonsterFactoryLevel3.h /**   @file     GAME_FACTORY_MonsterFactoryLevel3.h   @brief     the level 3 factory of Monster, use to create Monster (level 3)   @author   arvin   @version 1.0   2012/11/12  */ #ifndef CXX_GAME_FACTORY_MONSTERFACTORYLEVEL3_H #define CXX_GAME_FACTORY_MONSTERFACTORYLEVEL3_H #ifndef CXX_GAME_FACTORY_MONSTERABSTRACTFACTORY_H #include \"GAME_FACTORY_MonsterAbstractFactory.h\" #endif class MonsterFactoryLevel3 : public MonsterAbstractFactory { /************************************************************************/ /*                               function                               */ public: /** * Destruction * * @param VOID * @return  */ virtual ~MonsterFactoryLevel3(); /** * Instance * * @param VOID * @return MonsterFactoryLevel3* * @note singleton */ static MonsterFactoryLevel3* Instance(); /** * Destroy * * @param VOID * @return VOID * @note singleton */ static VOID Destroy(); /** * Create Monster * * @param VOID * @return Monster* * @use to create Monster (level 3) */ virtual Monster* CreateMonsterA(); /** * Create Monster * * @param VOID * @return Monster* * @use to create Monster (level 3) */ virtual Monster* CreateMonsterB(); /** * Create Monster * * @param VOID * @return Monster* * @use to create Monster (level 3) */ virtual Monster* CreateMonsterC(); protected: /** * Construction * * @param VOID * @return  */ MonsterFactoryLevel3(); private: /************************************************************************/ /************************************************************************/ /*                               member                                 */ public: protected: private: static MonsterFactoryLevel3* m_pInstance; /************************************************************************/ }; #endif /* >>CXX_GAME_FACTORY_MONSTERFACTORYLEVEL3_H<< */ /* EOF */ GAME_FACTORY_ProfessionAbstractFactory.h /**   @file     GAME_FACTORY_ProfessionAbstractFactory.h   @brief     the abstract factory of profession, use to create the professions (different race)   @author   arvin   @version 1.0   2012/11/12  */ #ifndef CXX_GAME_FACTORY_PROFESSIONABSTRACTFACTORY_H #define CXX_GAME_FACTORY_PROFESSIONABSTRACTFACTORY_H class Profession; class ProfessionAbstractFactory { public: /** * Destruction * * @param VOID * @return  */ virtual ~ProfessionAbstractFactory(); /** * Create Warrior * * @param VOID * @return Profession* * @note use to create the Warrior (different race) */ virtual Profession* CreateWarrior() = 0; /** * Create Master * * @param VOID * @return Profession* * @note use to create the Master (different race) */ virtual Profession* CreateMaster() = 0; /** * Create Priest * * @param VOID * @return Profession* * @note use to create the Priest (different race) */ virtual Profession* CreatePriest() = 0; /** * Create Robber * * @param VOID * @return Profession* * @note use to create the Robber (different race) */ virtual Profession* CreateRobber() = 0; protected: /** * Construction * * @param VOID * @return  */ ProfessionAbstractFactory(); private: }; #endif /* >>CXX_GAME_FACTORY_PROFESSIONABSTRACTFACTORY_H<< */ /* EOF */ GAME_FACTORY_ProfessionFactoryHuman.h /**   @file     GAME_FACTORY_ProfessionFactoryHuman.h   @brief     the Human factory of profession, use to create the professions (Human)   @author   arvin   @version 1.0   2012/11/12  */ #ifndef CXX_GAME_FACTORY_PROFESSIONFACTORYHUMAN_H #define CXX_GAME_FACTORY_PROFESSIONFACTORYHUMAN_H #ifndef CXX_GAME_FACTORY_PROFESSIONABSTRACTFACTORY_H #include \"GAME_FACTORY_ProfessionAbstractFactory.h\" #endif class ProfessionFactoryHuman : public ProfessionAbstractFactory { /************************************************************************/ /*                               function                               */ public: /** * Destruction * * @param VOID * @return  */ virtual ~ProfessionFactoryHuman(); /** * Instance * * @param VOID * @return ProfessionFactoryHuman* * @note singleton */ static ProfessionFactoryHuman* Instance(); /** * Destroy * * @param VOID * @return VOID * @note singleton */ static VOID Destroy(); /** * Create Warrior * * @param VOID * @return Profession* * @note use to create the Warrior (Human) */ virtual Profession* CreateWarrior(); /** * Create Master * * @param VOID * @return Profession* * @note use to create the Master (Human) */ virtual Profession* CreateMaster(); /** * Create Priest * * @param VOID * @return Profession* * @note use to create the Priest (Human) */ virtual Profession* CreatePriest(); /** * Create Robber * * @param VOID * @return Profession* * @note use to create the Robber (Human) */ virtual Profession* CreateRobber(); protected: /** * Construction * * @param VOID * @return  */ ProfessionFactoryHuman(); private: /************************************************************************/ /************************************************************************/ /*                               member                                 */ public: protected: private: static ProfessionFactoryHuman* m_pInstance; /************************************************************************/ }; #endif /* >>CXX_GAME_FACTORY_PROFESSIONFACTORYHUMAN_H<< */ /* EOF */ GAME_FACTORY_ProfessionFactoryOrc.h /**   @file     GAME_FACTORY_ProfessionFactoryOrc.h   @brief     the Orc factory of profession, use to create the professions (Orc)   @author   arvin   @version 1.0   2012/11/12  */ #ifndef CXX_GAME_FACTORY_PROFESSIONFACTORYORC_H #define CXX_GAME_FACTORY_PROFESSIONFACTORYORC_H #ifndef CXX_GAME_FACTORY_PROFESSIONABSTRACTFACTORY_H #include \"GAME_FACTORY_ProfessionAbstractFactory.h\" #endif class ProfessionFactoryOrc : public ProfessionAbstractFactory { /************************************************************************/ /*                               function                               */ public: /** * Destruction * * @param VOID * @return  */ virtual ~ProfessionFactoryOrc(); /** * Instance * * @param VOID * @return ProfessionFactoryOrc* * @note singleton */ static ProfessionFactoryOrc* Instance(); /** * Destroy * * @param VOID * @return VOID * @note singleton */ static VOID Destroy(); /** * Create Warrior * * @param VOID * @return Profession* * @note use to create the Warrior (Orc) */ virtual Profession* CreateWarrior(); /** * Create Master * * @param VOID * @return Profession* * @note use to create the Master (Orc) */ virtual Profession* CreateMaster(); /** * Create Priest * * @param VOID * @return Profession* * @note use to create the Priest (Orc) */ virtual Profession* CreatePriest(); /** * Create Robber * * @param VOID * @return Profession* * @note use to create the Robber (Orc) */ virtual Profession* CreateRobber(); protected: /** * Construction * * @param VOID * @return  */ ProfessionFactoryOrc(); private: /************************************************************************/ /************************************************************************/ /*                               member                                 */ public: protected: private: static ProfessionFactoryOrc* m_pInstance; /************************************************************************/ }; #endif /* >>CXX_GAME_FACTORY_PROFESSIONFACTORYORC_H<< */ /* EOF */ GAME_FACTORY_ProfessionFactoryUndead.h /**   @file     GAME_FACTORY_ProfessionFactoryUndead.h   @brief     the Undead factory of profession, use to create the professions (Undead)   @author   arvin   @version 1.0   2012/11/12  */ #ifndef CXX_GAME_FACTORY_PROFESSIONFACTORYUNDEAD_H #define CXX_GAME_FACTORY_PROFESSIONFACTORYUNDEAD_H #ifndef CXX_GAME_FACTORY_PROFESSIONABSTRACTFACTORY_H #include \"GAME_FACTORY_ProfessionAbstractFactory.h\" #endif class ProfessionFactoryUndead : public ProfessionAbstractFactory { /************************************************************************/ /*                               function                               */ public: /** * Destruction * * @param VOID * @return  */ virtual ~ProfessionFactoryUndead(); /** * Instance * * @param VOID * @return ProfessionFactoryUndead* * @note singleton */ static ProfessionFactoryUndead* Instance(); /** * Destroy * * @param VOID * @return VOID * @note singleton */ static VOID Destroy(); /** * Create Warrior * * @param VOID * @return Profession* * @note use to create the Warrior (Undead) */ virtual Profession* CreateWarrior(); /** * Create Master * * @param VOID * @return Profession* * @note use to create the Master (Undead) */ virtual Profession* CreateMaster(); /** * Create Priest * * @param VOID * @return Profession* * @note use to create the Priest (Undead) */ virtual Profession* CreatePriest(); /** * Create Robber * * @param VOID * @return Profession* * @note use to create the Robber (Undead) */ virtual Profession* CreateRobber(); protected: /** * Construction * * @param VOID * @return  */ ProfessionFactoryUndead(); private: /************************************************************************/ /************************************************************************/ /*                               member                                 */ public: protected: private: static ProfessionFactoryUndead* m_pInstance; /************************************************************************/ }; #endif /* >>CXX_GAME_FACTORY_PROFESSIONFACTORYUNDEAD_H<< */ /* EOF */ GAME_FACTORY_MonsterAbstractFactory.cpp /**   @file     GAME_FACTORY_MonsterAbstractFactory.h    @brief     the abstract factory of Monster, use to create Monster (different level)   @author   arvin   @version 1.0   2012/11/12  */ #include \"stdafx.h\" #ifndef CXX_GAME_FACTORY_MONSTERABSTRACTFACTORY_H #include \"GAME_FACTORY_MonsterAbstractFactory.h\" #endif /** * Construction * * @param VOID * @return  */ MonsterAbstractFactory::MonsterAbstractFactory() { } /** * Destruction * * @param VOID * @return  */ MonsterAbstractFactory::~MonsterAbstractFactory() { } /* EOF */ GAME_FACTORY_MonsterFactoryLevel1.cpp /**   @file     GAME_FACTORY_MonsterFactoryLevel1.cpp   @brief     the level 1 factory of Monster, use to create Monster (level 1)   @author   arvin   @version 1.0   2012/11/12  */ #include \"stdafx.h\" #ifndef CXX_GAME_FACTORY_MONSTERFACTORYLEVEL1_H #include \"GAME_FACTORY_MonsterFactoryLevel1.h\" #endif MonsterFactoryLevel1* MonsterFactoryLevel1::m_pInstance = NULL; /** * Construction * * @param VOID * @return  */ MonsterFactoryLevel1::MonsterFactoryLevel1() { } /** * Destruction * * @param VOID * @return  */ MonsterFactoryLevel1::~MonsterFactoryLevel1() { } /** * Instance * * @param VOID * @return MonsterFactoryLevel1* * @note singleton */ MonsterFactoryLevel1*  MonsterFactoryLevel1::Instance() { if (NULL == m_pInstance) { m_pInstance = new MonsterFactoryLevel1; } return m_pInstance; } /** * Destroy * * @param VOID * @return VOID * @note singleton */ VOID  MonsterFactoryLevel1::Destroy() { if (NULL != m_pInstance) { delete m_pInstance; m_pInstance = NULL; } } /** * Create Monster * * @param VOID * @return Monster* * @use to create Monster (level 1) */ Monster*  MonsterFactoryLevel1::CreateMonsterA() { return NULL; } /** * Create Monster * * @param VOID * @return Monster* * @use to create Monster (level 1) */ Monster*  MonsterFactoryLevel1::CreateMonsterB() { return NULL; } /** * Create Monster * * @param VOID * @return Monster* * @use to create Monster (level 1) */ Monster*  MonsterFactoryLevel1::CreateMonsterC() { return NULL; } /* EOF */ GAME_FACTORY_MonsterFactoryLevel2.cpp /**   @file     GAME_FACTORY_MonsterFactoryLevel2.cpp   @brief     the level 2 factory of Monster, use to create Monster (level 2)   @author   arvin   @version 1.0   2012/11/12  */ #include \"stdafx.h\" #ifndef CXX_GAME_FACTORY_MONSTERFACTORYLEVEL2_H #include \"GAME_FACTORY_MonsterFactoryLevel2.h\" #endif MonsterFactoryLevel2* MonsterFactoryLevel2::m_pInstance = NULL; /** * Construction * * @param VOID * @return  */ MonsterFactoryLevel2::MonsterFactoryLevel2() { } /** * Destruction * * @param VOID * @return  */ MonsterFactoryLevel2::~MonsterFactoryLevel2() { } /** * Instance * * @param VOID * @return MonsterFactoryLevel2* * @note singleton */ MonsterFactoryLevel2*  MonsterFactoryLevel2::Instance() { if (NULL == m_pInstance) { m_pInstance = new MonsterFactoryLevel2; } return m_pInstance; } /** * Destroy * * @param VOID * @return VOID * @note singleton */ VOID  MonsterFactoryLevel2::Destroy() { if (NULL != m_pInstance) { delete m_pInstance; m_pInstance = NULL; } } /** * Create Monster * * @param VOID * @return Monster* * @use to create Monster (level 2) */ Monster*  MonsterFactoryLevel2::CreateMonsterA() { return NULL; } /** * Create Monster * * @param VOID * @return Monster* * @use to create Monster (level 2) */ Monster*  MonsterFactoryLevel2::CreateMonsterB() { return NULL; } /** * Create Monster * * @param VOID * @return Monster* * @use to create Monster (level 2) */ Monster*  MonsterFactoryLevel2::CreateMonsterC() { return NULL; } /* EOF */ GAME_FACTORY_MonsterFactoryLevel3.cpp /**   @file     GAME_FACTORY_MonsterFactoryLevel3.cpp   @brief     the level 3 factory of Monster, use to create Monster (level 3)   @author   arvin   @version 1.0   2012/11/12  */ #include \"stdafx.h\" #ifndef CXX_GAME_FACTORY_MONSTERFACTORYLEVEL3_H #include \"GAME_FACTORY_MonsterFactoryLevel3.h\" #endif MonsterFactoryLevel3* MonsterFactoryLevel3::m_pInstance = NULL; /** * Construction * * @param VOID * @return  */ MonsterFactoryLevel3::MonsterFactoryLevel3() { } /** * Destruction * * @param VOID * @return  */ MonsterFactoryLevel3::~MonsterFactoryLevel3() { } /** * Instance * * @param VOID * @return MonsterFactoryLevel3* * @note singleton */ MonsterFactoryLevel3*  MonsterFactoryLevel3::Instance() { if (NULL == m_pInstance) { m_pInstance = new MonsterFactoryLevel3; } return m_pInstance; } /** * Destroy * * @param VOID * @return VOID * @note singleton */ VOID  MonsterFactoryLevel3::Destroy() { if (NULL != m_pInstance) { delete m_pInstance; m_pInstance = NULL; } } /** * Create Monster * * @param VOID * @return Monster* * @use to create Monster (level 3) */ Monster*  MonsterFactoryLevel3::CreateMonsterA() { return NULL; } /** * Create Monster * * @param VOID * @return Monster* * @use to create Monster (level 3) */ Monster*  MonsterFactoryLevel3::CreateMonsterB() { return NULL; } /** * Create Monster * * @param VOID * @return Monster* * @use to create Monster (level 3) */ Monster*  MonsterFactoryLevel3::CreateMonsterC() { return NULL; } /* EOF */ GAME_FACTORY_ProfessionAbstractFactory.cpp /**   @file     GAME_FACTORY_ProfessionAbstractFactory.cpp   @brief     the abstract factory of profession, use to create the professions (different race)   @author   arvin   @version 1.0   2012/11/12  */ #include \"stdafx.h\" #ifndef CXX_GAME_FACTORY_PROFESSIONABSTRACTFACTORY_H #include \"GAME_FACTORY_ProfessionAbstractFactory.h\" #endif /** * Construction * * @param VOID * @return  */ ProfessionAbstractFactory::ProfessionAbstractFactory() { } /** * Destruction * * @param VOID * @return  */ ProfessionAbstractFactory::~ProfessionAbstractFactory() { } /* EOF */ GAME_FACTORY_ProfessionFactoryHuman.cpp /**   @file     GAME_FACTORY_ProfessionFactoryHuman.cpp   @brief     the Human factory of profession, use to create the professions (Human)   @author   arvin   @version 1.0   2012/11/12  */ #include \"stdafx.h\" #ifndef CXX_GAME_FACTORY_PROFESSIONFACTORYHUMAN_H #include \"GAME_FACTORY_ProfessionFactoryHuman.h\" #endif ProfessionFactoryHuman* ProfessionFactoryHuman::m_pInstance = NULL; /** * Construction * * @param VOID * @return  */ ProfessionFactoryHuman::ProfessionFactoryHuman() { } /** * Destruction * * @param VOID * @return  */ ProfessionFactoryHuman::~ProfessionFactoryHuman() { } /** * Instance * * @param VOID * @return ProfessionFactoryHuman* * @note singleton */ ProfessionFactoryHuman*  ProfessionFactoryHuman::Instance() { if (NULL == m_pInstance) { m_pInstance = new ProfessionFactoryHuman; } return m_pInstance; } /** * Destroy * * @param VOID * @return VOID * @note singleton */ VOID  ProfessionFactoryHuman::Destroy() { if (NULL != m_pInstance) { delete m_pInstance; m_pInstance = NULL; } } /** * Create Warrior * * @param VOID * @return Profession* * @note use to create the Warrior (Human) */ Profession*  ProfessionFactoryHuman::CreateWarrior() { return NULL; } /** * Create Master * * @param VOID * @return Profession* * @note use to create the Master (Human) */ Profession*  ProfessionFactoryHuman::CreateMaster() { return NULL; } /** * Create Priest * * @param VOID * @return Profession* * @note use to create the Priest (Human) */ Profession*  ProfessionFactoryHuman::CreatePriest() { return NULL; } /** * Create Robber * * @param VOID * @return Profession* * @note use to create the Robber (Human) */ Profession*  ProfessionFactoryHuman::CreateRobber() { return NULL; } /* EOF */ GAME_FACTORY_ProfessionFactoryOrc.cpp /**   @file     GAME_FACTORY_ProfessionFactoryOrc.cpp   @brief     the Orc factory of profession, use to create the professions (Orc)   @author   arvin   @version 1.0   2012/11/12  */ #include \"stdafx.h\" #ifndef CXX_GAME_FACTORY_PROFESSIONFACTORYORC_H #include \"GAME_FACTORY_ProfessionFactoryOrc.h\" #endif ProfessionFactoryOrc* ProfessionFactoryOrc::m_pInstance = NULL; /** * Construction * * @param VOID * @return  */ ProfessionFactoryOrc::ProfessionFactoryOrc() { } /** * Destruction * * @param VOID * @return  */ ProfessionFactoryOrc::~ProfessionFactoryOrc() { } /** * Instance * * @param VOID * @return ProfessionFactoryOrc* * @note singleton */ ProfessionFactoryOrc*  ProfessionFactoryOrc::Instance() { if (NULL == m_pInstance) { m_pInstance = new ProfessionFactoryOrc; } return m_pInstance; } /** * Destroy * * @param VOID * @return VOID * @note singleton */ VOID  ProfessionFactoryOrc::Destroy() { if (NULL != m_pInstance) { delete m_pInstance; m_pInstance = NULL; } } /** * Create Warrior * * @param VOID * @return Profession* * @note use to create the Warrior (Orc) */ Profession*  ProfessionFactoryOrc::CreateWarrior() { return NULL; } /** * Create Master * * @param VOID * @return Profession* * @note use to create the Master (Orc) */ Profession*  ProfessionFactoryOrc::CreateMaster() { return NULL; } /** * Create Priest * * @param VOID * @return Profession* * @note use to create the Priest (Orc) */ Profession*  ProfessionFactoryOrc::CreatePriest() { return NULL; } /** * Create Robber * * @param VOID * @return Profession* * @note use to create the Robber (Orc) */ Profession*  ProfessionFactoryOrc::CreateRobber() { return NULL; } /* EOF */ GAME_FACTORY_ProfessionFactoryUndead.cpp /**   @file     GAME_FACTORY_ProfessionFactoryUndead.cpp   @brief     the Undead factory of profession, use to create the professions (Undead)   @author   arvin   @version 1.0   2012/11/12  */ #include \"stdafx.h\" #ifndef CXX_GAME_FACTORY_PROFESSIONFACTORYUNDEAD_H #include \"GAME_FACTORY_ProfessionFactoryUndead.h\" #endif ProfessionFactoryUndead* ProfessionFactoryUndead::m_pInstance = NULL; /** * Construction * * @param VOID * @return  */ ProfessionFactoryUndead::ProfessionFactoryUndead() { } /** * Destruction * * @param VOID * @return  */ ProfessionFactoryUndead::~ProfessionFactoryUndead() { } /** * Instance * * @param VOID * @return ProfessionFactoryUndead* * @note singleton */ ProfessionFactoryUndead*  ProfessionFactoryUndead::Instance() { if (NULL == m_pInstance) { m_pInstance = new ProfessionFactoryUndead; } return m_pInstance; } /** * Destroy * * @param VOID * @return VOID * @note singleton */ VOID  ProfessionFactoryUndead::Destroy() { if (NULL != m_pInstance) { delete m_pInstance; m_pInstance = NULL; } } /** * Create Warrior * * @param VOID * @return Profession* * @note use to create the Warrior (Undead) */ Profession*  ProfessionFactoryUndead::CreateWarrior() { return NULL; } /** * Create Master * * @param VOID * @return Profession* * @note use to create the Master (Undead) */ Profession*  ProfessionFactoryUndead::CreateMaster() { return NULL; } /** * Create Priest * * @param VOID * @return Profession* * @note use to create the Priest (Undead) */ Profession*  ProfessionFactoryUndead::CreatePriest() { return NULL; } /** * Create Robber * * @param VOID * @return Profession* * @note use to create the Robber (Undead) */ Profession*  ProfessionFactoryUndead::CreateRobber() { return NULL; } /* EOF */ GameFactory.cpp (Main文件) // GameFactory.cpp : Defines the entry point for the console application. // #include \"stdafx.h\" #ifndef CXX_GAME_FACTORY_MONSTERFACTORYLEVEL1_H #include \"GAME_FACTORY_MonsterFactoryLevel1.h\" #endif #ifndef CXX_GAME_FACTORY_MONSTERFACTORYLEVEL2_H #include \"GAME_FACTORY_MonsterFactoryLevel2.h\" #endif #ifndef CXX_GAME_FACTORY_MONSTERFACTORYLEVEL3_H #include \"GAME_FACTORY_MonsterFactoryLevel3.h\" #endif #ifndef CXX_GAME_FACTORY_PROFESSIONFACTORYHUMAN_H #include \"GAME_FACTORY_ProfessionFactoryHuman.h\" #endif #ifndef CXX_GAME_FACTORY_PROFESSIONFACTORYORC_H #include \"GAME_FACTORY_ProfessionFactoryOrc.h\" #endif #ifndef CXX_GAME_FACTORY_PROFESSIONFACTORYUNDEAD_H #include \"GAME_FACTORY_ProfessionFactoryUndead.h\" #endif MonsterAbstractFactory*  GetMonsterFactory() { //Monster Factory static int i = 0; i++; if (3 == i) { i = 0; } if (0 == i) { //level1 return MonsterFactoryLevel1::Instance(); } else if (1 == i) { //level2 return MonsterFactoryLevel2::Instance(); } else if (2 == i) { //level3 return MonsterFactoryLevel3::Instance(); } else{ return NULL; } } ProfessionAbstractFactory*  GetProfessionFactory() { //Profession Factory static int i = 0; i++; if (3 == i) { i = 0; } if (0 == i) { //level1 return ProfessionFactoryHuman::Instance(); } else if (1 == i) { //level2 return ProfessionFactoryOrc::Instance(); } else if (2 == i) { //level3 return ProfessionFactoryUndead::Instance(); } else{ return NULL; } } int _tmain(int argc, _TCHAR* argv[]) { //Monster Monster* pMonsterTemp = NULL; for (int i=0; i<3; i++) { MonsterAbstractFactory* pMonsterFactory = GetMonsterFactory(); if (NULL == pMonsterFactory) { //error do something return 0; } pMonsterTemp = pMonsterFactory->CreateMonsterA(); pMonsterTemp = pMonsterFactory->CreateMonsterB(); pMonsterTemp = pMonsterFactory->CreateMonsterC(); } //Profession Profession* pProfessionTemp = NULL; for (int i=0; i<3; i++) { ProfessionAbstractFactory* pProfessionFactory = GetProfessionFactory(); if (NULL == pProfessionFactory) { //error do something return 0; } pProfessionTemp = pProfessionFactory->CreateWarrior(); pProfessionTemp = pProfessionFactory->CreateMaster(); pProfessionTemp = pProfessionFactory->CreatePriest(); pProfessionTemp = pProfessionFactory->CreateRobber(); } return 0; }","title":"回合制游戏-------------------------------------------建模(工厂模式)"},{"content":"                     面向对象设计模式  常用的面向对象设计模式有4种： Factory模式、Singleton模式、Facade模式和MVC架构模式。  JSP设计模式  SUN公司推出JSP技术后，同时也推荐了两种web应用程序的开发模式，一种是JSP+JavaBean模式，一种是Servlet+JSP+JavaBean模式。 JSP设计模式包括两个： （1）Model1，JSP+JavaBean设计模式 （2）Model2，MVC设计模式  模式一JSP+JavaBean模式      在这种模式中，JSP页面独自响应请求并将处理结果返回客户，所有的数据库操作通过JavaBean来实现。 大量地使用这种模式，常会导致在JSP页面中嵌入大量的Java代码，当需要处理的商业逻辑非常复杂时，这种情况就会变得很糟糕。大量的Java代码使得JSP页面变得非常臃肿。前端的页面设计人员稍有不慎，就有可能破坏关系到商业逻辑的代码。 这种情况在大型项目中经常出现，造成了代码开发和维护的困难，同时会导致项目管理的困难。因此这种模式只适用于中小规模的项目。 JSP+JavaBean模式适合开发业务逻辑不太复杂的web应用程序，这种模式下，JavaBean用于封装业务数据，JSP即负责处理用户请求，又显示数据。 模式二  MVC模式    “MVC”模式即是：“Model-View-Controller”模式。在这种模式中，通过JSP技术来表现页面，通过Servlet技术来完成大量的事务处理工作，实现用户的商业逻辑。 在这种模式中，Servlet用来处理请求的事务，充当了控制器（Controller即“C”）的角色，Servlet负责响应客户对业务逻辑的请求并根据用户的请求行为，决定将哪个JSP页面发送给客户。JSP页面处于表现层，也就是视图（View即“V”）的角色。JavaBean则负责数据的处理，也就是模型（Model即“M”）的角色   Servlet+JSP+JavaBean(MVC)模式适合开发复杂的web应用，在这种模式下，servlet负责处理用户请求，jsp负责数据显示，javabean负责封装数据。 Servlet+JSP、JavaBean模式程序各个模块之间层次清晰，web开发推荐采用此种模式。  MVC架构 Model-View-Controller架构模式是80年代中期在Smalltalk-80 GUI（一种经典的面向对象程序设计语言）实验室发明的。 根据MVC模式，一个软件应该将商务逻辑（Model）和显示(View)分开。分开有许多好处，最主要的有两个方面： 1、同一的商务逻辑层（Model）可能会对应多个显示层（View），如果商务逻辑层和显示层放在一起的话，再添加一个显示层的时候就会极大的增加组件的复杂性。一个商务逻辑对着两个显示层的例子是：银行的帐户的商务逻辑层对应ATM和Internet两个显示层。 2、通常情况下，每次修改显示层的时候一般并不需要修改商务逻辑层。 例   在jsp文件头部加一个<%@taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %>  指令，运用foreach   <%        List list = new ArrayList();       list.add(new User(\"aaa\"));       list.add(new User(\"bbb\"));       list.add(new User(\"ccc\"));       list.add(new User(\"ddd\"));              request.setAttribute(\"list\",list);       %>    <c:forEach items=\"${list}\" var=\"user\">      ${user.name }        <\/c:forEach>       <%    Map map=new HashMap();    map.put(\"aa\",new User(\"aaaa\"));    map.put(\"bb\",new User(\"bbbb\"));    map.put(\"cc\",new User(\"cccc\"));    map.put(\"123\",new User(\"dddd\"));    request.setAttribute(\"mapp\",map);     %><!--        ${mapp.bb.name }<br/>   ${mapp[\"123\"].name }   -->   <c:forEach items=\"${mapp}\" var=\"mapp\">    ${ mapp.key}----${mapp.value.name }   <\/c:forEach>","title":"JavaWeb技术之--面向对象设计模式"},{"content":"JavaWeb技术之--面向对象设计模式 面向对象设计模式 面向对象软件开发领域中，设计模式包括一些规则来完成一定任务。设计模式针对一些特定的问题，提出一种解决方案。 常用的面向对象设计模式有4种： Factory模式、Singleton模式、Facade模式和MVC架构模式。 JSP设计模式 SUN公司推出JSP技术后，同时也推荐了两种web应用程序的开发模式，一种是JSP+JavaBean模式，一种是Servlet+JSP+JavaBean模式。 JSP设计模式包括两个： （1）Model1，JSP+JavaBean设计模式 （2）Model2，MVC设计模式 模式一JSP+JavaBean模式 在这种模式中，JSP页面独自响应请求并将处理结果返回客户，所有的数据库操作通过JavaBean来实现。 大量地使用这种模式，常会导致在JSP页面中嵌入大量的Java代码，当需要处理的商业逻辑非常复杂时，这种情况就会变得很糟糕。大量的Java代码使得JSP页面变得非常臃肿。前端的页面设计人员稍有不慎，就有可能破坏关系到商业逻辑的代码。 这种情况在大型项目中经常出现，造成了代码开发和维护的困难，同时会导致项目管理的困难。因此这种模式只适用于中小规模的项目。 JSP+JavaBean模式适合开发业务逻辑不太复杂的web应用程序，这种模式下，JavaBean用于封装业务数据，JSP即负责处理用户请求，又显示数据。 模式二  MVC模式 “MVC”模式即是：“Model-View-Controller”模式。在这种模式中，通过JSP技术来表现页面，通过Servlet技术来完成大量的事务处理工作，实现用户的商业逻辑。 在这种模式中，Servlet用来处理请求的事务，充当了控制器（Controller即“C”）的角色，Servlet负责响应客户对业务逻辑的请求并根据用户的请求行为，决定将哪个JSP页面发送给客户。JSP页面处于表现层，也就是视图（View即“V”）的角色。JavaBean则负责数据的处理，也就是模型（Model即“M”）的角色   Servlet+JSP+JavaBean(MVC)模式适合开发复杂的web应用，在这种模式下，servlet负责处理用户请求，jsp负责数据显示，javabean负责封装数据。 Servlet+JSP、JavaBean模式程序各个模块之间层次清晰，web开发推荐采用此种模式。 MVC架构 Model-View-Controller架构模式是80年代中期在Smalltalk-80 GUI（一种经典的面向对象程序设计语言）实验室发明的。 根据MVC模式，一个软件应该将商务逻辑（Model）和显示(View)分开。分开有许多好处，最主要的有两个方面： 1、同一的商务逻辑层（Model）可能会对应多个显示层（View），如果商务逻辑层和显示层放在一起的话，再添加一个显示层的时候就会极大的增加组件的复杂性。一个商务逻辑对着两个显示层的例子是：银行的帐户的商务逻辑层对应ATM和Internet两个显示层。 2、通常情况下，每次修改显示层的时候一般并不需要修改商务逻辑层。 MVC模式   MVC中三层的关系 MVC在JSP中的实现模型 目前有两种实现模型： （1）基于Bean的MVC模型。 （2）基于Stucts的MVC模型。 基于Bean的MVC模型 Bean可以利用JavaBean实现，也可以利用EJB来实现，分别构成的系统是： JavaBean（M）+JSP（V）+Servlet EJB（M）+JSP（V）+Servlet（C）实现。 基于Struts的MVC模型 Struts是Apache组织的一个项目，像其他的Apache组织的项目一样，它也是开放源码项目。 Struts是一个比较好的MVC框架提供了对开发MVC系统的底层支持，它采用的主要技术是Servlet，JSP和custom tag library。 Struts 是一组相互协作的类、Servlet 和 JSP 标记，它们组成一个可重用的MVC设计。这个定义表示Struts是一个框架，而不是一个库，但Struts也包含了丰富的标记库和独立于该框架工作的实用程序类。Struts的基本结构如图所示。","title":"11级_Java_曹建波 11.14 jsp设计模式"},{"content":"认识观察者模式 我们看看报纸和杂志的订阅是怎么回事： 报社的业务就是出版报纸。 向某家报社订阅报纸，只要他们有新报纸出版，就会给你送来。只要你是他们的订户，你就会一直收到新报纸。 当你不想再看报纸的时候，取消订阅，他们就不会再送新报纸来。 只要报社还在运营，就会一直有人（或单位）向他们订阅报纸或取消订阅报纸。 如果你了解报纸的订阅是怎么回事，其实就知道观察者模式是怎么回事，只是名称不太一样：出版者改称为“主题”（Subject），订阅者改称为“观察者”（Observer）。 定义观察者模式 当你试图勾勒观察者模式时，可以利用报纸订阅服务，以及出版者和订阅者比拟这一切。 在真实的世界中，你通常会看到观察者模式被定义成： 观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 松耦合的威力 设计原则 为了交互对象之间的松耦合设计而努力。 当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。观察者模式提供了一种对象设计，让主题和观察者之间松耦合。 为什么呢？ 关于观察者的一切，主题只知道观察者实现了某个接口（也就是Observer接口）。主题不需要知道观察者的具体类是谁、做了些什么或其他任何细节。 任何时候我们都可以增加新的观察者。因为主题唯一依赖的东西是一个实现Observer接口的对象列表，所以我们可以随时增加观察者。事实上，在运行时我们可以用新的观察者取代现有的观察者，主题不会受到任何影响。同样的，也可以在任何时候删除某些观察者。 有新类型的观察者出现时，主题的代码不需要修改。假如我们有个新的具体类需要当观察者，我们不需要为了兼容新类型而修改主题的代码，所有要做的就是在新的类里实现此观察者接口，然后注册为观察者即可。主题不在乎别的，它只会发送通知给所有实现了观察者接口的对象。 我们可以独立地复用主题或观察者。如果我们在其他地方需要使用主题或观察者，可以轻易地复用，因为二者并非紧耦合。 改变主题或观察者其中一方，并不会影响另一方。因为两者是松耦合的，所以只要他们之间的接口仍被遵守，我们就可以自由地改变他们。 松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的互相依赖降到了最低。","title":"设计模式（二）Observer - 观察者模式"},{"content":"作用：     在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。     UML结构图：     解析：     Memento模式中封装的是需要保存的状态，当需要恢复的时候才取出来进行恢复。原理很简单，实现的时候需要注意一个地方：窄接口和宽接口。所谓的宽接口就是一般意义上的接口，把对外的接口作为public成员；而窄接口反之，把接口作为private成员，而把需要访问这些接口函数的类作为这个类的友元类，也就是说接口只暴露给了对这些接口感兴趣的类，而不是暴露在外部。下面的实现就是窄实现的方法来实现的。     实现：     1）Memento.h #ifndef MEMENTO_H #define MEMENTO_H #include <string> typedef std::string State; class Memento; class Originator { public: 　　　 Originator(const State& rState); 　　　 Originator(); 　　　 ~Originator(); 　　　 Memento*　　　 CreateMemento(); 　　　 void　　　　　　　 SetMemento(Memento* pMemento); 　　　 State　　　　　　　 GetState(); 　　　 void　　　　　　　 SetState(const State& rState); 　　　 void　　　　　　　 RestoreState(Memento* pMemento); 　　　 void　　　　　　　 PrintState(); private: 　　　 State　　　　　　　 m_State; }; // 把Memento的接口函数都设置为私有的,而Originator是它的友元, // 这样保证了只有Originator可以对其访问 class Memento { private: 　　　 friend class Originator; 　　　 Memento(const State& rState); 　　　 void　　　 SetState(const State& rState); 　　　 State　　　 GetState(); 　　　 State　　　 m_State; }; #endif  2）Memento.cpp #include \"Memento.h\" #include <iostream> Originator::Originator() { } Originator::Originator(const State& rState) 　　　 : m_State(rState) { } Originator::~Originator() { } State Originator::GetState() { 　　　 return m_State; } void Originator::SetState(const State& rState) { 　　　 m_State = rState; } Memento* Originator::CreateMemento() { 　　　 return new Memento(m_State); } void Originator::RestoreState(Memento* pMemento) { 　　　 if (NULL != pMemento) 　　　 { 　　　　　　　 m_State = pMemento->GetState(); 　　　 }　　　 } void Originator::PrintState() { 　　　 std::cout << \"State = \" << m_State << std::endl; } Memento::Memento(const State& rState) 　　　 : m_State(rState) { } State Memento::GetState() { 　　　 return m_State; } void Memento::SetState(const State& rState) { 　　　 m_State = rState; }     3）Main.cpp #include \"Memento.h\" int main() { 　　　 // 创建一个原发器 　　　 Originator* pOriginator = new Originator(\"old state\"); 　　　 pOriginator->PrintState(); 　　　 // 创建一个备忘录存放这个原发器的状态 　　　 Memento *pMemento = pOriginator->CreateMemento(); 　　　 　　　 // 更改原发器的状态 　　　 pOriginator->SetState(\"new state\"); 　　　 pOriginator->PrintState(); 　　　 // 通过备忘录把原发器的状态还原到之前的状态 　　　 pOriginator->RestoreState(pMemento); 　　　 pOriginator->PrintState(); 　　　 delete pOriginator; 　　　 delete pMemento; 　　　 return 0; }","title":"设计模式解析和实现(C++)之十九-Memento模式"},{"content":"作用：     表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。     UML结构图：     解析：     Visitor模式把对结点的访问封装成一个抽象基类，通过派生出不同的类生成新的访问方式。在实现的时候，在visitor抽象基类中声明了对所有不同结点进行访问的接口函数，如图中的VisitConcreateElementA函数等，这样也造成了Visitor模式的一个缺陷——新加入一个结点的时候都要添加Visitor中的对其进行访问接口函数，这样使得所有的Visitor及其派生类都要重新编译了，也就是说Visitor模式一个缺点就是添加新的结点十分困难。另外，还需要指出的是Visitor模式采用了所谓的\"双重分派\"的技术，拿上图来作为例子，要对某一个结点进行访问，首先需要产生一个Element的派生类对象，其次要传入一个Visitor类派生类对象来调用对应的Accept函数，也就是说，到底对哪种Element采用哪种Visitor访问，需要两次动态绑定才可以确定下来，具体的实现可以参考下面实现代码中的Main.cpp部分是如何调用这些类的。     实现：     1）Visitor.h #ifndef VISITOR_H #define VISITOR_H class Visitor; class Element { public: 　　　 virtual ~Element(){} 　　　 virtual void Accept(Visitor &rVisitor) = 0; protected: 　　　 Element(){} }; class ConcreateElementA 　　　 : public Element { public: 　　　 virtual ~ConcreateElementA() {} 　　　 virtual void Accept(Visitor &rVisitor); }; class ConcreateElementB 　　　 : public Element { public: 　　　 virtual ~ConcreateElementB() {} 　　　 virtual void Accept(Visitor &rVisitor); }; class Visitor { public: 　　　 virtual ~Visitor(){} 　　　 virtual void VisitConcreateElementA(ConcreateElementA *pConcreateElementA) = 0; 　　　 virtual void VisitConcreateElementB(ConcreateElementB *pConcreateElementB) = 0; protected: 　　　 Visitor(){} }; class ConcreateVisitorA 　　　 : public Visitor { public: 　　　 virtual ~ConcreateVisitorA(){} 　　　 virtual void VisitConcreateElementA(ConcreateElementA *pConcreateElementA); 　　　 virtual void VisitConcreateElementB(ConcreateElementB *pConcreateElementB); }; class ConcreateVisitorB 　　　 : public Visitor { public: 　　　 virtual ~ConcreateVisitorB(){} 　　　 virtual void VisitConcreateElementA(ConcreateElementA *pConcreateElementA); 　　　 virtual void VisitConcreateElementB(ConcreateElementB *pConcreateElementB); }; #endif 2）Visitor.cpp #include \"Visitor.h\" #include <iostream> void ConcreateElementA::Accept(Visitor &rVisitor) { 　　　 rVisitor.VisitConcreateElementA(this); } void ConcreateElementB::Accept(Visitor &rVisitor) { 　　　 rVisitor.VisitConcreateElementB(this); } void ConcreateVisitorA::VisitConcreateElementA(ConcreateElementA *pConcreateElementA) { 　　　 std::cout << \"VisitConcreateElementA By ConcreateVisitorAn\"; } void ConcreateVisitorA::VisitConcreateElementB(ConcreateElementB *pConcreateElementA) { 　　　 std::cout << \"VisitConcreateElementB By ConcreateVisitorAn\"; } void ConcreateVisitorB::VisitConcreateElementA(ConcreateElementA *pConcreateElementA) { 　　　 std::cout << \"VisitConcreateElementA By ConcreateVisitorBn\"; } void ConcreateVisitorB::VisitConcreateElementB(ConcreateElementB *pConcreateElementA) { 　　　 std::cout << \"VisitConcreateElementB By ConcreateVisitorBn\"; }     3）Main.cpp #include \"Visitor.h\" int main() { 　　　 Visitor *pVisitorA = new ConcreateVisitorA(); 　　　 Element *pElement　 = new ConcreateElementA(); 　　　 pElement->Accept(*pVisitorA); 　　　 delete pElement; 　　　 delete pVisitorA; 　　　 return 0; }","title":"设计模式的解析和实现(C++)之二十-Visitor模式"},{"content":"作用：     定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。     UML结构图：     解析：     Observer模式定义的是一种一对多的关系，这里的一就是图中的Subject类，而多则是Obesrver类，当Subject类的状态发生变化的时候通知与之对应的Obesrver类们也去相应的更新状态，同时支持动态的添加和删除Observer对象的功能。Obesrver模式的实现要点是，第一一般subject类都是采用链表等容器来存放Observer对象，第二抽取出Observer对象的一些公共的属性形成Observer基类，而Subject中保存的则是Observer类对象的指针，这样就使Subject和具体的Observer实现了解耦，也就是Subject不需要去关心到底是哪个Observer对放进了自己的容器中。生活中有很多例子可以看做是Observer模式的运用，比方说，一个班有一个班主任（Subject），他管理手下的一帮学生（Observer），当班里有一些事情发生需要通知学生的时候，班主任要做的不是逐个学生挨个的通知而是把学生召集起来一起通知，实现了班主任和具体学生的关系解耦。     实现：     1）Observer.h #ifndef OBSERVER_H #define OBSERVER_H #include <list> typedef int STATE; class Observer; // Subject抽象基类,只需要知道Observer基类的声明就可以了 class Subject { public: 　　　 Subject() : m_nSubjectState(-1){} 　　　 virtual ~Subject(); 　　　 void Notify();　　　　　　　　　　　　　　　　　　　　　　　　　　　 // 通知对象改变状态 　　　 void Attach(Observer *pObserver);　　　　　　　 // 新增对象 　　　 void Detach(Observer *pObserver);　　　　　　　 // 删除对象 　　　 // 虚函数,提供默认的实现,派生类可以自己实现来覆盖基类的实现 　　　 virtual void　　　 SetState(STATE nState);　　　 // 设置状态 　　　 virtual STATE　　　 GetState();　　　　　　　 // 得到状态 protected: 　　　 STATE m_nSubjectState;　　　　　　　　　　　　　　　　　　　 // 模拟保存Subject状态的变量 　　　 std::list<Observer*>　　　 m_ListObserver;　　　 // 保存Observer指针的链表 }; // Observer抽象基类 class Observer { public: 　　　 Observer() : m_nObserverState(-1){} 　　　 virtual ~Observer(){} 　　　 // 纯虚函数,各个派生类可能有不同的实现 　　　 // 通知Observer状态发生了变化 　　　 virtual void Update(Subject* pSubject) = 0; protected: 　　　 STATE m_nObserverState;　　　　　　　　　　　　　　　　　　　 // 模拟保存Observer状态的变量 }; // ConcreateSubject类,派生在Subject类 class ConcreateSubject 　　　 : public Subject { public: 　　　 ConcreateSubject() : Subject(){} 　　　 virtual ~ConcreateSubject(){} 　　　 // 派生类自己实现来覆盖基类的实现 　　　 virtual void　　　 SetState(STATE nState);　　　 // 设置状态 　　　 virtual STATE　　　 GetState();　　　　　　　 // 得到状态 }; // ConcreateObserver类派生自Observer class ConcreateObserver 　　　 : public Observer { public: 　　　 ConcreateObserver() : Observer(){} 　　　 virtual ~ConcreateObserver(){} 　　　 // 虚函数,实现基类提供的接口 　　　 virtual void Update(Subject* pSubject); }; #endif 2）Observer.cpp #include \"Observer.h\" #include <iostream> #include <algorithm> /**//* -------------------------------------------------------------------- |　　　 Subject类成员函数的实现 | 　----------------------------------------------------------------------*/ void Subject::Attach(Observer *pObserver) { 　　　 std::cout << \"Attach an Observern\"; 　　　 m_ListObserver.push_back(pObserver); } void Subject::Detach(Observer *pObserver) { 　　　 std::list<Observer*>::iterator iter; 　　　 iter = std::find(m_ListObserver.begin(), m_ListObserver.end(), pObserver); 　　　 if (m_ListObserver.end() != iter) 　　　 { 　　　　　　　 m_ListObserver.erase(iter); 　　　 } 　　　 std::cout << \"Detach an Observern\"; } void Subject::Notify() { 　　　 std::cout << \"Notify Observers's Staten\"; 　　　 std::list<Observer*>::iterator iter1, iter2; 　　　 for (iter1 = m_ListObserver.begin(), iter2 = m_ListObserver.end(); 　　　　　　　　 iter1 != iter2; 　　　　　　　　 ++iter1) 　　　 { 　　　　　　　 (*iter1)->Update(this); 　　　 } } void Subject::SetState(STATE nState) { 　　　 std::cout << \"SetState By Subjectn\"; 　　　 m_nSubjectState = nState; } STATE Subject::GetState() { 　　　 std::cout << \"GetState By Subjectn\"; 　　　 return m_nSubjectState; } Subject::~Subject() { 　　　 std::list<Observer*>::iterator iter1, iter2, temp; 　　　 for (iter1 = m_ListObserver.begin(), iter2 = m_ListObserver.end(); 　　　　　　　 iter1 != iter2; 　　　　　　　 ) 　　　 { 　　　　　　　 temp = iter1; 　　　　　　　 ++iter1; 　　　　　　　 delete (*temp); 　　　 } 　　　 m_ListObserver.clear(); } /**//* -------------------------------------------------------------------- |　　　 ConcreateSubject类成员函数的实现 | ----------------------------------------------------------------------*/ void ConcreateSubject::SetState(STATE nState) { 　　　 std::cout << \"SetState By ConcreateSubjectn\"; 　　　 m_nSubjectState = nState; } STATE ConcreateSubject::GetState() { 　　　 std::cout << \"GetState By ConcreateSubjectn\"; 　　　 return m_nSubjectState; } /**//* -------------------------------------------------------------------- |　　　 ConcreateObserver类成员函数的实现 | ----------------------------------------------------------------------*/ void ConcreateObserver::Update(Subject* pSubject) { 　　　 if (NULL == pSubject) 　　　　　　　 return; 　　　 m_nObserverState = pSubject->GetState(); 　　　 std::cout << \"The ObeserverState is \" << m_nObserverState << std::endl; }     3）Main.cpp #include \"Observer.h\" #include <iostream> int main() { 　　　 Observer *p1 = new ConcreateObserver; 　　　 Observer *p2 = new ConcreateObserver; 　　　 Subject* p = new ConcreateSubject; 　　　 p->Attach(p1); 　　　 p->Attach(p2); 　　　 p->SetState(4); 　　　 p->Notify(); 　　　 p->Detach(p1); 　　　 p->SetState(10); 　　　 p->Notify(); 　　　 delete p; 　　　 system(\"pause\"); 　　　 return 0; }","title":"设计模式解析和实现(C++)之十五-Observer模式"},{"content":"作用：     定义一系列的算法，把它们一个个封装起来， 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。     解析：     简而言之一句话，Strategy模式是对算法的封装。处理一个问题的时候可能有多种算法，这些算法的接口（输入参数，输出参数等）都是一致的，那么可以考虑采用Strategy模式对这些算法进行封装，在基类中定义一个函数接口就可以了。     实现：     1）Strategy.h #ifndef STRATEGY_H #define STRATEGY_H class Strategy; class Context { public: 　　　 Context(Strategy *pStrategy); 　　　 ~Context(); 　　　 void ContextInterface(); private: 　　　 Strategy* m_pStrategy; }; class Strategy { public: 　　　 virtual ~Strategy(){} 　　　 virtual void AlgorithmInterface() = 0; }; class ConcreateStrategyA 　　　 : public Strategy { public: 　　　 virtual ~ConcreateStrategyA(){} 　　　 virtual void AlgorithmInterface(); }; #endif     2）Strategy.cpp #include <iostream> #include \"Strategy.h\" Context::Context(Strategy *pStrategy) 　　　 : m_pStrategy(pStrategy) { } Context::~Context() { 　　　 delete m_pStrategy; 　　　 m_pStrategy = NULL; } void Context::ContextInterface() { 　　　 if (NULL != m_pStrategy) 　　　 { 　　　　　　　 m_pStrategy->AlgorithmInterface(); 　　　 } } void ConcreateStrategyA::AlgorithmInterface() { 　　　 std::cout << \"AlgorithmInterface Implemented by ConcreateStrategyAn\"; }     3）Main.cpp #include \"Strategy.h\" int main() { 　　　 Strategy* pStrategy = new ConcreateStrategyA(); 　　　 Context*　 pContext　 = new Context(pStrategy); 　　　 pContext->ContextInterface(); 　　　 delete pContext; 　　　 return 0; }","title":"设计模式的解析和实现(C++)之十六-Strategy模式"},{"content":"作用：     允许一个对象在其内部状态改变时改变它的行为。     UML结构图：     解析：     State模式主要解决的是在开发中时常遇到的根据不同的状态需要进行不同的处理操作的问题，而这样的问题，大部分人是采用switch-case语句进行处理的，这样会造成一个问题：分支过多，而且如果加入一个新的状态就需要对原来的代码进行编译。State模式采用了对这些不同的状态进行封装的方式处理这类问题，当状态改变的时候进行处理然后再切换到另一种状态，也就是说把状态的切换责任交给了具体的状态类去负责。同时，State模式和Strategy模式在图示上有很多相似的地方，需要说明的是两者的思想都是一致的，只不过封装的东西不同：State模式封装的是不同的状态，而Stategy模式封装的是不同的算法。     实现：     1）State.h #ifndef STATE_H #define STATE_H class State; class Context { public: 　　　 Context(State* pState); 　　　 ~Context(); 　　　 void Request(); 　　　 void ChangeState(State *pState); private: 　　　 State *m_pState; }; class State { public: 　　　 virtual ~State(){} 　　　 virtual void Handle(Context* pContext) = 0; }; class ConcreateStateA 　　　 : public State { public: 　　　 void Handle(Context* pContext); }; class ConcreateStateB 　　　 : public State { public: 　　　 void Handle(Context* pContext); }; #endif 2）State.cpp #include \"State.h\" #include <iostream> Context::Context(State* pState) 　　　 : m_pState(pState) { } Context::~Context() { 　　　 delete m_pState; 　　　 m_pState = NULL; } void Context::Request() { 　　　 if (NULL != m_pState) 　　　 { 　　　　　　　 m_pState->Handle(this); 　　　 } } void Context::ChangeState(State *pState) { 　　　 if (NULL != m_pState) 　　　 { 　　　　　　　 delete m_pState; 　　　　　　　 m_pState = NULL; 　　　 } 　　　 　　　 m_pState = pState; } void ConcreateStateA::Handle(Context* pContext) { 　　　 std::cout << \"Handle by ConcreateStateAn\"; 　　　 　　　 if (NULL != pContext) 　　　 { 　　　　　　　 pContext->ChangeState(new ConcreateStateB()); 　　　 } } void ConcreateStateB::Handle(Context* pContext) { 　　　 std::cout << \"Handle by ConcreateStateBn\"; 　　　 if (NULL != pContext) 　　　 { 　　　　　　　 pContext->ChangeState(new ConcreateStateA()); 　　　 } }     3）Main.cpp #include \"State.h\" int main() { 　　　 State *pState = new ConcreateStateA(); 　　　 Context *pContext = new Context(pState); 　　　 pContext->Request(); 　　　 pContext->Request(); 　　　 pContext->Request(); 　　　 delete pContext; 　　　 return 0; }  ","title":"设计模式的解析和实现(C++)之十七-State模式"},{"content":"前言 之前我们已经将前两种类型的设计模式都已经悉数介绍完呢（创建型和结构型），希望此时大家能够对它们有一个全新的认识，不仅加深对各个模式的理论理解，更需要在日常开发活动中实践之，这样才能真正做到对模式的融会贯通。模式的学习和领悟需要一个过程，不可能一蹴而就，更不可高开低走，需要大家静下心来扎实地一步步学习和提高。从今天开始，我们将继续完成最后一种类型的设计模式——行为型模式的介绍和学习，所谓的行为型模式实际上涉及到算法和对象间职责的分配问题，行为型模式不仅是描述对象或者类的模式，还描述它们之间的通信模式。这些模式扁鹊了在运行时刻难以跟踪的复杂控制流，将你的注意力从控制流转移到对象间的联系方式上来。同时行为型模式可分为行为类模式和行为对象模式两种，前者是使用继承机制在类间分派行为，后者是使用对象组合的方式来完成行为的分派。本文将对第一个行为型模式——职责链模式进行深入的介绍和学习，开始我们对行为型模式的探索之旅吧！ 动机 在实际的软件系统开发中，有时我们会面临需要将操作请求转发到一系列接收者对象组成的链式结构情况，之所以是一系列接收者而不是单个接收者是因为操作请求者并不知道清楚当前请求将交由具体某个接收者来完成，而每个接收者能够处理的请求操作是有限度的，不可能面面俱到。面对一特定操作请求，它要么能够完全处理，完成对操作请求的相关任务，要么就只能向下传递给它认为可以胜任当前操作请求的下一个请求接收者对象，由其继续完成当前操作请求任务。试想一下，如果我们事先不能构建这样一条接收请求对象链，那么在客户端我们将不得不直接与处理特定请求的接收者打交道，这不仅增加了用户程序对请求接收者的使用难度，而且也势必造成两者的紧耦合关系。上述场景便是职责链模式擅长之地，在职责链模式里，若干对象由每一个对象对其下家的引用而连接起来形成请求处理链，请求将从该链头依次向链尾传递，直到遇到能够完全处理当前请求的接收者对象，此时才会结束请求向下传递过程。而请求的发出者并不知道当前链中哪个对象能够处理当前请求，这样系统就可以在不影响客户端的情况下动态地重新组织和分配职责，从而也就将具体操作请求与系列请求接收者解耦开来。接下来，让我们深入地学习职责链模式，尽量做到了然于胸吧。 意图 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 结构图 抽象处理者（Handler）角色：定义职责的接口，也就是在这里定义处理请求的方法，亦可以在这里实现后继链。 具体处理者（ConcreteHandler）角色：实现职责的类，在这个类中，实现对在它职责范围内请求的处理，如果处理不了，就继续转发请求给后继者。 客户端（client）角色：职责链的客户端，向链上的具体处理驍提交请求，让职责链负责处理。 代码示例     public abstract class Handler{       protected Handler successor;       public void SetSuccessor(Handler handler){           this.successor=successor;       }           public abstract void handleRequest(String request);   }      public class ConcreteHandler1 extends Handler{      public void handleRequest(String request){             //需要某些条件来判断当前请求是否为自己所能处理的范围，这里只是简单说明下          boolean someCondition=false;          if(someCondition){              System.out.println(\"ConcreteHandler1  handle request\"+request);          }else {              if(successor!=null){                  //既然当前处理器不能处理请求，那么就直接将当前请求传递给它直接后继处理器，由其继续处理                  successor.handleRequest(request);              }          }      }  }     public class ConcreteHandler2 extends Handler{      public void handleRequest(String request){          boolean someCondition=false;          if(someCondition){              System.out.println(\"ConcreteHandler2  handle request\"+request);          }else {              if(successor!=null){                  successor.handleRequest(request);              }else {                  System.out.println(\"当前请求不能被所有处理者处理！\");              }          }      }  }     public class Client{      public static void main(String[] args){          ConcreteHandler1 handler1=new ConcreteHandler1();          ConcreteHandler2 handler2=new ConcreteHandler2();             handler1.SetSuccessor(handler2);          handler2.SetSuccessor(null);             handler1.handleRequest(\"just for test\");                  }  }  从示例代码中，我们可以大致清楚地明白职责链模式的实现方式，如果大家还记得之前我们介绍过的设计模式，应该对这段代码会感觉似曾相识，还记得装饰模式的示例程序吗？首先，我们通过定义完成职责的统一接口，即Handler类，在其中，我们不仅定义了完成职责的接口，而且也保存着其后继处理器引用句柄，目的就是当当前处理器无法处理当前请求操作时，交给这个后继处理器来处理，完成对请求传递过程，而不是停止于自己，让有能力负责的处理器来完成对请求的处理工作。而具体的处理器ConcreteHandler1和ConcreteHandler2都是实现了自己处理请求的业务逻辑功能，也就是hanlerRequest方法。而在客户端，我们根据业务需求将不同的具体处理器形成链式结构，然后直接将操作请求放置到处理链上进行处理即可，这样一来，客户端只需要知道职责链的第一个处理对象即可，因为需要通过它将操作请求传递到职责链中。当然，客户端也并不知道当前请求将由哪一个具体处理器接受处理，理想情况是不需要知道的。在这里，需要提醒一点是，虽然职责链在示例代码中是由客户端直接构建生成的，但是也完全可以由不同的情景上下文对象根据实际的业务要求来生成不同处理能力的职责链，直接交由客户端使用，而不需要客户端负责对职责链的创建工作。 在实际的职责链模式实现里，请求不一定会被处理，因为可能没有合适的处理者，请求在职责链中从头传到尾，每个处理对象判断不属于自己处理，最后请求就没有对象来处理，这一点需要明白。再者就是，在职责链模式里有纯与不不纯之说，所谓“纯”职责链模式，就是对于链上的每一个处理对象，要么能有能力直接处理请求，结束请求在职责链上的传递，要么就直接将请求原封不动地直接传递其后继处理对象处理，而不能既对请求做部分操作又将部分处理过的请求传递给后继处理对象。但是话虽如此，在现实的应用场景中，很难出现如此“纯”的职责链模式，所以还是只能看到“不纯”的职责链实现。 现实场景 在现实的生活场景中，其实也不乏职责链模式原型的例子。比如企业里的费用报销活动就是一个比较鲜活的实例，一般来说，对于较小金额的费用报销通过自己直系领导就可以获得批准报销，但是当报销费用金额变大时，直系领导就无权做决定呢，需要将该报销请求传递到其直系领导上呢，就这样，随着报销费用金额的不断加大，报销请求也就必将会依次传递到具有对当前报销费用做决定的领导身上。当然，在这一链上的任一领导都有权利直接否决该报销请求，也就是不将该报销请求继续往其直系领导传递呢，这也是真实场景可以发生的事情。但是不管最终哪一层级的领导有能力处理当前报销请求，作为报销人一开始只能将该报销请求传递给其直系领导，然后由他来决定是否需要将请求传递到更加层级的领导中，否则就是越级上报呢，现实中一般是不允许出现这样的操作流程的：）。说到这里，结合我们刚刚对职责链模式的介绍和示例代码，大家应该能够将上述场景出现的人、物与职责链模式中出现的角色一一对应了。首先，报销请求者就是client，而报销的费用就是request,而各个层级的领导就是各个具体的hanler对象，而企业中规定好各个层级领导所应具有的职权范畴，同时各个层级领导之间的上下级关系也是早已规定确定下来，也就是说自然形成了一个无形的职责链。下面我们就通过代码来演绎下上述场景吧!    public abstract class Leader{       protected Leader successor;       public void SetSuccessor(Leader handler){           this.successor=successor;       }           public abstract void handleRequest(long fee);   }      public class Manager extends Leader{      public void handleRequest(long fee){          if(fee<1000){              //当报销费用小于一千时，经理有权力来决定批准不批准，而无需上报上级领导              //下面只是简单示意一下，现在情况下是可以批或者不批：）              System.out.println(\"批准或者不批准当前报销费用\"+fee);          }else {              if(successor!=null){                  //如果当前报销费用金额已经超过经理能够处理的范围应该直接将该报销请求传递到后继领导进行处理，                  //在这里，也就是总经理呢。                  successor.handleRequest(fee);              }          }      }  }     public class President extends Leader{      public void handleRequest(long fee){          if(fee<10000){              //当报销费用小于一万时，总经理有权力来决定批准不批准              //下面只是简单示意一下，现在情况下是可以批或者不批：）              System.out.println(\"批准或者不批准当前报销费用\"+fee);          }else {              System.out.println(\"超过公司报销费用上限，直接否决：)\");              }          }      }  }     public class Client{      public static void main(String[] args){          Manager manager=new Manager();              President president=new President();             manager.SetSuccessor(president);          president.SetSuccessor(null);             manager.handleRequest(500);          manager.handleRequest(5000);              }  }  通过结构图来表示如下： 由经理和总经理构成的链式结构简单表示如下： 通过上图能直观地说明了经理是职责链的入口点，而总经理是职责链的最后处理者，如果它都无法处理，那该请求也只能原样返回或者直接废弃呢。但是对费用报销者来说，他并不清楚当前报销费用请求最终将被哪一层级领导处理，因为他本身并不需要知道哪一层级领导具有什么职能，并且现实情况下，他也只能将报销请求交由其直系领导来处理，而不能越级上报：） 另外，熟悉java web开发的朋友对jsp 中的过滤器Filter肯定不会陌生，我们可以定义多个不同功能的过滤器，在web.xml文件中配置和确定各个过滤器的执行过滤操作的先后顺序，形成一个过滤链。这样，从前台传递到后台的请求都必须依次通过当前过滤器链上的各个过滤器的过滤功能呢，最后请求才能进入到servlet中进行处理。从这点来说，过滤器链就是职责链模式的一种变形实现。 实现要点 实现后继者链：有两种方法可以实现后继者链，一个是定义新的链接，也就是通过Handler来定义，示例代码就是采用这种方式来完成；另一个是使用已有的链接，当已有的链接能够支持所需要的功能时，完全可以复用它们，而不需要额外重新定义新的职责链。 连接后继者：如有没有已有的引用可定义一个链，那么必须自己引入它们。这样，在Handler里，不仅要定义请求的接口，还需要维护后继链接，通过ConcreteHandler默认情况下直接将请求转发给后继者。 表示请求：一个请求可以是原始类型，亦可以是复杂的对象，具体情况需要根据实际情况作决定。 运用效果 降低耦合度：职责链模式便利一个对象无需知道是由哪个处理器对象来处理其请求，对象只需知道该请求会被“正解”处理。接收者和发送者都没有对方明确的信息，同时链中的对象无需知道链式结构。 增强了给对象指派职责的灵活性：可以通过在运行时刻对职责链进行动态的增加或者修改来增加或者改变处理一个请求的那些职责，也就是说可以对链中的任意处理对象进行修改，以满足实际需要。 不保证被接受：既然一个请求没有明确的接收者，也就不能保证请求一定会被处理，完全有可能请求到链的末端都得到不相应的处理对象的处理，当然我们可以对这种请求最终不能被处理情况定义一种默认的终结方式。 产生较多细粒度的对象：职责链会把功能处理分散到单独的职责对象中，也就是一个职责对象只会完成一种职责，在实现的业务处理过程中，需要很多的职责对象的组合，这样也就不可避免地会产生较多细粒度的职责对象。 适用性 如果有多个对象可以处理同一个请求，但是具体由哪个对象来处理该请求，是运行时刻动态决定的的。这种情况使用职责链模式，把处理请求的对象实现为职责对象，再将它们构成一个职责链，当请求在这个链中传递的时候，具体由哪个职责对象来处理，在运行时刻进行判断。 在不明确指定接收者的情况下，向多个对象中的其中一个提交请求。职责链模式将请求者与接收者之间解耦，请求者不需要知道究竟是哪一个接收者对象处理了请求。 需要动态地指定处理一个请求的对象集合时。职责链模式能动态地构建职责链，也就动态决定哪些职责对象参与到处理请求中来，这也就相当于动态地指定了处理一个请求的职责对象集合。 相关模式 职责链模式与组合模式：两者可以组合使用。可以把各个职责对象通过组合模式来组合，这样就可以通过组合对象自动递归地向上调用，由父组件作为子组件的后继，从而形成链结构。 职责链模式与装饰模式：两者本质相似，都需要在运行期间动态组合，装饰模式是动态组合装饰器，而职责链是动态组合处理请求的职责对象链。同时两者可以相互模拟实现对方的功能，装饰模式能够动态地给被装饰对象添加功能，要求装饰对象与被装饰对象拥有相同的接口，而职责链模式可以实现动态的职责组合，标准的功能是有一个接收者处理了请求就结束，但是职责对象完成本职责后不急于结束，而是继续往下传递请求的话，其功能与装饰模式的功能就差不多呢。当然，从目的上来说，两者还是具有很大不同的，装饰模式是要实现透明的为对象添加功能，而职责链模式是要实现发送者和接收者解耦，另外装饰模式可以无限递归调用，而职责链是有一个处理就结束。 职责链模式与策略模式：两者可以组合使用。可以在职责链械的某个职责实现的时候，使用策略模式来选择具体的实现，两样也可以在策略模式的某个策略袖中，使用职责链模式来实现功能处理，同理职责链械与可以与状态模式组合使用，详情说明将在后续文章中提及。 总结 职责模式的本质是：分离职责，动态组合。分离职责是前提，只有先把复杂的功能分开，拆分成各个小功能，然后才能合理规划和定义职责类；而动态组合才是职责链模式的精华所在，因为要实现请求对象和处理对象的解耦，请求对象并不知道最终的处理对象，所以需要动态地将可能的处理对象组合进来，也正因为组合是动态的，所以可以很方便地修改和增加亲的处理对象，从而使系统具有更好的灵活性和扩展性。另外，由于职责对象只完成一种职责，粒度较小，可以在多个不同功能的职责链中进行复用，增强职责功能的复用性。对职责链模式的介绍就至此为此吧，下一篇将继续讲述另一个行为型模式——命令模式，敬请期待！ 参考资料： 程杰著《大话设计模式》一书 陈臣等著《研磨设计模式》一书 GOF著《设计模式》一书 Terrylee .Net设计模式系列文章 吕震宇老师 设计模式系列文章 转载自：http://www.cnblogs.com/JackyTecblog/archive/2012/11/03/2752875.html","title":"设计模式(9) ------------职责链模式"},{"content":"设计模式概要         设计模式，顾名思义，它是一种模式，在面向对象中，它运用类与它们的方法来达到目标。使用它便于代码的可重用和可读性，有利于系统的维护。《Design pattern》一书中首次提出了23种设计模式，倘若你想成为编程高手，就必须要学习设计模式。         以下列出《Design pattern》一书中描述的23种设计模式，它们分别是： 1、适配器模式 2、外观模式 3、合成模式 4、桥接模式 5、单例模式 6、观察者模式 7、调停者模式 8、代理模式 9、责任链模式 10、享元模式 11、构建者模式 12、工厂方法模式 13、抽象工厂模式 14、原型模式 15、备忘录模式 16、模板方法模式 17、状态模式 18、策略模式 19、命令模式 20、解释器模式 21、装饰器模式 22、迭代器模式 23、访问者模式 以下分别介绍这23种设计模式 一、适配器模式         所谓适配器模式，是指将一个类适配成用户所期待的，它通常分为两大类：类适配器和对象适配器。         类适配器         这种适配器模式下，适配器继承自已实现的类（一般多重继承）。       具体来说，我们需要实现目标接口，并继承自现有类，来达到用户所期望的效果。具体实现如下：     package cn.com.pattern;            //目标抽象角色，用户需要的是有圆形的usb接口      public interface Target {          public void provideCircleUsb();      }      package cn.com.pattern;      //源角色，这里是指提供方形的usb接口      public class Adaptee {          public void provideSquareUsb(){              System.out.println(\"我提供方形的USB接口\");          }      }      package cn.com.pattern;      //适配角色，这里指老板买给我们的那个转换器      public class Adapter extends Adaptee implements Target{          @Override          //转换器将圆形的接口转换为方形接口          public void provideCircleUsb() {              this.provideSquareUsb();          }      }      package cn.com.pattern;            //客户端，也就是问题中的键盘      public class Client {          public static void main(String[] args) {              Target target=new Adapter();              //键盘只能使用圆形的USB接口              target.provideCircleUsb();          }            }         对象适配器        在这种适配器模式中，适配器容纳一个它包裹的类的实例。在这种情况下，适配器调用被包裹对象的物理实体。当你需要适配的一组方法并非定义在接口中时，就可以创建一个对象适配器，采用对象方式实现： package cn.com.pattern;public class Adapter implements Target{         private Adaptee adptee；         public Adapter(Adaptee adptee){            this.adptee=adptee;            }                     @Override      //转换器将圆形的接口转换为方形接口      public void provideCircleUsb() {          adptee.provideSquareUsb();      }","title":"java23种设计模式一(连载)"},{"content":"作用：     定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。     UML结构图：     抽象基类：     1）Product：创建出来的对象的抽象基类。     2）Factory创建对象的工厂方法的抽象基类。     接口函数：     1）Creator：：FactoryMethod：纯虚函数，由派生类实现，创建出对应的Product.     解析：     在这个模式中，有两个抽象基类，一个是Product为创建出来的对象的抽象基类，一个是Factory是工厂的抽象基类，在互相协作的时候都是由相应的Factory派生类来生成Product的派生类，也就是说如果要新增一种Product那么也要对应的新增一个Factory，创建的过程委托给了这个Factory.也就是说一个Factory和一个Product是一一对应的关系。     备注：     设计模式的演示图上把Factory类命名为Creator，下面的实现沿用了这个命名。     演示实现：     1）Factory.h #ifndef FACTORY_H #define FACTORY_H class Product { public: 　　　 Product(){} 　　　 virtual ~Product(){} }; class ConcreateProduct 　　　 : public Product { public: 　　　 ConcreateProduct(); 　　　 virtual ~ConcreateProduct(); }; class Creator { public: 　　　 Creator(){} 　　　 virtual ~Creator(){} 　　　 void AnOperation(); protected: 　　　 virtual Product* FactoryMethod() = 0; }; class ConcreateCreator 　　　 : public Creator { public: 　　　 ConcreateCreator(); 　　　 virtual ~ConcreateCreator(); protected: 　　　 virtual Product* FactoryMethod(); }; #endif  2）Factory.cpp #include \"Factory.h\" #include <iostream> using namespace std; ConcreateProduct::ConcreateProduct() { 　　　 std::cout << \"construction of ConcreateProductn\"; } ConcreateProduct::~ConcreateProduct() { 　　　 std::cout << \"destruction of ConcreateProductn\"; } void Creator::AnOperation() { 　　　 Product* p = FactoryMethod(); 　　　 std::cout << \"an operation of productn\"; } ConcreateCreator::ConcreateCreator() { 　　　 std::cout << \"construction of ConcreateCreatorn\"; } ConcreateCreator::~ConcreateCreator() { 　　　 std::cout << \"destruction of ConcreateCreatorn\"; } Product* ConcreateCreator::FactoryMethod() { 　　　 return new ConcreateProduct(); }   3）Main.cpp（测试代码） #include \"Factory.h\" #include <stdlib.h> int main(int argc,char* argv[]) { 　　　 Creator *p = new ConcreateCreator(); 　　　 p->AnOperation(); 　　　 delete p; 　　　 system(\"pause\"); 　　　 return 0; } 　","title":"设计模式的解析和实现(C++)之一-Factory模式"},{"content":"作用：     提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。     UML结构图：     抽象基类：     1）ProductA，ProductB：分别代表不同类型的产品，而它们的派生类则是这种产品的一个实现。     2）AbstractFactory：生产这一系列产品的一个抽象工厂，它的派生类是不同的实现。     接口函数：     1）AbstractFactory：：CreateProductA和AbstractFactory：：CreateProductB：分别是生产不同产品的不同的实现，由各个派生出来的抽象工厂实现之。     解析：     Abstract Factory模式和Factory最大的差别就是抽象工厂创建的是一系列相关的对象，其中创建的实现其实采用的就是Factory模式的方法，对于某个实现的有一个派生出来的抽象工厂，另一个实现有另一个派生出来的工厂，等等。     可以举一个简单的例子来解释这个模式：比如，同样是鸡腿（ProductA）和汉堡（ProductB），它们都可以有商店出售（AbstractFactory），但是有不同的实现，有肯德基（ConcreateFactory1）和麦当劳（ConcreateFactory2）两家生产出来的不同风味的鸡腿和汉堡（也就是ProductA和ProductB的不同实现）。     而负责生产汉堡和鸡腿的就是之前提过的Factory模式了。     抽象工厂需要特别注意的地方就是区分不同类型的产品和这些产品的不同实现。显而易见的，如果有n种产品同时有m中不同的实现，那么根据乘法原理可知有n*m个Factory模式的使用。 实现：     1）AbstractFactory.h #ifndef ABSTRACTFACTORY_H #define ABSTRACTFACTORY_H // 抽象基类AbstractProductA,代表产品A的抽象 class AbstractProductA { public: 　　　 AbstractProductA() {} 　　　 virtual ~AbstractProductA(){}; }; // 派生类ConcreateProductA1,继承自AbstractProductA,代表产品A的第一种实现 class ConcreateProductA1 　　　 : public AbstractProductA { public: 　　　 ConcreateProductA1(); 　　　 virtual ~ConcreateProductA1(); }; // 派生类ConcreateProductA2,继承自AbstractProductA,代表产品A的第二种实现 class ConcreateProductA2 　　　 : public AbstractProductA { public: 　　　 ConcreateProductA2(); 　　　 virtual ~ConcreateProductA2(); }; // 抽象基类AbstractProductB,代表产品B的抽象 class AbstractProductB { public: 　　　 AbstractProductB() {} 　　　 virtual ~AbstractProductB(){}; }; // 派生类ConcreateProductB1,继承自AbstractProductB,代表产品B的第一种实现 class ConcreateProductB1 　　　 : public AbstractProductB { public: 　　　 ConcreateProductB1(); 　　　 virtual ~ConcreateProductB1(); }; // 派生类ConcreateProductB2,继承自AbstractProductB,代表产品B的第二种实现 class ConcreateProductB2 　　　 : public AbstractProductB { public: 　　　 ConcreateProductB2(); 　　　 virtual ~ConcreateProductB2(); }; // 抽象基类AbstractFactory,工厂的抽象类,生产产品A和产品B class AbstractFactory { public: 　　　 AbstractFactory(){} 　　　 virtual ~AbstractFactory(){} 　　　 virtual AbstractProductA* CreateProductA() = 0; 　　　 virtual AbstractProductB* CreateProductB() = 0; }; // 派生类ConcreateFactory1,继承自AbstractFactory // 生产产品A和产品B的第一种实现 class ConcreateFactory1 　　　 : public AbstractFactory { public: 　　　 ConcreateFactory1(); 　　　 virtual ~ConcreateFactory1(); 　　　 virtual AbstractProductA* CreateProductA(); 　　　 virtual AbstractProductB* CreateProductB(); }; // 派生类ConcreateFactory2,继承自AbstractFactory // 生产产品A和产品B的第二种实现 class ConcreateFactory2 　　　 : public AbstractFactory { public: 　　　 ConcreateFactory2(); 　　　 virtual ~ConcreateFactory2(); 　　　 virtual AbstractProductA* CreateProductA(); 　　　 virtual AbstractProductB* CreateProductB(); }; #endif  2）AbstractFactory.cpp #include <iostream> #include \"AbstractFactory.h\" ConcreateProductA1::ConcreateProductA1() { 　　　 std::cout << \"construction of ConcreateProductA1n\"; } ConcreateProductA1::~ConcreateProductA1() { 　　　 std::cout << \"destruction of ConcreateProductA1n\"; } ConcreateProductA2::ConcreateProductA2() { 　　　 std::cout << \"construction of ConcreateProductA2n\"; } ConcreateProductA2::~ConcreateProductA2() { 　　　 std::cout << \"destruction of ConcreateProductA2n\"; } ConcreateProductB1::ConcreateProductB1() { 　　　 std::cout << \"construction of ConcreateProductB1n\"; } ConcreateProductB1::~ConcreateProductB1() { 　　　 std::cout << \"destruction of ConcreateProductB1n\"; } ConcreateProductB2::ConcreateProductB2() { 　　　 std::cout << \"construction of ConcreateProductB2n\"; } ConcreateProductB2::~ConcreateProductB2() { 　　　 std::cout << \"destruction of ConcreateProductB2n\"; } ConcreateFactory1::ConcreateFactory1() { 　　　 std::cout << \"construction of ConcreateFactory1n\"; } ConcreateFactory1::~ConcreateFactory1() { 　　　 std::cout << \"destruction of ConcreateFactory1n\"; } AbstractProductA* ConcreateFactory1::CreateProductA() { 　　　 return new ConcreateProductA1(); } AbstractProductB* ConcreateFactory1::CreateProductB() { 　　　 return new ConcreateProductB1(); } ConcreateFactory2::ConcreateFactory2() { 　　　 std::cout << \"construction of ConcreateFactory2n\"; } ConcreateFactory2::~ConcreateFactory2() { 　　　 std::cout << \"destruction of ConcreateFactory2n\"; } AbstractProductA* ConcreateFactory2::CreateProductA() { 　　　 return new ConcreateProductA2(); } AbstractProductB* ConcreateFactory2::CreateProductB() { 　　　 return new ConcreateProductB2(); }  3）Main.cpp（测试代码） #include \"AbstractFactory.h\" #include <stdlib.h> int main() { 　　　 // 生产产品A的第一种实现 　　　 ConcreateFactory1 *pFactory1 = new ConcreateFactory1; 　　　 AbstractProductA *pProductA = pFactory1->CreateProductA(); 　　　 // 生产产品B的第二种实现 　　　 ConcreateFactory2 *pFactory2 = new ConcreateFactory2; 　　　 AbstractProductB *pProductB = pFactory2->CreateProductB(); 　　　 delete pFactory1; 　　　 delete pProductA; 　　　 delete pFactory2; 　　　 delete pProductB; 　　　 system(\"pause\"); 　　　 return 0; }  ","title":"设计模式解析和实现之二-Abstract Factory模式"},{"content":"作用：     将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。     UML结构图：     适用于以下情况：     1）当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。     2）当构造过程必须允许被构造的对象有不同的表示时。     抽象基类：     1）Builder：这个基类是全部创建对象过程的抽象，提供构建不同组成部分的接口函数     接口：     1）Builder：：BuildPartA，Builder：：BuildPartB：是对一个对象不同部分的构建函数接口，Builder的派生类来具体实现。     另外还有一个需要注意的函数，就是Director：：Construct函数，这个函数里面通过调用上面的两个接口函数完成对象的构建——也就是说各个不同部分装配的过程都是一致的（同样的调用的Construct函数），但是不同的构建方式会有不同的表示（根据Builder的实际类型来决定如何构建，也就是多态）     解析：     Builder模式是基于这样的一个情况：一个对象可能有不同的组成部分，这几个部分的不同的创建对象会有不同的表示，但是各个部分之间装配的方式是一致的。比方说一辆单车，都是由车轮车座等等的构成的（一个对象不同的组成部分），不同的品牌生产出来的也不一样（不同的构建方式）。虽然不同的品牌构建出来的单车不同，但是构建的过程还是一样的（哦，你见过车轮长在车座上的么？）。 也就是说，Director：：Construct函数中固定了各个组成部分的装配方式，而具体是装配怎样的组成部分由Builder的派生类实现。     实现：     Builder模式的实现基于以下几个面向对象的设计原则：1）把变化的部分提取出来形成一个基类和对应的接口函数，在这里不会变化的是都会创建PartA和PartB，变化的则是不同的创建方法，于是就抽取出这里的Builder基类和BuildPartA，BuildPartB接口函数 2）采用聚合的方式聚合了会发生变化的基类，就是这里Director聚合了Builder类的指针。     1）Builder.h #ifndef BUILDER_H 　#define　 BUILDER_H 　 　//　 虚拟基类,是所有Builder的基类,提供不同部分的构建接口函数 　class　 Builder 　 { 　public : 　　　 Builder()　 {} ; 　　　　 virtual　　 ~ Builder()　 {} 　 　　　　 //　 纯虚函数,提供构建不同部分的构建接口函数 　　　　　 virtual　　 void　 BuilderPartA()　 =　　 0 ; 　　　　 virtual　　 void　 BuilderPartB()　 =　　 0 ; } ; 　//　 使用Builder构建产品,构建产品的过程都一致,但是不同的builder有不同的实现 　//　 这个不同的实现通过不同的Builder派生类来实现,存有一个Builder的指针,通过这个来实现多态调用 　class　 Director 　 { 　public : 　　　 Director(Builder *　 pBuilder); 　　　　 ~ Director(); 　　　　 void　 Construct(); 　private : 　　　 Builder *　 m_pBuilder; } ; 　//　 Builder的派生类,实现BuilderPartA和BuilderPartB接口函数 　class　 ConcreateBuilder1 　　　 :　 public　 Builder 　 { 　public : 　　　 ConcreateBuilder1()　 {} 　　　　　 virtual　　 ~ ConcreateBuilder1()　 {} 　 　　　　 virtual　　 void　 BuilderPartA(); 　　　　 virtual　　 void　 BuilderPartB(); } ; 　//　 Builder的派生类,实现BuilderPartA和BuilderPartB接口函数 　class　 ConcreateBuilder2 　　　 :　 public　 Builder 　 { 　public : 　　　 ConcreateBuilder2()　 {} 　　　　　 virtual　　 ~ ConcreateBuilder2()　 {} 　 　　　　 virtual　　 void　 BuilderPartA(); 　　　　 virtual　　 void　 BuilderPartB(); } ; 　#endif 2）Builder.cpp #include　 \" Builder.h \" #include　 < iostream > 　 　void　 ConcreateBuilder1::BuilderPartA() 　 { 　　　 std::cout　 <<　　 \" BuilderPartA by ConcreateBuilder1n \" ; } 　 　void　 ConcreateBuilder1::BuilderPartB() 　 { 　　　 std::cout　 <<　　 \" BuilderPartB by ConcreateBuilder1n \" ; } 　 　void　 ConcreateBuilder2::BuilderPartA() 　 { 　　　 std::cout　 <<　　 \" BuilderPartA by ConcreateBuilder2n \" ; } 　 　void　 ConcreateBuilder2::BuilderPartB() 　 { 　　　 std::cout　 <<　　 \" BuilderPartB by ConcreateBuilder2n \" ; } 　 Director::Director(Builder *　 pBuilder) 　　　 : m_pBuilder(pBuilder) 　 { } 　 Director:: ~ Director() 　 { 　　　 delete m_pBuilder; 　　　 m_pBuilder　 =　 NULL; } 　 　//　 Construct函数表示一个对象的整个构建过程,不同的部分之间的装配方式都是一致的, 　//　 首先构建PartA其次是PartB,只是根据不同的构建者会有不同的表示 　void　 Director::Construct() 　 { 　　　 m_pBuilder -> BuilderPartA(); 　　　 m_pBuilder -> BuilderPartB(); } 3）Main.cpp #include　 \" Builder.h \" #include　 < stdlib.h > 　 　int　 main() 　 { 　　　 Builder *　 pBuilder1　 =　　 new　 ConcreateBuilder1; 　　　 Director　 * pDirector1　 =　　 new　 Director(pBuilder1); 　　　 pDirector1 -> Construct(); 　　　 Builder *　 pBuilder2　 =　　 new　 ConcreateBuilder2; 　　　 Director　 * pDirector2　 =　　 new　 Director(pBuilder2); 　　　 pDirector2 -> Construct(); 　　　 delete pDirector1; 　　　 delete pDirector2; 　　　 system( \" pause \" ); 　　　　 return　　 0 ; }","title":"设计模式的解析和实现(C++)之三-Builder模式"},{"content":"作用：     用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。     UML结构图：     抽象基类：     1）Prototype：虚拟基类，所有原型的基类，提供Clone接口函数     接口函数：     1）Prototype：：Clone函数：纯虚函数，根据不同的派生类来实例化创建对象。     解析：     Prototype模式其实就是常说的\"虚拟构造函数\"一个实现，C++的实现机制中并没有支持这个特性，但是通过不同派生类实现的Clone接口函数可以完成与\"虚拟构造函数\"同样的效果。举一个例子来解释这个模式的作用，假设有一家店铺是配钥匙的，他对外提供配制钥匙的服务（提供Clone接口函数），你需要配什么钥匙它不知道只是提供这种服务，具体需要配什么钥匙只有到了真正看到钥匙的原型才能配好。也就是说，需要一个提供这个服务的对象，同时还需要一个原型（Prototype），不然不知道该配什么样的钥匙。     实现：     1）Prototype.h #ifndef PROTOTYPE_H #define PROTOTYPE_H // 虚拟基类,所有原型的基类,提供Clone接口函数 class Prototype { public: 　　　 Prototype(){} 　　　 virtual ~Prototype(){} 　　　 virtual Prototype* Clone() = 0; }; // 派生自Prototype,实现Clone方法 class ConcreatePrototype1 　　　 : public Prototype { public: 　　　 ConcreatePrototype1(); 　　　 ConcreatePrototype1(const ConcreatePrototype1&); 　　　 virtual ~ConcreatePrototype1(); 　　　 virtual Prototype* Clone(); }; // 派生自Prototype,实现Clone方法 class ConcreatePrototype2 　　　 : public Prototype { public: 　　　 ConcreatePrototype2(); 　　　 ConcreatePrototype2(const ConcreatePrototype2&); 　　　 virtual ~ConcreatePrototype2(); 　　　 virtual Prototype* Clone(); }; #endif 2）Prototype.cpp #include \"Prototype.h\" #include <iostream> ConcreatePrototype1::ConcreatePrototype1() { 　　　 std::cout << \"construction of ConcreatePrototype1n\"; } ConcreatePrototype1::~ConcreatePrototype1() { 　　　 std::cout << \"destruction of ConcreatePrototype1n\"; } ConcreatePrototype1::ConcreatePrototype1(const ConcreatePrototype1&) { 　　　 std::cout << \"copy construction of ConcreatePrototype1n\"; } Prototype* ConcreatePrototype1::Clone() { 　　　 return new ConcreatePrototype1(*this); } ConcreatePrototype2::ConcreatePrototype2() { 　　　 std::cout << \"construction of ConcreatePrototype2n\"; } ConcreatePrototype2::~ConcreatePrototype2() { 　　　 std::cout << \"destruction of ConcreatePrototype2n\"; } ConcreatePrototype2::ConcreatePrototype2(const ConcreatePrototype2&) { 　　　 std::cout << \"copy construction of ConcreatePrototype2n\"; } Prototype* ConcreatePrototype2::Clone() { 　　　 return new ConcreatePrototype2(*this); }  3）Main.cpp #include \"Prototype.h\" #include <stdlib.h> int main() { 　　　 Prototype* pPrototype1 = new ConcreatePrototype1(); 　　　 Prototype* pPrototype2 = pPrototype1->Clone(); 　　　 Prototype* pPrototype3 = new ConcreatePrototype2(); 　　　 Prototype* pPrototype4 = pPrototype3->Clone(); 　　　 delete pPrototype1; 　　　 delete pPrototype2; 　　　 delete pPrototype3; 　　　 delete pPrototype4; 　　　 system(\"pause\"); 　　　 return 0; }","title":"设计模式的解析和实现(C++)之四-Prototype模式"},{"content":"作用：保证一个类仅有一个实例，并提供一个访问它的全局访问点。     UML结构图：     解析：     Singleton模式其实是对全局静态变量的一个取代策略，上面提到的Singleton模式的两个作用在C++中是通过如下的机制实现的：1）仅有一个实例，提供一个类的静态成员变量，大家知道类的静态成员变量对于一个类的所有对象而言是惟一的 2）提供一个访问它的全局访问点，也就是提供对应的访问这个静态成员变量的静态成员函数，对类的所有对象而言也是惟一的。在C++中，可以直接使用类域进行访问而不必初始化一个类的对象。     下面的实现其实是Singleton的一个简单实现，并不是特别的通用，一般的，如果一个项目中需要使用到Singleton模式比较多的话，那么一般会实现一个Singleton的模板类，模板类的模板参数是需要采用Singleton模式的类，比如这样实现：  template<typename T> class Singleton { //.类的声明 }; // 需要采用singleton模式的类 class Test 　　 : public Singleton<Test> { // 类的声明 };     但是，下面的实现还是采用最简单的实现办法，起的是演示的作用     实现：     1）Singleton.h #ifndef SINGLETON_H #define SINGLETON_H class Singleton { public: 　　　 Singleton(){}; 　　　 ~Singleton(){}; 　　　 // 静态成员函数,提供全局访问的接口 　　　 static Singleton* GetInstancePtr(); 　　　 static Singleton　 GetInstance(); 　　　 void Test(); private: 　　　 // 静态成员变量,提供全局惟一的一个实例 　　　 static Singleton* m_pStatic; }; #endif 2）Singleton.cpp #include \"Singleton.h\" #include <iostream> // 类的静态成员变量要在类体外进行定义 Singleton* Singleton::m_pStatic = NULL; Singleton* Singleton::GetInstancePtr() { 　　　 if (NULL == m_pStatic) 　　　 { 　　　　　　　 m_pStatic = new Singleton(); 　　　 } 　　　 return m_pStatic; } Singleton Singleton::GetInstance() { 　　　 return *GetInstancePtr(); } void Singleton::Test() { 　　　 std::cout << \"Test!n\"; }     3）Main.cpp #include \"Singleton.h\" #include <stdlib.h> int main() { 　　　 // 不用初始化类对象就可以访问了 　　　 Singleton::GetInstancePtr()->Test(); 　　　 Singleton::GetInstance().Test(); 　　　 system(\"pause\"); 　　　 return 0; }","title":"设计模式的解析和实现(C++)之五-Singleton模式"},{"content":"作用：     将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。     UML结构图：     抽象基类：     1）Component：为组合中的对象声明接口，声明了类共有接口的缺省行为（如这里的Add，Remove，GetChild函数），声明一个接口函数可以访问Component的子组件。     接口函数：     1）Component：：Operatation：定义了各个组件共有的行为接口，由各个组件的具体实现。     2）Component：：Add添加一个子组件     3）Component：：Remove：：删除一个子组件。     4）Component：：GetChild：获得子组件的指针。     解析：     Component模式是为解决组件之间的递归组合提供了解决的办法，它主要分为两个派生类，其中的Leaf是叶子结点，也就是不含有子组件的结点，而Composite是含有子组件的类。举一个例子来说明这个模式，在UI的设计中，最基本的控件是诸如Button，Edit这样的控件，相当于是这里的Leaf组件，而比较复杂的控件比如List则可也看做是由这些基本的组件组合起来的控件，相当于这里的Composite，它们之间有一些行为含义是相同的，比如在控件上作一个点击，移动操作等等的，这些都可以定义为抽象基类中的接口虚函数，由各个派生类去实现之，这些都会有的行为就是这里的Operation函数，而添加，删除等进行组件组合的操作只有非叶子结点才可能有，所以虚拟基类中只是提供接口而且默认的实现是什么都不做。 实现：     1）Composite.h #ifndef COMPOSITE_H #define COMPOSITE_H #include <list> // 组合中的抽象基类 class Component { public: 　　　 Component(){} 　　　 virtual ~Component(){} 　　　 // 纯虚函数,只提供接口,没有默认的实现 　　　 virtual void Operation() = 0; 　　　 // 虚函数,提供接口,有默认的实现就是什么都不做 　　　 virtual void Add(Component* pChild); 　　　 virtual void Remove(Component* pChild); 　　　 virtual Component* GetChild(int nIndex); }; // 派生自Component,是其中的叶子组件的基类 class Leaf 　　　 : public Component { public: 　　　 Leaf(){} 　　　 virtual ~Leaf(){} 　　　 virtual void Operation(); }; // 派生自Component,是其中的含有子件的组件的基类 class Composite 　　　 : public Component { public: 　　　 Composite(){} 　　　 virtual ~Composite(); 　　　 virtual void Operation(); 　　　 virtual void Add(Component* pChild); 　　　 virtual void Remove(Component* pChild); 　　　 virtual Component* GetChild(int nIndex); private: 　　　 // 采用list容器去保存子组件 　　　 std::list<Component*>　　　 m_ListOfComponent; }; #endif  2）Composite.cpp #include \"Composite.h\" #include <iostream> #include <algorithm> /**//*------------------------------------------------------------------- 　　　 Component成员函数的实现 　-------------------------------------------------------------------*/ void Component::Add(Component* pChild) { } void Component::Remove(Component* pChild) { } Component* Component::GetChild(int nIndex) { 　　　 return NULL; } /**//*------------------------------------------------------------------- 　　　 Leaf成员函数的实现 -------------------------------------------------------------------*/ void Leaf::Operation() { 　　　 std::cout << \"Operation by leafn\"; } /**//*------------------------------------------------------------------- 　　　 Composite成员函数的实现 -------------------------------------------------------------------*/ Composite::~Composite() { 　　　 std::list<Component*>::iterator iter1, iter2, temp; 　　　 for (iter1　 = m_ListOfComponent.begin(), iter2 = m_ListOfComponent.end(); 　　　　　　　　 iter1 != iter2; 　　　　　　　　 ) 　　　 { 　　　　　　　 temp = iter1; 　　　　　　　 ++iter1; 　　　　　　　 delete (*temp); 　　　 } } void Composite::Add(Component* pChild) { 　　　 m_ListOfComponent.push_back(pChild); } void Composite::Remove(Component* pChild) { 　　　 std::list<Component*>::iterator iter; 　　　 iter = find(m_ListOfComponent.begin(), m_ListOfComponent.end(), pChild); 　　　 if (m_ListOfComponent.end() != iter) 　　　 { 　　　　　　　 m_ListOfComponent.erase(iter); 　　　 } } Component* Composite::GetChild(int nIndex) { 　　　 if (nIndex <= 0 || nIndex > m_ListOfComponent.size()) 　　　　　　　 return NULL; 　　　 std::list<Component*>::iterator iter1, iter2; 　　　 int i; 　　　 for (i = 1, iter1　 = m_ListOfComponent.begin(), iter2 = m_ListOfComponent.end(); 　　　　　　　 iter1 != iter2; 　　　　　　　 ++iter1, ++i) 　　　 { 　　　　　　　 if (i == nIndex) 　　　　　　　　　　　 break; 　　　 } 　　　 return *iter1; } void Composite::Operation() { 　　　 std::cout << \"Operation by Compositen\"; 　　　 std::list<Component*>::iterator iter1, iter2; 　　　 for (iter1　 = m_ListOfComponent.begin(), iter2 = m_ListOfComponent.end(); 　　　　　　　 iter1 != iter2; 　　　　　　　 ++iter1) 　　　 { 　　　　　　　 (*iter1)->Operation(); 　　　 } }  3）Main.cpp #include \"Composite.h\" #include <stdlib.h> int main() { 　　　 Leaf *pLeaf1 = new Leaf(); 　　　 Leaf *pLeaf2 = new Leaf(); 　　　 Composite* pComposite = new Composite; 　　　 pComposite->Add(pLeaf1); 　　　 pComposite->Add(pLeaf2); 　　　 pComposite->Operation(); 　　　 pComposite->GetChild(2)->Operation(); 　　　 delete pComposite; 　　　 system(\"pause\"); 　　　 return 0; }","title":"设计模式解析和实现(C++)之八-Composite模式"},{"content":"作用：     动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator 模式相比生成子类更为灵活。     UML结构图：     抽象基类：     1）Component：定义一个对象接口，可以为这个接口动态的添加职责。     2）Decorator：维持一个指向Component的指针，并且有一个和Component一致的接口函数。     接口函数：     1）Component：：Operation：这个接口函数由Component声明，因此Component的派生类都需要实现，可以在这个接口函数的基础上给它动态添加职责。     解析：     Decorator的派生类可以为ConcreateComponent类的对象动态的添加职责，或者可以这么说：Decorator的派生类装饰ConcreateComponent类的对象。具体是这么实现的，首先初始化一个ConcreateComponent类的对象（被装饰者），采用这个对象去生成一个Decorator对象（装饰者），之后对Operation函数的调用则是对这个Decorator对象成员函数的多态调用。这里的实现要点是Decorator类和ConcreateComponent类都继承自Component，从而两者的接口函数是一致的；其次，Decorator维护了一个指向Component的指针，从而可以实现对Component：：Operation函数的动态调用。     实现：     1）Decorator.h #ifndef DECORATOR_H #define DECORATOR_H // 抽象基类,定义一个对象接口,可以为这个接口动态的添加职责. class Component { public: 　　　 Component(){} 　　　 virtual ~Component(){} 　　　 // 纯虚函数,由派生类实现 　　　 virtual void Operation() = 0; }; // 抽象基类,维护一个指向Component对象的指针 class Decorator 　　　 : public Component { public: 　　　 Decorator(Component* pComponent) : m_pComponent(pComponent){} 　　　 virtual ~Decorator(); protected: 　　　 Component* m_pComponent; }; // 派生自Component,在这里表示需要给它动态添加职责的类 class ConcreateComponent 　　　 : public Component { public: 　　　 ConcreateComponent(){} 　　　 virtual ~ConcreateComponent(){} 　　　 virtual void Operation(); }; // 派生自Decorator,这里代表为ConcreateComponent动态添加职责的类 class ConcreateDecorator 　　　 : public Decorator { public: 　　　 ConcreateDecorator(Component* pComponent) : Decorator(pComponent){} 　　　 virtual ~ConcreateDecorator(){} 　　　 virtual void Operation(); private: 　　　 void AddedBehavior(); }; #endif 2）Decorator.cpp #include \"Decorator.h\" #include <iostream> Decorator::~Decorator() { 　　　 delete m_pComponent; 　　　 m_pComponent = NULL; } void ConcreateComponent::Operation() { 　　　 std::cout << \"Operation of ConcreateComponentn\"; } void ConcreateDecorator::Operation() { 　　　 m_pComponent->Operation(); 　　　 AddedBehavior(); } void ConcreateDecorator::AddedBehavior() { 　　　 std::cout << \"AddedBehavior of ConcreateDecoratorn\"; }     3）Main.cpp #include \"Decorator.h\" #include <stdlib.h> int main() { 　　　 // 初始化一个Component对象 　　　 Component* pComponent = new ConcreateComponent(); 　　　 // 采用这个Component对象去初始化一个Decorator对象, 　　　 // 这样就可以为这个Component对象动态添加职责 　　　 Decorator* pDecorator = new ConcreateDecorator(pComponent); 　　　 pDecorator->Operation(); 　　　 delete pDecorator; 　　　 system(\"pause\"); 　　　 return 0; }     3）Main.cpp #include \"Decorator.h\" #include <stdlib.h> int main() { 　　　 // 初始化一个Component对象 　　　 Component* pComponent = new ConcreateComponent(); 　　　 // 采用这个Component对象去初始化一个Decorator对象, 　　　 // 这样就可以为这个Component对象动态添加职责 　　　 Decorator* pDecorator = new ConcreateDecorator(pComponent); 　　　 pDecorator->Operation(); 　　　 delete pDecorator; 　　　 system(\"pause\"); 　　　 return 0; }","title":"设计模式的解析和实现(C++)之九-Decorator模式"}]